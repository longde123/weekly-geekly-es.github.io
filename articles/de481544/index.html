<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗺️ 💢 👋🏾 Verwenden eines neuronalen Faltungsnetzwerks zum Spielen von Life (auf Keras) 🛫 ♋️ 🏝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Zweck dieses Artikels ist es, dem neuronalen Netzwerk beizubringen, das Life-Spiel zu spielen, ohne ihm die Spielregeln beizubringen. 


 Hallo ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden eines neuronalen Faltungsnetzwerks zum Spielen von Life (auf Keras)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481544/"><p><img src="https://habrastorage.org/getpro/habr/post_images/6e6/011/288/6e6011288fb72573558a3cebf6008a15.png"></p><br><p>  Der Zweck dieses Artikels ist es, dem neuronalen Netzwerk beizubringen, das Life-Spiel zu spielen, ohne ihm die Spielregeln beizubringen. </p><br><p>  Hallo habr  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://kylewbanks.com/blog/conways-game-of-life-convolutional-neural-network-keras" rel="nofollow">"Conways Spiel des Lebens mit Keras mithilfe eines neuronalen Faltungsnetzwerks"</a> von kylewbanks. </p><a name="habracut"></a><br><p>  Wenn Sie mit dem Spiel "Life" ( <em>ein vom englischen Mathematiker John Conway 1970 erfundener Zellularautomat)</em> nicht vertraut sind, gelten folgende Regeln. </p><br><p>  Das Spieluniversum ist ein unendliches, zweidimensionales Gitter aus quadratischen Zellen, von denen sich jede in einem von zwei möglichen Zuständen befindet: lebend oder tot (oder bewohnt bzw. unbewohnt).  Jede Zelle interagiert horizontal, vertikal oder diagonal mit ihren acht Nachbarn.  Zu jedem Zeitschritt treten die folgenden Übergänge auf: </p><br><ul><li>  Jede lebende Zelle mit weniger als zwei lebenden Nachbarn stirbt. </li><li>  Jede lebende Zelle mit zwei oder drei lebenden Nachbarn überlebt bis zur nächsten Generation. </li><li>  Jede lebende Zelle mit mehr als drei lebenden Nachbarn stirbt. </li><li>  Jede tote Zelle mit genau drei lebenden Nachbarn wird zu einer lebenden Zelle. </li></ul><br><p>  Die erste Generation wird durch gleichzeitiges Anwenden der oben genannten Regeln auf jede Zelle im Ausgangszustand erstellt. Geburt und Tod erfolgen gleichzeitig zu bestimmten Zeitpunkten.  Jede Generation ist eine reine Funktion der vorherigen.  Die Regeln gelten weiterhin für die neue Generation, um die nächste Generation zu erstellen. </p><br><p>  Siehe <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B3%25D1%2580%25D0%25B0_%25C2%25AB%25D0%2596%25D0%25B8%25D0%25B7%25D0%25BD%25D1%258C%25C2%25BB" rel="nofollow">Wikipedia für</a> Details. </p><br><p>  Warum das machen?  Hauptsächlich zur Unterhaltung und um ein wenig über Faltungs-Neuronale Netze zu lernen. </p><br><p>  Also ... </p><br><h1 id="igrovaya-logika">  Spiellogik </h1><br><p>  Als Erstes müssen Sie eine Funktion definieren, die das Spielfeld als Eingabe verwendet und den nächsten Status zurückgibt. </p><br><p>  Glücklicherweise stehen im Internet viele Implementierungen zur Verfügung, z. <a href="https://jakevdp.github.io/blog/2013/08/07/conways-game-of-life/" rel="nofollow">B</a> .: <a href="https://jakevdp.github.io/blog/2013/08/07/conways-game-of-life/" rel="nofollow">https://jakevdp.github.io/blog/2013/08/07/conways-game-of-life/</a> . </p><br><p>  Tatsächlich wird die Matrix des Spielfelds als Eingabe verwendet, wobei 0 eine tote Zelle darstellt und 1 eine lebende Zelle darstellt und eine Matrix derselben Größe zurückgibt, die jedoch den Status jeder Zelle bei der nächsten Iteration des Spiels enthält. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">life_step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X)</span></span></span><span class="hljs-function">:</span></span> live_neighbors = sum(np.roll(np.roll(X, i, <span class="hljs-number"><span class="hljs-number">0</span></span>), j, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> j != <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (live_neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) | (X &amp; (live_neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span>)).astype(int)</code> </pre> <br><h1 id="generaciya-igrovogo-polya">  Spielfeldgenerierung </h1><br><p>  Nach der Spielelogik brauchen wir eine Möglichkeit, Spielfelder nach dem Zufallsprinzip zu generieren und sie zu visualisieren. </p><br><p>  Die Funktion <code>generate_frames</code> erstellt <code>num_frames</code> zufälligen Spielfeldern mit einer bestimmten Form und einer festgelegten Wahrscheinlichkeit, dass jede Zelle "live" ist, und <code>render_frames</code> zeichnet zum Vergleich Darstellungen von Bildern zweier Spielfelder nebeneinander (lebende Zellen sind weiß und tote Zellen sind schwarz): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_frames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num_frames, board_shape=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">,</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span><span class="hljs-function"><span class="hljs-params">, prob_alive=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.15</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.array([ np.random.choice([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>], size=board_shape, p=[<span class="hljs-number"><span class="hljs-number">1</span></span>-prob_alive, prob_alive]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(num_frames) ]).astype(int) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_frames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(frame1, frame2)</span></span></span><span class="hljs-function">:</span></span> plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) plt.imshow(frame1.flatten().reshape(board_shape), cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) plt.subplot(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) plt.imshow(frame2.flatten().reshape(board_shape), cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><p>  Mal sehen, wie diese Felder aussehen: </p><br><pre> <code class="python hljs">board_shape = (<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) board_size = board_shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] * board_shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] probability_alive = <span class="hljs-number"><span class="hljs-number">0.15</span></span> frames = generate_frames(<span class="hljs-number"><span class="hljs-number">10</span></span>, board_shape=board_shape, prob_alive=probability_alive) print(frames.shape) <span class="hljs-comment"><span class="hljs-comment"># (num_frames, board_w, board_h)</span></span></code> </pre> <br><pre> <code class="plaintext hljs">(10, 20, 20)</code> </pre> <br><pre> <code class="python hljs">print(frames[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre> <br><pre> <code class="plaintext hljs">[[0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0]])</code> </pre> <br><p>  Als nächstes wird eine ganzzahlige Darstellung des Spielfelds aufgenommen und als Bild angezeigt. <br>  Der folgende Zustand des Spielfelds wird auch rechts mit der Funktion <code>life_step</code> : </p><br><pre> <code class="python hljs">ender_frames(frames[<span class="hljs-number"><span class="hljs-number">1</span></span>], life_step(frames[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/cf0/80f/cca/cf080fcca9b99fbad53e00abad7299a8.png"></p><br><h1 id="postroenie-obuchayuschego-i-testovogo-naborov">  Erstellen von Trainings- und Test-Sets </h1><br><p>  Jetzt können wir Daten für Schulungen, Überprüfungen und Tests generieren. </p><br><p>  Jedes Element in den <code>y_test</code> <code>y_train</code> / <code>y_val</code> / <code>y_test</code> repräsentiert das nächste Spielfeld für jeden <code>X_train</code> in <code>X_train</code> / <code>X_val</code> / <code>X_test</code> . </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reshape_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.reshape(X.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], X.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], X.shape[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_dataset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num_frames, board_shape, prob_alive)</span></span></span><span class="hljs-function">:</span></span> X = generate_frames(num_frames, board_shape=board_shape, prob_alive=prob_alive) X = reshape_input(X) y = np.array([ life_step(frame) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> frame <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X ]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X, y train_size = <span class="hljs-number"><span class="hljs-number">70000</span></span> val_size = <span class="hljs-number"><span class="hljs-number">10000</span></span> test_size = <span class="hljs-number"><span class="hljs-number">20000</span></span></code> </pre> <br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Training Set:"</span></span>) X_train, y_train = generate_dataset(train_size, board_shape, probability_alive) print(X_train.shape) print(y_train.shape)</code> </pre> <br><pre> <code class="plaintext hljs">Training Set: (70000, 20, 20, 1) (70000, 20, 20, 1)</code> </pre> <br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Validation Set:"</span></span>) X_val, y_val = generate_dataset(val_size, board_shape, probability_alive) print(X_val.shape) print(y_val.shape)</code> </pre> <br><pre> <code class="plaintext hljs">Validation Set: (10000, 20, 20, 1) (10000, 20, 20, 1)</code> </pre> <br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"Test Set:"</span></span>) X_test, y_test = generate_dataset(test_size, board_shape, probability_alive) print(X_test.shape) print(y_test.shape)</code> </pre> <br><pre> <code class="plaintext hljs">Test Set: (20000, 20, 20, 1) (20000, 20, 20, 1)</code> </pre> <br><h1 id="postroenie-svertochnoy-neyronnoy-seti">  Faltungsneuraler Netzwerkaufbau </h1><br><p>  Jetzt können wir den ersten Schritt zum Aufbau eines Faltungsnetzwerks mit Keras machen.  Der entscheidende Punkt hierbei ist die Kernelgröße (3, 3) und Schritt 1. Sie weisen CNN an, eine 3 × 3-Matrix von umgebenden Zellen für jede Zelle in dem Feld zu verwenden, das sie betrachtet, einschließlich der aktuellen Zelle. </p><br><p>  Wenn zum Beispiel das Folgende ein Spielfeld wäre und wir uns in der mittleren Zelle <code>x</code> , würde sie alle mit einem Ausrufezeichen markierten Zellen ansehen <code>!</code>  und Zelle <code></code> .  Dann bewegt sich das Netzwerk entlang der Zelle nach rechts und macht dasselbe und wiederholt es immer wieder, bis es jede Zelle und ihre Nachbarn im gesamten Feld verarbeitet. </p><br><pre> <code class="plaintext hljs">0 0 0 0 0 0! ! ! 0 0! x ! 0 0! ! ! 0 0 0 0 0 0</code> </pre> <br><p>  Der Rest des Netzwerks ist ziemlich einfach, daher werde ich nicht auf Details eingehen.  Wenn Sie an etwas interessiert sind, empfehle ich, die Dokumentation zu lesen. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sequential <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dense, Dropout, Activation, Conv2D, MaxPool2D <span class="hljs-comment"><span class="hljs-comment"># CNN Properties filters = 50 kernel_size = (3, 3) # look at all 8 neighboring cells, plus itself strides = 1 hidden_dims = 100 model = Sequential() model.add(Conv2D( filters, kernel_size, padding='same', activation='relu', strides=strides, input_shape=(board_shape[0], board_shape[1], 1) )) model.add(Dense(hidden_dims)) model.add(Dense(1)) model.add(Activation('sigmoid')) model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])</span></span></code> </pre> <br><p>  Schauen Sie sich die Ausgabe der <code>summary</code> Funktion an: </p><br><pre> <code class="python hljs">model.summary()</code> </pre> <br><pre> <code class="plaintext hljs">_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_9 (Conv2D) (None, 20, 20, 50) 500 _________________________________________________________________ dense_17 (Dense) (None, 20, 20, 100) 5100 _________________________________________________________________ dense_18 (Dense) (None, 20, 20, 1) 101 _________________________________________________________________ activation_9 (Activation) (None, 20, 20, 1) 0 ================================================================= Total params: 5,701 Trainable params: 5,701 Non-trainable params: 0 _________________________________________________________________</code> </pre> <br><h1 id="obuchenie-i-sohranenie-modeli">  Ein Modell trainieren und speichern </h1><br><p>  Nachdem Sie CNN erstellt haben, trainieren Sie das Modell und speichern es auf der Festplatte: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, X_train, y_train, X_val, y_val, batch_size=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">50</span></span></span></span><span class="hljs-function"><span class="hljs-params">, epochs=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, filename_suffix=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> model.fit( X_train, y_train, batch_size=batch_size, epochs=epochs, validation_data=(X_val, y_val) ) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'cgol_cnn{}.json'</span></span>.format(filename_suffix), <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> file: file.write(model.to_json()) model.save_weights(<span class="hljs-string"><span class="hljs-string">'cgol_cnn{}.h5'</span></span>.format(filename_suffix)) train(model, X_train, y_train, X_val, y_val, filename_suffix=<span class="hljs-string"><span class="hljs-string">'_basic'</span></span>)</code> </pre> <br><pre> <code class="plaintext hljs">Train on 70000 samples, validate on 10000 samples Epoch 1/2 70000/70000 [==============================] - 27s 388us/step - loss: 0.1324 - acc: 0.9651 - val_loss: 0.0833 - val_acc: 0.9815 Epoch 2/2 70000/70000 [==============================] - 27s 383us/step - loss: 0.0819 - acc: 0.9817 - val_loss: 0.0823 - val_acc: 0.9816</code> </pre> <br><p>  Dieses Modell bietet eine Genauigkeit von etwas mehr als 98% für Trainings- und Testsätze, was für den ersten Durchgang sehr gut ist.  Versuchen wir herauszufinden, wo wir Fehler machen. </p><br><h1 id="probuem">  Versuchen Sie es </h1><br><p>  Schauen wir uns die Vorhersage für ein zufälliges Spielfeld an und wie es funktioniert.  Erstellen Sie zunächst ein Spielfeld und schauen Sie sich das richtige nächste Bild an: </p><br><pre> <code class="python hljs">X, y = generate_dataset(<span class="hljs-number"><span class="hljs-number">1</span></span>, board_shape=board_shape, prob_alive=probability_alive) render_frames(X[<span class="hljs-number"><span class="hljs-number">0</span></span>].flatten().reshape(board_shape), y)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/b46/554/cee/b46554cee0c2fe745dc741cc54377b84.png"></p><br><p>  Als nächstes machen wir die Vorhersage und sehen, wie viele Zellen falsch vorhergesagt wurden: </p><br><pre> <code class="python hljs">pred = model.predict_classes(X) print(np.count_nonzero(pred.flatten() - y.flatten()), <span class="hljs-string"><span class="hljs-string">"incorrect cells."</span></span>)</code> </pre> <br><pre> <code class="plaintext hljs">4 incorrect cells.</code> </pre> <br><p>  Als nächstes vergleichen wir den richtigen nächsten Schritt mit dem vorhergesagten Schritt: </p><br><pre> <code class="python hljs">render_frames(y, pred.flatten().reshape(board_shape))</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/f66/eb1/91ff66eb1a2ec723621b3f49c1d34b84.png"></p><br><p>  Es ist nicht beängstigend, aber sehen Sie, wo die Vorhersage fehlgeschlagen ist?  Es scheint, dass das Netzwerk keine Zellen an den Rändern des Spielfelds vorhersagen kann.  Schauen wir uns an, wo Werte ungleich Null auf falsche Vorhersagen hinweisen: </p><br><pre> <code class="python hljs">print(pred.flatten().reshape(board_shape) - y.flatten().reshape(board_shape))</code> </pre> <br><pre> <code class="plaintext hljs">[[ 0 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 -1 -1 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] [ 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0]]</code> </pre> <br><p>  Wie Sie sehen, befinden sich alle Nicht-Null-Werte an den Rändern des Spielfelds.  Schauen wir uns die vollständige Testsuite an und bestätigen Sie, dass diese Beobachtung wahr ist. </p><br><h1 id="prosmotr-oshibok-ispolzuya-testovyy-nabor">  Zeigen Sie Fehler in der Testsuite an </h1><br><p>  Wir werden eine Funktion schreiben, die eine Heatmap anzeigt, die zeigt, wo das Modell Fehler macht, und sie mit der gesamten Testsuite aufrufen: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_prediction_errors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, X, y)</span></span></span><span class="hljs-function">:</span></span> y_pred = model.predict_classes(X) sum_y_pred = np.sum(y_pred, axis=<span class="hljs-number"><span class="hljs-number">0</span></span>).flatten().reshape(board_shape) sum_y = np.sum(y, axis=<span class="hljs-number"><span class="hljs-number">0</span></span>).flatten().reshape(board_shape) plt.imshow(sum_y_pred - sum_y, cmap=<span class="hljs-string"><span class="hljs-string">'hot'</span></span>, interpolation=<span class="hljs-string"><span class="hljs-string">'nearest'</span></span>) plt.show() view_prediction_errors(model, X_test, y_test)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/56a/177/360/56a17736048c4f2b817b8aca5615e6cb.png"></p><br><p>  Alle Fehler an den Kanten und Ecken.  Das ist logisch, da CNN sich nicht umsehen kann, aber die Logik des Spiels in <code>life_step</code> tut dies.  Betrachten Sie beispielsweise Folgendes.  Betrachtet man die Randzelle <code>x</code> unten, sieht CNN nur <code>x</code> und <code>!</code>  Zellen: </p><br><pre> <code class="plaintext hljs">0 0 0 0 0 ! ! 0 0 0 x ! 0 0 0 ! ! 0 0 0 0 0 0 0 0</code> </pre> <br><p>  Aber was wir wirklich wollen und was <code>life_step</code> tut, ist, die Zellen von der anderen Seite zu betrachten: </p><br><pre> <code class="plaintext hljs">0 0 0 0 0 ! ! 0 0 ! x ! 0 0 ! ! ! 0 0 ! 0 0 0 0 0</code> </pre> <br><p>  Eine ähnliche Situation in den Ecken: </p><br><pre> <code class="plaintext hljs">x ! 0 0 ! ! ! 0 0 ! 0 0 0 0 0 0 0 0 0 0 ! 0 0 0 !</code> </pre> <br><p>  Um dies zu beheben, muss <code>Conv2D</code> irgendwie auf die gegenüberliegende Seite des Spielfelds schauen.  Alternativ kann jedes Eingabefeld vorverarbeitet werden, um die Kanten auf der gegenüberliegenden Seite auszufüllen, und Conv2D kann dann einfach die erste oder letzte Spalte und Zeile löschen.  Da wir Keras und der darin enthaltenen Füllfunktionalität ausgeliefert sind, die nicht das unterstützen, wonach wir suchen, müssen wir auf das Hinzufügen unserer eigenen Füllung zurückgreifen. </p><br><h1 id="ispravlenie-kraevyh-defektov-s-pomoschyu-zapolneniya">  Korrektur von Kantendefekten durch Füllung </h1><br><p>  Wir müssen jedes Spielfeld mit einem entgegengesetzten Wert ergänzen, um nachzuahmen, wie <code>life_step</code> für <code>life_step</code> funktioniert.  Wir können hierfür <code>np.pad</code> mit <code>mode = 'wrap'</code> .  Betrachten Sie beispielsweise das folgende Array und die erweiterte Ausgabe: </p><br><pre> <code class="python hljs">x = np.array([ [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] ]) print(np.pad(x, (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), mode=<span class="hljs-string"><span class="hljs-string">'wrap'</span></span>))</code> </pre> <br><pre> <code class="plaintext hljs">[[9, 7, 8, 9, 7], [3, 1, 2, 3, 1], [6, 4, 5, 6, 4], [9, 7, 8, 9, 7], [3, 1, 2, 3, 1]]</code> </pre> <br><p>  Beachten Sie, dass die erste Spalte / Zeile und die letzte Spalte / Zeile die entgegengesetzte Seite der ursprünglichen Matrix widerspiegeln und die mittlere 3x3-Matrix der ursprüngliche <code>x</code> Wert ist.  Zum Beispiel wurde Zelle [1] [1] auf der gegenüberliegenden Seite in Zelle [4] [1] kopiert und enthält ähnlich wie [0] [1] [3] [1].  In alle Richtungen und sogar in Ecken wurde das Array so korrigiert, dass es die gegenüberliegende Seite enthielt.  Auf diese Weise kann CNN das gesamte Spielfeld überprüfen und Extremfälle korrekt behandeln. </p><br><p>  Jetzt können wir eine Funktion schreiben, um alle unsere Eingabematrizen zu füllen: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pad_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reshape_input(np.array([ np.pad(x.reshape(board_shape), (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), mode=<span class="hljs-string"><span class="hljs-string">'wrap'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X ])) X_train_padded = pad_input(X_train) X_val_padded = pad_input(X_val) X_test_padded = pad_input(X_test) print(X_train_padded.shape) print(X_val_padded.shape) print(X_test_padded.shape)</code> </pre> <br><pre> <code class="plaintext hljs">(70000, 22, 22, 1) (10000, 22, 22, 1) (20000, 22, 22, 1)</code> </pre> <br><p>  Alle Datensätze werden jetzt durch umbrochene Spalten / Zeilen ergänzt, <code>life_step</code> CNN wie <code>life_step</code> die gegenüberliegende Seite des Spielfelds sehen kann.  Aus diesem Grund hat jedes Spielfeld jetzt eine Größe von 22 x 22 anstelle der ursprünglichen 20 x 20. </p><br><p>  Dann sollte CNN neu aufgebaut werden, um das Auffüllen mit <code>padding = 'valid'</code> zu verwerfen (was Conv2D anweist, Kanten zu verwerfen, obwohl dies nicht sofort offensichtlich ist), und mit der neuen <code>input_shape</code> .  Wenn wir also Spielfelder mit einer Größe von 22x22 überspringen, erhalten wir immer noch eine Größe von 20x20 als Ausgabe, da wir die erste und letzte Spalte / Zeile verwerfen.  Der Rest bleibt identisch: </p><br><pre> <code class="python hljs">model_padded = Sequential() model_padded.add(Conv2D( filters, kernel_size, padding=<span class="hljs-string"><span class="hljs-string">'valid'</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, strides=strides, input_shape=(board_shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">2</span></span>, board_shape[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) )) model_padded.add(Dense(hidden_dims)) model_padded.add(Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>)) model_padded.add(Activation(<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>)) model_padded.compile(loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, optimizer=<span class="hljs-string"><span class="hljs-string">'adam'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>]) model_padded.summary()</code> </pre> <br><pre> <code class="plaintext hljs">_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_10 (Conv2D) (None, 20, 20, 50) 500 _________________________________________________________________ dense_19 (Dense) (None, 20, 20, 100) 5100 _________________________________________________________________ dense_20 (Dense) (None, 20, 20, 1) 101 _________________________________________________________________ activation_10 (Activation) (None, 20, 20, 1) 0 ================================================================= Total params: 5,701 Trainable params: 5,701 Non-trainable params: 0 _________________________________________________________________</code> </pre> <br><p>  Jetzt können wir mit dem ausgerichteten Feld lernen: </p><br><pre> <code class="plaintext hljs">train( model_padded, X_train_padded, y_train, X_val_padded, y_val, filename_suffix='_padded' )</code> </pre> <br><pre> <code class="plaintext hljs">Train on 70000 samples, validate on 10000 samples Epoch 1/2 70000/70000 [==============================] - 27s 389us/step - loss: 0.0604 - acc: 0.9807 - val_loss: 4.5475e-04 - val_acc: 1.0000 Epoch 2/2 70000/70000 [==============================] - 27s 382us/step - loss: 1.7058e-04 - acc: 1.0000 - val_loss: 5.9932e-05 - val_acc: 1.0000</code> </pre> <br><p>  Die Genauigkeit der Vorhersage liegt zwischen 98% und 100%, die wir vor dem Hinzufügen der Einrückung erhalten haben.  Schauen wir uns den Fehler im Testfall an: </p><br><pre> <code class="python hljs">view_prediction_errors(model_padded, X_test_padded, y_test)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/0cb/98e/b36/0cb98eb36fe336df53afab15ed8209ab.png"></p><br><p>  Großartig!  Die schwarze Heatmap zeigt an, dass es keine Unterschiede in den Werten gibt. Dies bedeutet, dass wir jede Zelle für jedes Spiel erfolgreich vorhergesagt haben. </p><br><p>  Es war eine lustige kleine Übung, mit Faltungsnetzwerken zu spielen, ohne einen großen Datensatz zu verwenden.  <a href="https://github.com/KyleBanks/conways-gol-cnn" rel="nofollow">Fühlen Sie sich frei, sich bei GitHub umzusehen</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481544/">https://habr.com/ru/post/de481544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481534/index.html">Stirbt Delphi - Falsch</a></li>
<li><a href="../de481536/index.html">Die Geschichte des Domain Name Systems: "Krieg" -Protokolle</a></li>
<li><a href="../de481538/index.html">20 SEO-Mythen, die 2020 sterben werden</a></li>
<li><a href="../de481540/index.html">OpenGLESv2-Texturen über DMABUF neu laden</a></li>
<li><a href="../de481542/index.html">Überprüfung von digitalen Schaltkreisen. Rückblick</a></li>
<li><a href="../de481546/index.html">Die Geschichte des Mikroprozessors und des Personalcomputers: 1947-1974</a></li>
<li><a href="../de481548/index.html">Symbol.iterator in Javascript</a></li>
<li><a href="../de481550/index.html">Inmarsat: Empfang und Dekodierung eines Satellitensignals zu Hause</a></li>
<li><a href="../de481552/index.html">PGConf.Russia 2020 erscheint in Kürze</a></li>
<li><a href="../de481554/index.html">Wie gehe ich durch den Online-Master of Science in Informatik, und für wen passt dies möglicherweise nicht?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>