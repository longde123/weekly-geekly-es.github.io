<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏼 ✔️ 🚾 我们如何使用ManageIQ在银行基础设施中结识朋友 👦🏽 🧑🏿‍🤝‍🧑🏾 🔗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几年前，主要趋势是自动化，DevOps实践和加速向市场交付价值。 Home Credit Bank决定继续前进，并继续进行技术开发，以免用户厌烦等待几天以等待其重要项目的新资源而在低声中大声疾呼。 


 我们决定从部门批准申请开始，与许多大公司一样，这需要时间和精力。 作为第一个任务，我们选择创建...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们如何使用ManageIQ在银行基础设施中结识朋友</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/homecredit/blog/461891/"><p> 几年前，主要趋势是自动化，DevOps实践和加速向市场交付价值。  Home Credit Bank决定继续前进，并继续进行技术开发，以免用户厌烦等待几天以等待其重要项目的新资源而在低声中大声疾呼。 </p><br><p> 我们决定从部门批准申请开始，与许多大公司一样，这需要时间和精力。 作为第一个任务，我们选择创建虚拟机的过程，而不管虚拟化环境如何。 通过列出任务清单，我们意识到有必要与银行基础设施中使用的其他系统集成，例如通过API。 </p><br><p><img src="https://habrastorage.org/webt/tt/h7/br/tth7br6euodgo1dklwgmaqhdxu4.png" alt="图片"></p><a name="habracut"></a><br><p>最合适的解决方案是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ManageIQ</a> 。 这是Red Hat在2012年收购的一个项目，并在此项目的基础上创建了商业<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Red Hat CloudForms产品</a> 。 同时，ManageIQ仍处于开源产品状态，并且正在与CloudForms并行开发。 </p><br><p>  ManageIQ用Ruby编写，并支持许多不同的虚拟化，公共云和容器化提供程序。 目前，我们正在Home的High-Availability配置中使用Gaprindashvili版本。 </p><br><h2> 流程如何变化 </h2><br><p> 以前，每个团队都需要在其职责范围内进行单独的设置。 在进行初步准备之后，所有数据都被收集并发送给管理员，该管理员部署并配置了虚拟机。 然后，有必要告知（例如）监视团队新的主机已出现，需要将其添加到监视中。 沟通中的延迟，专家的工作量，人为因素造成的错误可能会使此过程延长几天。 </p><br><p> 将整个过程放入ManageIQ，我们得到了以下结果： </p><br><div class="scrollable-table"><table><thead><tr><th> 虚拟资源类型 </th><th> 在介绍ManageIQ之前 </th><th> 实施ManageIQ之后 </th></tr></thead><tbody><tr><td>  VMware / oVirt中的Linux虚拟机 </td><td> 到一个 </td><td>  〜10分钟 </td></tr><tr><td>  Rancher虚拟机环境 </td><td> 工作中 </td><td>  〜15分钟 </td></tr><tr><td>  VMware中的Windows虚拟机 </td><td> 周 </td><td>  〜25分钟 </td></tr></tbody></table></div><br><p> 之所以存在时间差异，是因为在第二种情况下，需要额外的时间来准备要与Docker一起使用的主机，从Artifactory下载并集成基础架构容器的映像，因为在此阶段，仍然无法访问Docker Hub。 在Windows的情况下，实现差异的原因是，首先，未经定制的Linux VM的创建时间约为2分钟，而Windows VM的创建时间约为6分钟。 其次，自定义Windows本身大约需要10分钟，而Linux则需要2分钟。 </p><br><p> 考虑到直接在创建VM的过程中花费了大约2-3分钟，所以10分钟并不是那么快。 在剩余的时间里，ManageIQ设法执行以下操作： </p><br><ol><li> 系统以订单形式收集用户指定的参数，并将其分解为变量。 </li><li> 在事件管理系统中创建了一个新的变更请求，该请求显示有关新资源的数据。 </li><li>  ManageIQ资源名称查询系统发送新资源的值。 </li><li>  IP地址管理系统根据输入的参数发布新地址。 </li><li> 新的DNS记录在本地DNS服务器上注册。 </li><li> 根据参数，环境和资源负载，选择虚拟化的类型和要放置的群集。 </li><li> 接下来，是使用指定参数创建虚拟机的过程。 </li><li> 从模板部署虚拟机时，您需要运行将进行最终设置的脚本： <br><ul><li> 磁盘扩展到指定大小， </li><li> 生成新的root密码，在Linux主机上对其进行更改并写入密码管理器， </li><li> 在GitLab中为Puppet创建配置YAML文件， </li><li> 运行为Windows VM带来必要设置和更新的运行手册，或者 </li><li> 启动Puppet，它将更新和配置Linux机器。 </li></ul></li><li> 所有这些之后，将关闭在步骤2中创建的更改请求。 新数据将添加到其中，例如IP地址和主机名。 </li><li> 在计算资源管理库（CMDB）中注册了一个新单位。 </li><li> 虚拟机已在Zabbix中注册，并已添加到监视中。 </li><li> 客户和其他有关方面会收到一封电子邮件，其中包含有关使用ManageIQ创建的新设备的信息。 </li></ol><br><h2 id="chto-vnutri"> 里面有什么 </h2><br><p> 让我们深入研究产品的技术细节。 默认情况下，ManageIQ可以从模板创建虚拟机。 这与我们在vCenter中所做的有何不同？ 正确的答案是什么。  ManageIQ使用与虚拟化系统相同的方法，但是只在一个地方进行。 除此之外，您可以添加自己的脚本，这些脚本不适合标准功能集。 因此，如果您拥有资源（例如，在公共Azure中，在vCenter中部署在您自己的硬件上），并且Kubernetes群集正在其他地方旋转，那么可以通过ManageIQ方便地管理所有这些资源。 </p><br><p> 除了各种各样的集成提供程序之外，ManageIQ还提供了方便的自定义工具。 例如，这可以创建方便的表单来解决您的问题： </p><br><p><img src="https://habrastorage.org/webt/ku/7y/l3/ku7yl3xi9trq-9wndv-ad_vlpvu.png"></p><br><p> 因此，可以构建一个完整的接口来订购虚拟机，并将所有必需的参数放入其中： </p><br><p><img src="https://habrastorage.org/webt/v7/ey/tf/v7eytf_hbcxxjcpw4hvrzuwyzve.png"></p><br><p> 我们选择操作系统的计算资源量，并填写与外部系统集成所需的所有其他信息。 此外，使用内部机制（稍后介绍），系统选择放置新资源的位置：根据输入的所有参数和加载资源来选择数据中心，集群，主机和数据存储。 </p><br><p> 不要忘记，人们可以订购太多资源，或者根本无法订购他们真正需要的资源。 请求和确认系统在这里起作用： </p><br><p><img src="https://habrastorage.org/webt/mj/yv/28/mjyv28hsy0ggf6t68jjdkgc8mwc.png"></p><br><p> 用户订购的任何资源必须经过负责人的批准。 在Home中，一群建筑师这样做。 </p><br><h2 id="struktura-avtomatizacii"> 自动化结构 </h2><br><p> 如果将ManageIQ中的所有自动化过程分解为小部分，则会注意到一定的结构。 </p><br><h3 id="automate-domain"> 自动域 </h3><br><img align="right" src="https://habrastorage.org/webt/xy/ea/c_/xyeac_nx3if-e4txuiuriic4h0w.png"><br><p> 数据存储托管ManageIQ拥有的所有域。 </p><br><p> 默认情况下，有一个ManageIQ域，该域是锁定的，类似于参考模型。 如果需要进行更改，则会创建另一个域，将ManageIQ域中的元素复制并更改到您自己的任务中。 </p><br><h3 id="automate-namespace"> 自动命名空间 </h3><br><img align="right" src="https://habrastorage.org/webt/yf/e1/t3/yfe1t3kjxb4rhvenndkfkwtsad4.png"><br><p> 在内部，域分为负责各个流程的部分：这可以是负责管理基础结构（基础结构）或使用服务（服务）的部分。 我们有自己的命名空间，其中包含与银行系统有关的所有内容。 </p><br><p> 以新虚拟机的供应过程为例，更详细地考虑该结构。 在名为<em>VMProvision_VM</em>的自动化类中进行了描述。 </p><br><h3 id="automate-class"> 自动化课程 </h3><br><p> 该类的结构包括<strong>Instances</strong> ， <strong>Methods</strong> ， <strong>Properties</strong>和<strong>Schema</strong> 。 从自动化的角度来看，最感兴趣的是Schema： <br><img src="https://habrastorage.org/webt/vm/jt/lf/vmjtlfd9qpyrqpdpemtxfw2yczs.png"></p><br><p> 布局类似于CI / CD系统中的管道。 它描述了将在自动化过程中执行的步骤。 </p><br><h3 id="automate-instance"> 自动化实例 </h3><br><img align="right" src="https://habrastorage.org/webt/ie/wj/fj/iewjfjuzq9rplkcszwsh7wemsqu.png"><br><p> 上面描述的类有两个自动实例。 它们每个都从电路继承为其设置了<em>默认值</em>的阶段。 实例中描述了具有空值的阶段。 </p><br><p><img src="https://habrastorage.org/webt/wy/sl/5c/wysl5c2zze_9_sfplsnykplbf_m.png"></p><br><p> 在实例中，在模式描述中显示为空的步骤的值。 您还可以查看进行最后更改的人员和时间。 </p><br><p> 让我们看看其中一个Value值表示： <br><img src="https://habrastorage.org/webt/rd/j_/v7/rdj_v7hc3wgt7dty2zckjltiacg.png"></p><br><p> 这是一个称为方法的自动化类，它具有一个自动化实例。 其图描述了<em>ipam_base_uri</em>属性和<em>execute</em>方法。 相应地，execute方法调用Automate方法<em>acquisition_ip</em> 。 </p><br><h3 id="automate-method"> 自动化方法 </h3><br><p> 这是一个Ruby脚本，允许虚拟机通过REST API与其他系统进行通信。 例如，与IPAM地址空间管理系统一样。 在IPAM中，我们获取虚拟机的地址，掩码，子网和VLAN。 困难之处在于，该机器可以部署在测试环境中或用于应用程序或数据库的生产环境中。 或者，安全服务可能决定将其放入PCI-DSS循环中。 所有这些信息都是在创建VM的阶段收集的，或者在被调用实例的参数中传输的（在上面的屏幕快照中，您可以看到该参数包含该方法将访问IPAM的uri）： </p><br><div class="spoiler">  <b class="spoiler_title">这是一些Ruby代码</b> <div class="spoiler_text"><pre><code class="ruby hljs">base_uri = $evm.object[<span class="hljs-string"><span class="hljs-string">'ipam_base_uri'</span></span>] prov = $evm.root[<span class="hljs-string"><span class="hljs-string">"miq_provision"</span></span>] site = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:site</span></span>) app = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_dropdown_list_information_system</span></span>) crq = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:crq</span></span>) descr = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_textarea_box_usernotes</span></span>) owner = $evm.root[<span class="hljs-string"><span class="hljs-string">'user'</span></span>].name scope = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:dialog_dropdown_scope</span></span>) environment = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:landscape</span></span>)</code> </pre> <br><p>  <em>$ evm.root</em>是一种返回可以存储在ManageIQ中的所有内容的方法。 这可以是有关用户，环境，变量，当前请求（“ miq_request”）等的信息。 我们对当前的提供流程感兴趣。 <br><img src="https://habrastorage.org/webt/4m/hz/lm/4mhzlmb6p_lvkagsl7apu41mpdm.png"></p><br><p> 接下来，我们可以选择必要的值： <em>get_option（：site）</em>选择在先前阶段之一中传输的值，例如， <em>get_option（：dialog_dropdown_list_information_system）</em>从用户在订购新资源时填写的表格中选择。 <br> 所有接收到的值都是通过请求主体中的变量以JSON格式传输的： </p><br><pre> <code class="ruby hljs">options = { <span class="hljs-symbol"><span class="hljs-symbol">verify:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">body:</span></span> { <span class="hljs-string"><span class="hljs-string">"site"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{site}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"env"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{env}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"app"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{app}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"scope"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{scope}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"role"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{role}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"crq"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{crq}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"descr"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{descr}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"owner"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{owner}</span></span></span><span class="hljs-string">"</span></span>, }.to_json, }</code> </pre> <br><p> 使用这组参数，IPAM会明确确定虚拟机应位于哪个VLAN中，并将返回网络参数。 </p></div></div><br><p> 除了为正确的VM配置接收数据外，ManageIQ还可以生成其他信息，以便在所谓的后置供应阶段（在部署和启动虚拟机之后）进行一些设置。 在Home中，我们使用Puppet来管理Linux主机配置。 对于每个计算单元，在YAML中使用一组组创建GAML文件： </p><br><div class="spoiler">  <b class="spoiler_title">一些其他的Ruby代码</b> <div class="spoiler_text"><pre> <code class="ruby hljs">options = { <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Private-Token"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{api_token}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, } body = { <span class="hljs-string"><span class="hljs-string">"branch"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{branch}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"author_email"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"email@your.domain"</span></span>, <span class="hljs-string"><span class="hljs-string">"author_name"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ManageIQ Bot"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"commit_message"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"New host created by ManageIQ"</span></span>, } descr = prov.get_option(<span class="hljs-symbol"><span class="hljs-symbol">:long_description</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) &amp;&amp; descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - rancher\n - user-devops-UDCR"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - rancher\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> descr.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(<span class="hljs-string"><span class="hljs-string">'rancher'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> body[<span class="hljs-symbol"><span class="hljs-symbol">:content</span></span>] = <span class="hljs-string"><span class="hljs-string">"---\ngroups:\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{yaml_server}</span></span></span><span class="hljs-string">\n - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$is_id}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p> 组取决于虚拟机的类型，在其中创建虚拟机的环境以及信息系统。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1i/hv/ig/1ihvigmykpbqlihq2l8oturxxk0.png"></div><br><p> 成功完成该过程后，用户会收到一封包含以下信息的电子邮件： <br><img src="https://habrastorage.org/webt/qf/j-/br/qfj-brpfqe1ukkcvrw_jdtdpigm.png"></p><br><p> 信件的文本也可以通过添加必要的信息进行调整。 <br> 如果在流程的任何关键阶段发生错误，则可以添加一个条件，明确指出该流程应被中断。 如果该错误没有致命的后果，则尽管存在问题，也请指出可以继续执行的操作。 </p><br><h2 id="logirovanie"> 记录中 </h2><br><p>  ManageIQ写入所有可以跟踪的日志。 自动化过程写在automation.log中。 此外，还有API日志，各种云提供程序，安全日志，甚至记录了top命令的输出。 </p><br><p> 对于电路中的每个事件，您可以配置其开始和结束的日志条目： <br><img src="https://habrastorage.org/webt/tv/z0/yy/tvz0yyygspvyltb6d_x4ja00hpg.png"></p><br><p> 另外，您可以在日志中写入消息： </p><br><pre> <code class="ruby hljs">$evm.log(<span class="hljs-symbol"><span class="hljs-symbol">:info</span></span>, <span class="hljs-string"><span class="hljs-string">"Call job status uri: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{item_uri}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{job_id}</span></span></span><span class="hljs-string">/api/json"</span></span>)</code> </pre> <br><p> 当通过API访问系统以了解出现问题的原因时，这非常有用。 或者，要跟踪冗长过程的当前状态，例如运行Jenkins作业或SCCM Runbook，请执行以下操作： </p><br><pre> <code class="ruby hljs">$evm.log(<span class="hljs-symbol"><span class="hljs-symbol">:info</span></span>, <span class="hljs-string"><span class="hljs-string">"acquire_osname --- naming jobStatus: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{jobStatus}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> jobStatus.to_s == <span class="hljs-string"><span class="hljs-string">"Completed"</span></span></code> </pre> <br><p> 您可以使用标准函数将异常写入日志： </p><br><pre> <code class="ruby hljs">raise “VM <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified” <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> vm.<span class="hljs-literal"><span class="hljs-literal">nil</span></span>?</code> </pre> <br><p> 默认情况下，所有日志都存储在/ var / log / manManageiq / *节中，但是根据我自己的经验，我可以说通过tail和grep查找问题并不是最方便的解决方案。 鉴于ManageIQ编写了许多不同的日志，因此应注意将日志重定向到例如ELK堆栈。 </p><br><h2 id="manageiq-api">  ManageIQ API </h2><br><p> 除了用户友好的Web界面，ManageIQ还具有功能性API。 例如，使用它解决了动态确定要指定模板的标识符的问题 </p><br><div class="spoiler">  <b class="spoiler_title">创建虚拟机时：</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vendor, os, ems)</span></span></span></span> user = <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{user}</span></span></span><span class="hljs-string">'</span></span> pass = <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{pass}</span></span></span><span class="hljs-string">'</span></span> options = { <span class="hljs-symbol"><span class="hljs-symbol">verify:</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> {<span class="hljs-string"><span class="hljs-string">"Accept"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"*/*"</span></span>, <span class="hljs-string"><span class="hljs-string">"accept-encoding"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"gzip, deflate"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">basic_auth:</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">username:</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{user}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">password:</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{pass}</span></span></span><span class="hljs-string">"</span></span> }, } response = HTTParty.get(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{host}</span></span></span><span class="hljs-string">/api/templates?filter[]=vendor=%27</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{vendor}</span></span></span><span class="hljs-string">%27&amp;filter[]=name=%27%2A</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{os}</span></span></span><span class="hljs-string">%2A%27&amp;filter[]=ems_id=%27</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ems}</span></span></span><span class="hljs-string">%27"</span></span>, options).to_s link = JSON.parse(response) link[<span class="hljs-string"><span class="hljs-string">"resources"</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|r|</span></span> $url = r[<span class="hljs-string"><span class="hljs-string">"href"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> response = HTTParty.get($url,options).to_s template = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{JSON.parse(response)[</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'id'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>+<span class="hljs-string"><span class="hljs-string">", "</span></span>+<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{JSON.parse(response)[</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'name'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> template <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p> 使用POST请求并指定搜索过滤器，我们得到所需的模板。 <br> 除了解决内部问题之外，您还可以创建供外部系统使用的新API方法。 在本文的开头，显示了使用Web界面订购新虚拟机的过程。 如果您这样做，它就是它的外观 </p><br><div class="spoiler">  <b class="spoiler_title">POST请求：</b> <div class="spoiler_text"><pre> <code class="ruby hljs">curl -X POST \ <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/Manageiq.hostname/api</span></span><span class="hljs-regexp"><span class="hljs-regexp">/service_catalogs/</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>/service_templates/<span class="hljs-number"><span class="hljs-number">31</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Authorization: Basic Token-Value'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{ "action": "order", "resource": { "radio_button_vcpu": "a_2", "radio_button_vram": "a_2", "hdd_size": "40", "dropdown_os": "CentOS", "text_box_filter": "dns", "dropdown_list_information_system": "DNS ", "text_box_validator": "OK (DNS )", "textarea_box_usernotes": " ", "dropdown_env": "production", "date_control_retirement_dt": "2022-05-21", "dropdown_scope": "-" } }'</span></span></code> </pre> </div></div><br><h2 id="zaklyuchenie"> 结论 </h2><br><h3 id="plyusy"> 优点： </h3><br><ul><li> 难以置信的灵活性：ManageIQ不仅允许您根据需要自定义自动化过程，而且还可以通过添加其他按钮，字段等来更改其可视部分。 </li><li> 内置代码编辑器，具有语法突出显示和代码验证功能。 在我看来，如果您需要快速修复某些问题，这是一个很好的解决方案。 </li><li> 系统可以使用的大量来源。 云：Amazon EC2，Google Compute Engine，Azure，OpenStack，VMware vCloud。 基础架构：Microsoft SCVMM，OpenStack Platform Director，Red Hat Virtualization，VMware vCenter。 容器：Kubernetes，OpenShift </li></ul><br><h3 id="minusy"> 缺点： </h3><br><ul><li> 该工具的强大功能也会带来负面影响。 并非所有文档的结构都很好，有时很难弄清楚在哪里可以找到所需的内容。 但是，值得注意的是，情况正在发生变化，文档得到了补充和改进。 </li><li> 小社区。 如果您遇到一些非常具体的问题，则可能无法快速“搜索”答案。 还是根本没有成功。 </li><li> 前两个之后的一段。 一些基本的东西，设置和场景可以在文档中或Internet上找到，但是更具体，更狭窄的问题需要大量的时间来理解和研究，包括科学的戳方法：smile：。 </li></ul><br><h3 id="kak-u-nas-seychas"> 正如我们现在所拥有的： </h3><br><p> 由于ManageIQ可以充分利用Ruby语言，因此我们能够将其集成到以下API中： </p><br><ul><li> 密码管理员 它根据安全服务的要求生成一个根密码，并将其写入数据库，然后ManageIQ在操作系统内部使用它。 </li><li> 服务中心编排服务，用于管理DNS记录和主机名； </li><li>  BMC补救措施。 整个过程记录为对请求的注释。 成功执行后，请求将关闭； </li><li> 中国移动数据库 将在数据库中创建有关所有新数据的有关新配置单元的信息。 </li><li> 扎比克斯 根据与信息系统和环境的关系，将主机添加到相应的监视组。 </li><li> 牧场主 实现了新环境的创建，代理程序的安装以及现有环境中主机的注册。 </li><li> 詹金斯  Jenkins运行作业以在oVirt中配置VM。 </li><li>  LDAP 创建用于控制Rancher环境中的访问并在Vault中配置策略的新组； </li><li> 金库 在Home中，该产品到银行业务流程的集成才刚刚开始，但是我们已经有了创建存储的新组，策略和部分的方法。 </li><li> 前面提到了Puppet和IPAM。 </li></ul><br><p> 系统的功能和功能非常广泛，我遇到了许多人，并且在实施系统的过程中继续结识。 <br> 例如，我没有提到系统具有创建带有统计信息，计费设置或按钮的自己的仪表板的能力，您可以在其中附加单个脚本或整个脚本。 您可以添加自己的字段以记录有关服务和虚拟机等的其他信息。 </p><br><h3 id="k-chemu-stremitsya-houm"> 家庭追求的目标： </h3><br><ul><li>  Hammer版本的升级，在HA模式下，您可以尝试使用内置的Ansible。 </li><li> 从每个虚拟资源单元的协调到管理的过渡。 如果配额用尽，团队将能够更快地接收新的虚拟机。 </li><li> 开发新方法以进一步提供给外部系统。 </li><li> 例如，各种SaaS，例如jenkins，logstash等。 </li><li> 在现有门户中为信息系统所有者实现新的API方法。 用户无需考虑如何与新的基础架构元素集成，他们只需将其用作获取新资源或更改现有资源的服务。 </li></ul><br><p>  <em>最后，我想提醒您，工具很棒，但不要忘记不同团队之间进行交互的重要性。</em>  <em>没有在所有有关方面的新出现的问题上建立良好的沟通和持续互动，就不可能实现本文所述的更改。</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461891/">https://habr.com/ru/post/zh-CN461891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461877/index.html">Java vs Kotlin for Android：开发人员意见</a></li>
<li><a href="../zh-CN461879/index.html">《 Linux在行动》一书</a></li>
<li><a href="../zh-CN461881/index.html">Node.js记录指南</a></li>
<li><a href="../zh-CN461885/index.html">EDS是另一种欺诈</a></li>
<li><a href="../zh-CN461887/index.html">进入航空网第2集：无人机</a></li>
<li><a href="../zh-CN461895/index.html">边走边学-在第一届欧洲商业分析日我们如何开车</a></li>
<li><a href="../zh-CN461897/index.html">我们如何保持Lamoda应用程序的稳定性</a></li>
<li><a href="../zh-CN461899/index.html">事件生成，CQRS和Laravel</a></li>
<li><a href="../zh-CN461901/index.html">三年的自动测试：如何提高速度，而不仅仅是</a></li>
<li><a href="../zh-CN461903/index.html">神秘对手：模糊借用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>