<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¨ üè´ üö∂üèª Eine √úbersicht √ºber Textverkn√ºpfungsmethoden ü§ë üìù üòø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Vor einiger Zeit nahm ich an einem Projekt zur Entwicklung eines Softwareprodukts teil, mit dem Patientenakten und Daten √ºber ihren Ges...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine √úbersicht √ºber Textverkn√ºpfungsmethoden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417465/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Vor einiger Zeit nahm ich an einem Projekt zur Entwicklung eines Softwareprodukts teil, mit dem Patientenakten und Daten √ºber ihren Gesundheitszustand von medizinischen Organisationen analysiert werden k√∂nnen, um eine einheitliche Krankenakte zu erstellen.  Lange Zeit konnte das Team keinen Ansatz zur Kombination von Patientendaten entwickeln.  Ausgangspunkt war die Untersuchung der Quellcodes der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open EMPI-L√∂sung</a> (Open Enterprise Master Patient Index), die uns dazu veranlasste, Algorithmen zur Analyse der √Ñhnlichkeit zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfolgen</a> .  Von diesem Moment an begann eine eingehendere Untersuchung der Materialien, die es erm√∂glichte, zuerst ein Layout und dann eine funktionierende L√∂sung zu erstellen. </p><br><p>  Bisher muss man bei verschiedenen Arten von Pr√§sentationen viele Fragen zur Logik der Arbeit solcher Produkte h√∂ren, aus denen ich schlie√üe, dass eine √úberpr√ºfung der Textverkn√ºpfungsmethoden f√ºr einen breiten Leserkreis von Interesse sein wird. </p><br><p>  Das Material ist eine √úbersetzung des Wikipedia-Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Record Linkage</a> " mit Copyright und Erg√§nzungen. </p><a name="habracut"></a><br><h2 id="chto-takoe-svyazyvanie-tekstovyh-zapisey">  Was ist Textverkn√ºpfung? </h2><br><p>  Der Begriff <em>‚Äû</em> Datensatzverkn√ºpfung‚Äú beschreibt den Prozess des Anh√§ngens von Textdatens√§tzen aus einer Datenquelle an Datens√§tze aus einer anderen, sofern diese dasselbe Objekt beschreiben.  In der Informatik wird dies als <em>"Datenabbildung"</em> oder <em>"Objektidentit√§tsproblem" bezeichnet</em> .  Manchmal werden alternative Definitionen verwendet, wie <em>"Identifizierung"</em> , <em>"Bindung"</em> , <em>"Duplikaterkennung"</em> , <em>"Deduplizierung"</em> , <em>"√úbereinstimmende Datens√§tze"</em> , <em>"Objektidentifizierung"</em> , die dasselbe Konzept beschreiben.  Diese terminologische F√ºlle hat zu einer Trennung von Informationsverarbeitungs- und Strukturierungsans√§tzen gef√ºhrt - <em>Datensatzbindung</em> und <em>Datenbindung</em> .  Obwohl beide die Identifizierung √ºbereinstimmender Objekte durch unterschiedliche Parameters√§tze bestimmen, wird der Begriff "Verkn√ºpfen von Textdatens√§tzen" h√§ufig verwendet, wenn auf das <em>"Wesen" einer</em> Person Bezug genommen wird, w√§hrend "Datenverkn√ºpfung" die M√∂glichkeit bedeutet, eine Webressource zwischen Datens√§tzen zu verkn√ºpfen. unter Verwendung des breiteren Konzepts eines Bezeichners, n√§mlich eines URI. </p><br><h2 id="zachem-eto-nuzhno">  Warum wird das ben√∂tigt? </h2><br><p>  Bei der Entwicklung von Softwareprodukten zum Aufbau automatisierter Systeme, die in verschiedenen Bereichen im Zusammenhang mit der Verarbeitung personenbezogener Daten einer Person (Gesundheitswesen, Geschichte, Statistik, Bildung usw.) verwendet werden, besteht die Aufgabe darin, Daten zu Rechnungslegungsgegenst√§nden aus verschiedenen Quellen zu identifizieren. </p><br><p>  Beim Sammeln von Beschreibungen aus einer Vielzahl von Quellen treten jedoch Probleme auf, die ihre eindeutige Identifizierung erschweren.  Diese Probleme umfassen: </p><br><ul><li>  Tippfehler; </li><li>  Feldpermutationen (zum Beispiel im Vornamen); </li><li>  die Verwendung von Abk√ºrzungen und Abk√ºrzungen; </li><li>  die Verwendung eines anderen Formats von Kennungen (Datumsangaben, Dokumentennummern usw.). </li><li>  phonetische Verzerrung; </li><li>  usw. </li></ul><br><p>  Die Qualit√§t der Rohdaten wirkt sich direkt auf das Ergebnis des Bindungsprozesses aus.  Aufgrund dieser Probleme werden Datens√§tze h√§ufig in die Verarbeitung √ºbertragen, die, obwohl sie dasselbe Objekt beschreiben, so aussehen, als ob diese Datens√§tze unterschiedlich aussehen.  Daher werden einerseits alle √ºbertragenen Datensatzkennungen auf ihre Anwendbarkeit f√ºr den Identifizierungsprozess bewertet, und andererseits werden die Datens√§tze selbst normalisiert oder standardisiert, um sie in ein einziges Format zu bringen. </p><br><h2 id="ekskurs-v-istoriyu">  Geschichtstour </h2><br><p>  Die urspr√ºngliche Idee, Notizen zu verkn√ºpfen, wurde von Halbert L. Dunn vorgebracht, der 1946 im American Journal of Public Health einen Artikel mit dem Titel ‚ÄûRecord Linkage‚Äú ver√∂ffentlichte. </p><br><p>  Sp√§ter, 1959, legte Howard B. Newcombe in einem Artikel √ºber die automatische Verkn√ºpfung lebenswichtiger Aufzeichnungen in der Zeitschrift Science die probabilistischen Grundlagen der modernen String-Bindungstheorie, die 1969 von Ivan Fellegi und Alan entwickelt und verst√§rkt wurden Santer (Alan Sunter).  Ihre Arbeit ‚ÄûA Theory For Record Linkage‚Äú ist immer noch die mathematische Grundlage f√ºr viele Verkn√ºpfungsalgorithmen. </p><br><p>  Die Hauptentwicklung der Algorithmen erfolgte in den 90er Jahren des letzten Jahrhunderts.  Aus verschiedenen Bereichen (Statistik, Archivierung, Epidemiologie, Geschichte usw.) kamen dann Algorithmen zu uns, die heute h√§ufig in Softwareprodukten verwendet werden, wie beispielsweise die Jaro-Winkler-Entfernung (Entfernung) und die <em>Levenshtein-</em> Entfernung. Einige L√∂sungen, zum Beispiel der phonetische Soundex-Algorithmus, erschienen jedoch viel fr√ºher - in den 20er Jahren des letzten Jahrhunderts. </p><br><h2 id="algoritmy-sravneniya-tekstovyh-zapisey">  Algorithmen f√ºr den Vergleich von Texteingaben </h2><br><p>  Unterscheiden Sie zwischen <em>deterministischen</em> und <em>probabilistischen</em> Algorithmen zum Vergleichen von Textdatens√§tzen.  Deterministische Algorithmen basieren auf der vollst√§ndigen √úbereinstimmung von Datensatzattributen.  Probabilistische Algorithmen erm√∂glichen es, den √úbereinstimmungsgrad von Datensatzattributen zu berechnen und auf dieser Grundlage √ºber die M√∂glichkeit ihrer Beziehung zu entscheiden. </p><br><h3 id="determinirovannye-algoritmy">  Deterministische Algorithmen </h3><br><p>  Der einfachste Weg, Zeichenfolgen zu vergleichen, basiert auf klaren Regeln, wenn Verkn√ºpfungen zwischen Objekten basierend auf der Anzahl der √úbereinstimmungen der Attribute der Datens√§tze generiert werden.  Das hei√üt, zwei Datens√§tze entsprechen einander durch einen deterministischen Algorithmus, wenn alle oder einige ihrer Attribute identisch sind.  Deterministische Algorithmen eignen sich zum Vergleichen von Personen, die durch eine Reihe von Daten beschrieben werden, die durch eine gemeinsame Kennung (z. B. die Versicherungsnummer eines einzelnen pers√∂nlichen Kontos in der Pensionskasse - SNILS) gekennzeichnet sind oder √ºber mehrere repr√§sentative Kennungen (Geburtsdatum, Geschlecht usw.) verf√ºgen, denen vertraut werden kann. </p><br><p>  Deterministische Algorithmen k√∂nnen angewendet werden, wenn klar strukturierte (standardisierte) Datens√§tze in die Verarbeitung √ºbertragen werden. </p><br><p>  Zum Beispiel hat es die folgenden Texteingaben: </p><br><table><thead><tr><th>  Nein, nein. </th><th>  SNILS </th><th>  Vorname </th><th>  Geburtsdatum </th><th>  Geschlecht </th></tr></thead><tbody><tr><td>  A1 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  A2 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  A3 </td><td>  126-029-036 24 </td><td>  Ilchenko Victor </td><td>  01/02/1937 </td><td>  M. </td></tr><tr><td>  A4 </td><td></td><td>  Novikova Klara </td><td>  26.12.1946 </td><td>  F. </td></tr></tbody></table><br><table><thead><tr><th>  Nein, nein. </th><th>  SNILS </th><th>  Vorname </th><th>  Geburtsdatum </th><th>  Geschlecht </th></tr></thead><tbody><tr><td>  B1 </td><td>  126-029-036 24 </td><td>  Ilyichenko Victor </td><td>  01/02/1937 </td><td>  M. </td></tr><tr><td>  B2 </td><td></td><td>  Zhivanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  B3 </td><td></td><td>  Zerchaninova Klara </td><td>  26.12.1946 </td><td>  2 </td></tr></tbody></table><br><p>  Es wurde zuvor gesagt, dass der einfachste deterministische Algorithmus die Verwendung einer eindeutigen Kennung ist, die eine Person eindeutig identifizieren soll.  Beispielsweise nehmen wir an, dass alle Datens√§tze mit demselben Bezeichnerwert (SNILS) dasselbe Thema beschreiben, andernfalls handelt es sich um unterschiedliche Themen.  Die deterministische Verbindung erzeugt in diesem Fall die folgenden Paare: A1 und A2, A3 und B1.  B2 wird nicht mit A1 und A2 verkn√ºpft, da die Kennung keine Rolle spielt, obwohl sie inhaltlich mit den angegebenen Datens√§tzen √ºbereinstimmt. </p><br><p>  Diese Ausnahmen f√ºhren dazu, dass der deterministische Algorithmus durch neue Regeln erg√§nzt werden muss.  Wenn beispielsweise keine eindeutige Kennung vorhanden ist, k√∂nnen Sie andere Attribute wie Name, Geburtsdatum und Geschlecht verwenden.  In dem gegebenen Beispiel ergibt diese zus√§tzliche Regel wiederum keine B2- und A1 / A2-Entsprechung, da die Namen jetzt unterschiedlich sind - es gibt eine phonetische Verzerrung des Nachnamens. </p><br><p>  Dieses Problem kann mit den Methoden der phonetischen Analyse gel√∂st werden. Wenn Sie jedoch den Nachnamen √§ndern (z. B. im Falle einer Heirat), m√ºssen Sie auf die Anwendung einer neuen Regel zur√ºckgreifen, z. B. das Geburtsdatum vergleichen oder Unterschiede in den vorhandenen Attributen des Datensatzes zulassen (z. B. Geschlecht). </p><br><p>  Das Beispiel zeigt deutlich, dass der deterministische Algorithmus sehr empfindlich auf die Datenqualit√§t reagiert und eine Erh√∂hung der Anzahl der Datensatzattribute zu einer erheblichen Erh√∂hung der Anzahl der angewendeten Regeln f√ºhren kann, was die Verwendung deterministischer Algorithmen erheblich erschwert. </p><br><p>  Dar√ºber hinaus ist die Verwendung deterministischer Algorithmen m√∂glich, wenn ein verifizierter Datensatz (Hauptreferenz) vorhanden ist, mit dem die eingehenden Informationen verglichen werden.  Im Falle einer st√§ndigen Auff√ºllung des Hauptverzeichnisses selbst kann jedoch eine vollst√§ndige √úberarbeitung bestehender Beziehungen erforderlich sein, was die Verwendung deterministischer Algorithmen zeitaufw√§ndig oder einfach unm√∂glich macht. </p><br><h3 id="veroyatnostnye-algoritmy">  Probabilistische Algorithmen </h3><br><p>  Probabilistische Algorithmen zum Verkn√ºpfen von Zeichenfolgendatens√§tzen verwenden einen gr√∂√üeren Satz von Attributen als deterministische, und f√ºr jedes Attribut wird ein Gewichtskoeffizient berechnet, der die F√§higkeit bestimmt, die Verbindung bei der endg√ºltigen Bewertung der Wahrscheinlichkeit der Konformit√§t gesch√§tzter Datens√§tze zu beeinflussen.  Datens√§tze, bei denen das Gesamtgewicht √ºber einem bestimmten Schwellenwert angesammelt wurde, werden als verwandt betrachtet. Datens√§tze, bei denen das Gesamtgewicht unter einem bestimmten Schwellenwert angesammelt wurde, gelten als nicht verwandt.  Paare, die den Wert des Gesamtgewichts aus der Mitte des Bereichs gewonnen haben, gelten als Kandidaten f√ºr die Verkn√ºpfung und k√∂nnen sp√§ter (z. B. vom Bediener) in Betracht gezogen werden, die √ºber ihre Vereinigung (Verkn√ºpfung) entscheiden oder sie ungebunden lassen.  Im Gegensatz zu deterministischen Algorithmen, bei denen es sich um einen Satz einer gro√üen Anzahl klarer (programmierter) Regeln handelt, k√∂nnen probabilistische Algorithmen daher durch Auswahl von Schwellenwerten an die Qualit√§t der Daten angepasst werden und erfordern keine Neuprogrammierung. </p><br><p>  Probabilistische Algorithmen weisen den Attributen des Datensatzes also Gewichtskoeffizienten ( <em>u</em> und <em>m</em> ) zu, mit deren Hilfe ihre Entsprechung oder Inkonsistenz untereinander bestimmt wird. </p><br><p>  Der Koeffizient u bestimmt die Wahrscheinlichkeit, dass die Kennungen zweier unabh√§ngiger Datens√§tze zuf√§llig zusammenfallen.  Zum Beispiel betr√§gt die U-Wahrscheinlichkeit des Geburtsmonats (wenn es zw√∂lf gleichm√§√üig verteilte Werte gibt) 1 \ 12 = 0,083.  Bezeichner mit Werten, die nicht gleichm√§√üig verteilt sind, haben unterschiedliche Wahrscheinlichkeiten f√ºr unterschiedliche Werte (manchmal einschlie√ülich fehlender Werte). </p><br><p>  Der Koeffizient m ist die Wahrscheinlichkeit, dass die Identifikatoren in den verglichenen Paaren einander entsprechen oder ziemlich √§hnlich sind - zum Beispiel im Fall einer hohen Wahrscheinlichkeit durch den Jaro-Winkler-Algorithmus oder einer niedrigen Wahrscheinlichkeit durch den Levenshtein-Algorithmus.  Wenn die Attribute der Datens√§tze vollst√§ndig konsistent sind, sollte dieser Wert einen Wert von 1,0 haben. Angesichts der geringen Wahrscheinlichkeit sollte der Koeffizient jedoch anders bewertet werden.  Diese Bewertung kann auf der Grundlage einer vorl√§ufigen Analyse des Datensatzes erfolgen, indem beispielsweise <em>der</em> Wahrscheinlichkeitsalgorithmus zum Identifizieren einer gro√üen Anzahl von √ºbereinstimmenden und nicht √ºbereinstimmenden Paaren manuell <em>"gelernt"</em> wird oder indem der Algorithmus iterativ gestartet wird, um den am besten geeigneten m-Koeffizientenwert auszuw√§hlen. </p><br><p>  Wenn die m-Wahrscheinlichkeit als 0,95 definiert ist, sehen die Konformit√§ts- / Nichtkonformit√§tskoeffizienten f√ºr den Geburtsmonat folgenderma√üen aus: </p><br><table><thead><tr><th>  Metrisch </th><th>  Teilen von Links </th><th>  Anteil von Werten, keine Referenzen </th><th>  Frequenz </th><th>  Gewicht </th></tr></thead><tbody><tr><td>  Compliance </td><td>  m = 0,95 </td><td>  u = 0,083 </td><td>  m \ u = 11,4 </td><td>  ln (m / u) / ln (2) ‚â§ 3,51 </td></tr><tr><td>  Nicht√ºbereinstimmung </td><td>  1 m = 0,05 </td><td>  1-u = 0,917 </td><td>  (1-m) / (1-u) ‚â§ 0,0545 </td><td>  ln ((1-m) / (1-u)) / ln (2) ‚â§ -4,20 </td></tr></tbody></table><br><p>  √Ñhnliche Berechnungen sollten f√ºr andere Datensatzkennungen durchgef√ºhrt werden, um deren Konformit√§ts- und Nichtkonformit√§tskoeffizienten zu bestimmen.  Dann wird jede Kennung eines Datensatzes mit der entsprechenden Kennung eines anderen Datensatzes verglichen, um das Gesamtgewicht des Paares zu bestimmen: Das Gewicht des entsprechenden Paares wird mit einer kumulierten Summe zum Gesamtergebnis addiert, w√§hrend das Gewicht des unangemessenen Paares vom Gesamtergebnis abgezogen wird.  Der resultierende Betrag wird mit den identifizierten Schwellenwerten verglichen, um zu bestimmen, ob das analysierte Paar automatisch gepaart oder zur Pr√ºfung an den Bediener √ºbertragen werden soll. </p><br><h4 id="blokirovanie">  Blockieren </h4><br><p>  Die Bestimmung von Konformit√§ts- / Nichtkonformit√§tsschwellen ist ein Gleichgewicht zwischen dem Erhalten einer akzeptablen Empfindlichkeit (dem Anteil verwandter Datens√§tze, die vom Algorithmus erfasst werden) und dem Vorhersagewert des Ergebnisses (d. H. Genauigkeit als Ma√ü f√ºr wirklich √ºbereinstimmende Datens√§tze, die durch den Algorithmus verkn√ºpft sind).  Da das Definieren von Schwellenwerten eine sehr schwierige Aufgabe sein kann, insbesondere f√ºr gro√üe Datenmengen, wird h√§ufig ein als <em>Blockieren</em> bekanntes Verfahren verwendet, um die Recheneffizienz zu erh√∂hen.  Es wird versucht, einen Vergleich zwischen Datens√§tzen durchzuf√ºhren, bei denen eine signifikante Diskrepanz ( <em>Diskriminierung</em> ) in den Werten der Basisattribute festgestellt wird.  Dies f√ºhrt zu einer Erh√∂hung der Genauigkeit aufgrund einer Verringerung der Empfindlichkeit. </p><br><p>  Zum Beispiel reduziert das Sperren basierend auf der phonetischen Codierung eines Nachnamens die Gesamtzahl der erforderlichen Vergleiche und erh√∂ht die Wahrscheinlichkeit, dass die Beziehungen zwischen den Datens√§tzen korrekt sind, da die beiden Attribute bereits konsistent sind, aber m√∂glicherweise Datens√§tze √ºberspringen k√∂nnen, die sich auf dieselbe Person beziehen, deren Nachname ge√§ndert (zum Beispiel infolge der Ehe).  Das Blockieren nach Geburtsmonat ist ein stabilerer Indikator, der nur angepasst werden kann, wenn die Quelldaten fehlerhaft sind, aber einen geringeren Vorteil hinsichtlich des positiven Vorhersagewerts und des Empfindlichkeitsverlusts bietet, da zw√∂lf verschiedene Gruppen extrem gro√üer Datenmengen erstellt werden und dies nicht zu einer Geschwindigkeitssteigerung f√ºhrt Computing. </p><br><p>  Daher verwenden die effizientesten Verkn√ºpfungssysteme f√ºr Texteingaben h√§ufig mehrere Blockierungsdurchl√§ufe, um Daten auf verschiedene Weise zu gruppieren, um Gruppen von Datens√§tzen vorzubereiten, die sp√§ter zur Analyse eingereicht werden sollten. </p><br><h4 id="mashinnoe-obuchenie">  Maschinelles Lernen </h4><br><p>  In letzter Zeit wurden verschiedene Methoden des maschinellen Lernens verwendet, um Textdatens√§tze zu verkn√ºpfen.  Randall Wilson hat in seiner Arbeit von 2011 gezeigt, dass der klassische probabilistische Verkn√ºpfungsalgorithmus f√ºr Textdatens√§tze dem naiven Bayes-Algorithmus entspricht und unter der Annahme, dass Klassifizierungsmerkmale unabh√§ngig sind, dieselben Probleme hat.  Um die Genauigkeit der Analyse zu erh√∂hen, schl√§gt der Autor vor, ein Grundmodell eines neuronalen Netzwerks zu verwenden, das als einschichtiges Perzeptron bezeichnet wird und dessen Verwendung es erm√∂glicht, die mit herk√∂mmlichen probabilistischen Algorithmen erzielten Ergebnisse signifikant zu √ºbertreffen. </p><br><h2 id="foneticheskoe-kodirovanie">  Phonetische Codierung </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phonetische Algorithmen</a> stimmen mit zwei √§hnlich ausgesprochenen W√∂rtern mit denselben Codes √ºberein, sodass Sie solche W√∂rter anhand ihrer phonetischen √Ñhnlichkeit vergleichen k√∂nnen. </p><br><p>  Die meisten phonetischen Algorithmen dienen zur Analyse englischer W√∂rter, obwohl k√ºrzlich einige Algorithmen f√ºr die Verwendung mit anderen Sprachen modifiziert wurden oder urspr√ºnglich als nationale L√∂sungen erstellt wurden (z. B. Caverphone). </p><br><h3 id="soundex">  Soundex </h3><br><p>  Der klassische Algorithmus zum Vergleichen von zwei Saiten nach ihrem Klang ist Soundex (kurz f√ºr Klangindex).  Es wird der gleiche Code f√ºr Zeichenfolgen festgelegt, die auf Englisch einen √§hnlichen Klang haben.  Soundex wurde urspr√ºnglich in den 1930er Jahren von der US National Archives Administration verwendet, um Volksz√§hlungen von 1890 bis 1920 nachtr√§glich zu analysieren. </p><br><p>  Die Autoren der Algorithmen sind Robert C. Russel und Margaret King Odell, die sie in den 20er Jahren des letzten Jahrhunderts patentierten.  Der Algorithmus selbst gewann in der zweiten H√§lfte des letzten Jahrhunderts an Popularit√§t, als er Gegenstand mehrerer Artikel in popul√§rwissenschaftlichen Fachzeitschriften in den USA wurde und in D. Knuts Monographie ‚ÄûThe Art of Programming‚Äú ver√∂ffentlicht wurde. </p><br><h3 id="daitch-mokotoff-soundex">  Daitch-Mokotoff Soundex </h3><br><p>  Da Soundex nur f√ºr Englisch geeignet ist, haben einige Forscher versucht, es zu √§ndern.  1985 schlugen Gary Mokotoff und Randy Daitch eine Variante des Soundex-Algorithmus vor, mit der osteurop√§ische (einschlie√ülich russischer) Nachnamen mit einer relativ hohen Qualit√§t verglichen werden sollen. </p><br><h3 id="metaphone">  Metaphon </h3><br><p>  In den 90er Jahren schlug Lawrence Philips (Lawrence Philips) eine alternative Version des Soundex-Algorithmus vor, der als Metaphone bezeichnet wurde.  Der neue Algorithmus verwendete ein gr√∂√üeres Regelwerk f√ºr die englische Aussprache, aufgrund dessen es genauer war.  Sp√§ter wurde der Algorithmus ge√§ndert, um in anderen Sprachen verwendet zu werden, basierend auf der Transkription unter Verwendung von Buchstaben des lateinischen Alphabets. </p><br><h3 id="russkiy-metaphone">  Russisches Metaphon </h3><br><p>  Im Jahr 2002 ver√∂ffentlichte die 8. Ausgabe des Programmer-Magazins einen Artikel von Peter Kankowski √ºber seine Anpassung der englischen Version des Metaphone-Algorithmus.  Diese Version des Algorithmus konvertiert die Quellw√∂rter gem√§√ü den Regeln und Normen der russischen Sprache, wobei der phonetische Klang nicht betonter Vokale und die m√∂gliche "Verschmelzung" von Konsonanten in der Aussprache ber√ºcksichtigt werden. </p><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Infolge mehrerer Iterationen entwickelte das in der Einleitung erw√§hnte Projektteam des Softwareproduktentwicklungsprojekts eine Architekturl√∂sung, deren Schema in der Abbildung dargestellt ist. <br><img src="https://habrastorage.org/webt/fr/yx/dg/fryxdgd4sf1lcf1iachctg_rvqc.png"></p><br><p>  Textbeschreibungen von Patienten werden √ºber den REST-Service akzeptiert und unver√§ndert im Repository (Kartendatenbank) gespeichert.  Da unser System mit medizinischen Daten arbeitet, wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FHIR-</a> Standard (Fast Healthcare Interoperability Resources) f√ºr den Informationsaustausch gew√§hlt.  Informationen √ºber die empfangene Patientenkarte werden zur weiteren Analyse und Entscheidungsfindung beim Aufbau der Kommunikation in die Nachrichtenwarteschlange √ºbertragen. </p><br><p>  Die erste Karte, die verarbeitet wird, ist der <em>‚ÄûQuick Analyzer‚Äú</em> , der mit einem deterministischen Algorithmus arbeitet.  Wenn alle Regeln des deterministischen Algorithmus ausgearbeitet wurden, wird ein Datensatz mit einer Verkn√ºpfung zur verarbeiteten Karte in einem separaten Speicher (Verkn√ºpfungsdatenbank) erstellt.  Der Datensatz enth√§lt zus√§tzlich zur Kennung der analysierten Karte das Datum der Kommunikationsherstellung und eine bedingte Kennung, die den global identifizierten Patienten identifiziert.  Weitere Karten werden weiter auf die angegebene globale Kennung bezogen, wodurch ein Array gebildet wird, das eine bestimmte Person beschreibt. </p><br><p>  Wenn der deterministische Algorithmus keine √úbereinstimmung findet, werden die Karteninformationen √ºber die Nachrichtenwarteschlange an den ‚ÄûFull Analyzer‚Äú √ºbertragen. </p><br><p>       (  ).       .       : </p><br><p><img src="https://habrastorage.org/webt/i8/_7/-k/i8_7-km0ifcsu6llsqhmsruperg.png"></p><br><p> <strong> 1.  -</strong> <br>            ,       .          2. </p><br><p> <strong> 2.  </strong> <br>    -       ,         (). </p><br><p> <strong> 3.  </strong> <br>        ,    ,   (  )  ,      . </p><br><p> <strong> 4.   </strong> <br>     ,        .         .       ,      ,     .       ,   ,    ,         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417465/">https://habr.com/ru/post/de417465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417453/index.html">Organisation von Praktika f√ºr Studenten: Rechen und Tricks</a></li>
<li><a href="../de417457/index.html">Frontend Conf Moscow - Kundenseite rein und raus</a></li>
<li><a href="../de417459/index.html">Kennen Sie Ihre JIT: n√§her am Auto</a></li>
<li><a href="../de417461/index.html">Ivan Tulup: asynchron in JS unter der Haube</a></li>
<li><a href="../de417463/index.html">Ein unerwartetes Treffen. Kapitel 17</a></li>
<li><a href="../de417469/index.html">F√ºnf egoistische Gr√ºnde, reproduzierbar zu arbeiten</a></li>
<li><a href="../de417471/index.html">Einfaches Lot MK936 SMD. DIY L√∂tstation f√ºr SMD-Komponenten</a></li>
<li><a href="../de417473/index.html">Vertrauensw√ºrdiger Speicher mit DRBD9 und Proxmox (Teil 1: NFS)</a></li>
<li><a href="../de417475/index.html">Glusterfs + L√∂schcodierung: Wenn Sie viel brauchen, billig und zuverl√§ssig</a></li>
<li><a href="../de417477/index.html">Hot Desking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>