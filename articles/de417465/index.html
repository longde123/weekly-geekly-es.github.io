<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎬 🏫 🚶🏻 Eine Übersicht über Textverknüpfungsmethoden 🤑 📝 😿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 


 Vor einiger Zeit nahm ich an einem Projekt zur Entwicklung eines Softwareprodukts teil, mit dem Patientenakten und Daten über ihren Ges...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Übersicht über Textverknüpfungsmethoden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417465/"><h2 id="vvedenie">  Einführung </h2><br><p>  Vor einiger Zeit nahm ich an einem Projekt zur Entwicklung eines Softwareprodukts teil, mit dem Patientenakten und Daten über ihren Gesundheitszustand von medizinischen Organisationen analysiert werden können, um eine einheitliche Krankenakte zu erstellen.  Lange Zeit konnte das Team keinen Ansatz zur Kombination von Patientendaten entwickeln.  Ausgangspunkt war die Untersuchung der Quellcodes der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open EMPI-Lösung</a> (Open Enterprise Master Patient Index), die uns dazu veranlasste, Algorithmen zur Analyse der Ähnlichkeit zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfolgen</a> .  Von diesem Moment an begann eine eingehendere Untersuchung der Materialien, die es ermöglichte, zuerst ein Layout und dann eine funktionierende Lösung zu erstellen. </p><br><p>  Bisher muss man bei verschiedenen Arten von Präsentationen viele Fragen zur Logik der Arbeit solcher Produkte hören, aus denen ich schließe, dass eine Überprüfung der Textverknüpfungsmethoden für einen breiten Leserkreis von Interesse sein wird. </p><br><p>  Das Material ist eine Übersetzung des Wikipedia-Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Record Linkage</a> " mit Copyright und Ergänzungen. </p><a name="habracut"></a><br><h2 id="chto-takoe-svyazyvanie-tekstovyh-zapisey">  Was ist Textverknüpfung? </h2><br><p>  Der Begriff <em>„</em> Datensatzverknüpfung“ beschreibt den Prozess des Anhängens von Textdatensätzen aus einer Datenquelle an Datensätze aus einer anderen, sofern diese dasselbe Objekt beschreiben.  In der Informatik wird dies als <em>"Datenabbildung"</em> oder <em>"Objektidentitätsproblem" bezeichnet</em> .  Manchmal werden alternative Definitionen verwendet, wie <em>"Identifizierung"</em> , <em>"Bindung"</em> , <em>"Duplikaterkennung"</em> , <em>"Deduplizierung"</em> , <em>"Übereinstimmende Datensätze"</em> , <em>"Objektidentifizierung"</em> , die dasselbe Konzept beschreiben.  Diese terminologische Fülle hat zu einer Trennung von Informationsverarbeitungs- und Strukturierungsansätzen geführt - <em>Datensatzbindung</em> und <em>Datenbindung</em> .  Obwohl beide die Identifizierung übereinstimmender Objekte durch unterschiedliche Parametersätze bestimmen, wird der Begriff "Verknüpfen von Textdatensätzen" häufig verwendet, wenn auf das <em>"Wesen" einer</em> Person Bezug genommen wird, während "Datenverknüpfung" die Möglichkeit bedeutet, eine Webressource zwischen Datensätzen zu verknüpfen. unter Verwendung des breiteren Konzepts eines Bezeichners, nämlich eines URI. </p><br><h2 id="zachem-eto-nuzhno">  Warum wird das benötigt? </h2><br><p>  Bei der Entwicklung von Softwareprodukten zum Aufbau automatisierter Systeme, die in verschiedenen Bereichen im Zusammenhang mit der Verarbeitung personenbezogener Daten einer Person (Gesundheitswesen, Geschichte, Statistik, Bildung usw.) verwendet werden, besteht die Aufgabe darin, Daten zu Rechnungslegungsgegenständen aus verschiedenen Quellen zu identifizieren. </p><br><p>  Beim Sammeln von Beschreibungen aus einer Vielzahl von Quellen treten jedoch Probleme auf, die ihre eindeutige Identifizierung erschweren.  Diese Probleme umfassen: </p><br><ul><li>  Tippfehler; </li><li>  Feldpermutationen (zum Beispiel im Vornamen); </li><li>  die Verwendung von Abkürzungen und Abkürzungen; </li><li>  die Verwendung eines anderen Formats von Kennungen (Datumsangaben, Dokumentennummern usw.). </li><li>  phonetische Verzerrung; </li><li>  usw. </li></ul><br><p>  Die Qualität der Rohdaten wirkt sich direkt auf das Ergebnis des Bindungsprozesses aus.  Aufgrund dieser Probleme werden Datensätze häufig in die Verarbeitung übertragen, die, obwohl sie dasselbe Objekt beschreiben, so aussehen, als ob diese Datensätze unterschiedlich aussehen.  Daher werden einerseits alle übertragenen Datensatzkennungen auf ihre Anwendbarkeit für den Identifizierungsprozess bewertet, und andererseits werden die Datensätze selbst normalisiert oder standardisiert, um sie in ein einziges Format zu bringen. </p><br><h2 id="ekskurs-v-istoriyu">  Geschichtstour </h2><br><p>  Die ursprüngliche Idee, Notizen zu verknüpfen, wurde von Halbert L. Dunn vorgebracht, der 1946 im American Journal of Public Health einen Artikel mit dem Titel „Record Linkage“ veröffentlichte. </p><br><p>  Später, 1959, legte Howard B. Newcombe in einem Artikel über die automatische Verknüpfung lebenswichtiger Aufzeichnungen in der Zeitschrift Science die probabilistischen Grundlagen der modernen String-Bindungstheorie, die 1969 von Ivan Fellegi und Alan entwickelt und verstärkt wurden Santer (Alan Sunter).  Ihre Arbeit „A Theory For Record Linkage“ ist immer noch die mathematische Grundlage für viele Verknüpfungsalgorithmen. </p><br><p>  Die Hauptentwicklung der Algorithmen erfolgte in den 90er Jahren des letzten Jahrhunderts.  Aus verschiedenen Bereichen (Statistik, Archivierung, Epidemiologie, Geschichte usw.) kamen dann Algorithmen zu uns, die heute häufig in Softwareprodukten verwendet werden, wie beispielsweise die Jaro-Winkler-Entfernung (Entfernung) und die <em>Levenshtein-</em> Entfernung. Einige Lösungen, zum Beispiel der phonetische Soundex-Algorithmus, erschienen jedoch viel früher - in den 20er Jahren des letzten Jahrhunderts. </p><br><h2 id="algoritmy-sravneniya-tekstovyh-zapisey">  Algorithmen für den Vergleich von Texteingaben </h2><br><p>  Unterscheiden Sie zwischen <em>deterministischen</em> und <em>probabilistischen</em> Algorithmen zum Vergleichen von Textdatensätzen.  Deterministische Algorithmen basieren auf der vollständigen Übereinstimmung von Datensatzattributen.  Probabilistische Algorithmen ermöglichen es, den Übereinstimmungsgrad von Datensatzattributen zu berechnen und auf dieser Grundlage über die Möglichkeit ihrer Beziehung zu entscheiden. </p><br><h3 id="determinirovannye-algoritmy">  Deterministische Algorithmen </h3><br><p>  Der einfachste Weg, Zeichenfolgen zu vergleichen, basiert auf klaren Regeln, wenn Verknüpfungen zwischen Objekten basierend auf der Anzahl der Übereinstimmungen der Attribute der Datensätze generiert werden.  Das heißt, zwei Datensätze entsprechen einander durch einen deterministischen Algorithmus, wenn alle oder einige ihrer Attribute identisch sind.  Deterministische Algorithmen eignen sich zum Vergleichen von Personen, die durch eine Reihe von Daten beschrieben werden, die durch eine gemeinsame Kennung (z. B. die Versicherungsnummer eines einzelnen persönlichen Kontos in der Pensionskasse - SNILS) gekennzeichnet sind oder über mehrere repräsentative Kennungen (Geburtsdatum, Geschlecht usw.) verfügen, denen vertraut werden kann. </p><br><p>  Deterministische Algorithmen können angewendet werden, wenn klar strukturierte (standardisierte) Datensätze in die Verarbeitung übertragen werden. </p><br><p>  Zum Beispiel hat es die folgenden Texteingaben: </p><br><table><thead><tr><th>  Nein, nein. </th><th>  SNILS </th><th>  Vorname </th><th>  Geburtsdatum </th><th>  Geschlecht </th></tr></thead><tbody><tr><td>  A1 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  A2 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  A3 </td><td>  126-029-036 24 </td><td>  Ilchenko Victor </td><td>  01/02/1937 </td><td>  M. </td></tr><tr><td>  A4 </td><td></td><td>  Novikova Klara </td><td>  26.12.1946 </td><td>  F. </td></tr></tbody></table><br><table><thead><tr><th>  Nein, nein. </th><th>  SNILS </th><th>  Vorname </th><th>  Geburtsdatum </th><th>  Geschlecht </th></tr></thead><tbody><tr><td>  B1 </td><td>  126-029-036 24 </td><td>  Ilyichenko Victor </td><td>  01/02/1937 </td><td>  M. </td></tr><tr><td>  B2 </td><td></td><td>  Zhivanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  B3 </td><td></td><td>  Zerchaninova Klara </td><td>  26.12.1946 </td><td>  2 </td></tr></tbody></table><br><p>  Es wurde zuvor gesagt, dass der einfachste deterministische Algorithmus die Verwendung einer eindeutigen Kennung ist, die eine Person eindeutig identifizieren soll.  Beispielsweise nehmen wir an, dass alle Datensätze mit demselben Bezeichnerwert (SNILS) dasselbe Thema beschreiben, andernfalls handelt es sich um unterschiedliche Themen.  Die deterministische Verbindung erzeugt in diesem Fall die folgenden Paare: A1 und A2, A3 und B1.  B2 wird nicht mit A1 und A2 verknüpft, da die Kennung keine Rolle spielt, obwohl sie inhaltlich mit den angegebenen Datensätzen übereinstimmt. </p><br><p>  Diese Ausnahmen führen dazu, dass der deterministische Algorithmus durch neue Regeln ergänzt werden muss.  Wenn beispielsweise keine eindeutige Kennung vorhanden ist, können Sie andere Attribute wie Name, Geburtsdatum und Geschlecht verwenden.  In dem gegebenen Beispiel ergibt diese zusätzliche Regel wiederum keine B2- und A1 / A2-Entsprechung, da die Namen jetzt unterschiedlich sind - es gibt eine phonetische Verzerrung des Nachnamens. </p><br><p>  Dieses Problem kann mit den Methoden der phonetischen Analyse gelöst werden. Wenn Sie jedoch den Nachnamen ändern (z. B. im Falle einer Heirat), müssen Sie auf die Anwendung einer neuen Regel zurückgreifen, z. B. das Geburtsdatum vergleichen oder Unterschiede in den vorhandenen Attributen des Datensatzes zulassen (z. B. Geschlecht). </p><br><p>  Das Beispiel zeigt deutlich, dass der deterministische Algorithmus sehr empfindlich auf die Datenqualität reagiert und eine Erhöhung der Anzahl der Datensatzattribute zu einer erheblichen Erhöhung der Anzahl der angewendeten Regeln führen kann, was die Verwendung deterministischer Algorithmen erheblich erschwert. </p><br><p>  Darüber hinaus ist die Verwendung deterministischer Algorithmen möglich, wenn ein verifizierter Datensatz (Hauptreferenz) vorhanden ist, mit dem die eingehenden Informationen verglichen werden.  Im Falle einer ständigen Auffüllung des Hauptverzeichnisses selbst kann jedoch eine vollständige Überarbeitung bestehender Beziehungen erforderlich sein, was die Verwendung deterministischer Algorithmen zeitaufwändig oder einfach unmöglich macht. </p><br><h3 id="veroyatnostnye-algoritmy">  Probabilistische Algorithmen </h3><br><p>  Probabilistische Algorithmen zum Verknüpfen von Zeichenfolgendatensätzen verwenden einen größeren Satz von Attributen als deterministische, und für jedes Attribut wird ein Gewichtskoeffizient berechnet, der die Fähigkeit bestimmt, die Verbindung bei der endgültigen Bewertung der Wahrscheinlichkeit der Konformität geschätzter Datensätze zu beeinflussen.  Datensätze, bei denen das Gesamtgewicht über einem bestimmten Schwellenwert angesammelt wurde, werden als verwandt betrachtet. Datensätze, bei denen das Gesamtgewicht unter einem bestimmten Schwellenwert angesammelt wurde, gelten als nicht verwandt.  Paare, die den Wert des Gesamtgewichts aus der Mitte des Bereichs gewonnen haben, gelten als Kandidaten für die Verknüpfung und können später (z. B. vom Bediener) in Betracht gezogen werden, die über ihre Vereinigung (Verknüpfung) entscheiden oder sie ungebunden lassen.  Im Gegensatz zu deterministischen Algorithmen, bei denen es sich um einen Satz einer großen Anzahl klarer (programmierter) Regeln handelt, können probabilistische Algorithmen daher durch Auswahl von Schwellenwerten an die Qualität der Daten angepasst werden und erfordern keine Neuprogrammierung. </p><br><p>  Probabilistische Algorithmen weisen den Attributen des Datensatzes also Gewichtskoeffizienten ( <em>u</em> und <em>m</em> ) zu, mit deren Hilfe ihre Entsprechung oder Inkonsistenz untereinander bestimmt wird. </p><br><p>  Der Koeffizient u bestimmt die Wahrscheinlichkeit, dass die Kennungen zweier unabhängiger Datensätze zufällig zusammenfallen.  Zum Beispiel beträgt die U-Wahrscheinlichkeit des Geburtsmonats (wenn es zwölf gleichmäßig verteilte Werte gibt) 1 \ 12 = 0,083.  Bezeichner mit Werten, die nicht gleichmäßig verteilt sind, haben unterschiedliche Wahrscheinlichkeiten für unterschiedliche Werte (manchmal einschließlich fehlender Werte). </p><br><p>  Der Koeffizient m ist die Wahrscheinlichkeit, dass die Identifikatoren in den verglichenen Paaren einander entsprechen oder ziemlich ähnlich sind - zum Beispiel im Fall einer hohen Wahrscheinlichkeit durch den Jaro-Winkler-Algorithmus oder einer niedrigen Wahrscheinlichkeit durch den Levenshtein-Algorithmus.  Wenn die Attribute der Datensätze vollständig konsistent sind, sollte dieser Wert einen Wert von 1,0 haben. Angesichts der geringen Wahrscheinlichkeit sollte der Koeffizient jedoch anders bewertet werden.  Diese Bewertung kann auf der Grundlage einer vorläufigen Analyse des Datensatzes erfolgen, indem beispielsweise <em>der</em> Wahrscheinlichkeitsalgorithmus zum Identifizieren einer großen Anzahl von übereinstimmenden und nicht übereinstimmenden Paaren manuell <em>"gelernt"</em> wird oder indem der Algorithmus iterativ gestartet wird, um den am besten geeigneten m-Koeffizientenwert auszuwählen. </p><br><p>  Wenn die m-Wahrscheinlichkeit als 0,95 definiert ist, sehen die Konformitäts- / Nichtkonformitätskoeffizienten für den Geburtsmonat folgendermaßen aus: </p><br><table><thead><tr><th>  Metrisch </th><th>  Teilen von Links </th><th>  Anteil von Werten, keine Referenzen </th><th>  Frequenz </th><th>  Gewicht </th></tr></thead><tbody><tr><td>  Compliance </td><td>  m = 0,95 </td><td>  u = 0,083 </td><td>  m \ u = 11,4 </td><td>  ln (m / u) / ln (2) ≤ 3,51 </td></tr><tr><td>  Nichtübereinstimmung </td><td>  1 m = 0,05 </td><td>  1-u = 0,917 </td><td>  (1-m) / (1-u) ≤ 0,0545 </td><td>  ln ((1-m) / (1-u)) / ln (2) ≤ -4,20 </td></tr></tbody></table><br><p>  Ähnliche Berechnungen sollten für andere Datensatzkennungen durchgeführt werden, um deren Konformitäts- und Nichtkonformitätskoeffizienten zu bestimmen.  Dann wird jede Kennung eines Datensatzes mit der entsprechenden Kennung eines anderen Datensatzes verglichen, um das Gesamtgewicht des Paares zu bestimmen: Das Gewicht des entsprechenden Paares wird mit einer kumulierten Summe zum Gesamtergebnis addiert, während das Gewicht des unangemessenen Paares vom Gesamtergebnis abgezogen wird.  Der resultierende Betrag wird mit den identifizierten Schwellenwerten verglichen, um zu bestimmen, ob das analysierte Paar automatisch gepaart oder zur Prüfung an den Bediener übertragen werden soll. </p><br><h4 id="blokirovanie">  Blockieren </h4><br><p>  Die Bestimmung von Konformitäts- / Nichtkonformitätsschwellen ist ein Gleichgewicht zwischen dem Erhalten einer akzeptablen Empfindlichkeit (dem Anteil verwandter Datensätze, die vom Algorithmus erfasst werden) und dem Vorhersagewert des Ergebnisses (d. H. Genauigkeit als Maß für wirklich übereinstimmende Datensätze, die durch den Algorithmus verknüpft sind).  Da das Definieren von Schwellenwerten eine sehr schwierige Aufgabe sein kann, insbesondere für große Datenmengen, wird häufig ein als <em>Blockieren</em> bekanntes Verfahren verwendet, um die Recheneffizienz zu erhöhen.  Es wird versucht, einen Vergleich zwischen Datensätzen durchzuführen, bei denen eine signifikante Diskrepanz ( <em>Diskriminierung</em> ) in den Werten der Basisattribute festgestellt wird.  Dies führt zu einer Erhöhung der Genauigkeit aufgrund einer Verringerung der Empfindlichkeit. </p><br><p>  Zum Beispiel reduziert das Sperren basierend auf der phonetischen Codierung eines Nachnamens die Gesamtzahl der erforderlichen Vergleiche und erhöht die Wahrscheinlichkeit, dass die Beziehungen zwischen den Datensätzen korrekt sind, da die beiden Attribute bereits konsistent sind, aber möglicherweise Datensätze überspringen können, die sich auf dieselbe Person beziehen, deren Nachname geändert (zum Beispiel infolge der Ehe).  Das Blockieren nach Geburtsmonat ist ein stabilerer Indikator, der nur angepasst werden kann, wenn die Quelldaten fehlerhaft sind, aber einen geringeren Vorteil hinsichtlich des positiven Vorhersagewerts und des Empfindlichkeitsverlusts bietet, da zwölf verschiedene Gruppen extrem großer Datenmengen erstellt werden und dies nicht zu einer Geschwindigkeitssteigerung führt Computing. </p><br><p>  Daher verwenden die effizientesten Verknüpfungssysteme für Texteingaben häufig mehrere Blockierungsdurchläufe, um Daten auf verschiedene Weise zu gruppieren, um Gruppen von Datensätzen vorzubereiten, die später zur Analyse eingereicht werden sollten. </p><br><h4 id="mashinnoe-obuchenie">  Maschinelles Lernen </h4><br><p>  In letzter Zeit wurden verschiedene Methoden des maschinellen Lernens verwendet, um Textdatensätze zu verknüpfen.  Randall Wilson hat in seiner Arbeit von 2011 gezeigt, dass der klassische probabilistische Verknüpfungsalgorithmus für Textdatensätze dem naiven Bayes-Algorithmus entspricht und unter der Annahme, dass Klassifizierungsmerkmale unabhängig sind, dieselben Probleme hat.  Um die Genauigkeit der Analyse zu erhöhen, schlägt der Autor vor, ein Grundmodell eines neuronalen Netzwerks zu verwenden, das als einschichtiges Perzeptron bezeichnet wird und dessen Verwendung es ermöglicht, die mit herkömmlichen probabilistischen Algorithmen erzielten Ergebnisse signifikant zu übertreffen. </p><br><h2 id="foneticheskoe-kodirovanie">  Phonetische Codierung </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phonetische Algorithmen</a> stimmen mit zwei ähnlich ausgesprochenen Wörtern mit denselben Codes überein, sodass Sie solche Wörter anhand ihrer phonetischen Ähnlichkeit vergleichen können. </p><br><p>  Die meisten phonetischen Algorithmen dienen zur Analyse englischer Wörter, obwohl kürzlich einige Algorithmen für die Verwendung mit anderen Sprachen modifiziert wurden oder ursprünglich als nationale Lösungen erstellt wurden (z. B. Caverphone). </p><br><h3 id="soundex">  Soundex </h3><br><p>  Der klassische Algorithmus zum Vergleichen von zwei Saiten nach ihrem Klang ist Soundex (kurz für Klangindex).  Es wird der gleiche Code für Zeichenfolgen festgelegt, die auf Englisch einen ähnlichen Klang haben.  Soundex wurde ursprünglich in den 1930er Jahren von der US National Archives Administration verwendet, um Volkszählungen von 1890 bis 1920 nachträglich zu analysieren. </p><br><p>  Die Autoren der Algorithmen sind Robert C. Russel und Margaret King Odell, die sie in den 20er Jahren des letzten Jahrhunderts patentierten.  Der Algorithmus selbst gewann in der zweiten Hälfte des letzten Jahrhunderts an Popularität, als er Gegenstand mehrerer Artikel in populärwissenschaftlichen Fachzeitschriften in den USA wurde und in D. Knuts Monographie „The Art of Programming“ veröffentlicht wurde. </p><br><h3 id="daitch-mokotoff-soundex">  Daitch-Mokotoff Soundex </h3><br><p>  Da Soundex nur für Englisch geeignet ist, haben einige Forscher versucht, es zu ändern.  1985 schlugen Gary Mokotoff und Randy Daitch eine Variante des Soundex-Algorithmus vor, mit der osteuropäische (einschließlich russischer) Nachnamen mit einer relativ hohen Qualität verglichen werden sollen. </p><br><h3 id="metaphone">  Metaphon </h3><br><p>  In den 90er Jahren schlug Lawrence Philips (Lawrence Philips) eine alternative Version des Soundex-Algorithmus vor, der als Metaphone bezeichnet wurde.  Der neue Algorithmus verwendete ein größeres Regelwerk für die englische Aussprache, aufgrund dessen es genauer war.  Später wurde der Algorithmus geändert, um in anderen Sprachen verwendet zu werden, basierend auf der Transkription unter Verwendung von Buchstaben des lateinischen Alphabets. </p><br><h3 id="russkiy-metaphone">  Russisches Metaphon </h3><br><p>  Im Jahr 2002 veröffentlichte die 8. Ausgabe des Programmer-Magazins einen Artikel von Peter Kankowski über seine Anpassung der englischen Version des Metaphone-Algorithmus.  Diese Version des Algorithmus konvertiert die Quellwörter gemäß den Regeln und Normen der russischen Sprache, wobei der phonetische Klang nicht betonter Vokale und die mögliche "Verschmelzung" von Konsonanten in der Aussprache berücksichtigt werden. </p><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Infolge mehrerer Iterationen entwickelte das in der Einleitung erwähnte Projektteam des Softwareproduktentwicklungsprojekts eine Architekturlösung, deren Schema in der Abbildung dargestellt ist. <br><img src="https://habrastorage.org/webt/fr/yx/dg/fryxdgd4sf1lcf1iachctg_rvqc.png"></p><br><p>  Textbeschreibungen von Patienten werden über den REST-Service akzeptiert und unverändert im Repository (Kartendatenbank) gespeichert.  Da unser System mit medizinischen Daten arbeitet, wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FHIR-</a> Standard (Fast Healthcare Interoperability Resources) für den Informationsaustausch gewählt.  Informationen über die empfangene Patientenkarte werden zur weiteren Analyse und Entscheidungsfindung beim Aufbau der Kommunikation in die Nachrichtenwarteschlange übertragen. </p><br><p>  Die erste Karte, die verarbeitet wird, ist der <em>„Quick Analyzer“</em> , der mit einem deterministischen Algorithmus arbeitet.  Wenn alle Regeln des deterministischen Algorithmus ausgearbeitet wurden, wird ein Datensatz mit einer Verknüpfung zur verarbeiteten Karte in einem separaten Speicher (Verknüpfungsdatenbank) erstellt.  Der Datensatz enthält zusätzlich zur Kennung der analysierten Karte das Datum der Kommunikationsherstellung und eine bedingte Kennung, die den global identifizierten Patienten identifiziert.  Weitere Karten werden weiter auf die angegebene globale Kennung bezogen, wodurch ein Array gebildet wird, das eine bestimmte Person beschreibt. </p><br><p>  Wenn der deterministische Algorithmus keine Übereinstimmung findet, werden die Karteninformationen über die Nachrichtenwarteschlange an den „Full Analyzer“ übertragen. </p><br><p>       (  ).       .       : </p><br><p><img src="https://habrastorage.org/webt/i8/_7/-k/i8_7-km0ifcsu6llsqhmsruperg.png"></p><br><p> <strong> 1.  -</strong> <br>            ,       .          2. </p><br><p> <strong> 2.  </strong> <br>    -       ,         (). </p><br><p> <strong> 3.  </strong> <br>        ,    ,   (  )  ,      . </p><br><p> <strong> 4.   </strong> <br>     ,        .         .       ,      ,     .       ,   ,    ,         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417465/">https://habr.com/ru/post/de417465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417453/index.html">Organisation von Praktika für Studenten: Rechen und Tricks</a></li>
<li><a href="../de417457/index.html">Frontend Conf Moscow - Kundenseite rein und raus</a></li>
<li><a href="../de417459/index.html">Kennen Sie Ihre JIT: näher am Auto</a></li>
<li><a href="../de417461/index.html">Ivan Tulup: asynchron in JS unter der Haube</a></li>
<li><a href="../de417463/index.html">Ein unerwartetes Treffen. Kapitel 17</a></li>
<li><a href="../de417469/index.html">Fünf egoistische Gründe, reproduzierbar zu arbeiten</a></li>
<li><a href="../de417471/index.html">Einfaches Lot MK936 SMD. DIY Lötstation für SMD-Komponenten</a></li>
<li><a href="../de417473/index.html">Vertrauenswürdiger Speicher mit DRBD9 und Proxmox (Teil 1: NFS)</a></li>
<li><a href="../de417475/index.html">Glusterfs + Löschcodierung: Wenn Sie viel brauchen, billig und zuverlässig</a></li>
<li><a href="../de417477/index.html">Hot Desking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>