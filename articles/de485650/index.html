<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 ✌️ 🔺 Docker-Bildverkleinerungstechniken 👩🏻‍🍳 🧑🏿 ☦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie sich jemals gefragt, warum ein Docker-Container mit nur einer Anwendung etwa 400 MB groß sein kann? Oder haben Sie sich Sorgen über die Größ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker-Bildverkleinerungstechniken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  Haben Sie sich jemals gefragt, warum ein Docker-Container mit nur einer Anwendung etwa 400 MB groß sein kann?  Oder haben Sie sich Sorgen über die Größe des Docker-Images gemacht, das eine einzelne Binärdatei mit mehreren zehn MB enthält? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, möchte die Hauptfaktoren analysieren, die sich auf die Größe der Docker-Container auswirken.  Darüber hinaus wird er Empfehlungen zur Verringerung der Größe von Containern aussprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Docker-Bildebenen</font> </h2><br>  Ein Bild eines Docker-Containers ist im Wesentlichen eine Sammlung von Dateien, die in mehreren Ebenen übereinander gestapelt sind.  Aus diesen Dateien wird ein Arbeitscontainer zusammengestellt.  Docker verwendet das <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS-</a> Dateisystem, in dem Dateien in Ebenen gruppiert sind.  Eine Ebene kann eine Datei oder mehrere Dateien enthalten, Ebenen überlappen sich.  Während der Ausführung des Containers werden die Inhalte der Ebenen zusammengefasst, so dass der Endbenutzer des Containers die in Ebenen angeordneten Materialien als ein einziges Dateisystem wahrnimmt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Vereinfachte UnionFS-Ansicht</font></i> <br><br>  Das resultierende Dateisystem wird dem Endbenutzer mithilfe einer UnionFS-Implementierung präsentiert (Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">unterstützt</a> viele ähnliche Implementierungen über Plug-in-Speichertreiber).  Die Gesamtgröße der vom Endbenutzer empfangenen Dateien entspricht der Summe der Dateigrößen in den Ebenen.  Wenn Docker einen Container basierend auf dem Bild erstellt, werden alle schreibgeschützten Ebenen des Bildes verwendet, wobei eine dünne Ebene über diesen Ebenen hinzugefügt wird, die das Lesen und Schreiben unterstützt.  Auf dieser Ebene können Sie Dateien in einem laufenden Container ändern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">Der ausgeführte Container enthält eine Lese- / Schreibebene, die sich über schreibgeschützten Ebenen befindet</font></i> <br><br>  Was passiert, wenn eine Datei in der <code>Layer 4</code> oben schematisch dargestellten Containers gelöscht wird?  Obwohl diese Datei im Dateisystem, das der Benutzer sieht, nicht verfügbar ist, ist die Größe dieser Datei immer noch eine der Komponenten der Containergröße, da diese Datei in einer der schreibgeschützten Ebenen verbleibt. <br><br>  Es ist ganz einfach, das Image mit einer kleinen ausführbaren Anwendungsdatei zu erstellen und zum sehr großen Image zu gelangen.  Im Folgenden werden verschiedene Methoden vorgestellt, um Container so klein wie möglich zu machen. <br><br><h2>  <font color="#3AC1EF">Achten Sie auf den Pfad zum Ordner, der auf den Materialien basiert, von denen Bilder gesammelt werden</font> </h2><br>  Wie werden Docker-Images am häufigsten zusammengestellt?  Anscheinend - so: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  Der Punkt in diesem Befehl teilt Docker mit, dass das aktuelle Arbeitsverzeichnis das Stammverzeichnis des Dateisystems ist, das für den Image-Assembly-Prozess verwendet wird. <br><br>  Um besser zu verstehen, was passiert, nachdem der obige Befehl ausgeführt wurde, sollte beachtet werden, dass das Erstellen eines Docker-Images ein Client-Server-Prozess ist.  Die Docker-Befehlszeilenschnittstelle (Client), an die wir den <code>docker build</code> , verwendet die Docker-Engine (Server), um das Container-Image zu erstellen.  Um den Zugriff auf das Basisdateisystem des Clients einzuschränken, muss das Image-Assembly-System wissen, wo sich das Stammverzeichnis des virtuellen Dateisystems befindet.  Dort suchen die Anweisungen aus der <code>Dockerfile</code> Datei nach <code>Dockerfile</code> , die möglicherweise im zusammengestellten Image enden. <br><br>  Stellen Sie sich einen Ort vor, an dem <code>Dockerfile</code> normalerweise eine <code>Dockerfile</code> .  Dies ist wahrscheinlich das Stammverzeichnis des Projekts?  Befindet sich im Stammverzeichnis des Projekts eine <code>Dockerfile</code> , die vom <code>docker build</code> zum Erstellen des Abbilds verwendet wird, können alle Projektdateien in das Abbild aufgenommen werden.  Dies kann dazu führen, dass Tausende von Junk-Dateien mit einer Größe von mehreren Megabyte in den Kontext der Image-Assembly gelangen.  Wenn Sie die Befehle <code>Dockerfile</code> und <code>Dockerfile</code> in der <code>Dockerfile</code> leicht verwenden, werden alle Projektdateien möglicherweise Teil des fertigen Abbilds.  In den meisten Fällen benötigen diejenigen, die Bilder sammeln, dies nicht, da das endgültige Bild normalerweise nur einige ausgewählte Dateien enthalten sollte. <br><br>  <code>Dockerfile</code> immer sicher, dass der <code>docker build</code> Befehl <code>docker build</code> richtigen Pfad <code>docker build</code> und dass keine Befehle in der <code>Dockerfile</code> Datei vorhanden sind, die dem Image unnötige Dateien hinzufügen.  Wenn Sie aus irgendeinem Grund das Stammverzeichnis des Projekts zum Erstellungskontext machen müssen, können Sie Dateien selektiv einschließen und sie mithilfe von <code>.dockerignore</code> davon <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Bildebenen optimieren</font> </h2><br>  Ein Image kann maximal 127 Ebenen haben (sofern der Data Warehouse-Treiber eine solche Anzahl von Ebenen unterstützt).  Diese Einschränkung kann, falls unbedingt erforderlich, gelockert werden, aber mit diesem Ansatz wird der Bereich von Systemen, auf denen solche Bilder gesammelt werden können, eingeschränkt.  Der Punkt ist, dass die Docker-Engine auf einem System ausgeführt werden muss, dessen Kernel entsprechend geändert wurde. <br><br>  Wie im vorherigen Abschnitt erwähnt, bleiben Dateien, die in eine bestimmte Ebene fallen, dort, da UnionFS beim Zusammenstellen von Bildern verwendet wird, selbst dann, wenn sie aus den darüber liegenden Ebenen gelöscht wurden.  Lass es uns mit dem experimentellen Dockerfile herausfinden: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Lassen Sie uns das Bild zusammenbauen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Zusammenstellung eines experimentellen Bildes, in dem irrational genutzter Raum vorhanden ist</font></i> <br><br>  Erkunde das Bild mit einem <a href="https://github.com/wagoodman/dive">Tauchgang</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">Der Bildleistungsindikator ist 34%</font></i> <br><br>  Der Bildeffizienzindikator von 34% zeigt an, dass eine beträchtliche Menge an Bildraum irrational verwendet wird.  Dies führt zu einer Verlängerung der Startzeit des Images, zu einer unnötigen Verschwendung von Netzwerkressourcen und zu einer langsameren Startzeit des Containers. <br><br>  Wie dieses Problem loswerden?  Betrachten wir mehrere Optionen. <br><br><h3>  <font color="#3AC1EF">▍ Teamarbeitsergebnisse zusammenführen</font> </h3><br>  Haben Sie jemals <code>Dockerfile</code> gesehen, die sehr lange <code>RUN</code> Anweisungen enthalten, in denen viele Shell-Befehle mit <code>&amp;&amp;</code> kombiniert werden?  Dies ist der Zusammenschluss der Ergebnisse der Teams. <br><br>  Mit dieser Methode erstellen wir basierend auf den Ergebnissen eines einzelnen langen Teams nur eine Ebene.  Da das Bild keine Ebenen enthält, die in den folgenden Ebenen gelöschte Dateien enthalten, enthält das endgültige Bild keine solchen „Geisterdateien“.  Betrachten Sie dies als ein Beispiel und bringen Sie die obige <code>Dockerfile</code> in diesen Zustand: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Danach analysieren wir das Bild: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">Durch das Zusammenführen von Teams konnten Sie ein zu 100% optimiertes Image erstellen</font></i> <br><br>  Die Anwendung dieser Technik zum Optimieren der Größe von Bildern in der Praxis besteht darin, dass Sie nach Abschluss der Arbeit an der <code>Dockerfile</code> Datei diese analysieren und herausfinden müssen, ob das Zusammenführen von <code>Dockerfile</code> verwendet werden kann, um den verschwendeten Speicherplatz zu verringern. <br><br><h3>  <font color="#3AC1EF">▍Anwenden der Option --squash</font> </h3><br>  In Fällen, in denen Sie <code>Dockerfile</code> anderer Personen <code>Dockerfile</code> , die Sie nicht ändern möchten oder können, können Sie alternativ zum Zusammenführen von Befehlen ein Bild mit der Option <code>--squash</code> . <br><br>  In modernen Docker-Versionen (ab 1.13) können Sie alle Ebenen in einer Ebene zusammenfassen und so "Geister-Ressourcen" entfernen.  In diesem Fall können Sie die ursprüngliche, nicht <code>Dockerfile</code> , die viele separate Befehle enthält.  Sie müssen das Image jedoch mit der Option <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  Das resultierende Bild ist zu 100% optimiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">Durch die Verwendung der Option --squash während der Montage konnte ein zu 100% optimiertes Bild erstellt werden</font></i> <br><br>  Hier können Sie auf ein interessantes Detail achten.  In <code>Dockerfile</code> eine Ebene zum Hinzufügen einer Datei und eine weitere Ebene zum Löschen dieser Datei erstellt.  Die Option <code>--squash</code> ist intelligent genug, um zu verstehen, dass Sie in diesem Szenario überhaupt keine zusätzlichen Ebenen erstellen müssen (im endgültigen Bild gibt es nur <code>9ccd9…</code> aus dem von uns verwendeten Basis-Image).  Im Allgemeinen können wir dafür <code>--squash</code> ein zusätzliches Plus setzen.  <code>--squash</code> , mit <code>--squash</code> müssen Sie berücksichtigen, dass dies die Verwendung von zwischengespeicherten Ebenen beeinträchtigen kann. <br><br>  Daher wird empfohlen, die Tatsache zu berücksichtigen, dass Sie bei der Arbeit mit der <code>Dockerfile</code> - <code>Dockerfile</code> anderen <code>Dockerfile</code> , die Sie nicht ändern <code>Dockerfile</code> , den irrational <code>--squash</code> Bildspeicherplatz minimieren können, indem Sie Bilder mit der Option <code>--squash</code> .  Um das fertige Bild zu analysieren, können Sie das <a href="https://github.com/wagoodman/dive">Tauchwerkzeug</a> verwenden. <br><br><h2>  <font color="#3AC1EF">Löschen Sie Caches und temporäre Dateien</font> </h2><br>  Beim Containerisieren von Anwendungen tritt häufig eine Situation auf, in der Sie zusätzliche Tools, Bibliotheken und Dienstprogramme in das Image einfügen müssen.  Dies geschieht mit Paketmanagern wie <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Paketmanager bemühen sich, dem Benutzer Zeit zu sparen und seine Netzwerkverbindung bei der Installation von Paketen nicht erneut zu laden.  Daher werden heruntergeladene Daten zwischengespeichert.  Damit das endgültige Docker-Image so klein wie möglich wird, müssen in diesem Image keine Paketmanager-Caches gespeichert werden.  Wenn wir jemals ein anderes Image benötigen, können wir es immer mit dem aktualisierten <code>Dockerfile</code> neu <code>Dockerfile</code> . <br><br>  Um die von den drei oben genannten gängigen Paketmanagern erstellten Caches zu entfernen, können Sie am Ende eines aggregierten Befehls (dh eines Befehls, der zum Erstellen einer Ebene ausgeführt wird) Folgendes hinzufügen: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Aus diesem Grund wird empfohlen, vor Abschluss der Arbeiten an der <code>Dockerfile</code> hinzuzufügen <code>Dockerfile</code> mit denen die Caches der zum Erstellen des Abbilds verwendeten Paketmanager entfernt werden.  Gleiches gilt für temporäre Dateien, die den ordnungsgemäßen Betrieb des Containers nicht beeinträchtigen. <br><br><h2>  <font color="#3AC1EF">Wählen Sie Ihr Basisimage sorgfältig aus</font> </h2><br>  Jede <code>Dockerfile</code> beginnt mit einer <code>FROM</code> Direktive.  Hier legen wir das Grundbild fest, auf dessen Grundlage unser Bild erstellt wird. <br><br>  In der Docker- <a href="https://docs.docker.com/engine/reference/builder/">Dokumentation</a> heißt es dazu: „Der <code>FROM</code> Befehl initialisiert eine neue Erstellungsphase und richtet das Basisimage für die folgenden Anweisungen ein.  Aus diesem Grund sollte eine ordnungsgemäß erstellte <code>Dockerfile</code> mit einer <code>FROM</code> Anweisung beginnen.  Ein Bild kann ein beliebiges bearbeitbares Bild sein.  Am einfachsten ist es, ein eigenes Image zu erstellen, das auf einem Image aus einem öffentlichen Repository basiert. " <br><br>  Offensichtlich gibt es viele grundlegende Bilder, von denen jedes seine eigenen Merkmale und Fähigkeiten hat.  Die richtige Auswahl eines Basisbilds, das genau das enthält, was die Anwendung benötigt, nicht mehr und nicht weniger, hat einen enormen Einfluss auf die Größe des endgültigen Bilds. <br><br>  Wie zu erwarten ist, variieren die Größen der gängigen Basisbilder enorm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Größen der populären grundlegenden Dockerbilder</font></i> <br><br>  Die Containerisierung der Anwendung mit dem Basis-Image von <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> führt also dazu, dass die Größe des Images zusätzlich zur Größe der Anwendung um weitere 73 MB erhöht wird.  Sammeln wir das gleiche Bild auf Basis des Bildes von <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , so erhalten wir nur einen "Zusatz" in Höhe von 6 MB.  Da Docker Bildebenen zwischenspeichert, werden Netzwerkressourcen nur dann für das Laden eines Bildes aufgewendet, wenn der Container zum ersten Mal auf geeignete Weise gestartet wird (mit anderen Worten, wenn das Bild zum ersten Mal geladen wird).  Die Größe des Bildes selbst wird dadurch aber nicht kleiner. <br><br>  Hier können Sie zu folgendem (völlig logischen) Schluss kommen: "Also - ich werde immer Alpine verwenden!".  Leider ist in der Welt der Softwareentwicklung nicht alles so einfach. <br><br>  Vielleicht haben <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">Alpine Linux-Entwickler</a> eine geheime Zutat entdeckt, die Ubuntu oder Debian immer noch nicht finden können?  Nein.  Tatsache ist, dass die alpinen Entwickler, um ein Docker-Image zu erstellen, dessen Größe um eine Größenordnung kleiner ist als die Größe des Images desselben Debians, einige Entscheidungen darüber treffen mussten, was in das Image aufgenommen werden muss und was nicht.  Bevor Sie das Basis-Image, das Sie immer verwenden, als Alpine bezeichnen, sollten Sie fragen, ob es alles enthält, was Sie benötigen.  Obwohl Alpine über einen Paketmanager verfügt, kann es sein, dass das in Ihrer Arbeitsumgebung verwendete Paket, das beispielsweise auf Ubuntu basiert, in Alpine nicht verfügbar ist.  Oder - kein Paket, sondern die gewünschte Version des Pakets.  Dies sind die Kompromisse, die Sie berücksichtigen sollten, bevor Sie das für Ihr Projekt am besten geeignete Basisimage auswählen und testen. <br><br>  Und schließlich können Sie mit dem Tool die Bildgröße minimieren, wenn Sie wirklich eines der größten Basisbilder benötigen.  Zum Beispiel - ein kostenloses Open-Source-Tool <a href="https://dockersl.im/">DockerSlim</a> .  Dadurch wird das fertige Bild verkleinert. <br><br>  Am Ende können wir sagen, dass die Verwendung eines sorgfältig ausgewählten Basisbildes für die Erstellung Ihrer eigenen kompakten Bilder äußerst wichtig ist.  Bewerten Sie die Anforderungen Ihres Projekts, und wählen Sie ein Bild aus, das das enthält, was Sie benötigen, und das gleichzeitig für Sie akzeptable Abmessungen aufweist. <br><br><h2>  <font color="#3AC1EF">Ziehen Sie in Betracht, ein Bild zu erstellen, das kein Basisbild enthält.</font> </h2><br>  Wenn Ihre Anwendung ohne eine zusätzliche, grundlegend bereitgestellte Umgebung ausgeführt werden kann, entscheiden Sie sich möglicherweise dafür, kein Basis-Image zu verwenden.  Da der <code>FROM</code> Befehl in der <code>Dockerfile</code> vorhanden sein <code>Dockerfile</code> , können Sie <code>Dockerfile</code> nicht darauf verzichten.  Sie muss außerdem auf eine Art Bild verweisen.  Welches Bild soll man in einer solchen Situation verwenden? <br><br>  Ein <a href="https://hub.docker.com/_/scratch">Kratzerblick</a> könnte hier nützlich sein.  <code>Dockerfile</code> seiner Beschreibung können Sie feststellen, dass es speziell für die Erstellung von Bildern leer gemacht wurde, wenn Sie die <code>Dockerfile</code> Sprache <code>FROM scratch</code> (von Grund auf <code>FROM scratch</code> sprechen.  Dieses Image ist besonders nützlich, wenn grundlegende Images (wie Debian- und Busybox-Images) oder extrem minimale Images (solche, die eine einzelne Binärdatei enthalten und für deren Betrieb beispielsweise so etwas wie Hallo-Welt erforderlich sind) erstellt werden.  Die Verwendung dieses Abbilds als Grundlage für das von <code>Dockerfile</code> beschriebene <code>Dockerfile</code> ähnelt der Verwendung eines "leeren Vorgangs" in einigen Programmen.  Durch das Anwenden eines <code>scratch</code> wird im fertigen Bild keine zusätzliche Ebene erstellt. <br><br>  Wenn es sich bei Ihrer Anwendung um eine eigenständige ausführbare Datei handelt, die eigenständig arbeiten kann, können Sie durch Auswahl des Basis- <code>scratch</code> Image die Größe des Containers minimieren. <br><br><h2>  <font color="#3AC1EF">Verwenden Sie mehrstufige Builds</font> </h2><br>  Seit Docker 05/17 stehen mehrstufige Builds im Mittelpunkt des Interesses.  Es war eine Gelegenheit, auf die man lange gewartet hatte.  Es ermöglicht Image Buildern, ihre eigenen Skripte zu verlassen, um Images zu erstellen und alles <code>Dockerfile</code> mit dem bekannten <code>Dockerfile</code> Format zu <code>Dockerfile</code> . <br><br>  Im Allgemeinen kann eine mehrstufige Assembly als Kombination mehrerer <code>Dockerfile</code> oder als <code>Dockerfile</code> mit mehreren <code>FROM</code> Anweisungen betrachtet werden. <br><br>  Wenn Sie vor dem Entstehen von mehrstufigen Assemblys eine Assembly Ihres Projekts erstellen und mithilfe der <code>Dockerfile</code> in einem Container verteilen <code>Dockerfile</code> , müssten Sie wahrscheinlich den Assembly-Vorgang ausführen, der zum Erscheinen eines Containers wie dem folgenden führen würde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Erstellen und verteilen Sie eine Anwendung, ohne mehrstufige Build-Technologie zu verwenden</font></i> <br><br>  Obwohl aus technischer Sicht alles richtig gemacht wurde, werden das endgültige Bild und der resultierende Container mit Ebenen gefüllt, die bei der Vorbereitung der Projektmaterialien erstellt wurden.  Und diese Schichten werden nicht benötigt, um die Projektlaufzeitumgebung zu bilden. <br><br>  Mit mehrstufigen Baugruppen können Sie die Phasen der Erstellung und Vorbereitung von Projektmaterialien von der Umgebung trennen, in der der Projektcode ausgeführt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Mehrstufige Montage, Trennung des Erstellungsprozesses und der Vorbereitung des Projektmaterials von der Ausführungsumgebung</font></i> <br><br>  Gleichzeitig reicht eine einzige <code>Dockerfile</code> aus, um den gesamten Prozess der Projekterstellung zu beschreiben.  Jetzt können Sie jedoch Material von einer Phase in eine andere kopieren und unnötige Daten entfernen. <br><br>  Mit mehrstufigen Assemblys können Sie plattformübergreifende Assemblys erstellen, die wiederholt verwendet werden können, ohne eigene Assemblyskripts zu verwenden, die für ein bestimmtes Betriebssystem geschrieben wurden.  Die endgültige Größe des Bildes kann aufgrund der Möglichkeit des selektiven Einschlusses von Materialien minimiert werden, die in den vorherigen Stufen des Bildzusammensetzungsprozesses erzeugt wurden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Das Erstellen von Docker-Container-Images ist ein Prozess, mit dem sich moderne Programmierer häufig befassen müssen.  Es gibt viele Ressourcen zum Erstellen von <code>Dockerfile</code> , und im Internet finden Sie viele Beispiele für solche Dateien.  <code>Dockerfile</code> was Sie verwenden, ist es bei der Erstellung Ihrer eigenen <code>Dockerfile</code> immer <code>Dockerfile</code> die Größe der resultierenden Bilder zu berücksichtigen. <br><br>  Hier haben wir uns verschiedene Techniken zum Minimieren der Größe von Docker-Bildern angesehen.  Die Aufmerksamkeit für den Inhalt der <code>Dockerfile</code> , einschließlich der <code>Dockerfile</code> , die Sie wirklich benötigen, die Auswahl des richtigen Basis-Images mithilfe der mehrstufigen Build-Technologie - all dies kann dazu beitragen, die Größe der von Ihnen erstellten Docker-Images erheblich zu verringern. <br><br>  <b>PS</b> Wir haben den <a href="https://ruvds.com/ru-rub/marketplace">Marktplatz</a> auf der RUVDS-Website gestartet.  Auf dem Marktplatz wird das <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker-</a> Image mit einem Klick installiert, Sie können überprüfen, wie die Container auf <a href="https://ruvds.com/">VPS</a> funktionieren, 3 Testtage werden kostenlos für alle Neukunden zur Verfügung gestellt. <br><br>  <b>Sehr geehrte Leser!</b>  Wie optimieren Sie die Größe Ihrer Docker-Bilder? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485650/">https://habr.com/ru/post/de485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485634/index.html">Das Dungeons and Dragons-Dashboard hat mir geholfen, Englisch zu lernen</a></li>
<li><a href="../de485636/index.html">CRISPR-resistente Viren bauen Schutzräume, um das Genom vor DNA-durchdringenden Enzymen zu schützen</a></li>
<li><a href="../de485640/index.html">Methoden zum Ausblenden von Webseiten</a></li>
<li><a href="../de485646/index.html">Nützliche Python-Tipps, die Sie noch nie zuvor getroffen haben. Teil 2</a></li>
<li><a href="../de485648/index.html">Der pythonische Ansatz für for: range () - und enumerate () - Schleifen</a></li>
<li><a href="../de485652/index.html">Beeinflussen Sie die Statistik der Inline-Kommentare</a></li>
<li><a href="../de485654/index.html">Eine Idee aus der Physik hilft der KI, in höheren Dimensionen zu arbeiten.</a></li>
<li><a href="../de485660/index.html">Das DDoS-Schutzunternehmen selbst habe DDoS-Angriffe gestartet, gab sein Gründer zu</a></li>
<li><a href="../de485664/index.html">Erstellen dynamischer Parameter in einem Jenkins-Job oder wie Sie Ihre Aufgabe benutzerfreundlich gestalten können</a></li>
<li><a href="../de485672/index.html">Redis Best Practices, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>