<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèΩ ‚úåÔ∏è üî∫ Docker-Bildverkleinerungstechniken üë©üèª‚Äçüç≥ üßëüèø ‚ò¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie sich jemals gefragt, warum ein Docker-Container mit nur einer Anwendung etwa 400 MB gro√ü sein kann? Oder haben Sie sich Sorgen √ºber die Gr√∂√ü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker-Bildverkleinerungstechniken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  Haben Sie sich jemals gefragt, warum ein Docker-Container mit nur einer Anwendung etwa 400 MB gro√ü sein kann?  Oder haben Sie sich Sorgen √ºber die Gr√∂√üe des Docker-Images gemacht, das eine einzelne Bin√§rdatei mit mehreren zehn MB enth√§lt? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  Der Autor des Artikels, dessen √úbersetzung wir heute ver√∂ffentlichen, m√∂chte die Hauptfaktoren analysieren, die sich auf die Gr√∂√üe der Docker-Container auswirken.  Dar√ºber hinaus wird er Empfehlungen zur Verringerung der Gr√∂√üe von Containern aussprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Docker-Bildebenen</font> </h2><br>  Ein Bild eines Docker-Containers ist im Wesentlichen eine Sammlung von Dateien, die in mehreren Ebenen √ºbereinander gestapelt sind.  Aus diesen Dateien wird ein Arbeitscontainer zusammengestellt.  Docker verwendet das <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS-</a> Dateisystem, in dem Dateien in Ebenen gruppiert sind.  Eine Ebene kann eine Datei oder mehrere Dateien enthalten, Ebenen √ºberlappen sich.  W√§hrend der Ausf√ºhrung des Containers werden die Inhalte der Ebenen zusammengefasst, so dass der Endbenutzer des Containers die in Ebenen angeordneten Materialien als ein einziges Dateisystem wahrnimmt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Vereinfachte UnionFS-Ansicht</font></i> <br><br>  Das resultierende Dateisystem wird dem Endbenutzer mithilfe einer UnionFS-Implementierung pr√§sentiert (Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">unterst√ºtzt</a> viele √§hnliche Implementierungen √ºber Plug-in-Speichertreiber).  Die Gesamtgr√∂√üe der vom Endbenutzer empfangenen Dateien entspricht der Summe der Dateigr√∂√üen in den Ebenen.  Wenn Docker einen Container basierend auf dem Bild erstellt, werden alle schreibgesch√ºtzten Ebenen des Bildes verwendet, wobei eine d√ºnne Ebene √ºber diesen Ebenen hinzugef√ºgt wird, die das Lesen und Schreiben unterst√ºtzt.  Auf dieser Ebene k√∂nnen Sie Dateien in einem laufenden Container √§ndern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">Der ausgef√ºhrte Container enth√§lt eine Lese- / Schreibebene, die sich √ºber schreibgesch√ºtzten Ebenen befindet</font></i> <br><br>  Was passiert, wenn eine Datei in der <code>Layer 4</code> oben schematisch dargestellten Containers gel√∂scht wird?  Obwohl diese Datei im Dateisystem, das der Benutzer sieht, nicht verf√ºgbar ist, ist die Gr√∂√üe dieser Datei immer noch eine der Komponenten der Containergr√∂√üe, da diese Datei in einer der schreibgesch√ºtzten Ebenen verbleibt. <br><br>  Es ist ganz einfach, das Image mit einer kleinen ausf√ºhrbaren Anwendungsdatei zu erstellen und zum sehr gro√üen Image zu gelangen.  Im Folgenden werden verschiedene Methoden vorgestellt, um Container so klein wie m√∂glich zu machen. <br><br><h2>  <font color="#3AC1EF">Achten Sie auf den Pfad zum Ordner, der auf den Materialien basiert, von denen Bilder gesammelt werden</font> </h2><br>  Wie werden Docker-Images am h√§ufigsten zusammengestellt?  Anscheinend - so: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  Der Punkt in diesem Befehl teilt Docker mit, dass das aktuelle Arbeitsverzeichnis das Stammverzeichnis des Dateisystems ist, das f√ºr den Image-Assembly-Prozess verwendet wird. <br><br>  Um besser zu verstehen, was passiert, nachdem der obige Befehl ausgef√ºhrt wurde, sollte beachtet werden, dass das Erstellen eines Docker-Images ein Client-Server-Prozess ist.  Die Docker-Befehlszeilenschnittstelle (Client), an die wir den <code>docker build</code> , verwendet die Docker-Engine (Server), um das Container-Image zu erstellen.  Um den Zugriff auf das Basisdateisystem des Clients einzuschr√§nken, muss das Image-Assembly-System wissen, wo sich das Stammverzeichnis des virtuellen Dateisystems befindet.  Dort suchen die Anweisungen aus der <code>Dockerfile</code> Datei nach <code>Dockerfile</code> , die m√∂glicherweise im zusammengestellten Image enden. <br><br>  Stellen Sie sich einen Ort vor, an dem <code>Dockerfile</code> normalerweise eine <code>Dockerfile</code> .  Dies ist wahrscheinlich das Stammverzeichnis des Projekts?  Befindet sich im Stammverzeichnis des Projekts eine <code>Dockerfile</code> , die vom <code>docker build</code> zum Erstellen des Abbilds verwendet wird, k√∂nnen alle Projektdateien in das Abbild aufgenommen werden.  Dies kann dazu f√ºhren, dass Tausende von Junk-Dateien mit einer Gr√∂√üe von mehreren Megabyte in den Kontext der Image-Assembly gelangen.  Wenn Sie die Befehle <code>Dockerfile</code> und <code>Dockerfile</code> in der <code>Dockerfile</code> leicht verwenden, werden alle Projektdateien m√∂glicherweise Teil des fertigen Abbilds.  In den meisten F√§llen ben√∂tigen diejenigen, die Bilder sammeln, dies nicht, da das endg√ºltige Bild normalerweise nur einige ausgew√§hlte Dateien enthalten sollte. <br><br>  <code>Dockerfile</code> immer sicher, dass der <code>docker build</code> Befehl <code>docker build</code> richtigen Pfad <code>docker build</code> und dass keine Befehle in der <code>Dockerfile</code> Datei vorhanden sind, die dem Image unn√∂tige Dateien hinzuf√ºgen.  Wenn Sie aus irgendeinem Grund das Stammverzeichnis des Projekts zum Erstellungskontext machen m√ºssen, k√∂nnen Sie Dateien selektiv einschlie√üen und sie mithilfe von <code>.dockerignore</code> davon <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Bildebenen optimieren</font> </h2><br>  Ein Image kann maximal 127 Ebenen haben (sofern der Data Warehouse-Treiber eine solche Anzahl von Ebenen unterst√ºtzt).  Diese Einschr√§nkung kann, falls unbedingt erforderlich, gelockert werden, aber mit diesem Ansatz wird der Bereich von Systemen, auf denen solche Bilder gesammelt werden k√∂nnen, eingeschr√§nkt.  Der Punkt ist, dass die Docker-Engine auf einem System ausgef√ºhrt werden muss, dessen Kernel entsprechend ge√§ndert wurde. <br><br>  Wie im vorherigen Abschnitt erw√§hnt, bleiben Dateien, die in eine bestimmte Ebene fallen, dort, da UnionFS beim Zusammenstellen von Bildern verwendet wird, selbst dann, wenn sie aus den dar√ºber liegenden Ebenen gel√∂scht wurden.  Lass es uns mit dem experimentellen Dockerfile herausfinden: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Lassen Sie uns das Bild zusammenbauen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Zusammenstellung eines experimentellen Bildes, in dem irrational genutzter Raum vorhanden ist</font></i> <br><br>  Erkunde das Bild mit einem <a href="https://github.com/wagoodman/dive">Tauchgang</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">Der Bildleistungsindikator ist 34%</font></i> <br><br>  Der Bildeffizienzindikator von 34% zeigt an, dass eine betr√§chtliche Menge an Bildraum irrational verwendet wird.  Dies f√ºhrt zu einer Verl√§ngerung der Startzeit des Images, zu einer unn√∂tigen Verschwendung von Netzwerkressourcen und zu einer langsameren Startzeit des Containers. <br><br>  Wie dieses Problem loswerden?  Betrachten wir mehrere Optionen. <br><br><h3>  <font color="#3AC1EF">‚ñç Teamarbeitsergebnisse zusammenf√ºhren</font> </h3><br>  Haben Sie jemals <code>Dockerfile</code> gesehen, die sehr lange <code>RUN</code> Anweisungen enthalten, in denen viele Shell-Befehle mit <code>&amp;&amp;</code> kombiniert werden?  Dies ist der Zusammenschluss der Ergebnisse der Teams. <br><br>  Mit dieser Methode erstellen wir basierend auf den Ergebnissen eines einzelnen langen Teams nur eine Ebene.  Da das Bild keine Ebenen enth√§lt, die in den folgenden Ebenen gel√∂schte Dateien enthalten, enth√§lt das endg√ºltige Bild keine solchen ‚ÄûGeisterdateien‚Äú.  Betrachten Sie dies als ein Beispiel und bringen Sie die obige <code>Dockerfile</code> in diesen Zustand: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Danach analysieren wir das Bild: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">Durch das Zusammenf√ºhren von Teams konnten Sie ein zu 100% optimiertes Image erstellen</font></i> <br><br>  Die Anwendung dieser Technik zum Optimieren der Gr√∂√üe von Bildern in der Praxis besteht darin, dass Sie nach Abschluss der Arbeit an der <code>Dockerfile</code> Datei diese analysieren und herausfinden m√ºssen, ob das Zusammenf√ºhren von <code>Dockerfile</code> verwendet werden kann, um den verschwendeten Speicherplatz zu verringern. <br><br><h3>  <font color="#3AC1EF">‚ñçAnwenden der Option --squash</font> </h3><br>  In F√§llen, in denen Sie <code>Dockerfile</code> anderer Personen <code>Dockerfile</code> , die Sie nicht √§ndern m√∂chten oder k√∂nnen, k√∂nnen Sie alternativ zum Zusammenf√ºhren von Befehlen ein Bild mit der Option <code>--squash</code> . <br><br>  In modernen Docker-Versionen (ab 1.13) k√∂nnen Sie alle Ebenen in einer Ebene zusammenfassen und so "Geister-Ressourcen" entfernen.  In diesem Fall k√∂nnen Sie die urspr√ºngliche, nicht <code>Dockerfile</code> , die viele separate Befehle enth√§lt.  Sie m√ºssen das Image jedoch mit der Option <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  Das resultierende Bild ist zu 100% optimiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">Durch die Verwendung der Option --squash w√§hrend der Montage konnte ein zu 100% optimiertes Bild erstellt werden</font></i> <br><br>  Hier k√∂nnen Sie auf ein interessantes Detail achten.  In <code>Dockerfile</code> eine Ebene zum Hinzuf√ºgen einer Datei und eine weitere Ebene zum L√∂schen dieser Datei erstellt.  Die Option <code>--squash</code> ist intelligent genug, um zu verstehen, dass Sie in diesem Szenario √ºberhaupt keine zus√§tzlichen Ebenen erstellen m√ºssen (im endg√ºltigen Bild gibt es nur <code>9ccd9‚Ä¶</code> aus dem von uns verwendeten Basis-Image).  Im Allgemeinen k√∂nnen wir daf√ºr <code>--squash</code> ein zus√§tzliches Plus setzen.  <code>--squash</code> , mit <code>--squash</code> m√ºssen Sie ber√ºcksichtigen, dass dies die Verwendung von zwischengespeicherten Ebenen beeintr√§chtigen kann. <br><br>  Daher wird empfohlen, die Tatsache zu ber√ºcksichtigen, dass Sie bei der Arbeit mit der <code>Dockerfile</code> - <code>Dockerfile</code> anderen <code>Dockerfile</code> , die Sie nicht √§ndern <code>Dockerfile</code> , den irrational <code>--squash</code> Bildspeicherplatz minimieren k√∂nnen, indem Sie Bilder mit der Option <code>--squash</code> .  Um das fertige Bild zu analysieren, k√∂nnen Sie das <a href="https://github.com/wagoodman/dive">Tauchwerkzeug</a> verwenden. <br><br><h2>  <font color="#3AC1EF">L√∂schen Sie Caches und tempor√§re Dateien</font> </h2><br>  Beim Containerisieren von Anwendungen tritt h√§ufig eine Situation auf, in der Sie zus√§tzliche Tools, Bibliotheken und Dienstprogramme in das Image einf√ºgen m√ºssen.  Dies geschieht mit Paketmanagern wie <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Paketmanager bem√ºhen sich, dem Benutzer Zeit zu sparen und seine Netzwerkverbindung bei der Installation von Paketen nicht erneut zu laden.  Daher werden heruntergeladene Daten zwischengespeichert.  Damit das endg√ºltige Docker-Image so klein wie m√∂glich wird, m√ºssen in diesem Image keine Paketmanager-Caches gespeichert werden.  Wenn wir jemals ein anderes Image ben√∂tigen, k√∂nnen wir es immer mit dem aktualisierten <code>Dockerfile</code> neu <code>Dockerfile</code> . <br><br>  Um die von den drei oben genannten g√§ngigen Paketmanagern erstellten Caches zu entfernen, k√∂nnen Sie am Ende eines aggregierten Befehls (dh eines Befehls, der zum Erstellen einer Ebene ausgef√ºhrt wird) Folgendes hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Aus diesem Grund wird empfohlen, vor Abschluss der Arbeiten an der <code>Dockerfile</code> hinzuzuf√ºgen <code>Dockerfile</code> mit denen die Caches der zum Erstellen des Abbilds verwendeten Paketmanager entfernt werden.  Gleiches gilt f√ºr tempor√§re Dateien, die den ordnungsgem√§√üen Betrieb des Containers nicht beeintr√§chtigen. <br><br><h2>  <font color="#3AC1EF">W√§hlen Sie Ihr Basisimage sorgf√§ltig aus</font> </h2><br>  Jede <code>Dockerfile</code> beginnt mit einer <code>FROM</code> Direktive.  Hier legen wir das Grundbild fest, auf dessen Grundlage unser Bild erstellt wird. <br><br>  In der Docker- <a href="https://docs.docker.com/engine/reference/builder/">Dokumentation</a> hei√üt es dazu: ‚ÄûDer <code>FROM</code> Befehl initialisiert eine neue Erstellungsphase und richtet das Basisimage f√ºr die folgenden Anweisungen ein.  Aus diesem Grund sollte eine ordnungsgem√§√ü erstellte <code>Dockerfile</code> mit einer <code>FROM</code> Anweisung beginnen.  Ein Bild kann ein beliebiges bearbeitbares Bild sein.  Am einfachsten ist es, ein eigenes Image zu erstellen, das auf einem Image aus einem √∂ffentlichen Repository basiert. " <br><br>  Offensichtlich gibt es viele grundlegende Bilder, von denen jedes seine eigenen Merkmale und F√§higkeiten hat.  Die richtige Auswahl eines Basisbilds, das genau das enth√§lt, was die Anwendung ben√∂tigt, nicht mehr und nicht weniger, hat einen enormen Einfluss auf die Gr√∂√üe des endg√ºltigen Bilds. <br><br>  Wie zu erwarten ist, variieren die Gr√∂√üen der g√§ngigen Basisbilder enorm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Gr√∂√üen der popul√§ren grundlegenden Dockerbilder</font></i> <br><br>  Die Containerisierung der Anwendung mit dem Basis-Image von <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> f√ºhrt also dazu, dass die Gr√∂√üe des Images zus√§tzlich zur Gr√∂√üe der Anwendung um weitere 73 MB erh√∂ht wird.  Sammeln wir das gleiche Bild auf Basis des Bildes von <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , so erhalten wir nur einen "Zusatz" in H√∂he von 6 MB.  Da Docker Bildebenen zwischenspeichert, werden Netzwerkressourcen nur dann f√ºr das Laden eines Bildes aufgewendet, wenn der Container zum ersten Mal auf geeignete Weise gestartet wird (mit anderen Worten, wenn das Bild zum ersten Mal geladen wird).  Die Gr√∂√üe des Bildes selbst wird dadurch aber nicht kleiner. <br><br>  Hier k√∂nnen Sie zu folgendem (v√∂llig logischen) Schluss kommen: "Also - ich werde immer Alpine verwenden!".  Leider ist in der Welt der Softwareentwicklung nicht alles so einfach. <br><br>  Vielleicht haben <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">Alpine Linux-Entwickler</a> eine geheime Zutat entdeckt, die Ubuntu oder Debian immer noch nicht finden k√∂nnen?  Nein.  Tatsache ist, dass die alpinen Entwickler, um ein Docker-Image zu erstellen, dessen Gr√∂√üe um eine Gr√∂√üenordnung kleiner ist als die Gr√∂√üe des Images desselben Debians, einige Entscheidungen dar√ºber treffen mussten, was in das Image aufgenommen werden muss und was nicht.  Bevor Sie das Basis-Image, das Sie immer verwenden, als Alpine bezeichnen, sollten Sie fragen, ob es alles enth√§lt, was Sie ben√∂tigen.  Obwohl Alpine √ºber einen Paketmanager verf√ºgt, kann es sein, dass das in Ihrer Arbeitsumgebung verwendete Paket, das beispielsweise auf Ubuntu basiert, in Alpine nicht verf√ºgbar ist.  Oder - kein Paket, sondern die gew√ºnschte Version des Pakets.  Dies sind die Kompromisse, die Sie ber√ºcksichtigen sollten, bevor Sie das f√ºr Ihr Projekt am besten geeignete Basisimage ausw√§hlen und testen. <br><br>  Und schlie√ülich k√∂nnen Sie mit dem Tool die Bildgr√∂√üe minimieren, wenn Sie wirklich eines der gr√∂√üten Basisbilder ben√∂tigen.  Zum Beispiel - ein kostenloses Open-Source-Tool <a href="https://dockersl.im/">DockerSlim</a> .  Dadurch wird das fertige Bild verkleinert. <br><br>  Am Ende k√∂nnen wir sagen, dass die Verwendung eines sorgf√§ltig ausgew√§hlten Basisbildes f√ºr die Erstellung Ihrer eigenen kompakten Bilder √§u√üerst wichtig ist.  Bewerten Sie die Anforderungen Ihres Projekts, und w√§hlen Sie ein Bild aus, das das enth√§lt, was Sie ben√∂tigen, und das gleichzeitig f√ºr Sie akzeptable Abmessungen aufweist. <br><br><h2>  <font color="#3AC1EF">Ziehen Sie in Betracht, ein Bild zu erstellen, das kein Basisbild enth√§lt.</font> </h2><br>  Wenn Ihre Anwendung ohne eine zus√§tzliche, grundlegend bereitgestellte Umgebung ausgef√ºhrt werden kann, entscheiden Sie sich m√∂glicherweise daf√ºr, kein Basis-Image zu verwenden.  Da der <code>FROM</code> Befehl in der <code>Dockerfile</code> vorhanden sein <code>Dockerfile</code> , k√∂nnen Sie <code>Dockerfile</code> nicht darauf verzichten.  Sie muss au√üerdem auf eine Art Bild verweisen.  Welches Bild soll man in einer solchen Situation verwenden? <br><br>  Ein <a href="https://hub.docker.com/_/scratch">Kratzerblick</a> k√∂nnte hier n√ºtzlich sein.  <code>Dockerfile</code> seiner Beschreibung k√∂nnen Sie feststellen, dass es speziell f√ºr die Erstellung von Bildern leer gemacht wurde, wenn Sie die <code>Dockerfile</code> Sprache <code>FROM scratch</code> (von Grund auf <code>FROM scratch</code> sprechen.  Dieses Image ist besonders n√ºtzlich, wenn grundlegende Images (wie Debian- und Busybox-Images) oder extrem minimale Images (solche, die eine einzelne Bin√§rdatei enthalten und f√ºr deren Betrieb beispielsweise so etwas wie Hallo-Welt erforderlich sind) erstellt werden.  Die Verwendung dieses Abbilds als Grundlage f√ºr das von <code>Dockerfile</code> beschriebene <code>Dockerfile</code> √§hnelt der Verwendung eines "leeren Vorgangs" in einigen Programmen.  Durch das Anwenden eines <code>scratch</code> wird im fertigen Bild keine zus√§tzliche Ebene erstellt. <br><br>  Wenn es sich bei Ihrer Anwendung um eine eigenst√§ndige ausf√ºhrbare Datei handelt, die eigenst√§ndig arbeiten kann, k√∂nnen Sie durch Auswahl des Basis- <code>scratch</code> Image die Gr√∂√üe des Containers minimieren. <br><br><h2>  <font color="#3AC1EF">Verwenden Sie mehrstufige Builds</font> </h2><br>  Seit Docker 05/17 stehen mehrstufige Builds im Mittelpunkt des Interesses.  Es war eine Gelegenheit, auf die man lange gewartet hatte.  Es erm√∂glicht Image Buildern, ihre eigenen Skripte zu verlassen, um Images zu erstellen und alles <code>Dockerfile</code> mit dem bekannten <code>Dockerfile</code> Format zu <code>Dockerfile</code> . <br><br>  Im Allgemeinen kann eine mehrstufige Assembly als Kombination mehrerer <code>Dockerfile</code> oder als <code>Dockerfile</code> mit mehreren <code>FROM</code> Anweisungen betrachtet werden. <br><br>  Wenn Sie vor dem Entstehen von mehrstufigen Assemblys eine Assembly Ihres Projekts erstellen und mithilfe der <code>Dockerfile</code> in einem Container verteilen <code>Dockerfile</code> , m√ºssten Sie wahrscheinlich den Assembly-Vorgang ausf√ºhren, der zum Erscheinen eines Containers wie dem folgenden f√ºhren w√ºrde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Erstellen und verteilen Sie eine Anwendung, ohne mehrstufige Build-Technologie zu verwenden</font></i> <br><br>  Obwohl aus technischer Sicht alles richtig gemacht wurde, werden das endg√ºltige Bild und der resultierende Container mit Ebenen gef√ºllt, die bei der Vorbereitung der Projektmaterialien erstellt wurden.  Und diese Schichten werden nicht ben√∂tigt, um die Projektlaufzeitumgebung zu bilden. <br><br>  Mit mehrstufigen Baugruppen k√∂nnen Sie die Phasen der Erstellung und Vorbereitung von Projektmaterialien von der Umgebung trennen, in der der Projektcode ausgef√ºhrt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Mehrstufige Montage, Trennung des Erstellungsprozesses und der Vorbereitung des Projektmaterials von der Ausf√ºhrungsumgebung</font></i> <br><br>  Gleichzeitig reicht eine einzige <code>Dockerfile</code> aus, um den gesamten Prozess der Projekterstellung zu beschreiben.  Jetzt k√∂nnen Sie jedoch Material von einer Phase in eine andere kopieren und unn√∂tige Daten entfernen. <br><br>  Mit mehrstufigen Assemblys k√∂nnen Sie plattform√ºbergreifende Assemblys erstellen, die wiederholt verwendet werden k√∂nnen, ohne eigene Assemblyskripts zu verwenden, die f√ºr ein bestimmtes Betriebssystem geschrieben wurden.  Die endg√ºltige Gr√∂√üe des Bildes kann aufgrund der M√∂glichkeit des selektiven Einschlusses von Materialien minimiert werden, die in den vorherigen Stufen des Bildzusammensetzungsprozesses erzeugt wurden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Das Erstellen von Docker-Container-Images ist ein Prozess, mit dem sich moderne Programmierer h√§ufig befassen m√ºssen.  Es gibt viele Ressourcen zum Erstellen von <code>Dockerfile</code> , und im Internet finden Sie viele Beispiele f√ºr solche Dateien.  <code>Dockerfile</code> was Sie verwenden, ist es bei der Erstellung Ihrer eigenen <code>Dockerfile</code> immer <code>Dockerfile</code> die Gr√∂√üe der resultierenden Bilder zu ber√ºcksichtigen. <br><br>  Hier haben wir uns verschiedene Techniken zum Minimieren der Gr√∂√üe von Docker-Bildern angesehen.  Die Aufmerksamkeit f√ºr den Inhalt der <code>Dockerfile</code> , einschlie√ülich der <code>Dockerfile</code> , die Sie wirklich ben√∂tigen, die Auswahl des richtigen Basis-Images mithilfe der mehrstufigen Build-Technologie - all dies kann dazu beitragen, die Gr√∂√üe der von Ihnen erstellten Docker-Images erheblich zu verringern. <br><br>  <b>PS</b> Wir haben den <a href="https://ruvds.com/ru-rub/marketplace">Marktplatz</a> auf der RUVDS-Website gestartet.  Auf dem Marktplatz wird das <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker-</a> Image mit einem Klick installiert, Sie k√∂nnen √ºberpr√ºfen, wie die Container auf <a href="https://ruvds.com/">VPS</a> funktionieren, 3 Testtage werden kostenlos f√ºr alle Neukunden zur Verf√ºgung gestellt. <br><br>  <b>Sehr geehrte Leser!</b>  Wie optimieren Sie die Gr√∂√üe Ihrer Docker-Bilder? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485650/">https://habr.com/ru/post/de485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485634/index.html">Das Dungeons and Dragons-Dashboard hat mir geholfen, Englisch zu lernen</a></li>
<li><a href="../de485636/index.html">CRISPR-resistente Viren bauen Schutzr√§ume, um das Genom vor DNA-durchdringenden Enzymen zu sch√ºtzen</a></li>
<li><a href="../de485640/index.html">Methoden zum Ausblenden von Webseiten</a></li>
<li><a href="../de485646/index.html">N√ºtzliche Python-Tipps, die Sie noch nie zuvor getroffen haben. Teil 2</a></li>
<li><a href="../de485648/index.html">Der pythonische Ansatz f√ºr for: range () - und enumerate () - Schleifen</a></li>
<li><a href="../de485652/index.html">Beeinflussen Sie die Statistik der Inline-Kommentare</a></li>
<li><a href="../de485654/index.html">Eine Idee aus der Physik hilft der KI, in h√∂heren Dimensionen zu arbeiten.</a></li>
<li><a href="../de485660/index.html">Das DDoS-Schutzunternehmen selbst habe DDoS-Angriffe gestartet, gab sein Gr√ºnder zu</a></li>
<li><a href="../de485664/index.html">Erstellen dynamischer Parameter in einem Jenkins-Job oder wie Sie Ihre Aufgabe benutzerfreundlich gestalten k√∂nnen</a></li>
<li><a href="../de485672/index.html">Redis Best Practices, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>