<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„äóÔ∏è üê† üì≠ Wie STACKLEAK die Sicherheit des Linux-Kernels verbessert ‚úàÔ∏è üíÉüèª üë∏üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="STACKLEAK ist eine Linux-Kernel-Sicherheitsfunktion, die urspr√ºnglich von den Entwicklern von Grsecurity / PaX entwickelt wurde. Ich beschloss, STACKL...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie STACKLEAK die Sicherheit des Linux-Kernels verbessert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424633/">  STACKLEAK ist eine Linux-Kernel-Sicherheitsfunktion, die urspr√ºnglich von den Entwicklern von Grsecurity / PaX entwickelt wurde.  Ich beschloss, STACKLEAK auf den offiziellen Vanille-Kernel (Linux-Kernel-Mainline) zu bringen.  In diesem Artikel werden die interne Struktur, die Eigenschaften dieser Sicherheitsfunktion und ihr sehr langer, schwieriger Pfad in der Hauptzeile erl√§utert. <br><br><img src="https://habrastorage.org/webt/px/95/j_/px95j_edhs60awthgfeytj9uz84.png"><br><br><a name="habracut"></a><br><br>  STACKLEAK sch√ºtzt vor mehreren Klassen von Schwachstellen im Linux-Kernel, n√§mlich: <br><br><ul><li>  reduziert die f√ºr den Angreifer n√ºtzlichen Informationen, die vom Nuklearstapel in den Benutzerraum gelangen k√∂nnen; </li><li>  blockiert einige Angriffe auf nicht initialisierte Variablen im Kernel-Stack; </li><li>  Bietet dynamische Tools zur Erkennung von Stapel√ºberl√§ufen. </li></ul><br>  Diese Sicherheitsfunktion passt perfekt zum Konzept des Kernel Self Protection Project (KSPP): Sicherheit ist mehr als nur das Beheben von Fehlern.  Absolut alle Fehler im Code k√∂nnen nicht behoben werden, und daher sollte der Linux-Kernel in Fehlersituationen sicher funktionieren, auch wenn versucht wird, Schwachstellen auszunutzen.  Weitere Details zu KSPP finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Projekt-Wiki</a> . <br><br>  STACKLEAK ist im grsecurity / PaX-Patch als PAX_MEMORY_STACKLEAK vorhanden.  Der grsecurity / PaX-Patch wird jedoch seit April 2017 nicht mehr frei verbreitet.  Daher w√§re das Erscheinen von STACKLEAK im Vanillekern f√ºr Linux-Benutzer mit erh√∂hten Anforderungen an die Informationssicherheit von Nutzen. <br><br>  Arbeitsauftrag: <br><br><ul><li>  W√§hlen Sie STACKLEAK aus dem grsecurity / PaX-Patch. </li><li>  studiere den Code sorgf√§ltig und bilde einen Patch, </li><li>  an LKML senden, Feedback erhalten, verbessern, erneut wiederholen, bevor es in die Hauptleitung aufgenommen wird. </li></ul><br>  Zum Zeitpunkt des Schreibens (25. September 2018) wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 15 einer Reihe von Patches</a> gesendet.  Es enth√§lt ein architektonisch unabh√§ngiges Teil und Code f√ºr x86_64 und x86_32.  Die von Laura Abbott von Red Hat entwickelte STACKLEAK-Unterst√ºtzung f√ºr arm64 hat es bereits geschafft, in den Vanillekern 4.19 zu gelangen. <cut></cut><br><br><h2>  STACKLEAK: Sicherheitsmerkmale </h2><br><h3>  Restinformationen im Kernel-Stack l√∂schen </h3><br>  Diese Ma√ünahme reduziert die n√ºtzlichen Informationen, die einige Lecks vom Kernstapel zum Benutzerraum erzeugen k√∂nnen. <br><br>  Ein Beispiel f√ºr einen Informationsverlust aus dem Kernel-Stack ist in Abbildung 1 dargestellt. <br><br><img src="https://habrastorage.org/webt/kt/d2/6v/ktd26vqpdxlk4vk8lobb7ixrybc.png"><br><br>  <i>Schema 1.</i> <br><br>  Lecks dieses Typs werden jedoch unbrauchbar, wenn am Ende eines Systemaufrufs der verwendete Teil des Kernelstapels mit einem festen Wert gef√ºllt wird (Abbildung 2). <br><br><img src="https://habrastorage.org/webt/fy/rr/w4/fyrrw4y-hyyms3pqjlumc_4k01w.png"><br><br>  Schema 2. <br><br>  Infolgedessen blockiert STACKLEAK einige Angriffe auf nicht initialisierte Variablen im Kernel-Stack.  Beispiele f√ºr solche Sicherheitsanf√§lligkeiten: CVE-2017-17712, CVE-2010-2963.  Eine Beschreibung der Ausnutzungsmethode f√ºr die Sicherheitsanf√§lligkeit CVE-2010-2963 finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem Artikel von</a> Kees Cook. <br><br>  Die Essenz des Angriffs auf eine nicht initialisierte Variable im Kernel-Stack ist in Abbildung 3 dargestellt. <br><br><img src="https://habrastorage.org/webt/8j/0p/po/8j0pposbamjhyq2jlsmuxpoqhfq.png"><br><br>  <i>Schema 3.</i> <br><br>  STACKLEAK blockiert Angriffe dieses Typs, da der Wert, der den Kernstapel am Ende eines Systemaufrufs auff√ºllt, auf einen nicht verwendeten Bereich im virtuellen Adressraum hinweist (Abbildung 4). <br><br><img src="https://habrastorage.org/webt/-t/zp/ok/-tzpokwwsamgqqe0ij7tafszzps.png"><br><br>  <i>Schema 4.</i> <br><br>  Eine wichtige Einschr√§nkung besteht darin, dass STACKLEAK nicht vor √§hnlichen Angriffen sch√ºtzt, die in einem einzelnen Systemaufruf ausgef√ºhrt werden. <br><br><h3>  In-Kernel-Core-Stack-√úberlauferkennung </h3><br>  Im Vanilla-Kernel (Linux-Kernel-Hauptzeile) ist STACKLEAK nur in Verbindung mit CONFIG_THREAD_INFO_IN_TASK und CONFIG_VMAP_STACK gegen einen √úberlauf der Kernel-Stapeltiefe wirksam.  Beide Ma√ünahmen werden von Andy Lutomirski umgesetzt. <br><br>  Die einfachste Version zum Ausnutzen dieser Art von Sicherheitsanf√§lligkeit ist in Abbildung 5 dargestellt. <br><br><img src="https://habrastorage.org/webt/1a/vd/ft/1avdft3jdwd9utgtpletdnv_nuu.png"><br><br>  <i>Schema 5.</i> <br><br>  Das √úberschreiben bestimmter Felder in der Struktur thread_info am unteren Rand des Kernstapels kann die Berechtigungen des Prozesses erh√∂hen.  Wenn jedoch die Option CONFIG_THREAD_INFO_IN_TASK aktiviert ist, wird diese Struktur aus dem Nuklearstapel entfernt, wodurch die beschriebene Methode zum Ausnutzen der Sicherheitsanf√§lligkeit entf√§llt. <br><br>  Eine fortgeschrittenere Version dieses Angriffs besteht darin, Daten in einem benachbarten Speicherbereich zu √ºberschreiben, indem die Stapelgrenze √ºberschritten wird.  Mehr zu diesem Ansatz: <br><br><ul><li>  in der Pr√§sentation von " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Stack is Back</a> " von John Oberheide, </li><li>  im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausnutzung der Rekursion im Linux-Kernel</a> " von Jann Horn. </li></ul><br>  Diese Art von Angriff ist in Abbildung 6 dargestellt. <br><br><img src="https://habrastorage.org/webt/un/zy/3s/unzy3s_w29yrpp020kyj8bokvtw.png"><br><br>  <i>Schema 6.</i> <br><br>  Der Schutz ist in diesem Fall CONFIG_VMAP_STACK.  Wenn diese Option aktiviert ist, wird eine spezielle Speicherseite (Schutzseite) neben dem Kernstapel platziert, auf die der Zugriff zu einer Ausnahme f√ºhrt (Abbildung 7). <br><br><img src="https://habrastorage.org/webt/9w/4b/ht/9w4bht4brf9z7zu6t8udygbr48q.png"><br><br>  <i>Schema 7.</i> <br><br>  Schlie√ülich ist ein Angriff wie Stack Clash die interessanteste Option, um den Stapel in der Tiefe zu √ºberfluten.  Die Idee wurde bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2005 von</a> Gael Delalleau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgebracht</a> . <br><br>  Im Jahr 2017 haben Forscher der Firma Qualys dar√ºber nachgedacht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und</a> diese Technik Stack Clash genannt.  Tatsache ist, dass es eine M√∂glichkeit gibt, √ºber die Schutzseite zu springen und Daten aus einem benachbarten Speicherbereich zu √ºberschreiben (Abbildung 8).  Dies erfolgt √ºber ein Array mit variabler L√§nge (VLA), dessen Gr√∂√üe vom Angreifer gesteuert wird. <br><br><img src="https://habrastorage.org/webt/vs/si/z2/vssiz2shuuuswmz96rmjongjjbs.png"><br><br>  <i>Schema 8.</i> <br><br>  Weitere Informationen zu STACKLEAK und Stack Clash finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie im grsecurity-Blog</a> . <br><br>  Wie sch√ºtzt STACKLEAK vor Stack Clash im Nuklearstack?  Vor jedem Aufruf von alloca () wird eine √úberpr√ºfung des Stapel√ºberlaufs in der Tiefe durchgef√ºhrt.  Hier ist der entsprechende Code aus Version 14 der Patch-Serie: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-function">used </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stackleak_check_alloca</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sp = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)&amp;sp; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack_info</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack_info</span></span></span><span class="hljs-class"> = {</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> visit_mask = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> stack_left; BUG_ON(get_stack_info(&amp;sp, current, &amp;stack_info, &amp;visit_mask)); stack_left = sp - (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)stack_info.begin; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt;= stack_left) { <span class="hljs-comment"><span class="hljs-comment">/* * Kernel stack depth overflow is detected, let's report that. * If CONFIG_VMAP_STACK is enabled, we can safely use BUG(). * If CONFIG_VMAP_STACK is disabled, BUG() handling can corrupt * the neighbour memory. CONFIG_SCHED_STACK_END_CHECK calls * panic() in a similar situation, so let's do the same if that * option is on. Otherwise just use BUG() and hope for the best. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(CONFIG_VMAP_STACK) &amp;&amp; defined(CONFIG_SCHED_STACK_END_CHECK) panic(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"alloca() over the kernel stack boundary\n"</span></span></span><span class="hljs-meta">); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> BUG(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } }</span></span></code> </pre> <br>  Diese Funktionalit√§t wurde jedoch von Version 15 ausgeschlossen.  Dies war haupts√§chlich auf das umstrittene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbot von</a> Linus Torvalds zur√ºckzuf√ºhren, BUG_ON () in Linux-Kernel-Sicherheitspatches zu verwenden. <br><br>  Dar√ºber hinaus f√ºhrte die 9. Version der Patch-Serie zu einer Diskussion, weshalb beschlossen wurde, alle variablen Arrays aus dem Mainline-Kernel zu entfernen.  Ungef√§hr 15 Entwickler waren an dieser Arbeit beteiligt und sie wird bald abgeschlossen sein. <br><br><h2>  Auswirkungen auf die STACKLEAK-Leistung </h2><br>  Ich gebe die Ergebnisse von Leistungstests auf x86_64.  Ausstattung: Intel Core i7-4770, 16 GB RAM. <br><br>  Test Nr. 1, attraktiv: Aufbau eines Linux-Kernels auf einem einzelnen Prozessorkern <br><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># time make   4.18: real 12m14.124s user 11m17.565s sys 1m6.943s   4.18+stackleak: real 12m20.335s (+0.85%) user 11m23.283s sys 1m8.221s</span></span></code> </pre> <br>  Test Nr. 2, unattraktiv: <br><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># hackbench -s 4096 -l 2000 -g 15 -f 25 -P    4.18: 9.08     4.18+stackleak: 9.47  (+4.3%)</span></span></code> </pre><br>  Daher h√§ngt die Auswirkung von STACKLEAK auf die Systemleistung von der Art der Last ab.  Insbesondere eine gro√üe Anzahl von kurzen Systemaufrufen erh√∂ht den Overhead.  T.O.  Die STACKLEAK-Leistung muss vor der Produktion f√ºr die geplante Ladung bewertet werden. <br><br><h2>  Internes Ger√§t STACKLEAK </h2><br>  STACKLEAK besteht aus: <br><br><ul><li>  Der Code, der den Kernel-Stack am Ende des Systemaufrufs l√∂scht (urspr√ºnglich in Assembler geschrieben), </li><li>  GCC-Plugin zur instrumentellen Kompilierung von Kernel-Code. </li></ul><br>  Das L√∂schen des Kernel-Stacks erfolgt in der Funktion stackleak_erase ().  Diese Funktion wird erf√ºllt, bevor nach einem Systemaufruf zum Benutzerbereich zur√ºckgekehrt wird.  Das STACKLEAK_POISON (-0xBEEF) wird in den verwendeten Teil des Thread-Stacks geschrieben.  Die niedrigste_Stack-Variable, die in stackleak_track_stack () st√§ndig aktualisiert wird, zeigt auf den Bereinigungsstartpunkt. <br><br>  Die Stufen von stackleak_erase () spiegeln sich in den Schemata 9 und 10 wider. <br><br><img src="https://habrastorage.org/webt/o0/qu/ar/o0quaropj1l3lcpm_wkucohbrwq.png"><br><br>  <i>Schema 9.</i> <br><br><img src="https://habrastorage.org/webt/vb/qg/2v/vbqg2vqqzsqrstwaqew21svaids.png"><br><br>  <i>Schema 10.</i> <br><br>  T.O.  stackleak_erase () l√∂scht nur den verwendeten Teil des Kernstapels.  Deshalb ist STACKLEAK so schnell.  Wenn Sie am Ende jedes Systemaufrufs alle 16 kB des Kernel-Stacks auf x86_64 l√∂schen, zeigt Hackbench einen Leistungsabfall von 40%. <br><br>  Die Instrumentierung des Kernel-Codes in der Kompilierungsphase erfolgt im STACKLEAK GCC-Plugin. <br><br>  GCC-Plugins sind projektspezifische herunterladbare Module f√ºr den GCC-Compiler.  Sie registrieren neue P√§sse beim GCC Pass Manager und stellen R√ºckrufe f√ºr diese P√§sse bereit. <br><br>  F√ºr den vollst√§ndigen Betrieb von STACKLEAK werden Aufrufe von stackleak_track_stack () mit einem gro√üen Stapelrahmen (Stapelrahmen) in den Funktionscode eingef√ºgt.  Au√üerdem wird vor jeder alloca () ein Aufruf des bereits erw√§hnten stackleak_check_alloca () eingef√ºgt, und danach wird ein Aufruf von stackleak_track_stack () eingef√ºgt. <br><br>  Wie bereits erw√§hnt, wurde in Version 15 der Patch-Serie das Einf√ºgen von Aufrufen von stackleak_check_alloca () aus dem GCC-Plugin ausgeschlossen. <br><br><h2>  Pfad in der Linux-Kernel-Hauptzeile </h2><br>  Der STACKLEAK-Pfad in der Hauptlinie ist sehr lang und schwierig (Abbildung 11). <br><br><img src="https://habrastorage.org/webt/px/95/j_/px95j_edhs60awthgfeytj9uz84.png"><br><br>  <i>Schema 11. Fortschritte bei der Implementierung von STACKLEAK in der Linux-Kernel-Hauptlinie.</i> <br><br>  Im April 2017 haben die Entwickler von grsecurity ihre Patches f√ºr die Community geschlossen und damit begonnen, sie nur auf kommerzieller Basis zu vertreiben.  Im Mai 2017 habe ich beschlossen, STACKLEAK in den Vanillekern einzuf√ºhren.  So begann eine Reise l√§nger als ein Jahr.  Die Firma Positive Technologies, in der ich arbeite, gibt mir die M√∂glichkeit, mich f√ºr einen Teil meiner Arbeitszeit mit dieser Aufgabe zu befassen.  Aber im Grunde verbringe ich "Freizeit" damit. <br><br>  Seit letztem Mai wurde meine Patch-Serie mehrfach √ºberpr√ºft, hat wesentliche √Ñnderungen erfahren und wurde zweimal von Linus Torvalds kritisiert.  Ich wollte das Ganze oft verlassen.  Aber zu einem bestimmten Zeitpunkt gab es einen festen Wunsch, das Ende zu erreichen.  Zum Zeitpunkt des Schreibens (25. September 2018) befindet sich die 15. Version der Patch-Serie im Linux-Next-Zweig, erf√ºllt alle angegebenen Anforderungen von Linus und ist bereit f√ºr das Zusammenf√ºhrungsfenster des 4.20 / 5.0-Kernels. <br><br>  Vor einem Monat hielt ich auf dem Linux Security Summit einen Vortrag √ºber diese Arbeit.  Ich biete Links zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folien</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Videos</a> : <br><iframe width="560" height="315" src="https://www.youtube.com/embed/5wIniiWSgUc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Fazit </h2><br>  STACKLEAK ist eine sehr n√ºtzliche Sicherheitsfunktion f√ºr den Linux-Kernel, die die Ausnutzung mehrerer Arten von Sicherheitsl√ºcken gleichzeitig blockiert.  Dar√ºber hinaus konnte der urspr√ºngliche Autor von PaX Team es schnell und sch√∂n in der Technik machen.  Daher w√§re das Erscheinen von STACKLEAK im Vanillekern f√ºr Linux-Benutzer mit erh√∂hten Anforderungen an die Informationssicherheit von Nutzen.  Dar√ºber hinaus lenkt die Arbeit in dieser Richtung die Aufmerksamkeit der Linux-Entwicklergemeinde auf Kernel-Selbstverteidigungstools. <br><br><h2>  PS </h2><br>  STACKLEAK wurde schlie√ülich vom Linux 4.20-Kernel √ºbernommen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2d6bb6adb714b133db92ccd4bfc9c20f75f71f3f</a> <br><br>  Die unterst√ºtzten Architekturen sind x86_64, x86_32 und arm64. <br><br>  Dar√ºber hinaus wurden die Arbeiten zum Entfernen von Arrays variabler L√§nge aus dem Linux-Kernel-Code abgeschlossen.  Die Gcc-Compiler-Warnung "-Wvla" ist in der Kernel-Version 4.20 enthalten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lkml.org/lkml/2018/10/28/189</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424633/">https://habr.com/ru/post/de424633/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424621/index.html">Nicht-Film-Superhelden. Wer und wie sch√ºtzt die Baustelle des Lakhta Centers vor Br√§nden?</a></li>
<li><a href="../de424623/index.html">Lassen Sie uns den Sound auf Go verarbeiten</a></li>
<li><a href="../de424625/index.html">Quellcode-Leck bei Aeroflot-Webdiensten</a></li>
<li><a href="../de424627/index.html">√Ñnderung der Registrierkassen. Teil 1</a></li>
<li><a href="../de424629/index.html">Wie erh√∂hen Startups ihre Investitionschancen bei der Kommunikation mit einem Investor?</a></li>
<li><a href="../de424635/index.html">Willkommen bei Sberbank Data Science Journey 2018 - Algorithmus f√ºr maschinelles Lernen</a></li>
<li><a href="../de424637/index.html">Magischer Barcode</a></li>
<li><a href="../de424639/index.html">Google ist 20 Jahre alt</a></li>
<li><a href="../de424641/index.html">Rebranding: Life Hack, wie man nicht zum Thema Spott wird</a></li>
<li><a href="../de424645/index.html">Da haben wir die massivste interne Umfrage bei der Bank gemacht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>