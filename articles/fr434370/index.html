<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏻 🤵🏼 🐇 Un autre conquérant de l'ombre à Phaser, ou l'utilisation de vélos 😊 🕧 🔑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a deux ans, j'expérimentais déjà avec des substances fantômes dans Phaser 2D. Lors du dernier Ludum Dare, nous avons soudainement décidé de faire...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un autre conquérant de l'ombre à Phaser, ou l'utilisation de vélos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434370/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il y a deux ans,</a> j'expérimentais déjà avec des <s>substances</s> fantômes dans Phaser 2D.  Lors du dernier Ludum Dare, nous avons soudainement décidé de faire une horreur, et quelle horreur sans ombres ni lumières!  J'ai craqué mes articulations ... <br><br>  ... et pas une fichue chose à temps pour LD.  Dans le jeu, bien sûr, il y a un peu d'ombre et de lumière, mais c'est un misérable semblant de ce qui était vraiment censé être. <br><br>  De retour à la maison après avoir envoyé le jeu au concours, j'ai décidé de «fermer la gestalt» et de finir ces ombres malheureuses.  Ce qui s'est passé - vous pouvez vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sentir dans le jeu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jouer dans la démo</a> , regarder l'image et lire l'article. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/if/35/m3if351xwaowt3lxcayun-cuzak.png"></div><br><a name="habracut"></a>  Comme toujours dans de tels cas, cela n'a aucun sens d'essayer d'écrire une solution générale, vous devez vous concentrer sur une situation spécifique.  Le monde du jeu peut être représenté sous forme de segments - au moins les entités qui projettent des ombres.  Les murs sont des rectangles, les gens sont des rectangles, seulement tournés, le spoiler infernal est un cercle, mais dans le modèle de coupure, il peut être simplifié à une longueur d'un diamètre toujours perpendiculaire à un rayon de lumière. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dh/gq/id/dhgqidngehzo_pn9vgr9eirsgna.png"></div><br>  Il existe plusieurs sources de lumière (20-30), et toutes sont circulaires (projecteurs) et sont situées conditionnellement plus bas que les objets éclairés (de sorte que les ombres peuvent être infinies). <br><br>  J'ai vu dans ma tête les moyens suivants pour résoudre le problème: <br><br><ol><li>  Pour chaque source de lumière, nous construisons une texture de la taille d'un écran (enfin, ou 2 à 4 fois plus petite).  Sur cette texture, nous dessinons simplement le trapèze BCC'D ', où A est la source lumineuse, BC est le segment, B'C' est la projection du segment au bord de la texture.  Après cela, ces textures sont envoyées au shader, où elles sont mélangées en une seule image. <br><br>  L'auteur du jeu de plateforme Celeste a fait quelque chose comme ça, qui est bien écrit dans son article sur medium: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">medium.com/@NoelFB/remaking-celestes-lighting-3478d6f10bf</a> <br><br>  Problèmes: 20-30 textures de taille d'écran qui doivent être redessinées presque chaque image et chargées dans le GPU.  Je me souviens que ce fut un processus très, très rapide. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z2/ve/ya/z2veyaflrtcpobcfkkdecuqpkpa.png"></div><br></li><li>  La méthode décrite dans un article sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/post/272233</a> .  Pour chaque source de lumière, nous construisons une «carte de profondeur», c'est-à-dire  une telle texture, où x = l'angle du «faisceau» par rapport à la source de lumière, y = le numéro de la source de lumière et la couleur == distance de la source à l'obstacle le plus proche.  Si nous prenons un pas de 0,7 degrés (360/512) et 32 ​​sources lumineuses, nous obtenons une texture 512x32, qui n'a pas été mise à jour depuis si longtemps. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aq/ew/_x/aqew_xze8rbkwvhj-68t3d4glz4.png"></div>  <sup>(exemple de texture pour un pas de 45 degrés)</sup> <br></li><li>  La voie secrète que je décrirai à la toute fin </li></ol><br>  Au final, j'ai opté pour la méthode 2. Cependant, la description de l'article ne me convenait pas jusqu'au bout.  Là, la texture a également été construite dans le shader à l'aide d'un rakecast - le shader du cycle est allé de la source de lumière dans la direction du faisceau et a cherché un obstacle.  Dans mes expériences passées, j'ai également fait du rakecast dans le shader, et c'était très cher, quoique universel. <br><br>  «Nous avons seulement des segments dans le modèle», pensais-je, «et 10 à 20 segments tombent dans le rayon de n'importe quelle source de lumière.  Je ne peux pas calculer rapidement une carte de distance sur cette base? » <br><br>  J'ai donc décidé de le faire. <br><br>  Pour commencer, j'ai simplement affiché à l'écran les murs, le «personnage principal» conditionnel et les sources lumineuses.  Autour des sources lumineuses, un cercle de lumière claire et pure découpé dans l'obscurité.  Pour l'obtenir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/jh/y4/yljhy4kuzvmkdqscqjuzsbqfjms.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> )</sup> <br><br>  J'ai immédiatement commencé à faire avec le shader pour ne pas me détendre.  Il fallait y passer pour chaque source lumineuse ses coordonnées et son rayon d'action (au-delà duquel la lumière n'atteint pas), cela se fait simplement à travers un réseau uniforme.  Et puis dans le shader (qui est fragmentaire, qui est réalisé pour chaque pixel de l'écran), il restait à comprendre si le pixel courant se trouvait ou non dans notre cercle éclairé. <br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLightShader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(game) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(game); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lightsArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(MAX_LIGHTS*<span class="hljs-number"><span class="hljs-number">4</span></span>); lightsArray.fill(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, lightsArray.length); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lightsCount = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'1i'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lights = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'4fv'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: lightsArray}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fragmentSrc = <span class="hljs-string"><span class="hljs-string">` precision highp float; uniform int lightsCount; uniform vec4 lights[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${MAX_LIGHTS}</span></span></span><span class="hljs-string">]; void main() { float lightness = 0.; for (int i = 0; i &lt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${MAX_LIGHTS}</span></span></span><span class="hljs-string">; i++) { if (i &gt;= lightsCount) break; vec4 light = lights[i]; lightness += step(length(light.xy - gl_FragCoord.xy), light.z); } lightness = clamp(0., 1., lightness); gl_FragColor = mix(vec4(0,0,0,0.5), vec4(0,0,0,0), lightness); } `</span></span>; } updateLights(lightSources) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lightsCount.value = lightSources.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lights.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> light <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> lightSources) { array[i++] = light.x; array[i++] = game.world.height - light.y; array[i++] = light.radius; i++; } } }</code> </pre> <br>  Maintenant, nous devons comprendre pour chaque source de lumière quels segments projetteront une ombre.  Au contraire, quelles parties des segments - dans la figure ci-dessous, nous ne sommes pas intéressés par les parties "rouges" du segment, car  la lumière ne les atteint toujours pas. <br><br>  <i>Remarque: la définition d'intersection est une sorte d'optimisation préliminaire.</i>  <i>Il est nécessaire afin de réduire le temps de traitement ultérieur, en éliminant les gros morceaux de segments au-delà du rayon de la source de lumière.</i>  <i>Cela a du sens lorsque nous avons de nombreux segments dont la longueur est bien supérieure au rayon de la «lueur».</i>  <i>Si ce n'est pas le cas et que nous avons de nombreux segments courts, il peut être judicieux de ne pas perdre de temps à déterminer l'intersection et à traiter l'intégralité des segments, car</i>  <i>gagner du temps ne fonctionne toujours pas.</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cb/93/mb/cb93mbs6zzyyqwvfx633ppxbtzg.png"></div><br>  Pour ce faire, j'ai utilisé la formule bien connue pour trouver l'intersection d'une ligne droite et d'un cercle, dont tout le monde se souvient par cœur d'un cours d'école de géométrie ... dans le monde imaginaire de quelqu'un.  Je ne me souvenais tout simplement pas d'elle, j'ai donc dû le rechercher sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google</a> . <br><br>  Nous encodons, regardez ce qui s'est passé. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_0/up/go/_0upgoezkyggo7sfkntejosckg0.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> )</sup> <br>  Cela semble être la norme.  Nous savons maintenant quels segments peuvent projeter une ombre et peuvent effectuer un rakecast. <br><br>  Ici, nous avons également des options: <br><br><ol><li>  Nous allons simplement en cercle dans un cercle, jetons des rayons et cherchons des intersections.  La distance jusqu'à l'intersection la plus proche est la valeur dont nous avons besoin </li><li>  Vous ne pouvez aller qu'aux coins qui se divisent en segments.  Après tout, nous connaissons déjà les points, il n'est pas difficile de calculer les angles. </li><li>  De plus, si nous suivons un segment, nous n'avons pas besoin de projeter de rayons et de calculer les intersections - nous pouvons nous déplacer le long du segment avec le pas souhaité.  Voici comment cela fonctionne: </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9w/db/yp/9wdbyph5wjrn9dolovyhf_5y6-w.png"></div><br>  Ici <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi><mi>B</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.507ex" height="2.057ex" viewBox="0 -780.1 1510 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-41" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-42" x="750" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mi>B</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> AB </script>  - segment (mur), <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> C </script>  Est le centre de la source lumineuse, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.982ex" height="2.057ex" viewBox="0 -780.1 1284 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-64" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> Cd </script>  - perpendiculaire au segment. <br><br>  Soit <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> x </script>  - l'angle par rapport à la normale, pour lequel vous devez connaître la distance de la source au segment, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.979ex" height="2.298ex" viewBox="0 -780.1 1282.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-31" x="1171" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> X_1 </script>  - pointer sur le segment <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi><mi>B</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.507ex" height="2.057ex" viewBox="0 -780.1 1510 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-41" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-42" x="750" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mi>B</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> AB </script>  où le faisceau tombe.  Triangle <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>D</mi><msub><mi>X</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.669ex" height="2.298ex" viewBox="0 -780.1 2871.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-44" x="760" y="0"></use><g transform="translate(1589,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-31" x="1171" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>D</mi><msub><mi>X</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> CDX_1 </script>  - rectangulaire <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.982ex" height="2.057ex" viewBox="0 -780.1 1284 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-64" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-8"> Cd </script>  - une jambe, et sa longueur est connue et constante pour ce segment, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.298ex" viewBox="0 -780.1 2042.9 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-43" x="0" y="0"></use><g transform="translate(760,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-31" x="1171" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-9"> CX_1 </script>  - longueur souhaitée. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>C</mi><mi>D</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="23.042ex" height="2.66ex" viewBox="0 -832 9921 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-43" x="0" y="0"></use><g transform="translate(760,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-31" x="1171" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-3D" x="2320" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-66" x="3626" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-72" x="4177" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-61" x="4628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-63" x="5158" y="0"></use><g transform="translate(5591,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-44" x="760" y="0"></use></g><g transform="translate(7180,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-63" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-6F" x="433" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-73" x="919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-28" x="1388" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-78" x="1778" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-29" x="2350" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>C</mi><mi>D</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-10"> CX_1 = \ frac {CD} {cos (x)} </script>  .  Si vous connaissez l'étape à l'avance (et nous la connaissons), vous pouvez pré-calculer le tableau des cosinus inverses et rechercher les distances très rapidement. <br><br>  Je vais donner un exemple de code pour une telle table.  Presque tous les travaux avec coins sont remplacés par des travaux avec index, c'est-à-dire  entiers de 0 à N, où N = le nombre de pas dans le cercle (c.-à-d. angle de pas = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>i</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.923ex" height="2.419ex" viewBox="0 -780.1 4703 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-70" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-69" x="1254" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhiAzcf_eR-4JZQ2oO-Qo74wmdIEvw#MJMATHI-4E" x="3814" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mtext>&nbsp;</mtext><mi>p</mi><mi>i</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>N</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-11"> \ frac {2 \ pi} {N} </script>  ) <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HypTable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(steps = 512, stepAngle = 2*Math.PI/steps) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.perAngleStep = [<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; steps/<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">//   pi/2 let ang = i*stepAngle; this.perAngleStep[i] = 1/Math.cos(ang); } this.stepAngle = stepAngle; } /** * @param distancesMap -  ,    * @param angle1 -           * @param angle2 -           * @param normalFromLight - ,      */ fillDistancesForArc(distancesMap, angle1, angle2, normalFromLight) { const D = Math.hypot(normalFromLight.x, normalFromLight.y); const normalAngle = Phaser.Math.normalizeAngle(Math.atan2(normalFromLight.y, normalFromLight.x)); const normalAngleIndex = (normalAngle / this.stepAngle)|0; const index1 = (angle1 / this.stepAngle)|0; const index2 = (angle2 / this.stepAngle)|0; for (let angleIndex = index1; angleIndex &lt;= index2; angleIndex++) { let distanceForAngle = D * this.perAngleStep[normalize(angleIndex - normalAngleIndex)]; distancesMap.set(angleIndex, distanceForAngle); } } }</span></span></code> </pre><br>  Bien sûr, cette méthode introduit une erreur pour les cas où l'angle initial ACD n'est pas un multiple d'une étape.  Mais pour 512 étapes, je ne vois visuellement aucune différence. <br><br>  Donc ce que nous savons déjà faire: <br><ol><li>  Trouvez des segments dans la plage de la source de lumière qui peuvent projeter une ombre <br></li><li>  Pour l'étape t, créez une table dist (angle) en passant par chaque segment et en calculant les distances. </li></ol><br><br>  Voici à quoi ressemble ce tableau si vous le dessinez en rayons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/5m/17/kh5m17zbgdyq22dfeoys5borlbe.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> )</sup> <br><br>  Et voici à quoi cela ressemble 10 sources de lumière, si elles sont écrites dans une texture. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bg/ex/3-/bgex3-jcfuohb9_egfv_4ul-x2e.png"></div><br>  Ici, chaque pixel horizontal correspond à un angle, et la couleur à la distance en pixels. <br>  Il est écrit en js comme celui-ci en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">imageData</a> <br><pre> <code class="javascript hljs"> fillBitmap(data, index) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = index + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.steps*<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d1, d2; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//data[index] = Red //data[index+1] = Green //data[index+2] = Blue //data[index+3] = Alpha for (; index &lt; total; index+=4, i++) { //  512,    R     2. d1 = (this.distances[i]/2)|0; data[index] = d1; d1 = this.distances[i] - d1*2; d2 = (d1*128)|0; //   G -     2. data[index+1] = d2; //  B  A  255,     . data[index+2] = 255; data[index+3] = 255; } }</span></span></code> </pre><br><br>  Maintenant, nous passons la texture à notre shader, qui a déjà les coordonnées et les rayons des sources lumineuses.  Et traitez-le comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      uniform sampler2D iChannel0; #define STRENGTH 0.3 #define MAX_DARK 0.7 #define M_PI 3.141592653589793 #define M_PI2 6.283185307179586 //       float decodeDist(vec4 color) { return color.r*255.*2. + color.g*2.; } float getShadow(int i, float angle, float distance) { //   x   ==  float u = angle/M_PI2; //   y   ==     float v = float(i)/${MAX_LIGHTS}.; float shadowAfterDistance = decodeDist(texture2D(iChannel0, vec2(u, v))); //  1   ,  0  . return step(shadowAfterDistance, distance); } void main() { float lightness = 0.; for (int i = 0; i &lt; ${MAX_LIGHTS}; i++) { if (i &gt;= lightsCount) break; vec4 light = lights[i]; //       vec2 light2point = gl_FragCoord.xy - light.xy; float radius = light.z; float distance = length(light2point); float inLight = step(distance, radius); //      ,       //  . //      , //    ,          //           //     ,    if (inLight == 0.) continue; float angle = mod(-atan(light2point.y, light2point.x), M_PI2); // 1     0   float thisLightness = (1. - getShadow(i, angle, distance)); //,   “”  ,   ,  //    lightness += thisLightness*STRENGTH; } lightness = clamp(0., 1., lightness); gl_FragColor = mix(vec4(0,0,0,MAX_DARK), vec4(0,0,0,0), lightness); }</span></span></code> </pre> <br><br>  Résultat: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f9/0l/hj/f90lhj2yepescdli2qndmyx-xkq.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> )</sup> <br>  Maintenant, vous pouvez apporter un peu de beauté.  Laissez la lumière s'estomper avec la distance et les ombres seront floues. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1s/op/sg/1sopsggdgrpurmn0qsui8rcfhne.png"></div><br>  Pour le flou, je regarde les coins adjacents, + - étape, comme ceci: <br><br><pre> <code class="cpp hljs">thisLightness = (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle, distance)) * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle-SMOOTH_STEP, distance)) * <span class="hljs-number"><span class="hljs-number">0.2</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle+SMOOTH_STEP, distance)) * <span class="hljs-number"><span class="hljs-number">0.2</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle-SMOOTH_STEP*<span class="hljs-number"><span class="hljs-number">2.</span></span>, distance)) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle+SMOOTH_STEP*<span class="hljs-number"><span class="hljs-number">2.</span></span>, distance)) * <span class="hljs-number"><span class="hljs-number">0.1</span></span>;</code> </pre><br><br>  Si vous assemblez tout et mesurez le FPS, cela se révèle comme ceci: <br><br><ul><li>  Sur les cartes vidéo intégrées - tout est mauvais (&lt;30-40), même pour des exemples simples <br></li><li>  Tout le reste va bien, tant que les sources lumineuses ne sont pas très fortes.  C'est-à-dire que le nombre de sources de lumière par pixel est important, pas le nombre total. <br></li></ul><br><br>  Ce résultat me convenait tout à fait.  Vous pouvez toujours jouer avec la couleur de l'éclairage, mais je ne le fais pas.  Après avoir tordu un peu et ajouté des cartes normales, j'ai téléchargé une version mise à jour de NOPE.  Elle ressemblait à ceci maintenant: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cq/nw/4o/cqnw4opdblgnm6ebys-lgbtvnt4.gif"></div><br><br>  Puis il a commencé à préparer un article.  J'ai regardé un tel gif et j'ai pensé. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/de/zr/ctdezrcsaztxtgxx9jyioatirds.gif"></div><br>  «C'est donc presque un look pseudo-3D, comme dans Wolfenstein», m'exclamai-je (oui, j'ai une bonne imagination).  Et en fait - si nous supposons que tous les murs ont la même hauteur, les cartes de distance nous suffiront pour construire la scène.  Pourquoi ne pas l'essayer? <br><br>  La scène devrait ressembler à ceci. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/5v/-s/lg5v-sk8cmojfurrj_pnrg3xw0k.png"></div><br><br>  Donc notre tâche: <br><br><ol><li>  Sur un point de l'écran, obtenez les coordonnées mondiales de l'affaire lorsqu'il n'y a pas de murs. <br><br>  Nous considérerons ceci: <br><ul><li>  Tout d'abord, nous normalisons les coordonnées d'un point sur l'écran afin qu'il y ait un point (0,0) au centre de l'écran et aux coins (-1, -1) et (1,1), respectivement <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l9/ki/fu/l9kifubvfwn50ust9lhtsik2f_k.png"></div></li><li>  La coordonnée x devient l'angle de la direction de la vue, il vous suffit de le multiplier par A / 2, où A est l'angle de vue <br></li><li>  La coordonnée y détermine la distance de l'observateur au point, dans le cas général d ~ 1 / y.  Pour un point sur le bord inférieur de l'écran, distance = 1, pour un point au centre de l'écran, distance = infini. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8e/ua/4b/8eua4bycfatkegaiwbyu_eohxky.png"></div></li><li>  Ainsi, si vous ne prenez pas en compte les murs, alors pour chaque point visible du monde il y aura 2 points sur l'écran - un au dessus du milieu (au «plafond») et l'autre en dessous (au «sol») <br></li></ul></li><li>  Maintenant, nous pouvons regarder le tableau des distances.  S'il y a un mur plus proche que notre point, alors vous devez dessiner un mur.  Sinon, cela signifie sol ou plafond <br></li></ol><br>  Nous obtenons comme commandé: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/gj/lu/qpgjluavcmsuba51v0iovqdccc0.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> )</sup> <br>  Ajoutez de l'éclairage - de la même manière, parcourez les sources de lumière et vérifiez les coordonnées du monde.  Et - la touche finale - ajoutez des textures.  Pour ce faire, dans une texture avec des distances, vous devez également écrire le décalage u pour la texture du mur à ce stade.  C'est là que le canal b est devenu utile. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/ai/ay/knaiayi9epavp3cr8u6wcd4x2ss.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> )</sup> <br>  Parfait. <br><br>  Je plaisante. <br><br>  Imparfait, bien sûr.  Mais bon sang, j'ai toujours lu comment faire mon Wolfenstein grâce à rakecast il y a environ 15 ans, et je voulais tout faire, et voici une telle opportunité! <br><br><h4>  Au lieu d'une conclusion </h4><br>  Au début de l'article, j'ai mentionné une autre méthode secrète.  Le voici: <br><br><blockquote>  <b>Prenez simplement le moteur qui sait déjà.</b> </blockquote><br>  En fait, si vous devez créer un jeu, ce sera le moyen le plus correct et le plus rapide.  Pourquoi avez-vous besoin de clôturer vos vélos et de résoudre des problèmes de longue date? <br><br>  Mais pourquoi. <br><br>  En 10e année, j'ai déménagé dans une autre école et j'ai rencontré des problèmes de mathématiques.  Je ne me souviens pas de l'exemple exact, mais c'était une équation avec des degrés, qui à tous égards devait être simplifiée, mais elle n'a tout simplement pas réussi.  Désespérée, j'ai consulté ma sœur et elle a dit: «Alors, ajoutez x <sup>2 des</sup> deux côtés, et tout se décomposera.»  Et c'était la solution: ajoutez ce qui n'était pas là. <br><br>  Quand, beaucoup plus tard, j'ai aidé mon ami à construire ma maison, j'ai dû mettre un bloc sur le seuil - pour remplir une niche.  Et ici je me tiens et trie l'assiette des barres.  L'une semble convenir, mais pas tout à fait.  D'autres sont beaucoup plus petits.  Je réfléchis à la façon de collecter le mot bonheur ici, et un ami dit: "alors ils ont bu les sillons dans un endroit circulaire où il interfère".  Et maintenant, la grande barre est déjà immobile. <br><br>  Ces histoires sont unies par un tel effet, que j'appellerai «l'effet d'inventaire».  Lorsque vous essayez de prendre une décision à partir de pièces existantes, sans voir de matériau pouvant être traité et affiné dans ces pièces.  Les chiffres sont en bois, en argent ou en code. <br><br>  Plusieurs fois, j'ai observé le même effet avec des collègues en programmation.  Ne se sentant pas confiants dans le matériau, ils cèdent parfois quand il est nécessaire de faire, disons, des contrôles non standard.  Ou ajoutez des tests unitaires là où ils n'étaient pas.  Ou ils essaient de tout prévoir, tout lors de la conception d'une classe, puis nous obtenons un dialogue comme: <br>  - Ce n'est pas nécessaire maintenant <br>  - Et si cela devient nécessaire? <br>  - Ensuite, nous ajouterons.  Laissez les points d'expansion, c'est tout.  Le code n'est pas du granit, c'est de la pâte à modeler. <br><br>  Et pour apprendre à voir et à ressentir le matériau avec lequel nous travaillons, nous avons également besoin de vélos. <br><br>  Ce n'est pas seulement un entraînement pour l'esprit ou un entraînement.  C'est un moyen d'atteindre un niveau de travail qualitativement différent avec le code. <br><br>  Merci à tous d'avoir lu. <br><br>  Liens, au cas où vous auriez oublié de cliquer quelque part: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toutes les démos ensemble</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code démo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En fait un jeu LD avec des ombres</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434370/">https://habr.com/ru/post/fr434370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434358/index.html">Substitution d'importation de systèmes d'exploitation. Comment puis-je voir le système d'exploitation national</a></li>
<li><a href="../fr434360/index.html">Discussion expliquée sur la programmation asynchrone en Javascript</a></li>
<li><a href="../fr434362/index.html">PAS prévu pour 2019</a></li>
<li><a href="../fr434364/index.html">Prise en charge de la file d'attente Hangfire</a></li>
<li><a href="../fr434368/index.html">Apprentissage automatique pour trouver des erreurs dans le code: comment j'ai effectué un stage chez JetBrains Research</a></li>
<li><a href="../fr434374/index.html">Vérification de RBAC dans Kubernetes</a></li>
<li><a href="../fr434380/index.html">Bases de l'injection de dépendance</a></li>
<li><a href="../fr434382/index.html">Portage d'Alpine Linux vers RISC-V</a></li>
<li><a href="../fr434384/index.html">Sous la responsabilité des artistes interprètes ou exécutants</a></li>
<li><a href="../fr434386/index.html">Douglas Engelbart: «Augmenter l'intellect humain: un cadre conceptuel»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>