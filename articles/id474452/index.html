<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤´ğŸ» â© ğŸ‘©ğŸ¾â€ğŸ”§ Laporan Status Musim Gugur Haxe â™¨ï¸ ğŸ§—ğŸ¿ ğŸŒï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada tanggal 26 Oktober, Linz am Rhein (Jerman) menjadi tuan rumah konferensi mini HaxeUp Sessions 2019 yang didedikasikan untuk Haxe dan teknologi te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laporan Status Musim Gugur Haxe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474452/"><p>  Pada tanggal 26 Oktober, Linz am Rhein (Jerman) menjadi tuan rumah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi mini HaxeUp Sessions 2019 yang</a> didedikasikan untuk Haxe dan teknologi terkait.  Dan acara terpentingnya adalah, tentu saja, rilis final Haxe 4.0.0 (pada saat publikasi, yaitu, setelah sekitar satu minggu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembaruan 4.0.1 dirilis</a> ).  Dalam artikel ini, saya ingin menyampaikan kepada Anda terjemahan laporan pertama konferensi - sebuah laporan tentang pekerjaan yang dilakukan oleh tim Haxe untuk 2019. </p><br><p><img src="https://habrastorage.org/webt/hk/ik/sp/hkiksp6o31il9tcdxjjlm6xnmve.png" alt="gambar"></p><a name="habracut"></a><br><p>  Sedikit tentang penulis laporan: </p><br><p>  Simon telah bekerja dengan Haxe sejak 2010, ketika dia masih mahasiswa dan menulis karya simulasi cairan di Flash.  Implementasi dari simulasi semacam itu memerlukan akses konstan ke data yang menggambarkan keadaan partikel (pada setiap langkah lebih dari 100 pertanyaan dibuat ke array data tentang keadaan setiap sel dalam simulasi), sementara bekerja dengan array dalam ActionScript 3 tidak begitu cepat.  Oleh karena itu, implementasi awal tidak bisa digunakan dan diperlukan untuk menemukan solusi untuk masalah ini.  Dalam pencariannya, Simon menemukan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh Nicolas Kannass</a> (pencipta Haxe) pada opkode Alkimia yang tidak berdokumen yang tidak tersedia menggunakan ActionScript, tetapi Haxe mengizinkannya untuk digunakan.  Menulis ulang simulasi pada Haxe menggunakan opcodes, Simon mendapat simulasi yang berhasil!  Jadi, berkat array yang lambat di ActionScript, Simon belajar tentang Haxe. </p><br><p>  Sejak 2011, Simon bergabung dengan pengembangan Haxe, ia mulai mempelajari OCaml (di mana kompiler ditulis) dan membuat berbagai koreksi ke kompiler. </p><br><p>  Dan sejak 2012, ia menjadi pengembang kompiler utama.  Pada tahun yang sama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yayasan Haxe</a> dibentuk (sebuah organisasi yang tujuan utamanya adalah mengembangkan dan memelihara ekosistem Haxe, membantu komunitas menyelenggarakan konferensi, dan menyediakan layanan konsultasi), dan Simon menjadi salah satu pendiri bersama. </p><br><p><img src="https://habrastorage.org/webt/ic/n2/-z/icn2-zvorldkegboovusqzxfdbo.png" alt="gambar"></p><br><p>  Pada 2014-2015, Simon mengundang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Josephine Pertosa</a> ke Yayasan Haxe, yang seiring waktu menjadi bertanggung jawab untuk menyelenggarakan konferensi dan hubungan masyarakat. </p><br><p>  Pada 2016, Simon membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> pertamanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang Haxe</a> , dan pada 2018 menyelenggarakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HaxeUp Sessions pertama</a> . </p><br><p><img src="https://habrastorage.org/webt/ii/3p/vq/ii3pvqd1f88pj3toyvcaxjcmjr8.png" alt="gambar"></p><br><p>  Jadi apa yang terjadi di dunia Haxe selama 2019 yang lalu? </p><br><p>  Pada bulan Februari dan Maret, 2 kandidat rilis keluar (4.0.0-rc1 dan 4.0.0-rc2) <br>  Pada bulan April, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aurel Bili</a> (sebagai magang) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Kuzmenko</a> (sebagai pengembang kompiler) bergabung dengan tim Haxe Foundation. </p><br><p>  Pada bulan Mei, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Haxe US Summit 2019 diadakan</a> . <br>  Pada bulan Juni, Haxe 4.0.0-rc3 dirilis.  Dan pada bulan September - Haxe 4.0.0-rc4 dan Haxe 4.0.0-rc5. </p><br><p><img src="https://habrastorage.org/webt/bg/cz/di/bgczdidj4imp0y_rteusgqy-dwq.png" alt="gambar"></p><br><p>  Haxe tidak hanya kompiler, tetapi juga seluruh rangkaian berbagai alat, dan sepanjang tahun pengerjaan mereka juga terus dilakukan: <br>  Berkat upaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andy Lee,</a> Haxe sekarang menggunakan Pipa Azure, bukan Travis CI dan AppVeyor.  Ini berarti bahwa perakitan dan pengujian otomatis sekarang jauh lebih cepat. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hugh Sanderson</a> terus bekerja pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hxcpp</a> (perpustakaan untuk mendukung C ++ di Haxe). <br>  Tiba-tiba, pengguna Github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terurou</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">takashiski</a> bergabung dengan pekerjaan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">externs untuk</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node.js.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rudy Ges</a> bekerja pada perbaikan dan peningkatan untuk mendukung target C #. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">George Corney</a> terus mendukung generator extern HTML. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jens Fisher sedang</a> mengerjakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vshaxe</a> (perpanjangan untuk VS Code untuk bekerja dengan Haxe) dan pada banyak proyek terkait Haxe lainnya. </p><br><p><img src="https://habrastorage.org/webt/4c/n-/vr/4cn-vrhfusi6b6adnvyldgpyd7y.png" alt="gambar"></p><br><p>  Dan acara utama tahun ini, tentu saja, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis Haxe 4.0.0 yang</a> telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lama ditunggu-tunggu</a> (serta neko 2.3.0), yang secara tidak sengaja bertepatan dengan HaxeUp 2019 Linz :) </p><br><p><img src="https://habrastorage.org/webt/z6/n5/w0/z6n5w0pvjr4oecito4cd4w0ge_i.png" alt="gambar"></p><br><p>  Simon mencurahkan sebagian besar laporan untuk fitur-fitur baru di Haxe 4.0.0 (Anda juga dapat mempelajarinya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Alexander Kuzmenko</a> dari Haxe US Summit 2019 yang terakhir). </p><br><p><img src="https://habrastorage.org/webt/mn/-z/u2/mn-zu2pk84sti-8ztm8hvhmvizm.png" alt="gambar"></p><br><p>  Eval macro interpreter baru beberapa kali lebih cepat daripada yang lama.  Simon berbicara tentang dia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara</a> rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam pidatonya di Haxe Summit EU 2017</a> .  Tetapi sejak itu telah meningkatkan kemampuan debugging kode, memperbaiki banyak bug, mendesain ulang implementasi string. </p><br><p><img src="https://habrastorage.org/webt/d_/j3/uq/d_j3uqwvxpukog8q9pgp9prafrw.png" alt="gambar"></p><br><p> Haxe 4 memperkenalkan dukungan Unicode untuk semua platform (kecuali Neko).  Simon menggambarkan hal ini secara terperinci dalam pidatonya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tahun lalu</a> .  Untuk pengguna akhir dari kompiler, ini berarti ungkapan <code>"Haxeã¯æœ€é«˜ã ãï¼".length</code> untuk semua platform akan selalu kembali <code>10</code> (lagi, kecuali untuk Neko). </p><br><p>  Pengkodean UCS-2 didukung minimal (pengkodean yang didukung secara native digunakan untuk setiap platform / bahasa; mencoba untuk mendukung pengodean yang sama di mana-mana tidak praktis): </p><br><ul><li>  JavaScript, Flash, HashLink dan C ++ menggunakan pengkodean UCS-2 </li><li>  untuk eval, PHP, lua - UTF-8 </li><li>  untuk Java dan C # - UTF-16 </li><li>  untuk Python - UTF-32 </li></ul><br><p>  Semua karakter yang berada di luar bidang multibahasa utama (termasuk emoji) direpresentasikan sebagai "pasangan pengganti" - karakter tersebut diwakili oleh dua byte.  Misalnya, jika dalam Java / C # / JavaScript (yaitu, untuk string dalam pengkodean UTF-16 dan UCS-2) untuk meminta panjang string yang terdiri dari satu emoji, hasilnya akan menjadi "2".  Fakta ini harus diperhitungkan saat bekerja dengan string semacam itu pada platform ini. </p><br><p>  Haxe 4 memperkenalkan jenis iterator baru - nilai kunci: </p><br><p><img src="https://habrastorage.org/webt/h5/8l/1f/h58l1f46pistrquuipoopbqybeq.png" alt="gambar"></p><br><p>  Ini bekerja dengan kontainer tipe <code>Map</code> (kamus) dan string (menggunakan kelas StringTools), dukungan untuk array belum diimplementasikan.  Dimungkinkan juga untuk mengimplementasikan iterator seperti itu untuk kelas kustom, untuk ini cukup menerapkan metode <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> untuk mereka <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> . </p><br><p>  Tag meta baru <code>@:using</code> memungkinkan Anda untuk mengaitkan ekstensi statis dengan tipe di tempat deklarasi mereka. </p><br><p>  Pada contoh di bawah ini, enumerasi <code>MyOption</code> dikaitkan dengan <code>MyOptionTools</code> , jadi kami secara statis memperluas enumerasi ini (yang tidak mungkin dalam situasi biasa) dan mendapatkan kesempatan untuk memanggil metode <code>get()</code> , merujuknya sebagai metode objek. </p><br><p><img src="https://habrastorage.org/webt/ol/i7/in/oli7inyhluzdfnval9ohazjh-lg.png" alt="gambar"></p><br><p>  Dalam contoh ini, metode <code>get()</code> inline, yang juga memungkinkan kompiler untuk lebih mengoptimalkan kode: alih-alih memanggil metode <code>MyOptionTools.get(myOption)</code> , kompiler akan menggantikan nilai yang disimpan, mis. <code>12</code> . </p><br><p>  Jika metode ini tidak dinyatakan sebagai embeddable, maka alat optimasi lain yang tersedia untuk programmer adalah untuk menanamkan fungsi di tempat panggilan mereka (call-site inlining).  Untuk melakukan ini, saat memanggil fungsi, Anda juga harus menggunakan <code>inline</code> : </p><br><p><img src="https://habrastorage.org/webt/4p/bb/xp/4pbbxpcwmgfbabo5dih7lpqdmm0.png" alt="gambar"></p><br><p>  Berkat karya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daniil Korostelev</a> , Haxe sekarang memiliki kesempatan untuk menghasilkan kelas ES6 untuk JavaScript.  Yang perlu Anda lakukan hanyalah menambahkan flag kompilasi <code>-D js-es=6</code> . </p><br><p>  Saat ini, kompiler menghasilkan satu file js untuk seluruh proyek (mungkin di masa depan untuk menghasilkan file js terpisah untuk masing-masing kelas, tetapi sejauh ini ini hanya dapat dilakukan dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat tambahan</a> ). </p><br><p><img src="https://habrastorage.org/webt/md/mk/no/mdmknohyzhrkyftm1frzusodoi4.png" alt="gambar"></p><br><p>  Untuk enumerasi abstrak, nilai sekarang dihasilkan secara otomatis. </p><br><p>  Di Haxe 3, perlu untuk menetapkan nilai secara manual untuk setiap konstruktor.  Dalam Haxe 4, enumerasi abstrak yang dibuat di atas <code>Int</code> berperilaku sesuai dengan aturan yang sama seperti dalam C. Enumerasi abstrak yang dibuat di atas string berperilaku sama - bagi mereka, nilai yang dihasilkan akan bertepatan dengan nama konstruktor. </p><br><p><img src="https://habrastorage.org/webt/mu/gr/uj/mugrujzah5vmzrw-vcgyjzw42ju.png" alt="gambar"></p><br><p>  Beberapa perbaikan sintaks juga perlu disebutkan: </p><br><ul><li>  enumerasi abstrak dan fungsi extern telah menjadi anggota penuh Haxe dan sekarang Anda tidak perlu menggunakan <code>@:enum</code> dan <code>@:extern</code> meta tag untuk menyatakannya </li><li>  4th Haxe menggunakan sintaks persimpangan tipe baru yang lebih baik mencerminkan esensi dari struktur yang diperluas.  Konstruksi seperti itu paling berguna ketika mendeklarasikan struktur data: ekspresi <code>typedef T = A &amp; B</code> berarti bahwa struktur <code>T</code> memiliki semua bidang yang ada dalam tipe <code>A</code> dan <code>B</code> </li><li>  sama halnya, empat menyatakan batasan parameter tipe: entri <code>&lt;T:A &amp; B&gt;</code> menunjukkan bahwa tipe parameter <code>T</code> harus <code>A</code> dan <code>B</code> </li><li>  sintaks lama akan berfungsi (kecuali sintaksis untuk batasan jenis, karena akan bertentangan dengan sintaks baru untuk menggambarkan tipe fungsi) </li></ul><br><p><img src="https://habrastorage.org/webt/ju/gt/yu/jugtyumi4hrt7fvt7ridshgzt5a.png" alt="gambar"></p><br><p>  Sintaks baru untuk menggambarkan tipe fungsi (sintaks tipe fungsi) lebih logis: menggunakan tanda kurung di sekitar tipe argumen fungsi secara visual lebih mudah dibaca.  Selain itu, sintaks baru memungkinkan Anda untuk menentukan nama argumen, yang dapat digunakan sebagai bagian dari dokumentasi untuk kode (meskipun itu tidak mempengaruhi pengetikan itu sendiri). </p><br><p><img src="https://habrastorage.org/webt/1v/yu/y5/1vyuy5q4ayqlbteqmq3ugx9lzba.png" alt="gambar"></p><br><p>  Dalam kasus ini, sintaks lama terus didukung dan tidak ditinggalkan, seperti  jika tidak, itu akan memerlukan terlalu banyak perubahan dalam kode yang ada (Simon sendiri terus-menerus menemukan dirinya keluar dari kebiasaan dan terus menggunakan sintaksis lama). </p><br><p>  Haxe 4 akhirnya memiliki fungsi panah (atau ekspresi lambda)! </p><br><p><img src="https://habrastorage.org/webt/vh/49/oo/vh49oomjlu8y1o1t5cs-jmzv7nm.png" alt="gambar"></p><br><p>  Fitur fungsi panah di Haxe adalah: </p><br><ul><li>  <code>return</code> implisit.  Jika fungsi tubuh terdiri dari satu ekspresi, maka fungsi ini secara implisit mengembalikan nilai ekspresi ini </li><li>  dimungkinkan untuk mengatur jenis argumen fungsi, karena  kompiler tidak selalu dapat menentukan jenis yang diperlukan (mis. <code>Float</code> atau <code>Int</code> ) </li><li>  jika bodi fungsi terdiri dari beberapa ekspresi, maka Anda harus mengelilinginya dengan kurung kurawal </li><li>  tetapi tidak ada cara untuk secara eksplisit mengatur tipe kembalinya fungsi </li></ul><br><p>  Secara umum, sintaks fungsi panah sangat mirip dengan yang digunakan di Java 8 (meskipun bekerja agak berbeda). </p><br><p>  Dan karena kita menyebutkan Java, harus dikatakan bahwa dalam Haxe 4 menjadi mungkin untuk menghasilkan bytecode JVM secara langsung.  Untuk melakukan ini, ketika menyusun proyek di bawah Java, tambahkan saja flag <code>-D jvm</code> . </p><br><p>  Menghasilkan bytecode JVM berarti bahwa tidak perlu menggunakan kompiler Java, dan proses kompilasi jauh lebih cepat. </p><br><p><img src="https://habrastorage.org/webt/ut/bc/mw/utbcmwnuwk1ade_vqrztz5rzhjk.png" alt="gambar"></p><br><p>  Sejauh ini, target JVM memiliki status eksperimental karena alasan berikut: </p><br><ul><li>  dalam beberapa kasus, bytecode sedikit lebih lambat daripada hasil menerjemahkan Haxe di Jawa dan kemudian dikompilasi dengan javac.  Tetapi tim penyusun menyadari masalah dan tahu bagaimana memperbaikinya, itu hanya membutuhkan kerja tambahan. </li><li>  ada masalah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MethodHandle</a> di Android, yang juga membutuhkan pekerjaan tambahan (Simon akan senang jika dia membantu menyelesaikan masalah ini). </li></ul><br><p><img src="https://habrastorage.org/webt/yo/ho/r5/yohor5rg8cydts1horbcezmqqf0.png" alt="gambar"></p><br><p>  Perbandingan umum menghasilkan bytecode secara langsung (genjvm) dan mengkompilasi Haxe ke dalam kode Java, yang kemudian dikompilasi ke dalam bytecode (genjava): </p><br><ul><li>  seperti yang telah disebutkan, dalam hal kecepatan kompilasi, genjvm lebih cepat dari genjava <br>  dalam hal kecepatan eksekusi, bytecode genjvm masih kalah dengan genjava </li><li>  ada beberapa masalah saat menggunakan parameter tipe dan genjava </li><li>  genJvm menggunakan MethodHandle untuk merujuk ke fungsi, dan genjava menggunakan apa yang disebut "fungsi Waneck" (untuk menghormati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kaui Vanek</a> , berkat dukungan Java dan C # yang muncul di Haxe).  Meskipun kode yang diperoleh menggunakan fungsi-Waneck tidak terlihat cantik, ia bekerja dan bekerja cukup cepat. </li></ul><br><p>  Kiat umum untuk bekerja dengan Java di Haxe: </p><br><ul><li>  Karena fakta bahwa pengumpul sampah di Jawa cepat, masalah yang terkait dengannya jarang terjadi.  Tentu saja, terus-menerus membuat objek baru bukanlah ide yang baik, tetapi Java melakukan pekerjaan yang baik dalam mengelola memori dan kebutuhan untuk terus menjaga alokasi tidak separah pada beberapa platform lain yang didukung oleh Haxe (misalnya, di HashLink) </li><li>  mengakses bidang kelas dalam target jvm dapat bekerja sangat lambat jika ini dilakukan melalui struktur ( <code>typedef</code> ) - sedangkan kompiler tidak dapat mengoptimalkan kode tersebut </li><li>  penggunaan kata kunci <code>inline</code> berlebihan harus dihindari - kompiler JIT melakukan pekerjaan yang cukup baik </li><li>  Hindari penggunaan <code>Null&lt;T&gt;</code> , terutama saat berhadapan dengan perhitungan matematika yang rumit.  Kalau tidak, banyak pernyataan kondisional akan muncul dalam kode yang dihasilkan, yang akan berdampak negatif pada kecepatan kode Anda. </li></ul><br><p>  Fitur Haxe 4 baru, Null safety, dapat membantu menghindari penggunaan <code>Null&lt;T&gt;</code> .  Alexander Kuzmenko berbicara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara</a> rinci tentang dia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di HaxeUp tahun lalu</a> . </p><br><p><img src="https://habrastorage.org/webt/wx/hk/vk/wxhkvkjk-aq9pjo4mlp6l9hxrzi.png" alt="gambar"></p><br><p>  Pada contoh pada slide di atas, metode static <code>safe()</code> memiliki mode Strict untuk memeriksa keamanan Null diaktifkan, dan metode ini memiliki parameter <code>arg</code> opsional, yang dapat memiliki nilai nol.  Agar fungsi ini berhasil dikompilasi, pemrogram perlu menambahkan tanda centang pada nilai argumen <code>arg</code> (jika tidak, kompiler akan menampilkan pesan tentang ketidakmungkinan memanggil metode <code>charAt()</code> pada objek yang berpotensi nol). </p><br><p><img src="https://habrastorage.org/webt/sd/mq/md/sdmqmdmuv3lauh3wopzzblnxm8k.png" alt="gambar"></p><br><p>  Keamanan kosong dapat dikonfigurasi baik pada tingkat paket (menggunakan makro) dan tipe dan bidang individual objek (menggunakan tag meta <code>@:nullSafety</code> ). </p><br><p>  Mode di mana Null Security bekerja adalah: Strict, Loose, dan Off.  Secara global, pemeriksaan ini dinonaktifkan (Off-mode).  Ketika diaktifkan, mode Longgar digunakan secara default (kecuali jika Anda secara eksplisit menentukan mode).  Perbedaan utama antara mode Loose dan Strict adalah bahwa mode Loose mengabaikan kemungkinan perubahan nilai antara operasi mengakses nilai-nilai ini.  Pada contoh pada slide di bawah ini, kita melihat bahwa cek <code>null</code> telah ditambahkan untuk variabel <code>x</code> .  Namun, dalam mode Ketat, kode ini tidak dapat dikompilasi, karena  sebelum bekerja secara langsung dengan variabel <code>x</code> , metode <code>sideEffect()</code> , yang berpotensi menihilkan nilai variabel ini, jadi Anda perlu menambahkan tanda centang lain atau menyalin nilai variabel ke variabel lokal, yang akan terus kami kerjakan. </p><br><p><img src="https://habrastorage.org/webt/m6/sq/6w/m6sq6w1wgue4r9fiylnchvfaxk4.png" alt="gambar"></p><br><p>  Haxe 4 memperkenalkan kata kunci <code>final</code> baru, yang memiliki arti berbeda tergantung pada konteksnya: </p><br><ul><li>  jika Anda menggunakannya sebagai ganti kata kunci <code>var</code> , bidang yang dideklarasikan dengan cara ini tidak dapat diberi nilai baru.  Anda hanya dapat mengaturnya secara langsung ketika mendeklarasikan (untuk bidang statis) atau dalam konstruktor (untuk bidang non-statis) </li><li>  jika Anda menggunakannya saat mendeklarasikan sebuah kelas, itu akan melarang warisan darinya </li><li>  jika Anda menggunakannya sebagai pengubah untuk mengakses properti objek, maka ini melarang redefinisi pengambil / penyetel di kelas turunan. </li></ul><br><p><img src="https://habrastorage.org/webt/fo/je/_6/foje_6ftilhqwsyhnb-zbskf-l8.png" alt="gambar"></p><br><p>  Secara teoritis, kompiler, setelah memenuhi kata kunci <code>final</code> , dapat mencoba mengoptimalkan kode, dengan asumsi bahwa nilai bidang ini tidak berubah.  Tetapi untuk saat ini, kemungkinan ini hanya dipertimbangkan dan tidak diimplementasikan dalam kompiler. </p><br><p><img src="https://habrastorage.org/webt/aa/z_/th/aaz_thozjk6apzimnpf15tsfsja.png" alt="gambar"></p><br><p>  Dan sedikit tentang masa depan Haxe: </p><br><ul><li>  saat ini bekerja pada API I / O asinkron <br>  Dukungan Coroutine sudah direncanakan, tetapi sejauh ini, pekerjaan mereka masih terhambat pada tahap perencanaan.  Mungkin mereka akan muncul di Haxe 4.1, dan mungkin nanti. </li><li>  optimasi tail-call akan muncul di kompiler </li><li>  dan mungkin <a href="">fungsi yang tersedia di tingkat modul</a> .  Meskipun prioritas fitur ini terus berubah </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474452/">https://habr.com/ru/post/id474452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474440/index.html">Kesulitan dalam menghitung pendapatan dari langganan yang dapat diperbarui secara otomatis dalam aplikasi iOS</a></li>
<li><a href="../id474442/index.html">Kisah Ekstensi Kehidupan Irlandia</a></li>
<li><a href="../id474444/index.html">5 proyek pelatihan lebih berani untuk pengembang (Layer, Squoosh, Kalkulator, Crawler Situs Web, Music Player)</a></li>
<li><a href="../id474448/index.html">Apa yang mampu dimiliki otak seorang siswa di dunia komputer</a></li>
<li><a href="../id474450/index.html">Berhenti menggunakan TTL yang sangat kecil untuk DNS</a></li>
<li><a href="../id474458/index.html">Total kumulatif dalam SQL</a></li>
<li><a href="../id474460/index.html">Deskripsi arsitektur prosesor dalam LLVM menggunakan TableGen</a></li>
<li><a href="../id474462/index.html">Dataset terbuka yang besar untuk bahasa Rusia versi 1.0</a></li>
<li><a href="../id474466/index.html">Sejarah Diablo pertama</a></li>
<li><a href="../id474470/index.html">Serangan DDoS pada layanan RDP: kenali dan atasi. Pengalaman sukses dari Tucha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>