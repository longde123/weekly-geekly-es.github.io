<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óÄÔ∏è üë©üèº‚Äçüè≠ ‚õπüèª [Fran√ßais] Quand utiliser des flux parall√®les üî∞ ü§ë üë®üèø‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Source 
 Auteurs: Doug Lea en collaboration avec Brian Goetz, Paul Sandoz, Alexey Shipilev, Heinz Kabutz, Joe Bowbeer, ... 

 Le framework java.util.s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Fran√ßais] Quand utiliser des flux parall√®les</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420805/"><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> <br>  Auteurs: Doug Lea en collaboration avec Brian Goetz, Paul Sandoz, Alexey Shipilev, Heinz Kabutz, Joe Bowbeer, ... </blockquote><p> Le framework <code>java.util.streams</code> contient des op√©rations pilot√©es par les donn√©es sur les collections et d'autres sources de donn√©es.  La plupart des m√©thodes de flux effectuent la m√™me op√©ration sur chaque √©l√©ment.  En utilisant la m√©thode de collecte <code>parallelStream()</code> , si vous disposez de plusieurs c≈ìurs, vous pouvez transformer les <em>donn√©es pilot√©es</em> en <em>donn√©es parall√®les</em> .  Mais quand vaut-il la peine? </p><a name="habracut"></a><br><p>  Envisagez d'utiliser <code>S.parallelStream().operation(F)</code> au lieu de <code>S.stream().operation(F)</code> , √† condition que les op√©rations soient ind√©pendantes les unes des autres et soient co√ªteuses en termes de calcul ou appliqu√©es √† un grand nombre d'√©l√©ments qui sont effectivement fractionn√©s (divisibles) des structures de donn√©es, ou les deux.  Plus pr√©cis√©ment: </p><br><ul><li>  <code>F</code> : une fonction pour travailler avec un seul √©l√©ment, g√©n√©ralement un lambda, est ind√©pendante, c'est-√†-dire  l'op√©ration sur l'un des √©l√©ments est ind√©pendante et n'affecte pas les op√©rations sur d'autres √©l√©ments (pour des recommandations sur l'utilisation de fonctions sans √©tat sans interf√©rence, voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation du package de <em>flux</em></a> ). </li><li>  <code>S</code> : La collection d'origine est effectivement divis√©e.  En plus des collections, il existe d'autres adapt√©es √† la parall√©lisation, √† la diffusion de sources de donn√©es, par exemple, <code>java.util.SplittableRandom</code> (pour la parall√©lisation, vous pouvez utiliser la m√©thode <code>stream.parallel()</code> ).  Mais la plupart des sources avec E / S au c≈ìur sont principalement con√ßues pour un fonctionnement s√©quentiel. </li><li>  La dur√©e totale d'ex√©cution en mode s√©quentiel d√©passe la limite minimale autoris√©e.  Aujourd'hui, pour la plupart des plateformes, la limite est √† peu pr√®s √©gale (dans x10) √† 100 microsecondes.  Dans ce cas, des mesures pr√©cises ne sont pas n√©cessaires.  Pour des raisons pratiques, il suffit de multiplier simplement <code>N</code> (le nombre d'√©l√©ments) par <code>Q</code> (le temps de fonctionnement d'un <code>F</code> ), et <code>Q</code> peut √™tre estim√© approximativement par le nombre d'op√©rations ou le nombre de lignes de code.  Apr√®s cela, vous devez v√©rifier que <code>N * Q</code> est au moins inf√©rieur √† <code>10000</code> (si vous √™tes timide, ajoutez un ou deux z√©ros).  Donc, si <code>F</code> est une petite fonction comme <code>x -&gt; x + 1</code> , alors l'ex√©cution parall√®le aura un sens lorsque <code>N &gt;= 10000</code> .  Inversement, si <code>F</code> est un calcul de poids, semblable √† trouver le prochain meilleur coup dans une partie d'√©checs, alors la valeur de <code>Q</code> si grande que <code>N</code> peut √™tre n√©glig√©e, mais jusqu'√† ce que la collection soit compl√®tement divis√©e. </li></ul><br><p>  Le cadre de traitement du streaming n'insistera pas (et ne peut pas) insister sur aucun des √©l√©ments ci-dessus.  Si les calculs sont interd√©pendants, leur ex√©cution parall√®le n'a aucun sens, ou sera nuisible du tout et entra√Ænera des erreurs.  Les autres crit√®res d√©riv√©s des probl√®mes d'ing√©nierie et des compromis ci-dessus comprennent: </p><br><ul><li>  <em>D√©marrage</em> <br>  L'apparition de c≈ìurs suppl√©mentaires dans les processeurs, dans la plupart des cas, s'est accompagn√©e de l'ajout d'un m√©canisme de gestion de l'alimentation, ce qui peut entra√Æner un ralentissement du lancement des c≈ìurs, parfois avec des superpositions suppl√©mentaires de la JVM, du syst√®me d'exploitation et de l'hyperviseur.  Dans ce cas, la limite √† laquelle le mode parall√®le prend tout son sens correspond √† peu pr√®s au temps n√©cessaire pour commencer √† traiter les sous-t√¢ches avec un nombre suffisant de c≈ìurs.  Apr√®s cela, le calcul parall√®le peut √™tre plus √©conome en √©nergie que s√©quentiel (selon les d√©tails des processeurs et des syst√®mes. Pour un exemple, voir l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> ). </li><li>  <em>D√©tails (granularit√©)</em> <br>  Il est rarement judicieux de fractionner de petits calculs.  Le cadre divise g√©n√©ralement la t√¢che afin que les diff√©rentes pi√®ces puissent fonctionner sur tous les c≈ìurs syst√®me disponibles.  Si, apr√®s le d√©marrage, il n'y a pratiquement pas de travail pour chaque c≈ìur, les efforts (g√©n√©ralement s√©quentiels) pour organiser le calcul parall√®le seront vains.  √âtant donn√© que dans la pratique le nombre de c≈ìurs varie de 2 √† 256 seuils, il emp√™che √©galement l'effet ind√©sirable d'une division excessive de la t√¢che. </li><li>  <em>Divisibilit√©</em> <br>  Les collections fractionn√©es les plus efficaces incluent <code>ArrayList</code> et <code>{Concurrent}HashMap</code> , ainsi que les tableaux r√©guliers ( <code>T[]</code> , qui sont divis√©s en parties √† l'aide de m√©thodes statiques <code>java.util.Arrays</code> ).  Les s√©parateurs les moins efficaces sont <code>LinkedList</code> , <code>BlockingQueue</code> et la plupart des sources avec E / S bas√©es.  Les autres se situent quelque part au milieu (les structures de donn√©es qui prennent en charge l'acc√®s al√©atoire et / ou la recherche efficace sont g√©n√©ralement divis√©es efficacement).  Si le fractionnement des donn√©es prend plus de temps que le traitement, l'effort est vain.  Si <code>Q</code> est suffisamment grand, vous pouvez obtenir une augmentation en raison de la parall√©lisation, m√™me pour <code>LinkedList</code> , mais c'est un cas assez rare.  De plus, certaines sources ne peuvent pas √™tre divis√©es en un seul √©l√©ment et il peut donc y avoir une restriction sur le degr√© de d√©composition du probl√®me. </li></ul><br><p>  L'obtention des caract√©ristiques exactes de ces effets peut √™tre difficile (bien que, si vous essayez, cela peut √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait en</a> utilisant des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JMH</a> ).  Mais l'effet cumulatif est assez facile √† remarquer.  Pour le ressentir vous-m√™me - faites une exp√©rience.  Par exemple, sur une machine de test √† 32 c≈ìurs, lorsque vous ex√©cutez de petites fonctions, telles que <code>max()</code> ou <code>sum()</code> , au-dessus de <code>ArrayList</code> seuil de rentabilit√© est d'environ 10 000.  Pour plus d'√©l√©ments, une acc√©l√©ration jusqu'√† 20 fois est not√©e.  Les heures d'ouverture pour les collections de moins de 10 000 articles ne sont pas beaucoup moins que pour 10 000, et donc plus lentes que le traitement s√©quentiel.  Le pire r√©sultat se produit avec moins de 100 √©l√©ments - dans ce cas, les threads impliqu√©s s'arr√™tent sans rien faire d'utile, car  les calculs sont termin√©s avant de commencer.  D'un autre c√¥t√©, lorsque les op√©rations sur les √©l√©ments prennent du temps, lors de l'utilisation de collections efficaces et compl√®tement s√©parables, telles que <code>ArrayList</code> , les avantages sont imm√©diatement visibles. </p><br><p>  Pour paraphraser tout ce qui pr√©c√®de, l'utilisation de <code>parallel()</code> dans le cas d'une quantit√© de calcul d√©raisonnablement petite peut co√ªter environ <code>100</code> microsecondes, et une autre utilisation devrait √©conomiser au moins cette fois-ci (ou peut-√™tre des heures pour de tr√®s grandes t√¢ches).  Le co√ªt et les avantages sp√©cifiques varieront au fil du temps pour diff√©rentes plates-formes, et aussi, selon le contexte.  Par exemple, l'ex√©cution de petits calculs en parall√®le dans un cycle s√©quentiel am√©liore l'effet des hauts et des bas (les microtests de performance dans lesquels cela se produit peuvent ne pas refl√©ter la situation r√©elle). </p><br><h2 id="voprosy-i-otvety">  Q &amp; A </h2><br><ul><li>  Pourquoi la JVM ne peut-elle pas comprendre quand ex√©cuter des op√©rations en parall√®le? </li></ul><br><p>  Elle pourrait essayer, mais trop souvent la d√©cision serait mauvaise.  La recherche d'un parall√©lisme multic≈ìur enti√®rement automatique n'a pas conduit √† une solution universelle au cours des trente derni√®res ann√©es et, par cons√©quent, le cadre utilise une approche plus fiable, ne demandant √† l'utilisateur que de choisir entre <em>oui ou non</em> .  Ce choix est bas√© sur des probl√®mes d'ing√©nierie que l'on rencontre constamment dans la programmation s√©quentielle et qui ne dispara√Ætront probablement jamais compl√®tement.  Par exemple, vous pouvez rencontrer un ralentissement au centuple lorsque vous recherchez la valeur maximale dans une collection contenant un seul √©l√©ment en comparaison en utilisant directement cette valeur (sans collection).  Parfois, la JVM peut optimiser ces cas pour vous.  Mais cela se produit rarement dans les cas s√©quentiels, et jamais dans le cas du mode parall√®le.  D'un autre c√¥t√©, nous pouvons nous attendre √† ce qu'√† mesure qu'ils se d√©veloppent, les outils aident les utilisateurs √† prendre de meilleures d√©cisions. </p><br><ul><li>  Et si pour prendre une bonne d√©cision, je n'ai pas suffisamment de connaissances sur les param√®tres ( <code>F</code> , <code>N</code> , <code>Q</code> , <code>S</code> )? </li></ul><br><p>  Ceci est √©galement similaire aux probl√®mes rencontr√©s dans la programmation s√©quentielle.  Par exemple, la <code>S.contains(x)</code> de la classe <code>Collection</code> s'ex√©cute g√©n√©ralement rapidement si <code>S</code> est un <code>HashSet</code> , lente si <code>LinkedList</code> et moyenne dans les autres cas.  Habituellement, pour l'auteur d'un composant utilisant la collection, le meilleur moyen de sortir de cette situation est de l'encapsuler et de ne publier qu'une op√©ration sp√©cifique sur celui-ci.  Les utilisateurs seront alors isol√©s de la n√©cessit√© de choisir.  Il en va de m√™me pour les op√©rations parall√®les.  Par exemple, un composant avec une collecte de <em>prix</em> interne peut d√©terminer une m√©thode qui v√©rifie sa taille √† la limite, ce qui aura du sens jusqu'√† ce que le calcul au niveau du bit soit trop cher.  Un exemple: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaxPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> priceStream().max(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Stream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priceStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (prices.size() &lt; MIN_PAR) ? prices.stream() : prices.parallelStream(); }</code> </pre> <br><p>  Cette id√©e peut √™tre √©tendue √† d'autres consid√©rations sur le moment et la fa√ßon d'utiliser la concurrence. </p><br><ul><li>  Que faire si ma fonction effectue probablement des E / S ou des op√©rations synchronis√©es? </li></ul><br><p>  √Ä une extr√©mit√© se trouvent les fonctions qui ne r√©pondent pas aux crit√®res d'ind√©pendance, notamment les op√©rations d'E / S s√©quentielles, l'acc√®s au blocage des ressources synchronis√©es et les cas o√π une erreur dans une sous-t√¢che parall√®le qui effectue des E / S affecte les autres.  Leur parall√©lisation n'a pas beaucoup de sens.  D'un autre c√¥t√©, il existe des calculs qui effectuent occasionnellement des E / S ou rarement une synchronisation bloqu√©e (par exemple, la plupart des cas de journalisation et l'utilisation de collections comp√©titives telles que <code>ConcurrentHashMap</code> ).  Ils sont inoffensifs.  Ce qui les s√©pare n√©cessite plus de recherche.  Si chaque sous-t√¢che peut √™tre bloqu√©e pendant un temps consid√©rable en attendant les E / S ou l'acc√®s, les ressources CPU seront inactives sans possibilit√© d'utilisation par le programme ou la JVM.  De cela est mauvais pour tout le monde.  Dans ces cas, le traitement en streaming parall√®le n'est pas toujours le bon choix.  Mais il existe de bonnes alternatives - par exemple, les E / S asynchrones et l'approche <code>CompletableFuture</code> . </p><br><ul><li>  Que faire si ma source est bas√©e sur les E / S? </li></ul><br><p>  √Ä l'heure actuelle, √† l'aide des g√©n√©rateurs JDK <code>Stream</code> / I / O (par exemple, <code>BufferedReader.lines()</code> ), ils sont principalement adapt√©s pour une utilisation en mode s√©quentiel, en traitant les √©l√©ments un par un √† mesure qu'ils deviennent disponibles.  La prise en charge du traitement en masse hautes performances des E / S tamponn√©es est possible, mais pour le moment, cela n√©cessite le d√©veloppement de g√©n√©rateurs sp√©ciaux <code>Stream</code> s, <code>Spliterator</code> s et <code>Collector</code> s.  La prise en charge de certains cas courants peut √™tre ajout√©e dans les futures versions du JDK. </p><br><ul><li>  Que faire si mon programme s'ex√©cute sur un ordinateur occup√© et que tous les noyaux sont occup√©s? </li></ul><br><p>  Les machines ont g√©n√©ralement un nombre fixe de c≈ìurs et ne peuvent pas en cr√©er par magie de nouveaux lors de l'ex√©cution d'op√©rations parall√®les.  Cependant, tant que les crit√®res de choix d'un mode parall√®le parlent clairement, il n'y a aucun doute.  Vos t√¢ches parall√®les rivaliseront pour le CPU avec les autres et vous remarquerez moins d'acc√©l√©ration.  Dans la plupart des cas, cela reste plus efficace que d'autres alternatives.  Le m√©canisme sous-jacent est con√ßu de sorte que s'il n'y a pas de c≈ìurs disponibles, vous ne remarquerez qu'un l√©ger ralentissement par rapport √† la version s√©quentielle, sauf lorsque le syst√®me est tellement surcharg√© qu'il passe tout son temps √† changer de contexte au lieu de faire un vrai travail, ou configur√© dans l'espoir que tout le traitement est effectu√© s√©quentiellement.  Si vous avez un tel syst√®me, alors peut-√™tre que l'administrateur a d√©j√† d√©sactiv√© l'utilisation du multithreading / Nucl√©arit√© dans les param√®tres JVM.  Et si vous √™tes l'administrateur syst√®me, il est logique de le faire. </p><br><ul><li>  Toutes les op√©rations sont-elles parall√©lis√©es lors de l'utilisation du mode parall√®le? </li></ul><br><p>  Oui  Au moins dans une certaine mesure.  Mais il convient de tenir compte du fait que le cadre de flux prend en compte les limites des sources et des m√©thodes lors du choix de la mani√®re de proc√©der.  En g√©n√©ral, moins il y a de restrictions, plus le potentiel de parall√©lisme est grand.  D'un autre c√¥t√©, rien ne garantit que le cadre identifiera et appliquera toutes les opportunit√©s de simultan√©it√© disponibles.  Dans certains cas, si vous avez le temps et les comp√©tences, votre propre solution peut faire un bien meilleur usage des possibilit√©s de concurrence. </p><br><ul><li>  Quelle acc√©l√©ration vais-je obtenir de la concurrence? </li></ul><br><p>  Si vous respectez ces conseils, alors, g√©n√©ralement, assez pour avoir du sens.  La pr√©visibilit√© n'est pas un point fort du mat√©riel et des syst√®mes modernes, et il n'y a donc pas de r√©ponse universelle.  La localisation du cache, les caract√©ristiques du GC, la compilation JIT, les conflits d'acc√®s √† la m√©moire, l'emplacement des donn√©es, les politiques de planification du syst√®me d'exploitation et la pr√©sence d'un hyperviseur sont quelques-uns des facteurs qui ont un impact significatif.  Les performances du mode s√©quentiel sont √©galement soumises √† leur influence, qui, lors de l'utilisation du parall√©lisme, est souvent amplifi√©e: le probl√®me provoquant une diff√©rence de 10% en cas d'ex√©cution s√©quentielle peut entra√Æner une diff√©rence de 10 fois dans le traitement parall√®le. </p><br><p>  Le cadre de flux comprend certaines fonctionnalit√©s qui aident √† augmenter les chances d'acc√©l√©ration.  Par exemple, l'utilisation de la sp√©cialisation pour les primitives, telles que <code>IntStream</code> , a g√©n√©ralement un effet plus important pour le mode parall√®le que pour le mode s√©quentiel.  La raison en est que dans ce cas, non seulement la consommation de ressources (et de m√©moire) diminue, mais la localisation du cache s'am√©liore √©galement.  L'utilisation de <code>ConcurrentHashMap</code> au lieu de <code>HashMap</code> , dans le cas de l'op√©ration parall√®le de l'op√©ration de <code>collect</code> , r√©duit les co√ªts internes.  De nouveaux trucs et astuces appara√Ætront au fil de l'exp√©rience acquise avec le framework. </p><br><ul><li>  Tout cela fait trop peur!  Ne pouvons-nous pas simplement proposer des r√®gles d'utilisation des propri√©t√©s JVM pour d√©sactiver la concurrence? </li></ul><br><p>  Nous ne voulons pas vous dire quoi faire.  L'√©mergence de nouvelles fa√ßons pour les programmeurs de faire quelque chose de mal peut √™tre effrayante.  Des erreurs de code, d'architecture et d'√©valuations se produiront certainement.  Il y a des d√©cennies, certaines personnes pr√©disaient que la simultan√©it√© au niveau de l'application entra√Ænerait de grandes catastrophes.  Mais cela ne s'est jamais r√©alis√©. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420805/">https://habr.com/ru/post/fr420805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420793/index.html">D√©bogage en tant que processus</a></li>
<li><a href="../fr420795/index.html">Id√©es fausses de l'analyste</a></li>
<li><a href="../fr420797/index.html">L'apprentissage ne peut pas √™tre remis √† plus tard</a></li>
<li><a href="../fr420799/index.html">MPS 2018.2: tests de g√©n√©rateur, plug-in GitHub, aspect VCS, notifications de migration, etc.</a></li>
<li><a href="../fr420803/index.html">Cours d'impression 3D. √âconomie de plastique lors de l'impression de mod√®les non fonctionnels √† partir de 3Dtool</a></li>
<li><a href="../fr420809/index.html">Semaine de la s√©curit√© 31: cinquante nuances d'ins√©curit√© sur Android</a></li>
<li><a href="../fr420811/index.html">R√©seau de messagerie et de t√©l√©phonie d√©centralis√© de nouvelle g√©n√©ration</a></li>
<li><a href="../fr420813/index.html">R√©seaux dans les coulisses de Kubernetes</a></li>
<li><a href="../fr420815/index.html">Comment le "d√©codage du monde num√©rique" a explos√©: les 10 meilleurs rapports de DotNext 2018 Piter</a></li>
<li><a href="../fr420819/index.html">Top 10 des outils Python pour l'apprentissage automatique et la science des donn√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>