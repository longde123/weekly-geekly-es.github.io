<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÉ üñ§ üéÄ MVCC in PostgreSQL-7. Autovakuum üõåüèæ üé£ üéé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zur Erinnerung, wir begannen mit Problemen im Zusammenhang mit der Isolation , machten einen Exkurs √ºber die Datenstruktur auf niedriger Ebene , disku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-7. Autovakuum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/486104/">  Zur Erinnerung, wir begannen mit Problemen im Zusammenhang mit der <a href="https://habr.com/ru/company/postgrespro/blog/467437/">Isolation</a> , machten einen Exkurs √ºber die <a href="https://habr.com/ru/company/postgrespro/blog/469087/">Datenstruktur auf niedriger Ebene</a> , diskutierten <a href="https://habr.com/ru/company/postgrespro/blog/477648/">Zeilenversionen</a> im Detail und beobachteten, wie <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Datenschnappsch√ºsse</a> aus Zeilenversionen erhalten werden. <br><br>  Dann untersuchten wir <a href="https://habr.com/ru/company/postgrespro/blog/483768/">In-Page-Vakuum (und HOT-Updates)</a> und <a href="https://habr.com/ru/company/postgrespro/blog/484106/">Vakuum</a> .  Jetzt schauen wir uns das Autovakuum an. <br><br><h1>  Autovakuum </h1><br>  Wir haben bereits erw√§hnt, dass VACUUM normalerweise (dh wenn lange Zeit nichts den Transaktionshorizont festh√§lt) seine Arbeit erledigt.  Das Problem ist, wie oft man es anruft. <br><br>  Wenn wir einen Wickeltisch zu selten staubsaugen, w√§chst seine Gr√∂√üe mehr als gew√ºnscht.  Au√üerdem kann ein n√§chster Vakuumvorgang mehrere Indexdurchl√§ufe erfordern, wenn zu viele √Ñnderungen vorgenommen wurden. <br><br>  Wenn wir den Tisch zu oft staubsaugen, f√ºhrt der Server st√§ndig Wartungsarbeiten durch, anstatt n√ºtzliche Arbeiten auszuf√ºhren - und das ist auch nicht gut. <br><br>  Beachten Sie, dass das planm√§√üige Starten von VACUUM das Problem in keiner Weise behebt, da sich die Arbeitslast mit der Zeit √§ndern kann.  Wenn sich der Tisch st√§rker ver√§ndert, muss er h√§ufiger gesaugt werden. <br><br>  Autovakuum ist genau die Technik, die es uns erm√∂glicht, das Staubsaugen abh√§ngig von der Intensit√§t der Tischwechsel zu starten. <br><a name="habracut"></a><br>  Wenn Autovacuum aktiviert ist (der <em>Autovacuum-</em> Konfigurationsparametersatz), wird der <strong>Autovacuum-Launcher-</strong> Daemon-Prozess gestartet, der die Arbeit plant.  Das Staubsaugen selbst erfolgt durch <strong>Autovakuum-Worker-</strong> Prozesse, von denen mehrere Instanzen parallel ausgef√ºhrt werden k√∂nnen. <br><br>  Der <strong>Autovacuum Launcher-</strong> Prozess erstellt eine Liste von Datenbanken, in denen Aktivit√§ten stattfinden.  Die Aktivit√§t wird aus Statistiken ermittelt. <em>Um</em> sie zu erfassen, muss der Parameter <em>track_counts</em> festgelegt werden.  <em>Schalten</em> <em>Sie</em> niemals <em>autovacuum</em> und <em>track_counts aus</em> , sonst funktioniert die autovacuum-Funktion nicht. <br><br>  Einmal alle <em>autovacuum_naptime</em> Sekunden startet der <strong>Autovacuum-Launcher</strong> (unter Verwendung des <strong>Postmaster-</strong> Prozesses) einen Worker-Prozess f√ºr jede Datenbank in der Liste.  Mit anderen Worten, wenn eine Datenbank Aktivit√§ten enth√§lt, werden Worker-Prozesse in einem Intervall von <em>autovacuum_naptime</em> Sekunden an diese Datenbank gesendet.  Zu diesem Zweck werden Arbeitsprozesse N-mal so oft wie alle <em>autovacuum_naptime</em> Sekunden gestartet, wenn einige (N) aktive Datenbanken verf√ºgbar sind.  Die Gesamtzahl der gleichzeitig ausgef√ºhrten Worker-Prozesse ist jedoch durch den Parameter <em>autovacuum_max_workers</em> begrenzt. <br><br>  Beim Start stellt ein Worker-Prozess eine Verbindung zu der ihm zugewiesenen Datenbank her und erstellt zun√§chst eine Liste mit folgenden Elementen: <br><br><ul><li>  Alle Tabellen, materialisierten Ansichten und TOAST-Tabellen, die gesaugt werden m√ºssen. </li><li>  Alle zu analysierenden Tabellen und materialisierten Ansichten (TOAST-Tabellen werden nicht analysiert, da sie immer mit Indexzugriff erreicht werden). </li></ul><br>  Dann saugt und / oder analysiert der Arbeiter die Objekte auf der Liste nacheinander und wird abgeschlossen, wenn das Saugen beendet ist. <br><br>  Wenn der Prozess nicht alle in <em>autovacuum_naptime</em> Sekunden geplanten Arbeiten <em>ausf√ºhren</em> konnte, <strong>sendet</strong> der <strong>Autovacuum-Launcher-</strong> Prozess einen weiteren Worker-Prozess an diese Datenbank und sie arbeiten zusammen.  "Zusammen" bedeutet nur, dass der zweite Prozess eine eigene Liste erstellt und diese durcharbeitet.  Es werden also nur verschiedene Tabellen parallel verarbeitet, es gibt jedoch keine Parallelit√§t auf der Ebene einer Tabelle. Wenn einer der Arbeitsprozesse bereits eine Tabelle verarbeitet, wird diese von einem anderen Prozess √ºbersprungen und fortgesetzt. <br><br>  Lassen Sie uns nun n√§her erl√§utern, was unter "erfordert Staubsaugen" und "erfordert Analyse" zu verstehen ist. <br><br><blockquote>  K√ºrzlich wurde ein <a href="https://commitfest.postgresql.org/23/1774/">Patch</a> implementiert, mit dem das Vakuum Indizes parallel zu Hintergrund-Workern verarbeiten kann. <br></blockquote><br><h1>  Welche Tische m√ºssen gesaugt werden? </h1><br>  Das Staubsaugen wird als erforderlich angesehen, wenn die Anzahl der toten (dh veralteten) Tupel den angegebenen Schwellenwert √ºberschreitet.  Der Statistikkollektor verfolgt permanent die Anzahl der toten Tupel, die in der Tabelle <code>pg_stat_all_tables</code> gespeichert sind.  Und zwei Parameter geben den Schwellenwert an: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> definiert einen absoluten Wert (die Anzahl der Tupel). </li><li>  <em>autovacuum_vacuum_scale_factor</em> definiert den Anteil der Zeilen in der Tabelle. </li></ul><br>  Fazit: Staubsaugen ist erforderlich, wenn <code>pg_stat_all_tables.n_dead_tup</code> &gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Mit den Standardeinstellungen sind <em>autovacuum_vacuum_threshold</em> = 50 und <em>autovacuum_vacuum_scale_factor</em> = 0.2.  <em>autovacuum_vacuum_scale_factor</em> ist hier sicherlich der wichtigste - dieser Parameter ist entscheidend f√ºr gro√üe Tabellen (und mit diesen sind m√∂gliche Probleme verbunden).  Der Wert von 20% erscheint zu hoch und muss h√∂chstwahrscheinlich stark reduziert werden. <br><br>  Die optimalen Werte der Parameter k√∂nnen f√ºr verschiedene Tabellen variieren und h√§ngen von den Tabellengr√∂√üen und den Besonderheiten der √Ñnderungen ab.  Es ist sinnvoll, allgemein geeignete Werte festzulegen und bei Bedarf die Parameter auf der Ebene bestimmter Tabellen mit Hilfe von Speicherparametern zu optimieren: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> und <em>toast.autovacuum_vacuum_threshold</em> . </li><li>  <em>autovacuum_vacuum_scale_factor</em> und <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Um Verwirrung zu vermeiden, ist dies nur f√ºr wenige Tabellen sinnvoll, die sich im √úbrigen durch Umfang und Intensit√§t der √Ñnderungen auszeichnen, und nur dann, wenn die global festgelegten Werte nicht ordnungsgem√§√ü funktionieren. <br><br>  Au√üerdem k√∂nnen Sie den automatischen Unterdruck auf Tabellenebene ausschalten (obwohl wir uns kaum einen Grund vorstellen k√∂nnen, warum dies notwendig sein k√∂nnte): <br><br><ul><li>  <em>autovacuum_enabled</em> und <em>toast.autovacuum_enabled</em> . </li></ul><br>  Zum Beispiel, als wir das letzte Mal den Vakuumtisch mit ausgeschaltetem Autovakuum erstellt haben, um das Staubsaugen f√ºr Demozwecke manuell zu steuern.  Der Speicherparameter kann wie folgt ge√§ndert werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre><br>  Um all das zu formalisieren, erstellen wir eine Ansicht, die zeigt, welche Tabellen zu diesem Zeitpunkt gesaugt werden m√ºssen.  Dabei wird die Funktion verwendet, die den aktuellen Wert des Parameters zur√ºckgibt und ber√ºcksichtigt, dass der Wert auf Tabellenebene neu definiert werden kann: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">if</span></span></span><span class="ruby"> the storage parameter is set, we take its value (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE -- </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">for</span></span></span><span class="ruby"> TOAST tables, the parameter name differs WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), -- otherwise, we take the value of the configuration parameter current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Und das ist die Ansicht: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Welche Tabellen m√ºssen analysiert werden? </h1><br>  √Ñhnlich ist die Situation bei der automatischen Analyse.  Es wird davon ausgegangen, dass f√ºr diese Tabellen eine Analyse erforderlich ist, deren Anzahl aktualisierter Tupel (seit der letzten Analyse) den durch zwei √§hnliche Parameter angegebenen Schwellenwert √ºberschreitet: <code>pg_stat_all_tables.n_mod_since_analyze</code> &gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * <code>pg_class.reltupes</code> . <br><br>  Die Standardeinstellungen der automatischen Analyse sind etwas anders: <em>autovacuum_analyze_threshold</em> = 50 und <em>autovacuum_analyze_scale_factor</em> = 0.1.  Sie k√∂nnen auch auf der Ebene der Speicherparameter separater Tabellen definiert werden: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Da TOAST-Tabellen nicht analysiert werden, verf√ºgen sie nicht √ºber solche Parameter. <br><br>  Erstellen wir auch eine Ansicht zur Analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Beispiel </h1><br>  Stellen wir die folgenden Parameterwerte f√ºr Experimente ein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- to aviod waiting long =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Jetzt erstellen wir eine Tabelle, die der zuletzt verwendeten √§hnelt, und f√ºgen eintausend Zeilen ein.  Autovakuum ist auf Tischebene ausgeschaltet, und wir werden es selbst einschalten.  Ohne dies sind die Beispiele nicht reproduzierbar, da das automatische Absaugen zu einem schlechten Zeitpunkt ausgel√∂st werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Das zeigt unsere Sichtweise zum Staubsaugen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Hierbei sind zwei Dinge zu beachten.  Erstens ist <code>max_dead_tup</code> = 0, obwohl 3% von 1000 Zeilen 30 Zeilen ergeben.  Die Sache ist, dass wir noch keine Statistiken in der Tabelle haben, da INSERT sie nicht selbst aktualisiert.  Bis die Tabelle analysiert wird, bleiben Nullen, da <code>pg_class.reltuples</code> = 0 ist. Schauen wir uns jedoch die zweite Ansicht zur Analyse an: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Da in der Tabelle 1000 Zeilen ge√§ndert (hinzugef√ºgt) wurden, die gr√∂√üer als Null sind, muss eine automatische Analyse ausgel√∂st werden.  Lassen Sie uns das √ºberpr√ºfen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Nach einer kurzen Pause k√∂nnen wir sehen, dass die Tabelle analysiert wurde und dass in <code>max_dead_tup</code> anstelle von Nullen die richtigen 20 Zeilen angezeigt werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Kehren wir zum automatischen Staubsaugen zur√ºck: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Wie wir sehen k√∂nnen, wurde <code>max_dead_tup</code> bereits behoben.  Eine andere Sache, auf die man achten muss, ist <code>dead_tup</code> = 0. Die Statistik zeigt, dass die Tabelle keine toten Tupel hat ... und das ist wahr.  In der Tabelle gibt es noch nichts zu saugen.  Alle Tabellen, die ausschlie√ülich im Nur-Anh√§ngen-Modus verwendet werden, werden nicht gesaugt und daher wird die Sichtbarkeitskarte nicht aktualisiert.  Dies macht jedoch die Verwendung des Nur-Index-Scans unm√∂glich. <br><br>  (Das n√§chste Mal werden wir sehen, dass das Staubsaugen fr√ºher oder sp√§ter eine Nur-Anh√§ngen-Tabelle erreichen wird, aber dies wird zu selten passieren.) <br><br>  Eine Lektion gelernt: Wenn nur der Index-Scan kritisch ist, muss m√∂glicherweise ein Vakuumprozess manuell aufgerufen werden. <br><br>  Schalten Sie nun das automatische Vakuum wieder aus und aktualisieren Sie 31 Zeilen. Dies ist eine Zeile h√∂her als der Schwellenwert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  Jetzt ist die Bedingung der Vakuumausl√∂sung erf√ºllt.  Lassen Sie uns das automatische Vakuum einschalten und nach einer kurzen Pause werden wir sehen, dass die Tabelle verarbeitet wurde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Lastdrosselung </h1><br>  VACUUM blockiert keine anderen Prozesse, da es Seite f√ºr Seite arbeitet, aber es belastet das System zus√§tzlich und kann die Leistung erheblich beeintr√§chtigen. <br><br><h2>  Vakuum drosseln </h2><br>  Um die Vakuumintensit√§t und damit deren Auswirkung auf das System steuern zu k√∂nnen, wird abwechselnd gearbeitet und gewartet.  Der Prozess <em>erledigt</em> etwa das <em>Vakuum_Kosten_Begrenzen</em> herk√∂mmlicher Arbeitseinheiten und schl√§ft dann f√ºr <em>Vakuum_Kosten_Verz√∂gerungs-</em> ms. <br><br>  Die Standardeinstellungen sind <em>vacuum_cost_limit</em> = 200 und <em>vacuum_cost_delay</em> = 0. Die letzte Null bedeutet tats√§chlich, dass VACUUM nicht schl√§ft, sodass ein bestimmter Wert von <em>vacuum_cost_limit</em> √ºberhaupt keine Rolle spielt.  Der Grund daf√ºr ist, dass ein Administrator, der VACUUM manuell starten musste, wahrscheinlich w√ºnscht, dass das Staubsaugen so schnell wie m√∂glich erfolgt. <br><br>  Wenn wir jedoch die <em>Ruhezeit festlegen</em> , setzt sich der in <em>vacuum_cost_limit</em> angegebene <em>Arbeitsaufwand</em> aus den Kosten f√ºr die Arbeit mit Seiten im <em>Puffercache</em> zusammen.  Jeder Seitenzugriff wird wie folgt gesch√§tzt: <br><br><ul><li>  Wenn die Seite im <em>Puffercache</em> gefunden wird, ist <em>vacuum_cost_page_hit</em> = 1. </li><li>  Wenn es nicht gefunden wurde, ist <em>vacuum_cost_page_miss</em> = 10. </li><li>  Wenn es nicht gefunden wurde und eine schmutzige Seite zus√§tzlich aus dem Puffer-Cache entfernt werden musste, ist <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Das hei√üt, mit den Standardeinstellungen von <em>vacuum_cost_limit</em> k√∂nnen 200 <em>Cacheseiten</em> oder 20 Plattenseiten oder 10 Seiten mit R√§umung auf einmal verarbeitet werden.  Es ist klar, dass diese Zahlen ziemlich vorl√§ufig sind, aber es macht keinen Sinn, genauere Zahlen auszuw√§hlen. <br><br><h2>  Drosselung zum automatischen Absaugen </h2><br>  Bei Vakuumprozessen funktioniert die Lastdrosselung wie bei VACUUM.  Damit Autovakuumprozesse und manuell gestartetes VACUUM mit unterschiedlicher Intensit√§t arbeiten k√∂nnen, hat Autovakuum seine eigenen Parameter: <em>autovacuum_vacuum_cost_limit</em> und <em>autovacuum_vacuum_cost_delay</em> .  Wenn diese Parameter den Wert -1 haben, wird der Wert von <em>vacuum_cost_limit</em> und / oder <em>vacuum_cost_delay</em> verwendet. <br><br>  Standardm√§√üig ist <em>autovacuum_vacuum_cost_limit</em> = -1 ( <em>d. H.</em> Der Wert von <em>vacuum_cost_limit</em> = 200 wird verwendet) und <em>autovacuum_vacuum_cost_delay</em> = 20 ms.  Auf moderner Hardware ist das automatische Vakuum sehr langsam. <br><br>  In Version 12 wird der Wert von <em>autovacuum_vacuum_cost_delay</em> auf 2 ms reduziert, was f√ºr eine geeignetere erste Ann√§herung verwendet werden kann. <br><br>  Au√üerdem sollten wir beachten, dass das durch diese Einstellungen festgelegte Limit f√ºr alle Arbeitsprozesse gilt.  Mit anderen Worten, wenn die Anzahl der gleichzeitigen Arbeitsprozesse ge√§ndert wird, bleibt die Gesamtlast unver√§ndert.  Um die Autovakuum-Leistung beim Hinzuf√ºgen von Arbeitsprozessen zu erh√∂hen, ist es sinnvoll, auch <em>autovacuum_vacuum_cost_limit</em> zu erh√∂hen. <br><br><h2>  Speichernutzung und √úberwachung </h2><br>  <a href="https://habr.com/ru/company/postgrespro/blog/484106/">Das letzte Mal haben</a> wir beobachtet, wie VACUUM RAM der Gr√∂√üe <em>maintenance_work_mem</em> zum Speichern von zu saugenden Nachrichten verwendet hat. <br><br>  Autovacuum macht genau dasselbe.  Es k√∂nnen jedoch viele Worker-Prozesse gleichzeitig ausgef√ºhrt werden, wenn <em>autovacuum_max_workers</em> auf einen hohen Wert gesetzt ist.  Dar√ºber hinaus wird der gesamte Speicher auf einmal und nicht nach Bedarf zugewiesen.  Daher kann f√ºr einen Arbeitsprozess seine eigene Begrenzung mithilfe des Parameters <em>autovacuum_work_mem festgelegt</em> werden.  Der Standardwert dieses Parameters ist -1, dh er wird nicht verwendet. <br><br>  Wie bereits erw√§hnt, kann VACUUM auch mit einer minimalen Speichergr√∂√üe arbeiten.  Wenn jedoch Indizes f√ºr die Tabelle erstellt werden, kann ein kleiner Wert von <em>maintenance_work_mem</em> zu wiederholten Indexpr√ºfungen f√ºhren.  Gleiches gilt f√ºr Autovakuum.  Im Idealfall sollte <em>autovacuum_work_mem</em> einen Mindestwert haben, damit keine wiederholten Scans auftreten. <br><br>  Wir haben gesehen, dass zum √úberwachen von VACUUM die Option VERBOSE verwendet werden kann (die f√ºr Autovakuum nicht angegeben werden kann) oder die Ansicht <code>pg_stat_progress_vacuum</code> (die jedoch nur die aktuellen Informationen anzeigt).  Daher besteht das Hauptmittel zur √úberwachung des automatischen Absaugens in der Verwendung des Parameters <em>log_autovacuum_min_duration</em> , der die Informationen an das Servermeldungsprotokoll ausgibt.  Es ist standardm√§√üig deaktiviert (auf -1 gesetzt).  Es ist sinnvoll, diesen Parameter einzuschalten (mit dem Wert 0 werden Informationen √ºber alle automatischen Vakuuml√§ufe ausgegeben) und die Zahlen zu beobachten. <br><br>  So sehen die Ausgabeinformationen aus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Alle notwendigen Informationen finden Sie hier. <br><br>  Um Sie daran zu erinnern, ist es oft sinnvoll, die Schwelle f√ºr Vakuum-Triggerung zu senken, um weniger Daten gleichzeitig zu verarbeiten, anstatt die Speichergr√∂√üe zu erh√∂hen. <br><br>  Es kann auch sinnvoll sein, die obigen Ansichten zu verwenden, um die L√§nge der Liste der Tabellen zu √ºberwachen, f√ºr die ein Staubsaugen erforderlich ist.  Eine Erh√∂hung der Listenl√§nge zeigt an, dass die automatischen Vakuumprozesse nicht gen√ºgend Zeit haben, um ihre Arbeit zu erledigen, und dass die Einstellungen ge√§ndert werden m√ºssen. <br><br>  Fortsetzung folgt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486104/">https://habr.com/ru/post/de486104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486066/index.html">Im Zugangsbereich. Finden Sie die Entfernung von einem Punkt zu einem Gebiet und reduzieren Sie Reverse Geocoding-Anforderungen</a></li>
<li><a href="../de486070/index.html">ACL-Schalter im Detail</a></li>
<li><a href="../de486080/index.html">Lassen Sie mich vorstellen: Veeam Availability Suite v10</a></li>
<li><a href="../de486084/index.html">Ersetzen kleinerer Festplatten durch gr√∂√üere Festplatten unter Linux</a></li>
<li><a href="../de486100/index.html">Wie erstelle ich eine dezentrale Anwendung, die sich skalieren l√§sst? Verwenden Sie weniger Blockchain</a></li>
<li><a href="../de486106/index.html">Adaptive Hintergrundbeleuchtung f√ºr Raspberry Pi TV - Ambilight Analog</a></li>
<li><a href="../de486114/index.html">F√ºhrende Wissenschaftler auf dem Gebiet der Neurowissenschaften treffen sich auf dem j√§hrlichen Kongress der Neuronet Industry Union</a></li>
<li><a href="../de486116/index.html">Fermat- und Miller-Rabin-Einfachheitstests</a></li>
<li><a href="../de486120/index.html">Normalisierung der Abweichung. Wie falsche Praktiken in unserer Branche zur Norm werden</a></li>
<li><a href="../de486122/index.html">Child ReactJS mit 135 Codezeilen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>