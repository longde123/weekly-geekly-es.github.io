<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏿 🐵 🧢 Limites de concurrence adaptative dans Netflix 👴 😡 👩🏻‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Netflix est obsédé par la disponibilité des services. Nous l'avons déjà revu sur notre blog plus d'une fois et expliqué comment nous réussissons à att...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Limites de concurrence adaptative dans Netflix</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/413415/"><img src="https://habrastorage.org/webt/1f/9m/do/1f9mdoden4f5g0saek8572vqzk8.png"><br><br>  Netflix est obsédé par la disponibilité des services.  Nous l'avons déjà revu sur notre blog plus d'une fois et expliqué comment nous réussissons à atteindre nos objectifs.  Nous utilisons des disjoncteurs, des limites de simultanéité, des tests de chaos, etc.  Aujourd'hui, nous vous présentons une autre approche innovante qui améliore considérablement la stabilité de l'application sous des charges extrêmes et évite les défaillances de service en cascade - limites adaptatives pour les connexions parallèles.  Aucun effort supplémentaire n'est nécessaire pour déterminer les limites des connexions parallèles, permettant au système de maintenir un temps de réponse court.  Dans le cadre de cette annonce, nous publions également dans le domaine public une bibliothèque Java simple avec des capacités d'intégration pour les servlets, les programmes de contrôle et gRPC. <br><a name="habracut"></a><br><h4>  Commençons par les bases </h4><br>  La limite des connexions parallèles est le nombre maximal de demandes que le système est capable de traiter à un certain moment.  En règle générale, ce montant dépend d'une ressource limitée, telle que la puissance de traitement du processeur central.  Habituellement, la limite de connexions parallèles d'un système est calculée selon la loi de Little, qui se lit comme suit: pour un système stable, le nombre maximal de connexions parallèles est égal au produit du temps moyen passé à traiter la demande et de l'intensité moyenne des demandes entrantes (L = λW).  Toutes les demandes dépassant la limite de connexion parallèle ne peuvent pas être immédiatement traitées par le système, elles seront donc mises en file d'attente ou rejetées.  La mise en file d'attente est une fonction importante qui vous permet d'utiliser pleinement le système dans les cas où les demandes sont reçues de manière inégale et nécessitent un temps de traitement différent. <br><br><img src="https://habrastorage.org/webt/rt/xg/jc/rtxgjcvizrzpe0rffihujn_tfxq.png"><br><br>  S'il n'y a pas de limite pour la file d'attente, un plantage du système peut se produire, par exemple, si pendant longtemps l'intensité des demandes est supérieure à la vitesse de leur traitement.  À mesure que la file d'attente s'allonge, le délai augmente, ce qui entraîne un dépassement du temps d'attente pour les demandes.  Cela continue jusqu'à épuisement de la mémoire libre, après quoi le système se bloque.  Si vous ne suivez pas le temps de retard croissant, il commencera à affecter négativement les services d'appel et entraînera des défaillances du système en cascade. <br><br><img src="https://habrastorage.org/webt/so/wn/io/sowniojbjfektwb7esft-yaqham.png"><br><br>  L'utilisation de limites de connexion parallèle est une pratique standard, mais la difficulté réside dans leur détermination pour les grands systèmes distribués dynamiques, où les paramètres tels que le temps de retard et le nombre possible de connexions parallèles changent constamment.  L'essence de notre solution est la capacité de déterminer dynamiquement la limite des connexions parallèles.  Cette limite peut être représentée comme le nombre de demandes entrantes (exécutées en parallèle et en file d'attente) que le système est en mesure de traiter jusqu'à ce que ses performances commencent à diminuer (et que le temps de retard augmente). <br><br><h4>  Solution </h4><br>  Auparavant, les employés de Netflix déterminaient les limites de connexion simultanées manuelles grâce à des tests de performances et à un profilage fastidieux.  Le nombre résultant était correct pour une période de temps spécifique, mais bientôt la topologie du système a commencé à changer en raison de défaillances partielles, d'une mise à l'échelle automatique ou de l'introduction d'un code supplémentaire qui a affecté le temps de retard.  Par conséquent, la limite est obsolète.  Nous savions que nous étions capables de plus, qu'il ne nous suffisait plus de déterminer statiquement les limites de connexion.  Nous avions besoin d'un moyen de déterminer automatiquement les limites inhérentes au système lui-même.  En même temps, nous voulions cette méthode: <br><br><ol><li>  ne nécessitait pas de travail manuel; <br></li><li>  ne nécessitait pas de coordination centrale; <br></li><li>  pourrait déterminer la limite sans aucune information sur la topologie du matériel ou du système; <br></li><li>  Adapté aux changements de la topologie du système; <br></li><li>  était simple en termes de mise en œuvre et de calculs nécessaires. <br></li></ol><br>  Pour résoudre ce problème, nous nous sommes tournés vers l'algorithme éprouvé de suivi de la congestion TCP.  Cet algorithme détermine le nombre de paquets de données qui peuvent être transmis en parallèle (c'est-à-dire la taille de la fenêtre de débordement) sans augmenter le temps de retard ni dépasser le temps d'attente.  Ces algorithmes utilisent divers indicateurs pour déterminer la limite de paquets transmis simultanément et pour redimensionner la fenêtre de débordement en conséquence. <br><br><img src="https://habrastorage.org/webt/f-/ox/jo/f-oxjo0ds0ieqwv7flct4g5ntb8.png"><br><br>  La couleur bleue de l'image montre la limite inconnue pour les connexions parallèles au système.  Tout d'abord, le client envoie un petit nombre de demandes simultanées, puis il commence à vérifier périodiquement le système pour voir s'il peut traiter plus de demandes en augmentant la fenêtre de débordement jusqu'à ce que cela entraîne une augmentation du délai.  Lorsque le délai augmente encore, l'expéditeur décide qu'il a atteint la limite et réduit à nouveau la taille de la fenêtre de débordement.  Un tel test continu de la limite se reflète dans le graphique que vous voyez ci-dessus. <br><br>  Notre algorithme repose sur l'algorithme de suivi de congestion TCP, qui prend en compte la relation entre le temps de retard minimum (le meilleur scénario possible dans lequel la file d'attente n'est pas utilisée) et le temps de retard, qui est mesuré périodiquement au fur et à mesure de l'exécution des requêtes.  Ce rapport permet de déterminer qu'une file d'attente s'est formée provoquant une augmentation du retard.  Ce rapport nous donne le gradient ou l'amplitude du changement de temps de retard: <i>gradient = (RTTnoload / RTTactual)</i> .  Si la valeur est égale à un, alors nous comprenons qu'il n'y a pas de file d'attente et que la limite peut être augmentée.  Une valeur inférieure à un indique que la file d'attente est pleine et que la limite doit être réduite.  À chaque nouvelle mesure du temps de retard, la limite est ajustée en fonction du rapport ci-dessus, et avec elle la taille de file d'attente autorisée change conformément à cette formule simple: <br><br><pre><code class="hljs">_ = _ ×  + _</code> </pre> <br>  Pour plusieurs itérations, l'algorithme calcule une limite qui permet non seulement de maintenir le temps de retard à un niveau bas, mais aussi de former la file d'attente de requêtes nécessaire en cas de flambées d'activité.  La taille de file d'attente valide peut être configurée.  Il est utilisé pour déterminer la vitesse à laquelle la limite de simultanéité peut augmenter.  Comme taille par défaut, nous avons choisi la racine carrée de la valeur limite actuelle.  Ce choix est dû à la propriété utile de la racine carrée: aux petites valeurs, elle sera suffisamment grande par rapport à la limite pour assurer une croissance rapide, mais aux grandes valeurs, au contraire, sa valeur relative sera moindre, ce qui augmentera la stabilité du système. <br><br><h4>  Limites adaptatives en action </h4><br>  Les limites adaptatives côté serveur rejettent les demandes excessives et maintiennent une faible latence, ce qui permet à l'instance système de se protéger et de protéger les services dont elle dépend.  Auparavant, lorsqu'il n'était pas possible de rejeter des demandes excessives, toute augmentation régulière du nombre de demandes par seconde ou de retard entraînait une augmentation encore plus importante de ce délai et, finalement, la chute de l'ensemble du système.  Aujourd'hui, les services peuvent se débarrasser des charges de travail inutiles et maintenir une faible latence tout en travaillant avec d'autres outils de stabilisation, tels que la mise à l'échelle automatique. <br><br><img src="https://habrastorage.org/webt/zh/vp/zx/zhvpzxo9x0fp_pb_ckdcf9plhks.png"><br><br>  Il est important de se rappeler que des limites sont fixées au niveau du serveur (et sans aucune coordination), que le trafic vers chaque serveur peut chuter et augmenter fortement.  Par conséquent, il n'est pas surprenant que la limite détectée et le nombre de connexions simultanées puissent être différents selon le serveur.  Cela est particulièrement vrai dans un environnement cloud multi-clients.  Par conséquent, une situation peut se produire lorsqu'un serveur est surchargé, bien que le reste soit gratuit.  Dans le même temps, lors de l'équilibrage de la charge côté client, une seule demande répétée parviendra au serveur avec des ressources gratuites dans près de 100% des cas.  Et ce n'est pas tout: il n'y a plus de raison de craindre que des requêtes répétées provoquent une attaque DDOS, car les services sont capables de rejeter rapidement (en moins d'une milliseconde) le trafic avec un impact minimal sur les performances. <br><br><h4>  Conclusion </h4><br>  L'utilisation de limites adaptatives pour les connexions parallèles élimine la nécessité de déterminer manuellement comment et dans quels cas nos services doivent rejeter le trafic.  De plus, cela augmente également la fiabilité et la disponibilité globales de l'ensemble de notre écosystème de microservices. <br><br>  Nous sommes heureux de partager avec vous nos méthodes de mise en œuvre et l'intégration globale de cette solution, que vous pouvez trouver dans la bibliothèque publique à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/Netflix/concurrency-limits</a> .  Nous espérons que notre code aidera les utilisateurs à protéger leurs services contre les défaillances en cascade et les problèmes liés à l'augmentation de la latence, ainsi qu'à accroître leur disponibilité. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413415/">https://habr.com/ru/post/fr413415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413405/index.html">Les meilleurs livres, articles et ressources pour les produits pour débutants: les auteurs des produits Télégrammes conseillent</a></li>
<li><a href="../fr413407/index.html">Méthodes d'attribution dans les trackers populaires: correspondance d'ID de périphérique, référence d'installation et empreinte digitale</a></li>
<li><a href="../fr413409/index.html">Kubernetes d'Amazon (EKS) rendu public</a></li>
<li><a href="../fr413411/index.html">Nous surveillons les sessions actives de PostgreSQL 10, comme dans Oracle</a></li>
<li><a href="../fr413413/index.html">Présentation des composants Symfony: configuration</a></li>
<li><a href="../fr413417/index.html">Efficacité énergétique: les approches que nous testons en Russie</a></li>
<li><a href="../fr413419/index.html">Résumé des nouvelles de PostgreSQL. Numéro 7</a></li>
<li><a href="../fr413421/index.html">Incertitudes possibles dans la carrière d'un programmeur</a></li>
<li><a href="../fr413423/index.html">Solutions d'accès à distance dans Mars IS</a></li>
<li><a href="../fr413427/index.html">Programmation pour les ingénieurs réseau: utilisation de la configuration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>