<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔛 🌈 🛌🏽 Docker + Laravel = ❤ ⌚️ 👨🏼‍🚀 🎹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais parler de mon expérience de «wrapper» une application Laravel dans un conteneur Docker afin que les développeurs frontend et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker + Laravel = ❤</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425101/"><p><img src="https://habrastorage.org/getpro/habr/post_images/89c/b0e/91f/89cb0e91fd1efafb24b66b7ee44dc1b0.png" alt="laravel-in-docker"></p><br><p> Dans cet article, je vais parler de mon expérience de «wrapper» une application Laravel dans un conteneur Docker afin que les développeurs frontend et backend puissent travailler localement avec elle, et la lancer en production était aussi simple que possible.  De plus, CI exécutera automatiquement des analyseurs de code statique, des tests de <code>phpunit</code> et construira des images. </p><br><p>  "Et qu'est-ce que la complexité en fait?"  - vous pouvez dire, et vous aurez en partie raison.  Le fait est que beaucoup de discussions dans les communautés russophones et anglophones sont consacrées à ce sujet, et je diviserais conditionnellement presque tous les fils étudiés dans les catégories suivantes: </p><br><ul><li>  "J'utilise docker pour le développement local. J'ai mis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">laradock</a> et je ne connais pas les problèmes."  Cool, mais qu'en est-il du lancement de l'automatisation et de la production? </li><li>  "Je récupère un conteneur <em>(monolith)</em> basé sur <code>fedora:latest</code> (~ 230 Mo), y mets tous les services (nginx, db, cache, etc.), exécute tout à l'intérieur du superviseur."  Également excellent, facile à démarrer, mais qu'en est-il de l'idéologie «un conteneur - un processus»?  Qu'en est-il de l'équilibrage et de la gestion des processus?  Quelle est la taille de l'image? </li><li>  "Voici des morceaux de configs, assaisonnez avec des extraits de sh-scripts, ajoutez des valeurs env magiques, utilisez-le."  Merci, mais qu'en est-il d'au moins un exemple vivant que je pourrais bifurquer et jouer pleinement? </li></ul><br><p>  Tout ce que vous lisez ci-dessous est une expérience subjective qui ne prétend pas être la vérité ultime.  Si vous avez des ajouts ou des indications d'inexactitudes - bienvenue aux commentaires. </p><br><blockquote>  Pour les impatients - un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers le référentiel</a> , clonez que vous pouvez démarrer l'application Laravel avec une seule commande.  Il ne sera pas non plus difficile de l'exécuter sur le même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">éleveur</a> , de «lier» correctement les conteneurs ou d'utiliser la version d'épicerie <code>docker-compose.yml</code> comme point de départ. </blockquote><a name="habracut"></a><br><h2 id="chast-teoreticheskaya">  Partie théorique </h2><br><p>  Quels outils utiliserons-nous dans notre travail et sur quoi nous concentrerons-nous?  Tout d'abord, nous devons installer sur l'hôte: </p><br><ul><li>  <code>docker</code> - au moment de la rédaction, j'ai utilisé la version <code>18.06.1-ce</code> </li><li>  <code>docker-compose</code> - il gère la liaison des conteneurs et le stockage des valeurs d'environnement nécessaires;  version <code>1.22.0</code> </li><li>  <code>make</code> - vous pourriez être surpris, mais cela s'intègre parfaitement dans le contexte de travail avec docker </li></ul><br><blockquote>  Vous pouvez <code>curl -fsSL get.docker.com | sudo sh</code> <code>docker</code> sur des systèmes de type <code>debian</code> avec la commande <code>curl -fsSL get.docker.com | sudo sh</code>  <code>curl -fsSL get.docker.com | sudo sh</code> , mais <code>docker-compose</code> préférable d'installer à l'aide de <code>pip</code> , car les versions les plus récentes vivent dans ses référentiels ( <code>apt</code> loin derrière, en règle générale). </blockquote><p>  Ceci complète la liste des dépendances.  Ce que vous utiliserez pour travailler avec le code source - <code>phpstorm</code> , <code>phpstorm</code> ou le <code>vim</code> mort - c'est à vous. </p><br><p>  Ensuite, un contrôle qualité impromptu dans le contexte de la conception d'image <em>(je n'ai pas peur de ce mot)</em> : </p><br><ul><li><p>  <strong>Q: Image de base - quel est le meilleur choix?</strong> </p><br></li><li><p>  <strong>R:</strong> Celui qui est "plus mince", sans fioritures.  Sur la base de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>alpine</code></a> <em>(~ 5 Mo),</em> vous pouvez collecter tout ce que votre cœur désire, mais vous devrez probablement jouer avec l'ensemble des services de la source.  Comme alternative - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>jessie-slim</code></a> <em>(~ 30 Mo)</em> .  Ou utilisez celui qui est le plus souvent utilisé dans vos projets. </p><br></li><li><p>  <strong>Q: Pourquoi le poids de l'image est-il important?</strong> </p><br></li><li><p>  <strong>R:</strong> Diminution du volume de trafic, diminution de la probabilité d'une erreur lors du téléchargement (moins de données - moins de probabilité), diminution de la place consommée.  La règle "La gravité est fiable" (© "Snatch") ne fonctionne pas très bien ici. </p><br></li><li><p>  <strong>Q: Mais mon ami <code>%friend_name%</code> dit qu'une image "monolithique" avec toutes les dépendances est le meilleur moyen.</strong> </p><br></li><li><p>  <strong>R:</strong> Disons simplement compter.  L'application a 3 dépendances - PG, Redis, PHP.  Et vous vouliez tester son comportement dans des bundles de différentes versions de ces dépendances.  PG - versions 9.6 et 10, Redis - 3.2 et 4.0, PHP - 7.0 et 7.2.  Dans le cas où chaque dépendance est une image distincte - vous en avez besoin de 6, que vous n'avez même pas besoin de collecter - tout est prêt et se trouve sur <code>hub.docker.com</code> .  Si, pour des raisons idéologiques, toutes les dépendances sont "emballées" dans un seul conteneur, vous devez le remonter avec des stylos ... 8 fois?  Ajoutez maintenant la condition que vous voulez toujours jouer avec <code>opcache</code> .  Dans le cas d'une décomposition, il s'agit simplement d'un changement dans les balises des images utilisées.  Un monolithe est plus facile à gérer et à entretenir, mais c'est la route vers nulle part. </p><br></li><li><p>  <strong>Q: Pourquoi le superviseur du conteneur est-il mauvais?</strong> </p><br></li><li><p>  <strong>R:</strong> Parce que <code>PID 1</code> .  Si vous ne voulez pas une multitude de problèmes avec les processus zombies et que vous avez la possibilité d '«ajouter de la capacité» de manière flexible si nécessaire - essayez d'exécuter un processus par conteneur.  Une exception particulière est <code>nginx</code> avec ses employés et <code>php-fpm</code> , qui ont la capacité de produire des processus, mais doivent le supporter (en outre, ils ne sont pas mauvais pour réagir à <code>SIGTERM</code> , "tuant" à juste titre leurs employés).  En lançant tous les démons en tant que superviseur, vous vous condamnez certainement à des problèmes.  Bien que, dans certains cas, il soit difficile de s'en passer, ce sont déjà des exceptions. </p><br></li></ul><br><p>  Après avoir décidé des principales approches, passons à notre application.  Il doit pouvoir: </p><br><ul><li>  <code>web|api</code> - donnez statique avec <code>nginx</code> , et générez du contenu dynamique avec <code>fpm</code> </li><li>  <code>scheduler</code> - exécuter le planificateur de tâches natif </li><li>  <code>queue</code> - traiter les travaux des files d'attente </li></ul><br><p>  Un ensemble de base qui peut être étendu si nécessaire.  Passons maintenant aux images que nous devons collecter pour que notre application «décolle» (leurs noms de code sont indiqués entre parenthèses): </p><br><ul><li>  <code>PHP + PHP-FPM</code> ( <strong>app</strong> ) - l'environnement dans lequel notre code sera exécuté.  Étant donné que les versions de PHP et de FPM seront les mêmes pour nous - nous les collectons dans une seule image.  Il est donc plus facile à gérer avec les configurations, et la composition des packages sera identique.  Bien sûr - FPM et les processus d'application s'exécuteront dans différents conteneurs </li><li>  <code>nginx</code> ( <strong>nginx</strong> ) - cela ne dérangerait pas la livraison de configs et de modules optionnels pour <code>nginx</code> - nous collecterons une image séparée avec.  Puisqu'il s'agit d'un service distinct, il a son propre fichier docker et son contexte </li><li>  Sources de l'application ( <strong>sources</strong> ) - la source sera livrée à l'aide d'une image distincte, montant le <code>volume</code> avec eux dans un conteneur avec l'application.  L'image de base est <code>alpine</code> , à l'intérieur, il n'y a que des sources avec des dépendances installées et collectées à l'aide des actifs du webpack (génération d'artefacts) </li></ul><br><p>  D'autres services de développement sont lancés dans des conteneurs, les tirant de <code>hub.docker.com</code> ;  sur la production, d'autre part - ils fonctionnent sur des serveurs distincts, en cluster.  Il ne nous reste plus qu'à indiquer à l'application <em>(via l'environnement)</em> à quelles adresses / ports et avec quels détails il faut y toucher.  Encore plus cool est d'utiliser la découverte de services à cette fin, mais pas à cette époque. </p><br><p>  Après avoir décidé de la partie théorique, je propose de passer à la partie suivante. </p><br><h2 id="chast-prakticheskaya">  La partie pratique </h2><br><p>  Je suggère d'organiser les fichiers dans le référentiel comme suit: </p><br><pre> <code class="hljs css">. ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> #    <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>   │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> │  │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │  │  └── ... │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">nginx</span></span> │  │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │  │  └── ... │  └── <span class="hljs-selector-tag"><span class="hljs-selector-tag">sources</span></span> │    ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │    └── ... ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">src</span></span> #   │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">bootstrap</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">artisan</span></span> │ └── ... ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose-</span></span>    ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Makefile</span></span> ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHANGELOG</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span> └── <span class="hljs-selector-tag"><span class="hljs-selector-tag">README</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span></code> </pre> <br><blockquote>  Vous pouvez vous familiariser avec la structure et les fichiers en cliquant sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . </blockquote><p>  Pour créer un service, vous pouvez utiliser la commande: </p><br><pre> <code class="bash hljs">$ docker build \ --tag %local_image_name% \ -f ./docker/%service_directory%/Dockerfile ./docker/%service_directory%</code> </pre> <br><p>  La seule différence sera l'assemblage de l'image avec les sources - pour cela, le contexte d'assemblage (argument extrême) <code>./src</code> être défini sur <code>./src</code> . </p><br><p>  Les règles de dénomination des images dans le registre local recommandent d'utiliser celles que <code>docker-compose</code> utilise par défaut, à savoir: <code>%root_directory_name%_%service_name%</code> .  Si le répertoire du projet est appelé <code>my-awesome-project</code> et que le service est nommé <code>redis</code> , le nom de l'image (local) est préférable de choisir <code>my-awesome-project_redis</code> respectivement. </p><br><blockquote>  Pour accélérer le processus de construction, vous pouvez dire au docker d'utiliser le cache de l'image précédemment assemblée, et pour cela, l' <code>--cache-from %full_registry_name%</code> lancement <code>--cache-from %full_registry_name%</code> .  Ainsi, le démon docker va regarder avant de démarrer une instruction particulière dans le Dockerfile - a-t-elle changé?  Et sinon (le hachage converge) - il sautera l'instruction, en utilisant le calque déjà préparé de l'image, que vous lui direz d'utiliser comme cache.  Cette chose n'est pas mauvaise donc elle va reconstruire le processus, surtout si rien n'a changé :) <br><br>  Faites attention aux scripts <code>ENTRYPOINT</code> pour lancer les conteneurs d'applications. </blockquote><p>  L'image de l'environnement de lancement de l'application (app) a été collectée en tenant compte du fait que cela fonctionnera non seulement en production, mais aussi localement, les développeurs doivent interagir efficacement avec elle.  L'installation et la suppression des dépendances du <code>composer</code> , l'exécution de tests <code>unit</code> , les journaux de fin et l'utilisation d'alias familiers ( <code>php /app/artisan</code> → <code>art</code> , <code>composer</code> → <code>c</code> ) devraient être sans aucun inconfort.  De plus - il sera également utilisé pour exécuter des tests <code>unit</code> et des analyseurs de code statique ( <code>phpstan</code> dans notre cas) sur CI.  C'est pourquoi son Dockerfile, par exemple, contient la <code>xdebug</code> installation de <code>xdebug</code> , mais le module lui-même n'est pas activé (il est activé uniquement à l'aide de CI). </p><br><blockquote>  De plus, pour le <code>composer</code> le <code>hirak/prestissimo</code> est <code>hirak/prestissimo</code> , ce qui augmente considérablement l'installation de toutes les dépendances. </blockquote><p>  En production, nous montons le contenu du répertoire <code>/src</code> partir de l'image avec les sources (sources) à l'intérieur dans le répertoire <code>/app</code> .  Pour le développement, nous «survolons» le répertoire local avec les sources d'application ( <code>-v "$(pwd)/src:/app:rw"</code> ). </p><br><p>  Et ici réside une complexité - ce sont <strong>les droits d'accès aux fichiers</strong> créés à partir du conteneur.  Le fait est que par défaut les processus en cours d'exécution à l'intérieur du conteneur démarrent à partir de la racine ( <code>root:root</code> ), les fichiers créés par ces processus (cache, logs, sessions, etc.) - aussi, et par conséquent - vous n'avez rien «localement» avec eux vous pouvez le faire sans exécuter <code>sudo chown -R $(id -u):$(id -g) /path/to/sources</code> . </p><br><p>  Comme solution, utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fixuid</a> , mais cette solution est simple.  Le meilleur moyen m'a semblé de <code>USER_ID</code> local et son <code>GROUP_ID</code> à l'intérieur du conteneur, et de <a href="">démarrer les processus avec ces valeurs</a> .  Par défaut, la substitution des valeurs <code>1000:1000</code> (les valeurs par défaut pour le premier utilisateur local) s'est débarrassée de l'appel <code>$(id -u):$(id -g)</code> , et si nécessaire, vous pouvez toujours les remplacer ( <code>$ USER_ID=666 docker-compose up -d</code> ) ou placez le fichier docker-compose dans le fichier <code>.env</code> . </p><br><p>  De plus, lorsque <code>php-fpm</code> lancé localement <code>php-fpm</code> pas d'en désactiver <code>opcache</code> - sinon il y a beaucoup de "oui quoi diable!"  vous sera fourni. </p><br><p>  Pour une connexion "directe" à redis et postgres, j'ai jeté des ports supplémentaires "out" ( <code>15432</code> et <code>15432</code> respectivement), donc il n'y a aucun problème avec "se connecter et voir ce que c'est vraiment" et en principe ". </p><br><p>  Je garde le conteneur avec l' <code>app</code> nom de code en cours d'exécution ( <code>--command keep-alive.sh</code> ) dans le but d'un accès pratique à l'application. </p><br><p>  Voici quelques exemples de résolution de problèmes quotidiens avec <code>docker-compose</code> : </p><br><table><thead><tr><th>  Fonctionnement </th><th>  Commande en cours d'exécution </th></tr></thead><tbody><tr><td>  Installer le package du <code>composer</code> </td><td> <code>$ docker-compose exec app composer require package/name</code> </td> </tr><tr><td>  Exécuter phpunit </td><td> <code>$ docker-compose exec app php ./vendor/bin/phpunit --no-coverage</code> </td> </tr><tr><td>  Installer toutes les dépendances de noeud </td><td> <code>$ docker-compose run --rm node npm install</code> </td> </tr><tr><td>  Installer le package de noeud </td><td> <code>$ docker-compose run --rm node npm i package_name</code> </td> </tr><tr><td>  Lancement d'une reconstruction en direct des actifs </td><td> <code>$ docker-compose run --rm node npm run watch</code> </td> </tr></tbody></table><br><p>  Vous pouvez trouver tous les détails de lancement dans le <strong><a href="">fichier docker-compose.yml</a></strong> . </p><br><h4 id="coy-make-zhiv"><del>  Choi </del>  <code>make</code> vivant! </h4><br><p>  Taper les mêmes commandes à chaque fois devient ennuyeux après la deuxième fois, et puisque les programmeurs sont des créatures paresseuses par nature, faisons leur «automatisation».  Conserver un ensemble de scripts <code>sh</code> est une option, mais pas aussi attrayante qu'un <code>Makefile</code> , d'autant plus que son applicabilité dans le développement moderne est largement sous-estimée. </p><br><blockquote>  Vous trouverez le manuel complet en russe à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . </blockquote><p>  Voyons à quoi ressemble le <code>make</code> run à la racine du référentiel: </p><br><pre> <code class="bash hljs">[user@host ~/projects/app] $ make <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Show this <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> app-pull Application - pull latest Docker image (from remote registry) app Application - build Docker image locally app-push Application - tag and push Docker image into remote registry sources-pull Sources - pull latest Docker image (from remote registry) sources Sources - build Docker image locally sources-push Sources - tag and push Docker image into remote registry nginx-pull Nginx - pull latest Docker image (from remote registry) nginx Nginx - build Docker image locally nginx-push Nginx - tag and push Docker image into remote registry pull Pull all Docker images (from remote registry) build Build all Docker images push Tag and push all Docker images into remote registry login Log <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> to a remote Docker registry clean Remove images from <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> registry --------------- --------------- up Start all containers (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> background) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development down Stop all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers restart Restart all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers shell Start shell into application container install Install application dependencies into application container watch Start watching assets <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> changes (node) init Make full application initialization (install, seed, build assets) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Execute application tests Allowed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> overriding next properties: PULL_TAG - Tag <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pulling images before building own (<span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) PUBLISH_TAGS - Tags list <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building and pushing into remote registry (delimiter - single space, <span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) Usage example: make PULL_TAG=<span class="hljs-string"><span class="hljs-string">'v1.2.3'</span></span> PUBLISH_TAGS=<span class="hljs-string"><span class="hljs-string">'latest v1.2.3 test-tag'</span></span> app-push</code> </pre> <br><p>  Il est très bon pour les objectifs addictifs.  Par exemple, pour exécuter la <code>watch</code> ( <code>docker-compose run --rm node npm run watch</code> ), vous avez besoin que l'application soit «augmentée» - il vous suffit de spécifier la cible <code>up</code> comme dépendante - et vous n'avez pas à vous soucier d'oublier de le faire avant d'appeler <code>watch</code> - <code>make</code> lui-même fera tout pour vous.  La même chose s'applique à l'exécution de tests et d'analyseurs statiques, par exemple, avant de valider des modifications - exécutez un <code>make test</code> et toute la magie se produira pour vous! </p><br><p>  Inutile de dire que vous n'avez pas à vous soucier de l'assemblage d'images, de les télécharger, de spécifier <code>--cache-from</code> et à peu près tout? </p><br><p>  Vous pouvez voir le contenu du <code>Makefile</code> sur <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a></strong> . </p><br><h2 id="chast-avtomaticheskaya">  Pièce auto </h2><br><p>  Commençons la dernière partie de cet article - il s'agit de l'automatisation du processus de mise à jour des images dans le Docker Registry.  Bien que dans mon exemple, GitLab CI soit utilisé - pour transférer l'idée vers un autre service d'intégration, je pense que ce sera tout à fait possible. </p><br><p>  Tout d'abord, nous déterminerons la dénomination des balises d'image utilisées: </p><br><table><thead><tr><th>  Nom du tag </th><th>  Destination </th></tr></thead><tbody><tr><td> <code>latest</code> </td> <td>  Images recueillies auprès de la branche principale. <br>  L'état du code est le plus récent, mais pas encore prêt à entrer dans la version </td></tr><tr><td> <code>some-branch-name</code> </td> <td>  Images collectées sur le brunch du nom d' <code>some-branch-name</code> . <br>  Ainsi, nous pouvons «déployer» les changements dans n'importe quel environnement qui ont été implémentés uniquement dans le cadre d'un brunch spécifique avant de les fusionner avec le <code>master</code> -light - il suffit de «étirer» les images avec cette balise. <br>  Et - oui, les changements peuvent concerner à la fois le code et les images de tous les services en général! </td></tr><tr><td> <code>vX.XX</code> </td> <td>  En fait, la sortie de l'application (à utiliser pour déployer une version spécifique) </td></tr><tr><td> <code>stable</code> </td> <td>  Alias, pour la balise avec la dernière version (à utiliser pour déployer la dernière version stable) </td></tr></tbody></table><br><p>  La sortie a lieu en publiant une balise dans un <code>vX.XX</code> format <code>vX.XX</code> </p><br><p>  Pour accélérer la construction, la mise en cache des répertoires <code>./src/vendor</code> et <code>./src/node_modules</code> + <code>--cache-from</code> pour la <code>docker build</code> et comprend les étapes suivantes: </p><br><table><thead><tr><th>  Nom de la scène </th><th>  Destination </th></tr></thead><tbody><tr><td> <code>prepare</code> </td> <td>  La phase préparatoire - l'assemblage d'images de tous les services <strong>sauf l'</strong> image avec la source </td></tr><tr><td> <code>test</code> </td> <td>  Test de l'application (exécution de <code>phpunit</code> , analyseurs de code statique) à l'aide d'images <strong>collectées au stade de la préparation</strong> </td></tr><tr><td> <code>build</code> </td> <td>  Installation de toutes les dépendances du <code>composer</code> ( <code>--no-dev</code> ), assemblage des <code>assets</code> <code>webpack</code> et assemblage de l'image avec le code source, <strong>y compris les artefacts reçus</strong> ( <code>vendor/*</code> , <code>app.js</code> , <code>app.css</code> ) </td></tr></tbody></table><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c2/873/625/8c2873625893ec1a0605e24bf85ef541.png" alt="capture d'écran de pipelines"></p><br><blockquote>  L'assemblage sur la branche principale produisant un <code>push</code> avec les <code>latest</code> balises et les balises principales </blockquote><p>  En moyenne, toutes les étapes de l'assemblage prennent <strong>4 minutes</strong> , ce qui est un très bon résultat (l'exécution parallèle des tâches est notre tout). </p><br><p>  Vous pouvez vous familiariser avec le contenu de la configuration ( <strong><code>.gitlab-ci.yml</code></strong> ) du collecteur à <strong><a href="">ce lien</a></strong> . </p><br><h2 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h2><br><p>  Comme vous pouvez le voir, organiser le travail avec une application php (en utilisant <code>Laravel</code> comme exemple) en utilisant Docker n'est pas si difficile.  À titre de test, vous pouvez bifurquer le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel</a> , et en remplaçant toutes les occurrences de <code>tarampampam/laravel-in-docker</code> par les vôtres, essayez tout en direct par vous-même. </p><br><p>  Pour un lancement local - exécutez seulement 2 commandes: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://gitlab.com/tarampampam/laravel-in-docker.git ./laravel-in-docker &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$_</span></span> $ make init</code> </pre> <br><p>  Ouvrez ensuite <code>http://127.0.0.1:9999</code> dans votre navigateur préféré. </p><br><p>  <strong><em>... saisissant l'occasion</em></strong> </p><br><p>  <em>En ce moment je travaille sur le projet TL "autocode", et nous recherchons des développeurs php et des administrateurs système talentueux (le bureau de développement est situé à Iekaterinbourg).</em>  <em>Si vous vous considérez comme le premier ou le deuxième - écrivez notre lettre RH avec le texte "Je veux être une équipe de développement, reprenez:% link_on_summary%" à l'e-mail <code>hr@avtocod.ru</code> , nous aidons à la relocalisation.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425101/">https://habr.com/ru/post/fr425101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425089/index.html">L'informatique dans le monde animal: recherche d'aliments pour fourmis et TCP / IP</a></li>
<li><a href="../fr425091/index.html">Que se passe-t-il avec les cotes de popularité des langages de programmation?</a></li>
<li><a href="../fr425093/index.html">Solutions IoT pour le logement et les services communaux: quels seront les compteurs intelligents et qui devrait les entretenir?</a></li>
<li><a href="../fr425095/index.html">Webinaire ouvert "Jeu" 2048 "</a></li>
<li><a href="../fr425099/index.html">Ce que j'ai compris et quels problèmes j'ai rencontrés lors de la création d'un clone de Hacker News</a></li>
<li><a href="../fr425103/index.html">Empêchez Google Predators de poursuivre vos enfants</a></li>
<li><a href="../fr425105/index.html">Intel ME Manufacturing Mode - une menace cachée ou ce qui se cache derrière la vulnérabilité CVE-2018-4251 du MacBook</a></li>
<li><a href="../fr425107/index.html">Digest Fintech: problèmes de biométrie sur mobile, location de téléphones Samsung, titres sur la blockchain</a></li>
<li><a href="../fr425109/index.html">Le livre «Java dans le cloud. Spring Boot, Spring Cloud, Cloud Foundry »</a></li>
<li><a href="../fr425111/index.html">Astuces publicitaires qui peuvent vous coûter de l'argent et de la réputation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>