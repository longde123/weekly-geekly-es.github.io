<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”› ğŸŒˆ ğŸ›ŒğŸ½ Docker + Laravel = â¤ âŒšï¸ ğŸ‘¨ğŸ¼â€ğŸš€ ğŸ¹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais parler de mon expÃ©rience de Â«wrapperÂ» une application Laravel dans un conteneur Docker afin que les dÃ©veloppeurs frontend et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker + Laravel = â¤</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425101/"><p><img src="https://habrastorage.org/getpro/habr/post_images/89c/b0e/91f/89cb0e91fd1efafb24b66b7ee44dc1b0.png" alt="laravel-in-docker"></p><br><p> Dans cet article, je vais parler de mon expÃ©rience de Â«wrapperÂ» une application Laravel dans un conteneur Docker afin que les dÃ©veloppeurs frontend et backend puissent travailler localement avec elle, et la lancer en production Ã©tait aussi simple que possible.  De plus, CI exÃ©cutera automatiquement des analyseurs de code statique, des tests de <code>phpunit</code> et construira des images. </p><br><p>  "Et qu'est-ce que la complexitÃ© en fait?"  - vous pouvez dire, et vous aurez en partie raison.  Le fait est que beaucoup de discussions dans les communautÃ©s russophones et anglophones sont consacrÃ©es Ã  ce sujet, et je diviserais conditionnellement presque tous les fils Ã©tudiÃ©s dans les catÃ©gories suivantes: </p><br><ul><li>  "J'utilise docker pour le dÃ©veloppement local. J'ai mis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">laradock</a> et je ne connais pas les problÃ¨mes."  Cool, mais qu'en est-il du lancement de l'automatisation et de la production? </li><li>  "Je rÃ©cupÃ¨re un conteneur <em>(monolith)</em> basÃ© sur <code>fedora:latest</code> (~ 230 Mo), y mets tous les services (nginx, db, cache, etc.), exÃ©cute tout Ã  l'intÃ©rieur du superviseur."  Ã‰galement excellent, facile Ã  dÃ©marrer, mais qu'en est-il de l'idÃ©ologie Â«un conteneur - un processusÂ»?  Qu'en est-il de l'Ã©quilibrage et de la gestion des processus?  Quelle est la taille de l'image? </li><li>  "Voici des morceaux de configs, assaisonnez avec des extraits de sh-scripts, ajoutez des valeurs env magiques, utilisez-le."  Merci, mais qu'en est-il d'au moins un exemple vivant que je pourrais bifurquer et jouer pleinement? </li></ul><br><p>  Tout ce que vous lisez ci-dessous est une expÃ©rience subjective qui ne prÃ©tend pas Ãªtre la vÃ©ritÃ© ultime.  Si vous avez des ajouts ou des indications d'inexactitudes - bienvenue aux commentaires. </p><br><blockquote>  Pour les impatients - un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers le rÃ©fÃ©rentiel</a> , clonez que vous pouvez dÃ©marrer l'application Laravel avec une seule commande.  Il ne sera pas non plus difficile de l'exÃ©cuter sur le mÃªme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ã©leveur</a> , de Â«lierÂ» correctement les conteneurs ou d'utiliser la version d'Ã©picerie <code>docker-compose.yml</code> comme point de dÃ©part. </blockquote><a name="habracut"></a><br><h2 id="chast-teoreticheskaya">  Partie thÃ©orique </h2><br><p>  Quels outils utiliserons-nous dans notre travail et sur quoi nous concentrerons-nous?  Tout d'abord, nous devons installer sur l'hÃ´te: </p><br><ul><li>  <code>docker</code> - au moment de la rÃ©daction, j'ai utilisÃ© la version <code>18.06.1-ce</code> </li><li>  <code>docker-compose</code> - il gÃ¨re la liaison des conteneurs et le stockage des valeurs d'environnement nÃ©cessaires;  version <code>1.22.0</code> </li><li>  <code>make</code> - vous pourriez Ãªtre surpris, mais cela s'intÃ¨gre parfaitement dans le contexte de travail avec docker </li></ul><br><blockquote>  Vous pouvez <code>curl -fsSL get.docker.com | sudo sh</code> <code>docker</code> sur des systÃ¨mes de type <code>debian</code> avec la commande <code>curl -fsSL get.docker.com | sudo sh</code>  <code>curl -fsSL get.docker.com | sudo sh</code> , mais <code>docker-compose</code> prÃ©fÃ©rable d'installer Ã  l'aide de <code>pip</code> , car les versions les plus rÃ©centes vivent dans ses rÃ©fÃ©rentiels ( <code>apt</code> loin derriÃ¨re, en rÃ¨gle gÃ©nÃ©rale). </blockquote><p>  Ceci complÃ¨te la liste des dÃ©pendances.  Ce que vous utiliserez pour travailler avec le code source - <code>phpstorm</code> , <code>phpstorm</code> ou le <code>vim</code> mort - c'est Ã  vous. </p><br><p>  Ensuite, un contrÃ´le qualitÃ© impromptu dans le contexte de la conception d'image <em>(je n'ai pas peur de ce mot)</em> : </p><br><ul><li><p>  <strong>Q: Image de base - quel est le meilleur choix?</strong> </p><br></li><li><p>  <strong>R:</strong> Celui qui est "plus mince", sans fioritures.  Sur la base de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>alpine</code></a> <em>(~ 5 Mo),</em> vous pouvez collecter tout ce que votre cÅ“ur dÃ©sire, mais vous devrez probablement jouer avec l'ensemble des services de la source.  Comme alternative - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>jessie-slim</code></a> <em>(~ 30 Mo)</em> .  Ou utilisez celui qui est le plus souvent utilisÃ© dans vos projets. </p><br></li><li><p>  <strong>Q: Pourquoi le poids de l'image est-il important?</strong> </p><br></li><li><p>  <strong>R:</strong> Diminution du volume de trafic, diminution de la probabilitÃ© d'une erreur lors du tÃ©lÃ©chargement (moins de donnÃ©es - moins de probabilitÃ©), diminution de la place consommÃ©e.  La rÃ¨gle "La gravitÃ© est fiable" (Â© "Snatch") ne fonctionne pas trÃ¨s bien ici. </p><br></li><li><p>  <strong>Q: Mais mon ami <code>%friend_name%</code> dit qu'une image "monolithique" avec toutes les dÃ©pendances est le meilleur moyen.</strong> </p><br></li><li><p>  <strong>R:</strong> Disons simplement compter.  L'application a 3 dÃ©pendances - PG, Redis, PHP.  Et vous vouliez tester son comportement dans des bundles de diffÃ©rentes versions de ces dÃ©pendances.  PG - versions 9.6 et 10, Redis - 3.2 et 4.0, PHP - 7.0 et 7.2.  Dans le cas oÃ¹ chaque dÃ©pendance est une image distincte - vous en avez besoin de 6, que vous n'avez mÃªme pas besoin de collecter - tout est prÃªt et se trouve sur <code>hub.docker.com</code> .  Si, pour des raisons idÃ©ologiques, toutes les dÃ©pendances sont "emballÃ©es" dans un seul conteneur, vous devez le remonter avec des stylos ... 8 fois?  Ajoutez maintenant la condition que vous voulez toujours jouer avec <code>opcache</code> .  Dans le cas d'une dÃ©composition, il s'agit simplement d'un changement dans les balises des images utilisÃ©es.  Un monolithe est plus facile Ã  gÃ©rer et Ã  entretenir, mais c'est la route vers nulle part. </p><br></li><li><p>  <strong>Q: Pourquoi le superviseur du conteneur est-il mauvais?</strong> </p><br></li><li><p>  <strong>R:</strong> Parce que <code>PID 1</code> .  Si vous ne voulez pas une multitude de problÃ¨mes avec les processus zombies et que vous avez la possibilitÃ© d 'Â«ajouter de la capacitÃ©Â» de maniÃ¨re flexible si nÃ©cessaire - essayez d'exÃ©cuter un processus par conteneur.  Une exception particuliÃ¨re est <code>nginx</code> avec ses employÃ©s et <code>php-fpm</code> , qui ont la capacitÃ© de produire des processus, mais doivent le supporter (en outre, ils ne sont pas mauvais pour rÃ©agir Ã  <code>SIGTERM</code> , "tuant" Ã  juste titre leurs employÃ©s).  En lanÃ§ant tous les dÃ©mons en tant que superviseur, vous vous condamnez certainement Ã  des problÃ¨mes.  Bien que, dans certains cas, il soit difficile de s'en passer, ce sont dÃ©jÃ  des exceptions. </p><br></li></ul><br><p>  AprÃ¨s avoir dÃ©cidÃ© des principales approches, passons Ã  notre application.  Il doit pouvoir: </p><br><ul><li>  <code>web|api</code> - donnez statique avec <code>nginx</code> , et gÃ©nÃ©rez du contenu dynamique avec <code>fpm</code> </li><li>  <code>scheduler</code> - exÃ©cuter le planificateur de tÃ¢ches natif </li><li>  <code>queue</code> - traiter les travaux des files d'attente </li></ul><br><p>  Un ensemble de base qui peut Ãªtre Ã©tendu si nÃ©cessaire.  Passons maintenant aux images que nous devons collecter pour que notre application Â«dÃ©colleÂ» (leurs noms de code sont indiquÃ©s entre parenthÃ¨ses): </p><br><ul><li>  <code>PHP + PHP-FPM</code> ( <strong>app</strong> ) - l'environnement dans lequel notre code sera exÃ©cutÃ©.  Ã‰tant donnÃ© que les versions de PHP et de FPM seront les mÃªmes pour nous - nous les collectons dans une seule image.  Il est donc plus facile Ã  gÃ©rer avec les configurations, et la composition des packages sera identique.  Bien sÃ»r - FPM et les processus d'application s'exÃ©cuteront dans diffÃ©rents conteneurs </li><li>  <code>nginx</code> ( <strong>nginx</strong> ) - cela ne dÃ©rangerait pas la livraison de configs et de modules optionnels pour <code>nginx</code> - nous collecterons une image sÃ©parÃ©e avec.  Puisqu'il s'agit d'un service distinct, il a son propre fichier docker et son contexte </li><li>  Sources de l'application ( <strong>sources</strong> ) - la source sera livrÃ©e Ã  l'aide d'une image distincte, montant le <code>volume</code> avec eux dans un conteneur avec l'application.  L'image de base est <code>alpine</code> , Ã  l'intÃ©rieur, il n'y a que des sources avec des dÃ©pendances installÃ©es et collectÃ©es Ã  l'aide des actifs du webpack (gÃ©nÃ©ration d'artefacts) </li></ul><br><p>  D'autres services de dÃ©veloppement sont lancÃ©s dans des conteneurs, les tirant de <code>hub.docker.com</code> ;  sur la production, d'autre part - ils fonctionnent sur des serveurs distincts, en cluster.  Il ne nous reste plus qu'Ã  indiquer Ã  l'application <em>(via l'environnement)</em> Ã  quelles adresses / ports et avec quels dÃ©tails il faut y toucher.  Encore plus cool est d'utiliser la dÃ©couverte de services Ã  cette fin, mais pas Ã  cette Ã©poque. </p><br><p>  AprÃ¨s avoir dÃ©cidÃ© de la partie thÃ©orique, je propose de passer Ã  la partie suivante. </p><br><h2 id="chast-prakticheskaya">  La partie pratique </h2><br><p>  Je suggÃ¨re d'organiser les fichiers dans le rÃ©fÃ©rentiel comme suit: </p><br><pre> <code class="hljs css">. â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> #    <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>   â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> â”‚  â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> â”‚  â”‚  â””â”€â”€ ... â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">nginx</span></span> â”‚  â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> â”‚  â”‚  â””â”€â”€ ... â”‚  â””â”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">sources</span></span> â”‚    â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> â”‚    â””â”€â”€ ... â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">src</span></span> #   â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">bootstrap</span></span> â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span> â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">artisan</span></span> â”‚ â””â”€â”€ ... â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose-</span></span>    â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Makefile</span></span> â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHANGELOG</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span> â””â”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">README</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span></code> </pre> <br><blockquote>  Vous pouvez vous familiariser avec la structure et les fichiers en cliquant sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . </blockquote><p>  Pour crÃ©er un service, vous pouvez utiliser la commande: </p><br><pre> <code class="bash hljs">$ docker build \ --tag %local_image_name% \ -f ./docker/%service_directory%/Dockerfile ./docker/%service_directory%</code> </pre> <br><p>  La seule diffÃ©rence sera l'assemblage de l'image avec les sources - pour cela, le contexte d'assemblage (argument extrÃªme) <code>./src</code> Ãªtre dÃ©fini sur <code>./src</code> . </p><br><p>  Les rÃ¨gles de dÃ©nomination des images dans le registre local recommandent d'utiliser celles que <code>docker-compose</code> utilise par dÃ©faut, Ã  savoir: <code>%root_directory_name%_%service_name%</code> .  Si le rÃ©pertoire du projet est appelÃ© <code>my-awesome-project</code> et que le service est nommÃ© <code>redis</code> , le nom de l'image (local) est prÃ©fÃ©rable de choisir <code>my-awesome-project_redis</code> respectivement. </p><br><blockquote>  Pour accÃ©lÃ©rer le processus de construction, vous pouvez dire au docker d'utiliser le cache de l'image prÃ©cÃ©demment assemblÃ©e, et pour cela, l' <code>--cache-from %full_registry_name%</code> lancement <code>--cache-from %full_registry_name%</code> .  Ainsi, le dÃ©mon docker va regarder avant de dÃ©marrer une instruction particuliÃ¨re dans le Dockerfile - a-t-elle changÃ©?  Et sinon (le hachage converge) - il sautera l'instruction, en utilisant le calque dÃ©jÃ  prÃ©parÃ© de l'image, que vous lui direz d'utiliser comme cache.  Cette chose n'est pas mauvaise donc elle va reconstruire le processus, surtout si rien n'a changÃ© :) <br><br>  Faites attention aux scripts <code>ENTRYPOINT</code> pour lancer les conteneurs d'applications. </blockquote><p>  L'image de l'environnement de lancement de l'application (app) a Ã©tÃ© collectÃ©e en tenant compte du fait que cela fonctionnera non seulement en production, mais aussi localement, les dÃ©veloppeurs doivent interagir efficacement avec elle.  L'installation et la suppression des dÃ©pendances du <code>composer</code> , l'exÃ©cution de tests <code>unit</code> , les journaux de fin et l'utilisation d'alias familiers ( <code>php /app/artisan</code> â†’ <code>art</code> , <code>composer</code> â†’ <code>c</code> ) devraient Ãªtre sans aucun inconfort.  De plus - il sera Ã©galement utilisÃ© pour exÃ©cuter des tests <code>unit</code> et des analyseurs de code statique ( <code>phpstan</code> dans notre cas) sur CI.  C'est pourquoi son Dockerfile, par exemple, contient la <code>xdebug</code> installation de <code>xdebug</code> , mais le module lui-mÃªme n'est pas activÃ© (il est activÃ© uniquement Ã  l'aide de CI). </p><br><blockquote>  De plus, pour le <code>composer</code> le <code>hirak/prestissimo</code> est <code>hirak/prestissimo</code> , ce qui augmente considÃ©rablement l'installation de toutes les dÃ©pendances. </blockquote><p>  En production, nous montons le contenu du rÃ©pertoire <code>/src</code> partir de l'image avec les sources (sources) Ã  l'intÃ©rieur dans le rÃ©pertoire <code>/app</code> .  Pour le dÃ©veloppement, nous Â«survolonsÂ» le rÃ©pertoire local avec les sources d'application ( <code>-v "$(pwd)/src:/app:rw"</code> ). </p><br><p>  Et ici rÃ©side une complexitÃ© - ce sont <strong>les droits d'accÃ¨s aux fichiers</strong> crÃ©Ã©s Ã  partir du conteneur.  Le fait est que par dÃ©faut les processus en cours d'exÃ©cution Ã  l'intÃ©rieur du conteneur dÃ©marrent Ã  partir de la racine ( <code>root:root</code> ), les fichiers crÃ©Ã©s par ces processus (cache, logs, sessions, etc.) - aussi, et par consÃ©quent - vous n'avez rien Â«localementÂ» avec eux vous pouvez le faire sans exÃ©cuter <code>sudo chown -R $(id -u):$(id -g) /path/to/sources</code> . </p><br><p>  Comme solution, utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fixuid</a> , mais cette solution est simple.  Le meilleur moyen m'a semblÃ© de <code>USER_ID</code> local et son <code>GROUP_ID</code> Ã  l'intÃ©rieur du conteneur, et de <a href="">dÃ©marrer les processus avec ces valeurs</a> .  Par dÃ©faut, la substitution des valeurs <code>1000:1000</code> (les valeurs par dÃ©faut pour le premier utilisateur local) s'est dÃ©barrassÃ©e de l'appel <code>$(id -u):$(id -g)</code> , et si nÃ©cessaire, vous pouvez toujours les remplacer ( <code>$ USER_ID=666 docker-compose up -d</code> ) ou placez le fichier docker-compose dans le fichier <code>.env</code> . </p><br><p>  De plus, lorsque <code>php-fpm</code> lancÃ© localement <code>php-fpm</code> pas d'en dÃ©sactiver <code>opcache</code> - sinon il y a beaucoup de "oui quoi diable!"  vous sera fourni. </p><br><p>  Pour une connexion "directe" Ã  redis et postgres, j'ai jetÃ© des ports supplÃ©mentaires "out" ( <code>15432</code> et <code>15432</code> respectivement), donc il n'y a aucun problÃ¨me avec "se connecter et voir ce que c'est vraiment" et en principe ". </p><br><p>  Je garde le conteneur avec l' <code>app</code> nom de code en cours d'exÃ©cution ( <code>--command keep-alive.sh</code> ) dans le but d'un accÃ¨s pratique Ã  l'application. </p><br><p>  Voici quelques exemples de rÃ©solution de problÃ¨mes quotidiens avec <code>docker-compose</code> : </p><br><table><thead><tr><th>  Fonctionnement </th><th>  Commande en cours d'exÃ©cution </th></tr></thead><tbody><tr><td>  Installer le package du <code>composer</code> </td><td> <code>$ docker-compose exec app composer require package/name</code> </td> </tr><tr><td>  ExÃ©cuter phpunit </td><td> <code>$ docker-compose exec app php ./vendor/bin/phpunit --no-coverage</code> </td> </tr><tr><td>  Installer toutes les dÃ©pendances de noeud </td><td> <code>$ docker-compose run --rm node npm install</code> </td> </tr><tr><td>  Installer le package de noeud </td><td> <code>$ docker-compose run --rm node npm i package_name</code> </td> </tr><tr><td>  Lancement d'une reconstruction en direct des actifs </td><td> <code>$ docker-compose run --rm node npm run watch</code> </td> </tr></tbody></table><br><p>  Vous pouvez trouver tous les dÃ©tails de lancement dans le <strong><a href="">fichier docker-compose.yml</a></strong> . </p><br><h4 id="coy-make-zhiv"><del>  Choi </del>  <code>make</code> vivant! </h4><br><p>  Taper les mÃªmes commandes Ã  chaque fois devient ennuyeux aprÃ¨s la deuxiÃ¨me fois, et puisque les programmeurs sont des crÃ©atures paresseuses par nature, faisons leur Â«automatisationÂ».  Conserver un ensemble de scripts <code>sh</code> est une option, mais pas aussi attrayante qu'un <code>Makefile</code> , d'autant plus que son applicabilitÃ© dans le dÃ©veloppement moderne est largement sous-estimÃ©e. </p><br><blockquote>  Vous trouverez le manuel complet en russe Ã  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . </blockquote><p>  Voyons Ã  quoi ressemble le <code>make</code> run Ã  la racine du rÃ©fÃ©rentiel: </p><br><pre> <code class="bash hljs">[user@host ~/projects/app] $ make <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Show this <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> app-pull Application - pull latest Docker image (from remote registry) app Application - build Docker image locally app-push Application - tag and push Docker image into remote registry sources-pull Sources - pull latest Docker image (from remote registry) sources Sources - build Docker image locally sources-push Sources - tag and push Docker image into remote registry nginx-pull Nginx - pull latest Docker image (from remote registry) nginx Nginx - build Docker image locally nginx-push Nginx - tag and push Docker image into remote registry pull Pull all Docker images (from remote registry) build Build all Docker images push Tag and push all Docker images into remote registry login Log <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> to a remote Docker registry clean Remove images from <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> registry --------------- --------------- up Start all containers (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> background) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development down Stop all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers restart Restart all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers shell Start shell into application container install Install application dependencies into application container watch Start watching assets <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> changes (node) init Make full application initialization (install, seed, build assets) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Execute application tests Allowed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> overriding next properties: PULL_TAG - Tag <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pulling images before building own (<span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) PUBLISH_TAGS - Tags list <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building and pushing into remote registry (delimiter - single space, <span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) Usage example: make PULL_TAG=<span class="hljs-string"><span class="hljs-string">'v1.2.3'</span></span> PUBLISH_TAGS=<span class="hljs-string"><span class="hljs-string">'latest v1.2.3 test-tag'</span></span> app-push</code> </pre> <br><p>  Il est trÃ¨s bon pour les objectifs addictifs.  Par exemple, pour exÃ©cuter la <code>watch</code> ( <code>docker-compose run --rm node npm run watch</code> ), vous avez besoin que l'application soit Â«augmentÃ©eÂ» - il vous suffit de spÃ©cifier la cible <code>up</code> comme dÃ©pendante - et vous n'avez pas Ã  vous soucier d'oublier de le faire avant d'appeler <code>watch</code> - <code>make</code> lui-mÃªme fera tout pour vous.  La mÃªme chose s'applique Ã  l'exÃ©cution de tests et d'analyseurs statiques, par exemple, avant de valider des modifications - exÃ©cutez un <code>make test</code> et toute la magie se produira pour vous! </p><br><p>  Inutile de dire que vous n'avez pas Ã  vous soucier de l'assemblage d'images, de les tÃ©lÃ©charger, de spÃ©cifier <code>--cache-from</code> et Ã  peu prÃ¨s tout? </p><br><p>  Vous pouvez voir le contenu du <code>Makefile</code> sur <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a></strong> . </p><br><h2 id="chast-avtomaticheskaya">  PiÃ¨ce auto </h2><br><p>  CommenÃ§ons la derniÃ¨re partie de cet article - il s'agit de l'automatisation du processus de mise Ã  jour des images dans le Docker Registry.  Bien que dans mon exemple, GitLab CI soit utilisÃ© - pour transfÃ©rer l'idÃ©e vers un autre service d'intÃ©gration, je pense que ce sera tout Ã  fait possible. </p><br><p>  Tout d'abord, nous dÃ©terminerons la dÃ©nomination des balises d'image utilisÃ©es: </p><br><table><thead><tr><th>  Nom du tag </th><th>  Destination </th></tr></thead><tbody><tr><td> <code>latest</code> </td> <td>  Images recueillies auprÃ¨s de la branche principale. <br>  L'Ã©tat du code est le plus rÃ©cent, mais pas encore prÃªt Ã  entrer dans la version </td></tr><tr><td> <code>some-branch-name</code> </td> <td>  Images collectÃ©es sur le brunch du nom d' <code>some-branch-name</code> . <br>  Ainsi, nous pouvons Â«dÃ©ployerÂ» les changements dans n'importe quel environnement qui ont Ã©tÃ© implÃ©mentÃ©s uniquement dans le cadre d'un brunch spÃ©cifique avant de les fusionner avec le <code>master</code> -light - il suffit de Â«Ã©tirerÂ» les images avec cette balise. <br>  Et - oui, les changements peuvent concerner Ã  la fois le code et les images de tous les services en gÃ©nÃ©ral! </td></tr><tr><td> <code>vX.XX</code> </td> <td>  En fait, la sortie de l'application (Ã  utiliser pour dÃ©ployer une version spÃ©cifique) </td></tr><tr><td> <code>stable</code> </td> <td>  Alias, pour la balise avec la derniÃ¨re version (Ã  utiliser pour dÃ©ployer la derniÃ¨re version stable) </td></tr></tbody></table><br><p>  La sortie a lieu en publiant une balise dans un <code>vX.XX</code> format <code>vX.XX</code> </p><br><p>  Pour accÃ©lÃ©rer la construction, la mise en cache des rÃ©pertoires <code>./src/vendor</code> et <code>./src/node_modules</code> + <code>--cache-from</code> pour la <code>docker build</code> et comprend les Ã©tapes suivantes: </p><br><table><thead><tr><th>  Nom de la scÃ¨ne </th><th>  Destination </th></tr></thead><tbody><tr><td> <code>prepare</code> </td> <td>  La phase prÃ©paratoire - l'assemblage d'images de tous les services <strong>sauf l'</strong> image avec la source </td></tr><tr><td> <code>test</code> </td> <td>  Test de l'application (exÃ©cution de <code>phpunit</code> , analyseurs de code statique) Ã  l'aide d'images <strong>collectÃ©es au stade de la prÃ©paration</strong> </td></tr><tr><td> <code>build</code> </td> <td>  Installation de toutes les dÃ©pendances du <code>composer</code> ( <code>--no-dev</code> ), assemblage des <code>assets</code> <code>webpack</code> et assemblage de l'image avec le code source, <strong>y compris les artefacts reÃ§us</strong> ( <code>vendor/*</code> , <code>app.js</code> , <code>app.css</code> ) </td></tr></tbody></table><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c2/873/625/8c2873625893ec1a0605e24bf85ef541.png" alt="capture d'Ã©cran de pipelines"></p><br><blockquote>  L'assemblage sur la branche principale produisant un <code>push</code> avec les <code>latest</code> balises et les balises principales </blockquote><p>  En moyenne, toutes les Ã©tapes de l'assemblage prennent <strong>4 minutes</strong> , ce qui est un trÃ¨s bon rÃ©sultat (l'exÃ©cution parallÃ¨le des tÃ¢ches est notre tout). </p><br><p>  Vous pouvez vous familiariser avec le contenu de la configuration ( <strong><code>.gitlab-ci.yml</code></strong> ) du collecteur Ã  <strong><a href="">ce lien</a></strong> . </p><br><h2 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h2><br><p>  Comme vous pouvez le voir, organiser le travail avec une application php (en utilisant <code>Laravel</code> comme exemple) en utilisant Docker n'est pas si difficile.  Ã€ titre de test, vous pouvez bifurquer le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rÃ©fÃ©rentiel</a> , et en remplaÃ§ant toutes les occurrences de <code>tarampampam/laravel-in-docker</code> par les vÃ´tres, essayez tout en direct par vous-mÃªme. </p><br><p>  Pour un lancement local - exÃ©cutez seulement 2 commandes: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://gitlab.com/tarampampam/laravel-in-docker.git ./laravel-in-docker &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$_</span></span> $ make init</code> </pre> <br><p>  Ouvrez ensuite <code>http://127.0.0.1:9999</code> dans votre navigateur prÃ©fÃ©rÃ©. </p><br><p>  <strong><em>... saisissant l'occasion</em></strong> </p><br><p>  <em>En ce moment je travaille sur le projet TL "autocode", et nous recherchons des dÃ©veloppeurs php et des administrateurs systÃ¨me talentueux (le bureau de dÃ©veloppement est situÃ© Ã  Iekaterinbourg).</em>  <em>Si vous vous considÃ©rez comme le premier ou le deuxiÃ¨me - Ã©crivez notre lettre RH avec le texte "Je veux Ãªtre une Ã©quipe de dÃ©veloppement, reprenez:% link_on_summary%" Ã  l'e-mail <code>hr@avtocod.ru</code> , nous aidons Ã  la relocalisation.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425101/">https://habr.com/ru/post/fr425101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425089/index.html">L'informatique dans le monde animal: recherche d'aliments pour fourmis et TCP / IP</a></li>
<li><a href="../fr425091/index.html">Que se passe-t-il avec les cotes de popularitÃ© des langages de programmation?</a></li>
<li><a href="../fr425093/index.html">Solutions IoT pour le logement et les services communaux: quels seront les compteurs intelligents et qui devrait les entretenir?</a></li>
<li><a href="../fr425095/index.html">Webinaire ouvert "Jeu" 2048 "</a></li>
<li><a href="../fr425099/index.html">Ce que j'ai compris et quels problÃ¨mes j'ai rencontrÃ©s lors de la crÃ©ation d'un clone de Hacker News</a></li>
<li><a href="../fr425103/index.html">EmpÃªchez Google Predators de poursuivre vos enfants</a></li>
<li><a href="../fr425105/index.html">Intel ME Manufacturing Mode - une menace cachÃ©e ou ce qui se cache derriÃ¨re la vulnÃ©rabilitÃ© CVE-2018-4251 du MacBook</a></li>
<li><a href="../fr425107/index.html">Digest Fintech: problÃ¨mes de biomÃ©trie sur mobile, location de tÃ©lÃ©phones Samsung, titres sur la blockchain</a></li>
<li><a href="../fr425109/index.html">Le livre Â«Java dans le cloud. Spring Boot, Spring Cloud, Cloud Foundry Â»</a></li>
<li><a href="../fr425111/index.html">Astuces publicitaires qui peuvent vous coÃ»ter de l'argent et de la rÃ©putation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>