<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏻 🤪 ⤴️ 在区块链上确保2FA安全 🚋 🙎🏼 🔇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SMS消息是最流行的两因素身份验证（2FA）方法。 银行，电子和加密钱包，邮箱和各种服务都使用它。 该方法的用户数接近100％ 。 

 我这样的事件爆发是令人发指的，因为这种方法是不安全的。 从移动时代开始就将号码从一张SIM卡重新分配给另一张-这就是丢失SIM卡后如何恢复号码的方式。 实现了“数...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在区块链上确保2FA安全</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476090/">  SMS消息是最流行的两因素身份验证（2FA）方法。 银行，电子和加密钱包，邮箱和各种服务都使用它。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该方法的用户数接近100％</a> 。 <br><br> 我这样的事件爆发是令人发指的，因为这种方法是不安全的。 从移动时代开始就将号码从一张SIM卡重新分配给另一张-这就是丢失SIM卡后如何恢复号码的方式。 实现了“数字货币断奶专家”：可以在欺诈性方案中使用“覆盖SIM卡”选项。 毕竟，控制SIM卡的人可以管理其他人的网上银行，电子钱包，甚至是加密货币。 您还可以使用欺诈或伪造文件贿赂电信员工，从而接管他人的电话号码。 <br><br><img src="https://habrastorage.org/webt/sm/lg/oh/smlgohi_vtrtginwsqvp3t2jqy8.png"><br><br> 已发现成千上万次SIM交换事件-这就是所谓的欺诈方案。 灾难的严重性表明，世界很快将通过SMS放弃2FA。 但这并没有发生- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究</a>表明，选择2FA方法的不是用户，而是服务所有者。 <br><br> 我们建议使用安全的2FA方法，并通过区块链传递一次性代码，并告诉您如何将其连接到服务所有者。 <br><a name="habracut"></a><br><h2> 账单上百万 </h2><br> 根据伦敦警方的说法，2019年，SIM卡掉期欺诈增加了63％，攻击者的“平均支票”为4,000英镑。 我没有在俄罗斯找到统计信息，但我认为情况甚至更糟。 <br><br> 比特币企业家Joby Weeks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报道说</a> ，SIM卡交换用于窃取流行的Twitter，Instagram，Facebook，VK帐户，银行帐户以及最近进入的加密货币。 自2016年以来，在媒体报道中已经出现了备受瞩目的利用SIM卡交换盗窃加密货币的案例; 在2019年达到了真正的高峰。 <br><br>  5月，密歇根州东部地区的美国检察官<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">起诉了</a> 9名19至26岁的年轻人：据称他们是一个名为“社区”的黑客团伙的成员。 该团伙被控进行七次掉期攻击，因此黑客盗用了价值超过240万美元的加密货币。  4月，来自加利福尼亚的一名学生乔尔·奥尔蒂斯（Joel Ortiz）因更换SIM卡而被判入狱10年；  750万美元的加密货币成为了它的猎物。 <br><br><img src="https://habrastorage.org/webt/xy/b4/61/xyb4614ligd5ao0hslycslmxq3u.jpeg"><br>  <i>乔尔·奥尔蒂斯（Joel Ortiz）在大学新闻发布会上的照片。</i>  <i>两年后，他将因网络欺诈而被拘留。</i> <br><br><h2>  SIM卡交换的原理 </h2><br> 交换意味着交换。 在所有这些方案中，犯罪分子通常通过重新发行SIM卡来分配受害者的电话号码，然后使用该电话号码来重置密码。 理论上，典型的SIM交换如下所示： <br><br><ol><li> 情报。 欺诈者找出受害者的个人数据：姓名和电话。 它们可以在开放源代码（社交网络，朋友）中找到，也可以从同伙（移动运营商的雇员）获得。 </li><li> 阻塞。 受害者的SIM卡已停用； 为此，只需致电提供商的技术支持，报告电话号码并说电话已丢失。 </li><li> 捕获号码并将其转移到您的SIM卡中。 通常，这也可以通过电信公司的帮凶或伪造文件来完成。 </li></ol><br> 在现实生活中，情况仍然更为严峻。 攻击者选择一个受害者，然后每天监控电话的位置-一个有关用户已切换到漫游的信息请求的费用为1-2美分。  SIM卡拥有者出国后，便会与通讯沙龙的经理达成协议，签发新的SIM卡。 它的成本约为50美元（我发现信息-在不同的国家和不同的运营商，其价格从20美元到100美元不等），而经理在最坏的情况下将被解雇-这不承担任何责任。 <br><br> 现在，所有入侵者都将收到所有短信，而手机的所有者将无法对其进行任何操作-他在国外。 然后，恶棍可以访问受害者的所有帐户，并且可以根据需要更改密码。 <br><br><h2> 可能返还被盗的货物 </h2><br> 银行有时会去找受害者，并从他们的账户中提取转账。 因此，即使没有发现违法者，也可以归还法定货币。 但是，使用加密货币钱包，无论在<i>技术上</i>还是在法律上，一切都变得更加复杂。 到目前为止，还没有交易所/钱包为交换受害者支付了补偿。 <br><br> 如果受害者想在法庭上为自己的钱辩护，那么他们就指责经营者：他创造了从账户中盗窃金钱的条件。 这正是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迈克尔·特平（Michael Turpin）所做的</a> ，他因掉期而损失了2.24亿美元，现在他在起诉AT＆T电信公司。 <br><br><img src="https://habrastorage.org/webt/1d/bx/cp/1dbxcp8cbskbzhc8dlpwm3rqggm.png"><br><br> 到目前为止，还没有州制定任何法律上保护加密货币所有者的工作计划。 无法为您的资本提供保险或就其损失获得赔偿。 因此，防止交换攻击比对抗其后果更容易。 最明显的方法是对2FA使用更可靠的“第二因素”。 <br><br><h2>  SIM卡交换不是通过SMS唯一的2FA问题 </h2><br> 从技术角度来看，SMS中的确认代码也不安全。 由于信令系统7（SS7）中存在致命漏洞，因此可以截获消息。  SMS的2FA被正式确认为不安全（美国国家标准技术研究院在其《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数字认证指南》中</a>对此进行了说明）。 <br><br> 而且，2FA的出现通常会激发用户虚假的安全感，并且他选择了一个更简单的密码。 因此，这种身份验证并不复杂，但是可以使攻击者更容易访问该帐户。 <br><br> 而且，SMS经常会延迟很长时间甚至根本不会延迟。 <br><br><h2> 其他2FA方法 </h2><br> 当然，在智能手机和SMS上，光线并未收敛。 还有其他2FA方法。 例如，一次TAN编码：该方法是原始方法，但是可以工作-在某些银行中仍在使用。 有些系统使用生物特征数据：指纹，视网膜扫描。 在方便性，可靠性和价格方面，另一个似乎合理折衷的选择是2FA的特殊应用：RSA令牌，Google身份验证器。 并且有物理键和其他方法。 <br><br> 从理论上讲，一切看起来都是逻辑可靠的。 但是实际上，现代2FA解决方案存在问题，因此，现实与期望有所不同。 <br><br> 根据该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究</a> ，使用2FA原则上是一种不便，并且通过SMS进行2FA的普及可以通过“与其他方法相比不那么麻烦”来解释-接收一次性代码对于用户而言是可以理解的。 <br><br> 许多2FA方法用户担心会丢失访问权限。 物理密钥或TAN密码列表可能会丢失或被盗。 我个人使用Google Authenticator的经历很消极。 我使用该应用程序的第一部智能手机坏了-请评估我恢复帐户访问权的努力。 另一个问题是过渡到新设备。 出于安全方面的考虑，Google Authenticator无法导出（如果可以导出密钥，那将提供什么样的安全性？）。 一旦我手动转移了密钥，然后决定将旧的智能手机放在架子上的盒子里就容易了。 <br><br>  2FA方法应为： <br><br><ul><li> 安全-只有您有权访问自己的帐户，而不是攻击者 </li><li> 可靠-您随时可以访问自己的帐户 </li><li> 方便且负担得起-使用2FA非常简单，只需最少的时间 </li><li> 便宜的 </li></ul><br> 我们认为区块链是正确的解决方案。 <br><br><h2> 在区块链上使用2FA </h2><br> 对于用户而言，区块链上的2FA看起来与通过短信接收一次性代码相同。 唯一的区别在于交付渠道。 获取2FA代码的方式取决于区块链提供的内容。 在我们的项目中（信息在我的个人资料中），这是一个Web应用程序，Tor，iOS，Android，Linux，Windows，MacOS。 <br><br> 该服务生成一次性代码并将其发送到区块链上的Messenger。 此外，根据经典：用户在服务界面中输入接收到的代码并登录。 <br><br><img src="https://habrastorage.org/webt/4a/yq/ph/4ayqphaul5iozz1f_v2g0q4ziqw.png"><br><br> 在文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《分散的Messenger如何在区块链上工作》中，</a>我写道，区块链可确保消息传递的安全性和隐私性。 关于发送2FA代码的主题，我将重点介绍： <br><br><ul><li> 一键创建帐户-没有电话或电子邮件。 </li><li> 所有带有2FA代码的消息均被加密为“端到端曲线” 25519xsalsa20poly1305。 </li><li> 不包括MITM攻击-每个带有2FA代码的消息都是区块链上的事务，并由Ed25519 EdDSA签名。 </li><li> 带有2FA代码的消息将落入其块中。 块的顺序和时间戳无法确定，因此消息的顺序也无法确定。 </li><li> 没有中央结构可以检查消息的“真实性”。 这是由基于共识的分布式节点系统完成的，它属于用户。 </li><li> 无法禁用-无法阻止帐户，并且可以删除邮件。 </li><li> 随时从任何设备访问2FA代码。 </li><li> 带有2FA代码的交货确认消息。 发送一次性密码的服务可以确定已将其交付。 没有“再次提交”按钮。 </li></ul><br> 为了与其他2FA方法进行比较，我编译了一个表： <br><br><img src="https://habrastorage.org/webt/pl/am/tm/plamtmeiv5xnjmupd5bevfrpftu.png"><br><br> 用户在区块链Messenger中接收一个帐户以在一秒钟内接收代码-仅使用密码输入。 因此，应用方法可能不同：您可以使用一个帐户获取所有服务的代码，也可以为每个服务创建一个单独的帐户。 <br><br> 还有一个缺点-一个帐户必须至少有一笔交易。 为了使用户收到带有代码的加密消息，您需要知道他的公钥，并且他只有在进行第一次交易时才会出现在区块链中。 我们这样走了：他们给了我们机会在我们的钱包里获得免费代币。 但是，一种更正确的解决方案是将帐户命名为公共密钥。  （作为比较，我们的帐号<i>U1467838112172792705</i>是公钥<i>cc1ca549413b942029c4742a6e6ed69767c325f8d989f7e4b71ad82a164c2ada</i>的派生工具。对于Messenger来说，这更方便易读，但对于发送系统2FA代码而言）。 我认为将来会有人做出这样的决定，并将“便利性和可及性”转移到绿色区域。 <br><br> 发送2FA代码的成本非常低-0.001 ADM，现在为0.00001 USD。 同样，您可以提高区块链并使价格为零。 <br><br><h2> 如何将区块链上的2FA连接到您的服务 </h2><br> 我希望我能够引起一些读者的兴趣，以将区块链授权添加到他们的服务中。 <br><br> 我将使用我们的Messenger的示例来告诉您如何执行此操作，以此类推，您可以使用另一个区块链。 在2FA演示应用程序中，我们使用postgresql10来存储帐户信息。 <br><br> 连接步骤： <br><br><ol><li> 在区块链上创建一个帐户，您将从该帐户发送2FA代码。 您将收到一个密码删除密码，该密码用作私钥，用于使用代码加密消息并签署交易。 </li><li> 将脚本添加到服务器以生成2FA代码。 如果您已将其他2FA方法与一次性密码传递一起使用，则此步骤已经完成。 </li><li> 将脚本添加到服务器以将代码发送给区块链Messenger中的用户。 </li><li> 创建用于发送和输入2FA代码的用户界面。 如果您已将其他2FA方法与一次性密码传递一起使用，则此步骤已经完成。 </li></ol><br>  <b>1创建一个帐户</b> <br><br> 在区块链中创建账户是生成私钥，公钥以及从中派生的账户地址。 <br><br><img src="https://habrastorage.org/webt/7o/at/vs/7oatvsalils_l9wsl8av5cjqtkc.png"><br><br> 首先，生成密码短语BIP39，从中考虑SHA-256哈希。 散列用于生成ks私钥和kp公钥。 从具有相同SHA-256的公钥（具有反演）中，获得区块链中的地址。 <br><br> 如果您想每次从一个新帐户发送2FA代码，则需要将用于创建帐户的代码添加到服务器： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mnemonic <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bitcore-mnemonic'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passphrase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mnemonic(Mnemonic.Words.ENGLISH).toString() … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bip39 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bip39'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> crypto <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto'</span></span> adamant.createPassphraseHash = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">passphrase</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seedHex = bip39.mnemonicToSeedSync(passphrase).toString(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(seedHex, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>).digest() } … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sodium <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sodium-browserify-tweetnacl'</span></span> adamant.makeKeypair = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keypair = sodium.crypto_sign_seed_keypair(hash) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">publicKey</span></span>: keypair.publicKey, <span class="hljs-attr"><span class="hljs-attr">privateKey</span></span>: keypair.secretKey } } … <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> crypto <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto'</span></span> adamant.getAddressFromPublicKey = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">publicKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publicKeyHash = crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(publicKey, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>).digest() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> temp = Buffer.alloc(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { temp[i] = publicKeyHash[<span class="hljs-number"><span class="hljs-number">7</span></span> - i] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'U'</span></span> + bignum.fromBuffer(temp).toString() }</code> </pre> <br> 在演示应用程序中，我们对其进行了简化-在Web应用程序中创建了一个帐户，然后从中发送代码。 在大多数情况下，这对用户来说更方便：他知道该服务从特定帐户发送2FA代码并可以对其进行命名。 <br><br><img src="https://habrastorage.org/webt/j6/0p/pi/j60ppi_a1zvkc-ifcrdxkaz8ow8.png"><br><br>  <b>2代2FA代码</b> <br><br> 需要为每个用户登录生成2FA代码。 我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">speakeasy</a>库，但您可以选择其他任何库。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hotp = speakeasy.hotp({ counter, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: account.seSecretAscii, });</code> </pre><br> 验证用户输入的用户2FA代码： <br><br><pre> <code class="javascript hljs">se2faVerified = speakeasy.hotp.verify({ <span class="hljs-attr"><span class="hljs-attr">counter</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seCounter, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seSecretAscii, <span class="hljs-attr"><span class="hljs-attr">token</span></span>: hotp, });</code> </pre><br>  <b>3提交2FA代码</b> <br><br> 您可以使用区块链节点API，JS API库或控制台来发送2FA代码。 在此示例中，我们使用控制台-这是命令行界面，该实用程序可简化与区块链的交互。 要发送带有2FA代码的消息，您需要使用控制台的<code>send message</code>命令。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> util = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> exec = util.promisify(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'child_process'</span></span>).exec); … <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> command = <span class="hljs-string"><span class="hljs-string">`adm send message </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${adamantAddress}</span></span></span><span class="hljs-string"> "2FA code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${hotp}</span></span></span><span class="hljs-string">"`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { error, stdout, stderr } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> exec(command);</code> </pre><br> 发送消息的另一种方法是使用JS API库中的<code>send</code>方法。 <br><br>  <b>4个用户界面</b> <br><br> 需要给用户输入2FA代码的机会，这可以通过多种方式完成，具体取决于应用程序的平台。 在我们的示例中，这是Vue。 <br><br><img src="https://habrastorage.org/webt/1g/yb/yv/1gybyvcmjucrqilrcpo74k8onoy.png"><br><br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>查看二元授权在区块链上的演示应用程序的源代码。 自述文件的实时演示中有一个链接可以尝试。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476090/">https://habr.com/ru/post/zh-CN476090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476060/index.html">来自OpenStreetMap 485世界的新闻（10.29.2019-04.11.2019）</a></li>
<li><a href="../zh-CN476074/index.html">自制电动车-第1部分</a></li>
<li><a href="../zh-CN476076/index.html">太干净了吗</a></li>
<li><a href="../zh-CN476082/index.html">JavaScript中的Array.splice和Array.slice</a></li>
<li><a href="../zh-CN476088/index.html">黑帽美国会议。 致富或丧命：使用Black Hat在互联网上赚钱。 第一部分</a></li>
<li><a href="../zh-CN476092/index.html">关于“我是专业人士”奥林匹克运动会的“光子学”，“程序设计和IT”以及“信息和网络安全”指导</a></li>
<li><a href="../zh-CN476094/index.html">帝国时代的回归：关于帝国时代的一切IV</a></li>
<li><a href="../zh-CN476096/index.html">从I到Z的库存。我们考虑IT资产</a></li>
<li><a href="../zh-CN476098/index.html">Java中的数据结构。 有用的助手类方法</a></li>
<li><a href="../zh-CN476100/index.html">计算机系统体系结构1部分。 逻辑门</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>