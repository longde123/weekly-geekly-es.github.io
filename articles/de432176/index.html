<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèæ üôÜüèΩ üßñüèæ Wie wir die Geschwindigkeit der Arbeit mit Float in Mono verdoppelt haben üëßüèø üèÇüèª üë©üèª‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Freund Aras hat k√ºrzlich denselben Ray Tracer in verschiedenen Sprachen geschrieben, einschlie√ülich C ++, C # und dem Unity Burst-Compiler. Nat√ºr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die Geschwindigkeit der Arbeit mit Float in Mono verdoppelt haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432176/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  Mein Freund Aras hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√ºrzlich</a> denselben Ray Tracer in verschiedenen Sprachen geschrieben, einschlie√ülich C ++, C # und dem Unity Burst-Compiler.  Nat√ºrlich ist zu erwarten, dass C # langsamer als C ++ ist, aber es schien mir interessant, dass Mono so langsamer als .NET Core ist. <br><br>  Seine ver√∂ffentlichten <a href="">Indikatoren</a> waren schlecht: <br><br><ul><li>  C # (.NET Core): Mac 17.5 Mray / s, </li><li>  C # (Unity, Mono): Mac 4.6 Mray / s, </li><li>  C # (Unity, IL2CPP): Mac 17.1 Mray / s </li></ul><br>  Ich beschloss zu sehen, was geschah, und Orte zu dokumentieren, die verbessert werden k√∂nnten. <br><br>  Als Ergebnis dieses Benchmarks und der Untersuchung dieses Problems haben wir drei Bereiche gefunden, in denen Verbesserungen m√∂glich sind: <br><br><ul><li>  Zun√§chst m√ºssen Sie die Standardeinstellungen f√ºr Mono verbessern, da Benutzer ihre Einstellungen normalerweise nicht konfigurieren </li><li>  Zweitens m√ºssen wir die Welt aktiv in das Backend der LLVM-Codeoptimierung in Mono einf√ºhren </li><li>  Drittens haben wir die Abstimmung einiger Mono-Parameter verbessert. </li></ul><br>  Der Bezugspunkt dieses Tests waren die Ergebnisse des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raytracers</a> , der auf meinem Computer ausgef√ºhrt wurde, und da ich unterschiedliche Hardware habe, k√∂nnen wir die Zahlen nicht vergleichen. <br><br>  Die Ergebnisse auf meinem iMac f√ºr Mono und .NET Core zu Hause waren wie folgt: <br><br><table><thead><tr><th>  Arbeitsumgebung </th><th>  Ergebnisse, MRay / Sek </th></tr></thead><tbody><tr><td> .NET Core 2.1.4, <code>dotnet run</code> Debug Build </td><td>  3.6 </td></tr><tr><td>  .NET Core 2.1.4 Release Build <code>dotnet run -c Release</code> </td><td>  21.7 </td></tr><tr><td>  Vanille Mono, <code>mono Maths.exe</code> </td><td>  6.6 </td></tr><tr><td>  Vanilla Mono mit LLVM und float32 </td><td>  15.5 </td></tr></tbody></table><a name="habracut"></a><br>  Bei der Untersuchung dieses Problems haben wir einige Probleme festgestellt, nach deren Korrektur die folgenden Ergebnisse erzielt wurden: <br><br><table><thead><tr><th>  Arbeitsumgebung </th><th>  Ergebnisse, MRay / Sek </th></tr></thead><tbody><tr><td>  Mono mit LLVM und float32 </td><td>  15.5 </td></tr><tr><td>  Advanced Mono mit LLVM, float32 und fester Inline </td><td>  29.6 </td></tr></tbody></table><br>  Das gro√üe Ganze: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/407/ecf/385/407ecf385de6261087b4395928076e02.png"></div><br>  Durch einfaches Anwenden von LLVM und float32 k√∂nnen Sie die Leistung von Gleitkomma-Code um fast das 2,3-fache steigern.  Und nach dem Tuning, das wir als Ergebnis dieser Experimente zu Mono hinzugef√ºgt haben, k√∂nnen Sie die Produktivit√§t im Vergleich zum Standard-Mono um das 4,4-fache steigern - diese Parameter werden in zuk√ºnftigen Versionen von Mono zu den Standardparametern. <br><br>  In diesem Artikel werde ich unsere Ergebnisse erl√§utern. <br><br><h2>  32-Bit- und 64-Bit-Float </h2><br>  Aras verwendet 32-Bit-Gleitkommazahlen f√ºr den Hauptteil der Berechnungen (geben Sie <code>float</code> in C # oder <code>System.Single</code> in .NET ein).  In Mono haben wir vor langer Zeit einen Fehler gemacht: Alle 32-Bit-Gleitkommaberechnungen wurden als 64-Bit-Berechnungen durchgef√ºhrt, und die Daten wurden weiterhin in 32-Bit-Bereichen gespeichert. <br><br>  Heute ist mein Ged√§chtnis nicht mehr so ‚Äã‚Äãscharf wie zuvor und ich kann mich nicht genau erinnern, warum wir eine solche Entscheidung getroffen haben. <br><br>  Ich kann nur vermuten, dass es von Trends und Ideen dieser Zeit beeinflusst wurde. <br><br>  Dann schwebte eine positive Aura mit erh√∂hter Genauigkeit um Float Computing.  Beispielsweise verwendeten Intel x87-Prozessoren eine 80-Bit-Genauigkeit f√ºr Gleitkommaberechnungen, selbst wenn die Operanden doppelt waren, was den Benutzern genauere Ergebnisse lieferte. <br><br>  Zu dieser Zeit war auch die Idee relevant, dass in einem meiner vorherigen Projekte - Gnumeric Spreadsheets - statistische Funktionen effizienter implementiert wurden als in Excel.  Daher sind sich viele Gemeinden der Idee bewusst, dass genauere Ergebnisse mit h√∂herer Genauigkeit verwendet werden k√∂nnen. <br><br>  In der Anfangsphase der Mono-Entwicklung konnten die meisten mathematischen Operationen, die auf allen Plattformen ausgef√ºhrt wurden, am Eingang nur das Doppelte erhalten.  32-Bit-Versionen wurden zu C99, Posix und ISO hinzugef√ºgt, aber damals waren sie nicht f√ºr die gesamte Branche verf√ºgbar (z. B. <code>sinf</code> ist die Float-Version von <code>sin</code> , <code>fabsf</code> ist die Version von <code>fabs</code> usw.). <br><br>  Kurz gesagt, die fr√ºhen 2000er Jahre waren eine Zeit des Optimismus. <br><br>  Anwendungen zahlten einen hohen Preis f√ºr die Verl√§ngerung der Rechenzeit, aber Mono wurde haupts√§chlich f√ºr Desktop-Linux-Anwendungen verwendet, die HTTP-Seiten und einige Serverprozesse bedienen. Daher war die Gleitkomma-Geschwindigkeit nicht das Problem, auf das wir t√§glich stie√üen.  Dies machte sich nur in einigen wissenschaftlichen Benchmarks bemerkbar, und 2003 wurden sie selten in .NET entwickelt. <br><br>  Heutzutage haben Spiele, 3D-Anwendungen, Bildverarbeitung, VR, AR und maschinelles Lernen Gleitkommaoperationen zu einer h√§ufigeren Art von Daten gemacht.  Das Problem kommt nicht alleine und es gibt keine Ausnahmen.  Float war nicht mehr der benutzerfreundliche Datentyp, der nur an wenigen Stellen im Code verwendet wurde.  Sie verwandelten sich in eine Lawine, vor der man sich nirgendwo verstecken kann.  Es gibt viele von ihnen und ihre Ausbreitung kann nicht gestoppt werden. <br><br><h2>  Arbeitsbereich-Flag float32 </h2><br>  Aus diesem Grund haben wir vor einigen Jahren beschlossen, wie in allen anderen F√§llen Unterst√ºtzung f√ºr die Ausf√ºhrung von 32-Bit-Float-Operationen mit 32-Bit-Operationen hinzuzuf√ºgen.  Wir haben diese Funktion des Arbeitsbereichs "float32" genannt.  In Mono wird es durch Hinzuf√ºgen der Option <code>--O=float32</code> in der Arbeitsumgebung <code>--O=float32</code> , und in Xamarin-Anwendungen wird dieser Parameter in den Projekteinstellungen ge√§ndert. <br><br>  Diese neue Flagge wurde von unseren mobilen Benutzern gut aufgenommen, da mobile Ger√§te im Grunde immer noch nicht zu leistungsf√§hig sind und es vorzuziehen ist, Daten schneller zu verarbeiten als eine h√∂here Genauigkeit.  Wir empfehlen mobilen Benutzern, den LLVM-Optimierungscompiler und das float32-Flag gleichzeitig zu aktivieren. <br><br>  Obwohl dieses Flag seit mehreren Jahren implementiert ist, haben wir es nicht zum Standard-Flag gemacht, um unangenehme √úberraschungen f√ºr Benutzer zu vermeiden.  Es kam jedoch zu F√§llen, in denen aufgrund des 64-Bit-Standardverhaltens √úberraschungen auftreten. Weitere Informationen finden Sie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vom Unity-Benutzer eingereichten Fehlerbericht</a> . <br><br>  Jetzt verwenden wir <code>float32</code> Mono <code>float32</code> . Der Fortschritt kann hier verfolgt werden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mono/mono/issues/6985</a> . <br><br>  In der Zwischenzeit kehrte ich zum Projekt meines Freundes Aras zur√ºck.  Er verwendete die neuen APIs, die zu .NET Core hinzugef√ºgt wurden.  Obwohl .NET Core immer 32-Bit-Float-Operationen als 32-Bit-Floats ausgef√ºhrt hat, f√ºhrt die <code>System.Math</code> API dabei immer noch Konvertierungen von <code>float</code> zu <code>double</code> durch.  Wenn Sie beispielsweise die Sinusfunktion f√ºr einen Float-Wert berechnen m√ºssen, k√∂nnen Sie nur <code>Math.Sin (double)</code> aufrufen und m√ºssen von float in double konvertieren. <br><br>  Um dies zu beheben, wurde .NET Core ein neuer Typ von <code>System.MathF</code> hinzugef√ºgt, der mathematische Operationen mit Gleitkommazahlen mit einfacher Genauigkeit enth√§lt. Jetzt haben wir dieses <code>[System.MathF]</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach Mono</a> <code>[System.MathF]</code> . <br><br>  Der √úbergang vom 64-Bit- zum 32-Bit-Float verbessert die Leistung erheblich. Dies geht aus dieser Tabelle hervor: <br><br><table><thead><tr><th>  <strong>Arbeitsumgebung und Optionen</strong> </th><th>  Mrays / Sekunde </th></tr></thead><tbody><tr><td>  Mono mit System.Math </td><td>  6.6 </td></tr><tr><td>  Mono mit System.Math und <code>-O=float32</code> </td><td>  8.1 </td></tr><tr><td>  Mono mit System.MathF </td><td>  6.5 </td></tr><tr><td>  Mono mit System.MathF und <code>-O=float32</code> </td><td>  8.2 </td></tr></tbody></table><br>  Das hei√üt, die Verwendung von <code>float32</code> in diesem Test verbessert die Leistung erheblich, und MathF hat nur geringe Auswirkungen. <br><br><h1>  LLVM-Setup </h1><br>  Bei dieser Untersuchung haben wir festgestellt, dass der Fast JIT Mono-Compiler zwar <code>float32</code> Unterst√ºtzung bietet, diese Unterst√ºtzung jedoch nicht zum LLVM-Backend <code>float32</code> hat.  Dies bedeutete, dass Mono mit LLVM immer noch kostspielige Konvertierungen von Float zu Double durchf√ºhrte. <br><br>  Daher f√ºgte Zoltan der LLVM-Codegenerierungs-Engine <code>float32</code> Unterst√ºtzung hinzu. <br><br>  Dann bemerkte er, dass unser Inliner f√ºr Fast JIT die gleichen Heuristiken verwendet wie f√ºr LLVM.  Bei der Arbeit mit Fast JIT muss ein Gleichgewicht zwischen JIT-Geschwindigkeit und Ausf√ºhrungsgeschwindigkeit hergestellt werden. Daher haben wir die Menge an eingebettetem Code begrenzt, um den Arbeitsaufwand der JIT-Engine zu verringern. <br><br>  Wenn Sie sich jedoch f√ºr die Verwendung von LLVM in Mono entscheiden, bem√ºhen Sie sich so schnell wie m√∂glich um den Code. Daher haben wir die Einstellungen entsprechend ge√§ndert.  Heute kann dieser Parameter mithilfe der Umgebungsvariablen <code>MONO_INLINELIMIT</code> ge√§ndert werden. Tats√§chlich muss er jedoch in die Standardwerte geschrieben werden. <br><br>  Hier sind die Ergebnisse mit den ge√§nderten LLVM-Einstellungen: <br><br><table><thead><tr><th>  Arbeitsumgebung und Optionen </th><th>  Mrays / Sekunden </th></tr></thead><tbody><tr><td>  Mono mit System.Math <code>--llvm -O=float32</code> </td><td>  16.0 </td></tr><tr><td>  Mono mit System.Math <code>--llvm -O=float32</code> , konstante Heuristik </td><td>  29.1 </td></tr><tr><td>  Mono mit System.MathF <code>--llvm -O=float32</code> , konstante Heuristik </td><td>  29.6 </td></tr></tbody></table><br><h1>  N√§chste Schritte </h1><br>  Es waren nur geringe Anstrengungen erforderlich, um all diese Verbesserungen vorzunehmen.  Diese √Ñnderungen wurden von regelm√§√üigen Diskussionen bei Slack angef√ºhrt.  Ich habe es sogar geschafft, eines Abends ein paar Stunden Zeit zu haben, um <code>System.MathF</code> nach Mono zu portieren. <br><br>  Der Aras Ray Tracer Code ist zu einem idealen Studienfach geworden, da er autark war, eine echte Anwendung und kein synthetischer Benchmark.  Wir m√∂chten eine andere √§hnliche Software finden, mit der der von uns generierte Bin√§rcode untersucht werden kann, und sicherstellen, dass wir LLVM die besten Daten f√ºr die optimale Ausf√ºhrung seiner Arbeit √ºbergeben. <br><br>  Wir erw√§gen auch, unser LLVM zu aktualisieren und die neu hinzugef√ºgten Optimierungen zu verwenden. <br><br><h1>  Separate Notiz </h1><br>  Extra Pr√§zision hat sch√∂ne Nebenwirkungen.  Beim Lesen der Poolanforderungen der Godot-Engine habe ich beispielsweise festgestellt, dass derzeit aktiv diskutiert wird, ob die Genauigkeit von Gleitkommaoperationen zur Kompilierungszeit anpassbar gemacht werden soll ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/godotengine/godot/pull/17134</a> ). <br><br>  Ich fragte Juan, warum dies f√ºr jemanden notwendig sein k√∂nnte, weil ich glaubte, dass 32-Bit-Gleitkommaoperationen f√ºr Spiele v√∂llig ausreichend sind. <br><br>  Juan erkl√§rte, dass Floats im Allgemeinen hervorragend funktionieren. Wenn Sie sich jedoch von der Mitte wegbewegen, beispielsweise 100 Kilometer von der Spielmitte entfernt, sammelt sich ein Berechnungsfehler an, der zu interessanten Grafikfehlern f√ºhren kann.  Sie k√∂nnen verschiedene Strategien verwenden, um die Auswirkungen dieses Problems zu verringern. Eine davon ist die Arbeit mit erh√∂hter Genauigkeit, f√ºr die Sie f√ºr die Leistung bezahlen m√ºssen. <br><br>  Kurz nach unserem Gespr√§ch sah ich in meinem Twitter-Feed einen Beitrag, der dieses Problem demonstrierte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://pharr.org/matt/blog/2018/03/02/rendering-in-camera-space.html</a> <br><br>  <em>Das Problem ist in den folgenden Bildern dargestellt.</em>  <em>Hier sehen wir ein Sportwagenmodell aus dem</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Paket pbrt-v3-scene</em></a> ** <em>.</em>  <em>Sowohl die Kamera als auch die Szene befinden sich in der N√§he des Ursprungs und alles sieht gut aus.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f1/702/725/4f1702725634faa3ba94aa930230fb6d.png"></div><br>  ** <em>(Autor von</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Yasutoshi Mori</em></a> <em>.)</em> <br><br>  Dann bewegen wir die Kamera und die Szene 200.000 Einheiten bei xx, yy und zz vom Ursprung.  Es ist ersichtlich, dass das Modell der Maschine ziemlich fragmentiert ist;  Dies ist ausschlie√ülich auf die mangelnde Genauigkeit der Gleitkommazahlen zur√ºckzuf√ºhren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/4b0/658/8424b065878f52bcd83b5d2de19321e5.png"></div><br>  <em>Wenn wir uns noch 5 √ó 5 √ó 5 Mal weiter bewegen, 1 Million Einheiten vom Ursprung entfernt, beginnt sich das Modell aufzul√∂sen.</em>  <em>Die Maschine verwandelt sich in eine extrem grobe Voxel-Ann√§herung an sich selbst, sowohl interessant als auch erschreckend.</em>  <em>(Keanu stellte die Frage: Ist Minecraft so kubisch, nur weil alles sehr weit vom Ursprung entfernt ist?)</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  ** <em>(Ich entschuldige mich bei</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Yasutoshi Mori</em></a> <em>f√ºr das, was wir mit seinem sch√∂nen Modell gemacht haben.)</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432176/">https://habr.com/ru/post/de432176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432166/index.html">Apache NiFi: Was es ist und ein kurzer √úberblick √ºber die Funktionen</a></li>
<li><a href="../de432168/index.html">Chinesische Beh√∂rden sammeln Informationen von Elektrofahrzeugen von B√ºrgern des Landes</a></li>
<li><a href="../de432170/index.html">Transportieren Sie ein Rechenzentrum in 14.400 Sekunden</a></li>
<li><a href="../de432172/index.html">Gef√§hrliche Einladung oder wie die Kampflast f√ºr eine Phishing-E-Mail funktioniert</a></li>
<li><a href="../de432174/index.html">Wie man ein Softwareprodukt kompetent und effektiv entwickelt</a></li>
<li><a href="../de432178/index.html">... und eine Garantie f√ºr Projektoren - erh√∂hen</a></li>
<li><a href="../de432180/index.html">So steigern Sie Ihre Karriere mit GitHub</a></li>
<li><a href="../de432182/index.html">Wir holen Post ohne SMS und Registrierung ab</a></li>
<li><a href="../de432184/index.html">Problemidentit√§ten unter Testern</a></li>
<li><a href="../de432186/index.html">Verwenden von STP zum Erstellen von P2P-Kan√§len</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>