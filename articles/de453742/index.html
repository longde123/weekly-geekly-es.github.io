<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèΩ ü§ô ü§üüèº Memcached Plugin: NoSQL in MySQL ‚è±Ô∏è üéóÔ∏è üç∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Maxim Matyukhin, ich bin ein PHP-Programmierer bei Badoo . In unserer Arbeit setzen wir MySQL aktiv ein. Aber manchmal fehlt uns ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memcached Plugin: NoSQL in MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/453742/"><img src="https://habrastorage.org/webt/1v/q0/h5/1vq0h5tev1qw1ivnheyxg7jfiqm.jpeg"><br><br>  Hallo!  Mein Name ist Maxim Matyukhin, ich bin ein PHP-Programmierer bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo</a> .  In unserer Arbeit setzen wir MySQL aktiv ein.  Aber manchmal fehlt uns die Leistung, deshalb suchen wir st√§ndig nach Wegen, um die Arbeit zu beschleunigen. <br><br>  Im Jahr 2010 f√ºhrte Yoshinori Matsunobu das NoSQL MySQL-Plugin namens HandlerSocket ein.  Es wurde behauptet, dass Sie mit diesem Plugin mehr als 750.000 Anfragen pro Sekunde ausf√ºhren k√∂nnen.  Wir wurden neugierig und begannen fast sofort, diese L√∂sung zu verwenden.  Das Ergebnis hat uns so gut gefallen, dass wir angefangen haben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentationen zu machen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel zu</a> schreiben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, die</a> f√ºr HandlerSocket werben. <br><br>  Anscheinend waren wir einer der wenigen Benutzer dieses Plugins - seit MySQL 5.7 funktioniert es nicht mehr.  In dieser Version erschien jedoch ein anderes Oracle-Plugin - das Memo-Plugin von InnoDB, das √§hnliche Funktionen versprach. <br><br>  Trotz der Tatsache, dass das Memcached-Plugin 2013 bereits in MySQL 5.6 ver√∂ffentlicht wurde, gibt es nicht so viele Artikel dar√ºber und zum gr√∂√üten Teil wiederholen sie die Dokumentation: Es wird ein einfaches Label erstellt und √ºber den Memcached-Client werden Anforderungen an das Plugin gestellt. <br><br>  Wir haben umfangreiche Erfahrungen mit Memcached und sind es gewohnt, einfach damit zu interagieren.  Von InnoDB memcached Plugin erwarteten wir die gleiche Einfachheit.  Tats√§chlich stellte sich jedoch heraus, dass, wenn sich die Muster f√ºr die Verwendung des Plug-Ins zumindest geringf√ºgig von den in der Dokumentation und den Artikeln beschriebenen unterscheiden, viele Nuancen und Einschr√§nkungen auftauchen, die auf jeden Fall eine √úberlegung wert sind, wenn Sie das Plug-In verwenden. <br><a name="habracut"></a><br><h1>  MySQL HandlerSocket </h1><br>  In diesem Artikel werden wir das neue memcached Plugin auf die eine oder andere Weise mit dem alten HandlerSocket vergleichen.  Daher erinnere ich mich, dass es das letztere war. <br><br>  Nach der Installation des HandlerSocket-Plugins h√∂rte MySQL zwei zus√§tzliche Ports ab: <br><br><ol><li>  Der erste Port erhielt Clientanforderungen zum Lesen von Daten. <br></li><li>  Der zweite Port empfing Clientanforderungen zur Datenaufzeichnung. <br></li></ol><br>  Der Client musste eine normale TCP-Verbindung an einem dieser Ports herstellen (es wurde keine Authentifizierung unterst√ºtzt), und danach musste der Befehl "open index" gesendet werden (ein spezieller Befehl, mit dem der Client informierte, welche Tabelle von welchem ‚Äã‚ÄãIndex welche Felder wir wollten lesen (oder schreiben)). <br><br>  Wenn der Befehl "open index" erfolgreich funktioniert hat, k√∂nnen Sie je nach Port, an dem die Verbindung hergestellt wurde, GETs oder INSERT / UPDATE / DELETE-Befehle senden. <br><br>  Mit HandlerSocket konnten nicht nur GETs f√ºr den Prim√§rschl√ºssel ausgef√ºhrt werden, sondern auch einfache Beispiele aus einem nicht eindeutigen Index, Bereichsbeispiele, unterst√ºtzte Multigets und LIMIT.  Gleichzeitig war es m√∂glich, mit der Tabelle sowohl aus normalem SQL als auch √ºber das Plugin zu arbeiten.  Auf diese Weise konnten Sie beispielsweise einige √Ñnderungen an Transaktionen √ºber SQL vornehmen und diese Daten dann √ºber HandlerSocket lesen. <br><br>  Es ist wichtig, dass HandlerSocket alle Verbindungen mit einem begrenzten Pool von Threads √ºber epoll verarbeitet. Daher war es einfach, Zehntausende von Verbindungen zu unterst√ºtzen, w√§hrend in MySQL selbst f√ºr jede Verbindung ein Thread erstellt wurde und deren Anzahl sehr begrenzt war. <br><br>  Gleichzeitig ist es immer noch ein gew√∂hnlicher MySQL-Server - eine uns bekannte Technologie.  Wir wissen, wie man es repliziert und √ºberwacht.  Die √úberwachung von HandlerSocket ist schwierig, da keine spezifischen Metriken bereitgestellt werden.  Einige der Standardmetriken f√ºr MySQL und InnoDB sind jedoch n√ºtzlich. <br><br>  Es gab nat√ºrlich Unannehmlichkeiten, insbesondere unterst√ºtzte dieses Plugin die Arbeit mit dem Zeitstempeltyp nicht.  Nun, das HandlerSocket-Protokoll ist schwerer zu lesen und daher schwerer zu debuggen. <br><br>  Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr √ºber HandlerSocket.  Sie k√∂nnen sich auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine unserer Pr√§sentationen</a> ansehen. <br><br><h1>  InnoDB memcached Plugin </h1><br>  Was bietet uns das neue memcached Plugin? <br><br>  Wie der Name schon sagt, besteht seine Idee darin, den memcached-Client zu verwenden, um mit MySQL zu arbeiten und Daten √ºber memcached-Befehle zu empfangen und zu speichern. <br><br>  √úber die Hauptvorteile des Plugins k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier lesen</a> . <br><br>  Wir sind am meisten an Folgendem interessiert: <br><br><ol><li>  Geringer CPU-Verbrauch. <br></li><li>  Die Daten werden in InnoDB gespeichert, was bestimmte Garantien gibt. <br></li><li>  Sie k√∂nnen mit Daten sowohl √ºber Memcached als auch √ºber SQL arbeiten.  Sie k√∂nnen mit den in MySQL integrierten Tools repliziert werden. <br></li></ol><br>  Sie k√∂nnen dieser Liste folgende Pluspunkte hinzuf√ºgen: <br><br><ol><li>  Schnelle und g√ºnstige Verbindung.  Eine regul√§re MySQL-Verbindung wird von einem Thread verarbeitet, und die Anzahl der Threads ist begrenzt. Im Memcached-Plugin verarbeitet ein Thread alle Verbindungen in der Ereignisschleife. <br></li><li>  Die M√∂glichkeit, mehrere Schl√ºssel mit einer GET-Anforderung anzufordern. <br></li><li>  Wenn Sie mit MySQL HandlerSocket vergleichen m√∂chten, m√ºssen Sie im memcached Plugin nicht den Befehl "Open Table" verwenden, und alle Lese- und Schreibvorg√§nge werden an einem Port ausgef√ºhrt. <br></li></ol><br><br>  Weitere Details zum Plugin finden Sie in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  F√ºr uns waren die n√ºtzlichsten Seiten: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InnoDB memcached Architektur</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InnoDB memcached Plugin Internals</a> . <br></li></ol><br>  Nach der Installation des Plugins akzeptiert MySQL Verbindungen √ºber Port 11211 (Standard-Memcached-Port).  Eine spezielle Datenbank (Schema) innodb_memcache wird ebenfalls angezeigt, in der Sie den Zugriff auf Ihre Tabellen konfigurieren. <br><br><h1>  Einfaches Beispiel </h1><br>  Angenommen, Sie haben bereits eine Tabelle, mit der Sie √ºber das zwischengespeicherte Protokoll arbeiten m√∂chten: <br><br><pre><code class="plaintext hljs">CREATE TABLE `auth` (  `email` varchar(96) NOT NULL,  `password` varchar(64) NOT NULL,  `type` varchar(32) NOT NULL DEFAULT '',  PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  und Sie m√∂chten Daten auf dem Prim√§rschl√ºssel empfangen und √§ndern. <br><br>  Sie m√ºssen zuerst die Entsprechung zwischen dem zwischengespeicherten Schl√ºssel und der SQL-Tabelle in der Tabelle innodb_memcache.containers beschreiben.  Diese Tabelle sieht ungef√§hr so ‚Äã‚Äãaus (ich habe die Codierungsbeschreibung entfernt, um das Lesen zu erleichtern): <br><br><pre> <code class="plaintext hljs">CREATE TABLE `containers` ( `name` varchar(50) NOT NULL, `db_schema` varchar(250) NOT NULL, `db_table` varchar(250) NOT NULL, `key_columns` varchar(250) NOT NULL, `value_columns` varchar(250) DEFAULT NULL, `flags` varchar(250) NOT NULL DEFAULT '0', `cas_column` varchar(250) DEFAULT NULL, `expire_time_column` varchar(250) DEFAULT NULL, `unique_idx_name_on_key` varchar(250) NOT NULL, PRIMARY KEY (`name`) ) ENGINE=InnoDB DEFAULT</code> </pre> <br>  Die wichtigsten Felder: <br><br><ul><li>  Name - Pr√§fix Ihres Memcached-Schl√ºssels; <br></li><li>  db_schema - Name der Basis (Schaltung); <br></li><li>  db_table ist Ihre Tabelle; <br></li><li>  key_columns - der Name des Feldes in der Tabelle, nach dem gesucht wird (normalerweise ist dies Ihr Prim√§rschl√ºssel); <br></li><li>  value_columns - eine Liste von Feldern aus der Tabelle, die dem memcached Plugin zur Verf√ºgung stehen; <br></li><li>  unique_idx_name_on_key ist der Index, nach dem gesucht werden soll (obwohl Sie bereits key_columns angegeben haben, k√∂nnen sie sich in verschiedenen Indizes befinden und Sie m√ºssen den Index explizit angeben). <br></li></ul><br>  Die restlichen Felder sind f√ºr den Anfang nicht sehr wichtig. <br><br>  F√ºgen Sie innodb_memcache.containers eine Beschreibung unserer Tabelle hinzu: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  In diesem Beispiel ist name = 'auth' das Pr√§fix unseres zwischengespeicherten Schl√ºssels.  In der Dokumentation wird es oft als table_id bezeichnet, und sp√§ter im Artikel werde ich diesen Begriff verwenden. <br><br>  Stellen Sie nun eine Verbindung zwischen TELNET und dem zwischengespeicherten Plugin her und versuchen Sie, die Daten zu speichern und abzurufen: <br><br><pre> <code class="plaintext hljs">[21:26:22] maxm@localhost: ~&gt; telnet memchached-mysql.dev 11211 Trying 127.0.0.1... Connected to memchached-mysql.dev. Escape character is '^]'. get @@auth.max@example.com END set @@auth.max@example.com 0 0 10 1234567|89 STORED get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  Zuerst haben wir eine GET-Anfrage gesendet, die uns nichts zur√ºckgegeben hat.  Dann haben wir die Daten mit einer SET-Anfrage gespeichert, danach haben wir sie mit einem GET zur√ºckbekommen. <br><br>  GET gab die folgende Zeile zur√ºck: 1234567 | 89.  Dies sind die Werte der Felder "Passwort" und "Typ", die durch das Symbol "|" getrennt sind.  Felder werden in der Reihenfolge zur√ºckgegeben, in der sie in innodb_memcache.containers.value_columns beschrieben wurden. <br><br>  Vielleicht fragen Sie sich jetzt: "Was passiert, wenn das Symbol" | "im" Passwort "vorkommt?"  Ich werde unten dar√ºber sprechen. <br><br>  √úber SQL sind diese Daten auch verf√ºgbar: <br><br><pre> <code class="plaintext hljs">MySQL [(none)]&gt; select * from auth where email='max@example.com'; +-----------------+----------+------+ | email      | password | type | +-----------------+----------+------+ | max@example.com | 1234567  | 89 | +-----------------+----------+------+ 1 row in set (0.00 sec)</code> </pre> <br><h2>  Standard table_id </h2><br>  Es gibt auch eine solche Betriebsart: <br><br><pre> <code class="plaintext hljs">get @@auth VALUE @@auth 0 21 test/auth END get max@example.com VALUE max@example.com 0 10 1234567|99 END set ivan@example.com 0 0 10 qwerty|xxx STORED get ivan@example.com VALUE ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  In diesem Beispiel machen wir mit get @@ auth table_id auth zum Standardpr√§fix f√ºr diese Verbindung.  Danach k√∂nnen alle nachfolgenden Abfragen ohne Angabe von table_id durchgef√ºhrt werden. <br><br>  Bisher ist alles einfach und logisch.  Aber wenn Sie anfangen zu verstehen, dann gibt es viele Nuancen.  Ich werde Ihnen sagen, was wir gefunden haben. <br><br><h1>  Nuancen </h1><br><h2>  Zwischenspeichern der Tabelle innodb_memcache.containers </h2><br>  Das zwischengespeicherte Plugin liest die Tabelle innodb_memcache.containers beim Start einmal.  Wenn eine unbekannte table_id √ºber das Memcached-Protokoll eintrifft, sucht das Plugin in der Tabelle danach.  Daher k√∂nnen Sie problemlos neue Schl√ºssel (table_id) hinzuf√ºgen. Wenn Sie jedoch die Einstellungen einer vorhandenen table_id √§ndern m√∂chten, m√ºssen Sie das zwischengespeicherte Plugin neu starten: <br><br><pre> <code class="plaintext hljs">mysql&gt; UNINSTALL PLUGIN daemon_memcached; mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code> </pre> <br>  Zwischen diesen beiden Anforderungen funktioniert die Memcached-Schnittstelle nicht.  Aus diesem Grund ist es oft einfacher, eine neue table_id zu erstellen, als die vorhandene zu √§ndern und das Plugin neu zu starten. <br><br>  Es war eine √úberraschung f√ºr uns, dass eine so wichtige Nuance des Plug-In-Vorgangs auf der Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anpassen einer zwischengespeicherten Anwendung f√ºr das Memo-Plugin-Plugin von InnoDB beschrieben wird</a> , was f√ºr solche Informationen kein sehr logischer Ort ist. <br><br><h2>  Flags, cas_column, expire_time_column </h2><br>  Diese Felder werden ben√∂tigt, um einige Funktionen von Memcached zu simulieren.  Die Dokumentation f√ºr sie ist inkonsistent.  Die meisten Beispiele veranschaulichen die Arbeit mit Tabellen, in denen sich diese Felder befinden.  M√∂glicherweise m√ºssen Sie sie zu Ihren Tabellen hinzuf√ºgen (und dies sind mindestens drei INT-Felder).  Aber nein.  Wenn Sie keine solchen Felder in den Tabellen haben und keine Memcached-Funktionen wie CAS, Ablauf oder Flags verwenden m√∂chten, m√ºssen Sie diese Felder nicht zu den Tabellen hinzuf√ºgen. <br><br>  Wenn Sie die Tabelle in innodb_memcache.containers konfigurieren, m√ºssen Sie '0' in diese Felder eingeben und genau die Zeile mit Null machen: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Es ist √§rgerlich, dass cas_column und expire_time_column den Standardwert NULL haben. Wenn Sie INSERT INTO innodb_memcache.containers ausf√ºhren, ohne f√ºr diese Felder den Wert '0' anzugeben, wird NULL in ihnen gespeichert und dieses Memcache-Pr√§fix funktioniert einfach nicht. <br><br><h2>  Datentypen </h2><br>  Aus der Dokumentation geht nicht klar hervor, welche Datentypen bei der Arbeit mit dem Plugin verwendet werden k√∂nnen.  An mehreren Stellen wird gesagt, dass das Plugin nur mit Textfeldern (CHAR, VARCHAR, BLOB) arbeiten kann.  Hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anpassen eines vorhandenen MySQL-Schemas f√ºr das InnoDB-Memcached-Plugin</a> bietet die M√∂glichkeit, Zahlen in Zeichenfolgenfeldern zu speichern. Wenn Sie dann mit diesen Zahlenfeldern aus SQL arbeiten m√ºssen, erstellen Sie eine ANSICHT, in der VARCHAR-Felder mit Zahlen in INTEGER-Felder konvertiert werden :: <br><br><pre> <code class="plaintext hljs">CREATE VIEW numbers AS SELECT c1 KEY, CAST(c2 AS UNSIGNED INTEGER) val FROM demo_test WHERE c2 BETWEEN '0' and '9999999999';</code> </pre> <br>  An einigen Stellen in der Dokumentation steht jedoch noch, dass Sie mit Zahlen arbeiten k√∂nnen.  Bisher haben wir nur echte Produktionserfahrung mit Textfeldern, aber die experimentellen Ergebnisse zeigen, dass das Plugin auch mit Zahlen funktioniert: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `numbers` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `counter` int(10) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=InnoDB INSERT INTO innodb_memcache.containers SET name='numbers', db_schema='test', db_table='numbers', key_columns='id', value_columns='counter', flags='0', cas_column='0',expire_time_column='0',unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Danach √ºber das Memcached-Protokoll: <br><br><pre> <code class="plaintext hljs">get @@numbers.1 END set @@numbers.1 0 0 2 12 STORED get @@numbers.1 VALUE @@numbers.1 0 2 12 END</code> </pre> <br>  Wir sehen, dass das zwischengespeicherte Plugin alle Datentypen zur√ºckgeben kann.  Er gibt sie jedoch in der Form zur√ºck, in der sie in InnoDB liegen. Im Fall von timestamp / datetime / float / decimal / JSON wird beispielsweise eine Bin√§rzeichenfolge zur√ºckgegeben.  Ganzzahlen werden jedoch so zur√ºckgegeben, wie wir sie √ºber SQL sehen. <br><br><h2>  Multiget </h2><br>  Mit dem zwischengespeicherten Protokoll k√∂nnen Sie mehrere Schl√ºssel mit einer einzigen Anforderung anfordern: <br><br><pre> <code class="plaintext hljs">get @@numbers.2 @@numbers.1 VALUE @@numbers.2 0 2 12 VALUE @@numbers.1 0 2 13 END</code> </pre> <br>  Die Tatsache, dass Multiget funktioniert, ist bereits gut.  Aber es funktioniert im Rahmen einer table_id: <br><br><pre> <code class="plaintext hljs">get @@auth.ivan@example.com @@numbers.2 VALUE @@auth.ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  Dieser Punkt wird in der Dokumentation hier beschrieben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dev.mysql.com/doc/refman/8.0/en/innodb-memcached-multiple-get-range-query.html</a> .  Es stellt sich heraus, dass Sie in Multiget table_id nur f√ºr den ersten Schl√ºssel angeben k√∂nnen, wenn alle anderen Schl√ºssel aus der Standard-table_id stammen (Beispiel aus der Dokumentation): <br><br><pre> <code class="plaintext hljs">get @@aaa.AA BB VALUE @@aaa.AA 8 12 HELLO, HELLO VALUE BB 10 16 GOODBYE, GOODBYE END</code> </pre> <br>  In diesem Beispiel wird der zweite Schl√ºssel aus der Standard-Tabellen-ID √ºbernommen.  Wir k√∂nnten viel mehr Schl√ºssel aus der Standard-Tabellen-ID angeben, und f√ºr den ersten Schl√ºssel haben wir eine separate Tabellen-ID angegeben, und dies ist nur im Fall des ersten Schl√ºssels m√∂glich. <br><br>  Wir k√∂nnen sagen, dass Multiget im Rahmen einer Tabelle funktioniert, da Sie sich nicht auf eine solche Logik im Produktionscode verlassen m√∂chten: Es ist nicht offensichtlich, es ist leicht, sie zu vergessen und einen Fehler zu machen. <br><br>  Im Vergleich zu HandlerSocket arbeitete auch dort Multiget in derselben Tabelle.  Diese Einschr√§nkung sah jedoch nat√ºrlich aus: Der Client √∂ffnet den Index in der Tabelle und fordert einen oder mehrere Werte von ihm an.  Wenn Sie jedoch mit dem Multiget-Memcached-Plugin an mehreren Schl√ºsseln mit unterschiedlichen Pr√§fixen arbeiten, ist dies normale Praxis.  Und Sie erwarten dasselbe vom MySQL-Memcached-Plugin.  Aber nein :( <br><br><h2>  INCR, DEL </h2><br>  Ich habe bereits Beispiele f√ºr GET / SET-Anfragen gegeben.  INCR- und DEL-Abfragen haben eine Funktion.  Es liegt in der Tatsache, dass sie nur funktionieren, wenn die Standard-Tabellen-ID verwendet wird: <br><br><pre> <code class="plaintext hljs">DELETE @@numbers.1 ERROR get @@numbers VALUE @@numbers 0 24 test/numbers END delete 1 DELETED</code> </pre> <br><h2>  Eingeschr√§nkte Protokollbeschr√§nkungen </h2><br>  Memcached verf√ºgt √ºber ein Textprotokoll, das einige Einschr√§nkungen auferlegt.  Beispielsweise sollten zwischengespeicherte Schl√ºssel keine Leerzeichen (Leerzeichen, Zeilenvorschub) enthalten.  Wenn Sie sich die Beschreibung der Tabelle aus unserem Beispiel noch einmal ansehen: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `auth` ( `email` varchar(96) NOT NULL, `password` varchar(64) NOT NULL, `type` varchar(32) NOT NULL DEFAULT '', PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  Dies bedeutet, dass im Feld "E-Mail" keine solchen Zeichen vorhanden sein sollten. <br><br>  Au√üerdem m√ºssen zwischengespeicherte Schl√ºssel kleiner als 250 Byte sein (Bytes, keine Zeichen).  Wenn Sie mehr senden, erhalten Sie eine Fehlermeldung: <br><br><pre> <code class="plaintext hljs">"CLIENT_ERROR bad command line format"</code> </pre> <br>  Au√üerdem muss ber√ºcksichtigt werden, dass das memcached Plugin dem memcached Protokoll eine eigene Syntax hinzuf√ºgt.  Beispielsweise wird das Zeichen "|" verwendet.  als Feldtrennzeichen in der Antwort.  Sie m√ºssen sicherstellen, dass dieses Symbol in Ihrer Tabelle nicht verwendet wird.  Das Trennzeichen kann konfiguriert werden, die Einstellungen gelten jedoch f√ºr alle Tabellen auf dem gesamten MySQL-Server. <br><br><h2>  Feldtrennzeichen value_columns </h2><br>  Wenn Sie mehrere Spalten √ºber das zwischengespeicherte Protokoll zur√ºckgeben m√ºssen, wie in unserem ersten Beispiel: <br><br><pre> <code class="plaintext hljs">get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  dann werden die Spaltenwerte durch das Standardtrennzeichen "|" getrennt.  Es stellt sich die Frage: "Was passiert, wenn sich beispielsweise das Zeichen" | "im ersten Feld der Zeile befindet?"  Das zwischengespeicherte Plugin gibt in diesem Fall die Zeichenfolge unver√§ndert zur√ºck: 1234 | 567 | 89.  Im allgemeinen Fall ist es unm√∂glich zu verstehen, wo welches Feld ist. <br><br>  Daher ist es wichtig, sofort das richtige Trennzeichen auszuw√§hlen.  Und da es f√ºr alle Schl√ºssel aller Tabellen verwendet wird, sollte es ein universelles Symbol sein, das in keinem Feld gefunden wird, mit dem Sie das zwischengespeicherte Protokoll bearbeiten. <br><br><h1>  Zusammenfassung </h1><br>  Dies bedeutet nicht, dass das zwischengespeicherte Plugin schlecht ist.  Man hat jedoch den Eindruck, dass es f√ºr ein bestimmtes Arbeitsschema geschrieben wurde: einen MySQL-Server mit einer Tabelle, auf die √ºber das memcached-Protokoll zugegriffen werden kann, und diese table_id wird als Standard festgelegt.  Clients stellen eine dauerhafte Verbindung mit dem Memcached-Plugin her und stellen Anforderungen an die Standard-Tabellen-ID.  Wahrscheinlich wird in einem solchen Schema alles einwandfrei funktionieren.  Wenn Sie sich davon entfernen, sto√üen Sie auf verschiedene Unannehmlichkeiten. <br><br>  M√∂glicherweise haben Sie einige Plugin-Leistungsberichte erwartet.  Wir haben uns jedoch noch nicht entschieden, es an stark belasteten Orten einzusetzen.  Wir haben es nur in einigen nicht sehr ausgelasteten Systemen verwendet und dort funktioniert es ungef√§hr mit der gleichen Geschwindigkeit wie das HandlerSocket, aber wir haben keine ehrlichen Benchmarks erstellt.  Trotzdem bietet das Plugin eine solche Schnittstelle, mit der der Programmierer leicht einen Fehler machen kann - Sie m√ºssen viele Nuancen ber√ºcksichtigen.  Daher sind wir noch nicht bereit, dieses Plugin in gro√üen Mengen zu verwenden. <br><br>  Wir haben im MySQL-Bug-Tracker einige Feature-Anfragen gestellt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://bugs.mysql.com/bug.php?id=95091</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://bugs.mysql.com/bug.php?id=95092</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://bugs.mysql.com/bug.php?id=95093</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://bugs.mysql.com/bug.php?id=95094</a> <br><br>  Hoffen wir, dass das Memcached Plugin-Entwicklungsteam sein Produkt verbessern wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453742/">https://habr.com/ru/post/de453742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453722/index.html">√úber die Erforschung instation√§rer Prozesse</a></li>
<li><a href="../de453728/index.html">Schlacht der Hyperstars</a></li>
<li><a href="../de453730/index.html">Moderne Zahnmedizin: gleichzeitige Zahnimplantation und Streckung des Kieferknochens durch die Augen des technischen Direktors</a></li>
<li><a href="../de453732/index.html">Ich komme aus Moreinis. Schr√§ge Ansichten oder Respekt?</a></li>
<li><a href="../de453734/index.html">Einf√ºhrung in Helm 3</a></li>
<li><a href="../de453744/index.html">Wir untersuchen das Prinzip der Pseudoklasse: not () am Beispiel der Aufgabe ‚ÄûHervorheben der aktiven Zeile einer Tabelle in reinem CSS‚Äú.</a></li>
<li><a href="../de453748/index.html">Prototyping eines Handyspiels, wo man anf√§ngt und wie man es macht. Teil 3 (endg√ºltig)</a></li>
<li><a href="../de453750/index.html">√úber den j√ºngsten Cyberangriff in Baltimore</a></li>
<li><a href="../de453756/index.html">Probleme der aktuellen Methodik zur Ermittlung aktueller Bedrohungen durch die FSTEC</a></li>
<li><a href="../de453760/index.html">Zirkeltrainingslager f√ºr Panzer und Prozessoren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>