<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèΩ üßñüèª üë®üèΩ‚Äçüé® Bases de l'injection de d√©pendance ‚úâÔ∏è üßëüèº üéç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je vais parler des bases de l'injection de d√©pendance (Eng. Dependency Injection, DI ) dans un langage simple, ainsi que des raisons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bases de l'injection de d√©pendance</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434380/"><p><img src="https://habrastorage.org/getpro/habr/post_images/741/7ce/850/7417ce8508eb0e9c8dbd12b14d37f383.jpg" alt="Bases de l'injection de d√©pendance"></p><br><p>  Dans cet article, je vais parler des bases de l'injection de d√©pendance (Eng. <em>Dependency Injection, DI</em> ) dans un langage simple, ainsi que des raisons d'utiliser cette approche.  Cet article est destin√© √† ceux qui ne savent pas ce qu'est l'injection de d√©pendance ou qui doutent de la n√©cessit√© d'utiliser cette technique.  Commen√ßons donc. </p><a name="habracut"></a><br><h2 id="chto-takoe-zavisimost">  Qu'est-ce que la d√©pendance? </h2><br><p> Regardons d'abord un exemple.  Nous avons <code>ClassA</code> , <code>ClassB</code> et <code>ClassC</code> comme indiqu√© ci-dessous: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Vous pouvez voir que la classe <code>ClassA</code> contient une instance de la classe <code>ClassB</code> , nous pouvons donc dire que la classe <code>ClassA</code> d√©pend de la classe <code>ClassB</code> .  Pourquoi?  Parce que <code>ClassA</code> besoin de <code>ClassB</code> pour fonctionner correctement.  On peut √©galement dire que la classe <code>ClassB</code> est une d√©pendance de la classe <code>ClassA</code> . </p><br><p>  Avant de continuer, je tiens √† pr√©ciser qu'une telle relation est bonne, car nous n'avons pas besoin d'une seule classe pour faire tout le travail dans l'application.  Nous devons diviser la logique en diff√©rentes classes, chacune √©tant responsable d'une certaine fonction.  Et dans ce cas, les classes pourront interagir efficacement. </p><br><h2 id="kak-rabotat-s-zavisimostyami">  Comment travailler avec des d√©pendances? </h2><br><p>  Examinons trois m√©thodes utilis√©es pour effectuer des t√¢ches d'injection de d√©pendances: </p><br><h3 id="pervyy-sposob-sozdavat-zavisimosti-v-zavisimom-klasse">  Premi√®re fa√ßon: cr√©er des d√©pendances dans une classe d√©pendante </h3><br><p>  Autrement dit, nous pouvons cr√©er des objets chaque fois que nous en avons besoin.  Jetez un ≈ìil √† l'exemple suivant: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethodOrConstructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { classB = ClassB() classB.doSomething() } }</code> </pre> <br><p>  C'est tr√®s simple!  Nous cr√©ons une classe quand nous en avons besoin. </p><br><p>  <strong>Les avantages</strong> </p><br><ul><li>  C'est facile et simple. </li><li>  La classe d√©pendante ( <code>ClassA</code> dans notre cas) contr√¥le enti√®rement comment et quand cr√©er les d√©pendances. </li></ul><br><p>  <strong>Inconv√©nients</strong> </p><br><ul><li>  <code>ClassA</code> et <code>ClassB</code> √©troitement li√©es l'une √† l'autre.  Par cons√©quent, chaque fois que nous aurons besoin d'utiliser <code>ClassA</code> , nous serons oblig√©s d'utiliser <code>ClassB</code> et <strong>il sera impossible de remplacer <code>ClassB</code> par autre chose</strong> . </li><li>  Avec tout changement dans l'initialisation de la classe <code>ClassB</code> , vous devrez ajuster le code √† l'int√©rieur de la classe <code>ClassA</code> (et toutes les autres classes d√©pendantes de <code>ClassB</code> ).  Cela complique le processus de changement de d√©pendance. </li><li>  <strong><code>ClassA</code> ne peut pas √™tre test√©e.</strong>  Si vous avez besoin de tester une classe, et pourtant c'est l'un des aspects les plus importants du d√©veloppement logiciel, vous devrez effectuer des tests unitaires de chaque classe s√©par√©ment.  Cela signifie que si vous souhaitez v√©rifier <code>ClassA</code> le bon fonctionnement de la classe <code>ClassA</code> et cr√©er plusieurs tests unitaires pour le v√©rifier, alors, comme indiqu√© dans l'exemple, vous cr√©erez dans tous les cas √©galement une instance de la classe <code>ClassB</code> , m√™me si cela ne vous int√©resse pas.  Si une erreur se produit pendant le test, vous ne pourrez pas comprendre o√π elle se trouve - dans <code>ClassA</code> ou <code>ClassB</code> .  Apr√®s tout, il est possible qu'une partie du code de la <code>ClassB</code> conduit √† une erreur, alors que la <code>ClassA</code> fonctionne correctement.  En d'autres termes, le test unitaire n'est pas possible car les modules (classes) ne peuvent pas √™tre s√©par√©s les uns des autres. </li><li>  <code>ClassA</code> doit √™tre configur√© pour pouvoir injecter des d√©pendances.  Dans notre exemple, il doit savoir comment cr√©er un <code>ClassC</code> et l'utiliser pour cr√©er un <code>ClassB</code> .  Ce serait mieux s'il n'en savait rien.  Pourquoi?  En raison du <strong>principe de la responsabilit√© unique</strong> . </li></ul><br><blockquote>  <em>Chaque classe ne devrait faire que son travail.</em> </blockquote><p>  Par cons√©quent, nous ne voulons pas que les classes soient responsables d'autre chose que de leurs propres t√¢ches.  L'impl√©mentation des d√©pendances est une t√¢che suppl√©mentaire que nous leur avons assign√©e. </p><br><h3 id="vtoroy-sposob-vnedryat-zavisimosti-cherez-polzovatelskiy-klass">  Deuxi√®me fa√ßon: injecter des d√©pendances via une classe personnalis√©e </h3><br><p>  Donc, comprendre que l'injection de d√©pendances dans une classe d√©pendante n'est pas une bonne id√©e, explorons une autre fa√ßon.  Ici, la classe d√©pendante d√©finit toutes les d√©pendances dont elle a besoin √† l'int√©rieur du constructeur et permet √† la classe utilisateur de les fournir.  Est-ce une solution √† notre probl√®me?  Nous le saurons un peu plus tard. </p><br><p>  Jetez un ≈ìil √† l'exemple de code ci-dessous: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span></span>(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classC = ClassC(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classB = ClassB(classC); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> classA = ClassA(classB); classA.someMethod(); } } view rawDI Example In Medium -</code> </pre> <br><p>  Maintenant, <code>ClassA</code> obtient toutes les d√©pendances √† l'int√©rieur du constructeur et peut simplement appeler les m√©thodes de la classe <code>ClassB</code> sans rien initialiser. </p><br><p>  <strong>Les avantages</strong> </p><br><ul><li>  <code>ClassA</code> et <code>ClassB</code> d√©sormais faiblement coupl√©s, et nous pouvons remplacer <code>ClassB</code> sans casser le code √† l'int√©rieur de <code>ClassA</code> .  Par exemple, au lieu de passer <code>ClassB</code> nous pouvons passer <code>AssumeClassB</code> , qui est une sous-classe de <code>ClassB</code> , et notre programme fonctionnera correctement. </li><li>  <code>ClassA</code> peut d√©sormais √™tre test√©e.  Lors de l'√©criture d'un test unitaire, nous pouvons cr√©er notre propre version de <code>ClassB</code> (objet de test) et la transmettre √† <code>ClassA</code> .  Si une erreur se produit lors de la r√©ussite du test, nous savons maintenant avec certitude qu'il s'agit bien d'une erreur dans <code>ClassA</code> . </li><li>  <code>ClassB</code> libre de travailler avec des d√©pendances et peut se concentrer sur ses t√¢ches. </li></ul><br><p>  <strong>Inconv√©nients</strong> </p><br><ul><li>  Cette m√©thode ressemble √† un m√©canisme de cha√Æne, et √† un moment donn√©, la cha√Æne doit √™tre interrompue.  En d'autres termes, l'utilisateur de la classe <code>ClassA</code> doit tout savoir sur l'initialisation de <code>ClassB</code> , ce qui n√©cessite √† son tour des connaissances sur l'initialisation de <code>ClassC</code> , etc.  Ainsi, vous voyez que tout changement dans le constructeur de l'une de ces classes peut entra√Æner un changement dans la classe appelante, sans oublier que <code>ClassA</code> peut avoir plus d'un utilisateur, de sorte que la logique de cr√©ation d'objets sera r√©p√©t√©e. </li><li>  Malgr√© le fait que nos d√©pendances sont claires et faciles √† comprendre, le code utilisateur n'est pas trivial et difficile √† g√©rer.  Par cons√©quent, tout n'est pas si simple.  En outre, le code viole le principe de la responsabilit√© unique, car il est responsable non seulement de son travail, mais √©galement de la mise en ≈ìuvre des d√©pendances dans les classes d√©pendantes. </li></ul><br><p>  La deuxi√®me m√©thode fonctionne √©videmment mieux que la premi√®re, mais elle a toujours ses d√©fauts.  Est-il possible de trouver une solution plus adapt√©e?  Avant d'envisager la troisi√®me voie, parlons d'abord du concept m√™me d'injection de d√©pendance. </p><br><h3 id="chto-takoe-vnedrenie-zavisimostey">  Qu'est-ce que l'injection de d√©pendance? </h3><br><blockquote>  L'injection de d√©pendances est un moyen de g√©rer les d√©pendances en dehors de la classe d√©pendante lorsque la classe d√©pendante n'a rien √† faire. </blockquote><p>  Sur la base de cette d√©finition, notre premi√®re solution n'utilise √©videmment pas l'id√©e d'injection de d√©pendances, et la deuxi√®me mani√®re est que la classe d√©pendante ne fait rien pour fournir les d√©pendances.  Mais nous pensons toujours que la deuxi√®me solution est mauvaise.  POURQUOI?! </p><br><p>  √âtant donn√© que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©finition de l'injection de d√©pendance</a> ne dit rien sur l'endroit o√π le travail avec les d√©pendances doit avoir lieu (sauf en dehors de la classe d√©pendante), le d√©veloppeur doit choisir un endroit appropri√© pour l'injection de d√©pendance.  Comme vous pouvez le voir dans le deuxi√®me exemple, la classe d'utilisateurs n'est pas tout √† fait au bon endroit. </p><br><p>  Comment faire mieux?  Examinons une troisi√®me fa√ßon de g√©rer les d√©pendances. </p><br><h3 id="tretiy-sposob-pust-kto-nibud-eschyo-obrabatyvaet-zavisimosti-vmesto-nas">  Troisi√®me fa√ßon: laissez quelqu'un d'autre g√©rer les d√©pendances au lieu de nous </h3><br><p>  Selon la premi√®re approche, les classes d√©pendantes sont responsables de l'obtention de leurs propres d√©pendances, et dans la deuxi√®me approche, nous avons d√©plac√© le traitement des d√©pendances de la classe d√©pendante vers la classe utilisateur.  Imaginons qu'il y ait quelqu'un d'autre qui pourrait g√©rer les d√©pendances, √† la suite de quoi ni les classes d√©pendantes ni les classes d'utilisateurs ne feraient le travail.  Cette m√©thode vous permet de travailler directement avec les d√©pendances dans l'application. </p><br><blockquote>  <strong><em>Une impl√©mentation ¬´propre¬ª de l'injection de d√©pendance (√† mon avis)</em></strong> <br><br>  <em>La responsabilit√© du traitement des d√©pendances incombe √† un tiers, donc aucune partie de l'application n'interagira avec lui.</em> </blockquote><p>  L'injection de d√©pendances n'est pas une technologie, un cadre, une biblioth√®que ou quelque chose comme √ßa.  Ce n'est qu'une id√©e.  L'id√©e est de travailler avec des d√©pendances en dehors de la classe d√©pendante (de pr√©f√©rence dans une partie sp√©cialement allou√©e).  Vous pouvez appliquer cette id√©e sans utiliser de biblioth√®ques ou de frameworks.  Cependant, nous nous tournons g√©n√©ralement vers les frameworks pour impl√©menter les d√©pendances, car cela simplifie le travail et √©vite d'√©crire du code de mod√®le. </p><br><p>  Tout cadre d'injection de d√©pendance a deux caract√©ristiques inh√©rentes.  D'autres fonctions suppl√©mentaires peuvent √™tre √† votre disposition, mais ces deux fonctions seront toujours pr√©sentes: </p><br><p>  Premi√®rement, ces cadres offrent un moyen de d√©terminer les champs (objets) √† mettre en ≈ìuvre.  Certains frameworks le font en annotant un champ ou un constructeur √† l'aide de l'annotation <code>@Inject</code> , mais il existe d'autres m√©thodes.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Koin</a> utilise les fonctionnalit√©s du langage int√©gr√© de Kotlin pour d√©terminer la mise en ≈ìuvre.  <code>Inject</code> signifie que la d√©pendance doit √™tre g√©r√©e par le framework DI.  Le code ressemblera √† ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classB: ClassB <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classB: ClassB){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classB = classB } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classC: ClassC <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(classC: ClassC){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classC = classC } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ } }</code> </pre> <br><p>  Deuxi√®mement, les frameworks vous permettent de d√©terminer comment fournir chaque d√©pendance, et cela se produit dans un ou plusieurs fichiers distincts.  Cela ressemble approximativement √† ceci (gardez √† l'esprit qu'il ne s'agit que d'un exemple et qu'il peut diff√©rer d'un cadre √† l'autre): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OurThirdPartyGuy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ClassC() <span class="hljs-comment"><span class="hljs-comment">//just creating an instance of the object and return it. } fun provideClassB(classC: ClassC){ return ClassB(classC) } fun provideClassA(classB: ClassB){ return ClassA(classB) } }</span></span></code> </pre> <br><p>  Ainsi, comme vous pouvez le voir, chaque fonction est responsable du traitement d'une d√©pendance.  Par cons√©quent, si nous devons utiliser <code>ClassA</code> quelque part dans l'application, les <code>ClassA</code> suivants se produiront: notre <code>ClassC</code> DI cr√©e une instance de la classe <code>ClassC</code> en appelant <code>provideClassC</code> , en la passant √† <code>provideClassB</code> et en recevant une instance de <code>ClassB</code> , qui est transmise √† <code>provideClassA</code> , et en cons√©quence, <code>ClassA</code> est cr√©√©.  C'est presque magique.  Examinons maintenant les avantages et les avantages de la troisi√®me m√©thode. </p><br><p>  <strong>Les avantages</strong> </p><br><ul><li>  Tout est aussi simple que possible.  La classe d√©pendante et la classe qui fournit les d√©pendances sont claires et simples. </li><li>  Les classes sont faiblement coupl√©es et sont facilement rempla√ßables par d'autres classes.  Supposons que nous voulons remplacer <code>ClassC</code> par <code>AssumeClassC</code> , qui est une sous-classe de <code>ClassC</code> .  Pour ce faire, il vous suffit de modifier le code du fournisseur comme suit, et partout o√π <code>ClassC</code> est utilis√©, la nouvelle version sera d√©sormais automatiquement utilis√©e: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideClassC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssumeClassC() }</code> </pre> <br><p>  Veuillez noter qu'aucun code √† l'int√©rieur de l'application ne change, seulement la m√©thode du fournisseur.  Il semble que rien ne pourrait √™tre encore plus simple et plus flexible. </p><br><ul><li>  Testabilit√© incroyable.  Vous pouvez facilement remplacer les d√©pendances par des versions de test pendant le test.  En fait, l'injection de d√©pendance est votre principale aide en mati√®re de test. </li><li>  Am√©liorer la structure du code, comme  l'application a une place distincte pour le traitement des d√©pendances.  Par cons√©quent, le reste de l'application peut se concentrer exclusivement sur ses fonctions et ne pas chevaucher de d√©pendances. </li></ul><br><p>  <strong>Inconv√©nients</strong> </p><br><ul><li>  Les cadres DI ont un certain seuil d'entr√©e, donc l'√©quipe de projet doit passer du temps et l'√©tudier avant de l'utiliser efficacement. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><ul><li>  La gestion des d√©pendances sans DI est possible, mais elle peut entra√Æner des pannes d'application. </li><li>  DI n'est qu'une id√©e efficace, selon laquelle il est possible de g√©rer des d√©pendances en dehors de la classe d√©pendante. </li><li>  Il est plus efficace d'utiliser DI dans certaines parties de l'application.  De nombreux cadres y contribuent. </li><li>  Les cadres et les biblioth√®ques ne sont pas n√©cessaires pour DI, mais ils peuvent beaucoup aider. </li></ul><br><p>  Dans cet article, j'ai essay√© d'expliquer les bases de l'utilisation du concept d'injection de d√©pendance et j'ai √©galement √©num√©r√© les raisons pour lesquelles cette id√©e √©tait utilis√©e.  Il existe de nombreuses autres ressources que vous pouvez explorer pour en savoir plus sur l'utilisation de DI dans vos propres applications.  Par exemple, une section distincte dans la partie avanc√©e de notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cours de profession Android est</a> d√©di√©e √† ce sujet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434380/">https://habr.com/ru/post/fr434380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434362/index.html">PAS pr√©vu pour 2019</a></li>
<li><a href="../fr434364/index.html">Prise en charge de la file d'attente Hangfire</a></li>
<li><a href="../fr434368/index.html">Apprentissage automatique pour trouver des erreurs dans le code: comment j'ai effectu√© un stage chez JetBrains Research</a></li>
<li><a href="../fr434370/index.html">Un autre conqu√©rant de l'ombre √† Phaser, ou l'utilisation de v√©los</a></li>
<li><a href="../fr434374/index.html">V√©rification de RBAC dans Kubernetes</a></li>
<li><a href="../fr434382/index.html">Portage d'Alpine Linux vers RISC-V</a></li>
<li><a href="../fr434384/index.html">Sous la responsabilit√© des artistes interpr√®tes ou ex√©cutants</a></li>
<li><a href="../fr434386/index.html">Douglas Engelbart: ¬´Augmenter l'intellect humain: un cadre conceptuel¬ª</a></li>
<li><a href="../fr434394/index.html">Bugatti Automobiles teste avec succ√®s l'√©trier de frein imprim√© en 3D</a></li>
<li><a href="../fr434398/index.html">Vanivar Bush: ¬´Comme nous pouvons le penser¬ª. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>