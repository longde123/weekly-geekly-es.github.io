<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤°ğŸ» ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ğŸ· Bagaimana kami membangun pemantauan di Prometheus, Clickhouse dan ELK ğŸŒ¹ ğŸ¸ ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Anton Baderin. Saya bekerja di Pusat Teknologi Tinggi dan terlibat dalam administrasi sistem. Sebulan yang lalu, konferensi perusahaan kami ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami membangun pemantauan di Prometheus, Clickhouse dan ELK</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449352/"><p>  Nama saya Anton Baderin.  Saya bekerja di Pusat Teknologi Tinggi dan terlibat dalam administrasi sistem.  Sebulan yang lalu, konferensi perusahaan kami berakhir, di mana kami berbagi pengalaman kami dengan komunitas TI kota kami.  Saya berbicara tentang memonitor aplikasi web.  Materi itu dimaksudkan untuk tingkat junior atau menengah, yang tidak membangun proses ini dari awal. </p><br><p><img src="https://habrastorage.org/webt/uj/x8/ej/ujx8ej4lg5vvhtvxczpnxnq4xkm.jpeg" alt="gambar"></p><br><p> Landasan yang mendasari sistem pemantauan adalah solusi untuk masalah bisnis.  Pemantauan demi pemantauan tidak menarik bagi siapa pun.  Apa yang diinginkan bisnis?  Sehingga semuanya bekerja dengan cepat dan tanpa kesalahan.  Bisnis menginginkan proaktif, sehingga kami sendiri mengidentifikasi masalah dalam layanan dan menghilangkannya secepat mungkin.  Ini, sebenarnya, adalah tugas yang telah saya selesaikan sepanjang tahun lalu pada proyek salah satu pelanggan kami. </p><a name="habracut"></a><br><h2 id="o-proekte">  Tentang proyek </h2><br><p>  Proyek ini adalah salah satu program loyalitas terbesar di negara ini.  Kami membantu pengecer meningkatkan frekuensi penjualan mereka melalui berbagai alat pemasaran seperti kartu bonus.  Secara total, proyek ini mencakup 14 aplikasi yang berjalan di sepuluh server. </p><br><p>  Dalam proses melakukan wawancara, saya telah berulang kali memperhatikan bahwa admin tidak selalu yang tepat untuk memonitor aplikasi web: sejauh ini, banyak yang berkutat pada metrik sistem operasi, dan kadang-kadang memantau layanan. </p><br><p>  Dalam kasus saya, Icinga adalah dasar dari sistem pemantauan pelanggan sebelumnya.  Dia tidak memecahkan masalah di atas.  Seringkali klien sendiri memberi tahu kami tentang masalah dan setidaknya kami tidak punya cukup data untuk sampai ke dasar alasannya. </p><br><p>  Selain itu, ada pemahaman yang jelas tentang kesia-siaan pengembangan selanjutnya.  Saya pikir mereka yang akrab dengan Icinga akan mengerti saya.  Jadi, kami memutuskan untuk sepenuhnya mendesain ulang sistem pemantauan untuk aplikasi web pada proyek. </p><br><h2 id="prometheus">  Prometheus </h2><br><p>  Kami memilih Prometheus berdasarkan tiga indikator utama: </p><br><ol><li>  Sejumlah besar metrik yang tersedia.  Dalam kasus kami, ada 60 ribu dari mereka.  Tentu saja, perlu dicatat bahwa sebagian besar dari mereka tidak kita gunakan (mungkin sekitar 95%).  Di sisi lain, semuanya relatif murah.  Bagi kami, ini adalah ekstrim lain dibandingkan dengan Icinga yang sebelumnya digunakan.  Di dalamnya, menambahkan metrik sangat menyusahkan: yang tersedia mahal (lihat saja kode sumber plugin apa pun).  Setiap plug-in adalah skrip Bash atau Python, yang peluncurannya tidak murah dalam hal sumber daya yang dikonsumsi. </li><li>  Sistem ini mengkonsumsi sumber daya yang relatif sedikit.  Semua metrik kami memiliki 600 MB RAM, 15% dari satu inti dan beberapa lusin IOPS.  Tentu saja, Anda harus menjalankan pengekspor metrik, tetapi semuanya ditulis dalam Go dan juga tidak berbeda dalam kerakusan.  Saya tidak berpikir bahwa dalam kenyataan modern ini adalah masalah. </li><li>  Itu memungkinkan untuk beralih ke Kubernetes.  Mengingat rencana pelanggan, pilihannya jelas. </li></ol><br><h2 id="elk">  RUSA </h2><br><p>  Sebelumnya, kami tidak mengumpulkan atau memproses log.  Kekurangannya jelas bagi semua orang.  Kami memilih ELK, karena kami sudah memiliki pengalaman dengan sistem ini.  Kami hanya menyimpan log aplikasi di sana.  Kriteria pemilihan utama adalah pencarian teks lengkap dan kecepatannya. </p><br><h2 id="slickhouse">  Clickhouse </h2><br><p>  Awalnya, pilihan jatuh pada InfluxDB.  Kami menyadari kebutuhan untuk mengumpulkan log Nginx, statistik dari pg_stat_statements, dan menyimpan data historis Prometheus.  Kami tidak suka Influx, karena secara berkala mulai mengkonsumsi banyak memori dan jatuh.  Selain itu, saya ingin mengelompokkan permintaan dengan remote_addr, dan mengelompokkan dalam DBMS ini hanya dengan tag.  Tag jalan (memori), jumlahnya terbatas dengan syarat. </p><br><p>  Kami memulai pencarian lagi.  Kami membutuhkan basis analitik dengan konsumsi sumber daya minimal, lebih disukai dengan kompresi data pada disk. </p><br><p>  Clickhouse memenuhi semua kriteria ini, dan kami tidak pernah menyesali pilihannya.  Kami tidak menulis jumlah data yang luar biasa ke dalamnya (jumlah sisipan hanya sekitar lima ribu per menit). </p><br><h2 id="newrelic">  NewRelic </h2><br><p>  NewRelic secara historis bersama kami karena itu adalah pilihan pelanggan.  Kami menggunakannya sebagai APM. </p><br><h2 id="zabbix">  Zabbix </h2><br><p>  Kami menggunakan Zabbix secara eksklusif untuk memantau Black Box dari berbagai API. </p><br><h2 id="opredelenie-podhoda-k-monitoringu">  Mendefinisikan pendekatan pemantauan </h2><br><p>  Kami ingin menguraikan tugas dan dengan demikian mensistematisasikan pendekatan pemantauan. </p><br><p>  Untuk melakukan ini, saya membagi sistem kami ke level berikut: </p><br><ul><li>  Perangkat Keras dan VMS; </li><li>  sistem operasi </li><li>  layanan sistem, tumpukan perangkat lunak; </li><li>  aplikasi </li><li>  logika bisnis. </li></ul><br><p>  Apa yang membuat pendekatan ini nyaman: </p><br><ul><li>  kami tahu siapa yang bertanggung jawab atas pekerjaan masing-masing level dan, berdasarkan ini, kami dapat mengirimkan peringatan; </li><li>  kita dapat menggunakan struktur ketika menekan peringatan - akan aneh untuk mengirimkan peringatan tentang tidak dapat diaksesnya database ketika mesin virtual umumnya tidak dapat diakses. </li></ul><br><p>  Karena tugas kita adalah untuk mendeteksi penyimpangan dalam sistem, kita harus pada setiap level memilih serangkaian metrik tertentu yang harus diperhatikan ketika menulis aturan peringatan.  Selanjutnya, kita akan melewati level â€œVMSâ€, â€œSistem Operasiâ€ dan â€œLayanan Sistem, tumpukan perangkat lunakâ€. </p><br><h2 id="virtualnye-mashiny">  Mesin virtual </h2><br><p>  Hosting memberi kita prosesor, disk, memori, dan jaringan.  Dan dengan dua yang pertama kami punya masalah.  Jadi metrik: </p><br><p>  Waktu yang dicuri CPU - saat Anda membeli mesin virtual di Amazon (t2.micro, misalnya), Anda harus memahami bahwa Anda tidak mengalokasikan seluruh inti prosesor, tetapi hanya kuota waktunya.  Dan ketika Anda mengurasnya, prosesor akan diambil dari Anda. </p><br><p>  Metrik ini memungkinkan Anda untuk melacak momen seperti itu dan membuat keputusan.  Sebagai contoh, apakah perlu untuk mengambil tarif lebih gemuk atau mendistribusikan pemrosesan tugas latar belakang dan permintaan di API ke server yang berbeda. </p><br><p>  IOPS + CPU waktu iowait - untuk beberapa alasan, banyak perusahaan cloud hosting berdosa dengan tidak memberikan IOPS.  Selain itu, jadwal dengan IOPS rendah bukanlah argumen untuk mereka.  Karena itu, ada baiknya mengumpulkan CPU iowait.  Dengan pasangan grafik ini - dengan IOPS rendah dan harapan I / O tinggi - Anda sudah dapat berbicara dengan hosting dan menyelesaikan masalah. </p><br><h2 id="operacionnaya-sistema">  Sistem operasi </h2><br><p>  Metrik sistem operasi: </p><br><ul><li>  jumlah memori yang tersedia dalam%; </li><li>  aktivitas menggunakan swap: vmstat swapin, swapout; </li><li>  jumlah inode yang tersedia dan ruang kosong pada sistem file dalam% </li><li>  beban rata-rata; </li><li>  jumlah koneksi dalam dua kondisi; </li><li>  tabel conntrack kepenuhan; </li><li>  kinerja jaringan dapat dimonitor menggunakan utilitas ss, paket iproute2 - dapatkan indikator RTT-koneksi dari outputnya dan kelompokkan dengan dest-port. </li></ul><br><p>  Juga di tingkat sistem operasi, kami memiliki entitas seperti proses.  Penting untuk menyoroti dalam sistem serangkaian proses yang memainkan peran penting dalam pekerjaannya.  Jika, misalnya, Anda memiliki beberapa pgpool, maka Anda perlu mengumpulkan informasi untuk masing-masingnya. </p><br><p>  Rangkaian metrik adalah sebagai berikut: </p><br><ul><li>  CPU </li><li>  memori terutama penduduk; </li><li>  IO - lebih disukai di IOPS; </li><li>  FileFd - buka dan batasi; </li><li>  kegagalan halaman yang signifikan - sehingga Anda dapat memahami proses apa yang ditukar. </li></ul><br><p>  Semua pemantauan dikerahkan di Docker, kami menggunakan advisor untuk mengumpulkan data metrik.  Di mesin lain, kami menggunakan proses-eksportir. </p><br><h2 id="sistemnye-servisy-stek-po">  Layanan Sistem, Stack Perangkat Lunak </h2><br><p>  Setiap aplikasi memiliki spesifiknya sendiri, dan sulit untuk membedakan beberapa set metrik. </p><br><p>  Set universal adalah: </p><br><ul><li>  tingkat permintaan; </li><li>  jumlah kesalahan; </li><li>  latensi </li><li>  saturasi. </li></ul><br><p>  Contoh pemantauan yang paling mencolok di level ini adalah Nginx dan PostgreSQL. </p><br><p>  Layanan yang paling banyak dimuat di sistem kami adalah database.  Kami dulu sering mengalami masalah untuk mengetahui apa yang dilakukan database. </p><br><p>  Kami melihat beban tinggi pada disk, tetapi slogan tidak benar-benar menunjukkan apa-apa.  Kami memecahkan masalah ini dengan pg_stat_statements, tampilan yang mengumpulkan statistik berdasarkan permintaan. </p><br><p>  Ini semua yang dibutuhkan admin. </p><br><p>  Kami memplot aktivitas permintaan baca dan tulis: </p><br><img src="https://habrastorage.org/webt/6r/fm/rp/6rfmrp9k711d0azcv7thr3bfapu.jpeg"><br><img src="https://habrastorage.org/webt/j7/dn/ki/j7dnki6of_-n3l33xe5mz9xapkk.jpeg"><br><p>  Semuanya sederhana dan jelas, setiap permintaan memiliki warna tersendiri. </p><br><p>  Contoh yang sama mencoloknya adalah Nginx log.  Tidak mengherankan, sedikit yang mem-parsing mereka atau menyebutkannya dalam daftar yang diperlukan.  Format standar tidak terlalu informatif dan perlu diperluas. </p><br><p>  Secara pribadi, saya menambahkan request_time, upstream_response_time, body_bytes_sent, request_length, request_id. Kami memplot waktu respons dan jumlah kesalahan: </p><br><img src="https://habrastorage.org/webt/3l/wp/cw/3lwpcwwdctrsk7mgnexjmxstsxq.jpeg"><br><img src="https://habrastorage.org/webt/zk/w9/ak/zkw9akpuwajs85xktgcm6wtar1m.jpeg"><br><p>  Kami memplot waktu respons dan jumlah kesalahan.  Apakah kamu ingat?  Apakah saya berbicara tentang tujuan bisnis?  Untuk dengan cepat dan tanpa kesalahan?  Kami telah menutup masalah ini dengan dua grafik.  Dan pada mereka Anda sudah dapat memanggil administrator tugas. </p><br><p>  Tapi masalah lain tetap ada - untuk memastikan penghapusan cepat penyebab insiden tersebut. </p><br><h2 id="ustranenie-incidentov">  Manajemen insiden </h2><br><p>  Seluruh proses mulai dari mengidentifikasi hingga menyelesaikan masalah dapat dibagi menjadi beberapa langkah: </p><br><ul><li>  identifikasi masalah; </li><li>  pemberitahuan dari administrator yang bertugas; </li><li>  reaksi atas insiden tersebut; </li><li>  penghapusan penyebabnya. </li></ul><br><p>  Adalah penting bahwa kita melakukan ini secepat mungkin.  Dan jika kita tidak dapat memenangkan banyak waktu pada tahap mengidentifikasi masalah dan mengirim pemberitahuan - mereka akan pergi selama dua menit dalam hal apa pun, maka yang berikutnya hanyalah bidang yang belum tersentuh untuk peningkatan. </p><br><p>  Bayangkan saja telepon berdering saat bertugas.  Apa yang akan dia lakukan?  Cari jawaban atas pertanyaan - apa yang rusak, di mana rusak, bagaimana bereaksi?  Inilah cara kami menjawab pertanyaan-pertanyaan ini: </p><br><img src="https://habrastorage.org/webt/p_/kj/wj/p_kjwjrqkewlj50zmcy1hz9cuju.jpeg"><br><p>  Kami cukup memasukkan semua informasi ini dalam teks notifikasi, memberikan tautan ke halaman wiki yang menjelaskan bagaimana menanggapi masalah ini, bagaimana menyelesaikannya dan meningkatkannya. </p><br><p>  Saya masih belum mengatakan apa-apa tentang lapisan aplikasi dan logika bisnis.  Sayangnya, pengumpulan metrik belum diterapkan di aplikasi kami.  Satu-satunya sumber setidaknya beberapa informasi dari level ini adalah log. </p><br><p>  Beberapa poin. </p><br><p>  Pertama, tulis log terstruktur.  Tidak perlu memasukkan konteks dalam isi pesan.  Ini membuatnya sulit untuk dikelompokkan dan dianalisis.  Logstash membutuhkan waktu lama untuk menormalkan semua ini. </p><br><p>  Kedua, gunakan tingkat keparahan dengan benar.  Setiap bahasa memiliki standarnya sendiri.  Secara pribadi, saya membedakan empat level: </p><br><ol><li>  tidak ada kesalahan; </li><li>  kesalahan sisi klien; </li><li>  kesalahan ada di pihak kita, kita tidak kehilangan uang, kita tidak menanggung risiko; </li><li>  kesalahan ada di pihak kita, kita kehilangan uang. </li></ol><br><p>  Saya meringkas.  Penting untuk mencoba membangun pemantauan secara tepat dari logika bisnis.  Cobalah untuk memantau aplikasi itu sendiri dan beroperasi dengan metrik seperti jumlah penjualan, jumlah pendaftaran pengguna baru, jumlah pengguna yang saat ini aktif, dan sebagainya. </p><br><p>  Jika seluruh bisnis Anda adalah satu tombol di browser Anda, Anda perlu memantau apakah itu diperas dan berfungsi dengan baik.  Segala sesuatu yang lain tidak penting. </p><br><p>  Jika Anda tidak memiliki ini, Anda dapat mencoba untuk mengejarnya di log aplikasi, log Nginx, dan sebagainya, seperti yang kami lakukan.  Anda harus sedekat mungkin dengan aplikasi. </p><br><p>  Metrik sistem operasi tentu saja penting, tetapi mereka tidak menarik untuk bisnis, kami tidak dibayar untuk itu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449352/">https://habr.com/ru/post/id449352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449342/index.html">Peramalan acak berdasarkan tanda tangan digital blockchain</a></li>
<li><a href="../id449344/index.html">Kodim - pizza</a></li>
<li><a href="../id449346/index.html">MODX Digest # 4 (8 - 22 April 2019)</a></li>
<li><a href="../id449348/index.html">Buildroot - bagian 2. Membuat konfigurasi papan Anda; penerapan skrip eksternal tree, rootfs-overlay, post-build</a></li>
<li><a href="../id449350/index.html">Keybase dan TOFU sejati</a></li>
<li><a href="../id449356/index.html">Proses bisnis. Ekstraksi model BPMN dari dokumen. Bagian 1</a></li>
<li><a href="../id449358/index.html">Perbatasan Baru dalam Fisika</a></li>
<li><a href="../id449360/index.html">Microsoft telah mengadaptasi realitas virtual untuk orang-orang tunanetra</a></li>
<li><a href="../id449362/index.html">Healthcare UPS: Delta Health Health Experience</a></li>
<li><a href="../id449364/index.html">Latar Belakang: apa itu Pengiriman Kontinu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>