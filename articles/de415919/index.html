<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤐 😼 🌡️ Refactoring eines Programms auf Go: 23-fache Beschleunigung 👼🏼 🤙🏻 🚕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Marco, ich arbeite für Badoo in der Plattformabteilung. Wir haben viele Dinge in Go geschrieben, und diese sind oft entscheidend ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refactoring eines Programms auf Go: 23-fache Beschleunigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>Hallo!</i>  <i>Mein Name ist Marco, ich arbeite für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo</a> in der Plattformabteilung.</i>  <i>Wir haben viele Dinge in Go geschrieben, und diese sind oft entscheidend für die Systemleistung.</i>  <i>Deshalb biete ich Ihnen heute eine Übersetzung eines Artikels an, der mir sehr gut gefallen hat und der Ihnen sicher sehr nützlich sein wird.</i>  <i>Der Autor zeigt Schritt für Schritt, wie er mit Leistungsproblemen umgegangen ist und wie sie diese gelöst haben.</i>  <i>Einschließlich Sie werden mit den umfangreichen Werkzeugen vertraut gemacht, die in Go für solche Arbeiten verfügbar sind.</i>  <i>Viel Spaß beim Lesen!</i> <br><br>  Vor einigen Wochen habe ich den Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Guter Code gegen schlechten Code in Go</a> “ gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> in dem der Autor Schritt für Schritt demonstriert, wie eine echte Anwendung umgestaltet wird, die echte Geschäftsprobleme löst.  Es konzentriert sich darauf, „schlechten Code“ in „guten Code“ umzuwandeln: idiomatischer, verständlicher, unter vollständiger Nutzung der Besonderheiten von Go.  Der Autor wies jedoch auch auf die Bedeutung der Leistung der betreffenden Anwendung hin.  Die Neugier stieg in mich auf: Versuchen wir es zu beschleunigen! <br><a name="habracut"></a><br>  Das Programm liest grob gesagt die Eingabedatei, analysiert sie Zeile für Zeile und füllt die Objekte im Speicher. <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br>  Der Autor hat nicht nur den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode auf GitHub</a> gepostet, sondern auch einen Benchmark geschrieben.  Das ist eine großartige Idee.  Tatsächlich lud der Autor alle ein, mit dem Code herumzuspielen und ihn zu beschleunigen.  Verwenden Sie den folgenden Befehl, um die Ergebnisse des Autors zu reproduzieren: <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>μs pro Anruf (weniger - besser)</i> <br><br>  Es stellt sich heraus, dass auf meinem Computer „guter Code“ 16% schneller ist.  Können wir es beschleunigen? <br><br>  Nach meiner Erfahrung besteht ein Zusammenhang zwischen Codequalität und Leistung.  Wenn Sie den Code erfolgreich überarbeitet, sauberer und weniger verbunden gemacht haben, haben Sie ihn höchstwahrscheinlich schneller gemacht, weil er weniger überladen war (und es gibt keine unnötigen Anweisungen mehr, die zuvor vergeblich ausgeführt wurden).  Vielleicht haben Sie während des Refactorings einige Optimierungsmöglichkeiten bemerkt, oder jetzt haben Sie nur noch die Möglichkeit, diese zu nutzen.  Wenn Sie den Code jedoch noch produktiver gestalten möchten, müssen Sie sich wahrscheinlich von der Einfachheit lösen und verschiedene Hacks hinzufügen.  Sie sparen wirklich Millisekunden, aber die Qualität des Codes wird darunter leiden: Es wird schwieriger, ihn zu lesen und darüber zu sprechen, er wird fragiler und flexibler. <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>Wir besteigen den Berg der Einfachheit und steigen dann von ihm ab</i> <br><br>  Dies ist ein Kompromiss: Wie weit sind Sie bereit zu gehen? <br><br>  Um die Arbeit an der Beschleunigung richtig zu priorisieren, besteht die optimale Strategie darin, Engpässe zu finden und sich auf diese zu konzentrieren.  Verwenden Sie dazu die Profiling-Tools.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pprof</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trace</a> sind deine Freunde: <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>Ein ziemlich großes Diagramm der CPU-Auslastung (klicken für SVG)</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>Regenbogenverfolgung: viele kleine Aufgaben (zum Öffnen klicken, funktioniert nur in Google Chrome)</i> <br><br>  Die Ablaufverfolgung bestätigt, dass alle Prozessorkerne ausgelastet sind (Zeilen unter 0, 1 usw.), und dies ist auf den ersten Blick gut.  Sie zeigt aber auch Tausende kleiner Farbberechnungen und mehrere leere Bereiche, in denen die Kerne im Leerlauf waren.  Vergrößern wir: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>"Fenster" in 3 ms (zum Öffnen klicken, funktioniert nur in Google Chrome)</i> <br><br>  Jeder Kern ist für einige Zeit im Leerlauf und „springt“ auch ständig zwischen Mikroaufgaben.  Es scheint, dass die Granularität dieser Aufgaben nicht sehr optimal ist, was aufgrund der Synchronisation zu einer großen Anzahl von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontextwechseln</a> und zu Konkurrenz führt. <br><br>  Mal sehen, was der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flugdetektor</a> uns sagt.  Gibt es Probleme beim synchronen Zugriff auf Daten (wenn es welche gibt, haben wir viel größere Probleme als die Leistung)? <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br>  Großartig!  Alles ist richtig.  Keine Flüge gefunden.  Testfunktionen und Benchmark-Funktionen sind unterschiedliche Funktionen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Dokumentation</a> ), aber hier wird dieselbe <i>ParseAdexpMessage-</i> Funktion <i>aufgerufen.</i> Was wir also durch Tests auf Datenflüge überprüft haben, ist in Ordnung. <br><br>  Das Wettbewerbsmodell in der „guten“ Version besteht darin, jede Zeile aus der Eingabedatei in einer separaten Goroutine zu verarbeiten (um alle Kerne zu verwenden).  Die Intuition des Autors hat hier gut funktioniert, da Goroutinen für einfache und kostengünstige Funktionen bekannt sind.  Aber wie viel gewinnen wir durch parallele Ausführung?  Vergleichen wir mit demselben Code, verwenden jedoch keine Goroutinen (entfernen Sie einfach das Wort go, das vor dem Funktionsaufruf steht): <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br>  Hoppla, es scheint, dass der Code ohne Parallelität schneller geworden ist.  Dies bedeutet, dass der Overhead (ungleich Null) für das Starten von Goroutinen die Zeit überschreitet, die wir durch die gleichzeitige Verwendung mehrerer Kerne gewonnen haben.  Der nächste natürliche Schritt sollte darin bestehen, den Overhead (ungleich Null) zu entfernen, um Kanäle zum Senden der Ergebnisse zu verwenden.  Ersetzen wir es durch ein reguläres Slice: <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>μs pro Anruf (weniger ist besser)</i> <br><br>  Wir haben im Vergleich zur „guten“ Version eine Beschleunigung von ca. 40% erzielt, wodurch der Code vereinfacht und die Konkurrenz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diff</a> ) entfernt wurde. <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>Mit einer Goroutine funktioniert immer nur ein Kern</i> <br><br>  Schauen wir uns nun die Hot-Funktionen im pprof-Diagramm an: <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>Auf der Suche nach Engpässen</i> <br><br>  Der Benchmark der aktuellen Version (sequentielle Operation, Slices) verbringt 86% der Zeit damit, Nachrichten zu analysieren, und dies ist normal.  Wir werden jedoch schnell feststellen, dass 43% der Zeit für die Verwendung regulärer Ausdrücke und der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(* Regexp) .FindAll aufgewendet wird</a> . <br><br>  Trotz der Tatsache, dass reguläre Ausdrücke eine bequeme und flexible Möglichkeit sind, Daten aus einfachem Text abzurufen, weisen sie Nachteile auf, einschließlich der Verwendung einer großen Anzahl von Ressourcen, eines Prozessors und eines Speichers.  Sie sind ein mächtiges Werkzeug, aber oft ist ihre Verwendung unnötig. <br><br>  In unserem Programm eine Vorlage <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br>  Es ist hauptsächlich dazu gedacht, Befehle hervorzuheben, die mit einem Bindestrich (-) beginnen, und es können mehrere in der Zeile sein.  Dies kann, nachdem ein kleiner Code gezogen wurde, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.Split erfolgen</a> .  Passen wir den Code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> ) an, um die regulären Ausdrücke in Split zu ändern: <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>μs pro Anruf (weniger</i> ist <i>besser)</i> <br><br>  Wow!  40% produktiverer Code!  Das Diagramm zum CPU-Verbrauch sieht nun folgendermaßen aus: <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br>  Keine Zeitverschwendung mehr für reguläre Ausdrücke.  Ein wesentlicher Teil davon (40%) entfällt auf die Speicherzuweisung von fünf verschiedenen Funktionen.  Interessanterweise werden jetzt 21% der Zeit für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytes</a> aufgewendet. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trim-</a> Funktion: <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>Diese Funktion fasziniert mich.</i>  <i>Was können wir hier machen?</i> <i><br><br></i>  <i>bytes.Trim</i> erwartet eine Zeichenfolge mit Zeichen, die als Argument "abgeschnitten" wird. Als Zeichenfolge übergeben wir jedoch eine Zeichenfolge mit nur einem Zeichen - einem Leerzeichen.  Dies ist nur ein Beispiel dafür, wie Sie aufgrund der Komplexität eine Beschleunigung erzielen können: Erstellen wir unsere Trimmfunktion anstelle der Standardfunktion.  Unsere benutzerdefinierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trimmfunktion</a> funktioniert mit einem einzelnen Byte anstelle einer ganzen Zeile: <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>μs pro Anruf (weniger ist besser)</i> <br><br>  Hurra, weitere 20% abgeschnitten!  Die aktuelle Version ist viermal schneller als die ursprüngliche "schlechte" und verwendet gleichzeitig nur einen Kern.  Nicht schlecht! <br><br><hr><br><br>  Früher haben wir die Wettbewerbsfähigkeit auf der Ebene der Linienverarbeitung aufgegeben, aber ich behaupte, dass eine Beschleunigung durch die Nutzung der Wettbewerbsfähigkeit auf einer höheren Ebene erreicht werden kann.  Beispielsweise ist die Verarbeitung von 6.000 Dateien (6.000 Nachrichten) auf meinem Computer schneller, wenn jede Datei in einer eigenen Goroutine verarbeitet wird: <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>μs pro Anruf (weniger ist besser; lila ist eine wettbewerbsfähige Lösung)</i> <br><br>  Die Verstärkung beträgt 66% (dh dreimal Beschleunigung).  Das ist gut, aber nicht sehr, wenn man bedenkt, dass alle 12 Prozessorkerne, die ich habe, verwendet werden.  Dies kann bedeuten, dass der neue optimierte Code, der die gesamte Datei verarbeitet, immer noch eine „kleine Aufgabe“ ist, für die der Aufwand für die Erstellung von Goroutinen und die Kosten für die Synchronisierung nicht unerheblich sind.  Interessanterweise hat die Erhöhung der Anzahl der Nachrichten von 6.000 auf 120.000 keine Auswirkungen auf die Single-Thread-Version und verringert die Leistung bei der Version "Eine Goroutine pro Nachricht".  Dies liegt daran, dass trotz der Tatsache, dass das Erstellen einer so großen Anzahl von Goroutinen möglich und manchmal nützlich ist, der Laufzeit- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sheduler-Bereich</a> einen eigenen Overhead <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verursacht</a> . <br><br>  Wir können die Ausführungszeit weiter reduzieren (nicht um das 12-fache, aber immer noch), indem wir nur wenige Mitarbeiter erstellen.  Zum Beispiel 12 langlebige Goroutinen, von denen jede einen Teil der Nachrichten verarbeitet: <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>μs pro Anruf (weniger ist besser; lila ist eine wettbewerbsfähige Lösung)</i> <br><br>  Diese Option reduziert die Ausführungszeit um 79% im Vergleich zur Single-Threaded-Version.  Beachten Sie, dass diese Strategie nur dann sinnvoll ist, wenn Sie viele Dateien verarbeiten müssen. <br><br>  Die optimale Verwendung aller Prozessorkerne besteht darin, mehrere Goroutinen zu verwenden, von denen jede eine erhebliche Datenmenge ohne Interaktion oder Synchronisation verarbeitet, bevor die Arbeit abgeschlossen ist. <br><br>  Normalerweise nehmen sie so viele Prozesse (Goroutine) wie die Kerne des Prozessors, aber dies ist nicht immer die beste Option: Alles hängt von der spezifischen Aufgabe ab.  Wenn Sie beispielsweise etwas aus dem Dateisystem lesen oder viele Netzwerkanrufe tätigen, sollten Sie mehr Goroutinen als Ihre Kerne verwenden, um mehr Leistung zu erzielen. <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>μs pro Anruf (weniger ist besser; lila ist eine wettbewerbsfähige Lösung)</i> <br><br>  Wir sind an einem Punkt angelangt, an dem es schwierig ist, die Parsing-Leistung mit einigen lokalisierten Änderungen zu steigern.  Die Laufzeit wird von der Zeit für die Speicherzuweisung und die Speicherbereinigung dominiert.  Dies klingt logisch, da die Speicherverwaltungsfunktionen ziemlich langsam sind.  Die weitere Optimierung der mit Zuweisungen verbundenen Prozesse bleibt eine Hausaufgabe für die Leser. <br><br><hr><br><br>  Die Verwendung anderer Algorithmen kann ebenfalls zu einem großen Leistungsgewinn führen. <br><br>  Hier wurde ich von einem Vortrag von Lexical Scanning in Go von Rob Pike inspiriert, <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  um einen benutzerdefinierten Lexer ( <a href="">Quelle</a> ) und einen benutzerdefinierten Parser ( <a href="">Quelle</a> ) zu erstellen.  Dieser Code ist noch nicht fertig (ich verarbeite keine Eckfälle), er ist weniger klar als der ursprüngliche Algorithmus und manchmal ist es schwierig, die richtige Fehlerbehandlung zu schreiben.  Aber es ist klein und 30% schneller als die am besten optimierte Version. <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>μs pro Anruf (weniger ist besser; lila ist eine wettbewerbsfähige Lösung)</i> <br><br>  Ja  Als Ergebnis haben wir eine 23-fache Beschleunigung im Vergleich zum Quellcode erhalten. <br><br><hr><br><br>  Das ist alles für heute.  Ich hoffe du hast dieses Abenteuer genossen.  Hier einige Anmerkungen und Schlussfolgerungen: <br><br><ul><li>  Die Produktivität kann auf verschiedenen Abstraktionsebenen unter Verwendung verschiedener Techniken verbessert werden, und der Gewinn wird häufig erhöht. <br></li><li>  Die Optimierung muss mit Abstraktionen auf hoher Ebene beginnen: Datenstrukturen, Algorithmen, die korrekte Entkopplung von Modulen.  Nehmen Sie später Abstraktionen auf niedriger Ebene auf: E / A, Stapelverarbeitung, Wettbewerbsfähigkeit, Verwendung der Standardbibliothek, Arbeiten mit Speicher, Zuweisen von Speicher. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Big O-</a> Analyse ist sehr wichtig, aber normalerweise nicht das am besten geeignete Werkzeug, um ein Programm zu beschleunigen. <br></li><li>  Benchmarks zu schreiben ist harte Arbeit.  Verwenden Sie Profilerstellung und Benchmarks, um Engpässe zu finden und ein umfassenderes Verständnis der Vorgänge im Programm zu erlangen.  Beachten Sie, dass die Benchmark-Ergebnisse nicht mit denen Ihrer Benutzer in der Praxis übereinstimmen. <br></li><li>  Glücklicherweise macht eine Reihe von Tools ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pprof</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Race Detector</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cover</a> ) die Erforschung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeleistung</a> erschwinglich und interessant. <br></li><li>  Gute, relevante Tests zu schreiben ist keine triviale Aufgabe.  Aber sie sind verdammt wichtig, nicht in die Wildnis zu gehen.  Sie können umgestalten, indem Sie sicherstellen, dass der Code korrekt bleibt. <br></li><li>  Halten Sie an und fragen Sie sich, wie schnell "schnell genug" ist.  Verschwenden Sie keine Zeit damit, ein einmaliges Skript zu optimieren.  Vergessen Sie nicht, dass die Optimierung nicht kostenlos ist: Zeit, Komplexität, Fehler und technische Schulden des Ingenieurs. <br></li><li>  Überlegen Sie zweimal, bevor Sie den Code komplizieren. <br></li><li>  Algorithmen mit der Komplexität <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ω</a> (n²) und höher sind normalerweise zu teuer. <br></li><li>  Algorithmen mit der Komplexität O (n) oder O (n log n) und darunter sind normalerweise in Ordnung. <br></li><li>  Verschiedene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versteckte Faktoren</a> können nicht ignoriert werden.  Zum Beispiel wurden alle Verbesserungen in dem Artikel durch Reduzieren dieser Faktoren und nicht durch Ändern der Komplexitätsklasse des Algorithmus erzielt. <br></li><li>  E / A ist häufig ein Engpass: Netzwerkabfragen, Datenbankabfragen, Dateisystem. <br></li><li>  Reguläre Ausdrücke sind oft zu teuer und unnötig. <br></li><li>  Speicherzuordnungen sind teurer als Berechnungen. <br></li><li>  Ein auf dem Stapel zugewiesenes Objekt ist billiger als ein auf dem Heap zugewiesenes Objekt. <br></li><li>  Slices sind als Alternative zu teuren Speicherbewegungen nützlich. <br></li><li>  Strings sind schreibgeschützt (einschließlich Reslicing).  In allen anderen Fällen sind [] Bytes effektiver. <br></li><li>  Es ist sehr wichtig, dass sich die von Ihnen verarbeiteten Daten in der Nähe befinden (Prozessor-Caches). <br></li><li>  Wettbewerbsfähigkeit und Parallelität sind sehr nützlich, aber schwer vorzubereiten. <br></li><li>  Wenn Sie tief und tief graben, denken Sie an den „Glasboden“, den Sie nicht in Go einbrechen möchten.  Wenn Ihre Hände nach Assembler-Anweisungen oder SIMD-Anweisungen suchen, müssen Sie Go möglicherweise nur für das Prototyping verwenden und dann in eine niedrigere Sprache wechseln, um die vollständige Kontrolle über die Hardware und jede Nanosekunde zu erhalten! <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415919/">https://habr.com/ru/post/de415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415909/index.html">Browserübergreifende Web-Erweiterung für benutzerdefinierte Skripte Teil 2</a></li>
<li><a href="../de415911/index.html">Zugriff auf einen nicht vorhandenen Array-Index</a></li>
<li><a href="../de415913/index.html">Wärmen Sie sich für diejenigen auf, die in Python können</a></li>
<li><a href="../de415915/index.html">Harte Praxis: Welche Art von WLAN haben wir für Hoteliers?</a></li>
<li><a href="../de415917/index.html">"Frühlingsgesetz" trat in Kraft: Was kommt als nächstes?</a></li>
<li><a href="../de415923/index.html">Ist die Einheit langsam? Achtung LINQ</a></li>
<li><a href="../de415925/index.html">MasterCard patentierte anonyme Blockchain-Technologie</a></li>
<li><a href="../de415927/index.html">Industrielampe Breeze 50</a></li>
<li><a href="../de415929/index.html">Optimierung der Architektur der künstlichen Intelligenz: Das Rennen beginnt</a></li>
<li><a href="../de415933/index.html">So erstellen Sie eine IIoT-Architektur zum Selbermachen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>