<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ê üòº üå°Ô∏è Refactoring eines Programms auf Go: 23-fache Beschleunigung üëºüèº ü§ôüèª üöï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Marco, ich arbeite f√ºr Badoo in der Plattformabteilung. Wir haben viele Dinge in Go geschrieben, und diese sind oft entscheidend ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refactoring eines Programms auf Go: 23-fache Beschleunigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>Hallo!</i>  <i>Mein Name ist Marco, ich arbeite f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo</a> in der Plattformabteilung.</i>  <i>Wir haben viele Dinge in Go geschrieben, und diese sind oft entscheidend f√ºr die Systemleistung.</i>  <i>Deshalb biete ich Ihnen heute eine √úbersetzung eines Artikels an, der mir sehr gut gefallen hat und der Ihnen sicher sehr n√ºtzlich sein wird.</i>  <i>Der Autor zeigt Schritt f√ºr Schritt, wie er mit Leistungsproblemen umgegangen ist und wie sie diese gel√∂st haben.</i>  <i>Einschlie√ülich Sie werden mit den umfangreichen Werkzeugen vertraut gemacht, die in Go f√ºr solche Arbeiten verf√ºgbar sind.</i>  <i>Viel Spa√ü beim Lesen!</i> <br><br>  Vor einigen Wochen habe ich den Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Guter Code gegen schlechten Code in Go</a> ‚Äú gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> in dem der Autor Schritt f√ºr Schritt demonstriert, wie eine echte Anwendung umgestaltet wird, die echte Gesch√§ftsprobleme l√∂st.  Es konzentriert sich darauf, ‚Äûschlechten Code‚Äú in ‚Äûguten Code‚Äú umzuwandeln: idiomatischer, verst√§ndlicher, unter vollst√§ndiger Nutzung der Besonderheiten von Go.  Der Autor wies jedoch auch auf die Bedeutung der Leistung der betreffenden Anwendung hin.  Die Neugier stieg in mich auf: Versuchen wir es zu beschleunigen! <br><a name="habracut"></a><br>  Das Programm liest grob gesagt die Eingabedatei, analysiert sie Zeile f√ºr Zeile und f√ºllt die Objekte im Speicher. <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br>  Der Autor hat nicht nur den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode auf GitHub</a> gepostet, sondern auch einen Benchmark geschrieben.  Das ist eine gro√üartige Idee.  Tats√§chlich lud der Autor alle ein, mit dem Code herumzuspielen und ihn zu beschleunigen.  Verwenden Sie den folgenden Befehl, um die Ergebnisse des Autors zu reproduzieren: <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>Œºs pro Anruf (weniger - besser)</i> <br><br>  Es stellt sich heraus, dass auf meinem Computer ‚Äûguter Code‚Äú 16% schneller ist.  K√∂nnen wir es beschleunigen? <br><br>  Nach meiner Erfahrung besteht ein Zusammenhang zwischen Codequalit√§t und Leistung.  Wenn Sie den Code erfolgreich √ºberarbeitet, sauberer und weniger verbunden gemacht haben, haben Sie ihn h√∂chstwahrscheinlich schneller gemacht, weil er weniger √ºberladen war (und es gibt keine unn√∂tigen Anweisungen mehr, die zuvor vergeblich ausgef√ºhrt wurden).  Vielleicht haben Sie w√§hrend des Refactorings einige Optimierungsm√∂glichkeiten bemerkt, oder jetzt haben Sie nur noch die M√∂glichkeit, diese zu nutzen.  Wenn Sie den Code jedoch noch produktiver gestalten m√∂chten, m√ºssen Sie sich wahrscheinlich von der Einfachheit l√∂sen und verschiedene Hacks hinzuf√ºgen.  Sie sparen wirklich Millisekunden, aber die Qualit√§t des Codes wird darunter leiden: Es wird schwieriger, ihn zu lesen und dar√ºber zu sprechen, er wird fragiler und flexibler. <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>Wir besteigen den Berg der Einfachheit und steigen dann von ihm ab</i> <br><br>  Dies ist ein Kompromiss: Wie weit sind Sie bereit zu gehen? <br><br>  Um die Arbeit an der Beschleunigung richtig zu priorisieren, besteht die optimale Strategie darin, Engp√§sse zu finden und sich auf diese zu konzentrieren.  Verwenden Sie dazu die Profiling-Tools.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pprof</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trace</a> sind deine Freunde: <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>Ein ziemlich gro√ües Diagramm der CPU-Auslastung (klicken f√ºr SVG)</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>Regenbogenverfolgung: viele kleine Aufgaben (zum √ñffnen klicken, funktioniert nur in Google Chrome)</i> <br><br>  Die Ablaufverfolgung best√§tigt, dass alle Prozessorkerne ausgelastet sind (Zeilen unter 0, 1 usw.), und dies ist auf den ersten Blick gut.  Sie zeigt aber auch Tausende kleiner Farbberechnungen und mehrere leere Bereiche, in denen die Kerne im Leerlauf waren.  Vergr√∂√üern wir: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>"Fenster" in 3 ms (zum √ñffnen klicken, funktioniert nur in Google Chrome)</i> <br><br>  Jeder Kern ist f√ºr einige Zeit im Leerlauf und ‚Äûspringt‚Äú auch st√§ndig zwischen Mikroaufgaben.  Es scheint, dass die Granularit√§t dieser Aufgaben nicht sehr optimal ist, was aufgrund der Synchronisation zu einer gro√üen Anzahl von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontextwechseln</a> und zu Konkurrenz f√ºhrt. <br><br>  Mal sehen, was der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flugdetektor</a> uns sagt.  Gibt es Probleme beim synchronen Zugriff auf Daten (wenn es welche gibt, haben wir viel gr√∂√üere Probleme als die Leistung)? <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br>  Gro√üartig!  Alles ist richtig.  Keine Fl√ºge gefunden.  Testfunktionen und Benchmark-Funktionen sind unterschiedliche Funktionen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Dokumentation</a> ), aber hier wird dieselbe <i>ParseAdexpMessage-</i> Funktion <i>aufgerufen.</i> Was wir also durch Tests auf Datenfl√ºge √ºberpr√ºft haben, ist in Ordnung. <br><br>  Das Wettbewerbsmodell in der ‚Äûguten‚Äú Version besteht darin, jede Zeile aus der Eingabedatei in einer separaten Goroutine zu verarbeiten (um alle Kerne zu verwenden).  Die Intuition des Autors hat hier gut funktioniert, da Goroutinen f√ºr einfache und kosteng√ºnstige Funktionen bekannt sind.  Aber wie viel gewinnen wir durch parallele Ausf√ºhrung?  Vergleichen wir mit demselben Code, verwenden jedoch keine Goroutinen (entfernen Sie einfach das Wort go, das vor dem Funktionsaufruf steht): <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br>  Hoppla, es scheint, dass der Code ohne Parallelit√§t schneller geworden ist.  Dies bedeutet, dass der Overhead (ungleich Null) f√ºr das Starten von Goroutinen die Zeit √ºberschreitet, die wir durch die gleichzeitige Verwendung mehrerer Kerne gewonnen haben.  Der n√§chste nat√ºrliche Schritt sollte darin bestehen, den Overhead (ungleich Null) zu entfernen, um Kan√§le zum Senden der Ergebnisse zu verwenden.  Ersetzen wir es durch ein regul√§res Slice: <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>Œºs pro Anruf (weniger ist besser)</i> <br><br>  Wir haben im Vergleich zur ‚Äûguten‚Äú Version eine Beschleunigung von ca. 40% erzielt, wodurch der Code vereinfacht und die Konkurrenz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diff</a> ) entfernt wurde. <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>Mit einer Goroutine funktioniert immer nur ein Kern</i> <br><br>  Schauen wir uns nun die Hot-Funktionen im pprof-Diagramm an: <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>Auf der Suche nach Engp√§ssen</i> <br><br>  Der Benchmark der aktuellen Version (sequentielle Operation, Slices) verbringt 86% der Zeit damit, Nachrichten zu analysieren, und dies ist normal.  Wir werden jedoch schnell feststellen, dass 43% der Zeit f√ºr die Verwendung regul√§rer Ausdr√ºcke und der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(* Regexp) .FindAll aufgewendet wird</a> . <br><br>  Trotz der Tatsache, dass regul√§re Ausdr√ºcke eine bequeme und flexible M√∂glichkeit sind, Daten aus einfachem Text abzurufen, weisen sie Nachteile auf, einschlie√ülich der Verwendung einer gro√üen Anzahl von Ressourcen, eines Prozessors und eines Speichers.  Sie sind ein m√§chtiges Werkzeug, aber oft ist ihre Verwendung unn√∂tig. <br><br>  In unserem Programm eine Vorlage <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br>  Es ist haupts√§chlich dazu gedacht, Befehle hervorzuheben, die mit einem Bindestrich (-) beginnen, und es k√∂nnen mehrere in der Zeile sein.  Dies kann, nachdem ein kleiner Code gezogen wurde, mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bytes.Split erfolgen</a> .  Passen wir den Code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> ) an, um die regul√§ren Ausdr√ºcke in Split zu √§ndern: <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>Œºs pro Anruf (weniger</i> ist <i>besser)</i> <br><br>  Wow!  40% produktiverer Code!  Das Diagramm zum CPU-Verbrauch sieht nun folgenderma√üen aus: <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br>  Keine Zeitverschwendung mehr f√ºr regul√§re Ausdr√ºcke.  Ein wesentlicher Teil davon (40%) entf√§llt auf die Speicherzuweisung von f√ºnf verschiedenen Funktionen.  Interessanterweise werden jetzt 21% der Zeit f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytes</a> aufgewendet. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trim-</a> Funktion: <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>Diese Funktion fasziniert mich.</i>  <i>Was k√∂nnen wir hier machen?</i> <i><br><br></i>  <i>bytes.Trim</i> erwartet eine Zeichenfolge mit Zeichen, die als Argument "abgeschnitten" wird. Als Zeichenfolge √ºbergeben wir jedoch eine Zeichenfolge mit nur einem Zeichen - einem Leerzeichen.  Dies ist nur ein Beispiel daf√ºr, wie Sie aufgrund der Komplexit√§t eine Beschleunigung erzielen k√∂nnen: Erstellen wir unsere Trimmfunktion anstelle der Standardfunktion.  Unsere benutzerdefinierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trimmfunktion</a> funktioniert mit einem einzelnen Byte anstelle einer ganzen Zeile: <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>Œºs pro Anruf (weniger ist besser)</i> <br><br>  Hurra, weitere 20% abgeschnitten!  Die aktuelle Version ist viermal schneller als die urspr√ºngliche "schlechte" und verwendet gleichzeitig nur einen Kern.  Nicht schlecht! <br><br><hr><br><br>  Fr√ºher haben wir die Wettbewerbsf√§higkeit auf der Ebene der Linienverarbeitung aufgegeben, aber ich behaupte, dass eine Beschleunigung durch die Nutzung der Wettbewerbsf√§higkeit auf einer h√∂heren Ebene erreicht werden kann.  Beispielsweise ist die Verarbeitung von 6.000 Dateien (6.000 Nachrichten) auf meinem Computer schneller, wenn jede Datei in einer eigenen Goroutine verarbeitet wird: <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>Œºs pro Anruf (weniger ist besser; lila ist eine wettbewerbsf√§hige L√∂sung)</i> <br><br>  Die Verst√§rkung betr√§gt 66% (dh dreimal Beschleunigung).  Das ist gut, aber nicht sehr, wenn man bedenkt, dass alle 12 Prozessorkerne, die ich habe, verwendet werden.  Dies kann bedeuten, dass der neue optimierte Code, der die gesamte Datei verarbeitet, immer noch eine ‚Äûkleine Aufgabe‚Äú ist, f√ºr die der Aufwand f√ºr die Erstellung von Goroutinen und die Kosten f√ºr die Synchronisierung nicht unerheblich sind.  Interessanterweise hat die Erh√∂hung der Anzahl der Nachrichten von 6.000 auf 120.000 keine Auswirkungen auf die Single-Thread-Version und verringert die Leistung bei der Version "Eine Goroutine pro Nachricht".  Dies liegt daran, dass trotz der Tatsache, dass das Erstellen einer so gro√üen Anzahl von Goroutinen m√∂glich und manchmal n√ºtzlich ist, der Laufzeit- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sheduler-Bereich</a> einen eigenen Overhead <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verursacht</a> . <br><br>  Wir k√∂nnen die Ausf√ºhrungszeit weiter reduzieren (nicht um das 12-fache, aber immer noch), indem wir nur wenige Mitarbeiter erstellen.  Zum Beispiel 12 langlebige Goroutinen, von denen jede einen Teil der Nachrichten verarbeitet: <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>Œºs pro Anruf (weniger ist besser; lila ist eine wettbewerbsf√§hige L√∂sung)</i> <br><br>  Diese Option reduziert die Ausf√ºhrungszeit um 79% im Vergleich zur Single-Threaded-Version.  Beachten Sie, dass diese Strategie nur dann sinnvoll ist, wenn Sie viele Dateien verarbeiten m√ºssen. <br><br>  Die optimale Verwendung aller Prozessorkerne besteht darin, mehrere Goroutinen zu verwenden, von denen jede eine erhebliche Datenmenge ohne Interaktion oder Synchronisation verarbeitet, bevor die Arbeit abgeschlossen ist. <br><br>  Normalerweise nehmen sie so viele Prozesse (Goroutine) wie die Kerne des Prozessors, aber dies ist nicht immer die beste Option: Alles h√§ngt von der spezifischen Aufgabe ab.  Wenn Sie beispielsweise etwas aus dem Dateisystem lesen oder viele Netzwerkanrufe t√§tigen, sollten Sie mehr Goroutinen als Ihre Kerne verwenden, um mehr Leistung zu erzielen. <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>Œºs pro Anruf (weniger ist besser; lila ist eine wettbewerbsf√§hige L√∂sung)</i> <br><br>  Wir sind an einem Punkt angelangt, an dem es schwierig ist, die Parsing-Leistung mit einigen lokalisierten √Ñnderungen zu steigern.  Die Laufzeit wird von der Zeit f√ºr die Speicherzuweisung und die Speicherbereinigung dominiert.  Dies klingt logisch, da die Speicherverwaltungsfunktionen ziemlich langsam sind.  Die weitere Optimierung der mit Zuweisungen verbundenen Prozesse bleibt eine Hausaufgabe f√ºr die Leser. <br><br><hr><br><br>  Die Verwendung anderer Algorithmen kann ebenfalls zu einem gro√üen Leistungsgewinn f√ºhren. <br><br>  Hier wurde ich von einem Vortrag von Lexical Scanning in Go von Rob Pike inspiriert, <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  um einen benutzerdefinierten Lexer ( <a href="">Quelle</a> ) und einen benutzerdefinierten Parser ( <a href="">Quelle</a> ) zu erstellen.  Dieser Code ist noch nicht fertig (ich verarbeite keine Eckf√§lle), er ist weniger klar als der urspr√ºngliche Algorithmus und manchmal ist es schwierig, die richtige Fehlerbehandlung zu schreiben.  Aber es ist klein und 30% schneller als die am besten optimierte Version. <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>Œºs pro Anruf (weniger ist besser; lila ist eine wettbewerbsf√§hige L√∂sung)</i> <br><br>  Ja  Als Ergebnis haben wir eine 23-fache Beschleunigung im Vergleich zum Quellcode erhalten. <br><br><hr><br><br>  Das ist alles f√ºr heute.  Ich hoffe du hast dieses Abenteuer genossen.  Hier einige Anmerkungen und Schlussfolgerungen: <br><br><ul><li>  Die Produktivit√§t kann auf verschiedenen Abstraktionsebenen unter Verwendung verschiedener Techniken verbessert werden, und der Gewinn wird h√§ufig erh√∂ht. <br></li><li>  Die Optimierung muss mit Abstraktionen auf hoher Ebene beginnen: Datenstrukturen, Algorithmen, die korrekte Entkopplung von Modulen.  Nehmen Sie sp√§ter Abstraktionen auf niedriger Ebene auf: E / A, Stapelverarbeitung, Wettbewerbsf√§higkeit, Verwendung der Standardbibliothek, Arbeiten mit Speicher, Zuweisen von Speicher. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Big O-</a> Analyse ist sehr wichtig, aber normalerweise nicht das am besten geeignete Werkzeug, um ein Programm zu beschleunigen. <br></li><li>  Benchmarks zu schreiben ist harte Arbeit.  Verwenden Sie Profilerstellung und Benchmarks, um Engp√§sse zu finden und ein umfassenderes Verst√§ndnis der Vorg√§nge im Programm zu erlangen.  Beachten Sie, dass die Benchmark-Ergebnisse nicht mit denen Ihrer Benutzer in der Praxis √ºbereinstimmen. <br></li><li>  Gl√ºcklicherweise macht eine Reihe von Tools ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pprof</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Race Detector</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cover</a> ) die Erforschung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeleistung</a> erschwinglich und interessant. <br></li><li>  Gute, relevante Tests zu schreiben ist keine triviale Aufgabe.  Aber sie sind verdammt wichtig, nicht in die Wildnis zu gehen.  Sie k√∂nnen umgestalten, indem Sie sicherstellen, dass der Code korrekt bleibt. <br></li><li>  Halten Sie an und fragen Sie sich, wie schnell "schnell genug" ist.  Verschwenden Sie keine Zeit damit, ein einmaliges Skript zu optimieren.  Vergessen Sie nicht, dass die Optimierung nicht kostenlos ist: Zeit, Komplexit√§t, Fehler und technische Schulden des Ingenieurs. <br></li><li>  √úberlegen Sie zweimal, bevor Sie den Code komplizieren. <br></li><li>  Algorithmen mit der Komplexit√§t <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Œ©</a> (n¬≤) und h√∂her sind normalerweise zu teuer. <br></li><li>  Algorithmen mit der Komplexit√§t O (n) oder O (n log n) und darunter sind normalerweise in Ordnung. <br></li><li>  Verschiedene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versteckte Faktoren</a> k√∂nnen nicht ignoriert werden.  Zum Beispiel wurden alle Verbesserungen in dem Artikel durch Reduzieren dieser Faktoren und nicht durch √Ñndern der Komplexit√§tsklasse des Algorithmus erzielt. <br></li><li>  E / A ist h√§ufig ein Engpass: Netzwerkabfragen, Datenbankabfragen, Dateisystem. <br></li><li>  Regul√§re Ausdr√ºcke sind oft zu teuer und unn√∂tig. <br></li><li>  Speicherzuordnungen sind teurer als Berechnungen. <br></li><li>  Ein auf dem Stapel zugewiesenes Objekt ist billiger als ein auf dem Heap zugewiesenes Objekt. <br></li><li>  Slices sind als Alternative zu teuren Speicherbewegungen n√ºtzlich. <br></li><li>  Strings sind schreibgesch√ºtzt (einschlie√ülich Reslicing).  In allen anderen F√§llen sind [] Bytes effektiver. <br></li><li>  Es ist sehr wichtig, dass sich die von Ihnen verarbeiteten Daten in der N√§he befinden (Prozessor-Caches). <br></li><li>  Wettbewerbsf√§higkeit und Parallelit√§t sind sehr n√ºtzlich, aber schwer vorzubereiten. <br></li><li>  Wenn Sie tief und tief graben, denken Sie an den ‚ÄûGlasboden‚Äú, den Sie nicht in Go einbrechen m√∂chten.  Wenn Ihre H√§nde nach Assembler-Anweisungen oder SIMD-Anweisungen suchen, m√ºssen Sie Go m√∂glicherweise nur f√ºr das Prototyping verwenden und dann in eine niedrigere Sprache wechseln, um die vollst√§ndige Kontrolle √ºber die Hardware und jede Nanosekunde zu erhalten! <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415919/">https://habr.com/ru/post/de415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415909/index.html">Browser√ºbergreifende Web-Erweiterung f√ºr benutzerdefinierte Skripte Teil 2</a></li>
<li><a href="../de415911/index.html">Zugriff auf einen nicht vorhandenen Array-Index</a></li>
<li><a href="../de415913/index.html">W√§rmen Sie sich f√ºr diejenigen auf, die in Python k√∂nnen</a></li>
<li><a href="../de415915/index.html">Harte Praxis: Welche Art von WLAN haben wir f√ºr Hoteliers?</a></li>
<li><a href="../de415917/index.html">"Fr√ºhlingsgesetz" trat in Kraft: Was kommt als n√§chstes?</a></li>
<li><a href="../de415923/index.html">Ist die Einheit langsam? Achtung LINQ</a></li>
<li><a href="../de415925/index.html">MasterCard patentierte anonyme Blockchain-Technologie</a></li>
<li><a href="../de415927/index.html">Industrielampe Breeze 50</a></li>
<li><a href="../de415929/index.html">Optimierung der Architektur der k√ºnstlichen Intelligenz: Das Rennen beginnt</a></li>
<li><a href="../de415933/index.html">So erstellen Sie eine IIoT-Architektur zum Selbermachen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>