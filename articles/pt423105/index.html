<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥ üå®Ô∏è ü•í System.IO.Pipelines: E / S de alto desempenho no .NET üßëüèª‚Äçü§ù‚Äçüßëüèª üëãüèΩ üë©üèæ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="System.IO.Pipelines √© uma nova biblioteca que simplifica a organiza√ß√£o do c√≥digo no .NET. √â dif√≠cil garantir alto desempenho e precis√£o se voc√™ precis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines: E / S de alto desempenho no .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423105/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">System.IO.Pipelines</a> √© uma nova biblioteca que simplifica a organiza√ß√£o do c√≥digo no .NET.  √â dif√≠cil garantir alto desempenho e precis√£o se voc√™ precisar lidar com c√≥digos complexos.  A tarefa do System.IO.Pipelines √© simplificar o c√≥digo.  Mais detalhes sob o corte! <br><br><img src="https://habrastorage.org/webt/nq/me/p-/nqmep-tqvyyv5nlkpcxjnmlw8z4.jpeg"><a name="habracut"></a><br><br>  A biblioteca surgiu como resultado dos esfor√ßos da equipe de desenvolvimento do .NET Core para tornar o Kestrel um dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">servidores da Web mais r√°pidos do setor</a> .  Ele foi originalmente concebido como parte da implementa√ß√£o do Kestrel, mas evoluiu para uma API reutiliz√°vel, dispon√≠vel na vers√£o 2.1 como uma API BCL de primeira classe (System.IO.Pipelines). <br><br><h2>  Que problemas ela resolve? </h2><br>  Para analisar corretamente os dados de um fluxo ou soquete, voc√™ precisa escrever uma grande quantidade de c√≥digo padr√£o.  Ao mesmo tempo, existem muitas armadilhas que complicam o pr√≥prio c√≥digo e seu suporte. <br><br><h2>  Que dificuldades surgem hoje? </h2><br>  Vamos come√ßar com uma tarefa simples.  Precisamos escrever um servidor TCP que receba mensagens delimitadas por linha (\ n) do cliente. <br><br><h2>  Servidor TCP com NetworkStream </h2><br>  DESVIO: como em qualquer tarefa que exija alto desempenho, cada caso espec√≠fico deve ser considerado com base nos recursos do seu aplicativo.  Pode n√£o fazer sentido gastar recursos no uso de v√°rias abordagens, que ser√£o discutidas mais adiante, se a escala do aplicativo de rede n√£o for muito grande. <br><br>  O c√≥digo .NET regular antes de usar pipelines √© algo como isto: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length); <span class="hljs-comment"><span class="hljs-comment">// Process a single line from the buffer ProcessLine(buffer); }</span></span></code> </pre> <br>  veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample1.cs</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> <br><br>  Esse c√≥digo provavelmente funcionar√° com testes locais, mas possui v√°rios erros: <br><br><ul><li>  Talvez ap√≥s uma √∫nica chamada para o ReadAsync, a mensagem inteira n√£o seja recebida (at√© o final da linha). </li><li>  Ele ignora o resultado do m√©todo stream.ReadAsync () - a quantidade de dados realmente transferida para o buffer. </li><li>  O c√≥digo n√£o controla o recebimento de v√°rias linhas em uma √∫nica chamada ReadAsync. </li></ul><br>  Esses s√£o os erros mais comuns de leitura de dados de streaming.  Para evit√°-los, √© necess√°rio fazer v√°rias altera√ß√µes: <br><br><ul><li>  Voc√™ precisa armazenar em buffer os dados recebidos at√© que uma nova linha seja encontrada. </li><li>  √â necess√°rio analisar todas as linhas retornadas ao buffer. </li></ul><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, bytesBuffered, buffer.Length - bytesBuffered); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytesRead == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; var linePosition = -1; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample2.cs</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> <br><br>  Repito: isso pode funcionar com testes locais, mas √†s vezes existem cadeias maiores que 1 Kb (1024 bytes).  √â necess√°rio aumentar o tamanho do buffer de entrada at√© que uma nova linha seja encontrada. <br><br>  Al√©m disso, coletamos buffers em uma matriz ao processar seq√º√™ncias longas.  Podemos melhorar esse processo com o ArrayPool, que evita a realoca√ß√£o de buffers durante a an√°lise de longas filas do cliente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer var bytesRemaining = buffer.Length - bytesBuffered; if (bytesRemaining == 0) { // Double the buffer size and copy the previously buffered data into the new buffer var newBuffer = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length); // Return the old buffer to the pool ArrayPool&lt;byte&gt;.Shared.Return(buffer); buffer = newBuffer; bytesRemaining = buffer.Length - bytesBuffered; } var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining); if (bytesRead == 0) { // EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  <i>veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample3.cs</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a></i> <br><br>  O c√≥digo funciona, mas agora o tamanho do buffer mudou, como resultado, muitas c√≥pias dele aparecem.  Tamb√©m √© usada mais mem√≥ria, pois a l√≥gica n√£o reduz o buffer ap√≥s o processamento das linhas.  Para evitar isso, voc√™ pode salvar a lista de buffers, em vez de alterar o tamanho do buffer sempre que uma string chegar a mais de 1 Kb. <br><br>  Al√©m disso, n√£o aumentamos o tamanho do buffer de 1 KB, at√© que esteja completamente vazio.  Isso significa que transferiremos buffers cada vez menores para o ReadAsync, como resultado, o n√∫mero de chamadas para o sistema operacional aumentar√°. <br><br>  Vamos tentar eliminar isso e alocaremos um novo buffer assim que o tamanho do existente se tornar menor que 512 bytes: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BufferSegment</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Buffer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Remaining =&gt; Buffer.Length - Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;BufferSegment&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumedBufferIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferSegment { Buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>) }; segments.Add(segment); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer if (segment.Remaining &lt; minimumBufferSize) { // Allocate a new segment segment = new BufferSegment { Buffer = ArrayPool&lt;byte&gt;.Shared.Rent(1024) }; segments.Add(segment); } var bytesRead = await stream.ReadAsync(segment.Buffer, segment.Count, segment.Remaining); if (bytesRead == 0) { break; } // Keep track of the amount of buffered bytes segment.Count += bytesRead; while (true) { // Look for a EOL in the list of segments var (segmentIndex, segmentOffset) = IndexOf(segments, (byte)'\n', bytesConsumedBufferIndex, bytesConsumed); if (segmentIndex &gt;= 0) { // Process the line ProcessLine(segments, segmentIndex, segmentOffset); bytesConsumedBufferIndex = segmentOffset; bytesConsumed = segmentOffset + 1; } else { break; } } // Drop fully consumed segments from the list so we don't look at them again for (var i = bytesConsumedBufferIndex; i &gt;= 0; --i) { var consumedSegment = segments[i]; // Return all segments unless this is the current segment if (consumedSegment != segment) { ArrayPool&lt;byte&gt;.Shared.Return(consumedSegment.Buffer); segments.RemoveAt(i); } } } } (int segmentIndex, int segmentOffest) IndexOf(List&lt;BufferSegment&gt; segments, byte value, int startBufferIndex, int startSegmentOffset) { var first = true; for (var i = startBufferIndex; i &lt; segments.Count; ++i) { var segment = segments[i]; // Start from the correct offset var offset = first ? startSegmentOffset : 0; var index = Array.IndexOf(segment.Buffer, value, offset, segment.Count - offset); if (index &gt;= 0) { // Return the buffer index and the index within that segment where EOL was found return (i, index); } first = false; } return (-1, -1); }</span></span></code> </pre> <br>  <i>veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample4.cs</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a></i> <br><br>  Como resultado, o c√≥digo √© significativamente complicado.  Durante a pesquisa do delimitador, rastreamos os buffers preenchidos.  Para fazer isso, use uma Lista, que exibe dados em buffer ao procurar um novo separador de linhas.  Como resultado, ProcessLine e IndexOf aceitar√£o List em vez de byte [], deslocamento e contagem.  A l√≥gica de an√°lise come√ßar√° a processar um segmento do buffer ou v√°rios. <br><br>  E agora o servidor processar√° mensagens parciais e usar√° a mem√≥ria compartilhada para reduzir o consumo geral de mem√≥ria.  No entanto, v√°rias altera√ß√µes precisam ser feitas: <br><br><ol><li>  No ArrayPoolbyte, usamos apenas Byte [] - matrizes gerenciadas de maneira padr√£o.  Em outras palavras, quando as fun√ß√µes ReadAsync ou WriteAsync s√£o executadas, o per√≠odo de validade dos buffers √© vinculado ao tempo da opera√ß√£o ass√≠ncrona (para interagir com as pr√≥prias APIs de E / S do sistema operacional).  Como a mem√≥ria fixada n√£o pode ser movida, isso afeta o desempenho do coletor de lixo e pode causar fragmenta√ß√£o da matriz.  Pode ser necess√°rio alterar a implementa√ß√£o do pool, dependendo de quanto tempo as opera√ß√µes ass√≠ncronas aguardar√£o a execu√ß√£o. </li><li>  A taxa de transfer√™ncia pode ser aprimorada quebrando o link entre a l√≥gica de leitura e o processo.  Temos o efeito do processamento em lote, e agora a l√≥gica de an√°lise poder√° ler grandes quantidades de dados, processando grandes blocos de buffers, em vez de analisar linhas individuais.  Como resultado, o c√≥digo fica ainda mais complicado: <br><br><ul><li>  √â necess√°rio criar dois ciclos que funcionam independentemente um do outro.  O primeiro ler√° os dados do soquete e o segundo analisar√° os buffers. </li><li>  O que √© necess√°rio √© uma maneira de dizer √† l√≥gica de an√°lise que os dados est√£o se tornando dispon√≠veis. </li><li>  Tamb√©m √© necess√°rio determinar o que acontece se o loop l√™ os dados do soquete muito rapidamente.  Precisamos de uma maneira de ajustar o ciclo de leitura se a l√≥gica de an√°lise n√£o o acompanhar.  Isso geralmente √© chamado de "controle de fluxo" ou "resist√™ncia ao fluxo". </li><li>  Devemos garantir que os dados sejam transmitidos com seguran√ßa.  Agora, o conjunto de buffers √© usado tanto pelo ciclo de leitura quanto pelo ciclo de an√°lise; eles funcionam independentemente um do outro em threads diferentes. </li><li>  A l√≥gica de gerenciamento de mem√≥ria tamb√©m est√° envolvida em duas partes diferentes de c√≥digo: emprestando dados do buffer pool, que l√™ dados do soquete, e retornando do buffer pool, que √© a l√≥gica de an√°lise. </li><li>  √â preciso ter muito cuidado com o retorno de buffers ap√≥s a execu√ß√£o da l√≥gica de an√°lise.  Caso contr√°rio, existe a chance de retornarmos o buffer no qual a l√≥gica de leitura do soquete ainda est√° sendo gravada. </li></ul></li></ol><br>  A complexidade come√ßa a atravessar o telhado (e isso est√° longe de todos os casos!).  Para criar uma rede de alto desempenho, voc√™ precisa escrever um c√≥digo muito complexo. <br><br>  O objetivo do System.IO.Pipelines √© simplificar esse procedimento. <br><br><h4>  Servidor TCP e System.IO.Pipelines </h4><br>  Vamos ver como o System.IO.Pipelines funciona: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Task writing = FillPipeAsync(socket, pipe.Writer); Task reading = ReadPipeAsync(pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.WhenAll(reading, writing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket, PipeWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Allocate at least 512 bytes from the PipeWriter Memory&lt;byte&gt; memory = writer.GetMemory(minimumBufferSize); try { int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } // Tell the PipeWriter how much was read from the Socket writer.Advance(bytesRead); } catch (Exception ex) { LogError(ex); break; } // Make the data available to the PipeReader FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // Tell the PipeReader that there's no more data coming writer.Complete(); } async Task ReadPipeAsync(PipeReader reader) { while (true) { ReadResult result = await reader.ReadAsync(); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; SequencePosition? position = null; do { // Look for a EOL in the buffer position = buffer.PositionOf((byte)'\n'); if (position != null) { // Process the line ProcessLine(buffer.Slice(0, position.Value)); // Skip the line + the \n character (basically position) buffer = buffer.Slice(buffer.GetPosition(1, position.Value)); } } while (position != null); // Tell the PipeReader how much of the buffer we have consumed reader.AdvanceTo(buffer.Start, buffer.End); // Stop reading if there's no more data coming if (result.IsCompleted) { break; } } // Mark the PipeReader as complete reader.Complete(); }</span></span></code> </pre> <br>  <i>veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample5.cs</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a></i> <br><br>  A vers√£o em pipeline do nosso leitor de linha possui dois loops: <br><br><ul><li>  FillPipeAsync l√™ do soquete e grava no PipeWriter. </li><li>  O ReadPipeAsync l√™ no PipeReader e analisa as linhas recebidas. </li></ul><br>  Ao contr√°rio dos primeiros exemplos, n√£o h√° buffers especialmente atribu√≠dos.  Essa √© uma das principais fun√ß√µes do System.IO.Pipelines.  Todas as tarefas de gerenciamento de buffer s√£o transferidas para as implementa√ß√µes do PipeReader / PipeWriter. <br><br>  O procedimento √© simplificado: usamos o c√≥digo apenas para l√≥gica de neg√≥cios, em vez de implementar um gerenciamento de buffer complexo. <br><br>  No primeiro loop, PipeWriter.GetMemory (int) √© chamado primeiro para obter uma certa quantidade de mem√≥ria do gravador principal.  Em seguida, PipeWriter.Advance (int) √© chamado, o que informa ao PipeWriter quantos dados s√£o realmente gravados no buffer.  Isso √© seguido por uma chamada para PipeWriter.FlushAsync () para que PipeReader possa acessar os dados. <br><br>  O segundo loop consome os buffers que foram escritos pelo PipeWriter, mas originalmente recebidos do soquete.  Quando a solicita√ß√£o para PipeReader.ReadAsync () √© retornada, obtemos um ReadResult contendo duas mensagens importantes: dados lidos no formato ReadOnlySequence, bem como o tipo de dados l√≥gicos IsCompleted, que informa ao leitor se o gravador terminou de trabalhar (EOF).  Quando o terminador de linha (EOL) for encontrado e a sequ√™ncia for analisada, dividiremos o buffer em partes para pular o fragmento que j√° foi processado.  Depois disso, PipeReader.AdvanceTo √© chamado e informa ao PipeReader quantos dados foram consumidos. <br><br>  No final de cada ciclo, o leitor e o escritor s√£o conclu√≠dos.  Como resultado, o canal principal libera toda a mem√≥ria alocada. <br><br><h2>  System.io.pipelines </h2><br><h4>  Leitura parcial </h4><br>  Al√©m de gerenciar a mem√≥ria, o System.IO.Pipelines desempenha outra fun√ß√£o importante: verifica os dados no canal, mas n√£o os consome. <br><br>  O PipeReader possui duas APIs principais: ReadAsync e AdvanceTo.  O ReadAsync recebe dados do canal, AdvanceTo informa ao PipeReader que esses buffers n√£o s√£o mais necess√°rios pelo leitor, para que voc√™ possa se livrar deles (por exemplo, retorne-os ao buffer pool principal). <br><br>  A seguir, √© apresentado um exemplo de um analisador HTTP que l√™ dados de buffers de dados parciais do canal at√© receber uma linha inicial adequada. <br><br><img src="https://habrastorage.org/webt/9c/lp/d8/9clpd8h1r6b1m1jrwultkuggw6i.png"><br><br><h2>  ReadOnlySequenceT </h2><br>  A implementa√ß√£o do canal armazena uma lista de buffers relacionados passados ‚Äã‚Äãentre o PipeWriter e o PipeReader.  PipeReader.ReadAsync exp√µe ReadOnlySequence, que √© um novo tipo de BCL e consiste em um ou mais segmentos ReadOnlyMemory &lt;T&gt;.  √â semelhante ao Span ou Memory, que nos d√° a oportunidade de examinar matrizes e strings. <br><br><img src="https://habrastorage.org/webt/79/y0/kw/79y0kwylohggq941soblji6qd2o.png"><br><br>  Dentro do canal, existem indicadores que mostram onde o leitor e o gravador est√£o localizados no conjunto geral de dados destacados e tamb√©m os atualizam √† medida que os dados s√£o gravados e lidos.  SequencePosition √© um ponto √∫nico em uma lista vinculada de buffers e √© usado para separar eficientemente ReadOnlySequence &lt;T&gt;. <br><br>  Como o ReadOnlySequence &lt;T&gt; suporta um ou mais segmentos, a opera√ß√£o padr√£o da l√≥gica de alto desempenho √© separar caminhos r√°pidos e lentos com base no n√∫mero de segmentos. <br><br>  Como exemplo, aqui est√° uma fun√ß√£o que converte ASCII ReadOnlySequence em uma cadeia de caracteres: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAsciiString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.IsSingleSegment) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Encoding.ASCII.GetString(buffer.First.Span); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Create((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buffer.Length, buffer, (span, sequence) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence) { Encoding.ASCII.GetChars(segment.Span, span); span = span.Slice(segment.Length); } }); }</code> </pre> <br>  veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sample6.cs</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> <br><br><h4>  Resist√™ncia ao fluxo e controle de fluxo </h4><br>  Idealmente, a leitura e a an√°lise trabalham juntas: o fluxo de leitura consome dados da rede e os coloca em buffers, enquanto o fluxo de an√°lise cria estruturas de dados adequadas.  A an√°lise geralmente leva mais tempo do que apenas copiar blocos de dados da rede.  Como resultado, o fluxo de leitura pode sobrecarregar facilmente o fluxo de an√°lise.  Portanto, o fluxo de leitura ser√° for√ßado a diminuir a velocidade ou consumir mais mem√≥ria para salvar dados para o fluxo de an√°lise.  Para garantir o desempenho ideal, √© necess√°rio um equil√≠brio entre a frequ√™ncia de pausa e a aloca√ß√£o de uma grande quantidade de mem√≥ria. <br><br>  Para resolver esse problema, o pipeline possui duas fun√ß√µes de controle de fluxo de dados: PauseWriterThreshold e ResumeWriterThreshold.  PauseWriterThreshold determina quantos dados precisam ser armazenados em buffer antes que PipeWriter.FlushAsync seja pausado.  ResumeWriterThreshold determina quanta mem√≥ria o leitor pode consumir antes do gravador retomar a opera√ß√£o. <br><br><img src="https://habrastorage.org/webt/qf/yj/5u/qfyj5u6aahkadlp8nk1gtc9bqr4.png"><br><br>  PipeWriter.FlushAsync "bloqueia" quando a quantidade de dados no fluxo em pipeline excede o limite definido em PauseWriterThreshold e "desbloqueia" quando cai abaixo do limite definido em ResumeWriterThreshold.  Para evitar exceder o limite de consumo, apenas dois valores s√£o usados. <br><br><h4>  Planejamento de E / S </h4><br>  Ao usar async / waitit, as opera√ß√µes subseq√ºentes geralmente s√£o chamadas nos threads do pool ou no SynchronizationContext atual. <br><br>  Ao executar a E / S, √© muito importante monitorar cuidadosamente onde √© executada, a fim de aproveitar melhor o cache do processador.  Isso √© cr√≠tico para aplicativos de alto desempenho, como servidores da web.  O System.IO.Pipelines usa o PipeScheduler para determinar onde executar retornos de chamada ass√≠ncronos.  Isso permite controlar com precis√£o quais fluxos usar para E / S. <br><br>  Um exemplo de uma aplica√ß√£o pr√°tica √© o transporte Kestrel Libuv, no qual os retornos de chamada de E / S s√£o executados em canais dedicados do loop de eventos. <br><br><h2>  Existem outros benef√≠cios para o modelo PipeReader. </h2><br><ul><li>  Alguns sistemas b√°sicos suportam ‚Äúespera sem buffer‚Äù: voc√™ n√£o precisa alocar um buffer at√© que os dados dispon√≠veis apare√ßam no sistema b√°sico.  Portanto, no Linux com epoll, voc√™ n√£o pode fornecer um buffer de leitura at√© que os dados estejam prontos.  Isso evita a situa√ß√£o quando h√° muitos threads aguardando dados e voc√™ precisa reservar imediatamente uma quantidade enorme de mem√≥ria. </li><li>  O pipeline padr√£o facilita a grava√ß√£o de testes de unidade de c√≥digo de rede: a l√≥gica de an√°lise √© separada do c√≥digo de rede, e os testes de unidade executam essa l√≥gica apenas em buffers na mem√≥ria, em vez de consumi-la diretamente da rede.  Tamb√©m facilita o teste de padr√µes complexos enviando dados parciais.  O ASP.NET Core o utiliza para testar v√°rios aspectos das ferramentas de an√°lise http do Kestrel. </li><li>  Os sistemas que permitem que o c√≥digo do usu√°rio use os principais buffers do SO (por exemplo, APIs de E / S do Windows registradas) s√£o inicialmente adequados para o uso de pipelines porque a implementa√ß√£o do PipeReader sempre fornece buffers. </li></ul><br><h4>  Outros tipos relacionados </h4><br>  Tamb√©m adicionamos v√°rios novos tipos simples de BCL ao System.IO.Pipelines: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MemoryPoolT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IMemoryOwnerT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MemoryManagerT</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ArrayPoolT</a> foi adicionado no .NET Core 1.0 e, no .NET Core 2.1, agora existe uma representa√ß√£o abstrata mais geral para um pool que funciona com qualquer MemoryT.  Obtemos um ponto de extensibilidade que nos permite implementar estrat√©gias de distribui√ß√£o mais avan√ßadas, bem como controlar o gerenciamento de buffer (por exemplo, use buffers predefinidos em vez de matrizes gerenciadas exclusivamente). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBufferWriterT</a> √© um receptor para registrar dados em buffer sincronizados (implementados pelo PipeWriter). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IValueTaskSource</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ValueTaskT</a> existe desde o lan√ßamento do .NET Core 1.1, mas no .NET Core 2.1 ele adquiriu ferramentas extremamente eficazes que fornecem opera√ß√µes ass√≠ncronas ininterruptas sem distribui√ß√£o.  Veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui para</a> mais informa√ß√µes. </li></ul><br><h2>  Como usar transportadores? </h2><br>  As APIs est√£o no pacote de nuget <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">System.IO.Pipelines</a> . <br><br>  Para um exemplo de aplicativo de servidor .NET Server 2.1 que usa pipelines para processar mensagens em min√∫sculas (do exemplo acima), consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Pode ser iniciado usando o dotnet run (ou Visual Studio).  No exemplo, espera-se que os dados sejam transmitidos do soquete na porta 8087 e, em seguida, as mensagens recebidas ser√£o gravadas no console.  Voc√™ pode usar um cliente, como netcat ou putty, para conectar-se √† porta 8087.  Envie uma mensagem em min√∫scula e veja como ela funciona. <br><br>  Atualmente, o pipeline √© executado no Kestrel e no SignalR, e esperamos que ele encontre aplicativos mais amplos em muitas bibliotecas de rede e componentes da comunidade .NET no futuro. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423105/">https://habr.com/ru/post/pt423105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423093/index.html">Aumentamos a aleatoriedade do fato de que [provavelmente] [quase] por acidente</a></li>
<li><a href="../pt423095/index.html">Novidades da apresenta√ß√£o da Apple</a></li>
<li><a href="../pt423097/index.html">Tarefas e solu√ß√µes para o lutador PostgreSQL</a></li>
<li><a href="../pt423101/index.html">Implantando o armazenamento LINSTOR para Proxmox</a></li>
<li><a href="../pt423103/index.html">Podcasts em Python: foi tudo o que descobrimos</a></li>
<li><a href="../pt423107/index.html">Convidamos voc√™ para a reuni√£o Go in Production</a></li>
<li><a href="../pt423109/index.html">O que a Apple apresentou e o que os desenvolvedores do iOS pensam sobre isso</a></li>
<li><a href="../pt423115/index.html">Efeitos aprimorados com o modo de mesclagem da camada de segundo plano CSS</a></li>
<li><a href="../pt423117/index.html">Viver mais ou envelhecer mais devagar: uma abordagem tecnol√≥gica para a velhice</a></li>
<li><a href="../pt423119/index.html">DIY TTL arcade machine ... em 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>