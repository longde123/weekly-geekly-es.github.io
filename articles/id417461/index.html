<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔧 🎀 🔜 Ivan Tulup: asinkron di JS di bawah tenda 🧛🏽 🙀 ☹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah Anda kenal Ivan Tulup? Kemungkinan besar ya, Anda belum tahu orang macam apa ini, dan Anda harus sangat memperhatikan kondisi sistem kardiovask...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ivan Tulup: asinkron di JS di bawah tenda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417461/">  Apakah Anda kenal Ivan Tulup?  Kemungkinan besar ya, Anda belum tahu orang macam apa ini, dan Anda harus sangat memperhatikan kondisi sistem kardiovaskularnya. <br><br>  Tentang ini dan bagaimana asinkronisme bekerja di JS di bawah tenda, bagaimana Event Loop bekerja di browser dan Node.js, apakah ada perbedaan dan mungkin hal-hal serupa diberitahukan oleh <strong>Mikhail Bashurov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">SaitoNakamura</a> ) dalam laporannya tentang RIT ++.  Kami senang berbagi dengan Anda transkrip presentasi informatif ini. <br><br><img src="https://habrastorage.org/webt/mv/fj/ah/mvfjah-dahl8fndi-w8rt4qkbxw.jpeg"><br><br>  <strong>Tentang pembicara:</strong> Mikhail Bashurov adalah pengembang web fullstack di JS dan .NET dari Luxoft.  Dia mencintai UI yang indah, tes hijau, transpilasi, kompilasi, teknik penyusun yang memungkinkan dan meningkatkan pengalaman dev. <br><br>  <strong>Catatan Editor:</strong> Laporan Mikhail didampingi tidak hanya oleh slide, tetapi oleh proyek demo di mana Anda dapat mengklik tombol dan secara mandiri menyaksikan pelaksanaan shuffles.  Opsi terbaik adalah membuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> di tab yang berdekatan dan merujuknya secara berkala, tetapi teks juga akan menyediakan tautan ke halaman tertentu.  Dan sekarang kita melewati lantai ke pembicara, selamat membaca. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Kakek Ivan Tulup </h2><br>  Saya memiliki pencalonan untuk Ivan Tulup. <br><br><img src="https://habrastorage.org/webt/hl/8x/lx/hl8xlx_fubycz-ivega_hinmhp0.png"><br><br>  Tapi saya memutuskan untuk mengambil jalan yang lebih konformis, jadi temui - kakek Ivan Tulup! <br><br><img src="https://habrastorage.org/webt/qd/jc/dn/qdjcdntndkzeyiuw3zpwt4vos74.png"><br><br>  Faktanya, hanya dua hal yang perlu diketahui tentang dia: <br><br><ol><li>  Dia suka bermain kartu. </li><li>  Dia, seperti semua orang, memiliki hati, dan itu berdetak. </li></ol><br><h2>  Fakta Serangan Jantung </h2><br>  Anda mungkin pernah mendengar bahwa kasus penyakit jantung dan kematian dari mereka baru-baru ini menjadi lebih sering.  Mungkin penyakit jantung yang paling umum adalah serangan jantung, yaitu serangan jantung. <br><br>  Apa yang menarik tentang serangan jantung? <br><br><ul><li>  Paling sering, itu terjadi pada Senin pagi. </li><li>  Pada orang lajang, risiko serangan jantung dua kali lebih tinggi.  Di sini, mungkin, intinya semata-mata dalam korelasi, dan bukan dalam hubungan kausal.  Sayangnya (atau untungnya), bagaimanapun, ini benar. </li><li>  Sepuluh konduktor meninggal karena serangan jantung selama melakukan (pekerjaan tampaknya sangat gugup!). </li><li>  Serangan jantung adalah nekrosis otot jantung yang disebabkan oleh kurangnya aliran darah. </li></ul><br>  Kami memiliki arteri koroner yang membawa darah ke otot (miokardium).  Jika darah mulai mengalir dengan buruk, otot secara bertahap mati.  Secara alami, ini memiliki efek yang sangat negatif pada jantung dan pekerjaannya. <br><br>  Kakek Ivan Tulup juga memiliki hati, dan berdetak.  Tetapi hati kita memompa darah, dan hati Ivan Tulup memompa kode dan kesedihan kita. <br><br><h2>  Tasky: lingkaran besar sirkulasi darah <br></h2><br>  Apa tugasnya?  Apa yang biasanya malas di browser?  Mengapa mereka dibutuhkan sama sekali? <br><br>  Misalnya, kami mengeksekusi kode dari skrip.  Ini adalah satu detak jantung, dan sekarang kami memiliki aliran darah.  Kami mengklik tombol dan berlangganan acara - pengendali acara untuk acara ini - Callback yang kami kirimkan.  Mereka mengatur TimeTime, Callback bekerja - tugas lain.  Dan dalam beberapa bagian, satu detak jantung adalah satu tugas. <br><br><img src="https://habrastorage.org/webt/vz/sb/0z/vzsb0znwotnkpldqmb2chhwblxs.png"><br><br>  Ada banyak sumber kol yang berbeda, sesuai spesifikasi ada sejumlah besar.  Jantung kita terus berdetak, dan sementara itu berdetak, semuanya baik-baik saja dengan kita. <br><br><h3>  Perulangan Acara di browser: versi sederhana <br></h3><br>  Ini dapat direpresentasikan dalam diagram yang sangat sederhana. <br><br><img src="https://habrastorage.org/webt/hy/zf/2p/hyzf2pktcyzag0oroich978odpa.png"><br><br><ul><li>  Ada tugas, kami sudah menyelesaikannya. </li><li>  Kemudian kita menjalankan render browser. </li></ul><br>  Tetapi pada kenyataannya, ini tidak perlu, karena dalam beberapa kasus browser mungkin tidak membuat antara dua tugas. <br><br>  Ini dapat terjadi, misalnya, jika browser dapat memutuskan untuk mengelompokkan beberapa waktu tunggu atau beberapa acara gulir.  Atau pada titik tertentu, ada yang tidak beres, dan browser memutuskan alih-alih 60 fps (frame rate biasa sehingga semuanya menjadi dingin dan lancar) untuk menampilkan 30 fps.  Dengan demikian, ia akan memiliki lebih banyak waktu untuk mengeksekusi kode Anda dan pekerjaan bermanfaat lainnya, ia akan dapat melakukan beberapa kejutan. <br><br>  Oleh karena itu, render tidak benar-benar dilakukan setelah setiap tugas. <br><br><h3>  Tasky: klasifikasi <br></h3><br>  Ada dua jenis operasi potensial: <br><br><ol><li>  I / O terikat; </li><li>  Terikat CPU. </li></ol><br>  <strong>Ikatan CPU</strong> adalah pekerjaan bermanfaat yang kami lakukan (percaya, menampilkan, dll.) <br><br>  <strong>I / O terikat</strong> adalah poin di mana kita dapat berbagi tugas.  Itu bisa: <br><br><ul><li>  Batas waktu </li></ul>  Kami membuat setTimeout 5000 ms, dan kami hanya menunggu 5000 ms ini, tetapi kami dapat melakukan pekerjaan lain yang bermanfaat.  Hanya ketika waktu ini berlalu, kami mendapatkan Callback, dan melakukan beberapa pekerjaan di dalamnya. <br><br><ul><li>  xhr / ambil. </li></ul>  Kami online.  Sementara kami menunggu tanggapan dari jaringan, kami hanya menunggu, tetapi kami juga dapat melakukan sesuatu yang bermanfaat. <br><br><ul><li>  Jaringan (OBD). </li></ul>  Atau, misalnya, kita masuk ke Network BD.  Kita berbicara tentang Node.js juga, termasuk, dan jika kita ingin pergi ke suatu tempat ke jaringan dari Node.js tolong - ini adalah potensi tugas I / O terikat yang sama (input / output). <br><br><ul><li>  File. </li></ul>  Baca file - berpotensi bukan tugas yang terikat CPU sama sekali.  Di Node.js, ini berjalan di thread pool karena API Linux sedikit bengkok, jujur. <br><br>  Maka CPUbound adalah: <br><br><ul><li>  Sebagai contoh, ketika kita melakukan for / for (;;) loop atau kita melewati array entah bagaimana menggunakan metode tambahan: filter, map, dll. </li><li>  JSON.parse atau JSON.stringify, mis. Serialisasi pesan / deserialisasi.  Ini semua dilakukan pada CPU, kita tidak bisa menunggu semuanya dieksekusi secara ajaib di suatu tempat. </li><li>  Menghitung hash, mis., Penambangan kripto. </li></ul><br>  Tentu saja, crypto juga dapat ditambang di GPU, tapi saya pikir - GPU, CPU - Anda mengerti analogi ini. <br><br><h3>  Tasky: aritmia dan trombus </h3><br>  Sebagai hasilnya, ternyata jantung kita berdetak: ia melakukan satu tugas, yang kedua, yang ketiga - sampai kita melakukan sesuatu yang salah.  Misalnya, kita melalui array 1 juta elemen dan menghitung jumlahnya.  Tampaknya ini tidak begitu sulit, tetapi dapat mengambil waktu nyata.  Jika kami terus-menerus mengambil waktu nyata tanpa melepaskan tugas, render kami tidak dapat dilakukan.  Dia melayang dalam kerinduan ini, dan semua - aritmia dimulai. <br><br>  Saya pikir semua orang mengerti bahwa aritmia adalah penyakit jantung yang agak tidak menyenangkan.  Tapi kamu masih bisa hidup bersamanya.  Apa yang terjadi jika Anda menempatkan tugas yang hanya menggantung seluruh Loop Peristiwa dalam loop tanpa akhir?  Anda semacam meletakkan gumpalan darah di koroner atau arteri lainnya, dan semuanya akan menjadi benar-benar sedih.  Sayangnya, kakek kami Ivan Tulup akan mati. <br><br><h3>  Jadi kakek Ivan meninggal ... <br></h3><br><img src="https://habrastorage.org/webt/8t/nq/gc/8tnqgc8lygwpsdvts0b3xpqgtta.png"><br><br>  Bagi kami, ini berarti bahwa seluruh tab membeku sama sekali - Anda tidak dapat mengklik apa pun, dan kemudian Chrome berkata: "Aduh, Snap!" <br><br>  Ini bahkan jauh lebih buruk daripada bug situs web ketika terjadi kesalahan.  Tetapi jika semuanya tergantung, dan bahkan, mungkin, CPU dimuat dan pengguna biasanya digantung, maka kemungkinan besar dia tidak akan pernah pergi ke situs Anda lagi. <br><br>  Oleh karena itu, idenya adalah ini: kita memiliki tugas, dan kita tidak perlu bertahan dalam tugas ini untuk waktu yang sangat lama.  Kita perlu dengan cepat melepaskannya, sehingga peramban, jika ada, dapat merender (jika mau).  Jika Anda tidak mau - bagus, menari! <br><br><h2>  Demo Philip Roberts: Pembesar oleh Philip Roberts <br></h2><br>  Pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah contoh</a> : <br><br><pre><code class="javascript hljs">$.on(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); }); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span> log(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>); }. <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(“Hello world<span class="hljs-string"><span class="hljs-string">");</span></span></code> </pre> <br>  Intinya adalah ini: kami memiliki tombol, kami berlangganan (addEventListener), Timeout dipanggil selama 5 detik dan segera di console.log kita menulis "Halo, dunia!", Di setTimeout kita menulis Timeout, di onClick kita menulis Klik. <br><br>  Apa yang akan terjadi jika kita menjalankannya dan berkali-kali kita mengklik tombol - kapan Timeout sebenarnya akan dieksekusi?  Mari kita lihat demo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Kode mulai dijalankan, masuk stack, Timeout berjalan.  Sementara itu, kami mengklik tombol.  Di bagian bawah antrian, beberapa acara ditambahkan.  Ketika Click sedang berjalan, Timeout menunggu, meskipun 5 detik telah berlalu. <br><br>  Di sini, onClick cepat, tetapi jika Anda menempatkan tugas yang lebih panjang, maka semuanya akan membeku, seperti yang sudah dijelaskan.  Ini adalah contoh yang sangat sederhana.  Ini satu putaran, tetapi di browser, pada kenyataannya, semuanya tidak demikian. <br><br>  Dalam urutan apa acara dijalankan - apa spesifikasi HTML katakan? <br><br>  Dia mengatakan yang berikut: kami memiliki 2 konsep: <br><br><ol><li>  sumber tugas; </li><li>  antrian tugas. </li></ol><br>  Sumber tugas adalah sejenis tugas.  Ini mungkin interaksi Pengguna, yaitu, onClick, onChange - sesuatu yang berinteraksi dengan pengguna;  atau timer, mis. setTimeout dan setInterval, atau PostMessages;  atau bahkan tipe yang benar-benar liar seperti sumber tugas Canvas Blob Serialisasi - juga tipe yang terpisah. <br><br>  Spesifikasi mengatakan bahwa untuk sumber tugas yang sama tugas akan dijamin akan dieksekusi dalam urutan yang ditambahkan.  Untuk yang lainnya, tidak ada yang dijamin, karena dapat ada jumlah tugas yang tidak terbatas.  Browser memutuskan berapa banyak akan ada.  Dengan bantuan antrian tugas dan pembuatannya, browser dapat memprioritaskan tugas tertentu. <br><br><h3>  Prioritas Browser dan Antrean Tugas <br></h3><br><img src="https://habrastorage.org/webt/xv/fu/s9/xvfus9kn-18e_oxy00s_xwm6vdq.png"><br><br>  Bayangkan kita memiliki 3 baris: <br><br><ol><li>  interaksi pengguna; </li><li>  batas waktu </li><li>  memposting pesan. </li></ol><br>  Browser mulai mendapatkan tugas dari antrian ini: <br><br><ul><li>  Pertama, dia mengambil interaksi pengguna <strong>Fokus</strong> - ini sangat penting - satu detak jantung telah hilang. <br></li><li>  Lalu ia mengambil <strong>postMessage</strong> - well, postMessages adalah prioritas yang cukup tinggi, keren! <br></li><li>  Yang berikutnya, <strong>onChange,</strong> juga kembali dari interaksi pengguna dalam prioritas. <br></li><li>  Selanjutnya, <strong>Klik</strong> dikirim.  Antrian interaksi pengguna telah berakhir, kami telah menampilkan kepada pengguna segala yang diperlukan. <br></li><li>  Lalu kita ambil <strong>setInterval</strong> , tambahkan postMessages. <br></li><li>  <strong>setTimeout hanya akan menjalankan yang terbaru</strong> .  Dia berada di suatu tempat di ujung garis. <br></li></ul><br>  Sekali lagi ini adalah contoh yang sangat sederhana, dan, sayangnya, <strong>tidak ada yang bisa menjamin bagaimana ini akan bekerja di browser</strong> , karena mereka memutuskan semua ini sendiri.  Anda perlu menguji ini sendiri jika Anda ingin mengetahui apa itu. <br><br>  Sebagai contoh, postMessages lebih diutamakan daripada setTimeout.  Anda mungkin pernah mendengar hal seperti setImmediate, yang, misalnya, di browser IE, hanya asli.  Tetapi ada polyfile yang terutama didasarkan bukan pada setTimeout, tetapi pada pembuatan saluran postMessages dan berlangganan.  Ini umumnya bekerja lebih cepat karena browser memprioritaskannya. <br><br>  Nah, tugas-tugas ini dilakukan.  Pada titik apa kita menyelesaikan tugas kita dan memahami bahwa kita dapat mengambil yang berikutnya, atau yang dapat kita render? <br><br><h3>  Tumpukan </h3><br>  Tumpukan adalah struktur data sederhana yang bekerja berdasarkan prinsip "last in - first out", mis.  "Aku yang terakhir - kamu yang pertama <strong>.</strong> "  Rekan terdekat yang mungkin terdekat adalah setumpuk kartu.  Karena itu, kakek kami Ivan Tulup suka bermain kartu. <br><br><img src="https://habrastorage.org/webt/5b/03/dh/5b03dh5di0r9oktsyvekmflkey4.png"><br><br>  Contoh di atas, di mana ada beberapa kode, contoh yang sama dapat dicubit dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> .  Di beberapa tempat kami memanggil handleClick, masukkan console.log, panggil showPopup dan jendela.  konfirmasi.  Mari kita membentuk tumpukan. <br><br><ul><li>  Jadi, pertama-tama kita ambil handleClick dan dorong panggilan ke fungsi ini ke stack - hebat! </li><li>  Lalu kita masuk ke tubuhnya dan melaksanakannya. </li><li>  Kami meletakkan console.log di tumpukan dan segera menjalankannya, karena semuanya ada untuk menjalankannya. </li><li>  Selanjutnya kita taruh showConfirm - ini adalah panggilan fungsi - hebat. </li><li>  Kami menempatkan fungsi pada tumpukan - kami menempatkan tubuhnya, yaitu, window.confirm. </li></ul><br>  Kami tidak memiliki apa-apa lagi - kami melakukannya.  Sebuah jendela akan muncul: "Apakah Anda yakin?", Klik "Ya", dan semuanya akan meninggalkan tumpukan.  Sekarang kita telah menyelesaikan tubuh showConfirm dan badan handleClick.  Tumpukan kami dihapus dan kami dapat melanjutkan ke tugas berikutnya.  Pertanyaan: Oke, sekarang saya tahu bahwa Anda perlu memecahnya menjadi potongan-potongan kecil.  Bagaimana saya bisa, misalnya, melakukan ini dalam kasus yang paling dasar? <br><br><h3>  Mempartisi sebuah array menjadi potongan dan memprosesnya secara tidak sinkron </h3><br>  Mari kita lihat contoh yang paling "dahi".  Saya segera memperingatkan Anda: tolong jangan mencoba untuk mengulanginya di rumah - itu tidak akan dikompilasi. <br><br><img src="https://habrastorage.org/webt/on/a4/kz/ona4kz7lojjan82vfis4dkoxvh0.png"><br><br>  Kami memiliki array besar, besar, dan kami ingin menghitung sesuatu berdasarkan itu, misalnya, untuk mem-parsing beberapa data biner.  Kita cukup memecahnya menjadi potongan: proses bagian ini, ini dan ini.  Kami memilih ukuran chunk, misalnya, 10 ribu elemen, kami mempertimbangkan berapa banyak chunk yang akan kami miliki.  Kami memiliki fungsi parseData yang masuk ke CPU terikat dan benar-benar dapat melakukan sesuatu yang berat.  Kemudian kita memecah array menjadi potongan-potongan, lakukan setTimeout (() =&gt; parseData (slice), 0). <br><br>  Dalam hal ini, browser akan dapat kembali memprioritaskan interaksi pengguna dan membuat di antaranya.  Artinya, Anda setidaknya melepaskan Loop Peristiwa Anda, dan itu terus bekerja.  Jantungmu terus berdetak, dan itu bagus. <br><br>  Tapi ini benar-benar contoh yang sangat "dahi".  Ada banyak API di browser untuk membantu Anda melakukan ini dengan cara yang lebih khusus. <br><br>  Selain setTimeout dan setInterval, ada API yang melampaui batas, seperti, misalnya, requestAnimationFrame dan requestIdleCallback. <br><br>  Mungkin banyak yang akrab dengan <strong>requestAnimationFrame</strong> , dan bahkan sudah menggunakannya.  Itu dieksekusi sebelum rendering.  Pesonanya adalah, pertama, ia mencoba mengeksekusi setiap 60 fps (atau 30 fps), dan kedua, semua ini dilakukan segera sebelum membuat Model Objek CSS, dll. <br><br><img src="https://habrastorage.org/webt/0-/hy/qt/0-hyqtkge9dm9ayeciqrrzgjors.png"><br><br>  Oleh karena itu, bahkan jika Anda memiliki beberapa requestAnimationFrame, mereka sebenarnya akan mengelompokkan semua perubahan, dan bingkai akan keluar lengkap.  Dalam hal setTimeout, Anda tentu tidak bisa mendapatkan jaminan seperti itu.  Satu setTimeout akan mengubah satu hal, yang lain lagi, dan di antara proses rendering mungkin tergelincir - Anda akan menyentak layar atau sesuatu yang lain.  RequestAnimationFrame sangat bagus untuk ini. <br><br>  Selain itu, ada juga <strong>requestIdleCallback.</strong>  Mungkin Anda mendengar bahwa ini digunakan dalam React v16.0 (Fiber).  RequestIdleCallback berfungsi sedemikian rupa sehingga jika browser memahami bahwa ada waktu di antara frame (60 fps) untuk melakukan sesuatu yang bermanfaat, dan pada saat yang sama mereka sudah melakukan semuanya - mereka melakukan tugas, requestAnimationFrame lakukan - sepertinya keren, maka itu dapat menghasilkan kuanta kecil, katakanlah, masing-masing 50 ms, sehingga Anda dapat melakukan sesuatu (mode IDLE). <br><br>  Itu tidak ada dalam diagram di atas, karena tidak terletak di tempat tertentu.  Browser dapat memutuskan untuk meletakkannya di depan frame, setelah frame, antara requestAnimationFrame dan render, setelah tugas, sebelum tugas.  Tidak ada yang bisa menjamin ini. <br><br>  Dijamin untuk Anda bahwa jika Anda memiliki pekerjaan yang tidak terkait dengan mengubah DOM (karena kemudian requestAnimationFrame adalah animasi dan sebagainya), sementara itu bukan prioritas super, tetapi nyata, maka requestIdleCallback adalah jalan keluar Anda. <br><br>  Jadi, jika kita memiliki operasi terikat CPU yang panjang, maka kita dapat mencoba memecahnya menjadi beberapa bagian. <br><br><ul><li>  Jika ini adalah perubahan DOM, maka gunakan <strong>requestAnimationFrame.</strong> <br></li><li>  Jika ini adalah tugas yang tidak diprioritaskan, berumur pendek dan tidak sulit yang tidak akan <strong>membebani</strong> CPU, maka <strong>requestIdleCallback.</strong> <br></li><li>  Jika kami memiliki tugas besar yang sangat kuat yang perlu dilakukan terus-menerus, maka kami melampaui Event Loop dan menggunakan WebWorkers.  Tidak ada jalan lain. <br></li></ul><br>  <strong>Tugas di browser:</strong> <br><br><ol><li>  Hancurkan semuanya menjadi tugas-tugas kecil. </li><li>  Ada banyak jenis tugas. </li><li>  Tugas diprioritaskan oleh tipe-tipe ini melalui antrian spesifikasi. </li><li>  Banyak yang diputuskan oleh browser, dan satu-satunya cara untuk memahami cara kerjanya adalah dengan hanya memeriksa apakah satu atau kode lain sedang berjalan. </li><li>  Namun spesifikasinya tidak selalu dihormati! </li></ol><br>  Masalahnya adalah bahwa Ivan Tulup kami adalah kakek tua, karena implementasi Event Loop di browser juga sebenarnya sangat tua.  Mereka dibuat sebelum spesifikasi ditulis, sehingga spesifikasi, sayangnya, dihormati sejauh.  Bahkan jika Anda membaca seperti apa spesifikasi itu, tidak ada yang menjamin bahwa semua browser mendukungnya.  Jadi pastikan untuk memeriksa di browser bagaimana ini sebenarnya bekerja. <br><br>  Kakek Ivan Tulup di browser adalah orang yang tidak dapat diprediksi, dengan beberapa fitur menarik, Anda perlu mengingat ini. <br><br><h2>  Terminator Santa: Mascot Loop di Node.js <br></h2><br>  Node.js lebih seperti seseorang seperti itu. <br><br><img src="https://habrastorage.org/webt/bb/5u/bx/bb5ubx5cvdgtu2lilmk-rfmeajc.png"><br><br>  Karena di satu sisi itu adalah kakek yang sama dengan janggut, tetapi pada saat yang sama semuanya dibagikan secara bertahap dan dicat dengan jelas di mana dilakukan. <br><br>  <strong>Fase-fase Perulangan Acara di Node.js:</strong> <br><br><ul><li>  pengatur waktu; <br></li><li>  panggilan balik yang tertunda; <br></li><li>  menganggur, siapkan; <br></li><li>  jajak pendapat; <br></li><li>  periksa; <br></li><li>  tutup panggilan balik. <br></li></ul><br>  Semuanya kecuali yang terakhir tidak begitu jelas apa artinya.  Fase memiliki nama aneh seperti itu, karena di bawah tenda, seperti yang sudah kita ketahui, kita memiliki Libuv untuk memerintah semua orang: <br><br><ul><li>  <em>Linux -</em> epoll / POSIX AIO; <br></li><li>  <em>BSD -</em> kqueue; <br></li><li>  <em>Windows -</em> IOCP; <br></li><li>  <em>Solaris -</em> port acara. <br></li></ul><br>  Ribuan dari mereka semua! <br><br>  Selain itu, Libuv juga menyediakan Perulangan Acara yang sama.  Tidak memiliki spesifikasi Node.js, tetapi ada beberapa fase, dan Node.js hanya menggunakannya.  Tetapi karena suatu alasan dia mengambil nama-nama itu dari sana. <br><br>  Mari kita lihat apa arti setiap fase sebenarnya. <br><br><h4>  Tahap Timers melakukan: <br></h4><br><ul><li>  Timer siap panggil balik; <br></li><li>  setTimeout dan setInterval; <br></li><li>  Tapi <strong>BUKAN</strong> setImmediate adalah fase yang berbeda. <br></li></ul><br><h4>  Fase panggilan balik yang tertunda <br></h4><br>  Sebelum ini, fase dokumentasi disebut callback I / O.  Baru-baru ini, dokumentasi ini diperbaiki, dan tidak lagi bertentangan dengan dirinya sendiri.  Sebelum ini, di satu tempat ada tertulis bahwa I / O callback dieksekusi dalam fase ini, di tempat lain - yang dalam fase polling.  Tapi sekarang semuanya ditulis di sana dengan tegas dan baik, jadi bacalah dokumentasinya - sesuatu akan menjadi lebih mudah dimengerti. <br><br>  Dalam fase panggilan balik yang tertunda, panggilan balik dari beberapa operasi sistem (kesalahan TCP) dieksekusi.  Artinya, jika di Unix ada kesalahan pada TCP-socket, dalam hal ini ia tidak ingin segera membuangnya, tetapi dalam callback, yang akan dieksekusi hanya pada fase ini.  Hanya itu yang perlu kita ketahui tentangnya.  Kami praktis tidak tertarik. <br><br><h4>  Phase Idle, siapkan <br></h4><br>  Dalam fase ini, kita tidak bisa melakukan apa pun, jadi kita akan melupakannya secara prinsip. <br><br><img src="https://habrastorage.org/webt/xa/6l/n-/xa6ln-ao3qbubxteqecnh8lm5ke.png"><br><br><h4>  Fase pemilihan <br></h4><br>  Ini adalah fase paling menarik di Node.js karena ia melakukan pekerjaan bermanfaat utama: <br><br><ul><li>  Melakukan panggilan balik I / O (bukan fase panggilan balik yang tertunda!). </li><li>  Menunggu acara dari I / O; </li><li>  Sangat keren untuk melakukan setImmediate; </li><li>  Tidak ada timer; </li></ul><br>  Ke depan, setImmediate akan dieksekusi pada fase pemeriksaan berikutnya, yaitu dijamin sebelum timer. <br><br>  Dan juga fase polling mengontrol aliran acara.  Misalnya, jika kita tidak memiliki penghitung waktu, tidak ada setImmediate, yaitu, tidak ada yang melakukan timer, setImmediate tidak menelepon, kita hanya memblokir dalam fase ini dan menunggu acara dari I / O, jika sesuatu datang kepada kita, jika ada panggilan balik jika kami mendaftar untuk sesuatu. <br><br>  Bagaimana model non-pemblokiran diterapkan?  Misalnya, di Epoll yang sama, kita dapat berlangganan ke suatu acara - buka soket dan tunggu sesuatu dituliskan padanya.  Selain itu, argumen kedua adalah batas waktu, mis.  kita akan menunggu Epoll, tetapi jika batas waktu berakhir, dan acara dari I / O tidak datang, maka itu akan keluar dari batas waktu.  Jika suatu peristiwa datang kepada kita dari jaringan (seseorang menulis ke soket), maka itu akan datang. <br><br>  Oleh karena itu, fase jajak pendapat mengambil callback paling awal dari heap (heap adalah struktur data yang memungkinkan pengiriman dan pengiriman yang diurutkan dengan baik), mengambil batas waktu, menulis ke batas waktu ini dan melepaskan semuanya.  Jadi, bahkan jika tidak ada yang menulis kepada kami di soket, batas waktu akan berfungsi, kembali ke fase pemilihan dan pekerjaan akan dilanjutkan. <br><br><blockquote>  Penting untuk dicatat bahwa dalam fase polling ada batasan jumlah panggilan balik pada suatu waktu. <br></blockquote><br>  Sangat menyedihkan bahwa dalam fase yang tersisa tidak.  Jika Anda menambahkan 10 miliar batas waktu, Anda menambahkan batas waktu 10 miliar.  Oleh karena itu, fase selanjutnya adalah fase periksa. <br><br><h4>  Periksa fase </h4><br>  Di sinilah setImmediate dijalankan.  Fase indah di setImmediate itu, yang disebut dalam fase polling, dijamin untuk dieksekusi lebih awal dari timer.  Karena timer hanya akan berada pada tick berikutnya di awal, dan lebih awal dari fase polling.  Oleh karena itu, kita tidak boleh takut berkompetisi dengan timer lain dan menggunakan fase ini untuk hal-hal yang tidak kita inginkan untuk alasan tertentu untuk dieksekusi dalam panggilan balik. <br><br><h4>  Panggilan balik fase dekat </h4><br>  Fase ini tidak menjalankan semua panggilan balik penutup soket kami dan jenis lainnya: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, …).</code> </pre><br>  Dia mengeksekusi mereka hanya jika acara ini terbang secara tak terduga, misalnya, seseorang di ujung lainnya mengirim: "Semuanya - tutup soket - pergi dari sini, Vasya!"  Maka fase ini akan berhasil, karena acara tidak terduga.  Tapi ini tidak terlalu mempengaruhi kita. <br><br><h3>  Pemrosesan potongan asinkron yang salah di Node.js </h3><br>  Apa yang akan terjadi jika kita meletakkan pola yang sama yang kita ambil di browser dengan setTimeout di Node.js - yaitu, kita membagi array menjadi potongan-potongan, untuk setiap potongan kita membuat setTimeout - 0. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigArray = [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_000_000] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chunks = getChunks(bigArray) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data for (chunk of chunks) { setTimeout(() =&gt; parseData(slice), 0) }</span></span></code> </pre><br>  Apakah Anda pikir ada masalah dengan ini? <br><br>  Saya sudah berlari sedikit ketika saya mengatakan bahwa jika Anda menambahkan 10 ribu batas waktu (atau 10 miliar!), Akan ada 10 ribu penghitung waktu dalam antrian, dan dia akan mendapatkan dan mengeksekusi mereka - tidak ada perlindungan dari ini: dapatkan - jalankan, dapatkan - untuk memenuhi dan seterusnya ad infinitum. <br><br>  Hanya fase polling, jika kita secara konstan mendapatkan event dari I / O, setiap saat seseorang menulis sesuatu di socket sehingga kita dapat mengeksekusi setidaknya timer dan setImmediate, ia memiliki batasan perlindungan, dan itu tergantung pada sistem.  Artinya, itu akan berbeda pada sistem operasi yang berbeda. <br><br>  Sayangnya, fase-fase lain, termasuk timer dan setImmediate, <strong>tidak memiliki perlindungan seperti itu.</strong>  Karena itu, jika Anda melakukan seperti pada contoh, semuanya akan membeku dan tidak akan mencapai fase polling untuk waktu yang sangat lama. <br><br>  Tetapi apakah Anda berpikir bahwa sesuatu akan berubah jika kami mengganti setTimeout (() =&gt; parseData (slice), 0) dengan setImmediate (() =&gt; parseData (slice))?  - Tentu, tidak, tidak ada perlindungan pada tahap pemeriksaan di sana. <br><br>  Untuk mengatasi masalah ini, Anda dapat memanggil <strong>pemrosesan rekursif</strong> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data const recursiveAsyncParseData = (i) =&gt; { parseData(getChunk(i)) setImmediate(() =&gt; recursiveAsyncParseData(i + 1)) } recursiveAsyncParseData(0)</span></span></code> </pre><br>  Intinya adalah bahwa kita mengambil fungsi parseData dan menulis panggilan rekursifnya, tetapi bukan hanya diri kita sendiri, tetapi melalui setImmediate.  Ketika Anda memanggil ini dalam fase setImmediate, itu akan ke centang berikutnya, dan bukan ke yang sekarang.  Oleh karena itu, ini akan merilis Loop Peristiwa, itu akan melangkah lebih jauh dalam lingkaran.  Artinya, kita memiliki recursiveAsyncParseData, di mana kita melewati indeks tertentu, dapatkan potongan dengan indeks ini, uraikan - dan kemudian masukkan antrian setImmediate dengan indeks berikutnya.  Ini akan sampai ke tick kita berikutnya dan kita bisa memproses semua ini secara rekursif. <br><br>  Benar, masalahnya adalah ini masih semacam tugas yang terikat CPU.  Mungkin dia masih akan menimbang dan mengambil waktu di Event Loop.  Kemungkinan besar Anda ingin Node.js Anda murni terikat I / O. <br>  Oleh karena itu, lebih baik menggunakan beberapa hal lain, misalnya, <strong>proses fork / thread pool.</strong> <br><br>  Sekarang kita tahu tentang Node.js bahwa: <br><br><ul><li>  semuanya didistribusikan secara bertahap - yah, kita jelas tahu ini; <br></li><li>  ada perlindungan terhadap fase polling yang terlalu lama, tetapi tidak sisanya; <br></li><li>  pola pemrosesan rekursif dapat diterapkan agar tidak memblokir Event Loop; </li><li>  Tetapi lebih baik menggunakan garpu proses, pool thread, proses anak </li></ul><br>  Anda juga harus berhati-hati dengan kumpulan utas, karena Node.js memulai sesuatu di sana, khususnya, penyelesaian DNS, karena untuk Linux, untuk beberapa alasan, fungsi penyelesaian DNS tidak asinkron.  Oleh karena itu, itu harus dijalankan di ThreadPool.  Di Windows, untungnya, tidak begitu.  Tetapi di sana Anda dapat membaca file secara tidak sinkron.  Di Linux, sayangnya, itu tidak mungkin. <br><br>  Menurut pendapat saya, batas standar adalah 4 proses di ThreadPool.  Karena itu, jika Anda aktif melakukan sesuatu di sana, itu akan bersaing dengan orang lain - dengan fs dan lainnya.  Anda dapat mempertimbangkan meningkatkan ThreadPool, tetapi juga dengan sangat hati-hati.  Jadi baca sesuatu tentang topik ini. <br><br><h2>  Microtask: sirkulasi paru-paru </h2><br>  Kami memiliki tugas di Node.js dan tugas di browser.  Anda mungkin sudah pernah mendengar tentang mikrotask.  Mari kita lihat apa itu dan bagaimana cara kerjanya, dan mulai dengan browser. <br><br><h3>  Microtask di browser <br></h3><br>  Untuk memahami cara kerja mikrotask, kita beralih ke algoritma acara loop sesuai dengan standar whatwg, yaitu, mari kita pergi ke spesifikasi dan melihat bagaimana semuanya terlihat. <br><br><img src="https://habrastorage.org/webt/cb/kj/76/cbkj76j9xqsivioo2demagbbfty.png"><br><br>  Menerjemahkan ke dalam bahasa manusia, tampilannya seperti ini: <br><br><ul><li>  Ambil tugas gratis dari baris kami </li><li>  Kami melaksanakannya </li><li>  Kami melakukan pemeriksaan mikrotask - OK, kami masih tidak tahu apa itu, tapi kami ingat itu. </li><li>  Kami memperbarui rendering (jika perlu), dan kembali ke titik awal. </li></ul><br><img src="https://habrastorage.org/webt/1h/rs/ce/1hrsceluhstlxrdjjr7ig2wh9l0.png"><br><br>  Mereka dilakukan di tempat yang ditunjukkan pada diagram, dan di beberapa tempat lagi, yang akan segera kita pelajari.  Artinya, tugas selesai, mikrotask dieksekusi. <br><br><h3>  Sumber microtucks </h3><br><ul><li>  <strong>Janji. Lalu.</strong> </li></ul><br>  Penting - bukan Janji itu sendiri, yaitu Janji.  Panggilan balik yang ditempatkan kemudian adalah mikrotask.  Jika Anda menelepon 10 maka - Anda memiliki 10 mikrokars, 10 ribu kemudian - 10 ribu mikrokar. <br><br><ul><li>  <strong>Pengamat mutasi.</strong> <br></li><li>  <strong>Object.observe</strong> , yang sudah usang dan tidak ada yang perlu. <br></li></ul><br>  Berapa banyak yang menggunakan pengamat Mutasi? <br><br>  Saya pikir sedikit yang menggunakan pengamat Mutasi.  Kemungkinan besar, Promise. Kemudian digunakan lebih banyak, itu sebabnya kami akan mempertimbangkannya dalam contoh. <br><br>  <strong>Fitur pos pemeriksaan mikrotask:</strong> <br><br><ul><li>  <strong>Kami melakukan segalanya</strong> - ini berarti kami melakukan semua mikrotasks yang kami miliki dalam antrian sampai akhir.  Kami tidak melepaskan apa pun - kami hanya mengambil dan melakukan semua itu, mereka harus mikro, kan? </li><li>  Anda masih dapat menghasilkan mikrotask baru dalam proses, dan mereka akan dieksekusi di pos pemeriksaan mikrotask yang sama. </li><li>  Yang juga penting - mereka dieksekusi tidak hanya setelah eksekusi tugas, tetapi juga setelah membersihkan tumpukan. </li></ul><br>  Ini adalah hal yang menarik.  Ternyata dimungkinkan untuk menghasilkan mikrotasks baru dan kita semua akan memenuhinya semua.  Apa yang bisa membawa kita ke sini? <br><br><img src="https://habrastorage.org/webt/yr/i_/i9/yri_i9mhp2jz-6nyyj7pvfwl6yg.png"><br>  Kami memiliki dua hati.  Saya menghidupkan hati pertama dengan animasi JS, dan yang kedua dengan animasi CSS.  Ada fitur hebat lain yang disebut starveMicrotasks.  Kami menyebutnya Promise.resolve, dan kemudian menempatkan fungsi yang sama di kemudian. <br>  Lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> apa yang terjadi jika Anda memanggil fungsi ini. <br><br>  Ya, jantung JS akan berhenti, karena kami menambahkan mikrotask, dan kemudian kami menambahkan mikrotask di dalamnya, dan kemudian kami menambahkan mikrotask di dalamnya ... Dan tanpa henti. <br><br>  Artinya, panggilan microtucks rekursif akan menggantung segalanya.  Tapi sepertinya saya memiliki semuanya asinkron!  Seharusnya dilepaskan, saya menelepon setTimeout di sana.  Tidak!  Sayangnya, Anda perlu berhati-hati dengan microtask, jadi jika Anda entah bagaimana menggunakan panggilan rekursif, berhati-hatilah - Anda dapat memblokir semuanya. <br><br>  Selain itu, seperti yang kita ingat, microtask dieksekusi di akhir pembersihan tumpukan.  Kami ingat apa itu tumpukan.  Ternyata segera setelah kami keluar dari kode kami, panggilan balik setTimeout dieksekusi - itu saja - mikrotasks langsung ke sana.  Ini dapat menyebabkan efek samping yang menarik. <br><br>  Pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah contoh</a> . <br><br><img src="https://habrastorage.org/webt/kf/e-/tq/kfe-tqsysmprki74ayahty-n9ke.png"><br><br>  Ada tombol dan wadah abu-abu di mana ia berada.  Kami berlangganan klik tombol dan wadah. ,   , ,       . <br><br>     2 : <br><br><ol><li> Promise.resolve; </li><li> .then,    console.log('RO') </li></ol><br>       «FUS»,      – «DAH!» (    ). <br><br>   ,      ?      ,    ,   «FUS RO DAH!»  Hebat!  ,   . <br><br><img src="https://habrastorage.org/webt/3g/b6/w3/3gb6w3gi4es-fzxcicyk2batfm8.png"><br><br>       ,            ,        .   –  . , -   ? <br><br><img src="https://habrastorage.org/webt/uo/-t/dx/uo-tdxdjrfwgt0vvse4a6vuqips.png"><br><br>  !         . <br><br><img src="https://habrastorage.org/webt/yk/ob/w3/ykobw30-vcw5h6t6vvlitwk-y2a.png"><br><br>  ,   . <br><br> ,      ,     ,     .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> . <br><br><ul><li>         — buttonHandleClick,    . </li><li>    Promise.resolve.     .   ,      console.log('RO')  .   . </li><li>      console.log('FUS'). </li><li>   buttonHandleClick       .        . </li><li>   ,      (divHandleClick)    ,  «DAH!». </li><li> HandleClick . </li></ul><br>  ,     .         ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> : <br><br><ul><li>  button.click().     . </li><li>   button HandleClick. </li><li>  Promise.resolve  then.      , Promise.resolve . </li><li>    console.log   «FUS». </li><li>    buttonHandleClick    ,    . </li></ul><br>     (click)  ,       ,    .     divHandleClick , ,  console.log('DAH!') .        ,      . <br><br>   , ,    button.click   . <br>        .   , ,   .  ,    ,    . <br><br>    :     ()       (  ).   - ,      ,   stopPropagation.  ,     ,  ,  ,   -   ,  . <br><br>  ,  -   ( junior-)     —      «»,    promise,  ,    then  ,  -  .    ,  <strong>    ,    </strong> :   ,    ,  .   .        ,   -       . <br><br>    (  4)    ,        .     ,   ,  ,   ,      -   .           . <br><br> <strong>     , :</strong> <br><br><ul><li>      Event Loop.  Ini tidak menyenangkan. </li><li>         ,   . </li></ul><br>           ,    .  —   ,     ,  . <br><br><h2>   Node.js <br></h2><br>   Node.js  Promise.then  process.nextTick.      ,    —    .   ,   , ,   , . <br><br><h3> process.nextTick <br></h3><br> ,     process.nextTick,   setImmediate?      Node.js  ? <br><br>    .     createServer,   EventEmitter,    ,     listen (  ),      . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createServer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> evEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">listen</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function"> =&gt;</span></span> { evEmitter.emit(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evEmitter } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = createServer().listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) server.on(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>))</code> </pre><br>    ,  ,   8080,    listening   console.log  - . <br><br>  ,       ,      - . <br><br>    createServer,    .       listen,      ,        .        . <br><br>  ,    ,    .   ?   process.nextTick:  evEmitter.emit('listening', port)  process.nextTick(() =&gt; evEmitter.emit('listening', port)). <br><br>   ,  <strong>process.nextTick     ,    </strong> .    EventEmitter,     . ,   ,      API,       .    process.nextTick,   emit    ,  userland  .      createServer,  ,  listen,    listening.     —    process.nextTick — !  ,     ,  . <br><br>     process.nextTick  .     ,         . <br><br>   ,  process.nextTick    ,  Promise.then  .     process.nextTick ,     —    ,   Event Loop,  Node.js. , ,   . <br><br> <strong> process.nextTick    </strong> ,   ghbvtybnm  setImmediate   ,        C++  ..  process.nextTick       . <br><br><h2> Async/await </h2><br>      API — async/await, - .    .    , async/await   Promise,     Event Loop      .     ,          . <br><br><h2>   </h2><br><ul><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Philip Roberts. What the heck is the event loop anyway?</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bert Belder. Everything you need to know about Node.js event loop.</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jake Archibald. In the Loop</a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Node.js Event Loop, Timers, and process.nextTick()</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WHATWG Specification event loop processing model</a> <br></li></ul><br> <strong>,     !</strong> <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a>     — 4  5   ,  .    ,        : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grid Layout    </a> /   ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Building decentralised apps with JS</a> /   (ING) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> /   () <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StoreWars (ngxs, redux, vuex)</a> /  ,   (Cinimex) <br></li></ul><br>  Ayo, ini akan menarik! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417461/">https://habr.com/ru/post/id417461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417449/index.html">Dunia Jurassic: Bisakah Kita Benar-Benar Membangkitkan Dinosaurus?</a></li>
<li><a href="../id417451/index.html">Lima Kesalahan Umum untuk Pemula</a></li>
<li><a href="../id417453/index.html">Organisasi magang untuk siswa: menyapu dan trik</a></li>
<li><a href="../id417457/index.html">Frontend Conf Moscow - sisi klien masuk dan keluar</a></li>
<li><a href="../id417459/index.html">Ketahui JIT Anda: lebih dekat ke mobil</a></li>
<li><a href="../id417463/index.html">Pertemuan yang tidak terduga. Bab 17</a></li>
<li><a href="../id417465/index.html">Ikhtisar metode penautan teks</a></li>
<li><a href="../id417469/index.html">Lima alasan egois untuk bekerja secara berulang</a></li>
<li><a href="../id417471/index.html">Solder Sederhana MK936 SMD. Stasiun solder DIY untuk komponen SMD</a></li>
<li><a href="../id417473/index.html">Penyimpanan Tepercaya dengan DRBD9 dan Proxmox (Bagian 1: NFS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>