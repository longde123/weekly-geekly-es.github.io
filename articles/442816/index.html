<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏼 👨🏿‍🤝‍👨🏽 🕸️ Crea tu propio controlador de juego 🐊 🏜️ 🏓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fuente de inspiración 
 En las exhibiciones de juegos, los desarrolladores de Objects in Space mostraron una demostración de su juego con un controlad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crea tu propio controlador de juego</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442816/"><h2>  Fuente de inspiración </h2><br>  En las exhibiciones de juegos, los desarrolladores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Objects in Space</a> mostraron una demostración de su juego con un controlador en la cabina de una enorme nave espacial.  Se complementó con botones iluminadores, dispositivos analógicos, indicadores luminosos de estado, interruptores, etc. ... Esto afecta en gran medida la inmersión en el juego: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/44d/1ad/e9644d1ad417a9a97f888feea64d0e8a.jpg"></div><br>  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">ha</a> publicado un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">tutorial de Arduino</a> en el sitio web del juego con una descripción del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">protocolo de comunicación</a> para dichos controladores. <br><br>  <strong>Quiero crear lo mismo para mi juego</strong> <br><br>  En este ejemplo, gastaré alrededor de $ 40 para agregar interruptores hermosos, grandes y pesados ​​a la cabina de un simulador de carreras.  Los costos principales están asociados con estos interruptores: si usara interruptores / botones simples, ¡el precio sería la mitad!  Este es un equipo real que puede soportar 240 vatios de potencia, y solo dejaré salir aproximadamente 0.03 vatios. <br><br>  Advertencia: decidí ahorrar dinero, así que dejo un enlace a un sitio web chino barato donde compro un montón de diferentes componentes / herramientas.  Uno de los inconvenientes de comprar componentes baratos es que a menudo no tienen documentación, por lo que en este artículo resolveré este problema. <br><a name="habracut"></a><br><h2>  Componentes principales </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Arduino Mega2560</a> - $ 9 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Interruptor de encendido Racing Panel</a> - $ 26 <br></li><li>  Un montón de cables de conexión ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">"macho a macho"</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">"macho a hembra"</a> , etc.) - $ 2 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e18/fb6/f5ce18fb6e69f6d2dd322d5295a8c7db.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/2d0/b89/c432d0b89b271194d7e3c72a96f4a458.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/485/de1/454485de13be106ba6733352efa8c249.jpg"></div><br><h2>  Herramientas destacadas </h2><br><ul><li>  Soldador ( <em>vale la pena elegir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno bueno</a> , pero también es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">barato hacer</a> frente al trabajo</em> ) </li><li>  Soldadura ( <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con colofonia 60/40</a> : es fácil trabajar con ella, aunque es perjudicial para el medio ambiente</em> ). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tubo termorretráctil</a> ( <em>y secador de pelo industrial, secador de pelo o encendedor</em> ) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cinta aislante</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pistola de pegamento</a> ( <em>y varillas</em> ), o algún tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">epoxi</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Multímetro</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pinzas / alicates para pelar cables</a> , o simplemente tijeras, si necesita ahorrar dinero. </li></ul><br><h2>  Software </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Arduino IDE</a> para programar el procesador Arduino </li><li>  Para crear un controlador que aparezca como un controlador / joystick USB de hardware real: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">FLIP</a> para flashear nuevo firmware en el controlador USB Arduino </li><li>  Biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Arduino-usb</a> en github </li></ul></li><li>  Para crear un controlador con el que el juego se comunica directamente ( <em>o que aparece como un controlador / joystick virtual USB</em> ) <ul><li>  Mi biblioteca ois_protocol en github <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Controlador VJoy</a> si desea utilizar el controlador como un controlador / joystick virtual USB. </li></ul></li></ul><br><h2>  Advertencia </h2><br>  Estudié electrónica en la escuela secundaria, aprendí a usar un soldador, aprendí que los cables rojos deben conectarse al rojo y el negro al negro ... Voltios, amperios, resistencia y las ecuaciones que los conectan, eso es todo lo que agotó mi entrenamiento formal en electrónica. <br><br>  Para mí fue un proyecto de capacitación, por lo que podría tener malos consejos o errores. <br><br><h1>  Parte 1. ¡Poner el controlador junto! </h1><br><h2>  Trabajamos con interruptores sin documentación ... </h2><br>  Como se indicó anteriormente, compro piezas baratas de un minorista de bajo margen, por lo que lo primero que debe hacer es descubrir cómo funcionan estos interruptores / botones. <br><br><h3>  Pulsador / interruptor simple </h3><br>  Con el botón, todo es simple: no hay LED y solo dos contactos.  Cambie el multímetro al modo de continuidad / marcación ( <img src="https://habrastorage.org/getpro/habr/post_images/628/15d/e9f/62815de9fa4516b533fa2a44197455da.gif">  ) y toque las sondas de diferentes contactos: OL (bucle abierto, circuito abierto) se mostrará en la pantalla: esto significa que no hay conexión entre las dos sondas.  Luego presionamos el botón, aún tocando las sondas de contacto: ahora debería aparecer algo como 0.1Ω en la pantalla y el multímetro comenzará a emitir un pitido ( <em>lo que indica que hay una resistencia muy baja entre las sondas, un circuito cerrado</em> ). <br><br>  Ahora sabemos que cuando se presiona el botón, el circuito se cierra y, cuando se presiona, se abre.  En el diagrama, esto se puede describir como un simple interruptor: <img src="https://habrastorage.org/getpro/habr/post_images/ff1/078/8d9/ff10788d996450509595baba45cad58e.png"><br><br><h2>  Conectamos el interruptor a Arduino </h2><br>  Encuentre dos pines en la placa Arduino: etiquetados GND y etiquetados "2" (o cualquier otro número arbitrario; estos son pines de E / S de propósito general que podemos controlar a través del software). <br><br>  Si conectamos el interruptor de esta manera, y luego le ordenamos a Arduino que configure el pin 2 como un pin de ENTRADA, obtenemos el circuito que se muestra a la izquierda (en la figura a continuación).  Cuando se presiona el botón, el pin 2 se conectará directamente a tierra / 0 V, y cuando se presione, el pin 2 no se conectará a nada.  Este estado ( <em>no conectado a nada</em> ) se llama "flotante" (estado de alta impedancia) y, desafortunadamente, esta no es una muy buena condición para nuestros propósitos.  Cuando leemos datos de un contacto en el software ( <em>usando digitalRead (2)</em> ), obtenemos BAJO si el contacto está conectado a tierra, y un resultado impredecible (BAJO o ALTO) si el contacto está flotando. <br><br>  Para solucionar esto, podemos configurar el contacto para que esté en modo INPUT_PULLUP, que se conecta a la resistencia dentro del procesador y crea el circuito que se muestra a la derecha.  En este circuito, con el interruptor abierto, el pin 2 tiene una ruta de + 5V, por lo que cuando se lee, el resultado siempre será ALTO.  Cuando el interruptor está cerrado, el contacto seguirá teniendo una ruta con alta resistencia a + 5V, así como una ruta sin resistencia a tierra / 0V, que "gana", por lo que cuando leemos el contacto, obtenemos un BAJO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/a26/fa9/450a26fa93dae881e4f2aca3f68d52ad.png"></div><br>  Para los desarrolladores de software, el orden puede parecer invertido: cuando hacemos clic en el botón, leemos falso / BAJO, y cuando estamos deprimidos, leemos verdadero / ALTO. <br><br>  Puede hacer lo contrario, pero el procesador solo tiene resistencias pull-up incorporadas y no hay resistencias pull-down, por lo que nos quedaremos con este modelo. <br><br>  El programa más simple para Arduino, que lee el estado del interruptor y le dice a la PC sobre su estado, se parece a lo que se muestra a continuación.  Puede hacer clic en el botón de descarga en el IDE de Arduino y luego abrir el Monitor de serie (en el menú Herramientas) para ver los resultados. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); pinMode(<span class="hljs-number"><span class="hljs-number">2</span></span>, INPUT_PULLUP); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> state = digitalRead(pin); Serial.println( state == HIGH ? <span class="hljs-string"><span class="hljs-string">"Released"</span></span> : <span class="hljs-string"><span class="hljs-string">"Pressed"</span></span> ); delay(<span class="hljs-number"><span class="hljs-number">100</span></span>);<span class="hljs-comment"><span class="hljs-comment">//artifically reduce the loop rate so the output is at a human readable rate... }</span></span></code> </pre> <br><h2>  Otros interruptores casi sin documentación ... </h2><br><h3>  Interruptor LED de tres pines </h3><br>  Afortunadamente, en los interruptores principales de mi panel hay marcas de tres contactos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43a/9c1/8e7/43a9c18e7e7c13e8ce02744fe8320bb6.jpg"></div><br>  No estoy completamente seguro de cómo funciona, por lo que cambiaremos el multímetro a modo continuo y tocaremos todos los pares de contactos cuando el interruptor esté encendido y apagado ... sin embargo, esta vez el multímetro no emite ningún pitido cuando tocamos las sondas [GND] y [+] con " encender  La única configuración en la que el multímetro emite <em>un</em> pitido ( <em>detecta una conexión</em> ) es cuando el interruptor está "encendido" y las sondas están en [+] y [lámpara]. <br><br>  El LED dentro del interruptor bloquea las mediciones de continuidad, por lo que de las pruebas anteriores podemos suponer que el LED está conectado directamente al pin [GND], y no a los contactos [+] y [lámpara].  A continuación, cambiaremos el multímetro al modo de prueba de diodos (símbolo <img src="https://habrastorage.org/getpro/habr/post_images/aa4/e65/abe/aa4e65abeb894a55aa7074cbb67543aa.jpg">  ) y verifique nuevamente el par de contactos, pero esta vez la polaridad es importante ( <em>sonda roja y negra</em> ).  Ahora, si conectamos la sonda roja a [lámpara] y la negra a [GND], el LED se iluminará y se mostrarán 2.25V en el multímetro.  Este es el voltaje directo del diodo, o el voltaje mínimo requerido para encenderlo.  Independientemente de la posición del interruptor, 2.25V desde [lámpara] a [GND] hace que el LED se ilumine.  Si conectamos la sonda roja a [+] y la negra a [GND], el LED se encenderá solo cuando el interruptor esté encendido. <br><br>  A partir de estas lecturas, podemos suponer que el interior de este interruptor se parece al siguiente diagrama: <br><br><ol><li>  [+] y [lámpara] están en cortocircuito cuando el interruptor está encendido / cerrado. <br></li><li>  Un voltaje positivo de [lámpara] a [GND] siempre ilumina el LED. <br></li><li>  Un voltaje positivo de [+] a [GND] enciende el LED solo cuando el interruptor está encendido / cerrado. </li></ol><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd6/34a/728/bd634a728856e82e71eecafa5d42d8a4.png"></div><br>  Honestamente, solo podemos adivinar la presencia de una resistencia.  El LED <strong>debe</strong> estar conectado a la resistencia adecuada para limitar la corriente que se le suministra, o se quemará.  La mía no se quemó y parece que funciona correctamente.  En el foro del sitio web del vendedor, encontré una publicación que habla sobre una resistencia instalada que admite hasta 12 V, y esto me ahorró tiempo en verificar / calcular una resistencia adecuada. <br><br><h3>  Conectamos el interruptor a Arduino </h3><br>  La forma más fácil es usar el interruptor con Arduino, ignorando el pin [lámpara]: conectar [GND] al GND en Arduino y conectar [+] a uno de los contactos numerados de Arduino, por ejemplo 3. <br><br>  Si configuramos el pin 3 como INPUT_PULLUP ( <em>igual que para el botón anterior</em> ), obtendremos el resultado que se muestra a continuación.  La esquina superior izquierda muestra el valor que recibiremos al ejecutar "digitalRead (3)" en el código Arduino. <br><br>  Cuando el interruptor está encendido / cerrado, leemos el LOW y el LED se ilumina.  Para usar dicho interruptor en esta configuración, podemos usar el mismo código Arduino que en el ejemplo del botón. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd5/cc5/8ba/fd5cc58ba50f376abbd42806718b0f92.png"></div><br><h3>  Problemas de esta solucion </h3><br>  Después de conectarse al Arduino, el circuito completo se ve así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92c/305/f91/92c305f91bf0cf6fac213e2eba1db65e.png"></div><br>  Sin embargo, aquí podemos ver que cuando el interruptor está cerrado, además de la pequeña resistencia limitadora de corriente frente al LED (supongo que su resistencia es de 100 ohmios), también hay una resistencia pull-up de 20 kOhm, lo que reduce aún más la cantidad de corriente que fluye a través del LED.  Esto significa que aunque el circuito funciona, el LED no será muy brillante. <br><br>  Otro inconveniente de este esquema es que no tenemos control de software sobre el LED: se enciende cuando el interruptor está encendido y se deshabilita en el caso contrario. <br><br>  Puede ver qué sucede si conectamos el pin [lámpara] a 0V o + 5V. <br><br>  Si [lámpara] está conectada a 0V, entonces el LED está constantemente apagado ( <em>independientemente de la posición del interruptor</em> ), y el reconocimiento de posición de Arduino aún se realiza.  ¡Esto nos permite desactivar mediante programación el LED! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/de7/6d3/a55de76d395358050d3c96139e47df73.png"></div><br>  Si la [lámpara] está conectada a + 5V, entonces el LED está encendido constantemente ( <em>independientemente de la posición del interruptor</em> ), <strong>sin embargo, el</strong> reconocimiento de la posición de Arduino está roto: ALTO siempre se leerá desde el contacto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/310/ea5/4a8/310ea54a861f7f89bc624261abd71ce5.png"></div><br><h3>  Conectamos este interruptor a Arduino correctamente </h3><br>  ¡Podemos superar las limitaciones descritas anteriormente ( <em>baja corriente / brillo del LED y la falta de control del programa sobre el LED</em> ) escribiendo más código!  Para resolver el conflicto entre la capacidad de controlar el LED y el reconocimiento de posición que se rompió debido a él, podemos separar las dos tareas a tiempo, es decir, apagar temporalmente el LED al leer el contacto del sensor (3). <br><br>  Primero, conecte el pin [lámpara] a otro pin Arduino de uso general, por ejemplo, a 4 para poder controlar la lámpara. <br><br>  Para crear un programa que lea correctamente la posición del interruptor y controle el LED (haremos que parpadee), solo tenemos que apagar el LED antes de leer el estado del interruptor.  El LED se apagará solo una fracción de milisegundo, por lo que el parpadeo no debería ser notable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pinSwitch = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pinLed = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//connect to the PC Serial.begin(9600); //connect our switch's [+] connector to a digital sensor, and to +5V through a large resistor pinMode(pinSwitch, INPUT_PULLUP); //connect our switch's [lamp] connector to 0V or +5V directly pinMode(pinLed, OUTPUT); } void loop() { int lampOn = (millis()&gt;&gt;8)&amp;1;//make a variable that alternates between 0 and 1 over time digitalWrite(pinLed, LOW);//connect our [lamp] to +0V so the read is clean int state = digitalRead(pinSwitch); if( lampOn ) digitalWrite(pinLed, HIGH);//connect our [lamp] to +5V Serial.println(state);//report the switch state to the PC }</span></span></code> </pre> <br>  En Arduino Mega, los pines 2-13 y 44-46 pueden usar la función analogWrite, que en realidad no genera voltaje de 0V a + 5V, pero se aproxima usando una onda cuadrada.  Si lo desea, puede usarlo para controlar el brillo del LED.  Este código hará que la luz palpite, no solo parpadee: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lampState = (millis()&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span>;<span class="hljs-comment"><span class="hljs-comment">//make a variable that alternates between 0 and 255 over time digitalWrite(pinLed, LOW);//connect our [lamp] to +0V so the read is clean int state = digitalRead(pinSwitch); if( lampState &gt; 0 ) analogWrite(pinLed, lampState); }</span></span></code> </pre> <br><h2>  Consejos de montaje </h2><br>  La publicación ya es bastante grande, así que no agregaré el tutorial de soldadura, ¡puedes buscarlo en Google! <br><br>  Sin embargo, daré los consejos más básicos: <br><br><ul><li>  Al conectar cables con contactos metálicos grandes, primero asegúrese de que el soldador esté caliente y caliente el contacto metálico por un tiempo.  El significado de la soldadura es formar una conexión permanente creando una aleación, pero si solo una parte de la conexión está caliente, entonces puede obtener fácilmente una "conexión en frío" que parece una conexión, pero que en realidad no está conectada. <br></li><li>  Al conectar los dos cables, <i>primero</i> coloque en uno de ellos un trozo de tubo termorretráctil; después de la conexión, el tubo no se puede colocar.  Esto parece obvio, pero lo olvido constantemente y tengo que usar cinta aislante en lugar del tubo ... Retire el tubo retráctil de la conexión para que no se caliente antes de tiempo.  Después de verificar la conexión soldada, deslice el tubo sobre él y caliéntelo. <br></li><li>  Los pequeños y delgados cables de conexión que mencioné al principio son adecuados para conexiones sin soldadura (por ejemplo, cuando se conectan a un Arduino), pero bastante frágiles.  Después de soldar, use una pistola de pegamento para repararlos y eliminar todas las tensiones de la conexión.  Por ejemplo, los cables rojos en la imagen a continuación se pueden tirar accidentalmente durante la operación, por lo que después de soldarlos los arreglé con una gota de pegamento caliente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0d/fa0/1d4/a0dfa01d48145b489d680cc6e7f43bc8.jpg"></div></li></ul><br><h1>  Parte 2. ¡Convertimos el dispositivo en un controlador de juego! </h1><br>  Para que el sistema operativo reconozca el dispositivo como un controlador de juegos USB, necesita un código bastante simple, pero, desafortunadamente, también debe reemplazar el firmware del chip USB Arduino por otro, que puede tomar aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">https://github.com/harlequin-tech/arduino-usb</a> . <br><br>  Pero después de cargar este firmware en Arduino, el dispositivo se convierte en un joystick USB y deja de ser Arduino.  Por lo tanto, para reprogramarlo, debe volver a actualizar el firmware original de Arduino.  Estas iteraciones son bastante dolorosas: cargue el código Arduino, actualice el firmware del joystick, pruebe, actualice el firmware del arduino, repita ... <br><br>  A continuación se muestra un ejemplo de un programa para Arduino que se puede usar con este firmware: configura tres botones como entradas, lee sus valores, copia los valores a la estructura de datos esperada por este firmware y luego envía los datos.  Lavar, jabón, repetir. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// define DEBUG if you want to inspect the output in the Serial Monitor // don't define DEBUG if you're ready to use the custom firmware #define DEBUG //Say we've got three buttons, connected to GND and pins 2/3/4 int pinButton1 = 2; int pinButton2 = 3; int pinButton3 = 4; void setup() { //configure our button's pins properly pinMode(pinButton1, INPUT_PULLUP); pinMode(pinButton2, INPUT_PULLUP); pinMode(pinButton3, INPUT_PULLUP); #if defined DEBUG Serial.begin(9600); #else Serial.begin(115200);//The data rate expected by the custom USB firmware delay(200); #endif } //The structure expected by the custom USB firmware #define NUM_BUTTONS 40 #define NUM_AXES 8 // 8 axes, X, Y, Z, etc typedef struct joyReport_t { int16_t axis[NUM_AXES]; uint8_t button[(NUM_BUTTONS+7)/8]; // 8 buttons per byte } joyReport_t; void sendJoyReport(struct joyReport_t *report) { #ifndef DEBUG Serial.write((uint8_t *)report, sizeof(joyReport_t));//send our data to the custom USB firmware #else // dump human readable output for debugging for (uint8_t ind=0; ind&lt;NUM_AXES; ind++) { Serial.print("axis["); Serial.print(ind); Serial.print("]= "); Serial.print(report-&gt;axis[ind]); Serial.print(" "); } Serial.println(); for (uint8_t ind=0; ind&lt;NUM_BUTTONS/8; ind++) { Serial.print("button["); Serial.print(ind); Serial.print("]= "); Serial.print(report-&gt;button[ind], HEX); Serial.print(" "); } Serial.println(); #endif } joyReport_t joyReport = {}; void loop() { //check if our buttons are pressed: bool button1 = LOW == digitalRead( pinButton1 ); bool button2 = LOW == digitalRead( pinButton2 ); bool button3 = LOW == digitalRead( pinButton3 ); //write the data into the structure joyReport.button[0] = (button1?0x01:0) | (button2?0x02:0) | (button3?0x03:0); //send it to the firmware sendJoyReport(joyReport) }</span></span></code> </pre> <br><h1>  Parte 3. ¡Integramos el dispositivo con nuestro propio juego! </h1><br>  Si tienes control sobre el juego con el que el dispositivo debe interactuar, entonces, como alternativa, puedes comunicarte directamente con el controlador, ¡no es necesario que sea visible para el sistema operativo como un joystick!  Al comienzo de la publicación, mencioné Objetos en el espacio;  Este es el enfoque que usaron sus desarrolladores.  Crearon un protocolo de comunicación ASCII simple que permite que el controlador y el juego se comuniquen entre sí.  Simplemente enumere los puertos seriales del sistema ( <em>son puertos COM en Windows; por cierto, <a href="" rel="external nofollow">mire lo horrible que se ve en C</a></em> ), encuentre el puerto al que está conectado el dispositivo llamado "Arduino" y comience a leer / escribir ASCII desde este enlace. <br><br>  En el lado de Arduino, solo usamos las funciones Serial.print que se usaron en los ejemplos anteriores. <br><br>  Al comienzo de esta publicación, también mencioné mi biblioteca para resolver este problema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">https://github.com/hodgman/ois_protocol</a> . <br><br>  Contiene código C ++ que puede integrarse en el juego y usarse como un "servidor", y código Arduino que puede ejecutarse en el controlador para usarlo como un "cliente". <br><br><h2>  Personaliza Arduino </h2><br>  En <a href="" rel="external nofollow">example_hardware.h,</a> creé clases para abstraer botones individuales / botones de radio;  por ejemplo, "Switch" es un botón simple del primer ejemplo. y "LedSwitch2Pin" es un interruptor con un LED controlado del segundo ejemplo. <br><br>  El código de muestra para mi barra de botones es en <a href="" rel="external nofollow">example.ino</a> . <br><br>  Como un pequeño ejemplo, digamos que tenemos un solo botón que debe enviarse al juego y un LED controlado por el juego.  El código Arduino requerido se ve así: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ois_protocol.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//instantiate the library OisState ois; //inputs are values that the game will send to the controller struct { OisNumericInput myLedInput{"Lamp", Number}; } inputs; //outputs are values the controller will send to the game struct { OisNumericOutput myButtonOutput{"Button", Boolean}; } outputs; //commands are named events that the controller will send to the game struct { OisCommand quitCommand{"Quit"}; } commands; int pinButton = 2; int pinLed = 3; void setup() { ois_setup_structs(ois, "My Controller", 1337, 42, commands, inputs, outputs); pinMode(pinButton, INPUT_PULLUP); pinMode(pinLed, OUTPUT); } void loop() { //read our button, send it to the game: bool buttonPressed = LOW == digitalRead(pin); ois_set(ois, outputs.myButtonOutput, buttonPressed); //read the LED value from the game, write it to the LED pin: analogWrite(pinLed, inputs.myLedInput.value); //example command / event: if( millis() &gt; 60 * 1000 )//if 60 seconds has passed, tell the game to quit ois_execute(ois, commands.quitCommand); //run the library code (communicates with the game) ois_loop(ois); }</span></span></span></span></code> </pre> <br><h2>  Personaliza el juego </h2><br>  El código del juego está escrito en el estilo de "encabezado único".  Para importar la biblioteca, incluya <a href="" rel="external nofollow">oisdevice.h</a> en el juego. <br><br>  En un solo archivo CPP, antes de ejecutar el encabezado #include, escriba #define OIS_DEVICE_IMPL y #define OIS_SERIALPORT_IMPL: esto agregará el código fuente de las clases al archivo CPP.  Si tiene sus propias declaraciones, registros, cadenas o vectores, existen varias otras macros OIS_ * que puede definir antes de importar el encabezado para aprovechar las capacidades del motor. <br><br>  Para enumerar los puertos COM y crear una conexión con un dispositivo específico, puede usar el siguiente código: <br><br><pre> <code class="cpp hljs">OIS_PORT_LIST portList; OIS_STRING_BUILDER sb; SerialPort::EnumerateSerialPorts(portList, sb, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = portList.begin(); it != portList.end(); ++it ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> label = it-&gt;name + <span class="hljs-string"><span class="hljs-string">'('</span></span> + it-&gt;path + <span class="hljs-string"><span class="hljs-string">')'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-comment"><span class="hljs-comment">/*device selection choice*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gameVersion = <span class="hljs-number"><span class="hljs-number">1</span></span>; OisDevice* device = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OisDevice(it-&gt;id, it-&gt;path, it-&gt;name, gameVersion, <span class="hljs-string"><span class="hljs-string">"Game Title"</span></span>); ... } }</code> </pre> <br>  Después de recibir una instancia de OisDevice, debe llamar regularmente a su función miembro Poll (por ejemplo, en cada cuadro), puede obtener el estado actual de la salida del controlador usando DeviceOutputs (), usar eventos del dispositivo usando PopEvents () y enviar valores al dispositivo usando SetInput (). <br><br>  Aquí se puede encontrar una aplicación de ejemplo que hace todo esto: <a href="" rel="external nofollow">example_ois2vjoy / main.cpp</a> . <br><br><h1>  Parte 4. ¿Qué sucede si quiero las partes 2 y 3 al mismo tiempo? </h1><br>  Para que el controlador funcione en otros juegos (parte 2), debes instalar tu propio firmware y un programa Arduino, pero para que el juego esté completamente programado por el juego, utilizamos el firmware Arduino estándar y otro programa Arduino.  Pero, ¿qué pasa si queremos tener ambas posibilidades al mismo tiempo? <br><br>  La aplicación de muestra a la que le di el enlace anterior ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">ois2vjoy</a> ) resuelve este problema. <br><br>  Esta aplicación se comunica con el dispositivo OIS (el programa de la Parte 3), y luego en la PC convierte estos datos en datos regulares de controlador / joystick, que luego se transfieren al controlador <em>virtual</em> / dispositivo de joystick.  Esto significa que puede permitir que su controlador use constantemente la biblioteca OIS (no se requiere ningún otro firmware), y si queremos usarlo como un controlador / joystick normal, simplemente ejecute la aplicación ois2vjoy en la PC, que realiza la conversión. <br><br><h1>  Parte 5. Finalización </h1><br>  Espero que alguien haya encontrado este artículo útil o interesante.  ¡Gracias por leer hasta el final! <br><br>  Si tiene curiosidad, ¡lo invito a participar en el desarrollo de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">ois_protocol</a> !  ¡Creo que será genial desarrollar un protocolo único para admitir todo tipo de controladores caseros en los juegos y alentar a los juegos a admitir directamente los controladores caseros! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442816/">https://habr.com/ru/post/442816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442806/index.html">El programa preliminar DUMP-2019 está listo. Oradores de Evil Martians, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../442808/index.html">Te invitamos a la Fiesta Droid, una reunión dedicada a cuestiones prácticas del desarrollo de aplicaciones y dispositivos Android.</a></li>
<li><a href="../442810/index.html">Mitos de la física popular, continuación: Gravedad</a></li>
<li><a href="../442812/index.html">"No veo ninguna razón para usar Python para trabajar con Spark, excepto la pereza"</a></li>
<li><a href="../442814/index.html">Han pasado 10 años, y nadie ha descubierto cómo usar la cadena de bloques. ¿Y aquí otra vez?</a></li>
<li><a href="../442818/index.html">10 errores comunes en inglés escrito y cómo lidiar con ellos</a></li>
<li><a href="../442820/index.html">Corutinas personalizadas en unidad con preferencia y cortesanas</a></li>
<li><a href="../442822/index.html">Centro de datos en el mar y en órbita: ¿tienen un significado práctico?</a></li>
<li><a href="../442824/index.html">Bienvenido a Silicon Valley</a></li>
<li><a href="../442826/index.html">La ingeniería social como dramaturgia, o lo que tienen en común el dominio del phishing y el rifle Chekhov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>