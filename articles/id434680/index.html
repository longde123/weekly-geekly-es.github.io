<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐑 ✊🏽 🥣 Evolusi Penjadwal Tugas 👨🏼‍⚕️ 👷🏼 🤟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi iFunny yang kami kerjakan telah tersedia di toko selama lebih dari lima tahun. Selama masa ini, tim seluler harus melalui berbagai pendekatan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evolusi Penjadwal Tugas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/434680/"><img src="https://habrastorage.org/webt/bv/mr/ps/bvmrpspwu-kyhojb5tiu4lqbdi8.jpeg"><br><br>  Aplikasi iFunny yang kami kerjakan telah tersedia di toko selama lebih dari lima tahun.  Selama masa ini, tim seluler harus melalui berbagai pendekatan dan migrasi antar alat, dan setahun yang lalu ada waktu untuk beralih dari solusi yang ditulis sendiri dan melihat ke arah sesuatu yang lebih "modis" dan tersebar luas.  Artikel ini membahas sedikit tentang apa yang telah dipelajari, solusi apa yang telah dilihat, dan apa yang akhirnya mereka temukan. <a name="habracut"></a><br><br>  <b>Mengapa kita membutuhkan semua ini?</b> <br><br>  Mari kita segera memutuskan untuk menghormati apa artikel ini dan mengapa topik ini ternyata penting bagi tim pengembangan Android: <br><br><ol><li>  Ada banyak skenario ketika Anda perlu menjalankan tugas di luar kerangka antarmuka pengguna yang aktif; </li><li>  sistem memberlakukan sejumlah besar pembatasan pada peluncuran tugas-tugas tersebut; </li><li>  Ternyata cukup sulit untuk memilih antara solusi yang ada, karena masing-masing alat memiliki pro dan kontra. </li></ol><br><h3>  <b>Kronologi perkembangan acara</b> </h3><br>  <b>Android 0</b> <b><br></b> <h3>  AlarmManager, Handler, Layanan </h3><br>  Awalnya, solusi mereka diimplementasikan untuk meluncurkan tugas berbasis latar belakang berdasarkan layanan.  Ada juga mekanisme yang menghubungkan tugas dengan siklus hidup dan dapat membatalkan dan mengembalikannya.  Ini cocok untuk tim untuk waktu yang lama, karena platform tidak memberlakukan batasan pada tugas-tugas tersebut. <br>  Google menyarankan untuk melakukan ini berdasarkan diagram berikut: <br><br><img src="https://habrastorage.org/webt/e-/46/zn/e-46znleyxvynpm35pbebgrkdhk.png"><br><br>  Pada akhir 2018, tidak ada gunanya memahami hal ini, cukup untuk menilai skala bencana. <br>  Bahkan, tidak ada yang peduli berapa banyak pekerjaan yang terjadi di latar belakang.  Aplikasi melakukan apa yang mereka inginkan dan kapan mereka mau. <br><br>  <i><b>Pro</b> :</i> <i><br></i>  <i>tersedia di mana-mana;</i> <i><br></i>  <i>dapat diakses oleh semua.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>sistem membatasi pekerjaan dengan segala cara;</i> <i><br></i>  <i>tidak ada peluncuran berdasarkan kondisi;</i> <i><br></i>  <i>API minimal dan Anda perlu menulis banyak kode.</i> <i><br></i> <br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  Penjadwal Pekerjaan </h3><br>  Setelah 5 (!) Tahun, mendekati tahun 2015, Google memperhatikan bahwa tugas-tugas diluncurkan dengan tidak efisien.  Pengguna mulai mengeluh secara teratur bahwa ponsel mereka hampir habis hanya dengan berbaring di meja atau di saku mereka. <br><br>  Dengan rilis Android 5, alat seperti JobScheduler telah muncul.  Ini adalah mekanisme yang dengan bantuannya dimungkinkan untuk melakukan berbagai pekerjaan di latar belakang, yang awalnya dioptimalkan dan disederhanakan karena sistem terpusat untuk meluncurkan tugas-tugas ini dan kemampuan untuk menetapkan kondisi untuk peluncuran ini. <br><br>  Dalam kode, semua ini terlihat cukup sederhana: sebuah layanan diumumkan di mana peristiwa awal dan akhir datang. <br>  Dari nuansa: jika Anda ingin melakukan pekerjaan secara serempak, maka dari onStartJob Anda harus memulai streaming;  yang utama adalah jangan lupa memanggil metode jobFinished di akhir pekerjaan, jika tidak sistem tidak akan melepaskan WakeLock, tugas Anda tidak akan dianggap selesai dan akan hilang. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Dari mana saja di aplikasi, Anda dapat memulai pekerjaan ini.  Tugas dilakukan dalam proses kami, tetapi dimulai pada tingkat IPC.  Ada mekanisme terpusat yang mengontrol eksekusi mereka dan membangun aplikasi hanya pada saat-saat yang diperlukan untuk ini.  Anda juga dapat mengatur berbagai kondisi pemicu dan mentransfer data melalui Bundle. <br><br><pre> <code class="java hljs">JobInfo task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobInfo.Builder(JOB_ID, serviceName) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); JobScheduler scheduler = (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE); scheduler.schedule(task);</code> </pre> <br>  Secara umum, dibandingkan dengan tidak sama sekali, ini sudah menjadi sesuatu.  Tetapi mekanisme ini hanya tersedia dengan API 21, dan pada saat rilis Android 5.0 akan aneh untuk berhenti mendukung semua perangkat lama (3 tahun telah berlalu, dan kami masih mendukung merangkak). <br><br>  <i><b>Pro</b> :</i> <i><br></i>  <i>APInya sederhana;</i> <i><br></i>  <i>ketentuan untuk peluncuran.</i> <i><br></i> <br>  <b><i>Cons</i></b> : <br>  <s>Tersedia mulai dengan API 21</s> <br>  pada kenyataannya, hanya dengan API 23; <br>  mudah melakukan kesalahan. <br><br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  <b>Manajer jaringan Gcm</b> </h3><br>  Analog dari JobScheduler - GCM Network Manager juga disajikan.  Ini adalah pustaka yang menyediakan fungsionalitas serupa, tetapi sudah bekerja dengan API 9. Benar, sebagai gantinya diperlukan Layanan Google Play.  Rupanya, fungsionalitas yang diperlukan untuk JobScheduler untuk bekerja, mulai memberikan tidak hanya melalui versi Android, tetapi juga di tingkat GPS.  Perlu dicatat bahwa pengembang kerangka kerja berubah pikiran dengan sangat cepat dan memutuskan untuk tidak menghubungkan masa depan mereka dengan GPS.  Terima kasih kepada mereka untuk itu. <br><br>  Semuanya terlihat sangat identik.  Layanan yang sama: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmNetworkManagerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmTaskService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskParams taskParams)</span></span></span><span class="hljs-function"> </span></span>{ doWork(taskParams); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  Peluncuran tugas yang sama: <br><br><pre> <code class="java hljs">OneoffTask task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OneoffTask.Builder() .setService(GcmNetworkManagerService.class) .setTag(TAG) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); GcmNetworkManager mGcmNetworkManager = GcmNetworkManager.getInstance(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); mGcmNetworkManager.schedule(task);</code> </pre> <br>  Kesamaan arsitektur ini ditentukan oleh fungsionalitas yang diwarisi dan keinginan untuk mendapatkan migrasi sederhana antar alat. <br><br>  <i><b>Pro</b> :</i> <i><br></i>  <i>API mirip dengan JobScheduler;</i> <i><br></i>  <i>Tersedia mulai dengan API 9.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>Anda harus memiliki Layanan Google Play</i> <i><br></i>  <i>mudah melakukan kesalahan.</i> <br><br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  <b>WakefulBroadcastReceiver</b> </h3><br>  Selanjutnya, saya akan menulis beberapa kata tentang salah satu mekanisme dasar yang digunakan dalam JobScheduler dan tersedia langsung untuk pengembang.  Ini adalah WakeLock dan WakefulBroadcastReceiver berbasisnya. <br><br>  Menggunakan WakeLock, Anda dapat mencegah sistem agar tidak ditangguhkan, yakni menjaga perangkat dalam keadaan aktif.  Ini perlu jika kita ingin melakukan beberapa pekerjaan penting. <br>  Saat membuat WakeLock, Anda dapat menentukan pengaturannya: pegang CPU, layar, atau keyboard. <br><br><pre> <code class="java hljs">PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE) PowerManager.WakeLock wl = pm.newWakeLock(PARTIAL_WAKE_LOCK, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) wl.acquire(timeout);</code> </pre> <br>  Berdasarkan mekanisme ini, WakefulBroadcastReceiver berfungsi.  Kami memulai layanan dan menahan WakeLock. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleWakefulReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WakefulBroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Intent service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, SimpleWakefulService.class); startWakefulService(context, service); } }</code> </pre> <br>  Setelah layanan menyelesaikan pekerjaan yang diperlukan, kami merilisnya melalui metode serupa. <br><br>  Melalui 4 versi, BroadcastReceiver ini akan menjadi usang, dan alternatif berikut akan dijelaskan pada developer.android.com: <br><br><ul><li>  Penjadwal Pekerjaan; </li><li>  Syncadapter </li><li>  UnduhManager </li><li>  FLAG_KEEP_SCREEN_ON untuk Jendela. </li></ul><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>DozeMode: Tidur saat bepergian</b> </h3><br>  Kemudian Google mulai menerapkan berbagai optimasi untuk aplikasi yang berjalan di perangkat.  Tetapi apa yang dimaksud optimasi untuk pengguna adalah batasan untuk pengembang. <br><br>  Langkah pertama adalah DozeMode, yang menempatkan perangkat ke mode tidur jika tidak digunakan selama waktu tertentu.  Dalam versi pertama, itu berlangsung satu jam, dalam versi berikutnya durasi tidur dikurangi menjadi 30 menit.  Secara berkala, telepon bangun, melakukan semua tugas yang tertunda dan tertidur lagi.  Jendela DozeMode mengembang secara eksponensial.  Semua transisi antar mode dapat dilacak melalui adb. <br><br>  Ketika DozeMode terjadi, pembatasan berikut diberlakukan pada aplikasi: <br><br><ul><li>  sistem mengabaikan semua WakeLock; </li><li>  AlarmManager tertunda; </li><li>  JobScheduler tidak berfungsi; </li><li>  SyncAdapter tidak berfungsi; </li><li>  akses jaringan terbatas. </li></ul><br>  Anda juga dapat menambahkan aplikasi Anda ke daftar putih sehingga tidak termasuk dalam batasan DozeMode, tetapi setidaknya Samsung sepenuhnya mengabaikan daftar ini. <br><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>AppStandby: Aplikasi Tidak Aktif</b> </h3><br>  Sistem mengidentifikasi aplikasi yang tidak aktif, dan memberlakukan semua pembatasan yang sama pada mereka seperti di DozeMode. <br>  Aplikasi dikirim ke isolasi jika: <br><br><ul><li>  tidak memiliki proses di latar depan; </li><li>  tidak memiliki notifikasi aktif; </li><li>  tidak ditambahkan ke daftar pengecualian. </li></ul><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>Optimalisasi Latar Belakang.</b>  <b>Langsing</b> </h3><br>  Svelte adalah proyek di mana Google berusaha mengoptimalkan konsumsi RAM oleh aplikasi dan sistem itu sendiri. <br>  Di Android 7, dalam kerangka proyek ini, diputuskan bahwa Siaran tersirat tidak terlalu efektif, karena disimak oleh sejumlah besar aplikasi dan sistem menghabiskan banyak sumber daya saat peristiwa ini terjadi.  Oleh karena itu, jenis peristiwa berikut ini dilarang untuk dideklarasikan dalam manifes: <br><br><ul><li>  CONNECTIVITY_ACTION; </li><li>  ACTION_NEW_PICTURE; </li><li>  ACTION_NEW_VIDEO. </li></ul><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>FirebaseJobDispatcher</b> </h3><br>  Pada saat yang sama, versi baru kerangka peluncuran tugas diterbitkan - FirebaseJobDispatcher.  Bahkan, itu adalah NetworkManager GCM yang telah selesai, yang dirapikan sedikit dan dibuat sedikit lebih fleksibel. <br><br>  Secara visual, semuanya tampak persis sama.  Layanan yang sama: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Satu-satunya perbedaan di antara dia adalah kemampuan untuk menginstal drivernya.  Pengemudi adalah kelas yang bertanggung jawab atas strategi peluncuran tugas. <br><br>  Peluncuran tugas itu sendiri tidak berubah dari waktu ke waktu. <br><br><pre> <code class="java hljs">FirebaseJobDispatcher dispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirebaseJobDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GooglePlayDriver(context)); Job task = dispatcher.newJobBuilder() .setService(FirebaseJobDispatcherService.class) .setTag(TAG) .setConstraints(Constraint.ON_UNMETERED_NETWORK, Constraint.DEVICE_IDLE) .build(); dispatcher.mustSchedule(task);</code> </pre><br>  <i><b>Pro</b> :</i> <i><br></i>  <i>API mirip dengan JobScheduler;</i> <i><br></i>  <i>Tersedia mulai dengan API 9.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>Anda harus memiliki Layanan Google Play</i> <i><br></i>  <i>mudah melakukan kesalahan.</i> <i><br></i> <br>  Sangat menganjurkan untuk menginstal driver saya untuk menyingkirkan GPS.  Kami bahkan mencari, tetapi akhirnya menemukan yang berikut: <br><br><img src="https://habrastorage.org/webt/3n/39/ua/3n39uanajermu--vb5qrzgfl8jq.png"><br><br><img src="https://habrastorage.org/webt/zm/rq/i3/zmrqi3pnt_0hx8lcspdy8k6xio8.png"><br><br>  Google mengetahui hal ini, tetapi tugas ini tetap terbuka selama beberapa tahun. <br><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>Android Job oleh Evernote</b> </h3><br>  Akibatnya, masyarakat tidak tahan, dan solusi buatan sendiri muncul dalam bentuk perpustakaan dari Evernote.  Itu bukan satu-satunya, tetapi itu adalah solusi dari Evernote yang mampu membangun dirinya sendiri dan “masuk ke masyarakat”. <br><br>  Dalam hal arsitektur, perpustakaan ini lebih nyaman daripada pendahulunya. <br>  Entitas yang bertanggung jawab untuk membuat tugas telah muncul.  Dalam kasus JobScheduler, mereka diciptakan melalui refleksi. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJobCreator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobCreator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: String)</span></span></span><span class="hljs-function">: Job? </span></span>{ when (tag) { SendLogsJob.TAG -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SendLogsJob() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br>  Ada kelas yang terpisah, yang merupakan tugas itu sendiri.  Di JobScheduler, ini semua dibuang ke switch di dalam StartJob. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Params)</span></span></span><span class="hljs-function">: Result </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doWork(params) } }</code> </pre> <br>  Peluncuran tugas identik, tetapi selain acara yang diwariskan, Evernote juga menambahkan sendiri, seperti meluncurkan tugas harian, tugas unik, dan meluncurkan di dalam jendela. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobRequest.Builder(JOB_ID) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED) .build() .scheduleAsync();</code> </pre> <br>  <i><b>Pro</b> :</i> <i><br></i>  <i>API yang nyaman;</i> <i><br></i>  <i>didukung di semua versi;</i> <i><br></i>  <i>Tidak perlu Layanan Google Play.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>solusi pihak ketiga.</i> <i><br></i> <br>  Orang-orang secara aktif mendukung perpustakaan mereka.  Meskipun ada beberapa masalah kritis, ini bekerja pada semua versi dan pada semua perangkat.  Akibatnya, tahun lalu tim Android kami memilih solusi dari Evernote, karena perpustakaan dari Google memotong lapisan besar perangkat yang tidak dapat mereka dukung. <br>  Di dalam, ia mengerjakan solusi dari Google, dalam kasus-kasus ekstrem - dengan AlarmManager. <br><br>  <b>Android 8. Oreo</b> <b><br></b> <h3>  <b>Batas Eksekusi Latar Belakang</b> </h3><br>  Mari kita kembali ke batasan kita.  Dengan munculnya Android baru, optimisasi baru telah datang.  Orang-orang dari Google menemukan masalah lain.  Kali ini semuanya berubah menjadi layanan dan siaran (ya, bukan hal baru). <br><br><ul><li>  <s>startService jika aplikasi di latar belakang</s> </li><li>  <s>siaran tersirat dalam manifes</s> </li></ul><br>  Pertama, dilarang memulai layanan dari latar belakang.  Dalam "kerangka hukum" tetap hanya layanan foreground.  Layanan sekarang dapat dikatakan sudah usang. <br>  Batasan kedua adalah Siaran yang sama.  Kali ini menjadi terlarang untuk mendaftarkan SEMUA Siaran tersirat dalam manifes.  Siaran Tersirat adalah Siaran, yang dimaksudkan tidak hanya untuk aplikasi kita.  Misalnya, ada Tindakan ACTION_PACKAGE_REPLACED, dan ada ACTION_MY_PACKAGE_REPLACED.  Jadi, yang pertama adalah implisit. <br><br>  Tetapi semua Siaran masih dapat didaftarkan melalui Context.registerBroadcast. <br><br>  <b>Android 9. Pai</b> <b><br></b> <h3>  <b>Pekerja</b> </h3><br>  Pada optimasi ini sudah berhenti.  Mungkin perangkat mulai bekerja dengan cepat dan hati-hati dalam hal konsumsi energi;  mungkin pengguna kurang mengeluh tentang hal itu. <br>  Di Android 9, para pengembang kerangka kerja secara menyeluruh mendekati alat untuk meluncurkan tugas.  Dalam upaya untuk menyelesaikan semua masalah yang mendesak, perpustakaan diperkenalkan di Google I / O untuk meluncurkan tugas latar belakang WorkManager. <br><br>  Google baru-baru ini berusaha untuk membentuk visinya tentang arsitektur aplikasi Android dan memberi pengembang alat yang diperlukan untuk ini.  Jadi ada komponen arsitektur dengan LiveData, ViewModel dan Room.  WorkManager terlihat seperti pelengkap yang masuk akal untuk pendekatan dan paradigma mereka. <br><br>  Jika kita berbicara tentang bagaimana WorkManager diatur di dalam, maka tidak ada terobosan teknologi di dalamnya.  Bahkan, ini adalah pembungkus solusi yang ada: JobScheduler, FirebaseJobDispatcher dan AlarmManager. <br><br><div class="spoiler">  <b class="spoiler_title">buatBestTersediaBackgroundScheduler</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Scheduler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBestAvailableBackgroundScheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, WorkManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= MIN_JOB_SCHEDULER_API_LEVEL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemJobScheduler(context, workManager); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tryCreateFirebaseJobScheduler(context); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemAlarmScheduler(context); } }</code> </pre> <br></div></div><br>  Kode seleksi sangat sederhana.  Tetapi harus dicatat bahwa JobScheduler tersedia mulai dengan API 21, tetapi mereka hanya menggunakannya dengan API 23, karena versi pertama agak tidak stabil. <br><br>  Jika versi lebih rendah dari 23, maka melalui refleksi kami mencoba menemukan FirebaseJobDispatcher, jika tidak kami menggunakan AlarmManager. <br><br>  Perlu dicatat bahwa bungkusnya keluar cukup fleksibel.  Kali ini, pengembang memecah segalanya menjadi entitas yang terpisah, dan secara arsitektur terlihat nyaman: <br><br><ul><li>  Pekerja - logika kerja; </li><li>  WorkRequest - logika peluncuran tugas; </li><li>  WorkRequest.Builder - parameter; </li><li>  Batasan - kondisi; </li><li>  WorkManager - seorang manajer yang mengelola tugas; </li><li>  WorkStatus - status tugas. </li></ul><br><br><img src="https://habrastorage.org/webt/n_/ts/xi/n_tsxiw0wsxv6a5abotzdzokcba.png"><br><br>  Kondisi peluncuran diwarisi dari JobScheduler. <br>  Dapat dicatat bahwa pemicu untuk mengubah URI hanya muncul dengan API 23. Selain itu, Anda dapat berlangganan perubahan tidak hanya URI tertentu, tetapi juga semua bersarang di dalamnya menggunakan bendera dalam metode. <br><br>  Jika kita berbicara tentang kita, maka pada tahap alfa, diputuskan untuk beralih ke WorkManager. <br>  Ada beberapa alasan untuk ini.  Evernote memiliki beberapa bug penting yang dijanjikan pengembang untuk diperbaiki dengan transisi ke versi dengan WorkManager terintegrasi.  Dan mereka sendiri setuju bahwa keputusan dari Google meniadakan kelebihan Evernote.  Selain itu, solusi ini sangat sesuai dengan arsitektur kami, karena kami menggunakan Komponen Arsitektur. <br><br>  Lebih lanjut, saya ingin menunjukkan dengan contoh sederhana bagaimana kami mencoba menggunakan pendekatan ini.  Pada saat yang sama, tidak terlalu penting apakah Anda memiliki WorkManager atau JobScheduler. <br><br><img src="https://habrastorage.org/webt/ox/yd/0p/oxyd0pizr6h8tx4egaz_kub5wqy.png" width="300" height="430"><img src="https://habrastorage.org/webt/6m/ec/hd/6mechdqawzamahgaij7df-isocg.png" width="300" height="430"><br><br>  Mari kita lihat contoh dengan kasus yang sangat sederhana: mengklik publikasi ulang atau sejenisnya. <br><br>  Sekarang semua aplikasi berusaha untuk tidak memblokir permintaan ke jaringan, karena hal ini membuat pengguna gugup dan membuatnya menunggu, meskipun saat ini ia dapat melakukan pembelian di dalam aplikasi atau menonton iklan. <br><br>  Dalam kasus seperti itu, data lokal pertama kali berubah - pengguna segera melihat hasil tindakannya.  Kemudian di latar belakang ada permintaan ke server, jika gagal, data diatur ulang ke kondisi semula. <br><br>  Selanjutnya, saya akan menunjukkan contoh tampilannya bersama kami. <br><br>  JobRunner berisi logika untuk meluncurkan tugas.  Metodenya menggambarkan konfigurasi tugas dan lulus parameter. <br><br><div class="spoiler">  <b class="spoiler_title">JobRunner.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">likePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content: IFunnyContent)</span></span></span><span class="hljs-function"> </span></span>{ val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() val input = Data.Builder() .putString(LikeContentJob.ID, content.id) .build() val request = OneTimeWorkRequest.Builder(LikeContentJob::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setInputData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setConstraints</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constraints</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getInstance</span></span></span><span class="hljs-class">().</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enqueue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br></div></div><br>  Tugas itu sendiri dalam WorkManager adalah sebagai berikut: kami mengambil id dari parameter dan memanggil metode di server untuk menyukai konten ini. <br><br>  Kami memiliki kelas dasar yang berisi logika berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>{ val workerInjector = WorkerInjectorProvider.injector() workerInjector.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performJob(inputData) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Data)</span></span></span><span class="hljs-function">: Result }</span></span></code> </pre><br>  Pertama, ini memungkinkan Anda untuk menjauh dari pengetahuan eksplisit Pekerja.  Ini juga berisi logika injeksi ketergantungan melalui WorkerInjector. <br><br><div class="spoiler">  <b class="spoiler_title">WorkerInjectorImpl.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Ovierride</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Worker job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AppCrashedEventSendJob) { Injector.getAppComponent().inject((AppCrashedEventSendJob) job); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CheckNativeCrashesJob) { Injector.getAppComponent().inject((CheckNativeCrashesJob) job); } } }</code> </pre><br></div></div><br>  Ini hanya proksi panggilan ke Dagger, tetapi membantu kami dalam pengujian: kami mengganti implementasi injektor dan mengimplementasikan lingkungan yang diperlukan dalam tugas. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testRegisterPushProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WorkManagerTestInitHelper.initializeTestWorkManager(context) val testDriver = WorkManagerTestInitHelper.getTestDriver() WorkerInjectorProvider.setInjector(TestInjector()) <span class="hljs-comment"><span class="hljs-comment">// mock dependencies val id = jobRunner.runPushRegisterJob() testDriver.setAllConstraintsMet(id) Assert.assertTrue(…) }</span></span></code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jobRunner</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobRunner</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ iFunnyContentDao.like(getContent().id) jobRunner.likePost(getContent()) } }</code> </pre> <br>  Interactor adalah entitas yang ditarik oleh ViewController untuk memulai bagian skrip (dalam hal ini, seperti itu).  Kami menandai konten secara lokal sebagai "diunggah" dan mengirimkan tugas untuk dieksekusi.  Jika tugas gagal, sejenisnya dihapus. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class">() </span></span>{ val likeState = MediatorLiveData&lt;Boolean&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentId = MutableLiveData&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentState: LiveData&lt;IFunnyContent&gt; = attachLiveDataToContentId(); init { likeState.addSource(iFunnyContentState) { likeState.postValue(it!!.hasLike) } } }</code> </pre> <br>  Kami menggunakan Komponen Arsitektur Google: ViewModel dan LiveData.  Seperti inilah tampilan ViewModel kami.  Di sini kita menghubungkan pembaruan objek di DAO dengan status suka. <br><br><div class="spoiler">  <b class="spoiler_title">IFunnyContentViewController.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewController</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">likePostInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: View)</span></span></span><span class="hljs-function"> </span></span>{ viewModel.likeState.observe(lifecycleOwner, { updateLikeView(it!!) }) } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLikePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ likePostInteractor.setContent(getContent()) likePostInteractor.execute() } }</code> </pre> <br></div></div><br>  ViewController, di satu sisi, berlangganan untuk mengubah status sejenisnya, di sisi lain, memulai bagian naskah yang kita butuhkan. <br><br>  Dan itu praktis semua kode yang kita butuhkan.  Tetap menambahkan perilaku Tampilan itu sendiri dengan suka dan implementasi DAO Anda;  jika Anda menggunakan Kamar, maka cukup daftarkan bidang di objek.  Itu terlihat sangat sederhana dan efektif. <br><br><h3>  <b>Untuk meringkas</b> </h3><br>  <b>JobScheduler, Manajer Jaringan GCM, FirebaseJobDispatcher:</b> <br><br><ul><li>  jangan menggunakannya </li><li>  jangan membaca artikel tentang mereka lagi </li><li>  jangan menonton laporan </li><li>  jangan berpikir yang mana untuk dipilih. </li></ul><br>  <b>Pekerjaan Android oleh Evernote:</b> <br><br><ul><li>  Di dalamnya mereka akan menggunakan WorkManager; </li><li>  bug kritis kabur di antara solusi. </li></ul><br>  <b>WorkManager:</b> <br><br><ul><li>  API LEVEL 9+; </li><li>  independen dari Layanan Google Play; </li><li>  Rantai / InputMergers; </li><li>  pendekatan reaktif; </li><li>  dukungan dari Google (saya ingin percaya). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434680/">https://habr.com/ru/post/id434680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434670/index.html">Habrapost Pelaporan Tahunan - 2018</a></li>
<li><a href="../id434672/index.html">Fintech Digest: produk paling populer di tahun 2018, menggandakan volume transfer dari kartu ke kartu, pajak atas mata uang kripto</a></li>
<li><a href="../id434674/index.html">Kami menanggapi vandalisme kabel dengan cepat, di mana-mana dan tanpa perangkap fisik</a></li>
<li><a href="../id434676/index.html">TOP-10 - apa yang harus dipelajari pada tahun 2019</a></li>
<li><a href="../id434678/index.html">Admin pagi: tambahkan ruang pada lusinan server untuk minum kopi</a></li>
<li><a href="../id434682/index.html">Teleportator Kota Pribadi</a></li>
<li><a href="../id434684/index.html">Rust 2019 and Beyond: Batasan Pertumbuhan</a></li>
<li><a href="../id434686/index.html">Kursus Kuliah tentang JavaScript dan Node.js di KPI</a></li>
<li><a href="../id434688/index.html">FreeBSD berencana untuk beralih ke ZFSonLinux</a></li>
<li><a href="../id434690/index.html">Sistem operasi Haiku: porting aplikasi dan pembuatan paket</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>