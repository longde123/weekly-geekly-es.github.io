<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏼 🏁 🙇🏼 F # 5: Operadores 👩🏼 🤬 👵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tenía la intención de escribir 1/2 una publicación de blog decente sobre las declaraciones de F #, pero luego pensé, y honestamente, no podía ver dema...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F # 5: Operadores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470219/">  Tenía la intención de escribir 1/2 una publicación de blog decente sobre las declaraciones de F #, pero luego pensé, y honestamente, no podía ver demasiadas ventajas en simplemente repetir lo que ya está disponible gratuitamente en MSDN, que enumera TODAS las declaraciones de F #. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Puede encontrar una lista completa de todos los operadores y caracteres de F # en esta página de MSDN.</a> <br><br>  Si sigue este enlace, lo primero que comprenderá es que F # tiene muchos operadores y símbolos, demasiados para que yo los incluya en una publicación de blog.  Teniendo esto en cuenta, tomé la intención de crear medio blog decente sobre operadores y decidí reducir un poco el alcance para incluir solo una discusión de los operadores más comunes, por lo que creo que se podría decir que esto será solo 1/4 o 1/8 de una publicación decente, por lo cual me disculpo humildemente. <br><br>  Ahora, antes de comenzar, solo quería decir que voy a pasar por los operadores más comunes;  Lo más probable es que tenga que estudiar el enlace de MSDN que incluí al principio de esta publicación cuando realmente comience a usar F #, pero ahora espero que los que nos detenemos sean suficientes para que podamos comenzar. <br><br><h4>  Operadores aritméticos </h4><br>  <b>+ Suma</b> <b><br></b>  Incontrolable.  Una posible condición de desbordamiento es cuando se suman los números y la suma excede el valor absoluto máximo admitido por el tipo. <br><br>  <b>- Resta</b> <b><br></b>  Incontrolable.  Posible condición de relleno insuficiente cuando se restan tipos sin signo o cuando los valores de coma flotante son demasiado pequeños para ser representados por el tipo. <br><br>  <b>* Multiplicación</b> <b><br></b>  Incontrolable.  Una posible condición de desbordamiento si los números se multiplican y el producto excede el valor absoluto máximo admitido por el tipo. <br><br>  <b>/ División</b> <b><br></b>  La división por cero genera una DivideByZeroException para tipos enteros.  Para los tipos de coma flotante, dividir por cero le da valores especiales de coma flotante + Infinito o -Infinito.  Una condición de relleno insuficiente también es posible cuando el número de coma flotante es demasiado pequeño para ser representado por un tipo. <br><br>  <b>% Módulo</b> <b><br></b>  Devuelve el resto de una operación de división.  El signo del resultado es el mismo que el del primer operando. <br><br>  <b>** Exposición</b> <b><br></b>  Posible condición de desbordamiento cuando el resultado excede el valor absoluto máximo para el tipo.  El operador de exponenciación solo funciona con tipos de punto flotante. <br><br><h4>  Demo </h4><br><pre><code class="erlang hljs">//Arithmetic operators printfn <span class="hljs-string"><span class="hljs-string">"25 + 25 = %i"</span></span> (<span class="hljs-number"><span class="hljs-number">25</span></span> + <span class="hljs-number"><span class="hljs-number">25</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"75 - 25 = %i"</span></span> (<span class="hljs-number"><span class="hljs-number">75</span></span> - <span class="hljs-number"><span class="hljs-number">25</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"12 * 12 = %i"</span></span> (<span class="hljs-number"><span class="hljs-number">12</span></span> * <span class="hljs-number"><span class="hljs-number">12</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"100 / 4 = %i"</span></span> (<span class="hljs-number"><span class="hljs-number">100</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"101 %% 10 = %i"</span></span> (<span class="hljs-number"><span class="hljs-number">101</span></span> <span class="hljs-comment"><span class="hljs-comment">% 10) printfn "2 ** 3 = %f" (2.0 ** 3.0)</span></span></code> </pre> <br>  Y aquí está el resultado del lanzamiento: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/db2/5da/362db25da56e68e0627ca24d9b54d24a.png" alt="imagen"><br><br><h4>  Operadores binarios </h4><br>  La siguiente tabla muestra los operadores de comparación binarios disponibles para tipos enteros y tipos de punto flotante.  Estos operadores devuelven valores de tipo bool. <br><br>  <b>= Igual</b> <b><br></b>  Este no es un operador de asignación.  Se usa solo para comparación.  Este es un operador universal. <br><br>  <b>&gt; más que</b> <b><br></b>  Este es un operador universal. <br><br>  <b>&lt;menos de</b> <b><br></b>  Este es un operador universal. <br><br>  <b>&gt; = mayor o igual</b> <b><br></b>  Este es un operador universal. <br><br>  <b>&lt;= mayor o igual</b> <b><br></b>  Este es un operador universal. <br><br>  <b>&lt;&gt; No es igual</b> <b><br></b>  Este es un operador universal. <br><br><pre> <code class="erlang hljs">//Binary operators printfn <span class="hljs-string"><span class="hljs-string">"25 = 25 = %b"</span></span> (<span class="hljs-number"><span class="hljs-number">25</span></span> = <span class="hljs-number"><span class="hljs-number">25</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"26 &gt; 25 = %b"</span></span> (<span class="hljs-number"><span class="hljs-number">26</span></span> &gt; <span class="hljs-number"><span class="hljs-number">25</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"26 &lt; 25 = %b"</span></span> (<span class="hljs-number"><span class="hljs-number">26</span></span> &lt; <span class="hljs-number"><span class="hljs-number">25</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"26 &gt;= 25 = %b"</span></span> (<span class="hljs-number"><span class="hljs-number">26</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">25</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"26 &lt;= 25 = %b"</span></span> (<span class="hljs-number"><span class="hljs-number">26</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">25</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"'a' &lt;= 'b' = %b"</span></span> ('a' &lt;&gt; 'b') //how about a more complex example, a tuple printfn <span class="hljs-string"><span class="hljs-string">"(1,'a') = (2,'a') = %b"</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span>,'a') = (<span class="hljs-number"><span class="hljs-number">2</span></span>,'a')) printfn <span class="hljs-string"><span class="hljs-string">"(1,'a') = (1,'a') = %b"</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span>,'a') = (<span class="hljs-number"><span class="hljs-number">1</span></span>,'a')) printfn <span class="hljs-string"><span class="hljs-string">"Some(1) = Some(2) = %b"</span></span> (Some(<span class="hljs-number"><span class="hljs-number">1</span></span>) = Some(<span class="hljs-number"><span class="hljs-number">2</span></span>)) printfn <span class="hljs-string"><span class="hljs-string">"Some(2) = Some(2) = %b"</span></span> (Some(<span class="hljs-number"><span class="hljs-number">2</span></span>) = Some(<span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/be1/ccd/430/be1ccd4300f8e5e0bafaeb0d8c368dab.png" alt="imagen"><br><br><h4>  Operadores booleanos </h4><br>  La siguiente tabla enumera los operadores lógicos disponibles en F #.  El único tipo admitido por estos operadores es el tipo bool. <br><br>  <b>no</b> <b><br></b>  Negación booleana <br><br>  <b>||</b> <b><br></b>  O lógico <br><br>  <b>&amp;&amp;</b> <b><br></b>  Lógico y <br><br>  Aquí hay una pequeña demostración de los operadores booleanos mencionados anteriormente. <br><br><pre> <code class="erlang hljs">//Boolean operators printfn <span class="hljs-string"><span class="hljs-string">"not true = %b"</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"true || false = %b"</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span> || <span class="hljs-literal"><span class="hljs-literal">false</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"true &amp;&amp; true = %b"</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; <span class="hljs-literal"><span class="hljs-literal">true</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"true &amp;&amp; false = %b"</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/743/6ad/0ef/7436ad0ef4d05e4207bb989fffa050ca.png" alt="imagen"><br><br><h4>  Operadores de bits </h4><br>  La siguiente tabla describe los operadores bit a bit que son compatibles con los tipos enteros desempaquetados en F #. <br><br>  <b>&amp;&amp;&amp;</b> <b><br></b>  El operador AND bit a bit.  Como resultado, los bits tienen un valor de 1 si y solo si los bits correspondientes en ambos operandos de origen son 1. <br><br>  <b>|||</b> <b><br></b>  El operador OR bit a bit.  Como resultado, los bits tienen un valor de 1 si alguno de los bits correspondientes en los operandos de origen es 1. <br><br>  <b>^^^</b> <b><br></b>  El operador exclusivo bit a bit "OR".  Como resultado, los bits tienen un valor de 1 si y solo si los bits en los operandos originales tienen valores desiguales. <br><br>  <b>~~~</b> <b><br></b>  Operador de negación bit a bit.  Este es un operador unario que produce un resultado en el que todos los 0 bits del operando original se convierten en 1 bit, y todos los 1 bits se convierten en 0 bits. <br><br>  <b>&lt;&lt;&lt;</b> <b><br></b>  Operador de desplazamiento a la izquierda bit a bit.  El resultado es el primer operando con los bits desplazados a la izquierda por el número de bits en el segundo operando.  Los bits desplazados desde la posición más significativa no se convierten en la posición menos significativa.  Los bits menos significativos se rellenan con ceros.  El tipo del segundo argumento es int32. <br><br>  <b>&gt;&gt;&gt;</b> <b><br></b>  Operador de desplazamiento a la derecha bit a bit.  El resultado es un primer operando con bits desplazados a la derecha por el número de bits en el segundo operando.  Los bits desplazados desde la posición menos significativa no se convierten en la posición más significativa.  Para los tipos sin signo, los bits más significativos se rellenan con ceros.  Para los tipos con signo, los bits más significativos se rellenan con unos.  El tipo del segundo argumento es int32. <br><br><pre> <code class="erlang hljs">//Bit shift operators //&amp;&amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> printfn <span class="hljs-string"><span class="hljs-string">"2 &amp;&amp;&amp; 4 (which is 0010 &amp;&amp;&amp; 0100, should be 0) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp;&amp; <span class="hljs-number"><span class="hljs-number">4</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"2 &amp;&amp;&amp; 3 (which is 0010 &amp;&amp;&amp; 0011, should be 2) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp;&amp; <span class="hljs-number"><span class="hljs-number">3</span></span>) //||| or printfn <span class="hljs-string"><span class="hljs-string">"2 ||| 4 (which is 0010 ||| 0100, should be 6) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> ||| <span class="hljs-number"><span class="hljs-number">4</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"2 ||| 3 (which is 0010 ||| 0011, should be 3) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> ||| <span class="hljs-number"><span class="hljs-number">3</span></span>) //^^^ <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> printfn <span class="hljs-string"><span class="hljs-string">"2 ^^^ 4 (which is 0010 ^^^ 0100, should be 6) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> ^^^ <span class="hljs-number"><span class="hljs-number">4</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"2 ^^^ 3 (which is 0010 ^^^ 0011, should be 1) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> ^^^ <span class="hljs-number"><span class="hljs-number">3</span></span>) //^^^ negate printfn <span class="hljs-string"><span class="hljs-string">"~~~4 (which is not 0100, should be 1011 (B hex), or 11 decimal) = %X"</span></span> (~~~<span class="hljs-number"><span class="hljs-number">4</span></span>) //&lt;&lt;&lt; bit shift left printfn <span class="hljs-string"><span class="hljs-string">"4 &lt;&lt;&lt; 1 (which is 0100 &lt;&lt;&lt; by 1 place left , should be 1000 (8 hex), or 8 decimal) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span> &lt;&lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) //&gt;&gt;&gt; bit shift right printfn <span class="hljs-string"><span class="hljs-string">"4 &gt;&gt;&gt; 1 (which is 0100 &gt;&gt;&gt; by 1 place right , should be 0010 (2 hex), or 2 decimal) = %X"</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/f3a/541/cef/f3a541cefd7f2f33c76dd7a7811cc600.png" alt="imagen"><br><br><h4>  Sobrecarga del operador </h4><br>  Como mencioné, habrá momentos en los que necesite implementar su propia lógica de operador.  En otros lenguajes .NET, esto se puede lograr al proporcionar sus propias sobrecargas de operador.  No es sorprendente que deba hacer lo mismo en F #.  Todavía no quería entrar en clases y OO, pero parece ser coherente con la discusión actual, así que veamos cómo puede implementar sus propios operadores en F #. <br><br>  Lo robé nuevamente de MSDN.  El siguiente código ilustra una clase de vector que tiene solo dos operadores: uno para el unario menos y otro para multiplicar por un escalar.  En este ejemplo, se necesitan dos sobrecargas para la multiplicación escalar, ya que el operador debe trabajar independientemente del orden en que aparecen el vector y el escalar. <br><br><pre> <code class="erlang hljs">type Vector(x: float, y : float) = member this.x = x member this.y = y static member (~-) (v : Vector) = Vector(-<span class="hljs-number"><span class="hljs-number">1.0</span></span> * vx, -<span class="hljs-number"><span class="hljs-number">1.0</span></span> * vy) static member (*) (v : Vector, a) = Vector(a * vx, a * vy) static member (*) (a, v: Vector) = Vector(a * vx, a * vy) override this.ToString() = this.x.ToString() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + this.y.ToString()</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470219/">https://habr.com/ru/post/470219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470203/index.html">La aguja de aprobación del karma, como espejo de la evolución del homo</a></li>
<li><a href="../470207/index.html">1C Developer Tales: Epicafe</a></li>
<li><a href="../470209/index.html">Transformación de código en Android 2. Análisis AST</a></li>
<li><a href="../470215/index.html">CAGR como una maldición sobre especialistas, o errores en la predicción de procesos exponenciales</a></li>
<li><a href="../470217/index.html">Falso DS18B20 a prueba de agua: ¿qué hacer?</a></li>
<li><a href="../470221/index.html">Holivar Historia de Runet. Parte 3. Motores de búsqueda: Yandex vs Rambler. ¿Cómo no hacer una inversión?</a></li>
<li><a href="../470223/index.html">Pautas de diseño de juegos móviles UX</a></li>
<li><a href="../470225/index.html">¿Por qué las fotos / videos autodestruibles en Telegram no son seguros?</a></li>
<li><a href="../470227/index.html">¿Cómo entrevistar a un empleador?</a></li>
<li><a href="../470233/index.html">Cómo escribir un robot comercial: herramientas para principiantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>