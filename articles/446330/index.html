<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>  ワ M谩quinas autom谩ticas contra el c贸digo de espagueti  大Ⅲン </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Me encantan los spaghetti westerns, odio el c贸digo de spaghetti" 

 El "c贸digo de espagueti" es una expresi贸n ideal para describir el software que es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M谩quinas autom谩ticas contra el c贸digo de espagueti</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/15b/078/04915b0789f8de5be2bc6950b3265a8a.png"></div><br>  <i>"Me encantan los spaghetti westerns, odio el c贸digo de spaghetti"</i> <br><br>  El "c贸digo de espagueti" es una expresi贸n ideal para describir el software que es un caos humeante desde un punto de vista cognitivo y est茅tico.  En este art铆culo, hablar茅 sobre un plan de tres puntos para destruir un c贸digo de espagueti: <br><br><ul><li>  Discutimos por qu茅 el c贸digo de espagueti no es tan sabroso. </li><li>  Presentamos una nueva mirada a lo que realmente hace el c贸digo. </li><li>  Estamos discutiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Frame Machine Notation (FMN)</a> , que ayuda a los desarrolladores a desentra帽ar una bola de pasta. </li></ul><br>  Todos sabemos lo dif铆cil que es leer el c贸digo de otra persona.  Esto puede deberse al hecho de que la tarea en s铆 es dif铆cil o porque la estructura del c贸digo es demasiado ... "creativa".  A menudo, estos dos problemas van de la mano. <br><br>  Los desaf铆os son tareas dif铆ciles y, por lo general, nada m谩s que un descubrimiento revolucionario puede simplificarlos.  Sin embargo, sucede que la estructura del software en s铆 agrega complejidad innecesaria, y <em>vale la pena</em> resolver este problema. <br><br>  La fealdad del c贸digo de espagueti radica en su compleja l贸gica condicional.  Y aunque la vida puede ser dif铆cil de imaginar sin las muchas construcciones dif铆ciles de si-entonces-otro, este art铆culo le mostrar谩 una mejor soluci贸n. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/af0/c3c/6ccaf0c3c57a472e1eb5b80a238a86c5.png"></div><br>  Para ilustrar la situaci贸n con el c贸digo de espagueti, primero debemos cambiar esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/eac/43c/cf9eac43c588d9fecbbfc9bf15753ee1.jpg"></div><br>  <i>Pasta crujiente</i> <br><br>  En esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/683/f12/7fc683f12aa20bcf4abcf5a774c7a039.jpg"></div><br>  <i>Al dente!</i> <br><br>  Empecemos a cocinar. <br><br><h3>  Estado impl铆cito </h3><br>  Para hacer pasta, definitivamente necesitamos agua para cocinar.  Sin embargo, incluso un elemento aparentemente simple que involucra un c贸digo de espagueti puede ser muy confuso. <br><br>  Aqu铆 hay un ejemplo simple: <br><br><pre><code class="cpp hljs">(temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br>  驴Qu茅 hace realmente esta verificaci贸n?  Obviamente, divide la recta num茅rica en dos partes, pero 驴 <em>qu茅 significan</em> estas partes?  Creo que puede hacer una suposici贸n l贸gica, pero el problema es que el c贸digo en realidad no se comunica <em>expl铆citamente</em> . <br><br>  Si realmente confirmo que ella verifica si el agua es SLIDA <i>[aprox.</i>  <i>carril: seg煤n la escala Fahrenheit, el agua se congela a +32 grados]</i> , 驴qu茅 significar谩 l贸gicamente el retorno falso? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) }</span></span></code> </pre> <br>  Aunque el cheque dividi贸 los n煤meros en dos grupos, de hecho, hay tres estados l贸gicos: s贸lido, l铆quido y gaseoso (SLIDO, LQUIDO, GAS). <br><br>  Es decir, esta recta num茅rica: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/b04/343/fadb04343c512bbf297dbf17a250d742.png"></div><br>  dividido por verificaci贸n de condici贸n de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e83/2cc/56ae832ccebc547053d46dec39993ec3.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/dcf/20d/a55dcf20d2de1f679a233913c045546f.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Observe lo que sucedi贸 porque es muy importante para comprender la naturaleza del c贸digo de espagueti.  Una verificaci贸n booleana dividi贸 el espacio num茅rico en dos partes, pero NO categoriz贸 el sistema como una estructura l贸gica real de (SLIDO, LQUIDO, GAS).  En cambio, el cheque dividi贸 el espacio en (SLIDO, todo lo dem谩s). <br><br>  Aqu铆 hay una verificaci贸n similar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// GAS water } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Visualmente, se ver谩 as铆: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/127/810/51d127810231b42191868d0972e3865f.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/187/bd4/42a187bd4559e2dfa9e6acffcd24c8b2.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Tenga en cuenta que: <br><br><ol><li>  el conjunto completo de posibles estados no se anuncia en ninguna parte </li><li>  en ninguna parte de las construcciones condicionales se declaran estados l贸gicos verificables o grupos de estados </li><li>  algunos estados se agrupan indirectamente por la estructura de la l贸gica condicional y la ramificaci贸n </li></ol><br>  Tal c贸digo es fr谩gil, pero muy com煤n, y no tan grande como para causar problemas con su soporte.  As铆 que empeoremos la situaci贸n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/852/bd5/7a1/852bd57a151d005a34ddd883aea5d1ab.png"></div><br>  <i>Nunca me gust贸 tu c贸digo de todos modos</i> <br><br>  El c贸digo que se muestra arriba implica la existencia de tres estados de la materia: SLIDO, LQUIDO, GAS.  Sin embargo, seg煤n datos cient铆ficos, de hecho, hay <strong><em>cuatro</em></strong> estados observables en los que se incluye plasma (PLASMA) (de hecho, hay muchos otros, pero esto ser谩 suficiente para nosotros).  Aunque nadie est谩 preparando una pasta de plasma, si este c贸digo se publica en Github, y luego alg煤n estudiante de posgrado que estudie f铆sica de alta energ铆a lo bifurcar谩, tambi茅n tendremos que mantener este estado. <br><br>  Sin embargo, cuando se agrega plasma, el c贸digo que se muestra arriba ingenuamente har谩 lo siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) + (PLASMA?) // how did PLASMA get in here?? } if (temp &gt; 212) { // GAS water + (PLASMA) // again with the PLASMA!! } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Es probable que el antiguo c贸digo, cuando se agrega a muchos estados de plasma, se rompa en las ramas m谩s.  Desafortunadamente, nada en la estructura del c贸digo ayuda a informar la existencia de un nuevo estado o influir en los cambios.  Adem谩s, es probable que cualquier error no sea visible, es decir, encontrarlo ser谩 lo m谩s dif铆cil.  Solo di no a los insectos en el espagueti. <br><br>  En resumen, el problema es este: las comprobaciones booleanas se utilizan para determinar los estados <em>indirectamente</em> .  Los estados l贸gicos a menudo no se declaran y no son visibles en el c贸digo.  Como vimos anteriormente, cuando el sistema agrega nuevos estados l贸gicos, el c贸digo existente puede romperse.  Para evitar esto, los <strong>desarrolladores deben volver a examinar cada comprobaci贸n condicional individual y ramificaci贸n</strong> para asegurarse de que las rutas de c贸digo sigan siendo v谩lidas para <em>todos</em> sus estados l贸gicos.  Esta es la raz贸n principal de la degradaci贸n de los fragmentos de c贸digo grandes a medida que se vuelven m谩s complejos. <br><br>  Aunque no hay formas de deshacerse por completo de las verificaciones de datos condicionales, cualquier t茅cnica que las minimice reducir谩 la complejidad del c贸digo. <br><br>  Veamos ahora una implementaci贸n t铆pica orientada a objetos de una clase que crea un modelo <em>muy</em> simple del volumen de agua.  La clase gestionar谩 los cambios en el estado de la sustancia del agua.  Despu茅s de estudiar los problemas de la soluci贸n cl谩sica a este problema, discutimos una nueva notaci贸n llamada <strong>Frame</strong> y mostramos c贸mo puede hacer frente a las dificultades que hemos descubierto. <br><br><h3>  Primero hierva el agua ... </h3><br>  La ciencia dio nombres a todas las transiciones posibles que una sustancia puede hacer cuando cambia la temperatura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/016/dc5/638016dc5b2a19ecd2b677cc40e2ee26.png"></div><br>  Nuestra clase es muy simple (y no particularmente 煤til).  Responde a los desaf铆os de realizar transiciones entre estados y cambia la temperatura hasta que se vuelve adecuada para el estado objetivo deseado: <br><br>  (Nota: escrib铆 este pseudoc贸digo. selo en su trabajo solo bajo su propio riesgo y riesgo). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> temp:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Water</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(temp:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.temp = temp } <span class="hljs-comment"><span class="hljs-comment">// gas -&gt; solid func depose() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do depose while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // gas -&gt; liquid func condense() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do condense while (temp &gt; WATER_GAS_TEMP) decreaseTemp(1) } // liquid -&gt; gas func vaporize() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do vaporize while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } // liquid -&gt; solid func freeze() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do freeze while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // solid -&gt; liquid func melt() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do melt while (temp &lt; WATER_SOLID_TEMP) increaseTemp(1) } // solid -&gt; gas func sublimate() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do sublimate while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } func getState():string { if (temp &lt; WATER_SOLID_TEMP) return "SOLID" if (temp &gt; WATER_GAS_TEMP) return "GAS" return "LIQUID" } }</span></span></code> </pre> <br>  En comparaci贸n con el primer ejemplo, este c贸digo tiene ciertas mejoras.  Primero, los n煤meros "m谩gicos" codificados (32, 212) se reemplazan por las constantes de los l铆mites de temperatura del estado (WATER_SOLID_TEMP, WATER_GAS_TEMP).  Este cambio comienza a hacer que los estados sean m谩s expl铆citos, aunque indirectamente. <br><br>  Las verificaciones para "programaci贸n defensiva" tambi茅n aparecen en este c贸digo, que restringe la llamada al m茅todo si est谩 en un estado inadecuado para la operaci贸n.  Por ejemplo, el agua no puede congelarse si no es un l铆quido; esto viola la ley (de la naturaleza).  Pero la adici贸n de condiciones de vigilancia complica la comprensi贸n del prop贸sito del c贸digo.  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// liquid -&gt; solid if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError()</span></span></code> </pre> <br>  Esta verificaci贸n condicional hace lo siguiente: <br><br><ol><li>  Comprueba si la <code>temp</code> inferior a la temperatura l铆mite de GAS </li><li>  Comprueba si la <code>temp</code> excede la temperatura l铆mite SLIDO </li><li>  Devuelve un error si una de estas comprobaciones no es verdadera </li></ol><br>  Esta l贸gica es confusa.  En primer lugar, estar en estado l铆quido est谩 determinado por lo que la sustancia <strong>no</strong> es: un s贸lido o un gas. <br><br><pre> <code class="cpp hljs">(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// is liquid?</span></span></code> </pre> <br>  En segundo lugar, el c贸digo verifica si el agua es l铆quida para determinar si es necesario devolver un error. <br><br><pre> <code class="cpp hljs">!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// Seriously?</span></span></code> </pre> <br>  La primera vez para entender esta doble negaci贸n de estados no es f谩cil.  Aqu铆 hay una simplificaci贸n que reduce ligeramente la complejidad de la expresi贸n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLiquidWater = (temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLiquidWater) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateError()</code> </pre> <br>  Este c贸digo es m谩s f谩cil de entender porque el estado <strong>isLiquidWater</strong> es <em>expl铆cito</em> . <br><br>  Ahora estamos explorando t茅cnicas que arreglan un <strong>estado expl铆cito</strong> como la mejor manera de resolver problemas.  Con este enfoque, los estados l贸gicos del sistema se convierten en la estructura f铆sica del software, lo que mejora el c贸digo y simplifica su comprensi贸n. <br><br><h3>  Notaci贸n de m谩quina de marco </h3><br>  <strong>Frame Machine Notation (FMN)</strong> es un lenguaje de dominio espec铆fico (DSL) que define un enfoque categ贸rico, metodol贸gico y simple para definir e implementar varios tipos de <em>m谩quinas</em> .  Para simplificar, llamar茅 a los aut贸matas de Frame simplemente "m谩quinas", porque esta notaci贸n puede definir criterios te贸ricos para cualquier tipo diferente (m谩quinas de estado, aut贸matas de tiendas y la evoluci贸n superior de aut贸matas: m谩quinas de Turing).  Para conocer los diferentes tipos de m谩quinas y su aplicaci贸n, recomiendo estudiar la p谩gina en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Wikipedia</a> . <br><br>  Aunque la teor铆a de los aut贸matas puede ser interesante (una declaraci贸n MUY dudosa), en este art铆culo nos centraremos en la aplicaci贸n pr谩ctica de estos poderosos conceptos para construir sistemas y escribir c贸digo. <br><br>  Para resolver este problema, Frame presenta una notaci贸n estandarizada que funciona en tres niveles integrados: <br><br><ol><li>  Texto DSL para definir controladores Frame con sintaxis elegante y concisa </li><li>  Un conjunto de patrones de codificaci贸n de referencia para implementar clases orientadas a objetos en forma de m谩quinas que Frame llama "controladores" </li><li>  Notaci贸n visual en la que se usa FMN para expresar operaciones complejas que son dif铆ciles de representar gr谩ficamente - <strong>Notaci贸n visual de marco (FVN)</strong> </li></ol><br>  En este art铆culo, considerar茅 los dos primeros puntos: FMN y patrones de referencia, y dejar茅 la discusi贸n de FVN para futuros art铆culos. <br><br>  Frame es una notaci贸n que tiene varios aspectos importantes: <br><br><ol><li>  FMN tiene objetos de primer nivel relacionados con el concepto de aut贸matas, que no est谩n disponibles en lenguajes orientados a objetos. </li><li>  La especificaci贸n FMN define patrones de implementaci贸n est谩ndar en pseudoc贸digo que demuestran c贸mo se puede implementar la notaci贸n FMN. </li><li>  FMN pronto podr谩 compilar (trabajo en progreso) en cualquier lenguaje orientado a objetos </li></ol><br>  Nota: la implementaci贸n de referencia se utiliza para demostrar la equivalencia absoluta de la notaci贸n FMN y una forma sencilla de implementarla en cualquier lenguaje orientado a objetos.  Puedes elegir cualquier m茅todo. <br><br>  Ahora te presentar茅 los dos objetos de primer nivel m谩s importantes en Frame: <strong>Frame Events</strong> y <strong>Frame Controllers</strong> . <br><br><h3>  Eventos de marco </h3><br>  FrameEvents son una parte integral de la simplicidad de la notaci贸n FMN.  FrameEvent se implementa como una estructura o clase que al menos tiene las siguientes variables miembro: <br><br><ul><li>  ID del mensaje </li><li>  diccionario o lista de par谩metros </li><li>  devolver objeto </li></ul><br>  Aqu铆 est谩 el pseudoc贸digo de la clase FrameEvent: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-class"> {</span></span> var _msg:String var _params:Object var _return:<span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg:String, params:Object = null)</span></span></span><span class="hljs-function"> </span></span>{ _msg = msg _params = params } }</code> </pre> <br>  La notaci贸n de marco utiliza el s铆mbolo <strong>@</strong> , que identifica el objeto FrameEvent.  Cada uno de los atributos FrameEvent requeridos tiene un token especial para acceder a 茅l: <br><br><pre> <code class="cpp hljs">@|message| :  -    _msg @[param1] :  []      @^ :              _return</code> </pre> <br>  A menudo no tenemos que especificar con qu茅 FrameEvent funciona.  Como la mayor铆a de los contextos funcionan con un solo FrameEvent a la vez, la notaci贸n definitivamente se puede simplificar para que solo use selectores de atributos.  Por lo tanto, podemos simplificar el acceso: <br><br><pre> <code class="cpp hljs">|buttonClick| <span class="hljs-comment"><span class="hljs-comment">// Select for a "buttonClick" event _msg [firstName] = "Mark" // Set firstName _params property to "Mark" ^ = "YES" // Set the _return object to "YES"</span></span></code> </pre> <br>  Tal notaci贸n puede parecer extra帽a al principio, pero pronto veremos c贸mo una sintaxis tan simple para eventos simplifica enormemente la comprensi贸n del c贸digo FMN. <br><br><h3>  Controladores de marco </h3><br>  Un controlador de marco es una clase orientada a objetos, ordenada de manera bien definida para implementar una m谩quina de marco.  Los tipos de controlador se identifican con el prefijo <strong>#</strong> : <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  esto es equivalente al siguiente pseudoc贸digo orientado a objetos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span>}</code> </pre> <br>  Obviamente esta clase no es particularmente 煤til.  Para que pueda hacer algo, el controlador necesita al menos un estado para responder a los eventos. <br><br>  Los controladores est谩n estructurados de tal manera que contienen bloques de varios tipos, que se identifican mediante un gui贸n que rodea el nombre del tipo de bloque: <br><br><pre> <code class="cpp hljs">#MyController&lt;br&gt; -block <span class="hljs-number"><span class="hljs-number">1</span></span>- -block <span class="hljs-number"><span class="hljs-number">2</span></span>- -block <span class="hljs-number"><span class="hljs-number">3</span></span>-</code> </pre> <br>  Un controlador no puede tener m谩s de una instancia de cada bloque, y los tipos de bloque pueden contener solo ciertos tipos de subcomponentes.  En este art铆culo, examinamos solo el bloque <strong>-machine-</strong> , que solo puede contener estados.  Los estados se identifican por el token de prefijo <strong>$</strong> . <br><br>  Aqu铆 vemos el FMN para un controlador que contiene una m谩quina con un solo estado: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration</span></span></code> </pre> <br>  Aqu铆 est谩 la implementaci贸n del c贸digo FMN anterior: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = S1 // initialize state variable // to $S1 func S1(e:FrameEvent) { // state $S1 does nothing } }</span></span></code> </pre> <br>  La implementaci贸n del bloque de m谩quina consta de los siguientes elementos: <br><br><ol><li>  <strong>_state</strong> variable, que se refiere a una funci贸n del estado actual.  Se inicializa con la primera funci贸n de estado en el controlador. </li><li>  uno o m谩s m茅todos de estado </li></ol><br>  El m茅todo de estado de trama se define como una funci贸n con la siguiente firma: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span></span>;</code> </pre> <br>  Despu茅s de definir estos fundamentos de la implementaci贸n del bloque de m谩quina, podemos ver qu茅 tan bien interact煤a el objeto FrameEvent con la m谩quina. <br><br><h3>  Unidad de interfaz </h3><br>  La interacci贸n de FrameEvents que controla el funcionamiento de la m谩quina es la esencia misma de la simplicidad y el poder de la notaci贸n Frame.  Sin embargo, a煤n no hemos respondido a la pregunta, 驴de d贸nde provienen los FrameEvents? 驴C贸mo entran en el controlador para controlarlo?  Una opci贸n: los clientes externos pueden crear e inicializar FrameEvents, y luego llamar directamente al m茅todo se帽alado por la variable miembro _state: <br><br><pre> <code class="cpp hljs">myController._state(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Una alternativa mucho mejor ser铆a crear una interfaz com煤n que envuelva una llamada directa a la variable miembro _state: <br><br><pre> <code class="cpp hljs">myController.sendEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Sin embargo, la forma m谩s sencilla, que corresponde a la forma habitual de crear software orientado a objetos, es crear m茅todos comunes que env铆en un evento en nombre del cliente a la m谩quina interna: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FrameEvent e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>) _state(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e._return } }</code> </pre> <br>  Frame define la sintaxis para <strong>un bloque de interfaz</strong> que contiene m茅todos que convierten las llamadas en una interfaz com煤n para FrameEvents. <br><br><pre> <code class="cpp hljs">#MyController -interface- buttonClick ...</code> </pre> <br>  El bloque de <code>interface</code> tiene muchas otras caracter铆sticas, pero este ejemplo nos da una idea general de c贸mo funciona.  Dar茅 m谩s explicaciones en los siguientes art铆culos de la serie. <br><br>  Ahora continuemos estudiando el funcionamiento del aut贸mata Frame. <br><br><h3>  Controladores de eventos </h3><br>  Aunque hemos mostrado c贸mo definir un autom贸vil, todav铆a no tenemos una notaci贸n con la que <em>hacer</em> nada.  Para procesar eventos, necesitamos 1) poder seleccionar el evento que necesita ser procesado y 2) adjuntarlo al comportamiento que se est谩 realizando. <br><br>  Aqu铆 hay un controlador Frame simple que proporciona la infraestructura para manejar eventos: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration |e1| ^ // e1 event handler and return</span></span></code> </pre> <br>  Como se indic贸 anteriormente, para acceder al atributo <code>_msg</code> evento <code>_msg</code> , la notaci贸n FMN usa corchetes de l铆neas verticales: <br><br><pre> <code class="cpp hljs">|messageName|</code> </pre> <br>  FMN tambi茅n usa un token de exponente que representa la declaraci贸n de retorno.  El controlador que se muestra arriba se implementar谩 de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #MyController // -machine- var _state(e:FrameEvent) = S1 func S1(e:FrameEvent) { // $S1 if (e._msg == "e1") { // |e1| return // ^ } } }</span></span></code> </pre> <br>  Aqu铆 vemos cu谩n claramente la notaci贸n FMN corresponde a un patr贸n de implementaci贸n que es f谩cil de entender y codificar. <br><br>  Una vez establecidos estos aspectos b谩sicos de eventos, controladores, m谩quinas, estados y controladores de eventos, podemos proceder a resolver problemas reales con su ayuda. <br><br><h3>  M谩quinas de enfoque 煤nico </h3><br>  Arriba miramos un controlador sin estado que era bastante in煤til. <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  Un paso m谩s arriba en la cadena alimentaria de la utilidad es una clase con un solo estado, que, aunque no es in煤til, es simplemente aburrido.  Pero al menos 茅l al menos est谩 haciendo <em>algo</em> . <br><br>  Primero, veamos c贸mo se implementar谩 una clase con un solo estado (impl铆cito): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span> } }</code> </pre> <br>  Aqu铆 no se declara ni se implica ning煤n estado, pero supongamos que si el c贸digo hace algo, el sistema est谩 en el estado "En funcionamiento". <br><br>  Tambi茅n presentaremos una idea importante: las llamadas a la interfaz se considerar谩n similares a enviar un evento a un objeto.  Por lo tanto, el c贸digo anterior puede considerarse como un m茅todo para transmitir el estado |  la clase Mono, siempre en el estado $ Working. <br><br>  Esta situaci贸n se puede visualizar utilizando la tabla de enlace de eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/81e/7e0/e1b81e7e0916b8354c4092abcc79ab40.png"></div><br>  Ahora veamos FMN, que demuestra la misma funcionalidad y coincide con la misma tabla de enlace: <br><br><pre> <code class="cpp hljs">#Mono -machine- $Working |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>)</code> </pre> <br>  As铆 es como se ve la implementaci贸n: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Mono // -machine- var _state(e:FrameEvent) = Working // initialize start state func Working(e:FrameEvent) { // $Working if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } }</span></span></code> </pre> <br>  Puede notar que tambi茅n introdujimos una nueva notaci贸n para la <strong>declaraci贸n return</strong> , lo que significa evaluar la expresi贸n y devolver el resultado a la interfaz: <br><br><pre> <code class="cpp hljs">^(return_expr)</code> </pre> <br>  Este operador es equivalente <br><br><pre> <code class="cpp hljs">@^ = return_expr</code> </pre> <br>  o solo <br><br><pre> <code class="cpp hljs">^ = return_expr</code> </pre> <br>  Todos estos operadores son funcionalmente equivalentes y puede usar cualquiera de ellos, pero <code>^(return_expr)</code> parece el m谩s expresivo. <br><br><h3>  Encender la estufa </h3><br>  Hasta ahora hemos visto un controlador con 0 estados y un controlador con 1 estado.  Todav铆a no son muy 煤tiles, pero ya estamos al borde de algo interesante. <br><br>  Para cocinar nuestra pasta, primero debes encender la estufa.  La siguiente es una clase Switch simple con una sola variable booleana: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch</span></span></span><span class="hljs-class"> {</span></span> boolean _isOn; <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isOn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span>; } } }</code> </pre> <br>  Aunque a primera vista esto no es obvio, el c贸digo que se muestra arriba implementa la siguiente tabla de enlaces de eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/5f8/ad7/2ef5f8ad7634c21066e847faf89c8228.png"></div><br>  A modo de comparaci贸n, aqu铆 hay una FMN para el mismo comportamiento: <br><br><pre> <code class="cpp hljs">#Switch1 -machine- $Off |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Ahora vemos c贸mo la notaci贸n Frame coincide exactamente con el prop贸sito de nuestro c贸digo: adjuntar un evento (llamada al m茅todo) al comportamiento en funci贸n del estado en el que se encuentra el controlador.  Adem谩s, la estructura de implementaci贸n tambi茅n corresponde a la tabla de enlace: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch1 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { // $Off if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { // $On if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  La tabla le permite comprender r谩pidamente el prop贸sito del controlador en sus diversos estados.  Tanto la estructura de notaci贸n de trama como el patr贸n de implementaci贸n tienen ventajas similares. <br><br>  Sin embargo, nuestro interruptor tiene un problema funcional notable.  Se inicializa en el estado $ Off, pero no se puede cambiar al estado $ On!  Para hacer esto, necesitamos ingresar un operador de <strong>cambio de estado</strong> . <br><br><h3>  Cambiar estado </h3><br>  <strong>La declaraci贸n de cambio de estado es la</strong> siguiente: <br><br><pre> <code class="cpp hljs">-&gt;&gt; $NewState</code> </pre> <br>  Ahora podemos usar este operador para cambiar entre $ Off y $ On: <br><br><pre> <code class="cpp hljs">#Switch2 -machine- $Off |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Y aqu铆 est谩 la tabla de enlace de eventos correspondiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/08f/688/b0208f68897eb1412f386392e8779247.png"></div><br>  Nuevo evento | alternar |  ahora desencadena un cambio que simplemente recorre los dos estados.  驴C贸mo se puede implementar una operaci贸n de cambio de estado? <br><br>  En ninguna parte es m谩s f谩cil.  Aqu铆 est谩 la implementaci贸n de Switch2: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch2 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^("OFF") } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  Tambi茅n puede realizar la 煤ltima mejora en Switch2 para que no solo le permita cambiar entre estados, sino que tambi茅n establezca expl铆citamente el estado: <br><br><pre> <code class="cpp hljs">#Switch3 -machine- $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  A diferencia del evento | toggle |, if | turnOn |  transmitido cuando Switch3 ya est谩 activado o | desactivado | cuando ya est谩 desactivado, el mensaje se ignora y no sucede nada.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta peque帽a mejora le da al cliente la capacidad de indicar expl铆citamente el estado en el que deber铆a estar el conmutador: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch3 // -machine- var _state(e:FrameEvent) = Off /********************************** $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^("OFF") ***********************************/ func Off(e:FrameEvent) { if (e._msg == "turnOn") { // |turnOn| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } /********************************** $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^("ON") ***********************************/ func On(e:FrameEvent) { if (e._msg == "turnOff") { // |turnOff| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El paso final en la evoluci贸n de nuestro interruptor muestra lo f谩cil que es comprender el prop贸sito del controlador FMN. </font><font style="vertical-align: inherit;">El c贸digo relevante demuestra lo f谩cil que es implementarlo usando mecanismos Frame. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隆Despu茅s de haber creado la m谩quina Switch, podemos encender el fuego y comenzar a cocinar!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estado de sonido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un aspecto clave, aunque sutil, de los aut贸matas es que el estado actual de la m谩quina es el resultado de una situaci贸n (por ejemplo, encendido) o alg煤n tipo de an谩lisis de datos o del entorno. </font><font style="vertical-align: inherit;">Cuando la m谩quina cambia al estado deseado, est谩 impl铆cito. </font><font style="vertical-align: inherit;">que la situaci贸n no cambiar谩 sin el conocimiento del autom贸vil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esta suposici贸n no siempre es cierta. </font><font style="vertical-align: inherit;">En algunas situaciones, se requiere verificaci贸n (o "detecci贸n") de los datos para determinar el estado l贸gico actual:</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado restaurado inicial</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cuando la m谩quina se restaura desde un estado constante</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado externo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : define la "situaci贸n real" que existe en el entorno en el momento de la creaci贸n, restauraci贸n u operaci贸n de la m谩quina</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado interno vol谩til</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cuando parte de los datos internos administrados por una m谩quina en funcionamiento pueden cambiar fuera del control de la m谩quina</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En todos estos casos, los datos, el entorno o ambos deben ser "sondeados" para determinar la situaci贸n y establecer el estado de la m谩quina en consecuencia. </font><font style="vertical-align: inherit;">Idealmente, esta l贸gica booleana se puede implementar en una sola funci贸n que defina el estado l贸gico correcto. </font><font style="vertical-align: inherit;">Para admitir este patr贸n, la notaci贸n de cuadros tiene un tipo especial de funci贸n que sondea el universo y determina la situaci贸n en el momento actual. </font><font style="vertical-align: inherit;">Dichas funciones se indican con el prefijo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> antes del nombre del m茅todo que devuelve un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace al estado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En nuestra situaci贸n, dicho m茅todo se puede implementar de la siguiente manera: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probeForState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:FrameState </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Solid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">212</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Liquid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Gas }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como podemos ver, el m茅todo simplemente devuelve una referencia a la funci贸n de estado correspondiente al estado l贸gico correcto. </font><font style="vertical-align: inherit;">Esta funci贸n de detecci贸n se puede utilizar para ingresar el estado correcto:</font></font><br><br><pre> <code class="cpp hljs">-&gt;&gt; $probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El mecanismo de implementaci贸n se ve as铆: </font></font><br><br><pre> <code class="cpp hljs">_state = probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m茅todo de detecci贸n de estado es un ejemplo de notaci贸n de trama para gestionar el estado de una manera determinada. </font><font style="vertical-align: inherit;">A continuaci贸n, tambi茅n aprenderemos la notaci贸n importante para administrar FrameEvents.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Herencia conductual y despachador </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La herencia de comportamiento y el despachador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un poderoso paradigma de programaci贸n y el 煤ltimo tema sobre la notaci贸n de marcos en este art铆culo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de marcos utiliza la herencia de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportamiento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , no la herencia de datos u otros atributos. </font><font style="vertical-align: inherit;">Para este estado, FrameEvents se env铆an a otros estados si el estado inicial no maneja el evento (o, como veremos en los pr贸ximos art铆culos, solo quiere transmitirlo). </font><font style="vertical-align: inherit;">Esta cadena de eventos puede llegar a cualquier profundidad deseada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para esto, las m谩quinas se pueden implementar utilizando una t茅cnica llamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m茅todo de encadenamiento</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La notaci贸n FMN para enviar eventos de un estado a otro es el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despachador </font></font></strong> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$S1 =&gt; $S2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta declaraci贸n FMN se puede implementar de la siguiente manera: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span><span class="hljs-function"> </span></span>{ S2(e) <span class="hljs-comment"><span class="hljs-comment">// $S1 =&gt; $S2 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora vemos lo f谩cil que es encadenar m茅todos de estado. </font><font style="vertical-align: inherit;">Apliquemos esta t茅cnica a una situaci贸n bastante dif铆cil:</font></font><br><br><pre> <code class="cpp hljs">#Movement -machine- $Walking =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">3</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Running =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">6</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Crawling =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">.5</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $AtAttention =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $LyingDown =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $Moving |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Motionless |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">0</span></span>) |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el c贸digo anterior, vemos que hay dos estados b谩sicos: $ Moving y $ Motionless, y los otros cinco estados heredan una funcionalidad importante de ellos. </font><font style="vertical-align: inherit;">El enlace de evento nos muestra claramente c贸mo se ver谩n los enlaces en general:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/95d/97c/11795d97c6a96d32824dc9ac2ddf62dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gracias a las t茅cnicas que hemos aprendido, la implementaci贸n ser谩 muy simple: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Movement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Movement // -machine- /********************************** $Walking =&gt; $Moving |getSpeed| ^(3) |isStanding| ^(true) ***********************************/ func Walking(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 3 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Walking =&gt; $Moving } /********************************** $Running =&gt; $Moving |getSpeed| ^(6) |isStanding| ^(true) ***********************************/ func Running(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 6 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Running =&gt; $Moving } /********************************** $Crawling =&gt; $Moving |getSpeed| ^(.5) |isStanding| ^(false) ***********************************/ func Crawling(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = .5 return } if (e._msg == "isStanding") { e._return = false return } Moving(e) // $Crawling =&gt; $Moving } /********************************** $AtAttention =&gt; $Motionless |isStanding| ^(true) ***********************************/ func AtAttention(e:FrameEvent) { if (e._msg == "isStanding") { e._return = true return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $LyingDown =&gt; $Motionless |isStanding| ^(false) ***********************************/ func LyingDown(e:FrameEvent) { if (e._msg == "isStanding") { e._return = false return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $Moving |isMoving| ^(true) ***********************************/ func Moving(e:FrameEvent) { if (e._msg == "isMoving") { e._return = true return } } /********************************** $Motionless |getSpeed| ^(0) |isMoving| ^(false) ***********************************/ func Motionless(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 0 return } if (e._msg == "isMoving") { e._return = false return } } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maquina de agua </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos los conocimientos b谩sicos sobre FMN, lo que nos permite comprender c贸mo volver a implementar la clase WaterSample con estados y de una manera mucho m谩s inteligente. </font><font style="vertical-align: inherit;">Tambi茅n lo haremos 煤til para nuestro f铆sico de estudiantes de posgrado y le agregaremos un nuevo estado de $ Plasma:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/d16/64d/afbd1664dacfde5e4857c45e35ee33ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As铆 es como se ve la implementaci贸n completa de FMN: </font></font><br><br><pre> <code class="cpp hljs">#WaterSample -machine- $Begin |create| <span class="hljs-comment"><span class="hljs-comment">// set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |getState| ^("SOLID") $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, tenemos el estado inicial de $ Begin, que responde al mensaje | crear | y conserva el valor </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La funci贸n de detecci贸n primero verifica el valor inicial </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar el estado l贸gico, y luego realiza la transici贸n de la m谩quina a este estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los estados f铆sicos ($ S贸lido, $ L铆quido, $ Gas, $ Plasma) heredan el comportamiento protector del $ Estado predeterminado. Todos los eventos que no son v谩lidos para el estado actual se pasan al estado $ Default, que arroja un error InvalidStateError. Esto muestra c贸mo se puede implementar una programaci贸n defensiva simple usando la herencia de comportamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y ahora la implementaci贸n:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = Begin /********************************** $Begin |create| // set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ ***********************************/ func Begin(e:FrameEvent) { if (e._msg == "create") { setTemp(e["temp"]) _state = probeForState() return } } /********************************** $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |sublimate| ^("SOLID") ***********************************/ func Solid(e:FrameEvent) { if (e._msg == "melt") { doMelt() _state = Liquid return } if (e._msg == "sublimate") { doSublimate() _state = Gas return } if (e._msg == "getState") { e._return = "SOLID" return } Default(e) } /********************************** $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") ***********************************/ func Liquid(e:FrameEvent) { if (e._msg == "freeze") { doFreeze() _state = Solid return } if (e._msg == "vaporize") { doVaporize() _state = Gas return } if (e._msg == "getState") { e._return = "LIQUID" return } Default(e) } /********************************** $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") ***********************************/ func Gas(e:FrameEvent) { if (e._msg == "condense") { doCondense() _state = Liquid return } if (e._msg == "depose") { doDepose() _state = Solid return } if (e._msg == "ionize") { doIonize() _state = Plasma return } if (e._msg == "getState") { e._return = "GAS" return } Default(e) } /********************************** $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") ***********************************/ func Plasma(e:FrameEvent) { if (e._msg == "recombine") { doRecombine() _state = Gas return } if (e._msg == "getState") { e._return = "PLASMA" return } Default(e) } /********************************** $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError() ***********************************/ func Default(e:FrameEvent) { if (e._msg == "melt") { throw new InvalidStateError() } if (e._msg == "sublimate") { throw new InvalidStateError() } if (e._msg == "freeze") { throw new InvalidStateError() } if (e._msg == "vaporize") { throw new InvalidStateError() } if (e._msg == "condense") { throw new InvalidStateError() } if (e._msg == "depose") { throw new InvalidStateError() } if (e._msg == "ionize") { throw new InvalidStateError() } if (e._msg == "recombine") { throw new InvalidStateError() } if (e._msg == "getState") { throw new InvalidStateError() } } }</span></span></code> </pre> <br><h3>  Conclusi贸n </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automata es un concepto b谩sico de inform谩tica que se ha utilizado durante demasiado tiempo solo en 谩reas especializadas de desarrollo de software y hardware. La tarea principal de Frame es crear una notaci贸n para describir aut贸matas y establecer patrones simples para escribir c贸digo o "mecanismos" para su implementaci贸n. Espero que la notaci贸n Frame cambie la forma en que los programadores ven las m谩quinas, proporcionando una manera f谩cil de ponerlas en pr谩ctica en las tareas de programaci贸n cotidianas y, por supuesto, salvarlas de los espaguetis en el c贸digo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/041/f9d/411041f9dac0d4b6b9901a9528939495.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminator come pasta (foto de Suzuki san)</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En futuros art铆culos, basados en los conceptos que hemos aprendido, crearemos un poder y una expresividad a煤n mayores de la notaci贸n FMN. </font><font style="vertical-align: inherit;">Con el tiempo, ampliar茅 la discusi贸n al estudio del modelado visual, que incluye FMN y resuelve los problemas de comportamiento incierto en los enfoques modernos de modelado de software.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446330/">https://habr.com/ru/post/446330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446320/index.html">C贸mo el esc谩ner 3D permiti贸 abandonar el conjunto de control a gran escala del puente</a></li>
<li><a href="../446322/index.html">Criptograf铆a en Java. Keytool Utility</a></li>
<li><a href="../446324/index.html">Navegaci贸n en DataGrip con Yandex.Navigator</a></li>
<li><a href="../446326/index.html">Resolviendo problemas de tr谩fico</a></li>
<li><a href="../446328/index.html">驴Por qu茅 necesitamos servicios de recepci贸n de SMS y con qu茅 comen?</a></li>
<li><a href="../446332/index.html">IBM System i (tambi茅n conocido como AS / 400): c贸mo realizamos las pruebas autom谩ticas de aplicaciones de pantalla verde</a></li>
<li><a href="../446334/index.html">Reflexiones sobre una carrera en TI y consejos para principiantes</a></li>
<li><a href="../446336/index.html">C贸mo prohibir las contrase帽as est谩ndar y hacer que todos te odien</a></li>
<li><a href="../446338/index.html">SVG 3D: crear, rotar y animar</a></li>
<li><a href="../446340/index.html">Sistemas operativos: tres piezas f谩ciles. Parte 1: Introducci贸n (traducci贸n)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>