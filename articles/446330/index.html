<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕧 🌘 ♥️ Máquinas automáticas contra el código de espagueti 🧚🏼 🏴󠁧󠁢󠁥󠁮󠁧󠁿 🐶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Me encantan los spaghetti westerns, odio el código de spaghetti" 

 El "código de espagueti" es una expresión ideal para describir el software que es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Máquinas automáticas contra el código de espagueti</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/15b/078/04915b0789f8de5be2bc6950b3265a8a.png"></div><br>  <i>"Me encantan los spaghetti westerns, odio el código de spaghetti"</i> <br><br>  El "código de espagueti" es una expresión ideal para describir el software que es un caos humeante desde un punto de vista cognitivo y estético.  En este artículo, hablaré sobre un plan de tres puntos para destruir un código de espagueti: <br><br><ul><li>  Discutimos por qué el código de espagueti no es tan sabroso. </li><li>  Presentamos una nueva mirada a lo que realmente hace el código. </li><li>  Estamos discutiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Frame Machine Notation (FMN)</a> , que ayuda a los desarrolladores a desentrañar una bola de pasta. </li></ul><br>  Todos sabemos lo difícil que es leer el código de otra persona.  Esto puede deberse al hecho de que la tarea en sí es difícil o porque la estructura del código es demasiado ... "creativa".  A menudo, estos dos problemas van de la mano. <br><br>  Los desafíos son tareas difíciles y, por lo general, nada más que un descubrimiento revolucionario puede simplificarlos.  Sin embargo, sucede que la estructura del software en sí agrega complejidad innecesaria, y <em>vale la pena</em> resolver este problema. <br><br>  La fealdad del código de espagueti radica en su compleja lógica condicional.  Y aunque la vida puede ser difícil de imaginar sin las muchas construcciones difíciles de si-entonces-otro, este artículo le mostrará una mejor solución. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/af0/c3c/6ccaf0c3c57a472e1eb5b80a238a86c5.png"></div><br>  Para ilustrar la situación con el código de espagueti, primero debemos cambiar esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/eac/43c/cf9eac43c588d9fecbbfc9bf15753ee1.jpg"></div><br>  <i>Pasta crujiente</i> <br><br>  En esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/683/f12/7fc683f12aa20bcf4abcf5a774c7a039.jpg"></div><br>  <i>Al dente!</i> <br><br>  Empecemos a cocinar. <br><br><h3>  Estado implícito </h3><br>  Para hacer pasta, definitivamente necesitamos agua para cocinar.  Sin embargo, incluso un elemento aparentemente simple que involucra un código de espagueti puede ser muy confuso. <br><br>  Aquí hay un ejemplo simple: <br><br><pre><code class="cpp hljs">(temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br>  ¿Qué hace realmente esta verificación?  Obviamente, divide la recta numérica en dos partes, pero ¿ <em>qué significan</em> estas partes?  Creo que puede hacer una suposición lógica, pero el problema es que el código en realidad no se comunica <em>explícitamente</em> . <br><br>  Si realmente confirmo que ella verifica si el agua es SÓLIDA <i>[aprox.</i>  <i>carril: según la escala Fahrenheit, el agua se congela a +32 grados]</i> , ¿qué significará lógicamente el retorno falso? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) }</span></span></code> </pre> <br>  Aunque el cheque dividió los números en dos grupos, de hecho, hay tres estados lógicos: sólido, líquido y gaseoso (SÓLIDO, LÍQUIDO, GAS). <br><br>  Es decir, esta recta numérica: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/b04/343/fadb04343c512bbf297dbf17a250d742.png"></div><br>  dividido por verificación de condición de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e83/2cc/56ae832ccebc547053d46dec39993ec3.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/dcf/20d/a55dcf20d2de1f679a233913c045546f.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Observe lo que sucedió porque es muy importante para comprender la naturaleza del código de espagueti.  Una verificación booleana dividió el espacio numérico en dos partes, pero NO categorizó el sistema como una estructura lógica real de (SÓLIDO, LÍQUIDO, GAS).  En cambio, el cheque dividió el espacio en (SÓLIDO, todo lo demás). <br><br>  Aquí hay una verificación similar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// GAS water } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Visualmente, se verá así: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/127/810/51d127810231b42191868d0972e3865f.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/187/bd4/42a187bd4559e2dfa9e6acffcd24c8b2.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Tenga en cuenta que: <br><br><ol><li>  el conjunto completo de posibles estados no se anuncia en ninguna parte </li><li>  en ninguna parte de las construcciones condicionales se declaran estados lógicos verificables o grupos de estados </li><li>  algunos estados se agrupan indirectamente por la estructura de la lógica condicional y la ramificación </li></ol><br>  Tal código es frágil, pero muy común, y no tan grande como para causar problemas con su soporte.  Así que empeoremos la situación. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/852/bd5/7a1/852bd57a151d005a34ddd883aea5d1ab.png"></div><br>  <i>Nunca me gustó tu código de todos modos</i> <br><br>  El código que se muestra arriba implica la existencia de tres estados de la materia: SÓLIDO, LÍQUIDO, GAS.  Sin embargo, según datos científicos, de hecho, hay <strong><em>cuatro</em></strong> estados observables en los que se incluye plasma (PLASMA) (de hecho, hay muchos otros, pero esto será suficiente para nosotros).  Aunque nadie está preparando una pasta de plasma, si este código se publica en Github, y luego algún estudiante de posgrado que estudie física de alta energía lo bifurcará, también tendremos que mantener este estado. <br><br>  Sin embargo, cuando se agrega plasma, el código que se muestra arriba ingenuamente hará lo siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) + (PLASMA?) // how did PLASMA get in here?? } if (temp &gt; 212) { // GAS water + (PLASMA) // again with the PLASMA!! } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Es probable que el antiguo código, cuando se agrega a muchos estados de plasma, se rompa en las ramas más.  Desafortunadamente, nada en la estructura del código ayuda a informar la existencia de un nuevo estado o influir en los cambios.  Además, es probable que cualquier error no sea visible, es decir, encontrarlo será lo más difícil.  Solo di no a los insectos en el espagueti. <br><br>  En resumen, el problema es este: las comprobaciones booleanas se utilizan para determinar los estados <em>indirectamente</em> .  Los estados lógicos a menudo no se declaran y no son visibles en el código.  Como vimos anteriormente, cuando el sistema agrega nuevos estados lógicos, el código existente puede romperse.  Para evitar esto, los <strong>desarrolladores deben volver a examinar cada comprobación condicional individual y ramificación</strong> para asegurarse de que las rutas de código sigan siendo válidas para <em>todos</em> sus estados lógicos.  Esta es la razón principal de la degradación de los fragmentos de código grandes a medida que se vuelven más complejos. <br><br>  Aunque no hay formas de deshacerse por completo de las verificaciones de datos condicionales, cualquier técnica que las minimice reducirá la complejidad del código. <br><br>  Veamos ahora una implementación típica orientada a objetos de una clase que crea un modelo <em>muy</em> simple del volumen de agua.  La clase gestionará los cambios en el estado de la sustancia del agua.  Después de estudiar los problemas de la solución clásica a este problema, discutimos una nueva notación llamada <strong>Frame</strong> y mostramos cómo puede hacer frente a las dificultades que hemos descubierto. <br><br><h3>  Primero hierva el agua ... </h3><br>  La ciencia dio nombres a todas las transiciones posibles que una sustancia puede hacer cuando cambia la temperatura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/016/dc5/638016dc5b2a19ecd2b677cc40e2ee26.png"></div><br>  Nuestra clase es muy simple (y no particularmente útil).  Responde a los desafíos de realizar transiciones entre estados y cambia la temperatura hasta que se vuelve adecuada para el estado objetivo deseado: <br><br>  (Nota: escribí este pseudocódigo. Úselo en su trabajo solo bajo su propio riesgo y riesgo). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> temp:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Water</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(temp:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.temp = temp } <span class="hljs-comment"><span class="hljs-comment">// gas -&gt; solid func depose() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do depose while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // gas -&gt; liquid func condense() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do condense while (temp &gt; WATER_GAS_TEMP) decreaseTemp(1) } // liquid -&gt; gas func vaporize() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do vaporize while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } // liquid -&gt; solid func freeze() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do freeze while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // solid -&gt; liquid func melt() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do melt while (temp &lt; WATER_SOLID_TEMP) increaseTemp(1) } // solid -&gt; gas func sublimate() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do sublimate while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } func getState():string { if (temp &lt; WATER_SOLID_TEMP) return "SOLID" if (temp &gt; WATER_GAS_TEMP) return "GAS" return "LIQUID" } }</span></span></code> </pre> <br>  En comparación con el primer ejemplo, este código tiene ciertas mejoras.  Primero, los números "mágicos" codificados (32, 212) se reemplazan por las constantes de los límites de temperatura del estado (WATER_SOLID_TEMP, WATER_GAS_TEMP).  Este cambio comienza a hacer que los estados sean más explícitos, aunque indirectamente. <br><br>  Las verificaciones para "programación defensiva" también aparecen en este código, que restringe la llamada al método si está en un estado inadecuado para la operación.  Por ejemplo, el agua no puede congelarse si no es un líquido; esto viola la ley (de la naturaleza).  Pero la adición de condiciones de vigilancia complica la comprensión del propósito del código.  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// liquid -&gt; solid if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError()</span></span></code> </pre> <br>  Esta verificación condicional hace lo siguiente: <br><br><ol><li>  Comprueba si la <code>temp</code> inferior a la temperatura límite de GAS </li><li>  Comprueba si la <code>temp</code> excede la temperatura límite SÓLIDO </li><li>  Devuelve un error si una de estas comprobaciones no es verdadera </li></ol><br>  Esta lógica es confusa.  En primer lugar, estar en estado líquido está determinado por lo que la sustancia <strong>no</strong> es: un sólido o un gas. <br><br><pre> <code class="cpp hljs">(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// is liquid?</span></span></code> </pre> <br>  En segundo lugar, el código verifica si el agua es líquida para determinar si es necesario devolver un error. <br><br><pre> <code class="cpp hljs">!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// Seriously?</span></span></code> </pre> <br>  La primera vez para entender esta doble negación de estados no es fácil.  Aquí hay una simplificación que reduce ligeramente la complejidad de la expresión: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLiquidWater = (temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLiquidWater) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateError()</code> </pre> <br>  Este código es más fácil de entender porque el estado <strong>isLiquidWater</strong> es <em>explícito</em> . <br><br>  Ahora estamos explorando técnicas que arreglan un <strong>estado explícito</strong> como la mejor manera de resolver problemas.  Con este enfoque, los estados lógicos del sistema se convierten en la estructura física del software, lo que mejora el código y simplifica su comprensión. <br><br><h3>  Notación de máquina de marco </h3><br>  <strong>Frame Machine Notation (FMN)</strong> es un lenguaje de dominio específico (DSL) que define un enfoque categórico, metodológico y simple para definir e implementar varios tipos de <em>máquinas</em> .  Para simplificar, llamaré a los autómatas de Frame simplemente "máquinas", porque esta notación puede definir criterios teóricos para cualquier tipo diferente (máquinas de estado, autómatas de tiendas y la evolución superior de autómatas: máquinas de Turing).  Para conocer los diferentes tipos de máquinas y su aplicación, recomiendo estudiar la página en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Wikipedia</a> . <br><br>  Aunque la teoría de los autómatas puede ser interesante (una declaración MUY dudosa), en este artículo nos centraremos en la aplicación práctica de estos poderosos conceptos para construir sistemas y escribir código. <br><br>  Para resolver este problema, Frame presenta una notación estandarizada que funciona en tres niveles integrados: <br><br><ol><li>  Texto DSL para definir controladores Frame con sintaxis elegante y concisa </li><li>  Un conjunto de patrones de codificación de referencia para implementar clases orientadas a objetos en forma de máquinas que Frame llama "controladores" </li><li>  Notación visual en la que se usa FMN para expresar operaciones complejas que son difíciles de representar gráficamente - <strong>Notación visual de marco (FVN)</strong> </li></ol><br>  En este artículo, consideraré los dos primeros puntos: FMN y patrones de referencia, y dejaré la discusión de FVN para futuros artículos. <br><br>  Frame es una notación que tiene varios aspectos importantes: <br><br><ol><li>  FMN tiene objetos de primer nivel relacionados con el concepto de autómatas, que no están disponibles en lenguajes orientados a objetos. </li><li>  La especificación FMN define patrones de implementación estándar en pseudocódigo que demuestran cómo se puede implementar la notación FMN. </li><li>  FMN pronto podrá compilar (trabajo en progreso) en cualquier lenguaje orientado a objetos </li></ol><br>  Nota: la implementación de referencia se utiliza para demostrar la equivalencia absoluta de la notación FMN y una forma sencilla de implementarla en cualquier lenguaje orientado a objetos.  Puedes elegir cualquier método. <br><br>  Ahora te presentaré los dos objetos de primer nivel más importantes en Frame: <strong>Frame Events</strong> y <strong>Frame Controllers</strong> . <br><br><h3>  Eventos de marco </h3><br>  FrameEvents son una parte integral de la simplicidad de la notación FMN.  FrameEvent se implementa como una estructura o clase que al menos tiene las siguientes variables miembro: <br><br><ul><li>  ID del mensaje </li><li>  diccionario o lista de parámetros </li><li>  devolver objeto </li></ul><br>  Aquí está el pseudocódigo de la clase FrameEvent: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-class"> {</span></span> var _msg:String var _params:Object var _return:<span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg:String, params:Object = null)</span></span></span><span class="hljs-function"> </span></span>{ _msg = msg _params = params } }</code> </pre> <br>  La notación de marco utiliza el símbolo <strong>@</strong> , que identifica el objeto FrameEvent.  Cada uno de los atributos FrameEvent requeridos tiene un token especial para acceder a él: <br><br><pre> <code class="cpp hljs">@|message| :  -    _msg @[param1] :  []      @^ :              _return</code> </pre> <br>  A menudo no tenemos que especificar con qué FrameEvent funciona.  Como la mayoría de los contextos funcionan con un solo FrameEvent a la vez, la notación definitivamente se puede simplificar para que solo use selectores de atributos.  Por lo tanto, podemos simplificar el acceso: <br><br><pre> <code class="cpp hljs">|buttonClick| <span class="hljs-comment"><span class="hljs-comment">// Select for a "buttonClick" event _msg [firstName] = "Mark" // Set firstName _params property to "Mark" ^ = "YES" // Set the _return object to "YES"</span></span></code> </pre> <br>  Tal notación puede parecer extraña al principio, pero pronto veremos cómo una sintaxis tan simple para eventos simplifica enormemente la comprensión del código FMN. <br><br><h3>  Controladores de marco </h3><br>  Un controlador de marco es una clase orientada a objetos, ordenada de manera bien definida para implementar una máquina de marco.  Los tipos de controlador se identifican con el prefijo <strong>#</strong> : <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  esto es equivalente al siguiente pseudocódigo orientado a objetos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span>}</code> </pre> <br>  Obviamente esta clase no es particularmente útil.  Para que pueda hacer algo, el controlador necesita al menos un estado para responder a los eventos. <br><br>  Los controladores están estructurados de tal manera que contienen bloques de varios tipos, que se identifican mediante un guión que rodea el nombre del tipo de bloque: <br><br><pre> <code class="cpp hljs">#MyController&lt;br&gt; -block <span class="hljs-number"><span class="hljs-number">1</span></span>- -block <span class="hljs-number"><span class="hljs-number">2</span></span>- -block <span class="hljs-number"><span class="hljs-number">3</span></span>-</code> </pre> <br>  Un controlador no puede tener más de una instancia de cada bloque, y los tipos de bloque pueden contener solo ciertos tipos de subcomponentes.  En este artículo, examinamos solo el bloque <strong>-machine-</strong> , que solo puede contener estados.  Los estados se identifican por el token de prefijo <strong>$</strong> . <br><br>  Aquí vemos el FMN para un controlador que contiene una máquina con un solo estado: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration</span></span></code> </pre> <br>  Aquí está la implementación del código FMN anterior: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = S1 // initialize state variable // to $S1 func S1(e:FrameEvent) { // state $S1 does nothing } }</span></span></code> </pre> <br>  La implementación del bloque de máquina consta de los siguientes elementos: <br><br><ol><li>  <strong>_state</strong> variable, que se refiere a una función del estado actual.  Se inicializa con la primera función de estado en el controlador. </li><li>  uno o más métodos de estado </li></ol><br>  El método de estado de trama se define como una función con la siguiente firma: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span></span>;</code> </pre> <br>  Después de definir estos fundamentos de la implementación del bloque de máquina, podemos ver qué tan bien interactúa el objeto FrameEvent con la máquina. <br><br><h3>  Unidad de interfaz </h3><br>  La interacción de FrameEvents que controla el funcionamiento de la máquina es la esencia misma de la simplicidad y el poder de la notación Frame.  Sin embargo, aún no hemos respondido a la pregunta, ¿de dónde provienen los FrameEvents? ¿Cómo entran en el controlador para controlarlo?  Una opción: los clientes externos pueden crear e inicializar FrameEvents, y luego llamar directamente al método señalado por la variable miembro _state: <br><br><pre> <code class="cpp hljs">myController._state(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Una alternativa mucho mejor sería crear una interfaz común que envuelva una llamada directa a la variable miembro _state: <br><br><pre> <code class="cpp hljs">myController.sendEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Sin embargo, la forma más sencilla, que corresponde a la forma habitual de crear software orientado a objetos, es crear métodos comunes que envíen un evento en nombre del cliente a la máquina interna: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FrameEvent e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>) _state(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e._return } }</code> </pre> <br>  Frame define la sintaxis para <strong>un bloque de interfaz</strong> que contiene métodos que convierten las llamadas en una interfaz común para FrameEvents. <br><br><pre> <code class="cpp hljs">#MyController -interface- buttonClick ...</code> </pre> <br>  El bloque de <code>interface</code> tiene muchas otras características, pero este ejemplo nos da una idea general de cómo funciona.  Daré más explicaciones en los siguientes artículos de la serie. <br><br>  Ahora continuemos estudiando el funcionamiento del autómata Frame. <br><br><h3>  Controladores de eventos </h3><br>  Aunque hemos mostrado cómo definir un automóvil, todavía no tenemos una notación con la que <em>hacer</em> nada.  Para procesar eventos, necesitamos 1) poder seleccionar el evento que necesita ser procesado y 2) adjuntarlo al comportamiento que se está realizando. <br><br>  Aquí hay un controlador Frame simple que proporciona la infraestructura para manejar eventos: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration |e1| ^ // e1 event handler and return</span></span></code> </pre> <br>  Como se indicó anteriormente, para acceder al atributo <code>_msg</code> evento <code>_msg</code> , la notación FMN usa corchetes de líneas verticales: <br><br><pre> <code class="cpp hljs">|messageName|</code> </pre> <br>  FMN también usa un token de exponente que representa la declaración de retorno.  El controlador que se muestra arriba se implementará de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #MyController // -machine- var _state(e:FrameEvent) = S1 func S1(e:FrameEvent) { // $S1 if (e._msg == "e1") { // |e1| return // ^ } } }</span></span></code> </pre> <br>  Aquí vemos cuán claramente la notación FMN corresponde a un patrón de implementación que es fácil de entender y codificar. <br><br>  Una vez establecidos estos aspectos básicos de eventos, controladores, máquinas, estados y controladores de eventos, podemos proceder a resolver problemas reales con su ayuda. <br><br><h3>  Máquinas de enfoque único </h3><br>  Arriba miramos un controlador sin estado que era bastante inútil. <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  Un paso más arriba en la cadena alimentaria de la utilidad es una clase con un solo estado, que, aunque no es inútil, es simplemente aburrido.  Pero al menos él al menos está haciendo <em>algo</em> . <br><br>  Primero, veamos cómo se implementará una clase con un solo estado (implícito): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span> } }</code> </pre> <br>  Aquí no se declara ni se implica ningún estado, pero supongamos que si el código hace algo, el sistema está en el estado "En funcionamiento". <br><br>  También presentaremos una idea importante: las llamadas a la interfaz se considerarán similares a enviar un evento a un objeto.  Por lo tanto, el código anterior puede considerarse como un método para transmitir el estado |  la clase Mono, siempre en el estado $ Working. <br><br>  Esta situación se puede visualizar utilizando la tabla de enlace de eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/81e/7e0/e1b81e7e0916b8354c4092abcc79ab40.png"></div><br>  Ahora veamos FMN, que demuestra la misma funcionalidad y coincide con la misma tabla de enlace: <br><br><pre> <code class="cpp hljs">#Mono -machine- $Working |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>)</code> </pre> <br>  Así es como se ve la implementación: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Mono // -machine- var _state(e:FrameEvent) = Working // initialize start state func Working(e:FrameEvent) { // $Working if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } }</span></span></code> </pre> <br>  Puede notar que también introdujimos una nueva notación para la <strong>declaración return</strong> , lo que significa evaluar la expresión y devolver el resultado a la interfaz: <br><br><pre> <code class="cpp hljs">^(return_expr)</code> </pre> <br>  Este operador es equivalente <br><br><pre> <code class="cpp hljs">@^ = return_expr</code> </pre> <br>  o solo <br><br><pre> <code class="cpp hljs">^ = return_expr</code> </pre> <br>  Todos estos operadores son funcionalmente equivalentes y puede usar cualquiera de ellos, pero <code>^(return_expr)</code> parece el más expresivo. <br><br><h3>  Encender la estufa </h3><br>  Hasta ahora hemos visto un controlador con 0 estados y un controlador con 1 estado.  Todavía no son muy útiles, pero ya estamos al borde de algo interesante. <br><br>  Para cocinar nuestra pasta, primero debes encender la estufa.  La siguiente es una clase Switch simple con una sola variable booleana: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch</span></span></span><span class="hljs-class"> {</span></span> boolean _isOn; <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isOn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span>; } } }</code> </pre> <br>  Aunque a primera vista esto no es obvio, el código que se muestra arriba implementa la siguiente tabla de enlaces de eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/5f8/ad7/2ef5f8ad7634c21066e847faf89c8228.png"></div><br>  A modo de comparación, aquí hay una FMN para el mismo comportamiento: <br><br><pre> <code class="cpp hljs">#Switch1 -machine- $Off |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Ahora vemos cómo la notación Frame coincide exactamente con el propósito de nuestro código: adjuntar un evento (llamada al método) al comportamiento en función del estado en el que se encuentra el controlador.  Además, la estructura de implementación también corresponde a la tabla de enlace: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch1 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { // $Off if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { // $On if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  La tabla le permite comprender rápidamente el propósito del controlador en sus diversos estados.  Tanto la estructura de notación de trama como el patrón de implementación tienen ventajas similares. <br><br>  Sin embargo, nuestro interruptor tiene un problema funcional notable.  Se inicializa en el estado $ Off, pero no se puede cambiar al estado $ On!  Para hacer esto, necesitamos ingresar un operador de <strong>cambio de estado</strong> . <br><br><h3>  Cambiar estado </h3><br>  <strong>La declaración de cambio de estado es la</strong> siguiente: <br><br><pre> <code class="cpp hljs">-&gt;&gt; $NewState</code> </pre> <br>  Ahora podemos usar este operador para cambiar entre $ Off y $ On: <br><br><pre> <code class="cpp hljs">#Switch2 -machine- $Off |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Y aquí está la tabla de enlace de eventos correspondiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/08f/688/b0208f68897eb1412f386392e8779247.png"></div><br>  Nuevo evento | alternar |  ahora desencadena un cambio que simplemente recorre los dos estados.  ¿Cómo se puede implementar una operación de cambio de estado? <br><br>  En ninguna parte es más fácil.  Aquí está la implementación de Switch2: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch2 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^("OFF") } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  También puede realizar la última mejora en Switch2 para que no solo le permita cambiar entre estados, sino que también establezca explícitamente el estado: <br><br><pre> <code class="cpp hljs">#Switch3 -machine- $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  A diferencia del evento | toggle |, if | turnOn |  transmitido cuando Switch3 ya está activado o | desactivado | cuando ya está desactivado, el mensaje se ignora y no sucede nada.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta pequeña mejora le da al cliente la capacidad de indicar explícitamente el estado en el que debería estar el conmutador: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch3 // -machine- var _state(e:FrameEvent) = Off /********************************** $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^("OFF") ***********************************/ func Off(e:FrameEvent) { if (e._msg == "turnOn") { // |turnOn| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } /********************************** $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^("ON") ***********************************/ func On(e:FrameEvent) { if (e._msg == "turnOff") { // |turnOff| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El paso final en la evolución de nuestro interruptor muestra lo fácil que es comprender el propósito del controlador FMN. </font><font style="vertical-align: inherit;">El código relevante demuestra lo fácil que es implementarlo usando mecanismos Frame. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Después de haber creado la máquina Switch, podemos encender el fuego y comenzar a cocinar!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estado de sonido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un aspecto clave, aunque sutil, de los autómatas es que el estado actual de la máquina es el resultado de una situación (por ejemplo, encendido) o algún tipo de análisis de datos o del entorno. </font><font style="vertical-align: inherit;">Cuando la máquina cambia al estado deseado, está implícito. </font><font style="vertical-align: inherit;">que la situación no cambiará sin el conocimiento del automóvil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esta suposición no siempre es cierta. </font><font style="vertical-align: inherit;">En algunas situaciones, se requiere verificación (o "detección") de los datos para determinar el estado lógico actual:</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado restaurado inicial</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cuando la máquina se restaura desde un estado constante</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado externo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : define la "situación real" que existe en el entorno en el momento de la creación, restauración u operación de la máquina</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado interno volátil</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cuando parte de los datos internos administrados por una máquina en funcionamiento pueden cambiar fuera del control de la máquina</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En todos estos casos, los datos, el entorno o ambos deben ser "sondeados" para determinar la situación y establecer el estado de la máquina en consecuencia. </font><font style="vertical-align: inherit;">Idealmente, esta lógica booleana se puede implementar en una sola función que defina el estado lógico correcto. </font><font style="vertical-align: inherit;">Para admitir este patrón, la notación de cuadros tiene un tipo especial de función que sondea el universo y determina la situación en el momento actual. </font><font style="vertical-align: inherit;">Dichas funciones se indican con el prefijo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> antes del nombre del método que devuelve un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace al estado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En nuestra situación, dicho método se puede implementar de la siguiente manera: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probeForState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:FrameState </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Solid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">212</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Liquid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Gas }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como podemos ver, el método simplemente devuelve una referencia a la función de estado correspondiente al estado lógico correcto. </font><font style="vertical-align: inherit;">Esta función de detección se puede utilizar para ingresar el estado correcto:</font></font><br><br><pre> <code class="cpp hljs">-&gt;&gt; $probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El mecanismo de implementación se ve así: </font></font><br><br><pre> <code class="cpp hljs">_state = probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El método de detección de estado es un ejemplo de notación de trama para gestionar el estado de una manera determinada. </font><font style="vertical-align: inherit;">A continuación, también aprenderemos la notación importante para administrar FrameEvents.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Herencia conductual y despachador </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La herencia de comportamiento y el despachador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un poderoso paradigma de programación y el último tema sobre la notación de marcos en este artículo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de marcos utiliza la herencia de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportamiento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , no la herencia de datos u otros atributos. </font><font style="vertical-align: inherit;">Para este estado, FrameEvents se envían a otros estados si el estado inicial no maneja el evento (o, como veremos en los próximos artículos, solo quiere transmitirlo). </font><font style="vertical-align: inherit;">Esta cadena de eventos puede llegar a cualquier profundidad deseada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para esto, las máquinas se pueden implementar utilizando una técnica llamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método de encadenamiento</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La notación FMN para enviar eventos de un estado a otro es el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despachador </font></font></strong> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$S1 =&gt; $S2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta declaración FMN se puede implementar de la siguiente manera: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span><span class="hljs-function"> </span></span>{ S2(e) <span class="hljs-comment"><span class="hljs-comment">// $S1 =&gt; $S2 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora vemos lo fácil que es encadenar métodos de estado. </font><font style="vertical-align: inherit;">Apliquemos esta técnica a una situación bastante difícil:</font></font><br><br><pre> <code class="cpp hljs">#Movement -machine- $Walking =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">3</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Running =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">6</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Crawling =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">.5</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $AtAttention =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $LyingDown =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $Moving |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Motionless |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">0</span></span>) |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el código anterior, vemos que hay dos estados básicos: $ Moving y $ Motionless, y los otros cinco estados heredan una funcionalidad importante de ellos. </font><font style="vertical-align: inherit;">El enlace de evento nos muestra claramente cómo se verán los enlaces en general:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/95d/97c/11795d97c6a96d32824dc9ac2ddf62dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gracias a las técnicas que hemos aprendido, la implementación será muy simple: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Movement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Movement // -machine- /********************************** $Walking =&gt; $Moving |getSpeed| ^(3) |isStanding| ^(true) ***********************************/ func Walking(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 3 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Walking =&gt; $Moving } /********************************** $Running =&gt; $Moving |getSpeed| ^(6) |isStanding| ^(true) ***********************************/ func Running(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 6 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Running =&gt; $Moving } /********************************** $Crawling =&gt; $Moving |getSpeed| ^(.5) |isStanding| ^(false) ***********************************/ func Crawling(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = .5 return } if (e._msg == "isStanding") { e._return = false return } Moving(e) // $Crawling =&gt; $Moving } /********************************** $AtAttention =&gt; $Motionless |isStanding| ^(true) ***********************************/ func AtAttention(e:FrameEvent) { if (e._msg == "isStanding") { e._return = true return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $LyingDown =&gt; $Motionless |isStanding| ^(false) ***********************************/ func LyingDown(e:FrameEvent) { if (e._msg == "isStanding") { e._return = false return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $Moving |isMoving| ^(true) ***********************************/ func Moving(e:FrameEvent) { if (e._msg == "isMoving") { e._return = true return } } /********************************** $Motionless |getSpeed| ^(0) |isMoving| ^(false) ***********************************/ func Motionless(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 0 return } if (e._msg == "isMoving") { e._return = false return } } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maquina de agua </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos los conocimientos básicos sobre FMN, lo que nos permite comprender cómo volver a implementar la clase WaterSample con estados y de una manera mucho más inteligente. </font><font style="vertical-align: inherit;">También lo haremos útil para nuestro físico de estudiantes de posgrado y le agregaremos un nuevo estado de $ Plasma:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/d16/64d/afbd1664dacfde5e4857c45e35ee33ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Así es como se ve la implementación completa de FMN: </font></font><br><br><pre> <code class="cpp hljs">#WaterSample -machine- $Begin |create| <span class="hljs-comment"><span class="hljs-comment">// set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |getState| ^("SOLID") $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, tenemos el estado inicial de $ Begin, que responde al mensaje | crear | y conserva el valor </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La función de detección primero verifica el valor inicial </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar el estado lógico, y luego realiza la transición de la máquina a este estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los estados físicos ($ Sólido, $ Líquido, $ Gas, $ Plasma) heredan el comportamiento protector del $ Estado predeterminado. Todos los eventos que no son válidos para el estado actual se pasan al estado $ Default, que arroja un error InvalidStateError. Esto muestra cómo se puede implementar una programación defensiva simple usando la herencia de comportamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y ahora la implementación:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = Begin /********************************** $Begin |create| // set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ ***********************************/ func Begin(e:FrameEvent) { if (e._msg == "create") { setTemp(e["temp"]) _state = probeForState() return } } /********************************** $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |sublimate| ^("SOLID") ***********************************/ func Solid(e:FrameEvent) { if (e._msg == "melt") { doMelt() _state = Liquid return } if (e._msg == "sublimate") { doSublimate() _state = Gas return } if (e._msg == "getState") { e._return = "SOLID" return } Default(e) } /********************************** $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") ***********************************/ func Liquid(e:FrameEvent) { if (e._msg == "freeze") { doFreeze() _state = Solid return } if (e._msg == "vaporize") { doVaporize() _state = Gas return } if (e._msg == "getState") { e._return = "LIQUID" return } Default(e) } /********************************** $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") ***********************************/ func Gas(e:FrameEvent) { if (e._msg == "condense") { doCondense() _state = Liquid return } if (e._msg == "depose") { doDepose() _state = Solid return } if (e._msg == "ionize") { doIonize() _state = Plasma return } if (e._msg == "getState") { e._return = "GAS" return } Default(e) } /********************************** $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") ***********************************/ func Plasma(e:FrameEvent) { if (e._msg == "recombine") { doRecombine() _state = Gas return } if (e._msg == "getState") { e._return = "PLASMA" return } Default(e) } /********************************** $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError() ***********************************/ func Default(e:FrameEvent) { if (e._msg == "melt") { throw new InvalidStateError() } if (e._msg == "sublimate") { throw new InvalidStateError() } if (e._msg == "freeze") { throw new InvalidStateError() } if (e._msg == "vaporize") { throw new InvalidStateError() } if (e._msg == "condense") { throw new InvalidStateError() } if (e._msg == "depose") { throw new InvalidStateError() } if (e._msg == "ionize") { throw new InvalidStateError() } if (e._msg == "recombine") { throw new InvalidStateError() } if (e._msg == "getState") { throw new InvalidStateError() } } }</span></span></code> </pre> <br><h3>  Conclusión </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automata es un concepto básico de informática que se ha utilizado durante demasiado tiempo solo en áreas especializadas de desarrollo de software y hardware. La tarea principal de Frame es crear una notación para describir autómatas y establecer patrones simples para escribir código o "mecanismos" para su implementación. Espero que la notación Frame cambie la forma en que los programadores ven las máquinas, proporcionando una manera fácil de ponerlas en práctica en las tareas de programación cotidianas y, por supuesto, salvarlas de los espaguetis en el código.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/041/f9d/411041f9dac0d4b6b9901a9528939495.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminator come pasta (foto de Suzuki san)</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En futuros artículos, basados ​​en los conceptos que hemos aprendido, crearemos un poder y una expresividad aún mayores de la notación FMN. </font><font style="vertical-align: inherit;">Con el tiempo, ampliaré la discusión al estudio del modelado visual, que incluye FMN y resuelve los problemas de comportamiento incierto en los enfoques modernos de modelado de software.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446330/">https://habr.com/ru/post/446330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446320/index.html">Cómo el escáner 3D permitió abandonar el conjunto de control a gran escala del puente</a></li>
<li><a href="../446322/index.html">Criptografía en Java. Keytool Utility</a></li>
<li><a href="../446324/index.html">Navegación en DataGrip con Yandex.Navigator</a></li>
<li><a href="../446326/index.html">Resolviendo problemas de tráfico</a></li>
<li><a href="../446328/index.html">¿Por qué necesitamos servicios de recepción de SMS y con qué comen?</a></li>
<li><a href="../446332/index.html">IBM System i (también conocido como AS / 400): cómo realizamos las pruebas automáticas de aplicaciones de pantalla verde</a></li>
<li><a href="../446334/index.html">Reflexiones sobre una carrera en TI y consejos para principiantes</a></li>
<li><a href="../446336/index.html">Cómo prohibir las contraseñas estándar y hacer que todos te odien</a></li>
<li><a href="../446338/index.html">SVG 3D: crear, rotar y animar</a></li>
<li><a href="../446340/index.html">Sistemas operativos: tres piezas fáciles. Parte 1: Introducción (traducción)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>