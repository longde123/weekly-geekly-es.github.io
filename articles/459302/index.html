<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàµ üåÅ ‚òùüèª Reintentando solicitudes HTTP fallidas en Angular üëåüèª üïã üêÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La organizaci√≥n del acceso a los datos del servidor es la base de casi cualquier aplicaci√≥n de una p√°gina. Todo el contenido din√°mico en dichas aplica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reintentando solicitudes HTTP fallidas en Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459302/">  La organizaci√≥n del acceso a los datos del servidor es la base de casi cualquier aplicaci√≥n de una p√°gina.  Todo el contenido din√°mico en dichas aplicaciones se descarga desde el backend. <br><br>  En la mayor√≠a de los casos, las solicitudes HTTP al servidor funcionan de manera confiable y devuelven el resultado deseado.  Sin embargo, en algunas situaciones, las solicitudes pueden fallar. <br><br>  Imagine c√≥mo alguien trabaja con su sitio web a trav√©s de un punto de acceso en un tren que viaja por todo el pa√≠s a una velocidad de 200 kil√≥metros por hora.  La conexi√≥n de red en este escenario puede ser lenta, pero las solicitudes del servidor, a pesar de esto, hacen su trabajo. <br><br>  Pero, ¬øy si el tren entra al t√∫nel?  Existe una alta probabilidad de que la conexi√≥n a Internet se interrumpa y la aplicaci√≥n web no pueda "comunicarse" con el servidor.  En este caso, el usuario tendr√° que volver a cargar la p√°gina de la aplicaci√≥n despu√©s de que el tren salga del t√∫nel y se restablezca la conexi√≥n a Internet. <br><br>  Recargar la p√°gina puede afectar el estado actual de la aplicaci√≥n.  Esto significa que el usuario puede, por ejemplo, perder los datos que ingres√≥ en el formulario. <br><br>  En lugar de simplemente conciliar con el hecho de que una determinada solicitud no tuvo √©xito, ser√≠a mejor repetirla varias veces y mostrar al usuario una notificaci√≥n correspondiente.  Con este enfoque, cuando el usuario se da cuenta de que la aplicaci√≥n est√° tratando de hacer frente al problema, lo m√°s probable es que no vuelva a cargar la p√°gina. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/tq/jn/st/tqjnsttqoifuf4p9-rnt_g1dfwg.jpeg"></a> <br><br>  El material, cuya traducci√≥n publicamos hoy, est√° dedicado al an√°lisis de varias formas de repetir solicitudes fallidas en aplicaciones angulares. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Repetir solicitudes fallidas</font> </h2><br>  Reproduzcamos una situaci√≥n que puede encontrar un usuario que trabaja en Internet desde un tren.  Crearemos un backend que procese la solicitud de forma incorrecta durante los primeros tres intentos de acceso, devolviendo datos solo del cuarto intento. <br>  Usualmente, usando Angular, creamos un servicio, conectamos el <code>HttpClient</code> y lo usamos para obtener datos del backend. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      catchError((</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      })    );  } }</span></span></code> </pre> <br>  No hay nada especial aqu√≠.  <code>HttpClient</code> m√≥dulo Angular <code>HttpClient</code> y ejecutamos una simple solicitud GET.  Si la solicitud devuelve un error, ejecutamos un c√≥digo para procesarlo y devolvemos un <code>Observable</code> (objeto observable) vac√≠o para informar sobre lo que inici√≥ la solicitud.  Este c√≥digo, por as√≠ decirlo, dice: "Hubo un error, pero todo est√° en orden, puedo manejarlo". <br><br>  La mayor√≠a de las aplicaciones realizan solicitudes HTTP de esta manera.  En el c√≥digo anterior, la solicitud se ejecuta solo una vez.  Despu√©s de eso, devuelve los datos recibidos del servidor o no tiene √©xito. <br><br>  ¬øC√≥mo repetir la solicitud si el punto final <code>/greet</code> no <code>/greet</code> disponible o devuelve un error?  Tal vez hay una declaraci√≥n RxJS adecuada?  Por supuesto que existe.  RxJS tiene operadores para todo. <br><br>  Lo primero que puede venir a la mente en esta situaci√≥n es la <code>retry</code> .  Veamos su definici√≥n: ‚ÄúDevuelve un Observable que reproduce el Observable original, excepto por <code>error</code> .  Si el Observable original llama <code>error</code> , entonces este m√©todo, en lugar de propagar el error, se volver√° a suscribir al Observable original. <br><br>  El n√∫mero m√°ximo de nuevas suscripciones se limita al <code>count</code> (este es el par√°metro num√©rico pasado al m√©todo) ". <br><br>  La <code>retry</code> muy similar a lo que necesitamos.  As√≠ que incrustemos en nuestra cadena. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError, retry, shareReplay} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      retry(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">),      </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">catchError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      }),      shareReplay()    );  } }</span></span></code> </pre> <br>  Hemos utilizado con √©xito el operador de <code>retry</code> .  Veamos c√≥mo esto afect√≥ el comportamiento de la solicitud HTTP que se ejecuta en la aplicaci√≥n experimental.  <a href="">Aqu√≠ hay</a> un archivo GIF grande que muestra la pantalla de esta aplicaci√≥n y la pesta√±a Red de las herramientas de desarrollo del navegador.  Encontrar√° varias demostraciones m√°s aqu√≠. <br><br>  Nuestra aplicaci√≥n es extremadamente simple.  Simplemente realiza una solicitud HTTP cuando se hace clic en el bot√≥n <code>PING THE SERVER</code> . <br><br>  Como ya se mencion√≥, el back-end devuelve un error al realizar los primeros tres intentos de ejecutar una solicitud, y cuando llega una cuarta solicitud, devuelve una respuesta normal. <br><br>  En la pesta√±a de herramientas del desarrollador de la red, puede ver que la <code>retry</code> resuelve la tarea asignada y repite la ejecuci√≥n de la solicitud fallida tres veces.  El √∫ltimo intento es exitoso, la aplicaci√≥n recibe una respuesta, aparece un mensaje correspondiente en la p√°gina. <br><br>  Todo esto es muy bueno.  Ahora la aplicaci√≥n puede repetir solicitudes fallidas. <br><br>  Sin embargo, este ejemplo a√∫n se puede mejorar.  Tenga en cuenta que ahora las solicitudes repetidas se ejecutan inmediatamente despu√©s de la ejecuci√≥n de las solicitudes que no tienen √©xito.  Este comportamiento del sistema no traer√° muchos beneficios en nuestra situaci√≥n: cuando el tren ingresa al t√∫nel y se pierde la conexi√≥n a Internet por un tiempo. <br><br><h2>  <font color="#3AC1EF">Retraso en el reintento de solicitudes fallidas</font> </h2><br>  El tren que entr√≥ en el t√∫nel no lo deja al instante.  √âl pasa alg√∫n tiempo all√≠.  Por lo tanto, necesitamos "estirar" el per√≠odo durante el cual realizamos solicitudes repetidas al servidor.  Puede hacerlo aplazando los reintentos. <br><br>  Para hacer esto, necesitamos controlar mejor el proceso de ejecuci√≥n de solicitudes repetidas.  Necesitamos poder tomar decisiones sobre cu√°ndo exactamente repetir las solicitudes.  Esto significa que las capacidades del operador de <code>retry</code> ya no son suficientes para nosotros.  Por lo tanto, volvemos a la documentaci√≥n sobre RxJS. <br><br>  La documentaci√≥n contiene una descripci√≥n de la <code>retryWhen</code> , que parece ser <code>retryWhen</code> para nosotros.  En la documentaci√≥n, se describe de la siguiente manera: ‚ÄúDevuelve un Observable que reproduce el Observable original, excepto por <code>error</code> .  Si el Observable original llama <code>error</code> , entonces este m√©todo arrojar√° Throwable, que caus√≥ el error, el Observable regres√≥ del <code>notifier</code> .  Si este Observable llama <code>complete</code> o <code>error</code> , entonces este m√©todo llamar√° <code>complete</code> o <code>error</code> en la suscripci√≥n secundaria.  De lo contrario, este m√©todo se volver√° a suscribir al Observable original ". <br><br>  S√≠, la definici√≥n no es simple.  Describamos lo mismo en un lenguaje m√°s accesible. <br><br>  La <code>retryWhen</code> acepta una devoluci√≥n de llamada que devuelve un Observable.  El Observable devuelto decide c√≥mo se <code>retryWhen</code> se comportar√° el operador en funci√≥n de algunas reglas.  A saber, as√≠ es como el <code>retryWhen</code> operador se <code>retryWhen</code> : <br><br><ul><li>  Deja de funcionar y arroja un error si el Observable devuelto arroja un error. </li><li>  Sale si el Observable devuelto informa que se complet√≥. </li><li>  En otros casos, cuando el Observable regresa con √©xito, repite la ejecuci√≥n del Observable original. </li></ul><br>  Solo se llama a una devoluci√≥n de llamada cuando el Observable original arroja un error por primera vez. <br><br>  Ahora podemos usar este conocimiento para crear un mecanismo de reintento retrasado para una solicitud fallida usando la instrucci√≥n <code>retryWhen</code> . <br><br><pre> <code class="plaintext hljs">retryWhen((errors: Observable&lt;any&gt;) =&gt; errors.pipe(    delay(delayMs),    mergeMap(error =&gt; retries-- &gt; 0 ? of(error) : throwError(getErrorMessage(maxEntry))    )) )</code> </pre> <br>  Si el Observable original, que es nuestra solicitud HTTP, devuelve un error, entonces se <code>retryWhen</code> instrucci√≥n <code>retryWhen</code> .  En la devoluci√≥n de llamada, tenemos acceso al error que caus√≥ la falla.  Diferimos los <code>errors</code> , reducimos el n√∫mero de reintentos y devolvemos un nuevo Observable que arroja un error. <br><br>  Seg√∫n las reglas de la <code>retryWhen</code> , este Observable, dado que <code>retryWhen</code> , <code>retryWhen</code> solicitud.  Si la repetici√≥n no tiene √©xito varias veces y el valor de la variable de <code>retries</code> disminuye a 0, finalizamos la tarea con un error que se produjo al ejecutar la solicitud. <br><br>  Genial  Aparentemente, podemos tomar el c√≥digo anterior y reemplazar el operador de <code>retry</code> en nuestra cadena.  Pero aqu√≠ disminuimos un poco la velocidad. <br><br>  ¬øC√≥mo <code>retries</code> con los <code>retries</code> variables?  Esta variable contiene el estado actual del sistema de reintento de solicitud fallida.  ¬øD√≥nde se anuncia ella?  ¬øCu√°ndo se restablece la condici√≥n?  El estado debe gestionarse dentro de la secuencia, no fuera de ella. <br><br><h3>  <font color="#3AC1EF">‚ñçCree su propia declaraci√≥n de Retraso retrasado</font> </h3><br>  Podemos resolver el problema de la gesti√≥n del estado y mejorar la legibilidad del c√≥digo escribiendo el c√≥digo anterior como un operador RxJS separado. <br><br>  Hay diferentes formas de crear sus propios operadores RxJS.  El m√©todo a utilizar depende de c√≥mo est√© estructurado el operador en particular. <br><br>  Nuestro operador se basa en los operadores existentes de RxJS.  Como resultado, podemos usar la forma m√°s sencilla de crear nuestros propios operadores.  En nuestro caso, el operador RxJs es solo una funci√≥n con la siguiente firma: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt;</code> </pre> <br>  Esta declaraci√≥n toma el Observable original y devuelve otro Observable. <br><br>  Dado que nuestro operador permite al usuario especificar con qu√© frecuencia se deben ejecutar las solicitudes repetidas y cu√°ntas veces deben ejecutarse, debemos ajustar la declaraci√≥n de funci√≥n anterior en una funci√≥n de f√°brica, que requiere <code>delayMs</code> (retraso entre <code>maxRetry</code> ) y <code>maxRetry</code> ( N√∫mero m√°ximo de repeticiones). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt; }</code> </pre> <br>  Si desea crear un operador que no se base en operadores existentes, debe prestar atenci√≥n al manejo de errores y suscripciones.  Adem√°s, deber√° ampliar la clase <code>Observable</code> e implementar la funci√≥n de <code>lift</code> . <br><br>  Si est√° interesado, eche un vistazo <a href="">aqu√≠</a> . <br><br>  Entonces, en base a los fragmentos de c√≥digo anteriores, escribamos nuestro propio operador RxJs. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedRetry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        delay(delayMs),        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error) : throwError(getErrorMessage(maxRetry))        ))      )    ); }</code> </pre> <br>  Genial  Ahora podemos importar este operador al c√≥digo del cliente.  Lo usaremos al ejecutar una solicitud HTTP. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span><span class="hljs-string">/greet`</span></span>).pipe(        delayedRetry(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>),        catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error);            <span class="hljs-comment"><span class="hljs-comment">//               return EMPTY;        }),        shareReplay()    );</span></span></code> </pre> <br>  Pusimos el operador <code>delayedRetry</code> en la cadena y pasamos los n√∫meros 1000 y 3. Como par√°metros. El primer par√°metro establece el retraso en milisegundos entre los intentos de realizar solicitudes repetidas.  El segundo par√°metro determina el n√∫mero m√°ximo de solicitudes repetidas. <br><br>  Reinicie la aplicaci√≥n y <a href="">observe</a> c√≥mo funciona el nuevo operador. <br><br>  Despu√©s de analizar el comportamiento del programa utilizando las herramientas del desarrollador del navegador, podemos ver que la ejecuci√≥n de intentos repetidos para ejecutar la solicitud se retrasa por un segundo.  Despu√©s de recibir la respuesta correcta a la solicitud, aparecer√° un mensaje correspondiente en la ventana de la aplicaci√≥n. <br><br><h2>  <font color="#3AC1EF">Solicitud exponencial posponer</font> </h2><br>  Desarrollemos la idea del reintento retrasado de solicitudes fallidas.  Anteriormente, siempre retras√°bamos la ejecuci√≥n de cada una de las solicitudes repetidas al mismo tiempo. <br><br>  Aqu√≠ hablamos sobre c√≥mo aumentar el retraso despu√©s de cada intento.  El primer intento de reintentar la solicitud se realiza despu√©s de un segundo, el segundo despu√©s de dos segundos, el tercero despu√©s de tres. <br><br>  Cree una nueva instrucci√≥n, <code>retryWithBackoff</code> , que implementa este comportamiento. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up.`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_BACKOFF = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retryWithBackoff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES, backoffMs = DEFAULT_BACKOFF</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {              <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backoffTime = delayMs + (maxRetry - retries) * backoffMs;              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error).pipe(delay(backoffTime));            }            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> throwError(getErrorMessage(maxRetry));          }        )))); }</code> </pre> <br>  Si utiliza este operador en la aplicaci√≥n y lo prueba, puede <a href="">ver</a> c√≥mo aumenta el retraso en la ejecuci√≥n de la solicitud repetida despu√©s de cada nuevo intento. <br><br>  Despu√©s de cada intento, esperamos un cierto tiempo, repetimos la solicitud y aumentamos el tiempo de espera.  Aqu√≠, como de costumbre, despu√©s de que el servidor devuelve la respuesta correcta a la solicitud, mostramos un mensaje en la ventana de la aplicaci√≥n. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  La repetici√≥n de solicitudes HTTP fallidas hace que las aplicaciones sean m√°s estables.  Esto es especialmente significativo cuando se realizan consultas muy importantes, sin los datos obtenidos a trav√©s de los cuales, la aplicaci√≥n no puede funcionar normalmente.  Por ejemplo, pueden ser datos de configuraci√≥n que contienen las direcciones de los servidores con los que la aplicaci√≥n necesita interactuar. <br><br>  En la mayor√≠a de los escenarios, la <code>retry</code> reintento de RxJs no <code>retry</code> suficiente para proporcionar un sistema de reintento confiable para solicitudes fallidas.  La <code>retryWhen</code> le da al desarrollador un mayor nivel de control sobre las solicitudes repetidas.  Le permite configurar el intervalo para solicitudes repetidas.  Debido a las capacidades de este operador, es posible implementar un esquema de repetici√≥n retrasada o repeticiones exponencialmente retrasadas. <br><br>  Al implementar patrones de comportamiento adecuados para su reutilizaci√≥n en cadenas RxJS, se recomienda que se formatee como nuevos operadores.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/kreuzerk/">Aqu√≠ est√° el</a> repositorio desde el que se utiliz√≥ el c√≥digo en este art√≠culo. <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo resuelve el problema de volver a intentar las solicitudes HTTP fallidas? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459302/">https://habr.com/ru/post/459302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459292/index.html">Automatizaci√≥n de pruebas de aplicaciones m√≥viles: comparaci√≥n de herramientas</a></li>
<li><a href="../459294/index.html">¬øQu√© es m√°s importante: conocer un lenguaje de programaci√≥n o poder resolver un problema de negocios?</a></li>
<li><a href="../459296/index.html">Precio JavaScript 2019</a></li>
<li><a href="../459298/index.html">Angular: estado en 2019</a></li>
<li><a href="../459300/index.html">Quasar 1.0: una nueva herramienta √∫til para los desarrolladores de Vue y no solo para ellos</a></li>
<li><a href="../459304/index.html">Bypass de trampa angular y ahorro de tiempo</a></li>
<li><a href="../459306/index.html">Representaci√≥n del servidor en un entorno sin servidor</a></li>
<li><a href="../459308/index.html">¬øEl SEO no funciona en 2019?</a></li>
<li><a href="../459310/index.html">Pruebe las herramientas de automatizaci√≥n o el probador de esteroides m√≥vil</a></li>
<li><a href="../459312/index.html">Querida Agile, estoy harta de fingir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>