<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜñÔ∏è üôçüèæ üßö Plasma Cash Chain als L√∂sung f√ºr das Blockchain-Skalierbarkeitstrilemma üë©üèª‚Äçü§ù‚Äçüë®üèæ üë©‚Äç‚ù§Ô∏è‚Äçüë© üë¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, liebe Leser! 

 Dieser Artikel befasst sich mit der Plasma-Geldkette und beleuchtet die folgenden Themen: 



- das Skalierbarkeitstrilemma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plasma Cash Chain als L√∂sung f√ºr das Blockchain-Skalierbarkeitstrilemma</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457518/">  Guten Tag, liebe Leser! <br><br>  Dieser Artikel befasst sich mit der Plasma-Geldkette und beleuchtet die folgenden Themen: <br><br><ul><li>  das Skalierbarkeitstrilemma und die Methoden f√ºr seine L√∂sung; </li><li>  Datenstrukturen der untergeordneten Kette und ihre Anzeige in der Wurzelkette; </li><li>  Implementierung von Eingaben in die Wurzelkette; </li><li>  Umsetzung des R√ºckzugs aus der Wurzelkette. </li></ul><br>  Opporty verwendete die Programmiersprache Javascript, um die untergeordnete Kette zu implementieren, sowie Solidity f√ºr die Stammkette.  Codebeispiele werden in diesen Sprachen bereitgestellt. <br><br><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  Blockchain und Dezentralisierung erm√∂glichen es, die Arbeit in nahezu allen Lebensbereichen, in denen das Internet und Informationstechnologien verwendet werden, zu optimieren und zu verbessern.  Sie erh√∂hen die Zuverl√§ssigkeit, die finanzielle Effizienz und erleichtern die Digitalisierung realer Dinge und G√ºter. <br><br>  Intelligente Vertr√§ge bringen Gesch√§ftslogik in dezentrale Netzwerke.  Auf diese Weise k√∂nnen Sie neue DAPP-Anwendungen erstellen. <br><br>  Die Ausf√ºhrung intelligenter Vertr√§ge und der schnelle Betrieb von Anwendungen mit einer verteilten Datenbank ist nur m√∂glich, wenn die Skalierbarkeitsbedingung erf√ºllt ist. <br><br>  Moderne dezentrale Blockchains haben mehrere Nachteile.  Das wichtigste ist die Skalierbarkeit.  Das Ethereum verarbeitet ungef√§hr 20 tx / s.  Dies reicht in modernen Finanzrealit√§ten nicht aus.  Gleichzeitig bietet Ethereum den h√∂chstm√∂glichen Schutz vor Hacking und Netzwerkausf√§llen.  Andere Kryptow√§hrungen und Systeme, die auf der Blockchain basieren, weisen keinen so hohen Dezentralisierungsgrad auf, was das Vertrauen in das Netzwerk verringert. <br><br><h2>  Das Skalierbarkeitstrilemma </h2><br>  Es gibt ein Blockchain-Skalierbarkeitstrilemma, das drei Komponenten umfasst: <br><br><ul><li>  Dezentralisierung; </li><li>  Sicherheit </li><li>  Skalierbarkeit. </li></ul><br><h3>  Dezentralisierung im Trilemma </h3><br>  Die Dezentralisierung spiegelt, wie der Begriff schon sagt, den Grad der Diversifizierung des Eigentums an Aktivit√§ten in der Blockchain sowie den Grad der Diversifizierung der Erstellung von Bl√∂cken und der Generierung neuer Hauptbucheintr√§ge wider. <br><br>  Aus Gr√ºnden der Klarheit ist es notwendig, √ºber die am st√§rksten zentralisierten Organisationen zu sprechen.  Normalerweise wird anstelle der Blockchain eine einfache Datenbank verwendet.  Eine solche Organisation wird von speziellen Administratoren betrieben.  Alle Transaktionen k√∂nnen durch manuelles Eingreifen storniert werden. <br><br>  In vollst√§ndig dezentralen Netzwerken kann jeder Benutzer am Aufbau eines Netzwerks teilnehmen. <br><br>  Die wichtigste Folge der Dezentralisierung ist, dass der gr√∂√üte Teil des Werts an die Community geht, die an der Erstellung der Blockchain beteiligt ist.  Es gibt kein zwischengeschaltetes Team von Managern, die alle Vorteile erhalten, anstatt diejenigen, die die Netzwerkstruktur selbst generieren.  Tats√§chlich sind die meisten Krypto-Projekte zu 100% im Besitz ihrer Mitwirkenden oder Benutzer, nicht der Gr√ºnder.  Dies ist offensichtlich ein attraktiveres Modell f√ºr diejenigen, die kein Gr√ºnder sind. <br><br><h3>  Sicherheit im Trilemma </h3><br>  Es geht um die F√§higkeit der Blockchain, Angriffen von externen Quellen standzuhalten und das System in einem unver√§nderten Zustand zu halten.  Die meisten Blockchains sind vielen potenziellen Sicherheitsbedrohungen ausgesetzt.  Es ist unbedingt erforderlich, die g√§ngigsten Angriffsmethoden und Verteidigungsoptionen zu kennen. <br><br>  In diesem Fall gehen Dezentralisierung und Sicherheit Hand in Hand.  Je mehr Knoten vorhanden sind, desto weniger h√§ngt das Netzwerk von der zentralen Seite ab und daher besteht das Risiko eines zentralen Fehlerpunkts.  Es gibt jedoch viele andere Angriffsmethoden, die eine Bedrohung f√ºr dezentrale Netzwerke darstellen, darunter: <br>  &gt; <b>50% Angriff</b> - Ein Objekt, das mehr als 50% der Gesamtzahl der nicht bezahlten Token besitzt, besitzt tats√§chlich das Netzwerk. <br>  &gt; <b>Sybil-Angriff</b> - Der Benutzer kann viele Kennungen im System generieren, um einen signifikanten Anteil am Eigentum und / oder an der Entscheidungsfindung im Netzwerk effektiv zu steuern. <br>  &gt; <b>DDoS</b> - Ein DDoS-Angriff (Distributed Denial of Service) tritt auf, wenn der Datenverkehr im Netzwerk unterbrochen und das Netzwerk mit b√∂swilligen Transaktionen gef√ºllt werden soll. <br>  &gt; <b>Kollusionsangriff</b> - Ein oder mehrere Objekte (oder Knoten) werden zusammengef√ºhrt, um b√∂swillige Vorg√§nge im Netzwerk auszuf√ºhren. <br><br><h3>  Skalierbarkeit im Trilemma </h3><br>  Der Grad der Skalierbarkeit ist wichtig, da er den endg√ºltigen Durchsatz bestimmt, dh die Obergrenze der Netzwerkgr√∂√üe.  Die wichtigste Frage bei der Bewertung eines Netzwerks lautet: ‚ÄûWie vielen Benutzern kann dieses System standhalten?‚Äú  Bitcoin hat derzeit zwischen 2,9 und 5,8 Millionen Brieftascheninhaber.  EOS hat mehrere tausend Mitglieder. <br><br>  Skalierbarkeit und Dezentralisierung k√∂nnen nebeneinander bestehen, die Sicherheit wird jedoch verringert.  Entwickler w√§hlen die Plattformen aus, die ihren Anforderungen am besten entsprechen.  Benutzer tun dasselbe.  Die Meinungen der beiden Seiten sind manchmal unterschiedlich.  Einige Benutzer sind bereit, die Sicherheit f√ºr die Skalierbarkeit zu opfern, andere sind bereit, die Skalierbarkeit f√ºr die Sicherheit zu opfern, aber das Balancieren ist viel schwieriger. <br><br><h2>  "Heiliger Gral" in Blockchain-Technologie </h2><br>  Per Definition hat eine Blockchain nur zwei der folgenden drei Eigenschaften: <br><br><ul><li>  <b>Dezentralisierung</b> (jeder Teilnehmer hat nur Zugriff auf O ¬© -Ressourcen, dh auf einen normalen Laptop oder einen kleinen VPS); </li><li>  <b>Skalierbarkeit</b> (F√§higkeit zur Verarbeitung von Transaktionen O (n)&gt; O ¬©); </li><li>  <b>Sicherheit</b> (Schutz vor Eindringlingen mit O (n) -Ressourcen). </li></ul><br><img src="https://habrastorage.org/webt/ek/zg/zr/ekzgzredr00odj5mwae4f549hzs.png"><br>  Gr√ºn: Ein ausgeglichener Zustand mit drei Bedingungen. <br>  Rot: Starke Sicherheit, aber eingeschr√§nkte Dezentralisierung und Skalierbarkeit. <br>  Blau: Die Effizienz ist hoch, aber Sicherheit und Dezentralisierung sind begrenzt. <br>  Schwarz: Die Dezentralisierung ist hoch, aber es gibt keine Aspekte der Skalierbarkeit und Sicherheit. <br>  Grau: vollst√§ndige Dezentralisierung mit minimalen oder fehlenden Sicherheits- und Skalierbarkeitseigenschaften. <br>  Violett: ein ausgewogenes Verh√§ltnis zwischen Sicherheit und Skalierbarkeit, die Ablehnung der Dezentralisierung. <br><br>  Der ‚Äûheilige Gral‚Äú in der Blockchain-Technologie bedeutet, alle drei Aspekte zu kombinieren. <br>  In den meisten aktuellen Projekten, die mit Kryptow√§hrungen arbeiten, werden zwei grundlegende Eigenschaften erreicht: Dezentralisierung und Sicherheit.  Die Skalierbarkeit leidet. <br><br><h2>  Vielversprechende L√∂sungen f√ºr das Trilemma </h2><br><h3>  Nachweis des Einsatzes (PoS) </h3><br>  Proof of Stake (PoS) bietet potenzielle Verbesserungen der Skalierbarkeit.  POS ersetzt Cryptocurrency Mining basierend auf dem PoW-System (Proof of Work).  Die Wahl des Validators ist sehr schnell - deterministisch.  Gleichzeitig fallen keine Energiekosten an und es ist umweltfreundlich. <br><br><h3>  Seitenketten </h3><br>  Im virtuellen Ethereum-Netzwerk ist es m√∂glich, ein Seitennetzwerk zu erstellen, in dem das Projekt seine einzelnen Transaktionen verarbeiten kann, und dann nur die Anfangs- und Endergebnisse im Ethereum-Netzwerk aufzuzeichnen.  Dies reduziert die Belastung des EVM, gibt jedoch mehr Vertrauen in die Verwaltung der Sidechain.  Das Vertrauen in Dritte reduziert somit die Dezentralisierung. <br><br><h3>  Scherben </h3><br>  Durch das Sharding werden Transaktionen in kleinere Daten aufgeteilt.  Anstelle jedes einzelnen Knotens im Netzwerk, der ganze Transaktionen verarbeitet, werden Knoten in Gruppen unterteilt, und diese Knotengruppen verarbeiten bestimmte Daten.  Sp√§ter, w√§hrend der Verarbeitung, werden diese Daten zur dauerhaften Speicherung in der Blockchain erneut assimiliert. <br><br><h3>  Blockgr√∂√üe erh√∂hen </h3><br>  Litecoin und Bitcoin Cash (BCH) sind ‚ÄûGabeln‚Äú f√ºr die Bitcoin-Blockchain.  Forking kopiert grunds√§tzlich eine Blockchain.  Nach der Verzweigung k√∂nnen Sie √Ñnderungen vornehmen.  Sowohl LTC als auch BCH erh√∂hten die Gr√∂√üe jedes Blocks, wodurch mehr Transaktionen pro Block gespeichert werden konnten, wodurch die Verarbeitungsgeschwindigkeit von Transaktionen erh√∂ht wurde. <br><br><h3>  Blitznetzwerk </h3><br>  Die allererste Sidechain-L√∂sung war Lightning.  Die Hauptidee des Lightning-Netzwerks besteht darin, dass nicht alle Transaktionen in der Blockchain aufgezeichnet werden sollten, da dies das Netzwerk √ºberlastet.  Wenn Benutzer mehrmals Geld untereinander √ºberweisen, ist die Registrierung jeder √úberweisung optional.  Es reicht aus, nur eine Art Zahlungskanal zu √∂ffnen und die Daten √ºber die √ñffnung in der Blockchain aufzuschreiben.  Dieser Kanal bleibt nach Bedarf ge√∂ffnet.  Wenn es notwendig ist, es zu schlie√üen, wird das Ergebnis aller in diesem Kanal get√§tigten Transaktionen einfach in die Blockchain geschrieben.  Nach dieser Idee k√∂nnen Sie ein ganzes Netzwerk von Zahlungskan√§len erstellen.  Dann werden Transaktionen in der Blockchain viel seltener verwendet. <br><br>  Ein Zahlungskanal ist nur eine Kombination mehrerer Transaktionen.  Ein Kanal kann von jedem seiner Mitglieder geschlossen werden.  Diese Aktion ist wie das √ñffnen eines Safes, mit dem Sie die Gelder der Teilnehmer nehmen und die Daten zu ihrer √úberweisung in die Blockchain aufschreiben k√∂nnen. <br>  Diese Technologie wird sehr leistungsf√§hig, wenn mehrere solcher Kan√§le zu einem Netzwerk namens The Lightning Network kombiniert werden.  Dieses Netzwerk wurde speziell f√ºr Bitcoin entwickelt. <br><br><h3>  Raiden-Netzwerk </h3><br>  F√ºr Ethereum ist das Raiden-Netzwerk das bekannteste Gegenst√ºck zu Lightning. <br>  Dies ist eine L√∂sung f√ºr die Skalierung au√üerhalb der Hauptblockkette.  Es ist kompatibel mit der √úbertragung von ERC-20-Token in bidirektionale Zahlungskan√§le. <br><br>  Die grundlegende Architektur ist komplex, aber f√ºr die Interaktion mit Raiden m√ºssen Entwickler nur mit der API interagieren, um skalierbare Anwendungen auf Raiden zu erstellen. <br><br>  Raiden wurde entwickelt, um sofortige Zahlungen und niedrige Provisionen bereitzustellen, die Vertraulichkeit von Transaktionen zu erh√∂hen und Mikrozahlungen zu leisten.  Die meisten Zahlungskan√§le existieren au√üerhalb des Netzwerks und bilden nur gelegentlich Transaktionen innerhalb der Stammkette, wodurch der Durchsatz der untergeordneten Kette erheblich reduziert wird. <br><br><h2>  Optimale L√∂sung </h2><br>  Blitzideologen haben ein neues Childchain-Konzept entwickelt, das Blockchain-Geschwindigkeitsprobleme l√∂st. <br><br>  Opporty setzt das Konzept von Plasma und Plasma Cash praktisch um. <br><br>  Plasma ist eine Reihe intelligenter Vertr√§ge, die √ºber der Ethereum-Wurzelkette ausgef√ºhrt werden und aus einem Netzwerk von untergeordneten Ketten bestehen, die in einer hierarchischen Baumstruktur mit der Wurzelkette verbunden sind. <br><br>  Das hei√üt, die Sicherheit der Ethereum-Rootchain wird verwendet, um die Skalierbarkeit zu optimieren. <br><br><h2>  Plasma Cash: Gelegenheitsoption </h2><br>  <b>Opporty verwendet die Implementierung von Plasma Cash in der ersten Version.</b> <br><br>  Dieses Modell ist hinsichtlich der Skalierbarkeit die effektivste Plasmaimplementierung. <br>  Plasma Cash ist ein System, das auf der Verwendung eindeutiger Kennungen f√ºr jeden Token in der Plasmakette basiert.  Das hei√üt, NFT wird angewendet und Token im Netzwerk erhalten eindeutige Seriennummern. <br><br>  Eigenschaften von Plasma Cash: <br><br><ul><li>  Sharded Validation auf der Client-Seite - Kunden m√ºssen nur ihre Plasmakette √ºberwachen, um ihre Token zu erhalten.  Dies bedeutet, dass der Transaktionsdurchsatz erh√∂ht werden kann, ohne die Belastung einzelner Benutzer zu erh√∂hen. </li><li>  Vereinfachung des Massenausgangs - Massenausg√§nge stellen eine geringere Bedrohung f√ºr das Netzwerk dar, da der Dieb f√ºr jeden Token, den er stehlen m√∂chte, eine Exit-Transaktion einreichen muss. </li><li>  Keine bidirektionalen Best√§tigungen - Transaktionen erfordern kein zweistufiges Senden und Best√§tigen mehr.  Stattdessen kann eine Transaktion ausgegeben werden, sobald sie in der Hauptkette enthalten ist. </li></ul><br>  Nachteil: <br><br>  Gro√üe St√ºckelungen von Token - da jedem Token eine Seriennummer zugewiesen werden muss, ist es unm√∂glich, beliebig kleine Token zu produzieren.  Dies liegt an der Tatsache, dass der Wert des Token-Kaufs irgendwann h√∂her sein wird als der Wert des Tokens. <br><br><h3>  Transaktionsstruktur in Opportunity Plasma Cash </h3><br>  Opporty verwendete Javascript, um die Kinderkette zu implementieren.  Jede Transaktion in Opporty Plasma Cash hat eine √§hnliche Struktur: <br><br><pre><code class="plaintext hljs">const transactionFields = [ {name: 'prevHash'}, {name: 'prevBlock', int: true, default: 0}, {name: 'tokenId', isDecimal: true}, {name: 'newOwner'}, {name: 'type'}, {name: 'signature'}, ]</code> </pre> <br>  Die Hauptelemente hier sind eine Verkn√ºpfung zum vorherigen prevBlock-Block (der zum Bewegen in der Blockkette erforderlich ist), die Token-ID tokenId (muss eindeutig sein) und newOwner, der letzte Eigent√ºmer des Tokens. <br><br>  Ferner wird ein spezieller Typ des Patricia Merkle Trie-Baums verwendet, um den Block zusammenzusetzen und den Wurzelketten-Hash zu erhalten.  Der gleiche Baum wird im Ethereum verwendet.  Es hat einen komprimierten Look.  Gleichzeitig k√∂nnen Sie weiterhin Nachweise √ºber die Aufnahme oder Nichteinbeziehung einer Transaktion in einen Block erhalten. <br>  Signatur ist eine Signatur auf elliptischen Kurven. <br><br>  Eine Transaktion, die ein Token mit einer bestimmten Token-ID ausgibt, ist nur g√ºltig, wenn sie im Merkle-Baum an der Position Token-ID enthalten ist, dh f√ºr jedes Token im Merkle-Baum gibt es nur einen ‚ÄûOrt‚Äú, an dem dieses Token ausgegeben wird, an dem Transaktionen zul√§ssig sind.  Mit diesem Format k√∂nnen Benutzer den vollst√§ndigen Verlauf der Plasmakette √ºberpr√ºfen sowie den Besitz bestimmter Token nachweisen und widerlegen. <br><br>  Um ein Token auszugeben, m√ºssen Sie die Kette validieren, nach fehlenden Bl√∂cken suchen und erst dann die Transaktion zusammen mit dem gesamten Verlauf neu signieren. <br><br>  Der Block ist wie folgt: <br><br><pre> <code class="plaintext hljs">const blockFields = [ {name: 'prevHash'}, {name: 'blockNum', isDecimal: true}, {name: 'transactions'}, {name: 'merkleRoot'}, {name: 'time'} ]</code> </pre> <br>  Grunds√§tzlich ist eine Blockchain einfach eine Blockkette mit einer Verkn√ºpfung zum vorherigen Block.  Eine solche Struktur erm√∂glicht es, die Eigenschaft der Unver√§nderlichkeit zu erhalten, dh die Geschichte nicht neu zu schreiben.  merkleRoot erm√∂glicht das Schreiben von Pr√ºfpunkten in die Stammkette. <br><br>  In der Stammkette sieht es auf der Ebene der intelligenten Vertr√§ge folgenderma√üen aus (Solidity-Sprache): <br><br><pre> <code class="plaintext hljs">/* * Block structure (represents one block in a chain) */ struct Block { uint block_num; bytes32 merkle_root; uint time; /* * Transaction structure (decoded from RLP form) */ struct Transaction { bytes32 prevhash; uint prev_block; uint token_id; address new_owner; }</code> </pre><br>  Die Codierung erfolgt mit den Funktionen Codierung / Decodierung - RLP-Serialisierung / Deserialisierung. <br><br><h3>  M√∂glichkeiten zur Eingabe von Plasma Cash </h3><br>  Jeder kann Geld in Plasma Cash einzahlen, indem er einfach √Ñther auf einen intelligenten Vertrag √ºbertr√§gt.  Infolgedessen wird ein OPP-Token an einer bestimmten Token-ID-Position empfangen. <br><br>  Hier ist die Implementierung in Solidity: <br><br><pre> <code class="plaintext hljs">function deposit() public payable { uint token_id = uint(keccak256(msg.sender, msg.value, deposit_blk)); // token.index = deposit_blk; tokens[token_id] = msg.value; deposit_blk += 1; emit DepositAdded(msg.sender, msg.value, token_id, current_blk); }</code> </pre> <br>  Das hei√üt, tokenId wird als Zufallszahl (Hash) generiert.  Als n√§chstes wird ein Ereignis generiert, das in der untergeordneten Kette gescannt wird. <br><br><h3>  M√∂glichkeiten zum Abheben von Plasma Cash </h3><br>  Jede Person kann ihren Token zur√ºckziehen, indem sie die letzten beiden Transaktionen in der Besitzhistorie des Tokens bereitstellt. <br><br>  Implementierung des Ausstiegs aus der Wurzelkette: <br><br><pre> <code class="plaintext hljs">function startExit(uint block_num, bytes tx1, bytes tx0, bytes proof1, bytes proof0) public returns (uint exit_id) { require(checkPatriciaProof(keccak256(tx1), childChain[block_num].merkle_root, proof1)); bytes32 prev_hash; uint prev_blk; uint token_id; address new_owner; (prev_hash, prev_blk, token_id, new_owner,) = getTransactionFromRLP(tx1); require(msg.sender == new_owner); require(tokens[token_id] &gt; 0); bytes32 hashPrevTx = keccak256(tx0); require(checkPatriciaProof(hashPrevTx, childChain[prev_blk].merkle_root, proof0)); require(prev_hash == hashPrevTx); Exit storage record = exitRecords[token_id]; require(record.block_num == 0); record.block_num = block_num; record.new_owner = msg.sender; record.prev_block = prev_blk; if (childChain[block_num].time &gt; block.timestamp - week) record.priority = childChain[block_num].time; else record.priority = block.timestamp - week; exits.add(record.priority); exit_ids[record.priority].push(token_id); emit ExitAdded(msg.sender, record.priority, token_id); return token_id; }</code> </pre><br>  Zun√§chst werden zwei Transaktionen gepr√ºft.  Wenn der aktuelle Benutzer der Eigent√ºmer der Transaktion ist, f√ºgen wir einfach die Ausgabe zur Struktur hinzu und lassen zwei Wochen Zeit, um die Ausgabe herauszufordern. <br><br>  Die Schlussfolgerung kann auf drei Arten angefochten werden: <br><br><ul><li>  Best√§tigung der Ausgaben f√ºr Transaktionen: </li></ul><br><pre> <code class="plaintext hljs">function challengeSpent(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); require(prev_block == record.block_num &amp;&amp; record.block_num &lt; blk_num); require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Wenn es eine Transaktion gibt, die den angezeigten Token bereits ausgibt, wird eine solche Auszahlung storniert! <br><br><ul><li>  Kostennachweis f√ºr die vorherige Transaktion: </li></ul><br><pre> <code class="plaintext hljs">/* * Challenge exit by providing * a proof of a transaction spending P(C) that appears before C */ function challengeDoubleSpend(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); // bytes32 prev_hash; uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); // check if token double spent require(prev_block == record.prev_block &amp;&amp; blk_num &lt; record.block_num); // require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Dies ist die gleiche Pr√ºfung, als ob der Token vor der Auszahlung ausgegeben worden w√§re.  Suchen Sie zun√§chst im Root-Hash nach einer Transaktion.  Als n√§chstes l√∂schen wir die Ausgabe, wenn sie bereits ausgegeben wurde. <br><br><ul><li>  Bereitstellen einer Transaktion in der Transaktionshistorie des Tokens davor. </li></ul><br>  Dies kann eine falsche Geschichte sein, daher m√ºssen Sie sie mit einer untergeordneten Transaktion best√§tigen: <br><br><pre> <code class="plaintext hljs">// */ function challengeInvalidHistory(uint exit_id, uint blk_num, bytes tx0, bytes proof) public { // check if proof is valid require(checkPatriciaProof(keccak256(tx0), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); bytes32 prev_hash; uint token_id; (prev_hash, , token_id, ) = getTransactionFromRLP(tx0); //require(exit_id == token_id); require(tokens[token_id] &gt; 0); // transaction should be before exit tx in history require(blk_num &lt; record.block_num - 1); challenged[exit_id] = blk_num; emit ChallengedInvalidHistory(exit_id, token_id); }</code> </pre><br>  Das Aufrufen des ersten und zweiten Skripts blockiert die Ausgabe sofort. <br><br>  Der Aufruf zum dritten Szenario kann durch Angabe eines direkten Nachkommen beantwortet werden.  Es muss gleich oder vor der √ºbergeordneten Transaktion sein. <br><br><pre> <code class="plaintext hljs">/* * Respond to invalid history challenge by providing * the direct child of C*, which must be either equal to or before P( C ) */ function respondChallenge(uint exit_id, uint blk_num, bytes childtx, bytes proof) public { require(challenged[exit_id] &gt; 0); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); require(checkPatriciaProof(keccak256(childtx), childChain[blk_num].merkle_root, proof)); // get transaction from rlpencoded form bytes32 prev_hash; uint prev_block; uint token_id; (prev_hash, prev_block, token_id, ) = getTransactionFromRLP(childtx); // if direct child if (prev_block == challenged[exit_id] ) { if (blk_num &lt;= record.prev_block &amp;&amp; token_id == exit_id ) { delete challenged[exit_id]; emit ExitRespondedEvent(exit_id); } else { exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); } } }</code> </pre><br>  Das hei√üt, wenn die richtige untergeordnete Transaktion empfangen wird, ist die Ausgabe umstritten und bleibt in der Warteschlange! <br>  Nach dem Aufbau eines Teils des Opporty Plasma Cash-Protokolls wurde die folgende Schlussfolgerung gezogen: <br>  Dieses Protokoll bietet Sicherheit √ºber die Ethereum-Stammkette. <br><br>  Durch die Komplikation der Eingabe- und Ausgabeprozeduren aus der Stammkette und der Statuskomprimierung (Transaktionsbl√∂cke) haben wir alle Methoden der Ausgabe und Eingabe in die Stammkette untersucht und auch die grundlegenden Datenstrukturen untersucht: Transaktionen und Bl√∂cke. <br><br>  Mit der Sidechain, die auf dem Ethereum-Netzwerk basiert, k√∂nnen Sie Transaktionen erheblich beschleunigen.  Opporty erhielt bis zu <b>300.000</b> Transaktionen pro Sekunde mit einem einzigen Bediener.  Dies ist viel mehr als das, was aktuelle Zahlungssysteme bieten k√∂nnen. <br><br>  Trotz einiger Probleme bei der Datenverf√ºgbarkeit bietet der Betreiber ein hohes Ma√ü an Stabilit√§t der Blockchain und erm√∂glicht die Durchf√ºhrung effektiver internationaler Gesch√§ftstransaktionen. <br><br>  Plasma Cash bringt eine enorme Steigerung der Skalierbarkeit.  Daher verwendet Opporty Plasma als Teil seines PoE-Protokolls. <br><br><h3>  N√ºtzliche Links </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wei√übuchplasma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Git Hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungsf√§lle und Architekturbeschreibung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightning-Netzwerkpapier</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457518/">https://habr.com/ru/post/de457518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457508/index.html">Elternschaft gegen maschinelles Lernen: Vergleicht eine junge Mutter</a></li>
<li><a href="../de457510/index.html">Verwenden Sie mcrouter, um memcached horizontal zu skalieren</a></li>
<li><a href="../de457512/index.html">Logische Replikation zwischen PostgreSQL-Versionen</a></li>
<li><a href="../de457514/index.html">Nevanger</a></li>
<li><a href="../de457516/index.html">Schreiben eines Bedrohungsmodells</a></li>
<li><a href="../de457522/index.html">Erh√∂hen Sie Ihren Mailinglistendienst oder verwenden Sie vorgefertigte L√∂sungen? Was ich √ºber 5 Jahre bei UniSender gelernt habe</a></li>
<li><a href="../de457524/index.html">Tiefenkameras - stille Revolution (wenn Roboter sehen) Teil 1</a></li>
<li><a href="../de457526/index.html">Technische Medien als Basar</a></li>
<li><a href="../de457532/index.html">Es ist h√∂chste Zeit, Teil eines Open Source-Projekts zu werden</a></li>
<li><a href="../de457534/index.html">Zertifizierte Versionen - der Rechen, den wir w√§hlen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>