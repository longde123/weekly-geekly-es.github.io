<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↖️ 🙍🏾 🧚 Plasma Cash Chain als Lösung für das Blockchain-Skalierbarkeitstrilemma 👩🏻‍🤝‍👨🏾 👩‍❤️‍👩 👴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, liebe Leser! 

 Dieser Artikel befasst sich mit der Plasma-Geldkette und beleuchtet die folgenden Themen: 



- das Skalierbarkeitstrilemma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plasma Cash Chain als Lösung für das Blockchain-Skalierbarkeitstrilemma</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457518/">  Guten Tag, liebe Leser! <br><br>  Dieser Artikel befasst sich mit der Plasma-Geldkette und beleuchtet die folgenden Themen: <br><br><ul><li>  das Skalierbarkeitstrilemma und die Methoden für seine Lösung; </li><li>  Datenstrukturen der untergeordneten Kette und ihre Anzeige in der Wurzelkette; </li><li>  Implementierung von Eingaben in die Wurzelkette; </li><li>  Umsetzung des Rückzugs aus der Wurzelkette. </li></ul><br>  Opporty verwendete die Programmiersprache Javascript, um die untergeordnete Kette zu implementieren, sowie Solidity für die Stammkette.  Codebeispiele werden in diesen Sprachen bereitgestellt. <br><br><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  Blockchain und Dezentralisierung ermöglichen es, die Arbeit in nahezu allen Lebensbereichen, in denen das Internet und Informationstechnologien verwendet werden, zu optimieren und zu verbessern.  Sie erhöhen die Zuverlässigkeit, die finanzielle Effizienz und erleichtern die Digitalisierung realer Dinge und Güter. <br><br>  Intelligente Verträge bringen Geschäftslogik in dezentrale Netzwerke.  Auf diese Weise können Sie neue DAPP-Anwendungen erstellen. <br><br>  Die Ausführung intelligenter Verträge und der schnelle Betrieb von Anwendungen mit einer verteilten Datenbank ist nur möglich, wenn die Skalierbarkeitsbedingung erfüllt ist. <br><br>  Moderne dezentrale Blockchains haben mehrere Nachteile.  Das wichtigste ist die Skalierbarkeit.  Das Ethereum verarbeitet ungefähr 20 tx / s.  Dies reicht in modernen Finanzrealitäten nicht aus.  Gleichzeitig bietet Ethereum den höchstmöglichen Schutz vor Hacking und Netzwerkausfällen.  Andere Kryptowährungen und Systeme, die auf der Blockchain basieren, weisen keinen so hohen Dezentralisierungsgrad auf, was das Vertrauen in das Netzwerk verringert. <br><br><h2>  Das Skalierbarkeitstrilemma </h2><br>  Es gibt ein Blockchain-Skalierbarkeitstrilemma, das drei Komponenten umfasst: <br><br><ul><li>  Dezentralisierung; </li><li>  Sicherheit </li><li>  Skalierbarkeit. </li></ul><br><h3>  Dezentralisierung im Trilemma </h3><br>  Die Dezentralisierung spiegelt, wie der Begriff schon sagt, den Grad der Diversifizierung des Eigentums an Aktivitäten in der Blockchain sowie den Grad der Diversifizierung der Erstellung von Blöcken und der Generierung neuer Hauptbucheinträge wider. <br><br>  Aus Gründen der Klarheit ist es notwendig, über die am stärksten zentralisierten Organisationen zu sprechen.  Normalerweise wird anstelle der Blockchain eine einfache Datenbank verwendet.  Eine solche Organisation wird von speziellen Administratoren betrieben.  Alle Transaktionen können durch manuelles Eingreifen storniert werden. <br><br>  In vollständig dezentralen Netzwerken kann jeder Benutzer am Aufbau eines Netzwerks teilnehmen. <br><br>  Die wichtigste Folge der Dezentralisierung ist, dass der größte Teil des Werts an die Community geht, die an der Erstellung der Blockchain beteiligt ist.  Es gibt kein zwischengeschaltetes Team von Managern, die alle Vorteile erhalten, anstatt diejenigen, die die Netzwerkstruktur selbst generieren.  Tatsächlich sind die meisten Krypto-Projekte zu 100% im Besitz ihrer Mitwirkenden oder Benutzer, nicht der Gründer.  Dies ist offensichtlich ein attraktiveres Modell für diejenigen, die kein Gründer sind. <br><br><h3>  Sicherheit im Trilemma </h3><br>  Es geht um die Fähigkeit der Blockchain, Angriffen von externen Quellen standzuhalten und das System in einem unveränderten Zustand zu halten.  Die meisten Blockchains sind vielen potenziellen Sicherheitsbedrohungen ausgesetzt.  Es ist unbedingt erforderlich, die gängigsten Angriffsmethoden und Verteidigungsoptionen zu kennen. <br><br>  In diesem Fall gehen Dezentralisierung und Sicherheit Hand in Hand.  Je mehr Knoten vorhanden sind, desto weniger hängt das Netzwerk von der zentralen Seite ab und daher besteht das Risiko eines zentralen Fehlerpunkts.  Es gibt jedoch viele andere Angriffsmethoden, die eine Bedrohung für dezentrale Netzwerke darstellen, darunter: <br>  &gt; <b>50% Angriff</b> - Ein Objekt, das mehr als 50% der Gesamtzahl der nicht bezahlten Token besitzt, besitzt tatsächlich das Netzwerk. <br>  &gt; <b>Sybil-Angriff</b> - Der Benutzer kann viele Kennungen im System generieren, um einen signifikanten Anteil am Eigentum und / oder an der Entscheidungsfindung im Netzwerk effektiv zu steuern. <br>  &gt; <b>DDoS</b> - Ein DDoS-Angriff (Distributed Denial of Service) tritt auf, wenn der Datenverkehr im Netzwerk unterbrochen und das Netzwerk mit böswilligen Transaktionen gefüllt werden soll. <br>  &gt; <b>Kollusionsangriff</b> - Ein oder mehrere Objekte (oder Knoten) werden zusammengeführt, um böswillige Vorgänge im Netzwerk auszuführen. <br><br><h3>  Skalierbarkeit im Trilemma </h3><br>  Der Grad der Skalierbarkeit ist wichtig, da er den endgültigen Durchsatz bestimmt, dh die Obergrenze der Netzwerkgröße.  Die wichtigste Frage bei der Bewertung eines Netzwerks lautet: „Wie vielen Benutzern kann dieses System standhalten?“  Bitcoin hat derzeit zwischen 2,9 und 5,8 Millionen Brieftascheninhaber.  EOS hat mehrere tausend Mitglieder. <br><br>  Skalierbarkeit und Dezentralisierung können nebeneinander bestehen, die Sicherheit wird jedoch verringert.  Entwickler wählen die Plattformen aus, die ihren Anforderungen am besten entsprechen.  Benutzer tun dasselbe.  Die Meinungen der beiden Seiten sind manchmal unterschiedlich.  Einige Benutzer sind bereit, die Sicherheit für die Skalierbarkeit zu opfern, andere sind bereit, die Skalierbarkeit für die Sicherheit zu opfern, aber das Balancieren ist viel schwieriger. <br><br><h2>  "Heiliger Gral" in Blockchain-Technologie </h2><br>  Per Definition hat eine Blockchain nur zwei der folgenden drei Eigenschaften: <br><br><ul><li>  <b>Dezentralisierung</b> (jeder Teilnehmer hat nur Zugriff auf O © -Ressourcen, dh auf einen normalen Laptop oder einen kleinen VPS); </li><li>  <b>Skalierbarkeit</b> (Fähigkeit zur Verarbeitung von Transaktionen O (n)&gt; O ©); </li><li>  <b>Sicherheit</b> (Schutz vor Eindringlingen mit O (n) -Ressourcen). </li></ul><br><img src="https://habrastorage.org/webt/ek/zg/zr/ekzgzredr00odj5mwae4f549hzs.png"><br>  Grün: Ein ausgeglichener Zustand mit drei Bedingungen. <br>  Rot: Starke Sicherheit, aber eingeschränkte Dezentralisierung und Skalierbarkeit. <br>  Blau: Die Effizienz ist hoch, aber Sicherheit und Dezentralisierung sind begrenzt. <br>  Schwarz: Die Dezentralisierung ist hoch, aber es gibt keine Aspekte der Skalierbarkeit und Sicherheit. <br>  Grau: vollständige Dezentralisierung mit minimalen oder fehlenden Sicherheits- und Skalierbarkeitseigenschaften. <br>  Violett: ein ausgewogenes Verhältnis zwischen Sicherheit und Skalierbarkeit, die Ablehnung der Dezentralisierung. <br><br>  Der „heilige Gral“ in der Blockchain-Technologie bedeutet, alle drei Aspekte zu kombinieren. <br>  In den meisten aktuellen Projekten, die mit Kryptowährungen arbeiten, werden zwei grundlegende Eigenschaften erreicht: Dezentralisierung und Sicherheit.  Die Skalierbarkeit leidet. <br><br><h2>  Vielversprechende Lösungen für das Trilemma </h2><br><h3>  Nachweis des Einsatzes (PoS) </h3><br>  Proof of Stake (PoS) bietet potenzielle Verbesserungen der Skalierbarkeit.  POS ersetzt Cryptocurrency Mining basierend auf dem PoW-System (Proof of Work).  Die Wahl des Validators ist sehr schnell - deterministisch.  Gleichzeitig fallen keine Energiekosten an und es ist umweltfreundlich. <br><br><h3>  Seitenketten </h3><br>  Im virtuellen Ethereum-Netzwerk ist es möglich, ein Seitennetzwerk zu erstellen, in dem das Projekt seine einzelnen Transaktionen verarbeiten kann, und dann nur die Anfangs- und Endergebnisse im Ethereum-Netzwerk aufzuzeichnen.  Dies reduziert die Belastung des EVM, gibt jedoch mehr Vertrauen in die Verwaltung der Sidechain.  Das Vertrauen in Dritte reduziert somit die Dezentralisierung. <br><br><h3>  Scherben </h3><br>  Durch das Sharding werden Transaktionen in kleinere Daten aufgeteilt.  Anstelle jedes einzelnen Knotens im Netzwerk, der ganze Transaktionen verarbeitet, werden Knoten in Gruppen unterteilt, und diese Knotengruppen verarbeiten bestimmte Daten.  Später, während der Verarbeitung, werden diese Daten zur dauerhaften Speicherung in der Blockchain erneut assimiliert. <br><br><h3>  Blockgröße erhöhen </h3><br>  Litecoin und Bitcoin Cash (BCH) sind „Gabeln“ für die Bitcoin-Blockchain.  Forking kopiert grundsätzlich eine Blockchain.  Nach der Verzweigung können Sie Änderungen vornehmen.  Sowohl LTC als auch BCH erhöhten die Größe jedes Blocks, wodurch mehr Transaktionen pro Block gespeichert werden konnten, wodurch die Verarbeitungsgeschwindigkeit von Transaktionen erhöht wurde. <br><br><h3>  Blitznetzwerk </h3><br>  Die allererste Sidechain-Lösung war Lightning.  Die Hauptidee des Lightning-Netzwerks besteht darin, dass nicht alle Transaktionen in der Blockchain aufgezeichnet werden sollten, da dies das Netzwerk überlastet.  Wenn Benutzer mehrmals Geld untereinander überweisen, ist die Registrierung jeder Überweisung optional.  Es reicht aus, nur eine Art Zahlungskanal zu öffnen und die Daten über die Öffnung in der Blockchain aufzuschreiben.  Dieser Kanal bleibt nach Bedarf geöffnet.  Wenn es notwendig ist, es zu schließen, wird das Ergebnis aller in diesem Kanal getätigten Transaktionen einfach in die Blockchain geschrieben.  Nach dieser Idee können Sie ein ganzes Netzwerk von Zahlungskanälen erstellen.  Dann werden Transaktionen in der Blockchain viel seltener verwendet. <br><br>  Ein Zahlungskanal ist nur eine Kombination mehrerer Transaktionen.  Ein Kanal kann von jedem seiner Mitglieder geschlossen werden.  Diese Aktion ist wie das Öffnen eines Safes, mit dem Sie die Gelder der Teilnehmer nehmen und die Daten zu ihrer Überweisung in die Blockchain aufschreiben können. <br>  Diese Technologie wird sehr leistungsfähig, wenn mehrere solcher Kanäle zu einem Netzwerk namens The Lightning Network kombiniert werden.  Dieses Netzwerk wurde speziell für Bitcoin entwickelt. <br><br><h3>  Raiden-Netzwerk </h3><br>  Für Ethereum ist das Raiden-Netzwerk das bekannteste Gegenstück zu Lightning. <br>  Dies ist eine Lösung für die Skalierung außerhalb der Hauptblockkette.  Es ist kompatibel mit der Übertragung von ERC-20-Token in bidirektionale Zahlungskanäle. <br><br>  Die grundlegende Architektur ist komplex, aber für die Interaktion mit Raiden müssen Entwickler nur mit der API interagieren, um skalierbare Anwendungen auf Raiden zu erstellen. <br><br>  Raiden wurde entwickelt, um sofortige Zahlungen und niedrige Provisionen bereitzustellen, die Vertraulichkeit von Transaktionen zu erhöhen und Mikrozahlungen zu leisten.  Die meisten Zahlungskanäle existieren außerhalb des Netzwerks und bilden nur gelegentlich Transaktionen innerhalb der Stammkette, wodurch der Durchsatz der untergeordneten Kette erheblich reduziert wird. <br><br><h2>  Optimale Lösung </h2><br>  Blitzideologen haben ein neues Childchain-Konzept entwickelt, das Blockchain-Geschwindigkeitsprobleme löst. <br><br>  Opporty setzt das Konzept von Plasma und Plasma Cash praktisch um. <br><br>  Plasma ist eine Reihe intelligenter Verträge, die über der Ethereum-Wurzelkette ausgeführt werden und aus einem Netzwerk von untergeordneten Ketten bestehen, die in einer hierarchischen Baumstruktur mit der Wurzelkette verbunden sind. <br><br>  Das heißt, die Sicherheit der Ethereum-Rootchain wird verwendet, um die Skalierbarkeit zu optimieren. <br><br><h2>  Plasma Cash: Gelegenheitsoption </h2><br>  <b>Opporty verwendet die Implementierung von Plasma Cash in der ersten Version.</b> <br><br>  Dieses Modell ist hinsichtlich der Skalierbarkeit die effektivste Plasmaimplementierung. <br>  Plasma Cash ist ein System, das auf der Verwendung eindeutiger Kennungen für jeden Token in der Plasmakette basiert.  Das heißt, NFT wird angewendet und Token im Netzwerk erhalten eindeutige Seriennummern. <br><br>  Eigenschaften von Plasma Cash: <br><br><ul><li>  Sharded Validation auf der Client-Seite - Kunden müssen nur ihre Plasmakette überwachen, um ihre Token zu erhalten.  Dies bedeutet, dass der Transaktionsdurchsatz erhöht werden kann, ohne die Belastung einzelner Benutzer zu erhöhen. </li><li>  Vereinfachung des Massenausgangs - Massenausgänge stellen eine geringere Bedrohung für das Netzwerk dar, da der Dieb für jeden Token, den er stehlen möchte, eine Exit-Transaktion einreichen muss. </li><li>  Keine bidirektionalen Bestätigungen - Transaktionen erfordern kein zweistufiges Senden und Bestätigen mehr.  Stattdessen kann eine Transaktion ausgegeben werden, sobald sie in der Hauptkette enthalten ist. </li></ul><br>  Nachteil: <br><br>  Große Stückelungen von Token - da jedem Token eine Seriennummer zugewiesen werden muss, ist es unmöglich, beliebig kleine Token zu produzieren.  Dies liegt an der Tatsache, dass der Wert des Token-Kaufs irgendwann höher sein wird als der Wert des Tokens. <br><br><h3>  Transaktionsstruktur in Opportunity Plasma Cash </h3><br>  Opporty verwendete Javascript, um die Kinderkette zu implementieren.  Jede Transaktion in Opporty Plasma Cash hat eine ähnliche Struktur: <br><br><pre><code class="plaintext hljs">const transactionFields = [ {name: 'prevHash'}, {name: 'prevBlock', int: true, default: 0}, {name: 'tokenId', isDecimal: true}, {name: 'newOwner'}, {name: 'type'}, {name: 'signature'}, ]</code> </pre> <br>  Die Hauptelemente hier sind eine Verknüpfung zum vorherigen prevBlock-Block (der zum Bewegen in der Blockkette erforderlich ist), die Token-ID tokenId (muss eindeutig sein) und newOwner, der letzte Eigentümer des Tokens. <br><br>  Ferner wird ein spezieller Typ des Patricia Merkle Trie-Baums verwendet, um den Block zusammenzusetzen und den Wurzelketten-Hash zu erhalten.  Der gleiche Baum wird im Ethereum verwendet.  Es hat einen komprimierten Look.  Gleichzeitig können Sie weiterhin Nachweise über die Aufnahme oder Nichteinbeziehung einer Transaktion in einen Block erhalten. <br>  Signatur ist eine Signatur auf elliptischen Kurven. <br><br>  Eine Transaktion, die ein Token mit einer bestimmten Token-ID ausgibt, ist nur gültig, wenn sie im Merkle-Baum an der Position Token-ID enthalten ist, dh für jedes Token im Merkle-Baum gibt es nur einen „Ort“, an dem dieses Token ausgegeben wird, an dem Transaktionen zulässig sind.  Mit diesem Format können Benutzer den vollständigen Verlauf der Plasmakette überprüfen sowie den Besitz bestimmter Token nachweisen und widerlegen. <br><br>  Um ein Token auszugeben, müssen Sie die Kette validieren, nach fehlenden Blöcken suchen und erst dann die Transaktion zusammen mit dem gesamten Verlauf neu signieren. <br><br>  Der Block ist wie folgt: <br><br><pre> <code class="plaintext hljs">const blockFields = [ {name: 'prevHash'}, {name: 'blockNum', isDecimal: true}, {name: 'transactions'}, {name: 'merkleRoot'}, {name: 'time'} ]</code> </pre> <br>  Grundsätzlich ist eine Blockchain einfach eine Blockkette mit einer Verknüpfung zum vorherigen Block.  Eine solche Struktur ermöglicht es, die Eigenschaft der Unveränderlichkeit zu erhalten, dh die Geschichte nicht neu zu schreiben.  merkleRoot ermöglicht das Schreiben von Prüfpunkten in die Stammkette. <br><br>  In der Stammkette sieht es auf der Ebene der intelligenten Verträge folgendermaßen aus (Solidity-Sprache): <br><br><pre> <code class="plaintext hljs">/* * Block structure (represents one block in a chain) */ struct Block { uint block_num; bytes32 merkle_root; uint time; /* * Transaction structure (decoded from RLP form) */ struct Transaction { bytes32 prevhash; uint prev_block; uint token_id; address new_owner; }</code> </pre><br>  Die Codierung erfolgt mit den Funktionen Codierung / Decodierung - RLP-Serialisierung / Deserialisierung. <br><br><h3>  Möglichkeiten zur Eingabe von Plasma Cash </h3><br>  Jeder kann Geld in Plasma Cash einzahlen, indem er einfach Äther auf einen intelligenten Vertrag überträgt.  Infolgedessen wird ein OPP-Token an einer bestimmten Token-ID-Position empfangen. <br><br>  Hier ist die Implementierung in Solidity: <br><br><pre> <code class="plaintext hljs">function deposit() public payable { uint token_id = uint(keccak256(msg.sender, msg.value, deposit_blk)); // token.index = deposit_blk; tokens[token_id] = msg.value; deposit_blk += 1; emit DepositAdded(msg.sender, msg.value, token_id, current_blk); }</code> </pre> <br>  Das heißt, tokenId wird als Zufallszahl (Hash) generiert.  Als nächstes wird ein Ereignis generiert, das in der untergeordneten Kette gescannt wird. <br><br><h3>  Möglichkeiten zum Abheben von Plasma Cash </h3><br>  Jede Person kann ihren Token zurückziehen, indem sie die letzten beiden Transaktionen in der Besitzhistorie des Tokens bereitstellt. <br><br>  Implementierung des Ausstiegs aus der Wurzelkette: <br><br><pre> <code class="plaintext hljs">function startExit(uint block_num, bytes tx1, bytes tx0, bytes proof1, bytes proof0) public returns (uint exit_id) { require(checkPatriciaProof(keccak256(tx1), childChain[block_num].merkle_root, proof1)); bytes32 prev_hash; uint prev_blk; uint token_id; address new_owner; (prev_hash, prev_blk, token_id, new_owner,) = getTransactionFromRLP(tx1); require(msg.sender == new_owner); require(tokens[token_id] &gt; 0); bytes32 hashPrevTx = keccak256(tx0); require(checkPatriciaProof(hashPrevTx, childChain[prev_blk].merkle_root, proof0)); require(prev_hash == hashPrevTx); Exit storage record = exitRecords[token_id]; require(record.block_num == 0); record.block_num = block_num; record.new_owner = msg.sender; record.prev_block = prev_blk; if (childChain[block_num].time &gt; block.timestamp - week) record.priority = childChain[block_num].time; else record.priority = block.timestamp - week; exits.add(record.priority); exit_ids[record.priority].push(token_id); emit ExitAdded(msg.sender, record.priority, token_id); return token_id; }</code> </pre><br>  Zunächst werden zwei Transaktionen geprüft.  Wenn der aktuelle Benutzer der Eigentümer der Transaktion ist, fügen wir einfach die Ausgabe zur Struktur hinzu und lassen zwei Wochen Zeit, um die Ausgabe herauszufordern. <br><br>  Die Schlussfolgerung kann auf drei Arten angefochten werden: <br><br><ul><li>  Bestätigung der Ausgaben für Transaktionen: </li></ul><br><pre> <code class="plaintext hljs">function challengeSpent(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); require(prev_block == record.block_num &amp;&amp; record.block_num &lt; blk_num); require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Wenn es eine Transaktion gibt, die den angezeigten Token bereits ausgibt, wird eine solche Auszahlung storniert! <br><br><ul><li>  Kostennachweis für die vorherige Transaktion: </li></ul><br><pre> <code class="plaintext hljs">/* * Challenge exit by providing * a proof of a transaction spending P(C) that appears before C */ function challengeDoubleSpend(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); // bytes32 prev_hash; uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); // check if token double spent require(prev_block == record.prev_block &amp;&amp; blk_num &lt; record.block_num); // require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  Dies ist die gleiche Prüfung, als ob der Token vor der Auszahlung ausgegeben worden wäre.  Suchen Sie zunächst im Root-Hash nach einer Transaktion.  Als nächstes löschen wir die Ausgabe, wenn sie bereits ausgegeben wurde. <br><br><ul><li>  Bereitstellen einer Transaktion in der Transaktionshistorie des Tokens davor. </li></ul><br>  Dies kann eine falsche Geschichte sein, daher müssen Sie sie mit einer untergeordneten Transaktion bestätigen: <br><br><pre> <code class="plaintext hljs">// */ function challengeInvalidHistory(uint exit_id, uint blk_num, bytes tx0, bytes proof) public { // check if proof is valid require(checkPatriciaProof(keccak256(tx0), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); bytes32 prev_hash; uint token_id; (prev_hash, , token_id, ) = getTransactionFromRLP(tx0); //require(exit_id == token_id); require(tokens[token_id] &gt; 0); // transaction should be before exit tx in history require(blk_num &lt; record.block_num - 1); challenged[exit_id] = blk_num; emit ChallengedInvalidHistory(exit_id, token_id); }</code> </pre><br>  Das Aufrufen des ersten und zweiten Skripts blockiert die Ausgabe sofort. <br><br>  Der Aufruf zum dritten Szenario kann durch Angabe eines direkten Nachkommen beantwortet werden.  Es muss gleich oder vor der übergeordneten Transaktion sein. <br><br><pre> <code class="plaintext hljs">/* * Respond to invalid history challenge by providing * the direct child of C*, which must be either equal to or before P( C ) */ function respondChallenge(uint exit_id, uint blk_num, bytes childtx, bytes proof) public { require(challenged[exit_id] &gt; 0); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); require(checkPatriciaProof(keccak256(childtx), childChain[blk_num].merkle_root, proof)); // get transaction from rlpencoded form bytes32 prev_hash; uint prev_block; uint token_id; (prev_hash, prev_block, token_id, ) = getTransactionFromRLP(childtx); // if direct child if (prev_block == challenged[exit_id] ) { if (blk_num &lt;= record.prev_block &amp;&amp; token_id == exit_id ) { delete challenged[exit_id]; emit ExitRespondedEvent(exit_id); } else { exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); } } }</code> </pre><br>  Das heißt, wenn die richtige untergeordnete Transaktion empfangen wird, ist die Ausgabe umstritten und bleibt in der Warteschlange! <br>  Nach dem Aufbau eines Teils des Opporty Plasma Cash-Protokolls wurde die folgende Schlussfolgerung gezogen: <br>  Dieses Protokoll bietet Sicherheit über die Ethereum-Stammkette. <br><br>  Durch die Komplikation der Eingabe- und Ausgabeprozeduren aus der Stammkette und der Statuskomprimierung (Transaktionsblöcke) haben wir alle Methoden der Ausgabe und Eingabe in die Stammkette untersucht und auch die grundlegenden Datenstrukturen untersucht: Transaktionen und Blöcke. <br><br>  Mit der Sidechain, die auf dem Ethereum-Netzwerk basiert, können Sie Transaktionen erheblich beschleunigen.  Opporty erhielt bis zu <b>300.000</b> Transaktionen pro Sekunde mit einem einzigen Bediener.  Dies ist viel mehr als das, was aktuelle Zahlungssysteme bieten können. <br><br>  Trotz einiger Probleme bei der Datenverfügbarkeit bietet der Betreiber ein hohes Maß an Stabilität der Blockchain und ermöglicht die Durchführung effektiver internationaler Geschäftstransaktionen. <br><br>  Plasma Cash bringt eine enorme Steigerung der Skalierbarkeit.  Daher verwendet Opporty Plasma als Teil seines PoE-Protokolls. <br><br><h3>  Nützliche Links </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weißbuchplasma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Git Hub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungsfälle und Architekturbeschreibung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightning-Netzwerkpapier</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457518/">https://habr.com/ru/post/de457518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457508/index.html">Elternschaft gegen maschinelles Lernen: Vergleicht eine junge Mutter</a></li>
<li><a href="../de457510/index.html">Verwenden Sie mcrouter, um memcached horizontal zu skalieren</a></li>
<li><a href="../de457512/index.html">Logische Replikation zwischen PostgreSQL-Versionen</a></li>
<li><a href="../de457514/index.html">Nevanger</a></li>
<li><a href="../de457516/index.html">Schreiben eines Bedrohungsmodells</a></li>
<li><a href="../de457522/index.html">Erhöhen Sie Ihren Mailinglistendienst oder verwenden Sie vorgefertigte Lösungen? Was ich über 5 Jahre bei UniSender gelernt habe</a></li>
<li><a href="../de457524/index.html">Tiefenkameras - stille Revolution (wenn Roboter sehen) Teil 1</a></li>
<li><a href="../de457526/index.html">Technische Medien als Basar</a></li>
<li><a href="../de457532/index.html">Es ist höchste Zeit, Teil eines Open Source-Projekts zu werden</a></li>
<li><a href="../de457534/index.html">Zertifizierte Versionen - der Rechen, den wir wählen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>