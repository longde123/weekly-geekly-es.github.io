<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤒 🤾🏻 👩🏾‍🤝‍👨🏽 À propos du comptage de bits, des types non signés dans Kotlin et des situations où il est justifié d'enregistrer des correspondances 🧦 📖 👩🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce commentaire a été suscité par la rédaction de l'article. Plus précisément, une phrase de celui-ci. 
 ... dépenser des cycles de mémoire ou de proce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>À propos du comptage de bits, des types non signés dans Kotlin et des situations où il est justifié d'enregistrer des correspondances</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/451622/"><img src="https://habrastorage.org/webt/b6/qc/5k/b6qc5klplot_lkmjsi0edrecbye.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ce commentaire a été</a> suscité par la rédaction de l'article.  Plus précisément, une phrase de celui-ci. <br><blockquote>  ... dépenser des cycles de mémoire ou de processeur sur des articles en milliards de dollars n'est pas bon ... <br></blockquote>  Il se trouve que récemment, je devais faire exactement cela.  Et, bien que le cas que j'examinerai dans l'article soit assez spécial - les conclusions et les solutions appliquées peuvent être utiles à quelqu'un. <br><br><h1>  Un peu de contexte </h1><br>  L'application iFunny traite une énorme quantité de contenu graphique et vidéo, et la recherche floue de doublons est l'une des tâches très importantes.  C'est en soi un gros sujet qui mérite un article séparé, mais aujourd'hui je vais juste parler un peu de certaines approches pour calculer de très grands tableaux de nombres par rapport à cette recherche.  Bien sûr, tout le monde a une compréhension différente des «très grands réseaux», et il serait stupide de rivaliser avec le Hadron Collider, mais quand même.  :) <br><br>  Si l'algorithme est très court, alors pour chaque image sa signature numérique (signature) est créée à partir de 968 entiers, et la comparaison est faite en trouvant la "distance" entre les deux signatures.  Étant donné que le volume de contenu au cours des deux derniers mois à lui seul s'est élevé à environ 10 millions d'images, un lecteur attentif pourra facilement le comprendre dans son esprit - ce sont exactement les «éléments en milliards de volumes».  Peu importe - bienvenue au chat. <br><a name="habracut"></a><br>  Au début, il y aura une histoire ennuyeuse sur le gain de temps et de mémoire, et à la fin il y aura une courte histoire instructive sur le fait qu'il est parfois très utile de regarder la source.  Une image pour attirer l'attention est directement liée à cette histoire instructive. <br><br>  Je dois admettre que j'étais un peu rusé.  Dans une analyse préliminaire de l'algorithme, il a été possible de réduire le nombre de valeurs dans chaque signature de 968 à 420. C'est déjà deux fois plus bon, mais l'ordre de grandeur reste le même. <br><br>  Bien que, si vous y réfléchissez, je ne suis pas si trompeur, et ce sera la première conclusion: avant de commencer la tâche, il convient de réfléchir - est-il possible de la simplifier d'une manière ou d'une autre à l'avance? <br><br>  L'algorithme de comparaison est assez simple: la racine de la somme des carrés des différences des deux signatures est calculée, divisée par la somme des valeurs précédemment calculées (c'est-à-dire qu'à chaque itération, la somme sera toujours et ne pourra pas être considérée comme une constante) et comparée à la valeur de seuil.  Il convient de noter que les éléments de signature sont limités aux valeurs de -2 à +2 et, par conséquent, la valeur absolue de la différence est limitée aux valeurs de 0 à 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cl/yh/m8/clyhm8caq35-td519odrgd95msq.png"></div><br>  Rien de compliqué, mais la quantité décide. <br><br><h1>  Première approche, naïve </h1><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  const val d = 0.3 // 10.000.000 . //      , //        val collection: MutableList&lt;Signature&gt; = mutableListOf() // signature —   420   Byte class Signature(val signature: Array&lt;Byte&gt;, val norma: Double) fun getSimilar(signature: Signature) = collection .filter { calculateDistance(it, signature) &lt; d } fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; Math.pow((value - second.signature[index]).toDouble(), 2.0) }.sum()) / (first.norma + second.norma)</span></span></code> </pre> <br>  Calculons ce que nous avons ici avec le nombre d'opérations: <br><br>  <code>10M</code> Square Roots <code>Math.sqrt</code> <br>  <code>10M</code> et divisions de <code>10M</code> <code>/ (first.norma + second.norma)</code> <br>  <code>4.200M</code> soustractions et quadrature <code>Math.pow((value - second.signature[index]).toDouble(), 2.0)</code> <br>  <code>4.200M</code> ajouts <code>.sum()</code> <br><br>  Quelles options avons-nous: <br><br><ol><li>  Avec de tels volumes, dépenser un <code>Byte</code> entier (ou, Dieu ne plaise, quelqu'un aurait deviné utiliser <code>Int</code> ) pour stocker trois bits importants est un gaspillage impardonnable. </li><li>  Peut-être, comment réduire la quantité de mathématiques? </li><li>  Mais est-il possible de faire un filtrage préliminaire, qui n'est pas si coûteux en calcul? </li></ol><br><h1>  La deuxième approche, nous emballons </h1><br>  <i>Soit dit en passant, si quelqu'un suggère comment vous pouvez simplifier les calculs avec un tel emballage, vous recevrez un grand merci et plus en karma.</i>  <i>Bien qu'un, mais de tout mon cœur :)</i> <br><br>  Un <code>Long</code> est de 64 bits, ce qui, dans notre cas, nous permettra d'y stocker 21 valeurs (et 1 bit restera non réglé). <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   20   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) fun calculateDistance(first: Signature, second: Signature): Double = Math.sqrt(first.signature.mapIndexed { index, value -&gt; calculatePartial(value, second.signature[index]) }.sum()) / (first.norma + second.norma) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L (0..60 step 3).onEach { val current = (first.ushr(it) and 0x7) - (second.ushr(it) and 0x7) sum += current * current } return sum.toDouble() }</span></span></code> </pre><br>  C'est mieux de la mémoire ( <code>4.200M</code> contre <code>1.600M</code> octets, si grosso modo), mais qu'en est-il des calculs? <br><br>  Je pense qu'il est évident que le nombre d'opérations est resté le même et que <code>8.400M</code> décalages et <code>8.400M</code> logiques y ont <code>8.400M</code> ajoutés. Peut-être que cela peut être optimisé, mais la tendance n'est toujours pas heureuse - ce n'est pas ce que nous voulions. <br><br><h1>  La troisième approche, reconditionner avec des sous-sous-marins </h1><br>  Le matin, je me sens, ici, vous pouvez utiliser un peu de magie! <br><br>  Stockons les valeurs non pas en trois, mais en quatre bits.  De cette façon: <br><div class="scrollable-table"><table><tbody><tr><td>  -2 </td><td>  0b1100 </td></tr><tr><td>  -1 </td><td>  0b0100 </td></tr><tr><td>  0 </td><td>  0b0000 </td></tr><tr><td>  1 </td><td>  0b0010 </td></tr><tr><td>  2 </td><td>  0b0011 </td></tr></tbody></table></div><br>  Oui, nous perdrons la densité d'emballage par rapport à la version précédente, mais nous aurons la possibilité de recevoir <code>Long</code> avec 16 différences (pas tout à fait) avec un <code>XOR</code> 'ohm à la fois.  De plus, il n'y aura que 11 options pour la distribution des bits dans chaque quartet final, ce qui vous permettra d'utiliser des valeurs précalculées des carrés des différences. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//   27   Long class Signature(val signature: Array&lt;Long&gt;, val norma: Double) // -1    val precomputed = arrayOf(0, 1, 1, 4, 1, -1, 4, 9, 1, -1, -1, -1, 4, -1, 9, 16) fun calculatePartial(first: Long, second: Long): Double { var sum = 0L val difference = first xor second (0..60 step 4).onEach { sum += precomputed[(difference.ushr(it) and 0xF).toInt()] } return sum.toDouble() }</span></span></code> </pre><br>  De mémoire, il est devenu <code>2.160M</code> contre <code>1.600M</code> - désagréable, mais toujours meilleur que le <code>4.200M</code> initial. <br><br>  Calculons les opérations: <br><br>  <code>10M</code> racines carrées, ajouts et divisions (pas allé nulle part) <br>  <code>270M</code> <code>XOR</code> <br>  <code>4.320</code> ajouts, décalages, <code>4.320</code> logiques et extraits de la matrice. <br><br>  Cela semble déjà plus intéressant, mais de toute façon, il y a trop de calculs.  Malheureusement, il semble que nous ayons déjà dépensé ces 20% des efforts pour donner 80% du résultat et il est temps de réfléchir à d'autres sources de profit.  La première chose qui me vient à l'esprit est de ne pas le faire du tout, en filtrant les signatures manifestement inappropriées avec un filtre léger. <br><br><h1>  Quatrième approche, grand tamis </h1><br>  Si vous transformez légèrement la formule de calcul, vous pouvez obtenir cette inégalité (plus la distance calculée est petite, mieux c'est): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/ny/mv/nunymvgccfhu2hlexvir0d0dlvq.png"></div><br>  C'est-à-dire  maintenant, nous devons comprendre comment calculer la valeur minimale possible du côté gauche de l'inégalité sur la base des informations que nous avons sur le nombre de bits définis dans <code>Long</code> .  Ensuite, jetez simplement toutes les signatures qui ne le satisfont pas. <br>  Permettez-moi de vous rappeler que x <sub>i</sub> peut prendre des valeurs de 0 à 4 (le signe n'est pas important, je pense que c'est clair pourquoi).  Étant donné que chaque terme est au carré, il est facile de dériver un modèle général: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/pk/um/empkumsytnx11yoplffogdf4dbc.png"></div><br>  La formule finale ressemble à ceci (nous n'en avons pas besoin, mais je l'ai déduit pendant longtemps et il serait dommage d'oublier et de ne montrer à personne): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/md/xd/ramdxdoczcczinkn8bouj_40zls.png"></div><br>  Où B est le nombre de bits défini. <br><br>  En fait, dans un seul <code>Long</code> de 64 bits, lisez 64 résultats possibles.  Et ils sont parfaitement calculés à l'avance et ajoutés à un tableau, par analogie avec la section précédente. <br><br>  De plus, il est complètement facultatif de calculer les 27 Longs - il suffit de dépasser le seuil au prochain et vous pouvez interrompre le contrôle et retourner faux.  Soit dit en passant, la même approche peut être utilisée dans le calcul principal. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .asSequence() <span class="hljs-comment"><span class="hljs-comment">//     !? .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d } val estimateValues = arrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 69, 74, 79, 84, 89, 94, 99, 104, 109, 114, 119, 124, 129, 134, 139, 144, 151, 158, 165, 172, 179, 186, 193, 200, 207, 214, 221, 228, 235, 242, 249, 256) fun estimate(first: Signature, second: Signature):Boolean{ var bitThreshold = Math.pow(d * (first.norma + second.norma), 2.0).toLong() first.signature.forEachIndexed { index, value -&gt; bitThreshold -= estimateValues[java.lang.Long.bitCount(value xor second.signature[index])] if (bitThreshold &lt;= 0) return false } return true }</span></span></code> </pre><br>  Ici, il faut comprendre que l'efficacité de ce filtre (jusqu'à négatif) dépend de façon désastreuse du seuil sélectionné et, un peu moins fortement, des données d'entrée.  Heureusement, pour le seuil requis <code>d=0.3</code> un nombre assez faible d'objets réussit à passer le filtre et la contribution de leur calcul au temps de réponse total est si faible qu'ils peuvent être négligés.  Et si c'est le cas, vous pouvez économiser un peu plus. <br><br><h1>  Cinquième approche, se débarrasser de la séquence </h1><br>  Lorsque vous travaillez avec de grandes collections, la <code>sequence</code> est une bonne défense contre la <b>mémoire</b> extrêmement désagréable.  Cependant, si nous savons évidemment que sur le premier filtre, la collection sera réduite à une taille saine, un choix beaucoup plus raisonnable serait d'utiliser l'itération ordinaire en boucle avec la création d'une collection intermédiaire, car la <code>sequence</code> n'est pas seulement à la mode et jeune, mais aussi un itérateur, qui a des compagnons suivants qui sont loin d'être gratuits. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Signature</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = collection .filter { estimate(it, signature) } .filter { calculateDistance(it, signature) &lt; d }</code> </pre><br>  Il semblerait qu'ici c'est le bonheur, mais je voulais "le rendre beau".  Nous arrivons ici à l'histoire instructive promise. <br><br><h1>  Sixième approche, nous voulions le meilleur </h1><br>  Nous écrivons sur Kotlin, et voici quelques <code>java.lang.Long.bitCount</code> étrangers!  Et plus récemment, des types non signés ont été introduits dans la langue.  Attaque! <br><br>  Aussitôt dit, aussitôt fait.  Tous les <code>ULong</code> remplacés par <code>ULong</code> , <code>ULong</code> extrait de la source Java et réécrit en tant que fonction d'extension pour <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> ULong.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> i = i - (i.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>uL) i = (i and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) + (i.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>uL) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>) and <span class="hljs-number"><span class="hljs-number">0x0f0f0f0f0f0f0f0f</span></span>uL i = i + i.shr(<span class="hljs-number"><span class="hljs-number">8</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">16</span></span>) i = i + i.shr(<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.toInt() and <span class="hljs-number"><span class="hljs-number">0x7f</span></span> }</code> </pre><br>  Nous commençons et ... Quelque chose ne va pas.  Le code a commencé à fonctionner sensiblement plus lentement.  Nous démarrons le profileur et voyons quelque chose d'étrange (voir le <code>bitCount()</code> article): un peu moins d'un million d'appels à <code>bitCount()</code> près de 16 millions d'appels à <code>Kotlin.ULong.constructor-impl</code> .  WAT!? <br><br>  L'énigme est expliquée simplement - il suffit de regarder le code de classe <code>ULong</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ULong</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@PublishedApi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@PublishedApi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>) : Comparable&lt;ULong&gt; { <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.plus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ULong</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.minus(other.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bitCount: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> shl bitCount) <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ULong = ULong(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.inc())  .. }</code> </pre><br>  Non, je comprends tout, <code>ULong</code> est <code>experimental</code> maintenant, mais comment ça!? <br>  En général, nous reconnaissons que l'approche a échoué, ce qui est dommage. <br><br>  Eh bien, mais peut-être que quelque chose d'autre peut être amélioré? <br><br>  En fait, vous le pouvez.  Le code <code>java.lang.Long.bitCount</code> origine n'est pas le plus optimal.  Cela donne un bon résultat dans le cas général, mais si nous savons à l'avance sur quels processeurs notre application fonctionnera, alors nous pouvons choisir une manière plus optimale - voici un très bon article à ce sujet sur Habré.Je recommande vivement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compter les bits simples</a> . <br><br>  J'ai utilisé la "méthode combinée" <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Long</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> n -= (n.shr(<span class="hljs-number"><span class="hljs-number">1</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x5555555555555555L</span></span> n = ((n.shr(<span class="hljs-number"><span class="hljs-number">2</span></span>)) and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) + (n and <span class="hljs-number"><span class="hljs-number">0x3333333333333333L</span></span>) n = ((((n.shr(<span class="hljs-number"><span class="hljs-number">4</span></span>)) + n) and <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F0F0F0F0FL</span></span>) * <span class="hljs-number"><span class="hljs-number">0x0101010101010101</span></span>).shr(<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.toInt() and <span class="hljs-number"><span class="hljs-number">0x7F</span></span> }</code> </pre><br><h1>  Compter les perroquets </h1><br>  Toutes les mesures ont été effectuées au hasard, lors du développement sur la machine locale et sont reproduites de mémoire, il est donc difficile de parler de précision, mais vous pouvez estimer la contribution approximative de chaque approche. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Qu'est-ce que </th><th>  perroquets (secondes) </th></tr><tr><td>  Première approche, naïve </td><td>  25 ± </td></tr><tr><td>  La deuxième approche, nous emballons </td><td>  - </td></tr><tr><td>  La troisième approche, reconditionner avec des sous-sous-marins </td><td>  11-14 </td></tr><tr><td>  Quatrième approche, grand tamis </td><td>  2-3 </td></tr><tr><td>  Cinquième approche, se débarrasser de la séquence </td><td>  1.8-2.2 </td></tr><tr><td>  Sixième approche, nous voulions le meilleur </td><td>  3-4 </td></tr><tr><td>  "Méthode combinée" pour compter les bits définis </td><td>  1,5-1,7 </td></tr></tbody></table></div><br><h1>  Conclusions </h1><br><ul><li>  Lorsqu'il s'agit de traiter de grandes quantités de données, il vaut la peine de consacrer du temps à une analyse préliminaire.  Peut-être que toutes ces données n'ont pas besoin d'être traitées. </li><li>  Si vous pouvez utiliser un pré-filtrage grossier mais bon marché, cela peut être très utile. </li><li>  La magie un peu est notre tout.  Eh bien, le cas échéant, bien sûr. </li><li>  Regarder les codes sources des classes et fonctions standard est parfois très utile. </li></ul><br>  Merci de votre attention!  :) <br><br>  Et oui, à suivre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451622/">https://habr.com/ru/post/fr451622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451606/index.html">Histoire d'Internet: délabrement, partie 2</a></li>
<li><a href="../fr451610/index.html">Semaine de la sécurité 20: désactivation des extensions Firefox</a></li>
<li><a href="../fr451614/index.html">«Ce dont nous discutons en Russie est également pertinent en Occident»: entretien avec Denis Neklyudov</a></li>
<li><a href="../fr451618/index.html">CampusInsight: de la surveillance de l'infrastructure à l'analyse de l'expérience utilisateur</a></li>
<li><a href="../fr451620/index.html">Autorisation automatique sur la carte Strava Heatmap</a></li>
<li><a href="../fr451624/index.html">Sur la façon dont Harry Potter façonne l'éducation russe, bien sûr, pas là où vous en avez besoin</a></li>
<li><a href="../fr451626/index.html">Apprendre sans professeur: un étudiant curieux</a></li>
<li><a href="../fr451628/index.html">Top Revue 3D Expo en avril 2019</a></li>
<li><a href="../fr451630/index.html">Surveillance continue - automatisation des contrôles de qualité des logiciels dans CI / CD Pipeline</a></li>
<li><a href="../fr451634/index.html">Comment nous sommes analysés dans les magasins et les restaurants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>