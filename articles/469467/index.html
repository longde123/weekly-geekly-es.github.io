<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöù üìû üêñ C ++ vs C # üêß üôÖ üë®üèø‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos saben que no hay nada m√°s est√∫pido que discutir "qu√© idioma es mejor". Por ejemplo, ¬ømejor para qu√©? Diferentes idiomas tienen √©xito en diferent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vs C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469467/"><img src="https://habrastorage.org/webt/ud/4s/-_/ud4s-_jhcan8lv7ei9kfabnsszo.jpeg"><br><br>  Todos saben que no hay nada m√°s est√∫pido que discutir "qu√© idioma es mejor".  Por ejemplo, ¬ømejor para qu√©?  Diferentes idiomas tienen √©xito en diferentes nichos, y no tiene sentido sacar conclusiones definitivas sin tener en cuenta esto. <br><br>  Pero, ¬øqu√© sucede si recurre a especialistas experimentados que ellos mismos entienden todo esto y les pide que arreglen el holivar C ++ vs C #?  Resulta que puedes encontrar muchos detalles interesantes.  La palabra "multiplataforma" se puede aplicar de ambas maneras a ambos idiomas, pero ¬øqu√© significa esto en la pr√°ctica?  ¬øC ++ se est√° desarrollando activamente ahora?  ¬øC # ha roto alguna vez la compatibilidad con versiones anteriores?  Las respuestas pueden ser obvias para aquellos que ya est√°n profundamente inmersos en ambos idiomas a la vez, pero hay pocas de esas personas, y todos los dem√°s aprender√°n algo nuevo. <br><br>  De C ++, <b>Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">sermp</a> Platonov</b> , Presidente del Comit√© del Programa de la Conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++ Rusia</a> , particip√≥.  El lado C # estuvo representado por <b>Anatoly Kulakov</b> : est√° incluido en la PC de la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNext</a> y entre los l√≠deres de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNetRu</a> .  Y el l√≠der de la discusi√≥n, en la vida en la que coexisten ambos mundos, fue <b>Dmitry <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">mezastel</a> Nesteruk</b> . <br><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/sn/rb/_i/snrb_ie2-dnmplhnbfnl_klnvca.jpeg"><br><br>  <b>Dmitry:</b> Buenas tardes, colegas.  Bienvenido a reuniones informales sobre el tema de los lenguajes de programaci√≥n.  En Internet se nos recuerda constantemente que los idiomas no se pueden comparar.  Y hoy haremos exactamente lo que no puede hacer: comparar C ++ con C # y .NET, sus ventajas y desventajas.  Pres√©ntate por favor. <br><br>  <b>Anatoly:</b> Mi nombre es Anatoly, y hoy me ahogar√© por C #, porque he estado estudiando este lenguaje desde sus primeras versiones y, al parecer, s√© todo sobre √©l. <br><br>  <b>Sergey:</b> Hola, mi nombre es Sergey, hoy me ahogo por C ++.  Dima dijo correctamente que compararemos los pros y los contras.  Todos lo llaman "Pros", se sabe que, resulta que C # en esta discusi√≥n ser√° un signo negativo.  ¬øEs eso cierto, Anatoly? <br><br>  <b>Anatoly: ¬°</b> C # tiene dos ventajas m√°s!  Por lo tanto, creo que este es un desarrollo evolutivo de las ventajas que ya son obsoletas y que no pueden competir en casi ning√∫n lugar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/wy/sj/_pwysj2lxe1ncg6lmuzqxfs2dg0.jpeg"></div><br><br><h2>  Educacion </h2><br>  <b>Dmitry:</b> Tengo el primer tema para nuestra discusi√≥n.  Imagine que los nuevos estudiantes vienen a la universidad, necesitan el primer idioma.  ¬øCu√°l crees que deber√≠a ser el primer idioma que las personas obtienen en su primer a√±o: C ++, C # o ensamblador en general? <br><br>  <b>Sergey:</b> Ense√±√© durante alg√∫n tiempo, as√≠ que tengo una opini√≥n establecida.  Entiendo que aqu√≠ vamos a discutir qu√© lenguaje es mejor, y defiendo C ++ ... Pero para aprender C ++, necesitas entender la arquitectura de la computadora.  Y con esto, el gran problema de ense√±ar a los estudiantes (al menos en la universidad donde ense√±√©).  Y para ense√±ar algoritmos y otras cosas, probablemente necesite algo que no se centre en la infraestructura, en el lenguaje mismo.  Aqu√≠ Eiffel intent√≥ hacer esto, pero tambi√©n hay mucha magia.  Por lo tanto, dir√≠a que ninguno de nuestros dos idiomas es adecuado. <br><br>  La programaci√≥n es diferente, y no es la "programaci√≥n" la que ense√±a, sino los algoritmos, las estructuras de datos, etc.  Es posible que tenga sentido elegir su propio instrumento en cada tema.  Comprender alg√∫n tipo de estructuras de datos de Lisp.  Y C ++, en consecuencia, debe administrarse despu√©s de que los estudiantes entiendan algo sobre arquitectura.  Y entonces ser√° posible entender por qu√© todo este dolor y sufrimiento.  Ni siquiera argumentar√© que las ventajas son sobre el dolor. <br><br>  <b>Anatoly:</b> S√≠, estoy completamente de acuerdo en que necesitas separar los objetos, no ponerlos en "programaci√≥n" y martillar todo en un idioma.  Pero si llega al punto en el que aprendi√≥ los conceptos b√°sicos, los fundamentos, los algoritmos y comienza a elegir alg√∫n tipo de lenguaje industrial, entonces, por supuesto, C # ser√° mucho mejor.  Porque no te obliga a aprender todo esto a nivel de arquitecturas, bytes de memoria y otras "puestas de sol a mano".  Ofrece un lenguaje inmediatamente comprensible, una sintaxis simple, y en este idioma desde el primer o segundo a√±o puede ganar dinero bastante tangible. <br><br>  <b>Dmitry:</b> Hay un argumento de que no darles a los estudiantes principiantes algunas cosas como punteros es una especie de sacrilegio.  Tendr√°n un gran agujero si una persona no comprende que, por ejemplo, un enlace es en realidad solo la direcci√≥n de una variable en la memoria.  ¬øQu√© opinas sobre esto? <br><br>  <b>Anatoly: hace</b> 20 a√±os, esto era cierto cuando las computadoras no ten√≠an suficiente memoria, ni suficientes discos y otras cosas.  Ahora mire estos javascripts, arrastran 500 megabytes de bibliotecas a cada "hola mundo".  ¬øCu√°nto llevan en la memoria?  ¬øCu√°l es su desempe√±o?  ¬øCu√°les son los enlaces all√≠?  S√≠, a nadie le importa.  Lo principal es rodar r√°pidamente y lanzar algo en producci√≥n.  No pretendo que esta sea una buena o correcta manera, sostengo que es necesario cambiar junto con las realidades.  Tal vez ahora no sea tan importante cu√°nto tarda tu enlace. <br><br>  <b>Sergey:</b> Probablemente dependiendo de d√≥nde.  Dmitry, por lo que yo entiendo, estaba interesado en el comercio algor√≠tmico: puedo imaginar v√≠vidamente c√≥mo saca las bibliotecas de JS para enviar una orden al intercambio. <br><br>  <b>Dmitry:</b> Bueno, s√≠, por supuesto, en la pr√°ctica nadie usa idiomas de este tipo all√≠.  Aunque en teor√≠a esto puede ser posible: no olvidemos que no se arroja dinero d√©bil a la infraestructura de JS.  Motores que hacen que la compilaci√≥n JS se convierta en cualquier cosa.  Muchos consideran este lenguaje como el lenguaje de primera clase para todo en general. <br><br>  Naturalmente, algo de comercio es ahora una disciplina remota de dicha disciplina, pero algo de comercio y matem√°ticas financieras en general es un √°rea espec√≠fica.  Simplemente predomina C ++.  Y predomina en parte debido a la inercia, simplemente por razones hist√≥ricas: al principio todos estaban en C ++, y esta √°rea es conservadora. <br><br>  <b>Sergey:</b> no estoy de acuerdo.  Ahora trabajo en fintech, y mis colegas que han estado aqu√≠ desde el comienzo del comercio algor√≠tmico hablan de grandes empresas que escribieron por primera vez en Java.  Al principio, Java se enfrent√≥ al comercio algor√≠tmico, pero cuando el mercado comenz√≥ a crecer y aparecieron los competidores con C ++, en alg√∫n momento simplemente no pudieron hacerlo, no lograron hacer todo de manera eficiente ... As√≠ que no todos en el comercio algor√≠tmico comenzaron con C ++.  Solo aquellos que no escribieron sobre √©l murieron.  Una selecci√≥n tan natural. <br><br>  <b>Dmitry:</b> En realidad, puedes tomarlo m√°s ancho.  Hay muchos ejemplos en los que incluso los grandes bancos mantienen sus algoritmos en un documento de Excel.  Luego usan Excel tambi√©n como servidor para calcular todo esto.  Hay frenos infernales, pero todo depende de si est√° haciendo operaciones de alta frecuencia (o generalmente algo de alta frecuencia).  Si usted es un creador de mercado, es natural que necesite un alto rendimiento, y all√≠ el negocio ni siquiera se limita a C ++, all√≠ vamos a los lenguajes de hardware y HDL. <br><br>  Pero nuestra discusi√≥n no es solo sobre el comercio algor√≠tmico, sino tambi√©n sobre cosas simples.  Aqu√≠ les doy un ejemplo.  En relaci√≥n con la construcci√≥n, necesitaba escribir varias aplicaciones peque√±as que calcularan cosas diferentes: por ejemplo, c√≥mo colocar ladrillos alrededor del contorno de una casa.  Y apenas puedo imaginar c√≥mo hacer tales cosas en C ++, porque todo lo relacionado con la interfaz de usuario es m√°s d√©bil all√≠.  Solo hay un marco, Qt, e incluso escribir sobre √©l es muy dif√≠cil.  Y si me siento para C #, para WinForms, entonces instant√°neamente hago la aplicaci√≥n. <br><br>  <b>Anatoly:</b> Bueno, la parte visual siempre ha sido una fortaleza de C #.  Microsoft invirti√≥ mucho en moldes, e incluso en moldes multiplataforma, y ‚Äã‚Äãen general en visualizaci√≥n.  Por lo tanto, si estamos hablando de aplicaciones de escritorio visual, entonces me parece que las ventajas generalmente est√°n muy, muy por detr√°s. <br><br>  <b>Sergey:</b> Bueno, depende, como siempre.  Realmente no me gusta la interfaz de usuario, pero en las ventajas tengo que hacerlo constantemente.  Parecer√≠a traer JS e interactuar con los profesionales.  Pero trabaj√© con incrustado, y ah√≠ es dif√≠cil.  La gente compr√≥ alg√∫n tipo de motor r√°pido y costoso, pero a√∫n no pod√≠a hacer frente a la representaci√≥n normal de la IU escrita en JS.  Y despu√©s de reescribir todo esto en Qt, result√≥ ser overclock.  Historia ordinaria <br><br><img src="https://habrastorage.org/webt/kc/9t/uf/kc9tufwhjjwnla-uga_j8abdwqg.jpeg"><br><br><h2>  Multiplataforma vs multiplataforma </h2><br>  <b>Sergey:</b> quer√≠a aclarar aqu√≠.  No s√© mucho acerca de C #, lo toqu√© yo mismo hace mucho tiempo, en las primeras versiones (en ese entonces estaba roto la compatibilidad con versiones anteriores).  Entonces la pregunta es: ¬øtodav√≠a est√° siendo desarrollado solo por Microsoft? <br><br>  <b>Anatoly:</b> No, ahora es multiplataforma, abierto y verificado bajo ISO (ECMA-334 e ISO / IEC 23270).  Por cierto, hasta donde yo s√©, C ++ todav√≠a no tiene una especificaci√≥n ISO abierta, solo paga.  Y C #, por el contrario, est√° completamente abierto.  Desarrollado por muchas compa√±√≠as (incluidas Google, Amazon y Samsung), tenemos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fundaci√≥n .NET</a> .  Ni siquiera conozco un lenguaje m√°s abierto ahora que C # y su plataforma .NET. <br><br>  <b>Sergey:</b> Bueno, Haskell. <br><br>  <b>Anatoly:</b> Por cierto, el autor de Haskell trabaja en Microsoft Research e hizo muchos esfuerzos para hacer que todo tipo de cosas geniales aparezcan en C #, por ejemplo, una comprobaci√≥n est√°tica, alg√∫n tipo de reflexi√≥n, con la que probablemente ni siquiera puedas so√±ar. <br><br>  <b>Sergey:</b> Pueden so√±ar, e incluso el trabajo contin√∫a en esta direcci√≥n.  Pero est√° claro que todo tiene su propio precio.  En C ++, simplemente se niegan a pagar este precio. <br><br>  <b>Anatoly:</b> ¬øCu√°l?  Se compilan durante dos horas, ¬øcu√°l m√°s podr√≠a ser el precio? <br><br>  <b>Sergey:</b> En C ++, el principio de abstracci√≥n de costo cero.  Bueno, es decir, una m√°quina virtual no es una abstracci√≥n de costo cero, ¬øverdad?  Tenemos que aguantar esto. <br><br>  <b>Dmitry:</b> Bueno, pero una m√°quina virtual puede, por ejemplo, ocultar c√≥digo para una arquitectura en particular.  Mientras que en C ++, si uso la instrucci√≥n AVX en una computadora sin AVX, mi proceso simplemente se cierra.  Dir√≠a que este argumento no es del todo correcto, porque te√≥ricamente, enfatizo, te√≥ricamente, JIT puede hacer lo que C ++ no est√° disponible.  A saber, optimizaci√≥n en el momento del lanzamiento. <br><br>  <b>Sergey:</b> Pero en C ++, durante la compilaci√≥n, puedes controlar completamente las instrucciones que necesitas.  En este caso, no lo controla con las manos, pero abandona el instrumento (compilador).  Mire, qu√© instrucciones hay en esta arquitectura, qu√© conjunto de instrucciones ... <br><br>  <b>Dmitry:</b> Esto es comprensible.  Pero puede formularlo de esta manera: dado que hay un mill√≥n de plataformas, nunca obtendremos ning√∫n tipo de ideal, porque no podemos lanzar un mill√≥n de versiones con diferentes indicadores de compilaci√≥n.  Derecho?  Generalmente lanzamos x86 y x64, pero no lo desglosamos en algunos subgrupos. <br><br>  <b>Sergey:</b> ¬øPor qu√© no podemos?  Siglo XXI.  Mantenga Docker con diferentes par√°metros, eso es todo. <br><br>  <b>Dmitry:</b> cuando tenemos un cliente final que descarga nuestra aplicaci√≥n, quiere descargar un binario espec√≠fico.  Y en este binario, lo mejor que podemos hacer es pegarnos en todas partes si.  Como "si cpuid es regular y el soporte avx es regular, entonces usamos el algoritmo versi√≥n 25".  Como resultado, necesitamos 25 versiones diferentes del mismo algoritmo, porque la aceleraci√≥n depende de las plataformas, depende de la plataforma. <br><br>  <b>Sergey:</b> Probablemente estoy de acuerdo.  Es solo que, para ser honesto, nunca he creado un producto no interno.  Estoy principalmente en empresas que utilizan su producto. <br><br>  <b>Dmitry:</b> Bueno, por supuesto, la mejor opci√≥n es cuando conoces de manera predecible la arquitectura.  En este caso, estrictamente hablando, nadie te obliga a usar las instrucciones x86.  Puede tomar una tarjeta espec√≠fica (por ejemplo, Nvidia Tesla) y hacer lo que quiera.  Este es mi enfoque tambi√©n, yo controlo mi arquitectura.  Pero cuando toma decisiones de mercado masivo para el usuario ... Si toma un ReSharper condicional, √©l no puede simplemente tomar y usar la aceleraci√≥n de GPU para cualquier √≠ndice arbitrario.  Porque la aceleraci√≥n de GPU no es algo port√°til. <br><br>  <b>Sergey:</b> En realidad, hay enfoques (ahora probablemente no necesites entrar en detalles), hay tipos interesantes (el autor del enfoque, al parecer, ahora tambi√©n se mud√≥ a Microsoft).  Aqu√≠, en nuestra conferencia el a√±o anterior, hubo un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> sobre c√≥mo escribir un programa de este tipo, que comprender√° en qu√© consiste (relativamente f√°cil, de nuevo, abstracciones de costo cero).  Para que pueda elegir sobre la marcha y, en todo caso, reconstruir correctamente el c√≥digo en un estilo CUDA ... <br><br>  <b>Dmitry:</b> En realidad, CUDA est√° tratando de resolver este problema, porque en CUDA hay una cierta capa intermedia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PTX</a> que se ocupa de esto.  Pero esto sigue siendo muy dif√≠cil, porque el hierro est√° cambiando radicalmente evolutivamente, y es muy dif√≠cil mantenerse al d√≠a.  Y si observamos el uso de la aceleraci√≥n de GPU, por ejemplo, en productos de Adobe, entonces utilizan una secci√≥n muy limitada de tecnolog√≠as disponibles.  Si su tarjeta es correcta, entonces s√≠, todo lo ser√°.  Pero si es un poco ex√≥tico, nada est√° garantizado a este respecto. <br><br>  <b>Anatoly:</b> En esta discusi√≥n, tocamos un tema bastante importante, un mito: C ++ fue declarado hace muchos a√±os como un lenguaje multiplataforma, pero en este momento multiplataforma est√° mucho m√°s en C #.  Uno y solo binario funciona en todas partes donde se admite .NET, y esto es casi en todas partes. <br><br>  <b>Sergey:</b> Bueno, esto tambi√©n es bastante infundado.  Como una persona que pas√≥ la mayor parte de mi vida en incrustaciones, rara vez vi que .NET fuera compatible con la cadena de herramientas del fabricante del hardware.  Las empresas que producen hierro toman el mismo G ++ o Clang o hacen que comience a generar c√≥digo para su plataforma. <br><br>  <b>Dmitry:</b> S√≠, pero el problema es que cada vez que hacen esto, pierden algo de C ++.  Por ejemplo, Nokia us√≥ una variaci√≥n de C ++, pero su C ++ ten√≠a giros extra√±os y API locos que enfurec√≠an a todos.  Es decir, no es solo C ++, sino C ++ para una u otra plataforma.  Y entonces comienzan los problemas.  Por ejemplo, tome el mismo CUDA.  Es como si simplemente dejara pasar a los profesionales por s√≠ mismo; no es un compilador en absoluto, sino solo un controlador.  Pero a pesar de esto, tiene dudas sobre el hecho de que todav√≠a usa alg√∫n tipo de marco para dividir archivos CUDA en partes de GPU y CPU.  Y a veces ella no tiene √©xito. <br><br>  <b>Sergey:</b> No quise decir eso un poco.  Es solo que cuando escucho ".NET se ejecuta en todas partes", la mayor√≠a de mi biograf√≠a de trabajo retrocede.  Cuando compra una pieza de hardware con un procesador personalizado, solo viene incluido con la entrega de G ++.  Y hay C ++ ordinario, que G ++ puede convertir de la cadena de herramientas en c√≥digo de m√°quina compatible con este procesador en particular. <br><br>  <b>Dmitry:</b> Pero de nuevo, esto debe ser reensamblado ... <br><br>  <b>Sergey: por</b> supuesto. <br><br>  <b>Dmitry:</b> Y la idea de que tomemos un c√≥digo plus existente y lo arrastremos a una pieza de hierro; esta idea tampoco funciona, porque de repente arrastraste tu x86 normal a alguna parte, donde tienes 8 gigabytes de memoria para todo sobre todo, y no es expandir: por ejemplo, no hay intercambio en disco, porque no hay disco y acceso a √©l.  Esto es si estamos hablando de portabilidad.  Depende de los objetivos, naturalmente. <br><br>  <b>Anatoly: los</b> profesionales trabajan en m√°s dispositivos y, por supuesto, incrustar es una de las partes m√°s fuertes.  Pero generalmente tiene que adaptar de alguna manera su c√≥digo a la plataforma.  Esto es malo  Puedo cubrir una gran cantidad de plataformas, arquitecturas, modelos con un solo c√≥digo.  En las ventajas, tuve que pensar en cada plataforma individual: d√≥nde comenzar√° all√≠ y en qu√© condiciones.  Y es muy malo, est√° muy frenando. <br><br><img src="https://habrastorage.org/webt/f1/wn/1z/f1wn1zxi80gplsj3bpidl9fpr1i.jpeg"><br><br><h2>  Estabilidad, compatibilidad, desarrollo del lenguaje. </h2><br>  <b>Dmitry:</b> Tambi√©n se mencionaron abstracciones de costo cero, pero el problema es que esto tiene un precio enorme.  Por ejemplo, en .NET existe un concepto de tipo enumerado y una interfaz IEnumerable.  Y para cada tipo, por ejemplo, una matriz, puede tomar y pasar por un iterador.  Pero en C ++ no existe tal idea.  Debido a la abstracci√≥n de costo cero, para moverse por la colecci√≥n, hay un par de begin () y end (), hay reglas para su trabajo y todo esto es mucho m√°s complicado (especialmente para aquellos que comienzan a programar).  Este es un problema directo: c√≥mo moverse por una matriz de la A a la Z. <br><br>  <b>Sergey:</b> Si entiendo correctamente de lo que est√°s hablando ... Si solo necesitas recorrer un contenedor de principio a fin, ahora solo escribes, como en Python. <br><br>  <b>Dmitry:</b> Todo esto es maravilloso.  Pero usted, por ejemplo, no usa polimorfismo para esto.  No puede decir que aqu√≠ tengo una funci√≥n que recibe un cierto valor, que se enumera a priori.  No puede decir que tengo un valor que implementa la interfaz, y esta interfaz tiene un iterador, por ejemplo. <br><br>  <b>Sergey: ¬ø</b> Estamos hablando de qu√© C ++?  Sobre C ++ en general, C ++ del futuro, C ++, que ahora se aceptan como est√°ndar. <br><br>  <b>Dmitry:</b> Bueno, si en los pros del futuro ser√° ... <br><br>  <b>Sergey:</b> En C ++ 20, esto ya est√° ah√≠.  Ya puedes decir, incluso puedes declararte.  Estas no son interfaces, pero, c√≥mo decirlo correctamente ... En general, puede declarar que su tipo debe cumplir tales condiciones.  Por ejemplo, tiene inicio y fin, que devuelven un iterador.  Y un iterador es un concepto tan preparado en la biblioteca est√°ndar.  √âl dice lo que es, describe.  Los iteradores tambi√©n son diferentes.  En general, lo intentamos, lo hacemos m√°s conveniente para las personas. <br><br>  <b>Dmitry:</b> Me parece que esto surgi√≥ del hecho de que la gente se dio cuenta de que es dif√≠cil vivir sin los conceptos de iterable de un objeto.  Porque no est√° claro c√≥mo escribir cosas generalizadas.  S√≠, la abstracci√≥n de costo cero significa que no tenemos el costo de caminar por la mesa virtual cuando buscamos ... En .NET solo hay un m√©todo espec√≠fico, por ejemplo.  Y nosotros, para encontrarlo, naturalmente, tenemos que gastar esfuerzos, lo que las ventajas rechazan.  Pero desde el punto de vista de la usabilidad, dir√≠a que el resultado final no es tan bueno. <br><br>  <b>Sergey:</b> Naturalmente, debe haber un equilibrio.  No puedes tener todo de una vez. <br><br>  <b>Anatoly:</b> Te hace preguntarte cu√°ntos a√±os han pasado.  Los lenguajes alternativos evolucionan, y en ellos aparecen cosas tan b√°sicas desde el principio.  Ahora se est√°n poniendo al d√≠a con algo m√°s sustancial e interesante.  Y las ventajas se sientan durante diez a√±os con la misma sintaxis incomprensible, abstracciones oscuras, muletas incomprensibles y subdesarrolladas.  Puedes poner esto como uno de los inconvenientes. <br><br>  <b>Sergey:</b> Bueno, vamos!  ¬øQu√© significa "pobremente desarrollado"? <br><br>  Usted mencion√≥ un comit√©: C ++ tambi√©n tiene un comit√© ISO que lo desarrolla.  Hay representantes all√≠, incluido Microsoft, que se ahog√≥ por el hecho de que "no puede hacer esto, porque tenemos mucho legado que debemos apoyar".  Solo C ++ es el lenguaje que ya se tiene.  Y, por supuesto, camina con mucho cuidado.  Una de las tareas principales (que Straustrup ya declar√≥ al crear) es la compatibilidad con C. Pero ahora C incluso ha evolucionado bastante, debe designar con qu√© C es compatible. <br><br>  Y en mi opini√≥n, ahora C ++ se est√° desarrollando a un ritmo tremendo.  Con respecto a los conceptos, etc., de hecho, todo crece, por supuesto, no a partir de la iterabilidad.  De hecho, el desarrollo sigue lo que Alexander Stepanov tambi√©n describi√≥: uno de los autores de lo que ahora llamamos "programaci√≥n generalizada", la persona que realmente arrastr√≥ plantillas, gen√©ricos, etc. a C ++.  Para ser honesto, no s√© cu√°nto se inspira el comit√© en estas ideas, pero me parece que definitivamente hay alguna intersecci√≥n con ellas. <br><br>  <b>Anatoly:</b> Parece que todas estas metaclases, iteradores son realmente inspiraci√≥n, lo que ya fue hace muchas d√©cadas.  Incluso si toma metaprogramaci√≥n, plantillas, macros, todas estas personas tienen una larga experiencia, se mueven y hay conceptos mucho m√°s simples, obvios y comprensibles.  En otros idiomas, todo esto se hace un mill√≥n de veces mejor y m√°s r√°pido, con seguridad de tipo, verificaci√≥n de tiempo de compilaci√≥n, etc. <br><br>  <b>Sergey:</b> Espera, ya est√°s hablando de algo por lo que no todos est√°n dispuestos a pagar.  No quiero que mi programa verifique algo en tiempo de compilaci√≥n sin mi conocimiento.  ¬øEntiendes? <br><br>  <b>Anatoly:</b> Creo que todo esto con banderas se puede configurar.  Establece el nivel de optimizaci√≥n, y lo comprueba o no.  Esto no es un problema <br><br>  <b>Sergey:</b> A menudo necesitas controlar todo con tus manos.  Sepa exactamente lo que est√° pasando.  Porque las herramientas ... bueno, eso. <br><br>  <b>Dmitry:</b> Ni siquiera se trata de herramientas.  Aqu√≠ el hecho de que lenguajes como D y Rust, digan, digan: bueno, s√≠, existe tal cosa que cuando accedes a un elemento de matriz, puedes verificarlo, pero no puedes verificarlo.  Y simplemente se lo dan al usuario, es decir, puede decir "pero apaguemos las verificaciones de la matriz", "pero enci√©ndalo".  Es decir, alg√∫n tipo de control a este respecto. <br><br>  <b>Sergey:</b> No est√° claro cuando tienes inseguro y seguro, como en Rust, no veo la diferencia con C, por ejemplo, en este caso. <br><br>  <b>Anatoly:</b> La diferencia es que puedes escribir de manera segura y puedes escribir r√°pido.  Y en C tienes que escribir peligrosamente.  Bueno, s√≠, quiz√°s r√°pido.  La estabilidad es a veces m√°s importante que la velocidad. <br><br>  <b>Dmitry:</b> En realidad, si comenzamos a cavar este tema con nuevos lenguajes, en C ++ hay cosas que generalmente son muy dif√≠ciles de transmitir a las personas.  Una pregunta simple: ¬øde qu√© tama√±o es int?  En la mayor√≠a de los idiomas, sabes la respuesta a esta pregunta.  Usted dice: int es de 32 bits.  Pero no sabes los pros.  Conoces el tama√±o de tu computadora en particular porque lo recuerdas, pero, estrictamente hablando, ni siquiera quieres usar los tipos b√°sicos porque no son deterministas.  Y esas cosas me enfurecen cuando hay un conjunto de enfoques heredados como el int ser√° diferente en diferentes plataformas.  Y ahora ya entendemos que esto no se puede hacer.  ¬øPor qu√© no ir m√°s all√° y resolver de alguna manera este problema? <br><br>  <b>Sergey:</b> Bueno, eso est√° decidido.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ETS</a> , los tipos necesarios con una longitud fija.  Ahora el representante de Rusia en el comit√© est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arrastrando un</a> int de longitud variable (bueno, de nuevo, con abstracci√≥n de costo cero). <br><br>  <b>Anatoly:</b> ¬øRecuerdo correctamente que incluso hay un tama√±o no determinista de un puntero a un m√©todo?  Es decir, bajo diferentes compiladores y diferentes plataformas, ¬ølos punteros son diferentes? <br><br>  <b>Sergey:</b> Naturalmente, esto es arquitectura.  Cuando est√° cerca del hardware, ¬øc√≥mo puede garantizar el tama√±o del puntero, si tiene 8 bits y luego 64 bits? <br><br>  <b>Anatoly:</b> ¬øY c√≥mo se puede hacer aritm√©tica en punteros despu√©s de eso?  Esto es una locura <br><br>  <b>Sergey: quiero</b> decir?  Pues con cuidado. <br><br>  <b>Anatoly:</b> Ya veo.  El enfoque es claro en todas partes, controlando cuidadosamente todo con asas. <br><br>  <b>Sergey:</b> Bueno, si.  Una vez m√°s, en los est√°ndares modernos de C ++, se desarrollan enfoques ... Si hablamos de la elecci√≥n, entonces, en las ventajas modernas, de hecho, existe la opci√≥n de usar el recolector de basura.  Es solo que GC est√° construido all√≠ en contadores de referencia. <br><br>  En general, en sus palabras, colegas, lo siento, siento que no ha actualizado su conocimiento sobre las ventajas modernas durante mucho tiempo. <br><br>  Ahora, personas como Straustrup, que son parte del pante√≥n de los dioses m√°s, vienen con muchas llamadas para descubrir c√≥mo ense√±ar C ++ moderno.  El problema es lo que la gente piensa en las categor√≠as C ++ de 2003, y ense√±a en las mismas categor√≠as.  Y en relaci√≥n con esto, hay nuevos proyectos y enfoques interesantes, hay cursos modernos, digamos que los chicos de Yandex han hecho un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso</a> maravilloso.  Y ahora en ventajas se considera de mala educaci√≥n, por ejemplo, usar puro nuevo y eliminar. <br><br>  <b>Dmitry:</b> En cuanto a su comentario sobre la actualizaci√≥n del conocimiento ... El matiz es que mi enfoque, por ejemplo, es utilizar el peque√±o delta de C ++, que est√° garantizado que funcione para m√≠ y con el que soy "amigo".  Usted ve, C ++ es extenso.  Hay metaprogramaci√≥n de plantillas, y todo estar√≠a bien, hay mucha magia, pero, desafortunadamente, esta magia es ilegible.  Este es un c√≥digo en el que un no autor no puede resolverlo sin ning√∫n conocimiento especial, en cierto sentido, una caja negra.  Y hay muchas cajas negras en los profesionales, √°reas de oscuridad que no pueden ser digeridas ... Me gustar√≠a, no s√©, su opci√≥n para que se calcule de manera predecible, bien y sin ning√∫n truco. <br><br>  El ejemplo m√°s simple es hablar de rangos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rango-v3</a> y todo este tema).  Por un lado, todo esto es genial: hay cosas que han estado en C # durante varios a√±os, lo que permite, por ejemplo, construir un calendario mediante cualquier transformaci√≥n de la colecci√≥n est√°ndar.  Por otro lado, la forma en que se implementa en C ++ es simplemente desagradable en comparaci√≥n con C #: es pesado, no legible. <br><br>  <b>Sergey:</b> Esto es saborizante.  A m√≠, por el contrario, me gusta.  Seg√∫n tengo entendido, est√°s en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> Nibler y su presentaci√≥n ... <br><br>  <b>Dmitry:</b> Ver√°s, cuando el operador "o" se usa para filtrar una colecci√≥n, inmediatamente tengo preguntas sobre esto.  Tanto C # como Java hicieron todo a trav√©s del punto, a trav√©s de los m√©todos habituales. <br><br>  <b>Sergey:</b> Y me parece que esto est√° inspirado en Bash.  Es decir, es solo una tuber√≠a. <br><br>  <b>Dmitry:</b> Bueno, s√≠, probablemente esto explica algo en este enfoque. <br><br>  <b>Sergey: ¬°</b> Explica mucho!  Hablemos de PowerShell, ya que estamos hablando de Bash.  ¬øQui√©n vio PowerShell? <br><br>  <b>Anatoly:</b> Escribo en PowerShell, un gran lenguaje.  Pero nuevamente, la tuber√≠a debe insertarse donde est√° en su lugar, donde toda la arquitectura est√° impregnada por ella.  No es donde necesita hacer una sola acci√≥n, y es aqu√≠ una sintaxis idiom√°ticamente mala. <br><br>  <b>Sergey:</b> En la tuber√≠a de rango, es muy ... <br><br>  <b>Dmitry:</b> En mi opini√≥n, en el rango se usan por la siguiente raz√≥n ... Dir√© esto: si en C ++ hubiera m√©todos de extensi√≥n o funciones de extensi√≥n, las usar√≠a, por supuesto.  Porque lo m√°s natural si necesita ordenar una colecci√≥n es escribir "collection. Filter ()".  Y no "colecci√≥n |  view :: filter () ". <br><br>  <b>Anatoly:</b> Tambi√©n tuve la impresi√≥n de que te dispararon en las piernas durante 20 a√±os, te golpearon en la cara, te golpearon la cabeza contra la pared y finalmente dijiste: "Bueno, ahora hemos hecho todo muy bien en el vig√©simo est√°ndar, ahora ense√±emos los profesionales tienen raz√≥n ".  ¬°S√≠, nadie quiere ense√±arles correctamente!  Es decir, es un dolor a largo plazo. <br><br>  <b>Sergey:</b> Por favor no ense√±es.  Cual es el problema  Escribir en C #: comerciar con √©l, escribir incrustado.  No me importa <br><br>  <b>Anatoly:</b> Bueno, hay nichos estrechos donde los profesionales siguen ah√≠. <br><br>  <b>Sergey:</b> Incrustado es un "nicho estrecho" ... En este momento, mirando alrededor de mi cocina, veo un mont√≥n de computadoras. <br><br>  <b>Dmitry:</b> Cada vez que vuelo en avi√≥n, pienso: "Maldita sea, espero que estas ventajas hayan escrito todo bien all√≠". <br><br>  <b>Sergey:</b> Bueno, por cierto, hay principalmente Ada, por lo que recuerdo. <br><br>  <b>Dmitry:</b> Ada domina all√≠, s√≠. <br><br>  <b>Anatoly:</b> Por cierto, recientemente me encontr√© con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un excelente art√≠culo</a> donde el autor en diferentes idiomas (alrededor de 10) escribi√≥ un controlador de bajo nivel: controlador de red para una tarjeta Intel de 10 gigabits.  De C a Swift, JS, Python y, naturalmente, C #.  Si miramos estos gr√°ficos, que obtuvo, entonces C # en grandes lotes (cuando los costos de lanzamiento est√°n nivelados) va a la par con C y Rust. <br><br><img src="https://habrastorage.org/webt/bk/bp/ur/bkbpuriesi98tzgy1eon4cek8vs.png"><br><br>  Es decir, si hablamos de rendimiento, puede ser un error pensar que C # es muy inferior en alguna parte.  Tambi√©n hay un informe funky de Federico Luis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Scratched Metal</a> , donde mostr√≥ c√≥mo optimiz√≥ el c√≥digo C # para los perfiladores de procesadores. <br><br>  <b>Sergey:</b> Bueno, comienza de nuevo.  La cuesti√≥n es que cuando comienzas a optimizar esa Java, ese C #, no queda claro por qu√© no escribir en pluses.  Porque necesitas un conocimiento espec√≠fico.  Y, como me parece, la ventaja de lenguajes como C # y Java est√° nivelada, no es un umbral de entrada muy alto.  Hasta donde yo entiendo, de lo que Dmitry estaba hablando: legibilidad de c√≥digo, aprender mucho, dif√≠cil de explicar algunos conceptos, etc. <br><br>  <b>Anatoly:</b> Trabajo el 99% de mi tiempo escribiendo en C # "normal" - seguro, estable y trabajando todo el tiempo.  Y el 1% de las veces quiero escribir alg√∫n tipo de c√≥digo r√°pido de bajo nivel.  Y este C # me permite tambi√©n.  Pero mi herramienta principal sigue siendo estable, legible, sin errores ... <br><br>  <b>Dmitry:</b> Tolya, d√©jame darte un ejemplo simple: vectorizaci√≥n.  Con la vectorizaci√≥n en .NET, todo es muy malo, a pesar del hecho de que System.Numerics.Vectors se est√° cortando lentamente.  ¬øY a qu√© conduce, por mi parte, por ejemplo?  Al hecho de que si est√°s hurgando en el mercado y comprando una biblioteca matem√°tica para .NET, est√° escrito en los pros (con un contenedor completo).  Debido a que en .NET pr√°cticamente no hay acceso a la aceleraci√≥n de hardware (AVX, etc.), ahora se encuentra en una etapa embrionaria. <br><br>  <b>Anatoly:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intrinsics se</a> lanzan en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.NET Core 3</a> donde puede acceder directamente a AVX.  Realmente est√°n all√≠ en su infancia, pero hay cosas b√°sicas, y el resto es bastante conmovedor. <br><br>  <b>Dmitry:</b> Entiendes, tenemos 2019 en el patio.  Como usuario de todo este bien matem√°tico acelerado, no esper√© esto.  Y como resultado, para m√≠, si quiero considerar r√°pidamente algo, C # ya no es un candidato.  Porque las bibliotecas C ++ ya existen.  Tal vez ya se ha perdido tiempo para esto. <br><br>  <b>Anatoly:</b> Me parece que C # se est√° moviendo en la direcci√≥n de las ventajas, est√° tratando de ganar su mercado.  Pero las ventajas ya no se mueven a ning√∫n lado. <br><br>  <b>Sergey:</b> ¬øDe d√≥nde viene esto?  ¬øQu√© significa "las ventajas no van a ninguna parte"? <br><br>  <b>Anatoly:</b> Cuando me dicen en 2019 que habr√° iteradores en el est√°ndar, habr√° alg√∫n progreso sobre las lambdas, me parece que ... <br><br>  <b>Sergey:</b> No s√© por qu√© est√°s hablando de iteradores y lambdas, no entiendo en qu√© direcci√≥n estaba la piedra ... <br><br>  <b>Anatoly:</b> No se trata de iteradores, lo puse mal, me refer√≠a a los contenedores enumerables que discutimos antes.  Y mientras tanto, tenemos coincidencia de patrones. <br><br>  <b>Sergey:</b> Todo depende de si es necesario o no.  Estamos discutiendo la coincidencia de patrones.  Pero hasta ahora no hay argumentos sobre si es necesario en los profesionales. <br><br>  <b>Dmitry:</b> escucho muchos comentarios similares de las ventajas, que dicen que "aunque ya existe una presencia obvia de este o aquel enfoque en otros idiomas, ya se ha resuelto, a la gente le encanta y desarrolla soluciones, todav√≠a no queremos esto en ventajas, porque no se trata de ventajas idiom√°ticas ".  Y me parece que Java cay√≥ en el mismo agujero.  Java dijo "no chicos, no tendremos delegados".  Y en Java todav√≠a no existe el concepto de delegados, pero en .NET todo funciona bien. <br><br>  <b>Sergey:</b> Mira, los profesionales son muy simples.  De nuevo, de vuelta al comit√©.  Hay un consejo: estas son personas que est√°n desarrollando compiladores.  Y para ellos, las palabras "abstracci√≥n de costo cero" son exactamente lo que deben guiarse.  Y la palabra "legado", por desgracia. <br><br>  <b>Dmitry:</b> Bueno, la abstracci√≥n de costo cero es un ensamblador.  Si queremos abstracci√≥n de costo cero en general, necesitamos escribir todo en ensamblador. <br><br>  <b>Sergey:</b> No hay abstracci√≥n. <br><br>  <b>Dmitry:</b> Assembler es una abstracci√≥n sobre c√≥digo binario.  Es solo la segunda generaci√≥n, no la tercera. <br><br>  <b>Sergey:</b> Entonces, sobre todo tipo de "cosas convenientes", resulta que no est√° claro c√≥mo hacer que funcionen r√°pidamente. <br><br>  <b>Dmitry:</b> D√©jalos trabajar m√°s despacio.  La idea con iteradores as√≠ncronos, corutinas, todo esto: en .NET con C #, la palabra clave de rendimiento ya no sabe cu√°ntas versiones funcionan muy bien.  S√≠, se est√°n construyendo enormes m√°quinas de estado detr√°s de escena, solo magia.  Pero async / await tambi√©n construye magia, y en iteradores.  Pero todos lo usan, y es realmente conveniente. <br><br>  <b>Sergey: Las</b> rutinas se suman a las ventajas, hola. <br><br>  <b>Dmitry:</b> Bueno, s√≠, se est√°n haciendo progresos.  Pero las corutinas aparecen ahora, no hace 10 a√±os. <br><br>  <b>Sergey: una</b> vez m√°s.  Las ventajas son m√°s antiguas y, en mi opini√≥n, la velocidad de desarrollo disminuye con la acumulaci√≥n de la base de c√≥digo.  Claramente, todo depende de si existe el deseo de mantener el soporte de Legacy.  Para los profesionales, esta es una posici√≥n de principios.  Es decir, el c√≥digo que escribi√≥ en los a√±os 80 ahora est√° compilado por un compilador moderno. <br><br>  <b>Dmitry:</b> S√≠, pero compila el c√≥digo que escribi√≥ en C # 1.0 con un compilador moderno. <br><br>  <b>Sergey:</b> Esto no es cierto.  Al comienzo de la discusi√≥n, dije que lleg√≥ una actualizaci√≥n en mis primeras versiones de .NET, y de repente todos los programas dejaron de funcionar. <br><br>  <b>Dmitry:</b> Tal vez las API que usaste simplemente cambiaron.  Aqu√≠ debe separar la biblioteca y el lenguaje de programaci√≥n. <br><br>  <b>Sergey:</b> No ten√≠a nada, solo C #.  Yo era joven, estos fueron los primeros a√±os. <br><br>  <b>Dmitry:</b> Recuerdo solo un cambio importante, en C # 4: un peque√±o cambio en el comportamiento de foreach.  Por supuesto, en las versiones 1.x todo podr√≠a ser m√°s turbulento, pero ahora definitivamente no estamos en la fase en la que alguien de repente rompe algo. <br><br>  <b>Anatoly:</b> Bueno, oficialmente Microsoft se adhiere a la posici√≥n que monitorea estrictamente la compatibilidad con versiones anteriores, prueba nuevas versiones en una gran cantidad de m√°quinas y bases de c√≥digo.  Quiz√°s tuviste un error o algo as√≠. <br><br>  <b>Dmitry:</b> en general, .NET tambi√©n monitorea la compatibilidad con versiones anteriores, pero la velocidad del progreso ha aumentado tanto C ++ como Java. <br><br>  <b>Sergey:</b> Me parece que jug√≥ un papel importante, que al principio todo esto fue impulsado por una empresa.  Debido a que C ++ estaba originalmente en el comit√©, y esto es pol√≠tica, todos est√°n tratando de impulsar su decisi√≥n, y esto es como una reuni√≥n del Senado en Star Wars. <br><br>  <b>Dmitry:</b> ¬øEntonces su argumento es que todos somos rehenes de los comit√©s que no son impulsados ‚Äã‚Äãpor la innovaci√≥n? <br><br>  <b>Sergey:</b> El problema es que no eliges una soluci√≥n que satisfaga a todos.  La herramienta est√° tan ampliamente distribuida que muchas empresas la utilizan.  Ustedes las mismas corutinas recordaron: ¬øpor qu√© las recibieron tarde?  Porque Microsoft, al parecer, no podr√≠a estar de acuerdo con Google.  Hubo dos implementaciones: no recuerdo qui√©n estaba detr√°s de stackful y qui√©n estaba detr√°s de stackless, pero no pod√≠a estar de acuerdo.  Debido a que ambas compa√±√≠as son grandes, tienen enormes bases de c√≥digo que ya contienen una soluci√≥n, y se niegan a reescribirla. <br><br>  <b>Dmitry:</b> Desde el punto de vista del lector, uno tendr√° la sensaci√≥n de que lo escupieron desde un alto campanario, porque hay intereses corporativos, est√°n involucrados en entrelazados, y todo esto no parece preocuparle: vaya, lacayos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"d√©jenlos comer pastel"</a> . <br><br>  <b>Sergey:</b> Todo lo contrario.  El comit√© est√° tratando de elegir para que una persona com√∫n no tenga que sufrir.  Y a menudo es dif√≠cil. <br><br>  <b>Dmitry:</b> Bueno, puedo decir por m√≠ mismo que no sufrir√© si el costo cero va directo a alg√∫n lado, pero habr√° alg√∫n tipo de oportunidad flexible para caminar a lo largo del √°rbol binario e iterar de diferentes maneras sin variables de tiempo.      yield,     -   - ‚Äî    ,   ,      ,  ,     - . <br><br> <b>:</b> , ,           ,        ,      - . <br><br> <b>:</b>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Boost</a> . <br><br> <b>:</b> ,  . Boost , ,   , ‚Ä¶  -        .    std::string,  ,    .    size(),  length(),      :  ,    -  ?    -  ,    ,     .   , .  ,  , ,       .      ,    ,        ,   -  . <br><br><img src="https://habrastorage.org/webt/nh/k7/cd/nhk7cdikdhqxbdfj52qibe_pybo.jpeg"><br><br><h2>  </h2><br> <b>:</b>            , , ,    .       ? <br><br> <b>:</b>      , ,      ¬´¬ª,    . <br><br> <b>:</b>  . <br><br> <b>:</b>    embedded-,      include,  ? <br><br> <b>:</b>       .   embedded  -. <br><br> ,     , -  ?   ,    ,     .     ? <br><br> <b>:</b>  .   150 .   -     ,   .  . <br><br> <b>:</b>      ,    ! <br><br> <b>:</b>   ,     Steam, , , 64 . ,  150   ? <br><br> <b>:</b> , , . <br><br> <b>:</b>       ,        -.         ?     ,  ,      ,   ‚Äî  ,    zero cost abstractions  .       -? <br><br> <b>:</b>       ,  ,       ,   , ? <br><br> <b>:</b>    ,     .      ,    ,    . <br><br> <b>:</b> ,      ,    ,   .     ‚Äî ,     .     ,    .     ,   ,  .     ,  .    -.      C. <br><br> <b>:</b>   .      ¬´¬ª.       : ,            .  ,    ,   ,     .      .  ,       . <br><br> <b>:</b> ,   .     . ,  .      proposal.    . <br><br> <b>:</b>   ,    proposal.      ,       ¬´ ¬ª: ,  STL  ,    . ,  -   ,      . <br><br> <b>:</b> STL        . STL  .  ,    ,   STL  ‚Äî  ,    ,      . <br><br> <b>:</b>  ,   ‚Äî   ,    ?   ,     greenfield.    brownfield development,   .   ‚Äî ,  .   ‚Äî  .   ? <br><br> <b>:</b>  ,  .   ,   ,    .   ,   .      ,   ,     . G++  , Clang  .   . <br><br> <b>:</b>  , ,      ,     .  ¬´    ,   A,  B¬ª.     ,      .NET,         .  ,  ,     ,         ,       ,       ? <br><br> <b>:</b>  ,  ,     . ,    C++ 2.0.  ++C++.      ,     C. <br><br> <b>:</b>  ,    .          ,   ,  . ,  , ,   ,  #include  #import  -    ‚Äî   .  ,           . ,   ,    ,           , . <br><br>     .    ,       .    , ,       ,      C#  C++,             . <br><br> <b>:</b>    ,      ,     10  .     ,  ,   ,     ,    ,       ,   .         ¬´ ¬ª,      .      ,        . <br><br> C# ,      C++.   ,     C#     .       ,   ,   .      ,  ,     , ,  JIT' ‚Äî  ,   ,         -   (    int).  ,     ,   ,     ,    . <br><br> <b>:</b> ,  ,   ,   C#       ‚Äî     .  ,    ,   C++  .  ,     .  ( ,   ) ‚Äî   cutting edge.    ,     UI-  C++,      ,   .   C# ‚Äî .  C++   ,   . <br><br>       ,   . ,     ,       ,    C++   ,  ,   , . ,     . <br><br>         ,  C#     Microsoft.   ,    .NET Foundation,      ,   ,   Microsoft.   ,             . <br><br><hr><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C++ Russia</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNext</a> .  :    ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469467/">https://habr.com/ru/post/469467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469457/index.html">Hacia d√≥nde conduce Extravaganza</a></li>
<li><a href="../469459/index.html">Conexi√≥n de dispositivos IoT en Smart City</a></li>
<li><a href="../469461/index.html">"A las estrellas": Antic√≥smico "Apocalipsis hoy"</a></li>
<li><a href="../469463/index.html">Tendencias y pron√≥sticos en el procesamiento del lenguaje natural</a></li>
<li><a href="../469465/index.html">Inicializaci√≥n en C ++ moderno</a></li>
<li><a href="../469471/index.html">"5 centavos" para hablar sobre Sorts</a></li>
<li><a href="../469475/index.html">El auge y la ca√≠da de Flash, el complemento molesto que dio forma a la web moderna</a></li>
<li><a href="../469477/index.html">Es hora de que Apple deje de comparar iPad con PC</a></li>
<li><a href="../469479/index.html">¬øDe d√≥nde viene la probabilidad cu√°ntica?</a></li>
<li><a href="../469491/index.html">Interacci√≥n con el servidor Asterisk desde una aplicaci√≥n Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>