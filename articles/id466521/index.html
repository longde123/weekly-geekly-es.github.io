<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏼 👈 👩🏾‍🚀 C for Metal - logam mulia untuk komputasi pada kartu grafis Intel 🦉 🔹 🎫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berapa inti prosesor Intel yang Anda miliki di komputer? Jika Anda menggunakan sistem berbasis Intel, maka dalam sebagian besar kasus, Anda perlu mena...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C for Metal - logam mulia untuk komputasi pada kartu grafis Intel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/466521/">  Berapa inti prosesor Intel yang Anda miliki di komputer?  Jika Anda menggunakan sistem berbasis Intel, maka dalam sebagian besar kasus, Anda perlu menambahkan satu ke jawaban Anda.  Hampir semua prosesor Intel - dari Atom hingga Xeon E3, tentu saja, tanpa kehilangan Core, sudah bertahun-tahun memasukkan inti grafis terintegrasi Intel Graphics, yang pada dasarnya adalah prosesor penuh, dan karenanya, tidak hanya mampu menampilkan gambar di layar dan mempercepat video, tetapi juga melakukan perhitungan tujuan umum "biasa".  Bagaimana ini bisa digunakan secara efektif?  Lihat di bawah luka. <br><br><img src="https://habrastorage.org/webt/od/zy/qg/odzyqgwdoyvgvhlbsvulnty_doo.jpeg"><br><a name="habracut"></a><br>  Pertama, kami akan menjelaskan secara singkat mengapa Anda harus mengandalkan Intel GPU.  Tentu saja, kinerja CPU dalam sistem hampir selalu secara signifikan melebihi GPU, untuk itu juga merupakan Central Processor. <br><br>  Tetapi menarik untuk dicatat bahwa kinerja GPU terintegrasi Intel selama dekade terakhir telah tumbuh dalam persentase jauh lebih banyak daripada CPU, dan tren ini akan terus berlanjut dengan munculnya kartu grafis Intel diskrit baru.  Selain itu, GPU, berdasarkan arsitekturnya (banyak perangkat eksekusi vektor), jauh lebih cocok untuk melakukan jenis tugas tertentu - pemrosesan gambar, yaitu, pada kenyataannya, untuk melakukan semua jenis operasi pada array data.  GPU melakukan ini dengan paralelisasi internal penuh, menghabiskan lebih sedikit energi daripada CPU, dan dalam beberapa kasus bahkan melampauinya dalam kecepatan absolut.  Akhirnya, GPU dan CPU dapat bekerja secara paralel, masing-masing pada tugasnya sendiri, memberikan kinerja maksimum dan / atau konsumsi daya minimum dari keseluruhan sistem. <br><br>  - Ok, Intel.  Kami memutuskan untuk menggunakan Intel GPU untuk perhitungan tujuan umum, bagaimana cara melakukannya? <br>  - Cara paling sederhana yang tidak memerlukan pengetahuan khusus dalam grafik (Direct3D dan OpenGL shaders) adalah OpenCL. <br><br>  Kernel OpenCL adalah platform independen dan akan secara otomatis dijalankan pada semua perangkat komputasi yang tersedia dalam sistem - CPU, GPU, FPGA, dll.  Tetapi biaya untuk keserbagunaan tersebut jauh dari kinerja maksimum yang mungkin pada setiap jenis perangkat, dan terutama pada GPU Intel terintegrasi.  Di sini kita dapat memberikan contoh: ketika mengeksekusi kode pada GPU Intel apa pun yang mentransposasikan matriks 16x16 byte, keuntungan kinerja pemrograman langsung GPU Intel akan 8 kali lebih tinggi daripada dengan versi OpenCL! <br><br>  Selain itu, beberapa fungsi yang diperlukan untuk mengimplementasikan algoritma umum (misalnya, "filter lebar" yang menggunakan data dari sekelompok besar piksel dalam satu transformasi tunggal), OpenCL tidak mendukung. <br><br>  Oleh karena itu, jika Anda memerlukan kecepatan maksimum pada GPU dan \ atau sesuatu yang lebih rumit daripada bekerja secara independen dengan setiap elemen array dan tetangga terdekatnya, maka Intel C for Metal (ICM), alat untuk mengembangkan aplikasi yang berjalan pada Intel Graphics, akan membantu Anda . <br><br><h2>  <font color="#0071c5">ICM - selamat datang di bengkel!</font> </h2><br>  Dalam hal kinerja dan fungsionalitas, ICM dapat dianggap "assembler untuk kartu grafis Intel", dan dalam hal sirkuit dan kegunaan - "analog OpenCL untuk kartu grafis Intel." <br><br>  Selama bertahun-tahun, ICM telah digunakan secara internal oleh Intel dalam pengembangan produk pemrosesan media pada GPU Intel.  Tetapi pada tahun 2018, ICM dirilis ke publik, dan bahkan dengan open source! <br><br>  Intel C for Metal mendapatkan namanya saat ini beberapa bulan yang lalu, sebelum itu disebut Intel C for Media (akronim ICM yang sama atau hanya CM atau bahkan Cm), dan bahkan sebelumnya - Media Development Framework (MDF).  Jadi, jika suatu tempat atas nama komponen, dalam dokumentasi atau dalam komentar open source, nama lama bertemu - jangan khawatir, ini adalah nilai historis. <br><br>  Jadi, kode aplikasi ICM, seperti di OpenCL, berisi dua bagian: yang "administratif", dieksekusi pada prosesor, dan kernel, dieksekusi pada GPU.  Tidak mengherankan, bagian pertama disebut host, dan yang kedua adalah kernel. <br><br>  Kernel adalah fungsi memproses blok piksel yang diberikan (atau hanya data), ditulis dalam Intel C untuk bahasa Metal dan dikompilasi ke dalam set instruksi GPU Intel (ISA) menggunakan kompiler ICM. <br><br>  Tuan rumah adalah semacam "manajer tim kernel", yang mengelola proses transfer data antara CPU dan GPU dan melakukan "pekerjaan manajerial" lainnya melalui pustaka runtime ICM Runtime dan driver media Intel GPU. <br>  Alur kerja ICM terperinci terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/a1/q4/ola1q4zotlteitoqxvmttsuulu0.png"></div><br><ul><li>  Kode host ICM dikompilasi oleh kompiler x86 C / C ++ apa pun beserta seluruh aplikasi; </li><li>  Kode kernel ICM dikompilasi oleh kompiler ICM menjadi file biner dengan beberapa set instruksi umum (Common ISA); </li><li>  Pada saat runtime, rangkaian umum instruksi JIT ini diterjemahkan ke GPU Intel tertentu; </li><li>  Host ICM memanggil pustaka runtime ICM untuk berkomunikasi dengan GPU dan sistem operasi. </li></ul><br>  Beberapa poin yang lebih penting dan berguna: <br><br><ul><li>  Permukaan yang digunakan dalam ICM untuk mewakili / menyimpan data dapat dibagikan dengan DirectX 11 dan 9 (DXVA di Linux). </li><li>  GPU dapat mengambil dan menulis data dari memori video dan memori sistem yang dibagikan dengan CPU.  ICM mencakup fungsi-fungsi khusus untuk kedua kasus transfer data di kedua arah.  Pada saat yang sama, memori sistem tepat dibagi, dan penyalinan yang sebenarnya di dalamnya tidak diperlukan - untuk ini, yang disebut salinan nol disediakan di ICM. </li></ul><br><h2>  <font color="#0071c5">ICM - di lubang gunung berapi!</font> </h2><br>  Sudah dari nama "C for Iron" itu sendiri, berarti perangkat bahasa sesuai dengan perangkat grafis internal Intel.  Artinya, memperhitungkan fakta bahwa kode akan dieksekusi pada beberapa lusin unit eksekusi (Unit Eksekusi) dari kartu grafis, yang masing-masing adalah prosesor vektor penuh yang mampu mengeksekusi beberapa utas secara bersamaan. <br><br>  Bahasa ICM itu sendiri adalah C ++ dengan beberapa batasan dan ekstensi.  Dibandingkan dengan C ++, ICM tidak memiliki ... pointer, alokasi memori, dan variabel statis.  Di bawah larangan juga fungsi rekursif.  Tetapi ada pemrograman model vektor eksplisit (SIMD): tipe data vektor - vektor, matriks, dan permukaan;  operasi vektor pada tipe data ini, kondisi vektor jika / yang lain, dilakukan secara independen untuk setiap elemen vektor;  serta fungsi bawaan untuk mengakses fungsi tetap perangkat keras GPU Intel. <br><br>  Pekerjaan dengan vektor, matriks dan permukaan dalam tugas nyata difasilitasi oleh objek "subset" - dari objek dasar yang sesuai, Anda hanya dapat memilih blok "referensi" yang menarik bagi Anda atau, sebagai kasus khusus, elemen individual dengan topeng. <br><br>  Sebagai contoh, mari kita lihat kode ICM yang mengimplementasikan filter linier - mengganti nilai <br>  Warna RGB setiap piksel berdasarkan nilai rata-rata dan 8 tetangga dalam gambar: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/0q/xk/of/0qxkofxlflf0p_pxmtzgvcd7aze.png"></td><td>  <b>I (x, y) = [I (x-1, y-1) + I (x-1, y) + I (x-1, y + 1) + I (x, y-1) +</b> <b><br></b>  <b>+ I (x, y) + I (x, y + 1) + I (x + 1, y-1) + I (x + 1, y) + I (x + 1, y + 1)] / 9</b> <br></td></tr></tbody></table></div><br>  Jika warna (data) dalam matriks ditempatkan sebagai <b>R8G8B8</b> , maka perhitungan dengan memecah gambar input menjadi blok 6x8 piksel (elemen data 6x24 byte) adalah sebagai berikut: <br><br><pre><code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">GENX_MAIN_ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceIndex inBuf, SurfaceIndex outBuf, uint h_pos, uint v_pos)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    8x32 matrix&lt;uchar, 8, 32&gt; in; //   6x24 matrix&lt;uchar, 6, 24&gt; out; matrix&lt;float, 6, 24&gt; m; //    read(inBuf h_pos*24, v_pos*6, in); //    -  m = in.select&lt;6,1,24,1&gt;(1,3); m += in.select&lt;6,1,24,1&gt;(0,0); m += in.select&lt;6,1,24,1&gt;(0,3); m += in.select&lt;6,1,24,1&gt;(0,6); m += in.select&lt;6,1,24,1&gt;(1,0); m += in.select&lt;6,1,24,1&gt;(1,6); m += in.select&lt;6,1,24,1&gt;(2,0); m += in.select&lt;6,1,24,1&gt;(2,3); m += in.select&lt;6,1,24,1&gt;(2,6); //  -   9   * 0.111f; out = m * 0.111f; //   write(outBuf, h_pos*24, v_pos*6, out); }</span></span></code> </pre> <br><ul><li>  Ukuran matriks diatur dalam bentuk &lt;tipe data, tinggi, lebar&gt;; </li><li>  <i>operator pilih &lt;v_size, v_stride, h_size, h_stride&gt; (i, j)</i> mengembalikan submatrix dimulai dengan elemen <i>(i, j)</i> , <i>v_size</i> menunjukkan jumlah baris yang dipilih, <i>v_stride</i> - jarak antara baris yang dipilih <i>h_size</i> - jumlah kolom yang dipilih, <i>h_stride</i> - jarak di antara mereka . </li></ul><br>  Harap dicatat bahwa ukuran matriks input 8x32 dipilih karena meskipun blok 8x30 secara algoritmik cukup untuk menghitung nilai semua piksel dalam blok 6x24, blok data dibaca dalam ICM bukan byte, tetapi oleh elemen kata 32-bit. <br><br>  Kode di atas sebenarnya adalah ICM kernel lengkap.  Seperti yang disebutkan, itu akan dikompilasi oleh kompiler ICM dalam dua tahap (prakompilasi dan terjemahan JIT berikutnya).  Kompiler ICM dibangun berdasarkan LLVM dan, jika diinginkan, dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipelajari dalam sumber dan dibuat sendiri oleh Anda</a> . <br><br>  Tapi apa yang dilakukan host ICM?  Meminta fungsi pustaka runtime ICM Runtime yang: <br><br><ul><li>  Buat, inisialisasi, dan hapus setelah menggunakan perangkat GPU (CmDevice), serta permukaan yang berisi data pengguna yang digunakan dalam kernel (CmSurface); </li><li>  Bekerja dengan kernel - unduh dari file <i>.isa yang</i> telah dikompilasi, siapkan argumen mereka, yang mengindikasikan bagian dari data yang akan digunakan oleh masing-masing kernel; </li><li>  Membuat dan mengelola antrian eksekusi kernel; </li><li>  Mereka mengontrol operasi utas yang mengeksekusi setiap kernel pada GPU; </li><li>  Kelola acara (CmEvent) - objek sinkronisasi GPU dan CPU; </li><li>  Transfer data antara GPU dan CPU, atau lebih tepatnya, antara memori sistem dan video; </li><li>  Laporkan kesalahan, ukur waktu operasi kernel. </li></ul><br>  Kode host paling sederhana terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  CmDevice cm_result_check(::CreateCmDevice(p_cm_device, version)); //  hello_world_genx.isa std::string isa_code = isa::loadFile("hello_world_genx.isa"); //    isa  CmProgram CmProgram *p_program = nullptr; cm_result_check(p_cm_device-&gt;LoadProgram(const_cast&lt;char* &gt;(isa_code.data()),isa_code.size(), p_program)); //  hello_world . CmKernel *p_kernel = nullptr; cm_result_check(p_cm_device-&gt;CreateKernel(p_program, "hello_world", p_kernel)); //       CmKernel CmThreadSpace *p_thread_space = nullptr; cm_result_check(p_cm_device-&gt;CreateThreadSpace(thread_width, thread_height, p_thread_space)); //   . cm_result_check(p_kernel-&gt;SetKernelArg(0, sizeof(thread_width), &amp;thread_width)); //  CmTask –      //         //     . CmTask *p_task = nullptr; cm_result_check(p_cm_device-&gt;CreateTask(p_task)); cm_result_check(p_task-&gt;AddKernel(p_kernel)); //   CmQueue *p_queue = nullptr; cm_result_check(p_cm_device-&gt;CreateQueue(p_queue)); //    GPU (    ). CmEvent *p_event = nullptr; cm_result_check(p_queue-&gt;Enqueue(p_task, p_event, p_thread_space)); //   . cm_result_check(p_event-&gt;WaitForTaskFinished());</span></span></code> </pre> <br>  Seperti yang Anda lihat, tidak ada yang rumit dalam membuat dan menggunakan kernel dan host.  Semuanya sederhana! <br><br>  Satu-satunya kesulitan untuk memperingatkan untuk kembali ke dunia nyata: saat ini dalam versi ICM yang tersedia untuk umum, satu-satunya cara untuk men-debug kernel adalah pesan printf.  Cara menggunakannya dengan benar dapat dilihat pada contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hello, World</a> . <br><br><h2>  <font color="#0071c5">ICM - bukan logam berat!</font> </h2><br>  Sekarang mari kita lihat cara kerjanya dalam praktik.  Kit Pengembang ICM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia untuk Windows dan Linux</a> , dan untuk kedua sistem operasi berisi Kompiler ICM, dokumentasi, dan kasus penggunaan tutorial.  Deskripsi rinci tentang contoh-contoh pelatihan ini <a href="">diunduh secara terpisah</a> . <br><br>  Untuk Linux, paket ini juga menyertakan driver media mode pengguna untuk VAAPI dengan pustaka runtime ICM Runtime terintegrasi.  Untuk Windows, Driver Grafik Intel biasa untuk Windows akan bekerja dengan ICM.  Pustaka runtime ICM Runtime termasuk dalam set dll driver ini.  Paket ICM hanya menyertakan file tautan .lib untuknya.  Jika driver hilang dari sistem Anda karena suatu alasan, itu diunduh dari situs web Intel, dan operasi ICM yang benar dalam driver dijamin, mulai dari versi 15.60 - 2017). <br><br>  Kode sumber komponen dapat ditemukan di sini: <br><br><ul><li>  Intel Media Driver untuk VAAPI dan Intel C untuk Media Runtime: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/intel/media-driver</a> </li><li>  Intel C untuk Media Compiler dan contoh-contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/intel/cm-compiler</a> </li><li>  Intel Graphics Compiler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/intel/intel-graphics-compiler</a> </li></ul><br>  Konten lebih lanjut dari bagian ini berlaku secara eksklusif untuk Windows, tetapi prinsip-prinsip umum bekerja dengan ICM juga berlaku untuk Linux. <br><br>  Untuk pekerjaan "reguler" dengan paket ICM, Anda akan membutuhkan Visual Studio mulai tahun 2015 dan Cmake mulai dari versi 3.2.  Pada saat yang sama, file konfigurasi dan skrip dari contoh pelatihan dirancang untuk VS 2015, untuk menggunakan versi file VS yang lebih baru, Anda harus mempelajari dan mengedit sendiri path ke komponen VS. <br><br>  Jadi, mengenal ICM untuk Windows: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unduh arsipnya</a> ; </li><li>  Buka kemasannya; </li><li>  Kita mulai (lebih disukai pada baris perintah VS) skrip konfigurasi lingkungan setupenv.bat dengan tiga parameter - generasi Intel GPU (sesuai dengan prosesor tempat GPU dibangun, ia dapat dibiarkan secara default: gen9), platform kompilasi: x86 \ x64 dan versi DirectX untuk berbagi dengan ICM: dx9 / dx11. </li></ul><br>  Setelah itu, Anda cukup membuat semua contoh pelatihan - di folder contoh, skrip <i>build_all.bat</i> akan melakukan <i>ini</i> atau menghasilkan proyek untuk Microsoft Visual Studio - ini akan <i>membuat</i> skrip <i>create_vs.bat</i> dengan nama contoh spesifik sebagai parameter. <br><br>  Seperti yang Anda lihat, aplikasi ICM akan menjadi file .exe dengan bagian host dan file .isa dengan bagian GPU yang sudah dikompilasi sebelumnya. <br><br>  Berbagai contoh disertakan dalam paket ICM - dari Hello, World yang paling sederhana, yang menunjukkan prinsip-prinsip dasar operasi ICM, hingga yang agak rumit - implementasi algoritma untuk menemukan "aliran maksimum - potongan minimum" dari grafik (masalah min-cut max-flow) yang digunakan dalam segmentasi gambar dan jahitan . <br><br>  Semua studi kasus ICM didokumentasikan dengan baik tepat dalam kode dan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi terpisah yang</a> telah disebutkan.  Disarankan untuk mempelajari ICM secara tepat - mempelajari dan menjalankan contoh secara berurutan, dan kemudian - memodifikasinya agar sesuai dengan kebutuhan Anda. <br><br>  Untuk pemahaman umum tentang semua fitur ICM yang ada, sangat disarankan agar Anda mempelajari "spesifikasi" - deskripsi ICM <i>cmlangspec.html</i> di <i>folder</i> <i>\ document \ compiler \ html \ cmlangspec</i> . <br><br>  Secara khusus, ini menggambarkan API dari fungsi ICM yang diimplementasikan dalam perangkat keras - akses ke apa yang disebut sebagai sampler tekstur (Sampler) - suatu mekanisme untuk memfilter gambar dengan format yang berbeda, serta untuk mengevaluasi pergerakan (Estimasi Gerakan) antara bingkai video dan beberapa kemampuan analitik video. <br><br><h2>  <font color="#0071c5">ICM - serang selagi panas!</font> </h2><br>  Berbicara tentang kinerja aplikasi ICM, perlu dicatat bahwa studi kasus termasuk mengukur waktu pekerjaan mereka, sehingga dengan menjalankannya pada sistem target dan membandingkannya dengan tugas Anda, Anda dapat mengevaluasi kelayakan menggunakan ICM untuk mereka. <br><br>  Dan pertimbangan umum mengenai kinerja ICM cukup sederhana: <br><br><ul><li>  Saat menurunkan perhitungan pada GPU, ingat overhead mentransfer CPU &lt;-&gt; data GPU dan menyinkronkan perangkat ini.  Oleh karena itu, contoh seperti Hello, World bukanlah kandidat yang baik untuk implementasi ICM.  Tetapi algoritma dari visi komputer, AI, dan pemrosesan array data yang tidak sepele, terutama dengan perubahan urutan data ini dalam proses atau pada output, adalah apa yang dibutuhkan ICM. </li><li>  Selain itu, ketika merancang kode ICM, perlu untuk mempertimbangkan perangkat GPU internal, yaitu, disarankan untuk membuat jumlah yang cukup (&gt; 1000) utas GPU dan memuat semuanya dengan pekerjaan.  Dalam hal ini, merupakan ide bagus untuk membagi gambar untuk diproses menjadi blok kecil.  Tetapi cara khusus mempartisi, serta pilihan algoritma pemrosesan tertentu untuk mencapai kinerja maksimum, bukanlah tugas yang sepele.  Namun, ini berlaku untuk cara apa pun bekerja dengan GPU (dan CPU) apa pun. </li></ul><br>  Apakah Anda memiliki kode OpenCL, tetapi kinerjanya tidak menyenangkan Anda?  Atau kode CUDA, tetapi Anda ingin bekerja pada platform yang jauh lebih banyak?  Maka ada baiknya melihat ICM. <br><br>  ICM adalah produk yang hidup dan berkembang.  Anda dapat berpartisipasi dalam penggunaan dan pengembangannya - repositori terkait di github sedang menunggu komitmen Anda.  Semua informasi yang diperlukan untuk kedua proses ada di artikel ini dan readme file di github.  Dan jika ada sesuatu yang hilang, itu akan muncul setelah pertanyaan Anda di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466521/">https://habr.com/ru/post/id466521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466505/index.html">YIMP - Control Panel untuk Yii 2 di Bootstrap 4</a></li>
<li><a href="../id466509/index.html">Pandangan ke dalam: proses perangkat untuk bekerja dan adaptasi di Google</a></li>
<li><a href="../id466515/index.html">Wawancara Apa yang seharusnya seorang insinyur harapkan dari bekerja di startup Eropa, bagaimana wawancara dilakukan dan apakah sulit untuk beradaptasi</a></li>
<li><a href="../id466517/index.html">Pelatihan lokalisasi Universitas Washington</a></li>
<li><a href="../id466519/index.html">Analisis terperinci AWS Lambda</a></li>
<li><a href="../id466525/index.html">Apa itu tata letak iPhone PSD dan bagaimana menggunakannya?</a></li>
<li><a href="../id466527/index.html">Menguji fungsionalitas pengguna situs web dengan objek halaman Capybara</a></li>
<li><a href="../id466529/index.html">Jenis Kompilasi di JVM: Mengekspos Sesi Sihir Hitam</a></li>
<li><a href="../id466533/index.html">Pastilda: hasil</a></li>
<li><a href="../id466535/index.html">Memikirkan kembali deepClone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>