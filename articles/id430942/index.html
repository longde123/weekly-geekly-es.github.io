<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¸ âš¡ï¸ ğŸ« Julia. Script dan argumen baris perintah parsing ğŸ•°ï¸ ğŸ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus berurusan dengan bahasa pemrograman Julia. Karena hanya perlu memiliki mode operasi batch untuk bahasa yang difokuskan pada analisis dan pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia. Script dan argumen baris perintah parsing</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430942/"><p><img src="https://habrastorage.org/webt/pi/ts/0a/pits0aw00iivzdctpqqr82w5hww.png"><br>  Kami terus berurusan dengan bahasa pemrograman Julia.  Karena hanya perlu memiliki mode operasi batch untuk bahasa yang difokuskan pada analisis dan pemrosesan data, pertimbangkan fitur-fitur dari implementasi skrip dalam bahasa Julia dan meneruskan argumen dari baris perintah kepada mereka.  Topik ini mungkin tampak basi bagi seseorang, tetapi, mengingat kebaruan dari bahasa tersebut, saya berharap bahwa gambaran kecil tentang metode untuk mengurai argumen baris perintah dan perpustakaan untuk ini, disajikan dalam Julia, masih akan berguna. </p><a name="habracut"></a><br><p>  Untuk mulai dengan, beberapa kata tentang bagaimana naskah dibuat.  Setiap skrip dimulai dengan garis dalam format khusus yang menunjukkan juru bahasa.  Garis dimulai dengan urutan yang dikenal sebagai Shebang.  Untuk Julia, baris ini adalah: </p><br><pre><code class="plaintext hljs">#!/usr/bin/env julia</code> </pre> <br><p>  Tentu saja, Anda tidak dapat melakukan ini, tetapi kemudian Anda harus menjalankan skrip dengan perintah: </p><br><pre> <code class="plaintext hljs">julia .jl</code> </pre> <br><p>  Selain itu, skrip apa pun harus diakhiri dengan karakter baris baru.  Ini adalah persyaratan standar POSIX, yang mengikuti definisi string sebagai urutan karakter yang diakhiri oleh karakter baris baru. </p><br><p>  Agar skrip dijalankan secara langsung, skrip harus memiliki atribut yang <code>executable</code> .  Anda dapat menambahkan atribut seperti itu di terminal dengan perintah: </p><br><pre> <code class="plaintext hljs">chmod +x .jl</code> </pre> <br><p>  Aturan-aturan ini berlaku untuk semua sistem operasi modern, kecuali, mungkin, MS Windows. </p><br><h2 id="massiv-args">  Arg Array </h2><br><p>  Mari kita beralih ke opsi pertama untuk melewatkan parameter.  Argumen baris perintah tersedia dalam skrip Julia melalui konstanta array Base.ARGS.  Mari kita siapkan skrip yang paling sederhana: </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia @show typeof(ARGS) @show ARGS</code> </pre> <br><p>  Script ini hanya mencetak ke konsol jenis dan isi array ARGS. </p><br><p>  Sangat sering, nama file dilewatkan sebagai argumen baris perintah.  Dan di sini ada kekhasan pemrosesan templat file yang diteruskan sebagai argumen.  Misalnya, jalankan skrip kami menggunakan perintah <code>./args.jl *.jl</code> dan dapatkan: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl *.jl typeof(ARGS) = Array{String,1} ARGS = ["argparse.jl", "args.jl", "docopt.jl"]</code> </pre><br><p>  Dan sekarang mari kita ubah parameter baris perintah sedikit, mengelilingi topeng dengan tanda kutip: <br>  <code>./args.jl "*.jl"</code> .  Sebagai hasilnya, kita mendapatkan: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl "*.jl" typeof(ARGS) = Array{String,1} ARGS = ["*.jl"]</code> </pre> <br><p>  Kami melihat perbedaan yang jelas.  Dalam kasus pertama, kami mendapat array dengan nama-nama semua file yang ada di direktori yang sama.  Dalam kasus kedua, ini hanya topeng yang sama yang dilewatkan sebagai argumen ke baris perintah.  Alasan untuk perilaku skrip yang berbeda ini adalah karena bash interpreter (dan juga yang dekat dengannya), dari mana skrip dijalankan, mengenali templat nama file.  Lebih banyak dapat ditemukan di mesin pencari untuk "Pencocokan Pola Bash" atau "Kartu Liar Bash".  Dan secara keseluruhan disebut Glob. </p><br><p>  Di antara polanya, dimungkinkan untuk menutupi beberapa karakter - *, menutupi satu karakter -? .. Cari berdasarkan rentang [...], dan, bahkan, kemampuan untuk menentukan kombinasi kompleks: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl {args,doc}* typeof(ARGS) = Array{String,1} ARGS = ["args.jl", "docopt.jl"]</code> </pre> <br><p>  Lihat Ringkasan Alat Baris Perintah GNU / Linux untuk informasi lebih lanjut. </p><br><p>  Jika, karena alasan tertentu, kami tidak ingin menggunakan mekanisme gumpalan yang disediakan oleh bash, maka Anda dapat menemukan file berdasarkan mask dari skrip menggunakan paket Globs.jl. <br>  Kode berikut mengonversi semua yang ditemukan dalam string argumen menjadi satu array nama file.  Yaitu, terlepas dari apakah pengguna menentukan topeng dalam tanda kutip, tanpa tanda kutip, atau hanya mendaftar nama file yang ada atau tidak ada, hanya nama file aktual atau direktori akan tetap dalam array daftar <code>filelist</code> dihasilkan. </p><br><pre> <code class="plaintext hljs">using Glob filelist = unique(collect(Iterators.flatten(map(arg -&gt; glob(arg), ARGS))))</code> </pre> <br><p>  Contoh-contoh sederhana ini, pada kenyataannya, adalah demonstrasi penggunaan array ARGS, di mana programmer mengimplementasikan semua logika untuk parsing argumen.  Pendekatan ini sering digunakan ketika serangkaian argumen sangat sederhana.  Misalnya, daftar nama file.  Atau satu atau dua opsi yang dapat ditangani oleh operasi string sederhana.  Akses ke elemen ARGS sama dengan elemen array lainnya.  Hanya ingat bahwa indeks elemen pertama array di Julia adalah 1. </p><br><h2 id="paket-argparsejl">  Paket ArgParse.jl </h2><br><p>  Ini adalah alat yang fleksibel untuk menggambarkan atribut dan opsi dari baris perintah tanpa perlu menerapkan parsing logic. <br>  Mari kita gunakan contoh yang sedikit dimodifikasi dari dokumentasi paket - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://carlobaldassi.github.io/ArgParse.jl/stable/</a> : </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia using ArgParse function parse_commandline() s = ArgParseSettings() @add_arg_table s begin "--opt1" help = "an option with an argument" "--opt2", "-o" help = "another option with an argument" arg_type = Int default = 0 "--flag1" help = "an option without argument, ie a flag" action = :store_true "arg1" help = "a positional argument" required = true end return parse_args(s) end function main() @show parsed_args = parse_commandline() println("Parsed args:") for (arg,val) in parsed_args print(" $arg =&gt; ") show(val) println() end end main()</code> </pre> <br><p>  Jika kami menjalankan skrip ini tanpa argumen, kami mendapatkan output informasi referensi pada komposisi mereka: </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl required argument arg1 was not provided usage: argparse.jl [--opt1 OPT1] [-o OPT2] [--flag1] arg1</code> </pre> <br><p>  Selain itu, dalam tanda kurung siku kita melihat argumen opsional.  Sementara argumen yang ditandai sebagai <code>arg1</code> (yaitu, apa yang kita gantikan) adalah wajib. </p><br><p>  Jalankan lagi, tetapi tentukan atribut yang diperlukan <code>arg1</code> . </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl test parsed_args = parse_commandline() = Dict{String,Any}("flag1"=&gt;false,"arg1"=&gt;"test","opt1"=&gt;nothing,"opt2"=&gt;0) Parsed args: flag1 =&gt; false arg1 =&gt; "test" opt1 =&gt; nothing opt2 =&gt; 0</code> </pre> <br><p>  Kita dapat melihat bahwa <code>parsed_args</code> adalah array asosiatif, di mana kuncinya adalah nama atribut menurut deklarasi yang dibuat dalam fungsi <code>parse_commandline</code> , dan nilainya adalah apa yang ditetapkan secara default atau diteruskan sebagai nilai argumen baris perintah.  Selain itu, nilai-nilai dari tipe yang secara eksplisit ditentukan selama deklarasi. </p><br><p>  Argumen <code>@add_arg_table</code> menggunakan makro <code>@add_arg_table</code> .  Dimungkinkan untuk mendeklarasikan opsi: </p><br><pre> <code class="plaintext hljs"> "--opt2", "-o" help = "another option with an argument" arg_type = Int default = 0</code> </pre> <br><p>  Atau argumen </p><br><pre> <code class="plaintext hljs"> "arg1" help = "a positional argument" required = true</code> </pre> <br><p>  Selain itu, opsi dapat ditentukan menunjukkan bentuk penuh dan pendek (pada saat yang sama <code>--opt2</code> dan <code>-o</code> ).  Atau, hanya dalam satu bentuk.  <code>arg_type</code> ditentukan di bidang <code>arg_type</code> .  Nilai default dapat diatur menggunakan <code>default = ...</code>  Alternatif untuk nilai default adalah dengan memerlukan argumen - <code>required = true</code> . <br>  Dimungkinkan untuk mendeklarasikan tindakan otomatis, misalnya, menetapkan <code>true</code> atau <code>false</code> tergantung pada ada atau tidak adanya argumen.  Ini dilakukan dengan menggunakan <code>action = :store_true</code> </p><br><pre> <code class="plaintext hljs"> "--flag1" help = "an option without argument, ie a flag" action = :store_true</code> </pre> <br><p>  Bidang <code>help</code> berisi teks yang akan ditampilkan pada prompt di baris perintah. <br>  Jika saat startup kita menentukan semua atribut, maka kita mendapatkan: </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl --opt1 "2+2" --opt2 "4" somearg --flag parsed_args = parse_commandline() = Dict{String,Any}("flag1"=&gt;true,"arg1"=&gt;"somearg","opt1"=&gt;"2+2","opt2"=&gt;4) Parsed args: flag1 =&gt; true arg1 =&gt; "somearg" opt1 =&gt; "2+2" opt2 =&gt; 4</code> </pre> <br><p>  Untuk debugging dari Atom / Juno IDE, di baris pertama skrip Anda dapat menambahkan kode berikut, agak kotor, tetapi berfungsi untuk menginisialisasi array ARGS. </p><br><pre> <code class="plaintext hljs">if (Base.source_path() != Base.basename(@__FILE__)) vcat(Base.ARGS, ["--opt1", "2+2", "--opt2", "4", "somearg", "--flag"] ) end</code> </pre> <br><p>  Makro <code>@__FILE__</code> adalah nama file tempat makro digunakan.  Dan nama ini untuk REPL berbeda dari nama file program saat ini yang diperoleh melalui <code>Base.source_path()</code> .  Tidak mungkin menginisialisasi <code>Base.ARGS</code> array <code>Base.ARGS</code> nilai yang berbeda, tetapi pada saat yang sama, Anda dapat menambahkan baris baru, karena array itu sendiri bukan konstanta.  Array adalah kolom untuk Julia, jadi kami menggunakan <code>vcat</code> (vertical concatenate). </p><br><p>  Namun, dalam pengaturan editor Juno Anda dapat mengatur argumen untuk menjalankan skrip.  Tetapi mereka harus diubah setiap waktu untuk setiap skrip yang didebug secara terpisah. </p><br><h2 id="paket-docoptjl">  Paket DocOpt.jl </h2><br><p>  Opsi ini merupakan implementasi dari pendekatan bahasa docopt markup - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://docopt.org/</a> .  Gagasan utama dari bahasa ini adalah deskripsi deklaratif dari opsi dan argumen dalam bentuk, yang juga bisa menjadi deskripsi internal skrip.  Bahasa template khusus digunakan. </p><br><p>  Kami akan menggunakan contoh dari dokumentasi untuk paket ini <a href="">https://github.com/docopt/DocOpt.jl</a> </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia doc = """Naval Fate. Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;] naval_fate.jl ship shoot &lt;x&gt; &lt;y&gt; naval_fate.jl mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting] naval_fate.jl -h | --help naval_fate.jl --version Options: -h --help Show this screen. --version Show version. --speed=&lt;kn&gt; Speed in knots [default: 10]. --moored Moored (anchored) mine. --drifting Drifting mine. """ using DocOpt # import docopt function args = docopt(doc, version=v"2.0.0") @show args</code> </pre> <br><p>  Notasi <code>doc = ...</code> adalah penciptaan string <code>doc</code> Julia, yang berisi seluruh deklarasi untuk docopt.  Hasil menjalankan pada baris perintah tanpa argumen adalah: </p><br><pre> <code class="plaintext hljs">&gt;./docopt.jl Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;] naval_fate.jl ship shoot &lt;x&gt; &lt;y&gt; naval_fate.jl mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting] naval_fate.jl -h | --help naval_fate.jl --version</code> </pre><br><p>  Jika kita menggunakan petunjuk dan mencoba untuk "membuat kapal baru", kita mendapatkan cetakan dari array <code>args</code> asosiatif, yang dihasilkan oleh hasil penguraian baris perintah </p><br><pre> <code class="plaintext hljs">&gt;./docopt.jl ship new Bystriy args = Dict{String,Any}( "remove"=&gt;false, "--help"=&gt;false, "&lt;name&gt;"=&gt;["Bystriy"], "--drifting"=&gt;false, "mine"=&gt;false, "move"=&gt;false, "--version"=&gt;false, "--moored"=&gt;false, "&lt;x&gt;"=&gt;nothing, "ship"=&gt;true, "new"=&gt;true, "shoot"=&gt;false, "set"=&gt;false, "&lt;y&gt;"=&gt;nothing, "--speed"=&gt;"10")</code> </pre> <br><p>  Fungsi <code>docopt</code> dinyatakan sebagai: </p><br><pre> <code class="plaintext hljs">docopt(doc::AbstractString, argv=ARGS; help=true, version=nothing, options_first=false, exit_on_error=true)</code> </pre> <br><p>  Argumen <code>help</code> , <code>version</code> , <code>oprtions_first</code> , <code>exit_on_error</code> menentukan perilaku parser perintah argumen secara default.  Misalnya, jika terjadi kesalahan - untuk menyelesaikan eksekusi, pada permintaan versi, kembalikan nilai <code>version=â€¦</code> diganti di sini, atas permintaan <code>-h</code> - bantuan masalah.  <code>options_first</code> digunakan untuk menunjukkan bahwa opsi harus sebelum argumen posisi. </p><br><p>  Sekarang, mari kita lihat lebih dekat bahasa deklaratif ini dan reaksi parser argumen terhadap nilai yang dimasukkan. </p><br><p>  Deklarasi dimulai dengan teks arbitrer, yang, selain teks untuk baris perintah, dapat menjadi bagian dari dokumentasi skrip itu sendiri.  Kata layanan "Penggunaan:" menyatakan pola penggunaan untuk skrip ini. </p><br><pre> <code class="plaintext hljs">Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;]</code> </pre> <br><p>  Argumen dideklarasikan dalam bentuk <code>&lt;name&gt;</code> , <code>&lt;x&gt;</code> , <code>&lt;y&gt;</code> .  Perhatikan bahwa dalam array asosiatif <code>args</code> yang diperoleh sebelumnya, argumen ini bertindak sebagai kunci.  Kami menggunakan formulir peluncuran <code>./docopt.jl ship new Bystriy</code> , jadi kami mendapatkan nilai yang diinisialisasi secara eksplisit berikut: </p><br><pre> <code class="plaintext hljs"> "&lt;name&gt;"=&gt;["Bystriy"], "ship"=&gt;true, "new"=&gt;true,</code> </pre> <br><p>  Menurut bahasa docopt, elemen opsional ditentukan dalam tanda kurung.  Misalnya <code>[--speed=&lt;kn&gt;]</code> .  Elemen wajib ditentukan dalam tanda kurung, tetapi dengan kondisi tertentu.  Sebagai contoh <code>(set|remove)</code> menetapkan persyaratan untuk salah satunya.  Jika elemen ditentukan tanpa tanda kurung, misalnya <code>naval_fate.jl --version</code> , ia mengatakan bahwa dalam opsi run khusus ini, <code>--version</code> adalah opsi yang diperlukan. </p><br><p>  Bagian selanjutnya adalah bagian deskripsi opsi.  Dimulai dengan kata "Opsi:" <br>  Opsi dideklarasikan masing-masing pada baris terpisah.  Padding di sebelah kiri awal garis penting.  Untuk setiap opsi, Anda dapat menentukan formulir lengkap dan pendek.  Serta deskripsi opsi yang ditampilkan di tooltip.  Dalam hal ini, opsi <code>-h | --help, --version</code>  <code>-h | --help, --version</code> otomatis dikenali.  Tanggapan mereka diberikan oleh argumen untuk fungsi <code>docopt</code> .  Yang menarik untuk dipertimbangkan adalah deklarasi: </p><br><pre> <code class="plaintext hljs"> --speed=&lt;kn&gt; Speed in knots [default: 10].</code> </pre> <br><p>  Di sini form <code>...=&lt;kn&gt;</code> mendefinisikan keberadaan beberapa nilai, dan <code>[default: 10]</code> mendefinisikan nilai default.  Kami kembali ke nilai yang diperoleh dalam <code>args</code> : </p><br><pre> <code class="plaintext hljs">"--speed"=&gt;"10"</code> </pre> <br><p>  Perbedaan mendasar, misalnya, dari paket ArgParse, adalah bahwa nilainya tidak diketik.  Artinya, nilai <code>default: 10</code> ditetapkan sebagai string "10". <br>  Adapun argumen lain, yang disajikan dalam <code>args</code> sebagai hasil dari parsing argumen, Anda harus memperhatikan nilainya: </p><br><pre> <code class="plaintext hljs"> "remove"=&gt;false, "--help"=&gt;false, "--drifting"=&gt;false, "mine"=&gt;false, "move"=&gt;false, "--version"=&gt;false, "--moored"=&gt;false, "&lt;x&gt;"=&gt;nothing, "shoot"=&gt;false, "set"=&gt;false, "&lt;y&gt;"=&gt;nothing,</code> </pre> <br><p>  Artinya, benar-benar semua elemen template yang ditentukan dalam deklarasi docopt untuk semua kasus penggunaan disajikan sebagai hasil analisis dengan nama asli.  Semua argumen opsional yang tidak ada pada baris perintah salah di sini.  Argumen <code>&lt;x&gt;</code> , <code>&lt;y&gt;</code> juga hilang dari baris peluncuran dan tidak memiliki nilai apa pun.  Argumen lain yang cocok dengan pola parsing menerima nilai sebenarnya: </p><br><pre> <code class="plaintext hljs"> "ship"=&gt;true, "new"=&gt;true,</code> </pre> <br><p>  Dan kami telah menerima nilai spesifik untuk elemen templat berikut: </p><br><pre> <code class="plaintext hljs"> "&lt;name&gt;"=&gt;["Bystriy"], "--speed"=&gt;"10"</code> </pre> <br><p>  Nilai pertama ditetapkan secara eksplisit pada baris perintah sebagai substitusi argumen, dan yang kedua adalah opsi dengan nilai default. <br></p><p>  Perhatikan juga bahwa nama skrip saat ini dapat dihitung secara otomatis. <br>  Misalnya, kita bisa masuk: </p><br><pre> <code class="plaintext hljs">doc = """Naval Fate. Usage: $(Base.basename(@__FILE__)) ship new &lt;name&gt;â€¦ """</code> </pre> <br><p>  Rekomendasi tambahan untuk menempatkan parser argumen baris perintah adalah menempatkannya di awal file.  Fitur yang tidak menyenangkan dari Julia saat ini adalah koneksi modul yang agak panjang.  Misalnya <code>using Plots; using DataFrames</code>  <code>using Plots; using DataFrames</code> dapat mengirim skrip untuk menunggu beberapa detik.  Ini bukan masalah untuk skrip sisi-server, beban-tunggal, tetapi akan mengganggu pengguna yang hanya ingin melihat petunjuk untuk argumen baris perintah.  Itulah sebabnya, pertama Anda perlu mengeluarkan bantuan dan memeriksa argumen baris perintah, dan baru kemudian, lanjutkan untuk mengunduh perpustakaan yang diperlukan untuk pekerjaan tersebut. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Artikel itu tidak berpura-pura mempertimbangkan semua metode penguraian argumen dalam Julia.  Namun, opsi yang dipertimbangkan, pada kenyataannya, mencakup 3 opsi yang mungkin.  Analisis manual array <code>ARGS</code> .  Argumen yang dideklarasikan secara ketat tetapi secara otomatis di ArgParse.  Dan bentuk docopt sepenuhnya deklaratif, meskipun tidak ketat.  Pilihan use case tergantung sepenuhnya pada kompleksitas argumen yang diuraikan.  Opsi menggunakan docopt tampaknya yang paling mudah digunakan, meskipun membutuhkan konversi jenis eksplisit untuk nilai-nilai argumen yang diterima.  Namun, jika skrip tidak menerima apa pun selain nama file, maka sangat mungkin untuk mengambil keuntungan dari mengeluarkan bantuan di atasnya menggunakan fungsi <code>println("Run me with file name")</code> biasa <code>println("Run me with file name")</code> , dan parsing nama file langsung dari <code>ARGS</code> seperti yang ditunjukkan di bagian pertama. </p><br><h2 id="ssylki">  Referensi </h2><br><ul><li>  <a href="">https://github.com/vtjnash/Glob.jl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://argparsejl.readthedocs.io/en/latest/argparse.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/carlobaldassi/ArgParse.jl/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://docopt.org/</a> </li><li>  <a href="">https://github.com/docopt/DocOpt.jl</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430942/">https://habr.com/ru/post/id430942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430932/index.html">Peretas mencuri lebih dari 21 juta rubel dari bank Rusia</a></li>
<li><a href="../id430934/index.html">Asterisk dialplan extension mask generator</a></li>
<li><a href="../id430936/index.html">DEFCON 21. Konferensi DNS dapat berbahaya bagi kesehatan Anda. Bagian 2</a></li>
<li><a href="../id430938/index.html">Cara mendapatkan pesanan pertama dalam desain saat tidak ada portofolio dan pengalaman</a></li>
<li><a href="../id430940/index.html">SDK untuk Anda, SDK untuk saya, SDK untuk semua orang! Cara membuat SDK dan mengapa diperlukan</a></li>
<li><a href="../id430944/index.html">NASA telah memutuskan para peserta untuk kompetisi mini-moon rover</a></li>
<li><a href="../id430948/index.html">Kementerian Komunikasi mengusulkan untuk memperketat kendali atas data pribadi</a></li>
<li><a href="../id430950/index.html">Membuat Bangunan Modern</a></li>
<li><a href="../id430952/index.html">Mobil listrik dan mobil hibrida harus membuat suara tambahan: mengapa ini diperlukan</a></li>
<li><a href="../id430954/index.html">Qt Everywhere: WebAssembly dan WebGL Streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>