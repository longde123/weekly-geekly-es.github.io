<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèø üöê üé∫ Merkle Tree: rouill√© et rapide üç® üíñ ‚öúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! R√©cemment d√©couvert la langue Rust. Il a partag√© ses premi√®res impressions dans un article pr√©c√©dent . Maintenant, j'ai d√©cid√© de creu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merkle Tree: rouill√© et rapide</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455260/"><p><img src="https://habrastorage.org/webt/02/we/l8/02wel89vk_uuxibqbvaiimofkkk.png" alt="image"></p><br><p>  Bonjour √† tous!  R√©cemment d√©couvert la langue Rust.  Il a partag√© ses premi√®res impressions dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> .  Maintenant, j'ai d√©cid√© de creuser un peu plus, pour cela, vous avez besoin de quelque chose de plus s√©rieux que la liste.  Mon choix s'est port√© sur l'arbre Merkle.  Dans cet article, je veux: </p><br><ul><li>  parler de cette structure de donn√©es </li><li>  regardez ce que Rust a d√©j√† </li><li>  proposez votre impl√©mentation </li><li>  comparer les performances </li></ul><a name="habracut"></a><br><h1 id="derevo-merkla">  Arbre Merkle </h1><br><p> Il s'agit d'une structure de donn√©es relativement simple, et il y a d√©j√† beaucoup d'informations √† ce sujet sur Internet, mais je pense que mon article sera incomplet sans une description de l'arbre. </p><br><h2 id="v-chyom-problema">  Quel est le probl√®me </h2><br><p>  L'arbre Merkle a √©t√© invent√© en 1979, mais a gagn√© en popularit√© gr√¢ce √† la blockchain.  La cha√Æne de blocs dans le r√©seau est tr√®s grande (pour le bitcoin, elle est sup√©rieure √† 200 Go), et tous les n≈ìuds ne peuvent pas le pomper.  Par exemple, des t√©l√©phones ou des caisses enregistreuses.  N√©anmoins, ils doivent conna√Ætre le fait d'inclure telle ou telle transaction dans le bloc.  Pour cela, le protocole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SPV - Simplified Payment Verification a</a> √©t√© invent√©. </p><br><h2 id="kak-ustroeno-derevo">  Comment fonctionne un arbre </h2><br><p>  Il s'agit d'un arbre binaire dont les feuilles sont des hachages d'objets.  Pour construire le niveau suivant, les hachages des feuilles voisines sont pris par paires, concat√©n√©s et le hachage du r√©sultat de la concat√©nation est calcul√©, ce qui est illustr√© dans l'image dans l'en-t√™te.  Ainsi, la racine de l'arbre est un hachage de toutes les feuilles.  Si vous supprimez ou ajoutez un √©l√©ment, la racine changera. </p><br><h2 id="kak-rabotaet-derevo">  Comment fonctionne un arbre? </h2><br><p>  Ayant un arbre Merkle, vous pouvez construire des preuves de l'inclusion d'une transaction dans un bloc comme chemin d'un hachage de transaction √† la racine.  Par exemple, nous nous int√©ressons √† la transaction Tx2, pour cela la preuve sera (Hash3, Hash01).  Ce m√©canisme est √©galement utilis√© dans SPV.  Le client t√©l√©charge uniquement l'en-t√™te de bloc avec son hachage.  Ayant une transaction d'int√©r√™t, il demande une preuve √† un n≈ìud contenant toute la cha√Æne.  Ensuite, il fait un contr√¥le, pour Tx2 ce sera: </p><br><pre><code class="plaintext hljs">hash(Hash01, hash(Hash2, Hash3)) = Root Hash</code> </pre> <br><p>  Le r√©sultat est compar√© √† la racine de l'en-t√™te de bloc.  Cette approche rend impossible la fausse preuve, car dans ce cas, le r√©sultat du test ne converge pas avec le contenu de l'en-t√™te. </p><br><h1 id="kakie-uzhe-est-realizacii">  Quelles impl√©mentations existent d√©j√† </h1><br><p>  La rouille est une langue jeune, mais de nombreuses r√©alisations de l'arbre Merkle y sont d√©j√† √©crites.  A en juger par Github, actuellement 56, c'est plus qu'en C et C ++ combin√©s.  Bien que Go les fasse tenir debout avec 80 impl√©mentations. </p><br><h2 id="spinresearchmerklershttpsgithubcomspinresearchmerklers">  <a href="">SpinResearch / merkle.rs</a> </h2><br><p>  Pour ma comparaison, j'ai choisi cette impl√©mentation par le nombre d'√©toiles dans le r√©f√©rentiel. </p><br><p>  Cet arbre est construit de la mani√®re la plus √©vidente, c'est-√†-dire qu'il s'agit d'un graphe d'objets.  Comme je l'ai d√©j√† not√©, cette approche n'est pas compl√®tement compatible avec la rouille.  Par exemple, il n'est pas possible d'√©tablir une communication bidirectionnelle entre les enfants et les parents. </p><br><p>  La construction des preuves passe par une recherche approfondie.  Si une feuille avec le hachage droit est trouv√©e, le chemin d'acc√®s sera le r√©sultat. </p><br><h2 id="chto-mozhno-uluchshit">  Ce qui peut √™tre am√©lior√© </h2><br><p>  Ce n'√©tait pas int√©ressant pour moi de faire une impl√©mentation simple (n + 1), j'ai donc pens√© √† l'optimisation.  Le code de mon <em>arbre vectoriel-merkle</em> est sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> . </p><br><h3 id="hranenie-dannyh">  Stockage de donn√©es </h3><br><p>  La premi√®re chose qui me vient √† l'esprit est de d√©placer l'arbre vers un tableau.  Cette solution sera bien meilleure en termes de localisation des donn√©es: plus de hits de cache et une meilleure pr√©charge.  Marcher autour d'objets dispers√©s dans la m√©moire prend plus de temps.  Un fait pratique est que tous les hachages ont la m√™me longueur, car  calcul√© par un algorithme.  L'arbre Merkle dans le tableau ressemblera √† ceci: <br><img src="https://habrastorage.org/webt/7_/in/4_/7_in4_ijawhhqj4f9pldunhl2mu.png" alt="image"></p><br><h3 id="dokazatelstvo">  Preuve </h3><br><p>  Lorsque vous initialisez l'arborescence, vous pouvez cr√©er un HashMap avec tous les index de feuille.  Ainsi, lorsqu'il n'y a pas de feuille, il n'est pas n√©cessaire de faire le tour de l'arbre entier, et s'il y en a, vous pouvez imm√©diatement y aller et vous √©lever √† la racine, en construisant une preuve.  Dans mon impl√©mentation, j'ai rendu HashMap facultatif. </p><br><h3 id="konkatenaciya-i-heshirovanie">  Concat√©nation et hachage </h3><br><p>  Il semblerait qu'ici peut √™tre am√©lior√©?  Apr√®s tout, tout est clair - prenez deux hachages, collez-les et calculez un nouveau hachage.  Mais le fait est que cette fonction est non commutative, c'est-√†-dire  hachage (H0, H1) ‚â† hachage (H1, H0).  Pour cette raison, lors de la construction de la preuve, vous devez vous rappeler de quel c√¥t√© se trouve le n≈ìud voisin.  Cela rend l'algorithme plus difficile √† impl√©menter et ajoute la n√©cessit√© de stocker des donn√©es redondantes.  Tout est tr√®s facile √† r√©parer, il suffit de trier les deux n≈ìuds avant de hacher.  Par exemple, j'ai cit√© Tx2, en tenant compte de la commutativit√©, le ch√®que ressemblera √† ceci: </p><br><pre> <code class="plaintext hljs">hash(hash(Hash2, Hash3), Hash01) = Root Hash</code> </pre> <br><p>  Lorsque vous n'avez pas √† vous soucier de la commande, l'algorithme de v√©rification ressemble √† une simple convolution d'un tableau: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { proof[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .fold( get_pair_hash(proof[<span class="hljs-number"><span class="hljs-number">0</span></span>], proof[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo), |a, b| get_pair_hash(a.as_ref(), b, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo) ).as_ref() == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_root() }</code> </pre> <br><p>  L'√©l√©ment z√©ro est le hachage de l'objet souhait√©, le premier est son voisin. </p><br><h1 id="pognali">  C'est parti! </h1><br><p>  L'histoire serait incompl√®te sans une comparaison des performances, ce qui m'a pris plusieurs fois plus de temps que la mise en ≈ìuvre de l'arbre lui-m√™me.  √Ä ces fins, j'ai utilis√© le cadre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crit√®res</a> .  Les sources des tests eux-m√™mes sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Tous les tests ont lieu via l'interface <em>TreeWrapper</em> , qui a √©t√© impl√©ment√©e pour les deux sujets: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeWrapper</span></span></span></span>&lt;V&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); }</code> </pre> <br><p>  Les deux arbres fonctionnent avec la m√™me cryptographie en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>anneau</em></a> .  Ici, je ne vais pas comparer diff√©rentes biblioth√®ques.  J'ai pris le plus commun. </p><br><p>  En tant qu'objets de hachage, des cha√Ænes g√©n√©r√©es de mani√®re al√©atoire sont utilis√©es.  Les arbres sont compar√©s sur des tableaux de diff√©rentes longueurs: (500, 1000, 1500, 2000, 2500 3000).  2500 - 3000 est le nombre approximatif de transactions dans le bloc bitcoin pour le moment. </p><br><p>  Sur tous les graphiques, l'axe X indique le nombre d'√©l√©ments du tableau (ou le nombre de transactions dans le bloc) et l'axe Y repr√©sente le temps moyen pour terminer l'op√©ration en microsecondes.  C'est-√†-dire, plus c'est pire. </p><br><h2 id="sozdanie-dereva">  Fabrication d'arbres </h2><br><p>  Le stockage de toutes les donn√©es d'arborescence dans un tableau d√©passe largement le graphique de performances des objets.  Pour un tableau √† 500 √©l√©ments, 1,5 fois et pour 3000 √©l√©ments d√©j√† 3,6 fois.  La nature non lin√©aire de la d√©pendance de la complexit√© au volume des donn√©es d'entr√©e dans l'impl√©mentation standard est clairement visible. </p><br><p>  De plus, en comparaison, j'ai ajout√© deux variantes de l'arbre vectoriel: avec et sans <em>HashMap</em> .  Remplir une structure de donn√©es suppl√©mentaire ajoute environ 20%, mais cela vous permet de rechercher des objets beaucoup plus rapidement lors de la cr√©ation de preuves. <br><img src="https://habrastorage.org/webt/xk/nf/kj/xknfkjl5aqy8oqagfzaj05p1qo4.png" alt="image"></p><br><h2 id="postroenie-dokazatelstva">  Construire des preuves </h2><br><p>  Ici, vous pouvez voir l'inefficacit√© √©vidente de la recherche en profondeur.  Avec une augmentation des intrants, cela ne fait qu'empirer.  Il est important de comprendre que les objets que vous recherchez sont des feuilles, donc il ne peut y avoir de complexit√© <em>log (n)</em> .  Si les donn√©es sont pr√©-hach√©es, le temps de fonctionnement est pratiquement ind√©pendant du nombre d'√©l√©ments.  Sans hachage, la complexit√© cro√Æt lin√©airement et consiste en une recherche par force brute. <br><img src="https://habrastorage.org/webt/py/lc/20/pylc206tjr1oraib8eynbeeatym.png" alt="image"></p><br><h2 id="validaciya-dokazatelstva">  Validation des preuves </h2><br><p>  Ceci est la derni√®re op√©ration.  Cela ne d√©pend pas de la structure de l'arbre, car  fonctionne avec le r√©sultat de la construction de preuves.  Je crois que la principale difficult√© ici est le calcul du hachage. <br><img src="https://habrastorage.org/webt/2h/n6/hk/2hn6hkfzrbhxnejuihg2xx2hpoc.png" alt="image"></p><br><h1 id="itog">  R√©sum√© </h1><br><ul><li>  La fa√ßon dont les donn√©es sont stock√©es affecte consid√©rablement les performances.  Lorsque tout dans un m√™me tableau est beaucoup plus rapide.  Et la s√©rialisation d'une telle structure sera tr√®s simple.  Le montant total du code est √©galement r√©duit. </li><li>  La concat√©nation des n≈ìuds avec le tri simplifie consid√©rablement le code, mais ne le rend pas plus rapide. </li></ul><br><h1 id="nemnogo-o-rust">  Un peu de rouille </h1><br><ul><li>  J'ai aim√© le cadre des <em>crit√®res</em> .  Il donne des r√©sultats clairs avec des valeurs moyennes et des √©carts √©quip√©s de graphiques.  Capable de comparer diff√©rentes impl√©mentations du m√™me code. </li><li>  Le manque d'h√©ritage n'interf√®re pas beaucoup avec la vie. </li><li>  Les macros sont un m√©canisme puissant.  Je les ai utilis√©s dans <a href="">mes tests d'arborescence</a> pour le param√©trage.  Je pense que si elles sont mal utilis√©es, vous pouvez faire une telle chose que vous-m√™me ne serez pas heureux plus tard. </li><li>  √Ä certains endroits, le compilateur s'ennuie avec ses v√©rifications de m√©moire.  Mon hypoth√®se initiale selon laquelle commencer √† √©crire en Rust si simplement ne fonctionnait pas √©tait correcte. <br><img src="https://habrastorage.org/webt/1n/uw/mf/1nuwmfwfozbeosqyvhtmbybur7w.png" alt="image"></li></ul><br><h1 id="ssylki">  Les r√©f√©rences </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une description plus compl√®te de l'algorithme de l'arbre de Merkle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crit√®re - cadre de test de charge</a> </li><li>  <a href="">merkle.rs - l'arbre le plus populaire sous la rouille</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vector-merkle-tree - mon impl√©mentation d'arbre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">merkle-tree-test-rs - un projet pour comparer les performances de deux biblioth√®ques</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455260/">https://habr.com/ru/post/fr455260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455248/index.html">Principales erreurs de d√©veloppement lors de l'utilisation de PostgreSQL</a></li>
<li><a href="../fr455250/index.html">Celui qui a ressuscit√© Duke Nukem: entretien avec Randy Pitchford, magicien de Gearbox</a></li>
<li><a href="../fr455252/index.html">.NET: Outils pour travailler avec le multithread et l'asynchronie - Partie 1</a></li>
<li><a href="../fr455256/index.html">Habr Weekly # 4 / Computex, comment b√™ta-t-on Apple, Durov meurt de faim, BadComedian cat, pourquoi le r√©seau de neurones a-t-il cherch√© des acteurs porno</a></li>
<li><a href="../fr455258/index.html">Le vote pour les rapports de la section Backend √† l'anniversaire de DevConfX a commenc√©, qui se tiendra les 21 et 22 juin √† Moscou</a></li>
<li><a href="../fr455264/index.html">Soyez comme Munch, ou quelques mots sur le devoir technique</a></li>
<li><a href="../fr455268/index.html">Comment tout a commenc√©: des √©crans flexibles et pliants - l'histoire de l'apparition et de la sortie des "personnes"</a></li>
<li><a href="../fr455272/index.html">TheOutloud - Voix et partagez vos articles et histoires pr√©f√©r√©s.</a></li>
<li><a href="../fr455276/index.html">Jeux cloud: le service Google Stadia annonce la tarification des utilisateurs</a></li>
<li><a href="../fr455280/index.html">R√©ponse du psychiatre √† l'article "Malade en bonne sant√©"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>