<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏼 🧝🏼 🕙 Mini AI Cup 2 ou presque AgarIO - ce qui pourrait être fait pour gagner 🖍️ 📐 👨‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! Cette fois, je veux écrire comment j'ai réussi à gagner la compétition Mini AI Cup 2 . Comme dans mon dernier article , il n'y aura pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mini AI Cup 2 ou presque AgarIO - ce qui pourrait être fait pour gagner</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420737/">  Bonjour à tous!  Cette fois, je veux écrire comment j'ai réussi à gagner la compétition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mini AI Cup 2</a> .  Comme dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article</a> , il n'y aura pratiquement aucun détail de mise en œuvre.  Cette fois, la tâche était moins volumineuse, mais il y avait néanmoins beaucoup de nuances et de petites choses qui affectaient le comportement du bot.  En conséquence, même après près de trois semaines de travail actif sur le bot, il y avait encore des idées sur la façon d'améliorer la stratégie. <br><br><img src="https://habrastorage.org/webt/iw/ef/hv/iwefhvnhx6m3ubjpwo_d0cgn3qi.png"><br><br>  Sous la coupe, beaucoup de gifs et de trafic. <br><a name="habracut"></a><br>  <i>Les persévérants le découvriront, les autres s'enfuiront avec horreur (d'après les commentaires sur la <s>brève</s> partie compressée).</i> <br><br>  <i>Ceux qui sont trop paresseux pour lire beaucoup peuvent aller à l'avant-dernier spoiler de l'article pour voir une <s>brève</s> description concise de l'algorithme <s>, puis vous pouvez commencer à lire depuis le début</s> .</i> <br><br>  Lien vers la source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le github</a> . <br><br><h3>  Sélection d'outils </h3><br>  Comme la dernière fois, il m'a fallu beaucoup de temps pour réfléchir par où commencer.  Le choix s'est fait, entre autres, entre deux langages: Java, familier pour moi, et déjà assez oublié des jours étudiants C ++.  Mais comme dès le début il me semblait que le principal obstacle à l'écriture d'un bon bot ne serait pas tant la vitesse de développement que la productivité de la solution finale, le choix s'est néanmoins porté en C ++. <br><br>  Après l'expérience réussie d'utiliser mon propre visualiseur pour déboguer le bot lors des compétitions précédentes, je ne voulais pas m'en passer cette fois aussi.  Mais le visualiseur que j'ai écrit moi-même sur Qt pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CodeWars</a> ne ressemblait pas à une solution idéale pour moi, et j'ai décidé d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> visualiseur.  Il a également été réalisé sous CodeWars, mais n'a pas nécessité de traitement sérieux pour être utilisé dans ce concours.  La relative simplicité de connexion et la commodité d'invoquer le rendu n'importe où dans le code jouaient en sa faveur. <br><br>  Comme auparavant, je voulais vraiment déboguer n'importe quel tick du jeu - la possibilité d'exécuter une stratégie à un moment arbitraire du jeu testé.  Étant donné que le visualiseur de plug-in n'a pas pu résoudre ce problème, à l'aide de la paire #ifdef (dans laquelle j'ai également encapsulé les morceaux de code responsables du rendu), j'ai ajouté à chaque tick l'enregistrement de la classe Context, qui contenait toutes les valeurs nécessaires des variables de la tick précédente.  À la base, la solution était similaire à celle que j'utilisais dans Code Wizards, mais cette fois, l'approche n'était pas si spontanée.  Après avoir simulé l'intégralité du jeu, il vous a été demandé de saisir le numéro du tick du jeu, qui doit être redémarré.  Des informations sur l'état des variables avant ce tick ont ​​été prises dans le tableau, ainsi que la ligne reçue par la stratégie d'entrée, ce qui m'a permis de jouer les mouvements de ma stratégie dans n'importe quel ordre nécessaire. <br><br><h3>  Commencer </h3><br>  Le jour de l'ouverture des règles, je ne suis pas passé et le premier soir j'ai regardé ce qui nous attend.  Il n'a pas hésité à s'indigner du format d'entrée json (oui, c'est pratique, mais certains participants commencent à apprendre de nouveaux PJ anciens ou oubliés depuis longtemps dans de telles compétitions, et commencer par l'analyse json n'est pas le plus agréable), a examiné l'étrange formule de mouvement et a commencé à former le cadre de l'avenir stratégies (pour comprendre l'article à l'avenir, il est utile de lire les <a href="">règles</a> ).  Pendant 2 jours, j'ai écrit un tas de cours comme Ejection, Virus, Player et autres, lisant json, connectant une bibliothèque à fichier unique pour la journalisation ... Et le soir de l'ouverture d'un bac à sable non classé, j'avais déjà une stratégie qui était presque identique en principe au C ++, mais significativement, un code beaucoup plus grand. <br><br>  Et puis ... j'ai commencé à trouver des options, comment les développer.  Réflexions à l'époque: <br><br><ul><li>  La recherche des états du monde ne peut être réduite à ces valeurs qui peuvent dominer le minimax et les modifications; </li><li>  Les champs potentiels sont bons, mais ils répondent mal à la question de savoir comment le monde changera les n tics suivants; </li><li>  La génétique et des algorithmes similaires fonctionneront, mais seulement 20 ms sont donnés par coup, et la profondeur de calcul serait souhaitable, à première vue, plus que les sensations ne peuvent être traitées en utilisant le GA.  Oui, et vous pouvez jouer avec la sélection des paramètres de mutation «avec bonheur pour toujours». </li></ul><br>  J'ai définitivement décidé une chose: nous devons faire une simulation du monde.  Après tout, les calculs approximatifs peuvent-ils «battre» un calcul froid et précis?  De telles considérations, bien sûr, m'ont incité à examiner le code qui était censé être responsable de la simulation du monde sur le serveur, car cette fois il a été mis dans le domaine public avec les règles.  Après tout, il n'y a rien de mieux que du code qui devrait décrire avec précision les règles du monde? <br><br>  J'ai donc pensé exactement jusqu'à ce que je commence à étudier le code qui était censé tester nos bots sur le serveur et localement.  Initialement, en termes de compréhensibilité et d'exactitude du code, tout n'était pas très bon, et les organisateurs, avec les participants, ont commencé à le traiter activement.  Pendant le test bêta (capture quelques jours après), les changements dans le moteur de jeu ont été très graves, et beaucoup n'ont commencé à participer qu'au moment où le moteur de test ne se stabilise pas.  Mais au final, à mon avis, ils ont attendu un moteur qui fonctionne bien pour un jeu très adapté au format compétition.  Je n'ai pas non plus commencé à mettre en œuvre d'approches sérieuses jusqu'à ce que le coureur local se stabilise, et pendant la première semaine, rien de plus sensé n'a été fait dans mon bot, à l'exception du visualiseur vissé. <br><br>  La veille du premier week-end du télégramme, les organisateurs ont créé un groupe distinct dans lequel il était supposé que les gens seraient en mesure d'aider à corriger et à améliorer le coureur local.  J'ai également participé aux travaux sur le moteur du monde.  Après des discussions dans ce chat, en tant que test, j'ai fait 2 demandes de tirage aux paramètres régionaux du coureur: ajuster la formule <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">alimentaire</a> (et de petits changements dans l'ordre de manger) aux règles, et fusionner plusieurs parties en une seule agaric tout en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">maintenant l'inertie et le centre de masse</a> ).  Ensuite, j'ai commencé à réfléchir à la façon d'insérer une physique de collision saine dans ce code, car la physique présente dans le monde du jeu à cette époque fonctionnait très illogiquement.  Les collisions entre les deux agarics n'étant pas décrites dans le règlement, j'ai demandé aux organisateurs des critères selon lesquels ma mise en place d'une telle logique serait acceptable.  La réponse était la suivante: les agarics dans une collision devraient être «mous» (c'est-à-dire qu'ils pourraient se heurter un peu), tandis que la logique d'une collision avec les murs ne devrait pas être touchée (c'est-à-dire que les murs devraient simplement arrêter les agarics, mais pas les repousser).  Et ma prochaine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">demande de traction a</a> été une sérieuse altération de la physique. <br><br><div class="spoiler">  <b class="spoiler_title">Avant et après altération de la physique</b> <div class="spoiler_text">  <i>Cette physique de collision était:</i> <br><img src="https://habrastorage.org/webt/hx/xc/ey/hxxceykf2thwuvqz9eknvhuy9rw.gif" alt="image"><br>  <i>Et elle le devint après les mises à jour:</i> <br><img src="https://habrastorage.org/webt/hu/4s/-k/hu4s-kyhokl2-0sotgkuhib2fem.gif" alt="image"><br></div></div><br>  Je voudrais également souligner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> demande de tirage, qui a considérablement réduit le code déroutant avec l'analyse d'état et un grand nombre de bogues trouvés (et potentiels) en quelque chose de beaucoup plus intelligible. <br><br><h3>  Écrire une simulation </h3><br>  Après avoir apporté le code des paramètres régionaux du coureur sous une forme saine, j'ai progressivement commencé à transférer le code de simulation mondiale des paramètres régionaux du coureur vers mon bot.  Tout d'abord, c'était bien sûr un code pour simuler le mouvement des agarics, et en même temps un code pour calculer la physique des collisions.  Il a fallu quelques soirées pour sauver le code repensé des bogues de réécriture (le transfert logique n'a pas été fait du tout en copiant le code) et des estimations approximatives de la profondeur des calculs. <br><br>  La fonction de notation pour chaque tick à ce moment était +1 pour la nourriture que je mange et -1 pour la nourriture mangée par l'ennemi, ainsi que des valeurs légèrement plus élevées pour manger les agarics les uns des autres.  Dans les constantes pour manger d'autres agarics, il y avait initialement une différence entre manger mon adversaire, mon adversaire (et, bien sûr, une très grosse amende pour avoir mangé ma dernière agarika par l'adversaire), ainsi que deux adversaires différents l'un de l'autre (après quelques jours le dernier coefficient est devenu 0).  De plus, la vitesse totale pour tous les ticks précédents de la simulation, chaque tick a été multipliée par 1 + 1e-5 pour encourager mon bot à effectuer des actions plus utiles au moins un peu plus tôt, et à la fin de la simulation, la vitesse du dernier tick a été ajoutée en bonus, également très petite .  Pour simuler le mouvement des agarics, des points ont été sélectionnés sur le bord de la carte avec un pas de 15 degrés par rapport aux coordonnées arithmétiques moyennes de tous mes agarics, et un point a été sélectionné lors de la simulation du mouvement auquel la fonction d'estimation a pris la plus grande valeur.  Et déjà avec une simulation aussi primitive et une évaluation simple à l'époque, le bot s'est en toute confiance retranché dans le top 10. <br><br><div class="spoiler">  <b class="spoiler_title">Démonstration de points, la commande de mouvement à laquelle l'algorithme a simulé à l'origine</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fy/xr/l_/fyxrl_dc2onzsfeij-vmex1qnoc.gif" alt="image"><br>  <i>Points, dont l'ordre de mouvement a été donné lors de différentes simulations.</i>  <i>Si vous regardez de très près - la commande finale donnée est parfois décalée par rapport aux points recherchés, mais ce sont les conséquences de modifications futures.</i> <br></div></div><br>  Au cours de la soirée de vendredi et samedi, une simulation de fusion d'agarics, une simulation de «sape» sur les virus, et de deviner le TTF de l'adversaire a été ajoutée.  Le TTF de l'adversaire était une valeur calculée assez intéressante, et il était possible de comprendre à quel point l'adversaire a fait une scission ou atteint le virus uniquement en saisissant le moment du vol incontrôlé, qui pourrait durer à partir d'un très petit nombre de tiques avec une grande viscosité et jusqu'au vol à travers toute la carte.  Étant donné que les collisions agariques pouvaient entraîner un léger excès de leur vitesse maximale, pour calculer le TTF de l'adversaire, j'ai vérifié que sa vitesse en deux ticks d'affilée correspond vraiment à la vitesse à laquelle vous pouvez obtenir deux ticks d'affilée en vol libre (en vol libre, les agarics volaient strictement en ligne droite et avec ralentissement de chaque tique strictement égal à la viscosité).  Cela a presque complètement éliminé la possibilité de faux positifs.  De plus, lors du test de cette logique, j'ai remarqué qu'un TTF plus grand correspond toujours à un identifiant plus grand de l'agaric (dont j'ai été plus tard convaincu lors du transfert du code d' <a href="">explosion sur le virus</a> et du <a href="">traitement de la division</a> ), ce qui valait également la peine d'être utilisé. <br><br>  Après avoir examiné les divisions constantes dans le top 3 (ce qui leur a permis de collecter de la nourriture de manière significative sur la carte), comme test, j'ai ajouté une commande de division permanente au bot s'il n'y avait pas d'ennemi dans le rayon de visibilité, et dimanche matin, j'ai trouvé mon bot sur la deuxième ligne de la note.  Gérer une poignée de petites agarics a considérablement augmenté le classement, mais les perdre était beaucoup plus facile si vous tombez sur un adversaire.  Et comme la peur d'être mangée par mes agarics était très conditionnelle (la peine était seulement pour manger dans une simulation, mais pas pour approcher un adversaire qui pouvait manger), la première chose a été ajoutée une pénalité pour traverser avec un adversaire qui pouvait manger.  Et cette même évaluation a fonctionné comme un bonus pour chasser un adversaire.  Après avoir vérifié la consommation du processeur avec ma stratégie, j'ai décidé d'ajouter un tour de simulation supplémentaire lorsque le fractionnement a été effectué lors du premier tick (cette logique, bien sûr, a également dû être transférée vers mon code à partir des paramètres régionaux du runner), puis la simulation s'est déroulée exactement comme avant. .  Ce type de logique n'était pas très approprié pour "tirer" sur l'ennemi (bien que parfois par accident, il se fendait à un moment très approprié), mais il était très bon pour collecter de la nourriture plus rapidement, ce que faisait tout le haut à ce moment-là.  De telles modifications nous ont permis d'entrer la semaine prochaine sur la première ligne de la notation, bien que la marge ne soit pas significative. <br><br>  À cette époque, cela suffisait, la «colonne vertébrale» de la stratégie était élaborée, la stratégie semblait assez primitive et extensible.  Mais ce que j'ai vraiment remarqué, c'est la consommation du processeur et la stabilité globale du code.  Par conséquent, les soirées de la prochaine partie de la semaine de travail ont été principalement consacrées à l'amélioration de la précision des simulations (ce que le visualiseur a beaucoup aidé), à la stabilisation du code (valgrind) et à certaines optimisations de la vitesse de travail. <br><br><h3>  Allons de l'avant </h3><br>  Ma prochaine stratégie envoyée, qui a montré un résultat nettement meilleur et devançait les adversaires (à l'époque), contenait deux changements importants: ajouter un champ potentiel pour collecter de la nourriture et doubler le nombre de simulations s'il y a un adversaire avec un TTF inconnu à proximité. <br><br>  Le champ potentiel de collecte de nourriture dans la première version était assez simple et son essence était de se souvenir de la nourriture qui avait disparu de la zone de visibilité, réduisant le potentiel dans les endroits près du bot ennemi et mettant à zéro dans ma zone de visibilité (avec restauration ultérieure tous les n tiques conformément aux règles).  Cela semblait être une amélioration utile, mais dans la pratique, à mon avis subjectif, la différence était soit faible, soit complètement absente.  Par exemple, sur des cartes à forte inertie et vitesse, le bot sautait souvent la nourriture et tentait ensuite d'y revenir, tout en perdant beaucoup de vitesse.  Cependant, s'il décidait de maintenir la vitesse et ignorait simplement la nourriture sautée, il mangerait beaucoup plus. <br><br><div class="spoiler">  <b class="spoiler_title">Champ potentiel de collecte de nourriture</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/aw/ae/lg/awaelgpt4zl98lgdjfr1rvk53so.gif" alt="image"><br>  <i>Vous pouvez faire attention à la façon dont tous les 40 ticks le champ devient un peu plus lumineux.</i>  <i>Toutes les 40 graduations, le champ est mis à jour en fonction de la façon dont la nourriture est ajoutée sur la carte, et la probabilité d'apparition de nourriture est uniformément «étalée» à travers le champ.</i>  <i>Si sur cette tique, nous voyons qu'il y a de la nourriture que nous verrions sur la tique précédente - la probabilité d'apparition de cet aliment n'est pas "étalée" avec le reste, mais est fixée par des points spécifiques (la nourriture apparaît toutes les 40 tiques de manière strictement symétrique).</i> <br></div></div><br>  Un utilitaire subjectif complètement différent s'est avéré être une double simulation de l'ennemi avec différents TTF - le minimum et le maximum possible (au cas où je ne connais pas le TTF pour tous les agarics visibles sur la carte).  Et si plus tôt mon robot pensait que le tas d'agarics ennemi deviendrait un tout et se déplacerait lentement, alors maintenant il a choisi le pire des deux scénarios et ne risque pas d'être proche de l'ennemi, dont il sait moins qu'il ne voudrait. <br><br>  Après avoir obtenu un avantage significatif, j'ai essayé de l'augmenter en ajoutant une définition du point auquel l'adversaire donne l'ordre à ses agarics de se déplacer, et bien que ce point ait été calculé dans la plupart des cas assez précisément, cela seul n'a pas amélioré les résultats du bot.  Selon mes observations, cela est devenu encore pire que le cas lorsque les agarics de l'adversaire se sont simplement déplacés dans la même direction et à la même vitesse que si l'adversaire n'avait rien fait, de sorte que ces modifications ont été enregistrées dans une branche de guitare séparée jusqu'à des temps meilleurs. <br><br><div class="spoiler">  <b class="spoiler_title">La définition de l'équipe adverse qui a été utilisée plus tard</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8l/vx/ac/8lvxacnkg_w4byrrkka9znflham.gif" alt="image"><br>  <i>Les rayons des agarics de l'adversaire montrent l'équipe présumée que l'adversaire a donnée à leurs agarics lors du tick précédent.</i>  <i>Les rayons bleus sont la direction exacte dans laquelle l'agarik a changé de direction au dernier tick.</i>  <i>Le noir est l'intention.</i>  <i>Il n'a été possible de déterminer plus précisément la direction de l'équipe que si la gélose était complètement dans la zone de notre visibilité (il a été possible de calculer l'effet des collisions sur le changement de sa vitesse).</i>  <i>L'intersection des rayons est l'équipe prévue de l'adversaire.</i>  <i>Gif réalisé sur la base du jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aicups.ru/session/200710</a> , environ 3 000 ticks.</i> <br></div></div><br>  Il y a également eu des tentatives de transfert de la fonction d'évaluation à l'évaluation de la masse gagnée, des tentatives de changement de la fonction d'évaluation du danger de l'adversaire ... Mais encore une fois, tous ces changements de sentiments se sont encore aggravés.  La seule chose qui était utile pour évaluer le danger d'être proche de l'ennemi était une autre optimisation des performances ainsi que l'extension de cette estimation à un rayon beaucoup plus grand que le rayon d'intersection avec l'ennemi (essentiellement toute la carte, mais avec une diminution quadratique, si légèrement simplifiée - faisant une présence dans cinq rayons ou plus de l'adversaire dans la région de 1/25 du danger maximum d'être mangé).  Le dernier changement également imprévu a conduit au fait que mes agariks ont eu très peur d'approcher un ennemi beaucoup plus grand, ainsi que dans le cas de leurs tailles très supérieures étaient plus enclins à se diriger vers l'adversaire.  Ainsi, il s'est avéré être un remplacement réussi et peu gourmand en ressources du code prévu pour l'avenir, qui était censé être responsable de la peur d'une attaque d'un adversaire par scission (et un peu d'aide pour une telle attaque pour moi plus tard). <br><br>  Après de longues et relativement vaines tentatives d’améliorer quelque chose, je suis de nouveau revenu à prédire la direction du mouvement de l’adversaire.  J'ai décidé de l'essayer si ce n'est pas seulement pour remplacer les rivaux factices, puis faites comme je l'ai fait avec l'option TTF minimum et maximum - simulez deux fois et choisissez la meilleure.  Mais pour cela, le CPU pourrait ne pas être suffisant, et dans de nombreux jeux de mon bot, ils pourraient simplement se déconnecter du système en raison d'un appétit insatiable.  Par conséquent, avant de mettre en œuvre cette option, j'ai ajouté une définition approximative du temps passé et, si les limites étaient dépassées, j'ai commencé à réduire le nombre de mouvements de simulation.  En ajoutant une double simulation de l'ennemi pour le cas où je connais l'endroit où il se dirige, j'ai de nouveau reçu une augmentation assez sérieuse dans la plupart des paramètres de jeu, à l'exception des plus gourmandes en ressources (avec une grande inertie / faible vitesse / faible viscosité), ce qui en raison d'une forte diminution de la profondeur Les simulations pourraient même s'aggraver un peu. <br><br>  Avant le début des parties de 25 000 ticks, deux autres améliorations utiles ont été apportées: la pénalité pour terminer la simulation loin du centre de la carte, ainsi que pour se souvenir de la position précédente de l'adversaire s'il quittait la ligne de vue (ainsi que pour simuler son mouvement à ce moment-là).                    ,                .            CPU      ,     .               .      .     ,          (,    )   “”   ,        . <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de champ de danger à la fin d'un virage dans un coin et de tiques gâchées</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rc/qc/7s/rcqc7st4c0xmmzn038tl7eiuxrm.png"><br> <i>      ,         </i> <br><img src="https://habrastorage.org/webt/r_/qm/zx/r_qmzxmxzysmrityd6sld0yjhlw.gif" alt="image"><br> <i>  ,       .      ,      .</i> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, des points de simulation de mouvement ont été ajoutés aux points sur le bord de la carte: à chaque agarik de rivaux et dans un rayon de la coordonnée moyenne arithmétique de mon agariki tous les 45 degrés. </font><font style="vertical-align: inherit;">Le rayon a été réglé sur distance moyenne des coordonnées arithmétiques moyennes de mes agarics.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouveaux points de simulation</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1g/tp/s0/1gtps0pna1gmgquavh75h2ta-jc.gif" alt="image"><br> <i>        .       «»   ,   .       .</i> <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Préparation finale </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au moment de l'ouverture des matchs pour 25 000 ticks et du passage à la finale, j'avais une solide marge, mais je n'avais pas l'intention de me détendre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec les nouveaux jeux 25k, la nouvelle est arrivée: les matchs de la finale auront également une longueur de 25k, et la limite de temps de la stratégie pour les ticks est devenue un peu plus longue. </font><font style="vertical-align: inherit;">Après avoir évalué le temps que ma stratégie passe sur le jeu dans les nouvelles conditions, j'ai décidé d'ajouter une autre version de la simulation: on fait tout comme d'habitude, mais pendant la simulation on the go n do split. </font><font style="vertical-align: inherit;">Cela, entre autres, a nécessité l'utilisation de la simulation trouvée à l'étape précédente, mais avec un décalage de 1 mouvement (par exemple, si nous avons constaté que le fractionnement de 7 ticks de l'actuel, alors le coup suivant, nous répétons la même chose, mais nous ferons déjà la division au 6ème coup). </font><font style="vertical-align: inherit;">Cela a considérablement ajouté des attaques agressives contre ses rivaux, mais a mangé un peu plus de temps de stratégie.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il aurait dû y avoir une description concise de l'algorithme</font></font></b> <div class="spoiler_text"> <i>   </i> <br><br>  : <br><img src="https://habrastorage.org/webt/nr/we/mj/nrwemjif4m5vgis-dy_r6shmc3u.gif"><br><ul><li> f — ,            ; </li><li> sim —        (  ,  , TTF ,     ); </li><li> finalPositionFoodPotentialField —   ,   ,    ; </li><li> finalPositionCornerDanger —        .        ,         ; </li><li> n — ,         .  10   50 ; </li><li> ateFood —         i; </li><li> virusBurst —            i; </li><li> opponentAteFood —        i; </li><li> meAteOpponent —      ; </li><li> opponentAteMe —      ; </li><li> mine/opponents —     .  C'est-à-dire          —      ; </li><li> danger —  ,   ,     . </li></ul><br><br><img src="https://habrastorage.org/webt/xu/0b/vq/xu0bvqxveolkicxieftkfrmuv5u.gif"><br><ul><li> moveType —    ,        ; </li><li> max/min TTF —   ,        TTF   (    TTF ); </li><li> dummy/aim —      Dummy         (    ,          ). </li></ul><br><br><img src="https://habrastorage.org/webt/kr/cn/vl/krcnvlbbrj1eyfcai1abuv4o4pi.gif"><br><ul><li> destination — ,         ; </li><li> moveTo —  ,   n    “   ”   ; </li><li> splitThenMove —       split   ; </li><li> delayedSplitThenMove —  ,  split    . </li></ul><br><br>             1 .  C'est-à-dire  splitThenMove    moveTo, delayedSplitThenMove      7  6 ,      6  5  ..     ,     —               7 .                . <br><br>  destination : <br><ul><li>      15       ( —  ).  24      ; </li><li>  ,       (    ); </li><li>         : </li><li> “”     ,       ; </li><li>  8   .             . </li></ul><br>    destination     ,              . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les perfectionnements ultérieurs étaient exclusivement liés à l'efficacité des simulations en cas de manque de TL: optimisation de la séquence de déconnexion de certaines parties de la logique en fonction du CPU consommé. </font><font style="vertical-align: inherit;">Dans la plupart des jeux, cela n'était pas censé changer quoi que ce soit, mais trouver quelque chose de plus correct ne fonctionnait pas.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Points finaux en finale</font></font></b> <div class="spoiler_text"> <i>          .  808       2424 ,     . <s>   .</s></i> <br> <a href=""><img src="https://habrastorage.org/webt/ij/bi/qf/ijbiqfz4pmd8je8ps7qfvird4pi.png"></a> <br></div></div><br><h4>  Au lieu d'une conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, le début de cette compétition s'est avéré plutôt huilé, mais dans les premières semaines et demie, la tâche a été ramenée à une forme assez jouable avec l'aide des participants. </font><font style="vertical-align: inherit;">Au départ, la tâche était très variable et choisir la bonne approche pour la résoudre ne semblait pas être une tâche triviale. </font><font style="vertical-align: inherit;">Il était encore plus intéressant de trouver des moyens d'améliorer l'algorithme sans dépasser les limites de la consommation du processeur. </font><font style="vertical-align: inherit;">Un grand merci aux organisateurs pour le concours et pour la mise en place des codes sources du monde pour l'accès libre. </font><font style="vertical-align: inherit;">Ces derniers, bien sûr, leur ont énormément ajouté des problèmes au départ, mais ont grandement facilité (sinon pour dire, ce qui a permis en principe) la compréhension par les participants du dispositif du simulateur mondial. </font><font style="vertical-align: inherit;">Un merci spécial pour l'opportunité de choisir un prix! </font><font style="vertical-align: inherit;">Le prix est donc ressorti beaucoup plus utile :-) </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ai-je besoin d'un autre MacBook?</font></font></s> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420737/">https://habr.com/ru/post/fr420737/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420715/index.html">La dure vérité sur la gravité de l'apprentissage</a></li>
<li><a href="../fr420725/index.html">Comment j'ai appris à l'IA à jouer à Tetris pour NES. Partie 1: analyse du code du jeu</a></li>
<li><a href="../fr420729/index.html">Webinaire ouvert "Naive Bayes Classifier"</a></li>
<li><a href="../fr420731/index.html">Zabbix sur les stéroïdes: comment fonctionne la plate-forme de surveillance unifiée de Sbertech</a></li>
<li><a href="../fr420735/index.html">Nous vous invitons à la finale du marathon Find Yourself in Digital au bureau du groupe Mail.Ru</a></li>
<li><a href="../fr420739/index.html">La boîte est toujours dans la poignée: pourquoi en 2018 vous devez encore apprendre les langues vous-même</a></li>
<li><a href="../fr420741/index.html">Aide-mémoire pour les programmeurs ou "nous allons google pour vous"</a></li>
<li><a href="../fr420749/index.html">GitLab pour le projet de livraison continue sur les technologies InterSystems: conteneurs</a></li>
<li><a href="../fr420753/index.html">Frontend de microservice - une approche moderne de la séparation du front</a></li>
<li><a href="../fr420757/index.html">Concours de programmation: commerce (résultats)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>