<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏰 🐷 🐙 OOP死了，OOP万岁 ⚔️ 🧓 ✨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="灵感来源 
 感谢Aras Prantskevichus最近发表的有关面向初级程序员的报告的文章，此帖子才得以发表。 它讨论了如何适应新的ECS体系结构。 Aras遵循通常的模式（ 以下说明 ）：显示了糟糕的OOP代码的示例，然后证明了关系模型（ 但称其为“ ECS”而不是关系模型 ）是一个很好的选...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP死了，OOP万岁</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="图片"></div><br><h1> 灵感来源 </h1><br> 感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">Aras Prantskevichus</a>最近发表的有关面向初级程序员的报告的文章，此帖子才得以发表。 它讨论了如何适应新的ECS体系结构。  Aras遵循通常的模式（ <em>以下说明</em> ）：显示了糟糕的OOP代码的示例，然后证明了关系模型（ <em>但称其为“ ECS”而不是关系模型</em> ）是一个很好的选择。 我绝不批评阿拉斯-我是他的工作的忠实拥护者，并赞扬他的出色表现！ 我选择了他的演示文稿，而不是从互联网上其他有关ECS的其他数百篇文章中选择，因为他付出了更多的努力，并在演示文稿发布的同时发布了一个git存储库供研究。 它包含一个小的简单“游戏”，用作选择不同体系结构解决方案的示例。 这个小项目使我可以展示我对特定材料的评论，所以，谢谢！ <br><br>  Aras幻灯片可在此处找到： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy-ECS-DoD.pdf</a> ，代码在github上： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">//github.com/aras-p/dod-playground</a> 。 <br><br> 我不会（尚未？）从此报告中分析最终的ECS体系结构，而是从一开始就专注于“糟糕的OOP”代码（类似于填充技巧）。 我将展示如果正确纠正所有违反OOD原理（面向对象的设计，面向对象的设计）的情况，它的真实外观。 <br><br>  <strong>破坏者：消除所有违反OOD的行为都可以提高性能，类似于从Aras到ECS的转换，它还比ECS版本使用更少的RAM和更少的代码行！</strong> <br><br>  <em>TL; DR：在得出OOP吸吮和ECS驱动器结论之前，请暂停并检查OOD（以了解如何正确使用OOP），并了解关系模型（以了解如何正确应用ECS）。</em> <br><a name="habracut"></a><br> 我长期在论坛上参与过很多关于ECS的讨论，部分原因是我认为该模型不应该单独存在（ <em>破坏者：这只是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">关系模型</a>的临时版本</em> ），还因为几乎<em>所有</em>宣传ECS模式的帖子，演示文稿或文章都遵循以下结构： <br><br><ol><li> 显示一个可怕的OOP代码示例，由于过度使用继承（其实现违反了许多OOD原理），其实现存在严重的缺陷。 <br></li><li> 证明组合比继承是更好的解决方案（更不用说OOD确实给了我们相同的教训）。 <br></li><li> 证明关系模型非常适合游戏（但称其为“ ECS”）。 </li></ol><br> 这样的结构使我很生气，因为： <strong>（A）</strong>这是一个“塞满”的把戏……它把软代码和温暖代码（不好的代码和好的代码）进行比较……这是不公平的，即使是无意间做的，也不需要证明新的体系结构是好的。 并且，更重要的是： <strong>（B）</strong>它具有副作用-这种方法抑制了知识，并无意中使读者不熟悉半个世纪的研究。 他们在1960年代开始撰写有关关系模型的文章。 在整个70年代和80年代，该模型已得到了显着改善。 初学者经常会遇到诸如“ <em>您想将这些数据放入哪个班级？</em> ”这样的问题，而作为回应，他们经常被告知有些含糊不清的信息，例如“ <em>您只需要积累经验，然后您就可以学会内在地理解</em> ”……但是在70年代，这个问题很活跃研究并在一般情况下得出正式答案； 这称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">数据库规范化</a> 。 抛弃现有研究并将ECS称为全新的现代解决方案，您就可以对初学者隐藏这些知识。 <br><br> 面向对象编程的基础已经建立在很久以前，甚至更早（ <em>这种风格在1950年代的工作中就开始探索了</em> ！）！ 但是，直到1990年代，面向对象才变得流行，流行，并很快变成了占主导地位的编程范例。 包括Java和（ <em>标准版本</em> ）C ++在内的许多新的OO语言的流行已经发生。 但是，由于这是由于大肆宣传，所以每个人都<em>需要</em>了解这一备受瞩目的概念，以便在简历中写信，但真正参与其中的只有少数人。 这些新语言从OO的许多功能中创建了关键字<em>-class</em> ， <em>virtual</em> ， <em>extends</em>和<em>Implements</em> ，我认为这就是为什么OO当时被划分为两个独立的实体，过着自己的生活。 <br><br> 我将这些受OO启发的语言功能的使用称为“ <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">OOP</a></strong> ”，并将对OO启发的设计/架构技术的使用称为“ <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">OOD</a></strong> ”。 所有人很快都接受了OOP。 教育机构开设了面向对象的课程，这些课程使新的面向对象编程人员感到欣慰……但是，对面向对象的知识却落后了。 <br><br> 我认为使用OOP语言功能但不遵循OOD设计原则的<strong>代码不是OO代码</strong> 。 对OOP的大多数批评都使用了内脏代码，例如，它并不是真正的OO代码。 <br><br>  OOP代码的声誉非常差，尤其是因为大多数OOP代码没有遵循OOD的原理，因此不是“真正的” OO代码。 <br><br><h1> 背景知识 </h1><br> 如上所述，1990年代成为“ OO时尚”的高峰，而那时“糟糕的OOP”可能是最糟糕的。 如果您当时学习过OOP，那么您很可能了解了“ OOP的四个支柱”： <br><br><ul><li> 抽象化 </li><li> 封装形式 </li><li> 多态性 </li><li> 传承 </li></ul><br> 我更喜欢称它们不是四个支柱，而是“四个OOP工具”。 这些是<em><strong>可</strong></em>用于解决问题的工具。 但是，仅仅找出工具的工作原理还不够，您需要知道何时使用它。对于教师而言，教导人们一种新工具，而不是告诉他们每一种工具何时值得使用是不负责任的。 在2000年代初期，人们对积极使用这些工具产生了抵制，这是OOD思维的“第二波”。 结果就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">SOLID</a>助记符的出现，它提供了一种评估架构优势的快速方法。 应当指出，这种智慧实际上是在90年代广泛传播的，但尚未得到一个很酷的首字母缩写词，这使它们被确定为五个基本原则。 <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">唯一责任原则</a></strong> （ <b>S</b> ingle责任原则）。 每个班级只有一个改变的理由。 如果“ A”类有两个职责，那么您需要创建“ B”和“ C”类以分别处理它们，然后从“ B”和“ C”中创建“ A”。 </li><li> 打开/关闭的原理（ <b>O</b>笔/关闭的原理）。 软件会随着时间而变化（ <em>即其支持很重要</em> ）。 尝试将最可能更改的部分放在<em>实现中（</em> <em>即在特定类中</em> ），并根据那些不太可能更改的部分创建<em>接口</em> （ <em>例如，抽象基类</em> ）。 <br></li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">Barbara Liskov的替代原理</a></strong> （ <b>L</b> iskov替代原理）。 接口的每个实现都必须100％满足该接口的要求，即 与接口配合使用的任何算法都应与任何实现配合使用。 </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">界面</a></strong>分离的原理（接口分离原理）。 使接口尽可能小，以便使代码的每个部分“知道”最少的代码库，例如，避免不必要的依赖性。 这个技巧对C ++也很有用，如果不遵循它的话，编译时间会变得很长。 </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">依赖反转原理</a></strong> （ <b>D</b>依赖反转原理）。 通常，可以通过将其通信接口规范化为第三类（用作它们之间的接口）来分离它们，而不是直接（彼此依赖）进行通信的两个特定实现。 它可以是定义它们之间使用的方法的调用的抽象基类，甚至可以是定义它们之间传递的数据的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">POD</a>结构。 </li><li> 首字母缩略词SOLID中没有包含另一个原则，但是我相信它非常重要： <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">“优先于继承而不是继承”</a></strong> （复合重用原则）。  <em>默认情况下，</em>合成<em>是正确的选择</em> 。 对于绝对必要的情况，应保留继承。 </li></ul><br> 所以我们得到SOLID-C（++） <img alt=":)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br> 下面我将参考这些原则，将其称为首字母缩写-SRP，OCP，LSP，ISP，DIP，CRP ... <br><br> 一些注意事项： <br><br><ul><li> 在OOD中， <em>接口</em>和<em>实现</em>的概念不能与任何特定的OOP关键字联系在一起。 在C ++中，我们经常使用<em>抽象基类</em>和<em>虚函数</em>创建接口，然后<em>实现</em>从这些基类继承……但这只是实现接口原理的一种特定方法。 在C ++中，我们还可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">PIMPL</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">不透明指针</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">鸭子类型</a> ，typedef等。。。您可以创建一个OOD结构，然后在C中实现它，而根本没有OOP语言关键字！ 因此，当我谈论<em>接口时</em> ，我不一定指<em>虚</em>函数-而是在讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">隐藏实现</a>的原理。 接口<em>可以</em>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">多态的</a> ，但往往不是！ 多态很少被正确使用，但是接口是所有软件的基本概念。 <br><ul><li> 正如我在上面明确指出的，如果您创建一个POD结构，该结构仅存储一些数据以从一个类传输到另一个类，则此结构将用作<em>接口</em> -这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">对数据</a>的正式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">描述</a> 。 <br></li><li> 即使仅使用<em>公共</em>部分和<em>私有</em>部分创建一个单独的类， <em>公共</em>部分中的所有内容也是一个<em>接口</em> ，私有部分中的所有内容都是一个<em>实现</em> 。 </li></ul></li><li> 继承实际上（至少）具有两种类型-接口继承和实现继承。 <br><ul><li> 在C ++中，接口继承包括具有纯虚函数，PIMPL，条件typedef的抽象基类。 在Java中，接口继承是通过<em>Implements</em>关键字表示的。 </li><li> 在C ++中，每当基类包含除纯虚函数之外的其他东西，实现的继承就会发生。 在Java中，实现继承是使用<em>extend关键字</em>表示的。 </li><li>  OOD对于继承接口有很多规则，但是实现的继承通常值得考虑为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">“一口代码”</a> ！ </li></ul></li></ul><br> 最后，我将展示一些可怕的OOP培训示例，以及它如何导致现实生活中的不良代码（以及OOP的不良声誉）。 <br><br><ol><li> 在教授层次结构/继承时，您可能会得到类似的任务： <strong><em>假设您有一个大学应用程序，其中包含学生和工作人员的目录。</em></strong>  <strong><em>您可以创建基类Person，然后创建从Person继承的Student类和Staff类。</em></strong> <br><br> 不不不 在这里，我会阻止你。  LSP原理不言而喻的含义是<em>类层次结构</em>和<em>处理它们</em>的<em>算法</em>是共生的。 这是整个程序的两半。  OOP是过程编程的扩展，并且仍然主要与这些过程相关。 如果我们不知道<i>学生</i>和<em>教职员工</em>可以使用哪种类型的算法（ <em>并且由于多态性而简化了哪些算法</em> ），那么开始创建类层次结构是完全不负责任的。 首先，您需要了解算法<em>和</em>数据。 </li><li> 当您学习层次结构/继承时，您可能会得到类似的任务： <b><i>假设您有一类形状。</i></b>  <b><i>我们也有正方形和矩形作为子类。</i></b>  <b><i>正方形应该是矩形，还是矩形是正方形？</i></b> <br><br> 这实际上是一个很好的示例，可以演示实现的继承与接口的继承之间的区别。 <br><ul><li> 如果您使用实现继承方法，那么您将完全忽略LSP，并且从实际的角度考虑使用继承作为工具来重用代码的可能性。 <br><br> 从这个角度来看，以下是完全合乎逻辑的： <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br> 正方形只有宽度，矩形只有宽度+高度，也就是说，用高度分量扩展正方形，我们得到一个矩形！ <br><ul><li> 您可能已经猜到了，OOD表示这样做（ <em>可能</em> ）是错误的。 我说<em>“大概”</em>是因为在这里您可以争论接口的隐含特性……哦。 <br><br> 正方形始终具有相同的高度和宽度，因此从正方形的界面中完全可以假设该区域为“宽度*宽度”。 <br><br> 继承自正方形的矩形类别（根据LSP） <strong>必须</strong>遵守正方形接口的规则。 任何适用于正方形的算法也应适用于矩形。 </li><li> 采用另一种算法： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br> 它将对正方形正确（计算它们的面积之和），但对矩形不起作用。 <br><br> 因此，矩形违反了LSP原理。 </li></ul></li><li> 如果使用接口继承方法，则Square和Rectangle都不会相互继承。 正方形和矩形的接口实际上是不同的，并且一个不是另一个的超集。 <br></li><li> 因此，OOD不鼓励使用实现继承。 如上所述，如果您想重用代码，则OOD表示组合是正确的选择！ <br><ul><li> 因此，以上（错误）代码的<i>正确</i>版本适用于C ++实现的继承层次结构，如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  Java中的“公共虚拟”是指“实现”。 在实现接口时使用。 <br></li><li>  “ Private”允许您扩展基类而不继承其接口-在这种情况下，尽管矩形继承自矩形，但它<b>不是</b>正方形。 <br></li></ul></li><li> 我不建议编写这样的代码，但是如果您想使用实现的继承，那么就需要这样做！ </li></ul></li></ul></li></ol><br>  TL; DR-您的OOP类告诉您继承是什么样的。 您缺少的OOD类应该告诉您99％的时间不要使用它！ <br><br><h1> 实体/组件概念 </h1><br> 在处理了先决条件之后，让我们继续前进至Aras的起点-所谓的“典型OOP”起点。 <br><br> 但是对于初学者来说，还有一个补充-Aras将此代码称为“传统OOP”，我想对此表示反对。 该代码对于现实世界中的OOP可能是典型的，但是，像上面的示例一样，它违反了OO的所有基本原理，因此根本不应视为传统代码。 <br><br> 在他开始重新构建ECS结构之前，我将首先进行第一次提交： <a href="" rel="external nofollow">“使它再次在Windows上运行” 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br> 是的，很难立即计算出一百行代码，所以让我们开始吧……我们还需要先决条件的一个方面-在90年代的游戏中，使用继承来解决所有代码重用的问题很普遍。 您拥有实体，可扩展角色，可扩展播放器和怪物，等等……这是实现的继承，如我们先前所描述的（ <em>“扼杀代码”</em> ），看来从它开始是正确的，但是结果导致不灵活的代码库。 因为OOD具有上述“继承之上的组成”原则。 因此，在2000年代，“组成高于继承”的原则开始流行，游戏开发人员开始编写类似的代码。 <br><br> 该代码的作用是什么？ 好不好 <img alt="：D" height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title="：D" width="20"><br><br> 简而言之， <strong>此代码重新实现了该语言的现有功能-组合</strong>为运行时库，而不是该语言的功能。 您可以想象一下，好像代码实际上是在C ++之上创建了一个新的元语言，并在虚拟机（VM）上执行该元语言。 在Aras演示游戏中，不需要此代码（ <em>我们将很快将其完全删除！</em> ），仅可将游戏性能降低约10倍。 <br><br> 但是他实际上在做什么？ 这是“实体/组件系统”（ <em>有时由于某种原因被称为“实体/组件系统”</em> ）的概念，但是与<em>“实体/组件系统”</em>的概念完全不同组件系统（“” entity-component-system“）（ <em>出于明显的原因，从来没有被称为</em> “实体组件系统”。）它规范了“ EC”的几个原则： <br><br><ul><li> 游戏将基于不具有“实体”（“实体”）（ <em>在此示例中称为</em> GameObjects）的功能构建，该功能由“组件”（“ Component”）组成。 </li><li>  GameObjects实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">“服务定位器”模式</a> -将按类型查询其子组件。 </li><li> 组件知道它们属于哪个GameObject-通过查询父级GameObject可以找到与它们处于同一级别的组件。 <br></li><li> 合成只能<em>深一层</em> （ <em>组件不能具有自己的子组件，GameObjects不能具有子GameObjects</em> ）。 <br></li><li>  GameObject每种类型只能有一个组件（ <em>在某些框架中这是强制性要求，在其他框架中则不是</em> ）。 <br></li><li> 每个组件（可能）会以某种未指定的方式随时间变化，因此该接口包含“虚拟无效更新”。 <br></li><li>  GameObject属于可以对所有GameObject（并因此对所有组件）执行查询的场景。 </li></ul><br> 类似的概念在2000年代非常流行，尽管有其局限性，但事实证明它足够灵活，可以创建当时和今天的无数游戏。 <br><br> 但是，这不是必需的。 您的编程语言已经支持组合作为该语言的功能-不需要need肿的概念来访问它。那么，为什么存在这些概念？ 好吧，老实说，它们允许您<em>在运行时</em>执行<em>动态合成</em> 。 您可以从数据文件中加载它们，而不必在代码中硬性定义GameObject类型。 这非常方便，因为它允许游戏/关卡设计人员创建自己的对象类型。但是，在大多数游戏项目中，设计人员很少，实际上是一整套程序员，因此我认为这是一个重要的机会。 更糟糕的是，这不是在运行时实现合成的唯一方法！ 例如，Unity使用C＃作为其“脚本语言”，许多其他游戏使用其替代语言，例如Lua，这是一种方便的工具，设计人员可以生成C＃/ Lua代码来定义新的游戏对象，而无需这种such肿的概念！ 我们将在下一篇文章中重新添加此“功能”，并使其不会导致性能降低十倍... <br><br> 让我们根据OOD评估此代码： <br><br><ul><li>  GameObject :: GetComponent使用dynamic_cast。 大多数人会告诉您，dynamic_cast是“令人窒息的代码”，这很明显地表明您在某处存在错误。 我要说这-这是您违反<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">LSP的</a>证据-您有某种可以与基本接口一起使用的算法，但是它需要知道不同的实现细节。 由于这个特殊原因，代码闻起来很糟。 <br></li><li> 原则上来说，GameObject不错，如果您想象它实现了“服务定位器”模板...但是，如果您从OOD的角度出发不仅仅批评，那么该模板会在项目的各个部分之间创建隐式连接，并且我认为（ <em>没有可以支持的Wikipedia链接）我从计算机科学的知识中了解到</em> ）隐式沟通渠道是一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">反模式</a> ，他们应该更喜欢显式沟通渠道。 相同的论点适用于有时在游戏中使用的the肿的“事件概念” ... <br></li><li> 我想声明一个组件违反了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">SRP，</a>因为它的接口（ <em>virtual void Update（time）</em> ）太宽了。 在游戏开发中普遍使用“虚拟无效更新”，但我还要说这是反模式。 好的软件应该可以让您轻松地考虑控制流和数据流。 将<em>游戏代码的每个元素</em>放在“虚拟无效更新”调用之后，这将完全混淆控制流和数据流。 恕我直言，无形的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">副作用</a> ，也称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">远程，</a>是一些最常见的bug来源，“虚拟无效更新”可确保几乎所有内容都是无形的副作用。 <br></li><li> 尽管Component类的目标是启用合成，但它是通过继承来实现的，这违反了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">CRP</a> 。 </li><li> 此示例的唯一好处是，为了遵守SRP和ISP的原则，游戏代码过大了-将游戏代码划分为许多简单的组件，几乎没有责任，这对于重用代码非常有用。 <br><br> 但是，他不太擅长维护DIP-许多组件之间具有彼此直接的知识。 </li></ul><br> 因此，上面显示的所有代码实际上都可以删除。 这整个结构。 删除GameObject（在其他框架中也称为Entity），删除Component，删除FindOfType。 这是违反OOD原则的无用VM的一部分，极大地减慢了我们的游戏速度。 <br><br><h1> 没有框架的组合（即使用编程语言本身的功能） </h1><br> 如果我们删除了合成框架而没有Component基类，那么我们的GameObjects将如何使用合成并由组件组成？ 就像标题中所说的那样，不要编写这个肿的VM并在其之上以奇怪的语言创建GameObjects，而只需用C ++编写它们，因为我们是游戏程序员，这实际上是我们的工作。 <br><br> 这是删除了实体/组件框架的提交： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">//github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br> 这是源代码的原始版本： <a href="" rel="external nofollow">https</a> : <a href="" rel="external nofollow">//github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br> 这是源代码的修改版： <a href="" rel="external nofollow">https</a> : <a href="" rel="external nofollow">//github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br> 简要介绍一下更改： <br><br><ul><li> 从每种组件类型中删除了“：public Component”。 <br></li><li> 为每种类型的组件添加了一个构造函数。 <br><ul><li>  OOD主要是关于封装类的状态的，但是由于这些类非常小/简单，因此实际上没有什么可隐藏的：接口是对数据的描述。 但是，封装是主要支柱的主要原因之一是，它使我们能够保证<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">类不变式</a>的恒定真理……或者如果不变式被破坏，那么您只需要检查封装的实现代码以发现错误。 在此代码示例中，值得添加构造函数以实现简单的不变式-必须初始化所有值。 </li></ul></li><li> 我重命名了过于笼统的“ Update”方法，以使其名称能够反映它们的实际功能-MoveComponent的UpdatePosition以及避免组件的ResolveCollisions。 <br></li><li> 我删除了三个类似于模板/预制的硬编码代码块-创建包含特定类型Component的GameObject的代码，并将其替换为三个C ++类。 <br></li><li> 消除了反模式“虚拟无效更新”。 <br></li><li> 游戏无需在组件之间通过“服务定位器”模板互相寻找，而是在构建过程中将它们明确绑定在一起。 </li></ul><br><h2> 对象 </h2><br> 因此，代替此“虚拟机”代码： <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br> 现在，我们有了常规的C ++代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2> 演算法 </h2><br> 对算法进行了另一项重大更改。 记住，在一开始我曾说过接口和算法可以共生，并且应该影响彼此的结构吗？ 因此，反模式“ <em>virtual void Update</em> ”也已成为这里的敌人。 初始代码包含主循环算法，仅包括以下内容： <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br> 您可以说它是美丽而简单的，但是恕我直言，它是非常非常糟糕的。 这完全混淆了游戏中的<em>控制</em> <em>流</em>和<em>数据流</em> 。 如果我们希望能够理解我们的软件，想要对其进行支持，想要向其添加新的东西，对其进行优化，在多个处理器内核上高效地执行它，那么我们既需要了解控制流，也需要了解数据流。 因此，“虚拟无效更新”必须着火。 <br><br> 相反，我们创建了一个更明确的主循环，该循环大大简化了对控制流的理解（ <em>仍然混淆</em>了其中的<em>数据流，但是我们将在以下提交中解决此问题</em> ）。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br> 这种风格的缺点是，对于添加到游戏中的<em>每种新类型的对象</em> ，我们都必须在主循环中添加几行。 我将在本系列的后续文章中再次谈到这一点。 <br><br><h1> 性能表现 </h1><br> 有很多严重的OOD违规行为，在选择结构时做出了一些错误的决定，并且有很多优化的机会，但是我将在本系列的下一篇文章中找到它们。 但是，在此阶段已经很明显，带有“固定OOD”的版本几乎从演示结束就完全匹配或赢得了最终的“ ECS”代码……而我们所做的只是采用错误的伪OOP代码并使其符合原则。 OOP（还删除了一百行代码）！ <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1> 后续步骤 </h1><br> 在这里，我想考虑范围更广的问题，包括解决剩余的OOD问题，不可变的对象（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">以功能风格进行编程</a> ）以及它们可以带来有关数据流，消息传递，将DOD逻辑应用于我们的OOD代码的讨论的优势，在OOD代码中运用相关的知识，删除最终得到的这些“实体”类，并仅使用纯组件，并使用不同的样式来连接组件（比较指针和指针）。 从现实世界中携带）的容器部件的责任，ECS-修订版本更好的优化，以及进一步优化，在报表中不阿拉斯<em>（如多线程/ SIMD）</em>提及<em>。</em> 顺序不一定是这个顺序，也许我不会考虑以上所有内容... <br><br><h1> 加法 </h1><br> 这篇文章的链接已经超出了游戏开发人员的范围，因此，我将添加：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">ECS</a> ”（ <em>顺便说一下，此Wikipedia文章很糟糕，它结合了EC和ECS的概念，而且不尽相同...</em> ）-这是在社区中流传的虚假模板游戏开发商。 实际上，它是关系模型的一种版本，其中“实体”只是指定无形对象的ID，“组件”是引用ID的特定表中的行，而“系统”是可以修改组件的过程代码。 这个“模板”一直被定位为解决过度使用继承问题的解决方案，但是没有提到过度使用继承实际上违反了OOP的建议。 因此，我很愤慨。 这不是编写软件的“唯一真实方法”。 该帖子旨在确保人们实际了解现有的设计原则。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441174/">https://habr.com/ru/post/zh-CN441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441158/index.html">伦理如何成为最昂贵的硅谷问题，而哲学如何成为其最实际的解决方案</a></li>
<li><a href="../zh-CN441160/index.html">如何学习确定何时说不</a></li>
<li><a href="../zh-CN441166/index.html">我们从锁定的密码管理器中获取主密码1密码4</a></li>
<li><a href="../zh-CN441168/index.html">QUIC数据通道：第一步</a></li>
<li><a href="../zh-CN441172/index.html">2018年3D打印市场如何增长以及对业务意味着什么</a></li>
<li><a href="../zh-CN441180/index.html">多云，星空下有无障碍广告的机会</a></li>
<li><a href="../zh-CN441182/index.html">用于检测网络DDoS攻击的机器综合方法。 第二部分</a></li>
<li><a href="../zh-CN441184/index.html">第一届游戏会议Mail.ru集团</a></li>
<li><a href="../zh-CN441186/index.html">ASH查看器：重新启动</a></li>
<li><a href="../zh-CN441192/index.html">使用R的计算能力检验均值相等的假设</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>