<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçï üë≤üèæ ü§¶üèº Wenn externe Funktionsaufrufe schneller sind als native C-Aufrufe üïì ü§üüèø ‚úñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinzugef√ºgt von: gute Diskussion √ºber Hacker News 

 David Yu auf GitHub hat einen interessanten Leistungstest f√ºr Funktionsaufrufe √ºber verschiedene ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenn externe Funktionsaufrufe schneller sind als native C-Aufrufe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413181/"> <font color="gray"><i>Hinzugef√ºgt von: gute Diskussion √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hacker News</a></i></font> <br><br>  David Yu auf GitHub hat einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessanten Leistungstest</a> f√ºr Funktionsaufrufe √ºber verschiedene externe Schnittstellen (Foreign Function Interfaces, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FFI</a> ) entwickelt. <br><br>  Er erstellte eine gemeinsam genutzte Objektdatei ( <code>.so</code> ) mit einer einfachen C-Funktion. Dann schrieb er Code, um diese Funktion wiederholt √ºber jedes FFI mit einer Zeitdimension aufzurufen. <br><br>  F√ºr C ‚ÄûFFI‚Äú verwendete er die standardm√§√üige dynamische Verkn√ºpfung, nicht <code>dlopen()</code> .  Dieser Unterschied ist sehr wichtig, da er die Testergebnisse wirklich beeinflusst.  Sie k√∂nnen argumentieren, wie ehrlich dieser Vergleich mit dem tats√§chlichen FFI ist, aber es ist immer noch interessant zu messen. <br><br>  Das √ºberraschendste Benchmark-Ergebnis ist, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> FFI von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LuaJIT</a> <b>deutlich schneller ist als C.</b>  Es ist ungef√§hr 25% schneller als ein nativer C-Aufruf f√ºr eine gemeinsam genutzte Objektfunktion.  Wie k√∂nnte eine schwach und dynamisch typisierte Skriptsprache in Benchmark C √ºberholen?  Ist das Ergebnis korrekt? <br><a name="habracut"></a><br>  In der Tat ist dies ziemlich logisch.  Der Test l√§uft unter Linux, daher stammt die Verz√∂gerung aus der Procedure Linkage Table (PLT).  Ich habe ein wirklich einfaches Experiment vorbereitet, um den Effekt in einfachem alten C zu demonstrieren: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/skeeto/dynamic-function-benchmark</a> <br><br>  Hier sind die Ergebnisse des Intel i7-6700 (Skylake): <br><br> <code>plt: 1.759799 ns/call <br> ind: 1.257125 ns/call <br> jit: 1.008108 ns/call</code> <br> <br>  Es gibt drei verschiedene Arten von Funktionsaufrufen: <br><br><ol><li>  √úber PLT. </li><li>  Indirekter Funktionsaufruf (via <code>dlsym(3)</code> ) </li><li>  Direkter Funktionsaufruf (√ºber eine JIT-kompilierte Funktion) </li></ol><br>  Wie Sie sehen k√∂nnen, ist letzteres das schnellste.  Es wird normalerweise nicht in C-Programmen verwendet, ist jedoch eine nat√ºrliche Option, wenn ein JIT-Compiler vorhanden ist, einschlie√ülich nat√ºrlich LuaJIT. <br><br>  In meinem Benchmark hei√üt die Funktion <code>empty()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Kompilieren Sie zu einem freigegebenen Objekt: <br><br><pre> <code class="cpp hljs">$ cc -shared -fPIC -Os -o empty.so empty.c</code> </pre> <br>  Wie im vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PRNG-Vergleich</a> ruft der Benchmark diese Funktion so oft wie m√∂glich auf, bevor der Alarm ausgel√∂st wird. <br><br><h1>  Prozedur Layout-Tabellen </h1><br>  Wenn ein Programm oder eine Bibliothek eine Funktion in einem anderen gemeinsam genutzten Objekt aufruft, kann der Compiler nicht wissen, wo sich diese Funktion im Speicher befindet.  Informationen werden nur zur Laufzeit ermittelt, wenn das Programm und seine Abh√§ngigkeiten in den Speicher geladen werden.  Normalerweise befindet sich die Funktion an zuf√§lligen Stellen, beispielsweise gem√§√ü der Randomisierung des Adressraums (Address Space Layout Randomization, ASLR). <br><br>  Wie kann man ein solches Problem l√∂sen?  Nun, es gibt mehrere M√∂glichkeiten. <br><br>  Eine davon besteht darin, jeden Aufruf in bin√§ren Metadaten zu markieren.  Der Builder f√ºr dynamische Laufzeit <i>f√ºgt</i> dann bei jedem Aufruf <i>die</i> richtige Adresse ein.  Der spezifische Mechanismus h√§ngt vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codemodell ab</a> , das w√§hrend der Kompilierung verwendet wurde. <br><br>  Der Nachteil dieses Ansatzes besteht darin, dass er das Laden verlangsamt, die Gr√∂√üe von Bin√§rdateien erh√∂ht und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Austausch von Codepages</a> zwischen verschiedenen Prozessen verringert.  Das Herunterladen wird verlangsamt, da alle Peers mit dynamischer Wahl vor dem Starten des Programms mit der richtigen Adresse gepatcht werden m√ºssen.  Die Bin√§rdatei ist aufgebl√§ht, da jeder Eintrag einen Platz in der Tabelle ben√∂tigt.  Und das Fehlen einer Freigabe ist mit einer √Ñnderung der Codepages verbunden. <br><br>  Auf der anderen Seite kann der Aufwand f√ºr das Aufrufen dynamischer Funktionen entfallen, was zu einer JIT-√§hnlichen Leistung f√ºhrt, wie im Benchmark gezeigt. <br><br>  Die zweite Option besteht darin, alle dynamischen Anrufe √ºber eine Tabelle weiterzuleiten.  Der urspr√ºngliche Dial Peer bezieht sich auf den Stub in dieser Tabelle und von dort auf die eigentliche dynamische Funktion.  Bei diesem Ansatz muss der Code nicht gepatcht werden, was zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">trivialen Austausch</a> zwischen Prozessen f√ºhrt.  F√ºr jede dynamische Funktion m√ºssen Sie nur einen Datensatz in der Tabelle patchen.  Dar√ºber hinaus k√∂nnen diese Korrekturen beim ersten Aufruf der Funktion <i>tr√§ge</i> vorgenommen werden, was das Laden noch weiter beschleunigt. <br><br>  Auf ELF-Bin√§rsystemen wird diese Tabelle als Procedure Linkage Table (PLT) bezeichnet.  PLT selbst wird nicht wirklich korrigiert - es wird f√ºr den Rest des Codes als schreibgesch√ºtzt angezeigt.  Stattdessen wird die Global Offset Table (GOT) korrigiert.  Der PLT-Stub ruft die Adresse einer dynamischen Funktion vom GOT ab und springt <i>indirekt</i> zu dieser Adresse.  Um Funktionsadressen tr√§ge zu laden, werden diese GOT-Eintr√§ge mit der Adresse der Funktion initialisiert, die das Zielzeichen findet, die GOT mit dieser Adresse aktualisiert und dann mit der Funktion fortf√§hrt.  Nachfolgende Anrufe verwenden eine tr√§ge erkannte Adresse. <br><br><img src="https://habrastorage.org/webt/47/2r/yh/472ryhlyogynkwwrxyopa1rg7l0.png"><br><br>  Der Nachteil von PLT ist der zus√§tzliche Aufwand f√ºr das Aufrufen einer dynamischen Funktion, wie er im Benchmark angegeben wurde.  Da der Benchmark <i>nur</i> Funktionsaufrufe misst, scheint der Unterschied ziemlich signifikant zu sein, in der Praxis liegt er jedoch normalerweise nahe bei Null. <br><br>  Hier ist der Benchmark: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Cleared by an alarm signal. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plt_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) empty(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  Da sich <code>empty()</code> in einem gemeinsam genutzten Objekt befindet, durchl√§uft der Aufruf die PLT. <br><br><h1>  Indirekte dynamische Anrufe </h1><br>  Eine andere M√∂glichkeit, Funktionen dynamisch aufzurufen, besteht darin, die PLT zu durchlaufen und die Adresse der Zielfunktion im Programm beispielsweise √ºber <code>dlsym(3)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *h = dlopen(<span class="hljs-string"><span class="hljs-string">"path/to/lib.so"</span></span>, RTLD_NOW); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*f)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(<span class="hljs-string"><span class="hljs-string">"f"</span></span>); f();</code> </pre> <br>  Wenn die Funktionsadresse empfangen wird, sind die Kosten geringer als die Funktionsaufrufe √ºber PLT.  Es gibt keine Zwischenfunktion f√ºr Stub und Zugriff auf GOT.  (Achtung: Wenn das Programm einen PLT-Datensatz f√ºr diese Funktion hat, kann <code>dlsym(3)</code> tats√§chlich eine Stub-Adresse zur√ºckgeben.) <br><br>  Dies ist jedoch immer noch eine <i>indirekte</i> Herausforderung.  Bei herk√∂mmlichen Architekturen erhalten <i>direkte</i> Funktionsaufrufe ihre unmittelbare relative Adresse.  Das hei√üt, der Zweck des Anrufs ist ein fest codierter Versatz vom Anrufpunkt.  Die CPU kann viel fr√ºher herausfinden, wohin der Anruf f√ºhren wird. <br><br>  Indirekte Anrufe haben mehr Overhead.  Zun√§chst muss die Adresse irgendwo gespeichert werden.  Selbst wenn es sich nur um ein Register handelt, erh√∂ht seine Verwendung das Registerdefizit.  Zweitens provozieren indirekte Aufrufe einen Verzweigungspr√§diktor in der CPU, wodurch der Prozessor zus√§tzlich belastet wird.  Im schlimmsten Fall kann ein Aufruf sogar dazu f√ºhren, dass die Pipeline gestoppt wird. <br><br>  Hier ist der Benchmark: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indirect_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) f(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  Die an diesen Benchmark √ºbergebene Funktion wird mit <code>dlsym(3)</code> extrahiert, sodass der Compiler keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schwierigen</a> <code>dlsym(3)</code> kann, z. B. die Konvertierung dieses indirekten <code>dlsym(3)</code> in einen direkten Aufruf. <br><br>  Wenn der Schleifenk√∂rper komplex genug ist, um ein Registerdefizit zu verursachen und damit dem Stapel die Adresse zu geben, kann dieser Benchmark auch nicht ehrlich mit dem PLT-Benchmark verglichen werden. <br><br><h1>  Direkte Funktionsaufrufe </h1><br>  Die ersten beiden Arten von dynamischen Funktionsaufrufen sind einfach und benutzerfreundlich.  <i>Direkte</i> Aufrufe f√ºr dynamische Funktionen sind schwieriger zu organisieren, da sie w√§hrend der Ausf√ºhrung Code√§nderungen erfordern.  In meinem Benchmark habe ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleinen JIT-Compiler zusammengestellt</a> , um einen direkten Aufruf zu generieren. <br><br>  Der Trick besteht darin, dass bei x86-64 explizite √úberg√§nge aufgrund des 32-Bit-Operanden mit Vorzeichen (sofort signiert) auf einen Bereich von 2 GB beschr√§nkt sind.  Dies bedeutet, dass der JIT-Code fast neben der Zielfunktion <code>empty()</code> .  Wenn der JIT-Code zwei verschiedene dynamische Funktionen aufrufen muss, die durch mehr als 2 GB geteilt werden, ist es unm√∂glich, zwei direkte Anrufe zu t√§tigen. <br><br>  Um die Situation zu vereinfachen, ist mein Benchmark nicht besorgt √ºber die genaue oder sehr sorgf√§ltige Auswahl der Adresse des JIT-Codes.  Nach dem Empfang der Adresse der Zielfunktion werden einfach 4 MB subtrahiert, auf die n√§chste Seite gerundet, ein wenig Speicher zugewiesen und Code darauf geschrieben.  Wenn alles so gemacht wird, wie es sollte, m√ºssen Sie zur Suche nach einem Ort Ihre eigenen Darstellungen des Programms im Speicher √ºberpr√ºfen. Dies kann nicht auf saubere, tragbare Weise erfolgen.  Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erfordert das Parsen virtueller Dateien unter / proc</a> . <br><br>  So sieht meine JIT-Speicherzuordnung aus.  Es wird ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angemessenes Verhalten f√ºr das Casting von uintptr_t vorausgesetzt</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jit_compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct jit_func *f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*empty)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> addr = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)empty; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *desired = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((addr - SAFETY_MARGIN) &amp; PAGEMASK); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = mmap(desired, len, prot, flags, fd, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Hier stechen zwei Seiten hervor: eine zum Schreiben und die andere mit nicht beschreibbarem Code.  Wie in meiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek f√ºr Schlie√üungen</a> ist hier die untere Seite beschreibbar und enth√§lt eine <code>running</code> Variable, die auf Alarm zur√ºckgesetzt wird.  Diese Seite sollte sich neben dem JIT-Code befinden, um einen effektiven Zugriff auf RIP als Funktion in den beiden anderen Benchmarks zu erm√∂glichen.  Die obere Seite enth√§lt diesen Assemblycode: <br><br><pre> <code class="hljs vbscript">jit_benchmark: push rbx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> ebx, ebx .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: mov eax, [rel running] test eax, eax je .done <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> inc ebx jmp .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> .done: mov eax, ebx pop rbx ret</code> </pre> <br>  <code>call empty</code> ist die einzige dynamisch generierte Anweisung. Die relative Adresse muss korrekt eingegeben werden (minus 5 wird relativ zum <i>Ende der</i> Anweisung angezeigt): <br><br><pre> <code class="hljs lisp"> // call empty uintptr_t rel = (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)empty - (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)p - <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-comment"><span class="hljs-comment">; *p++ = 0xe8; *p++ = rel &gt;&gt; 0; *p++ = rel &gt;&gt; 8; *p++ = rel &gt;&gt; 16; *p++ = rel &gt;&gt; 24;</span></span></code> </pre> <br>  Befindet sich die Funktion <code>empty()</code> nicht im allgemeinen Objekt, sondern in derselben Bin√§rdatei, handelt es sich im Wesentlichen um einen direkten Aufruf, den der Compiler f√ºr <code>plt_benchmark()</code> generiert, sofern er aus irgendeinem Grund nicht <code>empty()</code> eingebaut hat. <br><br>  Ironischerweise erfordert das Aufrufen eines JIT-kompilierten Codes einen indirekten Aufruf (z. B. √ºber einen Funktionszeiger), und daran f√ºhrt kein Weg vorbei.  Was kann ich hier tun, JIT-kompilieren Sie eine andere Funktion f√ºr einen direkten Aufruf?  Gl√ºcklicherweise spielt dies keine Rolle, da nur ein direkter Anruf in einer Schleife gemessen wird. <br><br><h1>  Kein Geheimnis </h1><br>  Angesichts dieser Ergebnisse wird deutlich, warum LuaJIT effizientere Aufrufe dynamischer Funktionen als PLT generiert, <i>auch wenn diese indirekte Aufrufe bleiben</i> .  In meinem Benchmark waren indirekte Anrufe ohne PLT 28% schneller als mit PLT und direkte Anrufe ohne PLT waren 43% schneller als mit PLT.  Dieser kleine Vorteil von JIT-Programmen gegen√ºber einfachen alten nativen Programmen wird durch die absolute Ablehnung des Codeaustauschs zwischen Prozessen erreicht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413181/">https://habr.com/ru/post/de413181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413169/index.html">N√ºtzliche Array- und Objektmethoden in JavaScript</a></li>
<li><a href="../de413171/index.html">Tokamak JET startet neue Deuterium Tritium Kampagne</a></li>
<li><a href="../de413173/index.html">√úberwachen von JavaScript-Fehlern mit window.onerror</a></li>
<li><a href="../de413175/index.html">Statische Analyse in Go: Wie wir Zeit sparen, wenn wir Code √ºberpr√ºfen</a></li>
<li><a href="../de413177/index.html">Digitale Events in Moskau vom 4. bis 10. Juni</a></li>
<li><a href="../de413183/index.html">Optane DC Persistent Memory - Optane im DIMM-Format</a></li>
<li><a href="../de413185/index.html">Foulspiel oder wie die Organisatoren der Auslosung uns t√§uschen</a></li>
<li><a href="../de413187/index.html">Interview mit Ryan Dahl, Sch√∂pfer von Node.js</a></li>
<li><a href="../de413189/index.html">Sammlung von CSS-Lidschatten Box-Shadows.css</a></li>
<li><a href="../de413195/index.html">Funktionales Denken. Teil 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>