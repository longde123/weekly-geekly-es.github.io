<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéõÔ∏è ‚õèÔ∏è üòÉ Copiar sem√¢ntica e gerenciamento de recursos em C ++ ü§ûüèº üßó üêÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No C ++, o programador deve decidir como os recursos usados ‚Äã‚Äãser√£o liberados; n√£o h√° ferramentas autom√°ticas como o coletor de lixo. O artigo discute...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Copiar sem√¢ntica e gerenciamento de recursos em C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>No C ++, o programador deve decidir como os recursos usados ‚Äã‚Äãser√£o liberados; n√£o h√° ferramentas autom√°ticas como o coletor de lixo.</i>  <i>O artigo discute poss√≠veis solu√ß√µes para esse problema, considera poss√≠veis problemas em detalhes, al√©m de v√°rios problemas relacionados.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Sum√°rio </h1><br><div class="spoiler">  <b class="spoiler_title">Sum√°rio</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdu√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Estrat√©gias b√°sicas de propriedade de c√≥pias</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrat√©gia de proibi√ß√£o de c√≥pia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrat√©gia de Propriedade Exclusiva</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrat√©gia de c√≥pia em profundidade</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrat√©gia de copropriedade</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. Estrat√©gia de c√≥pia profunda - problemas e solu√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Copiar em registro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Definindo uma Fun√ß√£o de Troca de Estado para uma Classe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Removendo c√≥pias intermedi√°rias pelo compilador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o de sem√¢ntica de deslocamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alojamento vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inser√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.6</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sum√°rio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3. Op√ß√µes para implementar uma estrat√©gia de propriedade compartilhada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Estrat√©gia de propriedade exclusiva e sem√¢ntica de movimento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. Estrat√©gia de Proibi√ß√£o de C√≥pia - In√≠cio R√°pido</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. O ciclo de vida do recurso e o objeto do propriet√°rio do recurso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Captura de recursos na inicializa√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Op√ß√µes avan√ßadas de gerenciamento do ciclo de vida dos recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ciclo de vida estendido de recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.2.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Captura de recurso √∫nico</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Indire√ß√£o aumentada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Co-propriedade</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Resumo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplica√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ap√™ndice A. Links de Valor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ap√™ndice B. Sem√¢ntica de Deslocamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Refer√™ncias</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  1. Introdu√ß√£o </h1><br><p> Gerenciamento de recursos √© algo que um programador C ++ precisa fazer o tempo todo.  Os recursos incluem blocos de mem√≥ria, objetos do kernel do SO, bloqueios multithread, conex√µes de rede, conex√µes de banco de dados e qualquer objeto criado na mem√≥ria din√¢mica.  O acesso ao recurso √© por meio de um descritor, o tipo do descritor geralmente √© um ponteiro ou um de seus aliases ( <code>HANDLE</code> , etc.), √†s vezes o todo (descritores de arquivo UNIX).  Depois de usar o recurso, voc√™ deve liber√°-lo, caso contr√°rio, mais cedo ou mais tarde, um aplicativo que n√£o libera recursos (e possivelmente outros aplicativos) ficar√° sem recursos.  Esse problema √© muito grave, podemos dizer que um dos principais recursos do .NET, Java e v√°rias outras plataformas √© um sistema de gerenciamento de recursos unificado baseado na coleta de lixo. </p><br><p>  Os recursos orientados a objeto do C ++ naturalmente levam √† seguinte solu√ß√£o: a classe que gerencia o recurso cont√©m o descritor de recursos como membro, inicializa o descritor quando o recurso √© capturado e libera o recurso no destruidor.  Mas depois de algum pensamento (ou experi√™ncia) vem a compreens√£o de que n√£o √© t√£o simples.  E o principal problema √© a sem√¢ntica da c√≥pia.  Se a classe que gerencia o recurso usa o construtor de c√≥pias gerado pelo compilador padr√£o, depois de copiar o objeto, obteremos duas c√≥pias do identificador do mesmo recurso.  Se um objeto libera um recurso, depois disso, o segundo poder√° tentar usar ou liberar o recurso j√° liberado, o que, em qualquer caso, est√° incorreto e pode levar ao chamado comportamento indefinido, ou seja, qualquer coisa pode acontecer, por exemplo, uma interrup√ß√£o anormal do programa. </p><br><p>  Felizmente, em C ++, um programador pode controlar totalmente o processo de c√≥pia, definindo um construtor de c√≥pias e um operador de atribui√ß√£o de c√≥pias sozinho, o que nos permite resolver o problema acima, e geralmente n√£o de uma maneira.  A implementa√ß√£o da c√≥pia deve estar intimamente ligada ao mecanismo de libera√ß√£o do recurso, e chamaremos isso coletivamente de estrat√©gia de propriedade da c√≥pia.  A chamada "regra das Tr√™s Grandes" √© bem conhecida, que afirma que se um programador define pelo menos uma das tr√™s opera√ß√µes - construtor de c√≥pias, operador de atribui√ß√£o de c√≥pias ou destruidor - ele deve definir as tr√™s opera√ß√µes.  As estrat√©gias de propriedade de c√≥pia apenas especificam como fazer isso.  Existem quatro estrat√©gias b√°sicas de propriedade de c√≥pia. </p><br><a name="id-1"></a><br><h1>  1. Estrat√©gias b√°sicas de propriedade de c√≥pias </h1><br><p>  Antes da captura do recurso ou ap√≥s seu lan√ßamento, o descritor deve assumir um valor especial indicando que ele n√£o est√° associado ao recurso.  Normalmente, este √© zero, √†s vezes -1, convertido em um tipo de descritor.  De qualquer forma, esse descritor ser√° chamado zero.  A classe que gerencia o recurso deve reconhecer o descritor nulo e n√£o tentar usar ou liberar o recurso nesse caso. </p><br><a name="id-1-1"></a><br><h2>  1.1  Estrat√©gia de proibi√ß√£o de c√≥pia </h2><br><p>  Esta √© a estrat√©gia mais simples.  Nesse caso, √© simplesmente proibido copiar e atribuir inst√¢ncias de classe.  O destruidor libera o recurso capturado.  No C ++, proibir a c√≥pia n√£o √© dif√≠cil, a classe deve declarar, mas n√£o definir, o construtor de c√≥pia fechada e o operador de atribui√ß√£o de c√≥pia. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  As tentativas de c√≥pia s√£o frustradas pelo compilador e vinculador. </p><br><p>  O padr√£o C ++ 11 oferece uma sintaxe especial para este caso: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Essa sintaxe √© mais visual e fornece mensagens mais compreens√≠veis para o compilador ao tentar copiar. </p><br><p>  Na vers√£o anterior da biblioteca padr√£o (C ++ 98), as classes de fluxos de entrada / sa√≠da ( <code>std::fstream</code> , etc.) usavam a estrat√©gia de proibi√ß√£o de c√≥pia e, no Windows, muitas classes do MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> etc.).  Na biblioteca padr√£o do C ++ 11, algumas classes usam essa estrat√©gia para oferecer suporte √† sincroniza√ß√£o multithread. </p><br><a name="id-1-2"></a><br><h2>  1.2  Estrat√©gia de Propriedade Exclusiva </h2><br><p>  Nesse caso, ao implementar c√≥pia e atribui√ß√£o, o descritor de recursos passa do objeto de origem para o objeto de destino, ou seja, permanece em uma √∫nica c√≥pia.  Ap√≥s copiar ou atribuir, o objeto de origem possui um descritor nulo e n√£o pode usar o recurso.  O destruidor libera o recurso capturado.  Os termos propriedade exclusiva ou estrita [Josuttis] tamb√©m s√£o usados ‚Äã‚Äãpara esta estrat√©gia; Andrei Alexandrescu usa o termo c√≥pia destrutiva.  No C ++ 11, isso √© feito da seguinte maneira: a c√≥pia regular e a atribui√ß√£o de c√≥pias s√£o proibidas da maneira descrita acima, e a sem√¢ntica de movimento √© implementada, ou seja, o construtor de movimenta√ß√£o e o operador de atribui√ß√£o de movimenta√ß√£o s√£o definidos.  (Mais sobre sem√¢ntica de movimento posteriormente.) </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Assim, a estrat√©gia de propriedade exclusiva pode ser considerada uma extens√£o da estrat√©gia de proibi√ß√£o de c√≥pias. </p><br><p>  Na biblioteca padr√£o do C ++ 11, essa estrat√©gia usa o ponteiro inteligente <code>std::unique_ptr&lt;&gt;</code> e algumas outras classes, por exemplo: <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , bem como as classes que usavam anteriormente a estrat√©gia de proibi√ß√£o de c√≥pia ( <code>std::fstream</code> , etc.).  No Windows, as classes MFC que usavam anteriormente a estrat√©gia de proibi√ß√£o de c√≥pia tamb√©m come√ßaram a usar a estrat√©gia de propriedade exclusiva ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> etc.). </p><br><a name="id-1-3"></a><br><h2>  1.3  Estrat√©gia de c√≥pia em profundidade </h2><br><p>  Nesse caso, voc√™ pode copiar e atribuir inst√¢ncias de classe.  √â necess√°rio definir o construtor de c√≥pia e o operador de atribui√ß√£o de c√≥pia, para que o objeto de destino copie o recurso para si do objeto de origem.  Depois disso, cada objeto possui sua c√≥pia do recurso, pode usar, modificar e liberar independentemente o recurso.  O destruidor libera o recurso capturado.  √Äs vezes, para objetos que usam a estrat√©gia de c√≥pia em profundidade, o termo objetos de valor √© usado. </p><br><p>  Essa estrat√©gia n√£o se aplica a todos os recursos.  Ele pode ser aplicado a recursos associados a um buffer de mem√≥ria, como strings, mas n√£o est√° muito claro como aplic√°-lo a objetos do kernel do sistema operacional, como arquivos, mutexes etc. </p><br><p>  A estrat√©gia de c√≥pia em profundidade √© usada em todos os tipos de cadeias de objetos, <code>std::vector&lt;&gt;</code> e em outros cont√™ineres da biblioteca padr√£o. </p><br><a name="id-1-4"></a><br><h2>  1.4  Estrat√©gia de copropriedade </h2><br><p>  Nesse caso, voc√™ pode copiar e atribuir inst√¢ncias de classe.  Voc√™ deve definir o construtor de c√≥pia e o operador de atribui√ß√£o de c√≥pia no qual o descritor de recursos (assim como outros dados) √© copiado, mas n√£o o pr√≥prio recurso.  Depois disso, cada objeto possui sua pr√≥pria c√≥pia do descritor, pode usar, modificar, mas n√£o pode liberar o recurso, desde que haja pelo menos mais um objeto que possua uma c√≥pia do descritor.  Um recurso √© liberado ap√≥s o √∫ltimo objeto que possui uma c√≥pia do identificador ficar fora do escopo.  Como isso pode ser implementado est√° descrito abaixo. </p><br><p>  As estrat√©gias de copropriedade s√£o frequentemente usadas por indicadores inteligentes, e tamb√©m √© natural us√°-las para recursos imut√°veis.  O ponteiro inteligente <code>std::shared_ptr&lt;&gt;</code> implementa essa estrat√©gia na biblioteca padr√£o do C ++ 11. </p><br><a name="id-2"></a><br><h1>  2. Estrat√©gia de c√≥pia profunda - problemas e solu√ß√µes </h1><br><p>  Considere um modelo para a fun√ß√£o de troca de estado de objetos do tipo <code>T</code> na biblioteca padr√£o do C ++ 98. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Se o tipo <code>T</code> possui um recurso e usa uma estrat√©gia de c√≥pia profunda, temos tr√™s opera√ß√µes para alocar um novo recurso, tr√™s opera√ß√µes de c√≥pia e tr√™s opera√ß√µes para liberar recursos.  Embora na maioria dos casos, essa opera√ß√£o possa ser realizada sem alocar novos recursos e copiar, basta que os objetos troquem dados internos, incluindo um descritor de recursos.  Existem muitos exemplos semelhantes quando voc√™ precisa criar c√≥pias tempor√°rias de um recurso e liber√°-las imediatamente.  Uma implementa√ß√£o t√£o ineficaz das opera√ß√µes cotidianas estimulou a busca de solu√ß√µes para sua otimiza√ß√£o.  Vamos considerar as principais op√ß√µes. </p><br><a name="id-2-1"></a><br><h2>  2.1  Copiar em registro </h2><br><p>  A c√≥pia na grava√ß√£o (COW), tamb√©m chamada de c√≥pia diferida, pode ser vista como uma tentativa de combinar uma estrat√©gia de c√≥pia profunda e uma estrat√©gia de propriedade compartilhada.  Inicialmente, ao copiar um objeto, o descritor de recurso √© copiado, sem o pr√≥prio recurso, e para os propriet√°rios, o recurso se torna compartilhado e somente leitura, mas assim que algum propriet√°rio precisa modificar o recurso compartilhado, o recurso √© copiado e, em seguida, esse propriet√°rio trabalha com ele. uma c√≥pia  A implementa√ß√£o da COW resolve o problema da troca de estados: a aloca√ß√£o adicional de recursos e a c√≥pia n√£o ocorrem.  O uso de COW √© bastante popular na implementa√ß√£o de strings; por exemplo, <code>CString</code> (MFC, ATL).  Uma discuss√£o sobre poss√≠veis maneiras de implementar a COW e quest√µes emergentes pode ser encontrada em [Meyers1], [Sutter].  [Guntheroth] prop√¥s uma implementa√ß√£o de COW usando <code>std::shared_ptr&lt;&gt;</code> .  Existem problemas ao implementar o COW em um ambiente multiencadeado, e √© por isso que √© proibido usar o COW para seq√º√™ncias de caracteres na biblioteca C ++ 11 padr√£o, consulte [Josuttis], [Guntheroth]. </p><br><p>  O desenvolvimento da ideia COW leva ao seguinte esquema de gerenciamento de recursos: o recurso √© imut√°vel e gerenciado por objetos usando a estrat√©gia de propriedade compartilhada; se necess√°rio, altere o recurso, um novo recurso modificado adequadamente ser√° criado e um novo objeto propriet√°rio ser√° retornado.  Esse esquema √© usado para seq√º√™ncias de caracteres e outros objetos imut√°veis ‚Äã‚Äãnas plataformas .NET e Java.  Na programa√ß√£o funcional, √© usado para estruturas de dados mais complexas. </p><br><a name="id-2-2"></a><br><h2>  2.2  Definindo uma Fun√ß√£o de Troca de Estado para uma Classe </h2><br><p>  Foi demonstrado acima como a fun√ß√£o de troca de estado pode ser ineficiente, implementada de maneira direta, por meio de c√≥pia e atribui√ß√£o.  E √© amplamente utilizado, por exemplo, √© usado por muitos algoritmos da biblioteca padr√£o.  Para que os algoritmos n√£o usem outro <code>std::swap()</code> , mas outra fun√ß√£o definida especificamente para a classe, duas etapas devem ser executadas. </p><br><p>  1. Defina na classe uma fun√ß√£o membro <code>Swap()</code> (o nome n√£o √© importante) que implementa a troca de estados. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Voc√™ deve garantir que essa fun√ß√£o n√£o <code>noexcept</code> exce√ß√µes; no C ++ 11, essas fun√ß√µes devem ser declaradas como n√£o <code>noexcept</code> . </p><br><p>  2. No mesmo espa√ßo para nome da classe <code>X</code> (geralmente no mesmo arquivo de cabe√ßalho), defina a fun√ß√£o <code>swap()</code> livre (n√£o membro) da seguinte maneira (o nome e a assinatura s√£o fundamentais): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Depois disso, os algoritmos da biblioteca padr√£o a usar√£o, n√£o <code>std::swap()</code> .  Isso fornece um mecanismo chamado pesquisa dependente de argumento (ADL).  Para mais informa√ß√µes sobre ADL, consulte [Dewhurst1]. </p><br><p>  Na biblioteca padr√£o C ++, todos os cont√™ineres, ponteiros inteligentes e outras classes implementam a fun√ß√£o de troca de estado conforme descrito acima. </p><br><p>  A fun√ß√£o de membro <code>Swap()</code> geralmente √© facilmente definida: √© necess√°rio aplicar seq√ºencialmente uma opera√ß√£o de troca de estado aos bancos de dados e membros, se eles suportarem, e <code>std::swap()</code> caso contr√°rio. </p><br><p>  A descri√ß√£o acima √© um pouco simplificada, uma mais detalhada pode ser encontrada em [Meyers2].  Uma discuss√£o sobre quest√µes relacionadas √† fun√ß√£o de troca de estados tamb√©m pode ser encontrada em [Sutter / Alexandrescu]. </p><br><p>  A fun√ß√£o de troca de estado pode ser atribu√≠da a uma das opera√ß√µes b√°sicas da classe.  Com ele, voc√™ pode definir outras opera√ß√µes com eleg√¢ncia.  Por exemplo, o operador de atribui√ß√£o de c√≥pia √© definido por meio de copy e <code>Swap()</code> seguinte maneira: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Esse modelo √© chamado de idioma de c√≥pia e troca ou idioma de Herb Sutter. Para mais detalhes, consulte [Sutter], [Sutter / Alexandrescu], [Meyers2].  Sua modifica√ß√£o pode ser aplicada para implementar a sem√¢ntica do deslocamento, consulte as se√ß√µes 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3  Removendo c√≥pias intermedi√°rias pelo compilador </h2><br><p>  Considere a classe </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  E fun√ß√£o </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Com uma abordagem direta, o retorno da fun√ß√£o <code>Foo()</code> √© realizado copiando a inst√¢ncia do <code>X</code>  Mas os compiladores s√£o capazes de remover a opera√ß√£o de c√≥pia do c√≥digo, o objeto √© criado diretamente no ponto de chamada.  Isso √© chamado de otimiza√ß√£o do valor de retorno (RVO).  O RVO √© usado pelos desenvolvedores de compiladores h√° algum tempo e atualmente est√° corrigido no padr√£o C ++ 11.  Embora a decis√£o sobre o RVO seja tomada pelo compilador, o programador pode escrever c√≥digo com base em seu uso.  Para fazer isso, √© desej√°vel que a fun√ß√£o tenha um ponto de retorno e o tipo da express√£o retornada corresponda ao tipo do valor de retorno da fun√ß√£o.  Em alguns casos, √© aconselh√°vel definir um construtor fechado especial chamado ‚Äúconstrutor computacional‚Äù, para obter mais detalhes, consulte [Dewhurst2].  O RVO tamb√©m √© discutido em [Meyers3] e [Guntheroth]. </p><br><p>  Os compiladores podem excluir c√≥pias intermedi√°rias em outras situa√ß√µes. </p><br><a name="id-2-4"></a><br><h2>  2.4  Implementa√ß√£o de sem√¢ntica de deslocamento </h2><br><p>  A implementa√ß√£o da sem√¢ntica de movimenta√ß√£o consiste em definir um construtor de movimenta√ß√£o que tenha um par√¢metro do tipo rvalue-reference para a origem e um operador de atribui√ß√£o de movimenta√ß√£o com o mesmo par√¢metro. </p><br><p>  Na biblioteca padr√£o do C ++ 11, o modelo da fun√ß√£o de troca de estado √© definido da seguinte maneira: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  De acordo com as regras para resolver sobrecargas de fun√ß√µes com par√¢metros do tipo rvalue-reference (consulte o Ap√™ndice A), no caso em que o tipo <code>T</code> tenha um construtor em movimento e um operador de atribui√ß√£o m√≥vel, eles ser√£o usados ‚Äã‚Äãe n√£o haver√° aloca√ß√£o de recursos e c√≥pias tempor√°rios.  Caso contr√°rio, o construtor de c√≥pias e o operador de atribui√ß√£o de c√≥pias ser√£o usados. </p><br><p>  O uso da sem√¢ntica da realoca√ß√£o evita a cria√ß√£o de c√≥pias tempor√°rias em um contexto muito mais amplo do que a fun√ß√£o de troca de estado descrita acima.  A sem√¢ntica de movimento se aplica a qualquer valor rvalue, ou seja, um valor tempor√°rio, sem nome, bem como ao valor de retorno de uma fun√ß√£o se ela foi criada localmente (incluindo lvalue) e o RVO n√£o foi aplicado.  Em todos esses casos, √© garantido que o objeto de origem n√£o possa ser utilizado de forma alguma ap√≥s a movimenta√ß√£o.  A sem√¢ntica de movimenta√ß√£o tamb√©m se aplica ao valor lvalue ao qual a transforma√ß√£o <code>std::move()</code> √© aplicada.  Mas, neste caso, o programador √© respons√°vel por como os objetos de origem ser√£o usados ‚Äã‚Äãap√≥s a movimenta√ß√£o (exemplo: <code>std::swap()</code> ). </p><br><p>  A biblioteca C ++ 11 padr√£o foi redesenhada, levando em considera√ß√£o a sem√¢ntica do movimento.  Muitas classes adicionaram um construtor de movimenta√ß√£o e um operador de atribui√ß√£o de movimenta√ß√£o, al√©m de outras fun√ß√µes-membro, com par√¢metros do tipo refer√™ncia de valor.  Por exemplo, <code>std::vector&lt;T&gt;</code> possui uma vers√£o sobrecarregada do <code>void push_back(T&amp;&amp; src)</code> .  Tudo isso permite, em muitos casos, evitar a cria√ß√£o de c√≥pias tempor√°rias. </p><br><p>  A implementa√ß√£o da sem√¢ntica de movimenta√ß√£o n√£o cancela as defini√ß√µes da fun√ß√£o de troca de estado para uma classe.  Uma fun√ß√£o de troca de estado especialmente definida pode ser mais eficiente que o padr√£o <code>std::swap()</code> .  Al√©m disso, o construtor de movimenta√ß√£o e o operador de atribui√ß√£o de movimenta√ß√£o s√£o muito facilmente definidos usando a fun√ß√£o de membro da troca de estados da seguinte maneira (varia√ß√£o da express√£o de c√≥pia e troca): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  O construtor de movimenta√ß√£o e o operador de atribui√ß√£o de movimenta√ß√£o s√£o aquelas fun√ß√µes-membro para as quais √© altamente desej√°vel garantir que eles n√£o <code>noexcept</code> exce√ß√µes e, portanto, sejam declarados como sem <code>noexcept</code> .  Isso permite otimizar algumas opera√ß√µes dos cont√™ineres da biblioteca padr√£o sem violar a garantia estrita da seguran√ßa das exce√ß√µes; consulte [Meyers3] e [Guntheroth] para obter detalhes.  O modelo proposto fornece essa garantia, desde que o construtor padr√£o e a fun√ß√£o membro da troca de estados n√£o lan√ßem exce√ß√µes. </p><br><p>  O padr√£o C ++ 11 fornece ao compilador a gera√ß√£o autom√°tica de um construtor em movimento e um operador de atribui√ß√£o m√≥vel.Para fazer isso, eles devem ser declarados usando a constru√ß√£o <code>"=default"</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  As opera√ß√µes s√£o implementadas aplicando sequencialmente a opera√ß√£o de movimenta√ß√£o √†s bases e membros da classe, se suportarem a movimenta√ß√£o, e copie as opera√ß√µes de outra forma.  √â claro que esta op√ß√£o est√° longe de ser sempre aceit√°vel.  Os descritores brutos n√£o se movem, mas geralmente n√£o √© poss√≠vel copi√°-los.  Sob certas condi√ß√µes, o compilador pode gerar independentemente um construtor m√≥vel semelhante e um operador de atribui√ß√£o m√≥vel, mas √© melhor n√£o usar essa oportunidade, essas condi√ß√µes s√£o bastante confusas e podem mudar facilmente quando a classe √© refinada.  Veja [Meyers3] para detalhes. </p><br><p>  Em geral, a implementa√ß√£o e o uso da sem√¢ntica do deslocamento √© uma "coisa sutil".  O compilador pode aplicar c√≥pias onde o programador espera uma mudan√ßa.  Aqui est√£o algumas regras para eliminar ou pelo menos reduzir a probabilidade de tal situa√ß√£o. </p><br><ol><li>  Se poss√≠vel, use a proibi√ß√£o de c√≥pia. </li><li>  Declare o construtor de movimenta√ß√£o e o operador de atribui√ß√£o de movimenta√ß√£o como <code>noexcept</code> . </li><li>  Implemente sem√¢ntica de movimento para classes base e membros. </li><li>  Aplique a transforma√ß√£o <code>std::move()</code> aos par√¢metros das fun√ß√µes do tipo rvalue reference. </li></ol><br><p>  A regra 2 foi discutida acima.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      ‚Äî   (variadic templates),         .  ,      C++11 ‚Äî     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6  Sum√°rio </h2><br><p>     ,    ,     .               -  .                   .   ‚Äî     :    ,    .     ,       ,     ,  .      :     ,     ,  ¬´¬ª   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    ‚Äî   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    ‚Äî   .     6. </p><br><p>   ,     -  -,  ¬´  ¬ª,   -     .         -    . ,   ,     ,     ,    -       .      ¬´¬ª. </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          ¬´   ¬ª (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      ¬´¬ª RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2> 6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     ¬´  ¬ª,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  ¬´¬ª RAII,   ‚Äî          .      ,     ,    . 3.       .    ¬´¬ª,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        ‚Äî    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Aplica√ß√µes </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Um exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- ‚Äî      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         ‚Äî    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Refer√™ncias </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  do ingl√™s  - M .: LLC ‚ÄúI.D. ¬ª, 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  do ingl√™s ‚Äî .:  ¬´-¬ª, 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  do ingl√™s  - M .: LLC ‚ÄúI.D. ¬ª, 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  do ingl√™s ‚Äî .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  do ingl√™s ‚Äî .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  do ingl√™s ‚Äî .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  do ingl√™s ‚Äî .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  do ingl√™s  - M .: LLC ‚ÄúI.D. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  do ingl√™s ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  do ingl√™s  - M .: LLC ‚ÄúI.D. ¬ª, 2015. </p><br><p> [Schildt] <br> , .    C++.: .  do ingl√™s ‚Äî .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  do ingl√™s ‚Äî .:  ¬´ ¬´¬ª, 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425837/">https://habr.com/ru/post/pt425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425827/index.html">Li√ß√£o do Google+: os projetos precisam garantir que os limites entre os interesses dos usu√°rios na vida real sejam respeitados on-line</a></li>
<li><a href="../pt425829/index.html">Como lutamos com Roskomnadzor e o que aconteceu</a></li>
<li><a href="../pt425831/index.html">Alerta RKN - banco de dados Roskomnadzor no seu navegador</a></li>
<li><a href="../pt425833/index.html">Uma ferramenta para ajud√°-lo a escolher as melhores ideias para o seu produto.</a></li>
<li><a href="../pt425835/index.html">‚ÄúBreaking Bugs‚Äù no Sberbank: como corrigir a taxa de sete dias de bugs por dia</a></li>
<li><a href="../pt425839/index.html">Revis√£o da Confer√™ncia Atlassian</a></li>
<li><a href="../pt425843/index.html">Python para a crian√ßa: escolhendo um tutorial</a></li>
<li><a href="../pt425845/index.html">Bloquear aplicativos automaticamente no Google Play</a></li>
<li><a href="../pt425847/index.html">Um exemplo de como usar o Microsoft Flow ou Como dar flores √† sua esposa</a></li>
<li><a href="../pt425849/index.html">Amazon desistiu e aumentou os sal√°rios dos funcion√°rios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>