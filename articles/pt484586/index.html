<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìà üõéÔ∏è üîö Trabalhar com IPv6 em PHP üèôÔ∏è üëèüèª üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, recebemos o status LIR e / 29 IPv6 block. E havia a necessidade de acompanhar as sub-redes designadas. E como nosso faturamento foi escr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabalhar com IPv6 em PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/484586/">  Recentemente, recebemos o status LIR e / 29 IPv6 block.  E havia a necessidade de acompanhar as sub-redes designadas.  E como nosso faturamento foi escrito em PHP, tive que me inspirar um pouco no problema e perceber que essa linguagem n√£o √© a mais amig√°vel em termos de trabalho com o IPv6.  Sob o corte - nossa solu√ß√£o para os problemas de trabalhar com endere√ßos e intervalos.  Talvez n√£o seja o mais elegante, mas executa as tarefas. <br><br><img src="https://habrastorage.org/webt/bk/on/p9/bkonp9-y-sxfdqvirte2ehjunr0.jpeg"><a name="habracut"></a><br><br><h3>  Pouco de teoria </h3><br><blockquote>  <b>Isen√ß√£o de responsabilidade.</b>  Se voc√™ estiver familiarizado com o que √© IPv6 e com√™-lo, essa parte pode ser chata para voc√™.  Pode n√£o ser. </blockquote><br>  As pessoas que v√™em a anota√ß√£o IPv6 pela primeira vez podem ficar desanimadas.  Ap√≥s o elegante <i>64.233.177.101, de</i> repente encontramos <i>2607: f8b0: 4002: c08 :: 8b</i> e podemos ficar confusos.  Tanto isso quanto outro - apenas representa√ß√£o leg√≠vel por humanos de 32 e 128 bits, respectivamente.  Qualquer pacote IP cont√©m um cabe√ßalho com uma atribui√ß√£o estritamente padronizada de cada bit.  Sem aprofundar ainda mais a estrutura dos cabe√ßalhos, precisamos tirar uma coisa daqui: para opera√ß√µes com endere√ßos IP e intervalos, geralmente √© conveniente usar opera√ß√µes bin√°rias de matem√°tica e bit a bit.  Tamb√©m √© mais conveniente armazen√°-los no banco de dados como <i>BINARY (4)</i> para IPv4 e <i>BINARY (16)</i> para IPv6. <br><br>  Outro aspecto importante que deve ser tratado s√£o as m√°scaras de rede e a nota√ß√£o CIDR.  CIDR √© um acr√¥nimo para Roteamento sem Dom√≠nio Classless.  Esse conceito substituiu a classe 1 na quest√£o de determinar qual parte do endere√ßo IP √© o prefixo da rede e qual parte √© o endere√ßo da interface de rede nessa rede.  Na pr√°tica, os primeiros n bits correspondentes ao prefixo ser√£o configurados para 1 e os demais para 0. <br><br>  Na forma leg√≠vel por humanos, isso √© escrito como <i>ip.add.re.ss. / cidr</i> .  Por exemplo, <i>64.233.177.0/24</i> significa que os primeiros 24 bits se referem ao prefixo.  Os √∫ltimos 8 bits, eles s√£o o √∫ltimo n√∫mero em uma entrada leg√≠vel por humanos, referem-se ao endere√ßo dentro da sub-rede.  Mais alguns exerc√≠cios.  <i>64.233.177.101/32</i> e <i>2607: f8b0: 4002: c08 :: 8b / 128</i> - um endere√ßo espec√≠fico.  <i>2607: f8b0: 4002: c08 :: / 64</i> - os primeiros 64 bits (os 4 primeiros grupos) - o prefixo, os 64 bits restantes - a parte local.  A prop√≥sito, se algu√©m ficar embara√ßado com o "::" na entrada, dois pontos e dois pontos substituir√£o um n√∫mero arbitr√°rio de se√ß√µes contendo 0. Ele pode ocorrer na anota√ß√£o apenas 1 vez.  Em outras palavras, <i>2607: f8b0: 4002: c08 :: 8b = 2607: f8b0: 4002: c08: 0: 0: 0: 8b</i> . <br><br>  O que precisamos aprender com tudo isso?  Primeiramente, o primeiro e o √∫ltimo endere√ßo de sub-rede podem ser obtidos usando AND e OR bin√°rios, conhecendo a m√°scara na forma bin√°ria.  Em segundo lugar, a pr√≥xima sub-rede de tamanho (isto √©, com CIDR) <b>n</b> pode ser calculada adicionando 1 √† <b>n-</b> √©sima posi√ß√£o na representa√ß√£o bin√°ria.  Por vis√£o bin√°ria, quero dizer o resultado do uso das fun√ß√µes <i>pack ()</i> e <i>inet_pton ()</i> e o uso adicional de <a href="https://www.php.net/manual/ru/language.operators.bitwise.php">operadores bit a bit</a> , por binary - uma representa√ß√£o no sistema bin√°rio, que pode ser obtida, digamos, usando <i>base_convert ()</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Antecedentes hist√≥ricos</b> <div class="spoiler_text"> A <s>segrega√ß√£o</s> sem classes <s>de</s> endere√ßamento precedeu a sem classe.  Naqueles anos distantes, ningu√©m esperava que houvesse tantas sub-redes; elas foram distribu√≠das √† direita e √† esquerda em grandes blocos: classe A - os primeiros 8 bits (ou seja, o primeiro n√∫mero) foram prefixados, com o bit inicial 0;  classe B - os 16 primeiros (dois primeiros n√∫meros), os bits iniciais de 10;  classe C - os primeiros 24 bits, os bits iniciais de 110. Esses mesmos bits <i>iniciais</i> definem os intervalos nos quais o endere√ßo de uma classe foi emitido: <i>0.0.0.0 - 127.255.255.255</i> para a classe A, <i>128.0.0.0 - 191.255.255.255</i> - classe B, 192.0 .0.0 - 223.255.255.255 - classe C. √Ä medida que a Internet se espalhava por todo o planeta, os reguladores perceberam que estavam errados e, no in√≠cio dos anos 90, desenvolveram um conceito sem classe, que lhes permitia n√£o se apegar aos bits principais.  Um pouco mais de detalhes podem ser encontrados, digamos, no <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">grande e onisciente</a> . </div></div><br><br><h3>  Vamos seguir praticando </h3><br>  Na pr√°tica, implementamos as tr√™s tarefas mais prov√°veis, como me pareceu: <br><br><ol><li>  obtendo o primeiro e o √∫ltimo endere√ßo do intervalo; </li><li>  obter o pr√≥ximo intervalo de um determinado tamanho (CIDR); </li><li>  verificando se o endere√ßo pertence a um intervalo. </li></ol><br>  A implementa√ß√£o ser√° para IPv6, mas se necess√°rio, a l√≥gica pode ser facilmente adaptada.  Eu tenho algumas id√©ias <a href="https://intsystem.org/coding/kak-rabotat-s-ipv6-v-php/">daqui</a> , mas implementei um pouco diferente.  Tamb√©m nos exemplos, n√£o h√° verifica√ß√£o de erros de entrada.  Ent√£o vamos l√°. <br><br>  Como j√° mencionei, o primeiro e o √∫ltimo endere√ßo de um intervalo podem ser determinados usando opera√ß√µes bit a bit, conhecendo o in√≠cio do intervalo e a m√°scara de sub-rede bin√°ria.  Portanto, a primeira coisa que precisamos fazer √© transformar o CIDR em uma m√°scara bin√°ria.  Para fazer isso, colete sua representa√ß√£o hexadecimal e empacote-a em bin√°rio. <br><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cidrToMask</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cidr)</span></span></span><span class="hljs-function"> </span></span>{ $mask = str_repeat(<span class="hljs-string"><span class="hljs-string">'f'</span></span>, ceil($cidr / <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask .= dechex(<span class="hljs-number"><span class="hljs-number">4</span></span> * ($cidr % <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask = str_pad($mask, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $mask); }</code> </pre> <br>  O <i>pacote de</i> chamadas <i>('H *', $ mask)</i> compacta a representa√ß√£o hexadecimal da mesma maneira que <i>inet_pton ()</i> .  A √∫nica diferen√ßa √© que, quando voc√™ chama <i>pack (),</i> todos os 0 devem estar no lugar e n√£o deve haver dois pontos na entrada, em contraste com a entrada leg√≠vel por humanos. <br><br>  O pr√≥ximo passo √© calcular o in√≠cio e o fim do intervalo.  E aqui h√° nuances.  As opera√ß√µes bit a bit s√£o limitadas pela capacidade do processador.  Assim, no meu CubieTruck de 32 bits, que √†s vezes uso para qualquer mimo de teste, todos os 128 bits do endere√ßo n√£o podem ser processados ‚Äã‚Äãem uma opera√ß√£o.  No entanto, nada nos impede de dividi-lo em grupos de 32 bits (por precau√ß√£o, quem sabe em quais processadores estaremos rodando). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeBoundary</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $cidr, $which, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ $mask = cidrToMask($cidr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ip = inet_pton($ip); } $ipParts = str_split($ip, <span class="hljs-number"><span class="hljs-number">4</span></span>); $maskParts = str_split($mask, <span class="hljs-number"><span class="hljs-number">4</span></span>); $rangeParts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; count($ipParts); $i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($which == <span class="hljs-string"><span class="hljs-string">'start'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  &amp;       . */</span></span> $rangeParts[$i] = $ipParts[$i] &amp; $maskParts[$i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*  |    (~)           1. */</span></span> $rangeParts[$i] = $ipParts[$i] | ~$maskParts[$i]; } } $rangeBoundary = implode($rangeParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rangeBoundary; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($rangeBoundary); } }</code> </pre> <br>  Para uso futuro, forneceremos a capacidade de transmitir IP e obter o resultado tanto na forma bin√°ria quanto na leg√≠vel por humanos.  O par√¢metro <i>$ which</i> aqui define se queremos obter o in√≠cio ou o fim do intervalo (os valores s√£o <i>'start'</i> ou <i>'end',</i> respectivamente). <br><br>  A pr√≥xima tarefa (al√©m da mais pr√°tica para a nossa empresa) √© calcular o pr√≥ximo intervalo.  Para esta tarefa, nada melhor veio √† mente, exceto como decompor o endere√ßo em uma cadeia bin√°ria e adicionar 1 na posi√ß√£o desejada, e recolher tudo de volta.  Para impedir que artefatos apare√ßam em qualquer lugar, decidi dividir o endere√ßo por byte durante a decomposi√ß√£o e montagem. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ipStart, $cidr, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ipStart = inet_pton($ipStart); } $ipParts = str_split($ipStart, <span class="hljs-number"><span class="hljs-number">1</span></span>); $ipBin = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $ipPart) { $ipBin .= str_pad(base_convert(unpack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $ipPart)[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT); } <span class="hljs-comment"><span class="hljs-comment">/*  1       "" :) */</span></span> $i = $cidr - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($ipBin[$i] == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'0'</span></span>; } $i--; } $ipBinParts = str_split($ipBin, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipBinParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $ipBinPart) { $ipParts[$key] = pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, str_pad(base_convert($ipBinPart, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT)); } $nextIp = implode($ipParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $nextIp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($nextIp); } }</code> </pre> <br>  Na sa√≠da, obtemos o prefixo do pr√≥ximo intervalo de tamanho especificado em <i>$ cidr</i> .  Com essa fun√ß√£o, alocamos blocos de endere√ßos para nossos clientes. <br><br>  Por fim, verifique se o endere√ßo pertence ao intervalo.  Por exemplo, alocamos um bloco / 48 para distribui√ß√£o de / 64 blocos aos clientes e precisamos garantir que, durante o compromisso, n√£o excedamos o bloco alocado (na pr√°tica, isso acontecer√° em breve, mas ainda h√° uma chance).  Tudo √© simples aqui.  Obtemos o in√≠cio e o fim do intervalo em formato bin√°rio e verificamos se o endere√ßo est√° dentro. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ipInRange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $rangeStart, $cidr)</span></span></span><span class="hljs-function"> </span></span>{ $start = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'start'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $end = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'end'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $ipBin = inet_pton($ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($ipBin &gt;= $start &amp;&amp; $ipBin &lt;= $end); }</code> </pre> <br>  Espero que tenha sido √∫til.  Quais outros recursos de endere√ßamento voc√™ pode achar √∫teis?  Quaisquer adi√ß√µes, coment√°rios e revis√µes de c√≥digo s√£o muito bem vindos nos coment√°rios. <br><br>  Se voc√™ j√° √© nosso cliente ou est√° apenas pensando em se tornar um, por ocasi√£o do lan√ßamento deste artigo, sugerimos que voc√™ obtenha o bloco / 64 gratuitamente para todos os servi√ßos vps ou um servidor dedicado no data center Equinix Tier IV, na Holanda, mediante solicita√ß√£o ao departamento de vendas, fornecendo um link para este artigo no ticket.  A oferta √© v√°lida at√© mar√ßo de 2020. <br><br><h3>  Um pouco de publicidade :) </h3><br>  Obrigado por ficar conosco.  Voc√™ gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando aos seus amigos <a href="https://ua-hosting.company/cloudvps/nl">VPS baseado em nuvem para desenvolvedores a partir de US $ 4,99</a> , um <b>anal√≥gico exclusivo de servidores</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">b√°sicos</a> <b>que foi inventado por n√≥s para voc√™:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">Toda a verdade sobre o VPS (KVM) E5-2697 v3 (6 n√∫cleos) 10GB DDR4 480GB SSD 1Gbps de 10GB de US $ 19 ou como dividir o servidor?</a>  (as op√ß√µes est√£o dispon√≠veis com RAID1 e RAID10, at√© 24 n√∫cleos e at√© 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato no data center Equinix Tier IV em Amsterd√£?</b>  Somente temos <b><a href="https://ua-hosting.company/serversnl">2 TVs Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV a partir de US $ 199</a> na Holanda!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - a partir de US $ 99!</b></b>  Leia sobre <a href="https://habr.com/company/ua-hosting/blog/329618/">Como criar um pr√©dio de infraestrutura.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484586/">https://habr.com/ru/post/pt484586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484574/index.html">Sem carrapatos! Vetor de plantas versus doen√ßa de Lyme</a></li>
<li><a href="../pt484578/index.html">Objetivos do n√≠vel de servi√ßo - Experi√™ncia do Google (tradu√ß√£o do cap√≠tulo do livro do Google SRE)</a></li>
<li><a href="../pt484580/index.html">O que voc√™ precisa saber sobre simuladores de mem√≥ria</a></li>
<li><a href="../pt484582/index.html">ASP.NET MVC - Entity Framework, MySQL e usando o Dependency Resolver para selecionar um reposit√≥rio</a></li>
<li><a href="../pt484584/index.html">Por que precisamos de um gerente em um projeto de TI e o que acontecer√° quando n√£o for</a></li>
<li><a href="../pt484588/index.html">Modelo de gerenciamento automatizado de programas</a></li>
<li><a href="../pt484590/index.html">Para que os meninos n√£o tivessem vergonha de mostrar</a></li>
<li><a href="../pt484592/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 398 (13 a 19 de janeiro de 2020)</a></li>
<li><a href="../pt484596/index.html">Loja on-line do lado do cliente Blazor: Parte 1 - Autoriza√ß√£o oidc (oauth2) + Identity Server4</a></li>
<li><a href="../pt484600/index.html">Microsoft Ignite The Tour Confer√™ncia T√©cnica de Praga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>