<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¹ğŸ¼ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ•µğŸ¿ Pipa & Filter. Contoh aplikasi dan implementasi menggunakan Spring ğŸ§‘ğŸ¾ ğŸ¥— ğŸ’“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan membahas penggunaan pola Pipa & Filter. 


 Pertama, kita akan menganalisis contoh fungsi, yang akan kita tulis ulang nanti menggunak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pipa & Filter. Contoh aplikasi dan implementasi menggunakan Spring</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479464/"><p>  Artikel ini akan membahas penggunaan pola Pipa &amp; Filter. </p><br><p>  Pertama, kita akan menganalisis contoh fungsi, yang akan kita tulis ulang nanti menggunakan pola yang disebutkan di atas.  Perubahan kode akan terjadi secara bertahap dan setiap kali kita akan membuat versi yang bisa diterapkan sampai kita memikirkan solusi menggunakan DI (dalam contoh Musim Semi ini). </p><br><p>  Dengan demikian, kami akan membuat beberapa solusi, memberikan peluang untuk menggunakan apa saja. <br>  Pada akhirnya, kami membandingkan implementasi awal dan akhir, melihat contoh aplikasi dalam proyek nyata dan merangkumnya. </p><a name="habracut"></a><br><h2 id="zadacha">  Tantangan </h2><br><p>  Misalkan kita memiliki banyak pakaian yang kita dapatkan dari pengeringan dan yang sekarang kita perlu pindah ke lemari.  Ternyata data (pakaian) berasal dari layanan terpisah dan tugasnya adalah memberikan data ini kepada klien dalam bentuk yang benar (di lemari tempat ia bisa mendapatkan pakaian). </p><br><p>  Dalam kebanyakan kasus, Anda tidak dapat menggunakan data yang diterima dalam bentuk yang diterima oleh kami.  Data ini perlu diperiksa, diubah, disortir, dll. <br>  Misalkan pelanggan menuntut pakaian yang harus disetrika jika mereka mint. </p><br><p> Kemudian untuk pertama kalinya kami membuat <code>Modifier</code> , di mana kami meresepkan perubahan: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { <span class="hljs-comment"><span class="hljs-comment">// }); } }</span></span></code> </pre> <br><p>  Pada tahap ini, semuanya sederhana dan jelas.  Mari kita menulis tes yang memeriksa bahwa semua pakaian yang kusut telah disetrika. </p><br><p>  Namun seiring waktu, persyaratan baru muncul dan setiap kali fungsi kelas <code>Modifier</code> meluas: </p><br><ul><li>  Jangan menaruh cucian kotor di lemari. </li><li>  Kemeja, jaket dan celana panjang harus digantung di bahu. </li><li>  Kaus kaki bocor harus dijahit terlebih dahulu </li><li>  ... </li></ul><br><p>  Urutan perubahan juga penting.  Misalnya, Anda tidak bisa menggantungkan pakaian terlebih dahulu di bahu mereka, lalu menyeterika. </p><br><p>  Jadi, pada titik tertentu, <code>Modifier</code> dapat mengambil bentuk berikut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ (); (); (); (); <span class="hljs-comment"><span class="hljs-comment">//   return ; } private void (List&lt;&gt; ) { .stream() .filter(.class::isInstance) .map(.class::cast) .filter(::) .forEach(o -&gt; { // }); } private void (List&lt;&gt; ) { .stream() .filter(___) .forEach(o -&gt; { //   }); } private void (List&lt;&gt; ) { .removeIf(::); } private void (List&lt;&gt; ) { .stream() .filter(::) .forEach(o -&gt; { // }); } //  }</span></span></code> </pre> <br><p>  Sejalan dengan itu, tes menjadi lebih rumit, yang sekarang setidaknya harus memeriksa setiap langkah secara individual. </p><br><p>  Dan ketika persyaratan baru tiba, melihat kode, kami memutuskan bahwa saatnya telah tiba untuk Refactoring. </p><br><h2 id="refactoring">  Refactoring </h2><br><p>  Hal pertama yang menarik perhatian Anda adalah seringnya penghancuran semua pakaian.  Jadi langkah pertama, kami memindahkan semuanya dalam satu siklus, dan juga mentransfer pemeriksaan kebersihan ke awal siklus: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;&gt; ___ = ((Predicate&lt;&gt;).class::isInstance) .or(.class::isInstance) .or(.class::isInstance) ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   } return result; } private void ( ) { if( instanceof ){ // ()  } } private void ( ) { if(___.test()){ //   } } private void ( ) { if(.()){ // } } //  }</span></span></code> </pre> <br><p>  Sekarang, waktu pemrosesan untuk pakaian berkurang, tetapi kode ini masih terlalu lama untuk satu kelas dan untuk siklus tubuh.  Mari kita coba memperpendek tubuh siklus pertama. </p><br><ul><li><p>  Setelah memeriksa kebersihan, Anda dapat melakukan semua panggilan dengan metode <code>modify( )</code> terpisah <code>modify( )</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ){ List&lt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o : ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(o.()){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } result.add(o); modify(o); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( o)</span></span></span><span class="hljs-function"> </span></span>{ (o); (o); (o); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br></li><li><p>  Anda dapat menggabungkan semua panggilan menjadi satu <code>Consumer</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;&gt; modification = ((Consumer&lt;&gt;) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::) .andThen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::); <span class="hljs-comment"><span class="hljs-comment">//   public List&lt;&gt; modify(List&lt;&gt; ){ return .stream() .filter(o -&gt; !o.()) .peek(modification) .collect(Collectors.toList()); }</span></span></code> </pre> <br><blockquote>  Blunt: mengintip <br>  Saya menggunakan mengintip singkatnya.  Sonar akan mengatakan bahwa kode seperti itu tidak boleh dilakukan, karena  Javadoc memberitahu mengintip bahwa metode ini ada terutama untuk debug.  Tetapi jika Anda menulis ulang di peta: .map (o -&gt; {modifikasi.accept (o); return o;}), maka IDEA akan mengatakan bahwa lebih baik menggunakan mengintip </blockquote><br></li></ul><br><blockquote>  Gagap: Konsumen <br>  Contoh dengan Konsumen (dan selanjutnya dengan Fungsi) diberikan untuk menunjukkan kemampuan bahasa. </blockquote><p>  Sekarang tubuh siklus menjadi lebih pendek, tetapi sejauh ini kelas itu sendiri masih terlalu besar dan mengandung terlalu banyak informasi (pengetahuan tentang semua langkah). </p><br><p>  Mari kita coba selesaikan masalah ini menggunakan pola pemrograman yang sudah ada.  Dalam hal ini, kami akan menggunakan <code>Pipes &amp; Filters</code> . </p><br><h2 id="pipes--filters">  Pipa &amp; filter </h2><br><p>  <a href="https://docs.microsoft.com/ru-ru/azure/architecture/patterns/pipes-and-filters">Templat saluran dan filter</a> <a href="https://medium.com/nuances-of-programming/%25D0%25BA%25D1%2580%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B8%25D0%25B9-%25D0%25BE%25D0%25B1%25D0%25B7%25D0%25BE%25D1%2580-10-%25D0%25BF%25D0%25BE%25D0%25BF%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D1%258B%25D1%2585-%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-81647be5c46f">menjelaskan pendekatan</a> di mana data yang masuk melewati beberapa langkah pemrosesan. </p><br><p>  Mari kita coba menerapkan pendekatan ini ke kode kita. </p><br><h3 id="shag-1">  Langkah 1 </h3><br><p>  Sebenarnya, kode kami sudah dekat dengan pola ini.  Data yang diperoleh melalui beberapa langkah independen.  Sejauh ini, setiap metode adalah filter, dan <code>modify</code> sendiri menggambarkan saluran, pertama-tama menyaring semua pakaian kotor. </p><br><p>  Sekarang kita akan mentransfer setiap langkah ke kelas yang terpisah dan melihat apa yang kita dapatkan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span>  ; <span class="hljs-comment"><span class="hljs-comment">//  public Modifier( ,  ,   //  ) { this. = ; this. = ; this. = ; //  } public List&lt;&gt; modify(List&lt;&gt; ) { return .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { .(o); .(o); .(o); //  }) .collect(Collectors.toList()); } }</span></span></code> </pre> <br><p>  Dengan demikian, kami menempatkan kode dalam kelas yang terpisah, menyederhanakan tes untuk transformasi individu (dan menciptakan kemungkinan menggunakan kembali langkah-langkah).  Urutan panggilan menentukan urutan langkah-langkah. </p><br><p>  Tetapi kelas itu sendiri masih tahu semua langkah individu, mengontrol urutan dan dengan demikian memiliki daftar besar dependensi.  Selain menambahkan langkah baru, kami akan dipaksa untuk tidak hanya menulis kelas baru, tetapi juga menambahkannya ke <code>Modfier</code> . </p><br><h3 id="shag-2">  Langkah 2 </h3><br><p>  Sederhanakan kode menggunakan Spring. <br>  Pertama, buat antarmuka untuk setiap langkah: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; }</code> </pre><br><p>  <code>Modifier</code> itu sendiri sekarang akan jauh lebih pendek: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modifier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Modification&gt; steps; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Modifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Modification&gt; steps)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.steps = steps; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .filter(o -&gt; !o.()) .peek(o -&gt; { steps.forEach(m -&gt; m.modify(o)); }) .collect(Collectors.toList()); } }</code> </pre> <br><p>  Sekarang, untuk menambahkan langkah baru, Anda hanya perlu menulis kelas baru yang mengimplementasikan antarmuka <code>Modification</code> dan meletakkan <code>@Component</code> di atasnya.  Spring akan menemukannya dan menambahkannya ke daftar. </p><br><p>  <code>Modifer</code> sendiri tidak tahu apa-apa tentang langkah-langkah individu, yang menciptakan "koneksi lemah" antara komponen. </p><br><p>  Satu-satunya kesulitan adalah mengatur urutan.  Untuk melakukan ini, Spring memiliki anotasi <code>@Order</code> yang Anda bisa berikan nilai int.  Daftar ini diurutkan dalam urutan menaik. <br>  Dengan demikian, mungkin terjadi bahwa dengan menambahkan langkah baru di tengah daftar, Anda harus mengubah nilai pengurutan untuk langkah-langkah yang ada. </p><br><blockquote>  Pegas bisa dikeluarkan jika semua implementasi yang diketahui secara manual diteruskan ke konstruktor Modifier.  Ini akan membantu menyelesaikan masalah penyortiran, tetapi sekali lagi menyulitkan penambahan langkah baru. </blockquote><br><h3 id="shag-3">  Langkah 3 </h3><br><p>  Sekarang kami lulus ujian kebersihan di langkah terpisah.  Untuk melakukan ini, kami menulis ulang antarmuka kami sehingga selalu memberikan nilai: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); }</code> </pre> <br><p>  Periksa kebersihan: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@Order</span></span>(Ordered.HIGHEST_PRECEDENCE) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CleanFilter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(.()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ; } }</code> </pre> <br><p>  <code>Modifier.modify</code> : </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;&gt; modify(List&lt;&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .stream() .map(o -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modified = o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step : steps){ modified = step.modify(o); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(modified == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; }) .filter(Objects::nonNull) .collect(Collectors.toList()); }</code> </pre> <br><p>  Dalam versi ini, <code>Modifier</code> tidak memiliki informasi data apa pun.  Dia hanya meneruskannya ke setiap langkah yang diketahui dan mengumpulkan hasilnya. </p><br><p>  Jika salah satu langkah mengembalikan nol, maka pemrosesan untuk garmen ini terganggu. </p><br><p>  Prinsip serupa digunakan dalam Spring for HandlerInterceptors.  Sebelum dan sesudah panggilan pengontrol, semua Interceptor yang sesuai untuk URL ini dipanggil.  Pada saat yang sama, ia mengembalikan benar atau salah dalam metode preHandle untuk menunjukkan apakah memproses dan memanggil Interceptor berikutnya dapat melanjutkan </p><br><h3 id="shag-n">  Langkah n </h3><br><p>  Langkah selanjutnya adalah menambahkan metode <code>matches</code> ke antarmuka <code>Modification</code> , di mana langkah-langkah untuk atribut yang terpisah dari pakaian diperiksa: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Modification</span></span></span><span class="hljs-class"> </span></span>{  modify( ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;} }</code> </pre> <br><p>  Karena ini, Anda dapat sedikit menyederhanakan logika dalam <code>modify</code> metode dengan memindahkan pemeriksaan untuk kelas dan properti ke metode yang terpisah. </p><br><p>  Pendekatan serupa digunakan dalam Filter Pegas (Permintaan), tetapi perbedaan utama adalah bahwa setiap Filter adalah pembungkus berikutnya dan secara eksplisit memanggil FilterChain.doFilter untuk melanjutkan pemrosesan. </p><br><h2 id="itogo">  Total </h2><br><p>  Hasil akhirnya sangat berbeda dari versi awal.  Membandingkannya, kita bisa menarik kesimpulan berikut: </p><br><ul><li>  Implementasi berdasarkan Pipes &amp; Filter menyederhanakan kelas <code>Modifier</code> itu sendiri. </li><li>  Tanggung jawab yang didistribusikan dengan lebih baik dan koneksi â€œlemahâ€ antara komponen. </li><li>  Lebih mudah untuk menguji langkah-langkah individual. </li><li>  Lebih mudah untuk menambah dan menghapus langkah. </li><li>  Agak sulit untuk menguji seluruh rangkaian filter.  Kami sudah membutuhkan IntegrationTests. </li><li>  Lebih banyak kelas </li></ul><br><p>  Pada akhirnya, opsi yang lebih nyaman dan fleksibel daripada yang asli. </p><br><p>  Selain itu, Anda dapat memparalelkan pemrosesan data menggunakan parallelStream yang sama. </p><br><h3 id="chto-ne-reshaet-dannyy-primer">  Apa contoh ini tidak terpecahkan </h3><br><ol><li>  Deskripsi pola mengatakan bahwa filter individual dapat digunakan kembali dengan membuat rantai filter lain (saluran). <br><ul><li>  Di satu sisi, ini mudah dilakukan menggunakan <code>@Qualifier</code> . </li><li>  Di sisi lain, pengaturan urutan berbeda dengan <code>@Order</code> akan gagal. </li></ul></li><li>  Untuk contoh yang lebih kompleks, Anda harus menggunakan beberapa rantai, menggunakan rantai bersarang, dan masih mengubah implementasi yang ada. <br><ul><li>  Jadi misalnya, tugas: "untuk setiap kaus kaki, cari sepasang dan masukkan ke dalam satu contoh &lt;? Extends Clothing&gt;" tidak akan cocok dengan implementasi yang dijelaskan, karena  Sekarang, untuk setiap jari kaki, Anda harus memilah-milah semua linen dan mengubah daftar data awal. </li><li>  Untuk mengatasinya, Anda dapat menulis antarmuka baru yang menerima dan mengembalikan Daftar &lt;Clothing&gt; dan mentransfernya ke rantai baru.  Tetapi Anda perlu berhati-hati dengan urutan panggilan rantai itu sendiri, jika kaus kaki hanya dapat dijahit oleh hotel. </li></ul></li></ol><br><h2 id="spasibo-za-vnimanie">  Terima kasih atas perhatian anda </h2></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479464/">https://habr.com/ru/post/id479464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479450/index.html">AppCode 2019.3: bekerja lebih cepat, memahami Swift lebih baik, tahu tentang Mac Catalyst, dengan mudah menampilkan pesan perakitan</a></li>
<li><a href="../id479452/index.html">Bagaimana Sistem Nama Domain Dikembangkan: Era ARPANET</a></li>
<li><a href="../id479458/index.html">Keindahan atau kepraktisan di ruang server</a></li>
<li><a href="../id479460/index.html">Panduan untuk Mobil Terbang</a></li>
<li><a href="../id479462/index.html">Serialisasi dalam C ++</a></li>
<li><a href="../id479466/index.html">Habraiting 2019: statistik dan peringkat artikel terbaik untuk 2019</a></li>
<li><a href="../id479468/index.html">Edge of Honesty dan John Doe</a></li>
<li><a href="../id479474/index.html">Mengapa self-organisasi tim sangat penting dalam Scrum dan mengapa tidak ada manajer di dalamnya</a></li>
<li><a href="../id479478/index.html">Plug-in Java tanpa rasa sakit</a></li>
<li><a href="../id479480/index.html">SARIF SDK dan Kesalahannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>