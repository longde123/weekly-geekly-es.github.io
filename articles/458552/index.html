<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÖ üë¨ üíÇüèº Acerca de comparar formatos de almacenamiento en Hadoop: comencemos con ORC üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üñäÔ∏è üéº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hadoop incluye productos que pueden trabajar con archivos de varios formatos. He buscado, le√≠do y pensado en repetidas ocasiones qu√© formato es mejor....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acerca de comparar formatos de almacenamiento en Hadoop: comencemos con ORC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/458552/"><p>  Hadoop incluye productos que pueden trabajar con archivos de varios formatos.  He buscado, le√≠do y pensado en repetidas ocasiones qu√© formato es mejor.  Cuando me encontr√© con el formato ORC de manera relativamente aleatoria, me interes√©, le√≠ (e incluso un poco codificado), y eso es lo que entend√≠: es incorrecto comparar formatos como tales.  M√°s precisamente, generalmente se comparan, en mi opini√≥n, de manera incorrecta.  En realidad, un art√≠culo sobre esto, as√≠ como sobre el formato ORC de Apache (en t√©rminos t√©cnicos) y las oportunidades que ofrece. </p><br><p>  Comenzar√© con la pregunta: ¬øcu√°l puede ser el tama√±o de una tabla relacional (en bytes y muy aproximadamente), que consta de 10 mil filas (dos campos enteros por fila)?  Por lo general, ponen un kat aqu√≠, y la respuesta se coloca debajo del kat: responder√© aqu√≠: 628 bytes.  Y los detalles y la historia se transferir√°n bajo cat. </p><a name="habracut"></a><br><p>  C√≥mo comenz√≥ todo: constru√≠ una biblioteca para trabajar con Apache ORC (consulte la p√°gina de inicio del proyecto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://orc.apache.org</a> ) y compil√© su propio ejemplo sobre c√≥mo escribir en ORC (para romper la cabeza, comenzamos con lo que funciona) , ten√≠a 2 campos y 10 mil l√≠neas.  Lo comenc√©, recib√≠ el archivo orco porque lo hice en alg√∫n lugar fuera de la oficina, por si acaso, reescrib√≠ la biblioteca y el archivo en una unidad flash (a toda prisa, no mir√© el tama√±o, creo que la unidad flash puede manejarlo). </p><br><p>  Pero de alguna manera respond√≠ r√°pidamente ... Mir√© el tama√±o: 628 bytes.  Pens√© que era un error, me sent√© y comenc√© a entender.  Lanc√© la utilidad para ver ORC desde la misma biblioteca compilada: el contenido del archivo muestra que todo es honesto: 10 mil l√≠neas.  Despu√©s de eso, me pregunt√© c√≥mo cab√≠an 10 mil l√≠neas en 628 bytes (ya sab√≠a un poco sobre ORC en ese momento y me di cuenta de que tambi√©n hab√≠a metadatos: el formato era autosuficiente).  Entendido, compartir. </p><br><h2 id="o-formate-orc">  Sobre el formato ORC </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/85d/d6c/e83/85dd6ce839b506e8033b3a6683c0c58c.png" alt="imagen"></p><br><p> No repetir√© aqu√≠ palabras generales sobre el formato: vea el enlace de arriba, est√° bien escrito all√≠.  Me centrar√© en dos adjetivos en excelente forma de la imagen de arriba (la imagen est√° tomada de la p√°gina de inicio del proyecto): tratemos de descubrir por qu√© ORC es "el m√°s r√°pido" y "el m√°s compacto". </p><br><h1 id="skorost">  Velocidad </h1><br><p>  La velocidad puede ser diferente con respecto a los datos, al menos la velocidad de lectura o escritura (puede profundizar m√°s, pero deteng√°monos por ahora).  Dado que Hadoop se menciona expl√≠citamente en el eslogan anterior, consideraremos principalmente la velocidad de lectura. </p><br><p>  Para citar un poco m√°s de la documentaci√≥n de ORC: </p><br><blockquote>  Est√° optimizado para grandes lecturas de transmisi√≥n, pero con soporte integrado para encontrar filas requeridas r√°pidamente.  El almacenamiento de datos en formato de columnas permite al lector leer, descomprimir y procesar solo los valores necesarios para la consulta actual. </blockquote><p>  Voy a traducir un poco: </p><br><ul><li>  formato optimizado para transmisi√≥n de lectura de grandes vol√∫menes </li><li>  al mismo tiempo contiene soporte para b√∫squeda r√°pida de l√≠neas necesarias </li><li>  le permite leer solo los datos que necesita </li></ul><br><h1 id="razmer">  Tama√±o </h1><br><p>  No hubo cita, dir√© en mis propias palabras </p><br><ul><li>  formato almacena de manera √≥ptima la metainformaci√≥n </li><li>  lograr un equilibrio entre la velocidad de lectura de transmisi√≥n y el almacenamiento compacto </li><li>  soporte integrado para el almacenamiento m√°s compacto de valores de columna </li></ul><br><h2 id="predostavlenie-vozmozhnostey">  Brindando oportunidades </h2><br><p>  Quiero llamar su atenci√≥n sobre la redacci√≥n de las citas anteriores: "optimizado para ...", "contiene soporte ...", "le permite leer ..." - el formato de archivo, como lenguaje de programaci√≥n, es un medio (en este caso, asegurar almacenamiento eficiente y acceso a datos).  El hecho de que el almacenamiento y el acceso a los datos sea realmente efectivo depende no solo de la herramienta, sino tambi√©n de qui√©n la usa y c√≥mo. </p><br><p>  Veamos qu√© formato proporciona el formato para velocidad y compacidad. </p><br><h1 id="kolonchatoe-hranenie-i-straypy">  Almacenamiento de columna y franja </h1><br><p>  Los datos en el ORC se almacenan en forma de columnas, en primer lugar, afecta el tama√±o.  Para garantizar la velocidad de la lectura de transmisi√≥n, el archivo se divide en las llamadas "franjas", cada franja es autosuficiente, es decir  se puede leer por separado (y, por lo tanto, en paralelo).  Debido a las tiras, el tama√±o del archivo aumentar√° (los valores de columna no √∫nicos se almacenar√°n varias veces, en esas tiras donde se producen dichos valores), el mismo equilibrio de "velocidad - tama√±o" (es un compromiso). </p><br><h1 id="indeksy">  √çndices </h1><br><p>  El formato ORC implica √≠ndices que le permiten determinar si la banda (o m√°s bien, las partes de banda de 10 mil filas cada una, el llamado "grupo de filas") contiene los datos que est√° buscando o no.  Los √≠ndices se construyen en cada una de las columnas.  Esto afecta la velocidad de lectura, aumentando el tama√±o.  Al transmitir √≠ndices de lectura, por cierto, no puede leer. </p><br><h1 id="szhatie">  Compresi√≥n </h1><br><p>  Todos los metadatos se almacenan en forma comprimida, y esto </p><br><ul><li>  informaci√≥n estad√≠stica y descriptiva (el formato le permite recrear la tabla que est√° almacenada en √©l, incluidos los nombres y tipos de campos) </li><li>  √≠ndices </li><li>  partici√≥n de informaci√≥n (en bandas y secuencias) </li></ul><br><p>  (a continuaci√≥n veremos que los metadatos son una parte esencial del archivo) </p><br><p>  Los valores de columna tambi√©n se almacenan en forma comprimida.  Al mismo tiempo, es posible leer y desempaquetar solo el bloque de datos que se necesita (es decir, no se comprime un archivo ni una tira completa).  La compresi√≥n afecta tanto el tama√±o como la velocidad de lectura. </p><br><h1 id="kodirovanie">  Codificaci√≥n </h1><br><p>  Los valores de la columna, y el archivo almacena exactamente estos valores, se almacenan en forma codificada.  En la versi√≥n actual del formato (ORC v1) para enteros, por ejemplo, hay 4 opciones de codificaci√≥n disponibles.  Al mismo tiempo, no se codifica toda la columna, se codifican partes de la columna, cada parte se puede codificar de manera √≥ptima para esta parte (dichas partes se denominan "ejecuci√≥n" en la especificaci√≥n).  Por lo tanto, se logra la minimizaci√≥n de la longitud total de los datos almacenados.  De nuevo, el efecto sobre el tama√±o y la velocidad. </p><br><h2 id="posmotrim-orc-fayl">  Veamos el archivo ORC </h2><br><p>  Veamos brevemente lo que hay dentro del archivo ORC (el que tiene 628 bytes).  Para aquellos que no est√°n muy interesados ‚Äã‚Äãen los detalles t√©cnicos, despl√°cese hacia abajo a la siguiente secci√≥n (sobre comparaci√≥n de formatos). </p><br><p>  As√≠ es como se defini√≥ nuestra tabla en el registro de ejemplo en ORC: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af7/bb2/a01/af7bb2a019f050cbc47ec9e2c8152a2b.png" alt="imagen"></p><br><h1 id="metadannye">  Metadatos </h1><br><p>  Informaci√≥n sobre las longitudes (doy capturas de pantalla del cuaderno jupyter, creo que es lo suficientemente claro) </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d3e/e1f/398/d3ee1f39809cccf7fc9523df72bb2def.png" alt="imagen"></p><br><p>  Lo que vemos aqu√≠: </p><br><ul><li>  en el "v√°stago" (y esto es PostScript + Pie de p√°gina + Metadatos) solo 1 + 23 + 115 + 50 = 189 bytes </li><li>  en una sola banda, solo 3 + 436 = 439 bytes, total 628 bytes </li><li>  la tira contiene un √≠ndice (73 bytes), datos (276 bytes), pie de p√°gina (87 bytes) </li></ul><br><p>  Prestemos atenci√≥n aqu√≠ a la relaci√≥n de volumen de datos y metadatos (276 a 352 bytes).  Pero estos 276 bytes de datos no son solo datos, los datos contienen un poco de "superfluo" (aqu√≠ por brevedad no doy capturas de pantalla; es mucho tiempo con ellos, lo gestionar√© solo con mis comentarios), que est√° incluido en los datos: </p><br><ul><li>  PRESENTES flujos para cada columna, hay tres de ellos (incluida una estructura de pseudocolumna com√∫n): 20 bytes por cada uno, un total de 60 bytes </li><li>  flujos de datos (aqu√≠ la pseudocolumna no est√° representada) - 103 y 113 bytes (columnas "x" e "y", respectivamente) </li></ul><br><p>  Las corrientes PRESENTES son cadenas de bits que le permiten saber d√≥nde est√°n las columnas NULL.  Para nuestro ejemplo, su presencia parece extra√±a (en las estad√≠sticas de nuestro archivo est√° claramente escrito que no hay NULL en los datos, ¬øpor qu√© entonces incluir PRESENT? Parece una falla ...) </p><br><p>  En total, los datos en s√≠ ocupan 216 bytes, metadatos - 352. </p><br><p>  Tambi√©n se puede ver en los metadatos que ambas columnas est√°n codificadas usando el m√©todo DIRECT_V2 (para enteros, permite 4 tipos de representaciones, para detalles me refiero a la especificaci√≥n, est√° en el sitio web del proyecto). </p><br><h1 id="dannye">  Datos </h1><br><p>  Veamos (nuevamente sin capturas de pantalla por brevedad) c√≥mo caben 10 mil n√∫meros en 103 bytes (para la columna "x"): </p><br><ul><li>  Se utiliza la codificaci√≥n delta, en la que los par√°metros son el valor inicial y el paso (un poco simplificado por brevedad) </li><li>  siempre tenemos 1 paso, el valor inicial para la primera ejecuci√≥n es 0, luego 511, 1022, etc. </li><li>  run (un conjunto de datos codificados de una sola manera) en nuestro caso contiene 511 valores (el valor m√°ximo posible para la codificaci√≥n delta) </li><li>  la longitud de cada ejecuci√≥n en el archivo es de 4 a 6 bytes (la longitud de la ejecuci√≥n aumenta debido al hecho de que el valor inicial se representa usando zigzag) </li><li>  total para la columna "x" obtenemos en el archivo 20 ejecuciones con una longitud total de 103 bytes (lo comprob√©, todo encaja) </li></ul><br><p>  Concluyendo la revisi√≥n de la presentaci√≥n de nuestra tabla simple en un archivo, dir√© que los √≠ndices en este ejemplo son degenerados: indican el comienzo del flujo de datos.  Tratar√© los √≠ndices con ejemplos de la vida real; probablemente los describir√© en un art√≠culo separado. </p><br><p>  Para aquellos interesados: en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> puede encontrar el cuaderno jupyter, en el que "entend√≠" el formato interno.  Puede usarlo y repetir (el archivo ORC tambi√©n est√° adjunto all√≠). </p><br><p>  Estoy seguro de que muchos lectores est√°n "perdidos": s√≠, el formato ORC no es simple (tanto en t√©rminos de comprensi√≥n de los detalles como en t√©rminos de uso de las funciones proporcionadas). </p><br><h2 id="o-sravnenii-formatov">  Acerca de la comparaci√≥n de formatos </h2><br><p>  Ahora pasemos al punto principal: comparaci√≥n de formato incorrecta. </p><br><p>  Con qu√© frecuencia se comparan los formatos: comparemos el tama√±o de los archivos en formato A y B, la velocidad de lectura (diferentes tipos de lectura - aleatoria, transmisi√≥n, etc.) en formato A y B. Comparados, concluimos que el formato A es mejor que el formato B. </p><br><p>  Usando el ejemplo de la √∫ltima de las herramientas de compacidad (codificaci√≥n) enumeradas anteriormente: ¬øse pueden codificar los datos en el ORC de manera √≥ptima?  S√≠, hay oportunidades, ver arriba.  Pero igual de bien, ¬°no puedes hacer esto!  Depende del "escritor" (escritor en terminolog√≠a ORC): en el ejemplo anterior, el escritor podr√≠a hacer esto.  Pero √©l podr√≠a escribir 2 veces en 10 mil n√∫meros y esto tambi√©n ser√≠a correcto en t√©rminos de formato.  <strong>Comparando formatos "por tama√±o" comparamos no solo y no tanto los formatos como la calidad algor√≠tmica de los sistemas de aplicaci√≥n que usan estos formatos</strong> . </p><br><p>  ¬øQui√©n es el "escritor" en Hadoop?  Hay muchos de ellos, por ejemplo, Hive, que crea una tabla que almacena sus datos en archivos en formato ORC.  Comparando, por ejemplo, ORC con Parquet en Hadoop, en realidad evaluamos la calidad de implementaci√≥n del algoritmo de conversi√≥n de datos implementado en Hive.  No comparamos formatos (como tales). </p><br><p>  <strong>Caracter√≠stica importante de Hadoop</strong> </p><br><p>  En el mundo relacional cl√°sico, no ten√≠amos forma de influir en el tama√±o de la tabla en Oracle: de alguna manera estaba almacenada y solo Oracle sab√≠a c√≥mo hacerlo.  En Hadoop, la situaci√≥n es ligeramente diferente: podemos ver c√≥mo se almacena esta o aquella tabla (qu√© tan bien Hive, por ejemplo, logr√≥ "codificarla").  Y, si vemos que esto puede mejorarse, tenemos una oportunidad real para esto: crear nuestro propio archivo ORC m√°s √≥ptimo y d√°rselo a Hive como una tabla externa. </p><br><h2 id="sravnim-orc-i-qvd">  Compare ORC y QVD </h2><br><p>  Recientemente describ√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el formato QVD</a> que QlikVew / QlikSense est√° usando activamente.  Vamos a ilustrar muy brevemente estos dos formatos en t√©rminos de las capacidades que brindan para lograr la m√°xima velocidad de lectura y minimizar el tama√±o.  Las capacidades de ORC se describen arriba, como en QVD: </p><br><h1 id="kolonchatoe-hranenie">  Columna de almacenamiento </h1><br><p>  QVD puede considerarse un formato "columnar", no hay duplicaci√≥n de valores de columna en √©l, los valores √∫nicos se almacenan una vez.  PERO no permite el procesamiento en paralelo: primero debe leer completamente los valores de todas las columnas, luego puede leer las filas en paralelo. </p><br><p>  Y hay duplicaci√≥n a nivel de fila: las filas almacenan valores de √≠ndice duplicados en una tabla de caracteres. </p><br><h1 id="szhatie-1">  Compresi√≥n </h1><br><p>  No encontr√© archivos QVD comprimidos, no tuve √©xito, hay una etiqueta en los metadatos, quiz√°s cada una de las partes sobre las que hay un desplazamiento y longitud en los metadatos (y esta es cada tabla de caracteres y toda la tabla de cadenas) se puede comprimir.  En este caso, una lectura paralela de las l√≠neas es "adi√≥s" ... </p><br><h1 id="indeksy-1">  √çndices </h1><br><p>  No hay forma de entender en el archivo QVD qu√© parte de √©l necesita leerse.  En la pr√°ctica, debe analizar la tabla de caracteres byte a byte (cada uno). No es una forma muy eficiente ... </p><br><h1 id="kodirovanie-1">  Codificaci√≥n </h1><br><p>  La codificaci√≥n en QVD no se usa, es posible dibujar una analog√≠a del √≠ndice de bits en una tabla de cadenas con codificaci√≥n, pero esta analog√≠a se "compensa" duplicando n√∫meros por cadenas en las tablas de caracteres (para m√°s detalles, vea el art√≠culo brevemente; el valor de la columna a menudo se representa por el n√∫mero Y la cadena). </p><br><p>  La conclusi√≥n de esta breve comparaci√≥n que personalmente se me ocurri√≥ es la siguiente: el formato QVD pr√°cticamente no contiene capacidades que permitan un almacenamiento compacto y una lectura r√°pida de los datos contenidos en los archivos de este formato. </p><br><p>  (Sonaba de alguna manera ofensivo para QVD, agregar√© un poco: el formato se cre√≥ hace mucho tiempo, solo se usa QlikView / QlikSense y "almacenan" todos los datos en la memoria. Creo que el archivo QVD simplemente se lee todo "tal cual" en la memoria, y luego estos maravillosos productos de BI funcionan muy r√°pidamente con esta presentaci√≥n, aqu√≠ son maestros ...) </p><br><h2 id="vmesto-zaklyucheniya">  En lugar de una conclusi√≥n </h2><br><p>  Critic√≥ y todav√≠a no ha ofrecido nada ... - Sugiero. </p><br><p>  Me parece que los formatos deben compararse no por el ejemplo de su implementaci√≥n espec√≠fica, los formatos deben compararse en t√©rminos de las herramientas incluidas en ellos y la capacidad de usar estas herramientas para resolver nuestros problemas espec√≠ficos.  La velocidad de los procesadores est√° en constante crecimiento, ahora podemos permitirnos casi cualquier algoritmo de conversi√≥n de datos despu√©s de leerlos; de todos modos, la lectura desde el disco ser√° m√°s lenta.  Es por eso que los "medios expresivos" de los formatos son importantes. </p><br><p>  Arriba, enumer√© brevemente interesantes, en mi opini√≥n, las posibilidades del formato ORC.  Todav√≠a no tengo estad√≠sticas sobre c√≥mo est√°n las cosas en la pr√°ctica (cu√°l de estas caracter√≠sticas y hasta qu√© punto utiliza Hive, por ejemplo).  Cuando aparezca, escribir√©.  Los planes inmediatos son hacer una revisi√≥n similar de otro formato de almacenamiento popular: Parquet. </p><br><p>  Bueno, y en conclusi√≥n, en el mundo moderno hay mucha informaci√≥n, desafortunadamente, parte de esta informaci√≥n es demasiado superficial.  No nos rendiremos, miraremos la esencia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458552/">https://habr.com/ru/post/458552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458532/index.html">Pioneros de las nuevas tecnolog√≠as: Vadim Artsev cont√≥ c√≥mo dej√≥ de ser ciego</a></li>
<li><a href="../458536/index.html">Python + Pyside2 o simplemente "Calculadora"</a></li>
<li><a href="../458546/index.html">D√≠a de la automatizaci√≥n, o c√≥mo construimos la capa de autotest.</a></li>
<li><a href="../458548/index.html">Cree su propia biblioteca de estilos de Spring Data Repository con Dynamic Proxy y Spring IoC</a></li>
<li><a href="../458550/index.html">Biblioteca de s√≠mbolos GOST para DipTrace</a></li>
<li><a href="../458556/index.html">Desarrolle la extensi√≥n de Chrome con CLI angular</a></li>
<li><a href="../458558/index.html">Presentaciones con Magento Meetup Kharkiv - Videos y presentaciones</a></li>
<li><a href="../458560/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 12. VLAN avanzada</a></li>
<li><a href="../458564/index.html">Pozos en camino a convertirse en programador</a></li>
<li><a href="../458566/index.html">¬øC√≥mo atrapamos a un dise√±ador de UX con carnada viva?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>