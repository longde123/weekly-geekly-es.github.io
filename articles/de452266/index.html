<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑ ‚õ™Ô∏è üèâ Serverlose Racks üî∏ üèÜ üèÇüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Serverless geht es nicht um die physische Abwesenheit von Servern. Dies ist kein ‚ÄûKiller‚Äú f√ºr Container und kein vor√ºbergehender Trend. Dies ist e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serverlose Racks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/452266/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/40/f2/jb40f22sdsdaapg5pvd_wlcj81w.png"></div><br>  Bei Serverless geht es nicht um die physische Abwesenheit von Servern.  Dies ist kein ‚ÄûKiller‚Äú f√ºr Container und kein vor√ºbergehender Trend.  Dies ist ein neuer Ansatz zum Erstellen von Systemen in der Cloud.  In dem heutigen Artikel werden wir uns mit der Architektur von Serverless-Anwendungen befassen und herausfinden, welche Rolle der Serverless-Dienstanbieter und Open-Source-Projekte spielen.  Am Ende werden wir √ºber Serverless sprechen. <br><a name="habracut"></a><br>  Ich m√∂chte die Serverseite der Anwendung schreiben (ja sogar einen Online-Shop).  Dies kann ein Chat, ein Dienst zum Ver√∂ffentlichen von Inhalten oder ein Load Balancer sein.  In jedem Fall wird es viele Kopfschmerzen geben: Sie m√ºssen die Infrastruktur vorbereiten, die Anwendungsabh√§ngigkeiten ermitteln und √ºber das Host-Betriebssystem nachdenken.  Dann m√ºssen Sie kleine Komponenten aktualisieren, die die Arbeit des restlichen Monolithen nicht beeintr√§chtigen.  Vergessen wir nicht die Skalierung unter Last. <br><br>  Was aber, wenn wir kurzlebige Container verwenden, in denen die erforderlichen Abh√§ngigkeiten bereits vorinstalliert sind und die Container selbst voneinander und vom Host-Betriebssystem isoliert sind?  Wir werden den Monolithen in Mikrodienste aufteilen, von denen jeder unabh√§ngig von den anderen aktualisiert und skaliert werden kann.  Nachdem ich den Code in einem solchen Container abgelegt habe, kann ich ihn auf jeder Infrastruktur ausf√ºhren.  Schon besser. <br><br>  Und wenn Sie keine Container konfigurieren m√∂chten?  Ich m√∂chte nicht √ºber die Skalierung der Anwendung nachdenken.  Ich m√∂chte nicht f√ºr im Leerlauf laufende Container bezahlen, wenn die Belastung des Dienstes minimal ist.  Ich m√∂chte Code schreiben.  Konzentrieren Sie sich mit Lichtgeschwindigkeit auf Gesch√§ftslogik und Marktprodukte. <br><br>  Solche Gedanken f√ºhrten mich zu Serverless Computing.  Serverlos bedeutet in diesem Fall <em>nicht</em> das <em>physische Fehlen von Servern, sondern das Fehlen von Kopfschmerzen bei der Verwaltung der Infrastruktur.</em> <br><br>  Die Idee ist, dass die Anwendungslogik in unabh√§ngige Funktionen zerf√§llt.  Sie haben eine Ereignisstruktur.  Jede der Funktionen f√ºhrt eine "Mikrotask" aus.  Der Entwickler muss lediglich die Funktionen in die vom Cloud-Anbieter bereitgestellte Konsole laden und sie mit den Ereignisquellen korrelieren.  Der Code wird auf Anfrage in einem automatisch vorbereiteten Container ausgef√ºhrt, und ich bezahle nur die Ausf√ºhrungszeit. <br><br>  Mal sehen, wie der Anwendungsentwicklungsprozess jetzt aussehen wird. <br><br><h2>  Vom Entwickler </h2><br>  Zuvor haben wir √ºber die Anwendung f√ºr den Online-Shop gesprochen.  Beim traditionellen Ansatz wird die Hauptlogik des Systems von einer monolithischen Anwendung ausgef√ºhrt.  Und der Server mit der Anwendung l√§uft st√§ndig, auch wenn keine Last vorhanden ist. <br><br>  <strong>Um zu Serverless zu wechseln, teilen wir die Anwendung in Mikrotasks auf.</strong>  Unter jedem von ihnen schreiben wir unsere eigene Funktion.  Funktionen sind unabh√§ngig voneinander und speichern keine Statusinformationen.  Sie k√∂nnen sogar in verschiedenen Sprachen geschrieben werden.  Wenn einer von ihnen abst√ºrzt, wird die gesamte Anwendung nicht gestoppt.  Die Anwendungsarchitektur sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/1_/yj/pm1_yj5fd2s0f99zcirrpofsura.png" title="Serverlose Anwendungsarchitektur. Das Diagramm zeigt, dass Sie zus√§tzliche Ressourcen verbinden m√ºssen (hier die Datenbank und der Authentifizierungsserver)."></div><br>  Die Unterteilung in Funktionen in Serverless √§hnelt der Arbeit mit Microservices.  Ein Microservice kann jedoch mehrere Aufgaben ausf√ºhren, und im Idealfall sollte eine Funktion eine ausf√ºhren.  Stellen Sie sich vor, die Aufgabe besteht darin, Statistiken zu sammeln und auf Anfrage des Benutzers anzuzeigen.  Beim Microservice-Ansatz wird die Aufgabe von einem Service mit zwei Einstiegspunkten ausgef√ºhrt: Schreiben und Lesen.  Beim Serverless Computing sind dies zwei verschiedene Funktionen, die nicht miteinander verbunden sind.  Ein Entwickler spart Rechenressourcen, wenn beispielsweise Statistiken h√§ufiger aktualisiert als heruntergeladen werden. <br><br>  Serverlose Funktionen m√ºssen in einer kurzen Zeitspanne (Timeout) ausgef√ºhrt werden, die vom Dienstanbieter festgelegt wird.  F√ºr AWS betr√§gt das Zeitlimit beispielsweise 15 Minuten.  Dies bedeutet, dass langlebige Funktionen (langlebig) ge√§ndert werden m√ºssen, um die Anforderungen zu erf√ºllen - dieser Serverless unterscheidet sich von anderen heute g√§ngigen Technologien (Container und Platform as a Service). <br><br>  <strong>Wir weisen jeder Funktion ein Ereignis zu.</strong>  Ein Ereignis ist ein Ausl√∂ser f√ºr eine Aktion: <br><div class="scrollable-table"><table><tbody><tr><td>  <strong>Ereignis</strong> </td><td>  <strong>Die Aktion, die die Funktion ausf√ºhrt</strong> </td></tr><tr><td>  Das Produktbild wurde in den Store hochgeladen </td><td>  Bild komprimieren und in den Katalog hochladen </td></tr><tr><td>  Die Adresse des physischen Gesch√§fts wurde in der Datenbank aktualisiert </td><td>  Laden Sie einen neuen Ort auf Karten hoch </td></tr><tr><td>  Der Kunde bezahlt die Ware </td><td>  Starten Sie die Zahlungsabwicklung </td></tr></tbody></table></div>  Ereignisse k√∂nnen HTTP-Anforderungen, Streaming-Daten, Nachrichtenwarteschlangen usw. sein.  Ereignisquellen sind die √Ñnderung oder das Erscheinungsbild von Daten.  Dar√ºber hinaus k√∂nnen Funktionen per Timer ausgef√ºhrt werden. <br><br>  Die Architektur funktionierte und die Anwendung wurde fast serverlos.  Als n√§chstes gehen wir zum Dienstleister. <br><br><h2>  Vom Anbieter </h2><br>  Serverless Computing wird normalerweise von Cloud-Dienstanbietern angeboten.  Sie nennen es anders: Azure-Funktionen, AWS Lambda, Google Cloud-Funktionen, IBM Cloud-Funktionen. <br><br>  Wir werden den Dienst √ºber die Konsole oder das pers√∂nliche Konto des Anbieters nutzen.  Der Funktionscode kann auf eine der folgenden Arten heruntergeladen werden: <br><br><ul><li>  Schreiben Sie Code in integrierten Editoren √ºber die Webkonsole. </li><li>  Laden Sie das Archiv mit dem Code herunter, </li><li>  Arbeit mit √∂ffentlichen oder privaten Git-Repositories. </li></ul><br>  Hier konfigurieren wir die Ereignisse, die die Funktion aufrufen.  Unterschiedliche Anbieter k√∂nnen unterschiedliche Ereigniss√§tze haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iv/qc/f2/ivqcf25p7y6nha_iduzvjursray.png" title="Google Cloud Platform Console-Oberfl√§che"></div><br><br>  Der Anbieter seiner Infrastruktur hat das FaaS-System (Function as a Service) aufgebaut und automatisiert: <br><br><ol><li>  Der Funktionscode gelangt auf der Anbieterseite in das Repository. </li><li>  Wenn ein Ereignis auftritt, werden Container mit der vorbereiteten Umgebung automatisch auf dem Server bereitgestellt.  Jede Funktionsinstanz verf√ºgt √ºber einen eigenen isolierten Container. </li><li>  Aus dem Speicher wird die Funktion an den Container gesendet, berechnet, das Ergebnis zur√ºckgegeben. </li><li>  Die Anzahl der parallelen Ereignisse w√§chst - die Anzahl der Container w√§chst.  Das System skaliert automatisch.  Wenn Benutzer nicht auf die Funktion zugreifen, ist sie inaktiv. </li><li>  Der Anbieter legt die Leerlaufzeit der Container fest. Wenn w√§hrend dieser Zeit die Funktionen nicht im Container angezeigt werden, werden sie zerst√∂rt. </li></ol><br>  So bekommen wir Serverless aus der Box.  Wir zahlen f√ºr den Service nach dem Pay-as-you-go-Modell und nur f√ºr die Funktionen, die verwendet werden, und nur f√ºr den Zeitpunkt, zu dem sie verwendet wurden. <br><br>  Um Entwicklern den Service n√§her zu bringen, bieten Anbieter bis zu 12 Monate kostenlose Tests an. Sie begrenzen jedoch die gesamte Rechenzeit, die Anzahl der Anfragen pro Monat, das Geld oder den Stromverbrauch. <br><br>  Der Hauptvorteil der Zusammenarbeit mit einem Anbieter besteht darin, dass Sie sich keine Gedanken √ºber die Infrastruktur (Server, virtuelle Maschinen, Container) machen m√ºssen.  Der Anbieter kann FaaS sowohl in eigenen Entwicklungen als auch mithilfe von Open-Source-Tools implementieren.  Wir werden weiter dar√ºber sprechen. <br><br><h2>  Aus Open Source </h2><br>  In den letzten Jahren hat die Open-Source-Community aktiv an serverlosen Tools gearbeitet.  Insbesondere die gr√∂√üten Marktteilnehmer tragen zur Entwicklung serverloser Plattformen bei: <br><br><ul><li>  <strong>Google</strong> bietet Entwicklern sein Open-Source-Tool <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Knative an</a> .  Die Entwicklung umfasste IBM, RedHat, Pivotal und SAP. </li><li>  <strong>IBM</strong> arbeitete an der OpenWhisk Serverless-Plattform, die dann zum Apache Foundation-Projekt wurde. </li><li>  <strong>Microsoft hat</strong> den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Azure Functions-</a> Plattformcode teilweise ge√∂ffnet. </li></ul><br>  Entwicklungen werden auch in Richtung serverloser Frameworks durchgef√ºhrt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Kubeless</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Fission werden</a> in vorbereiteten Kubernetes-Clustern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">bereitgestellt. OpenFaaS</a> funktioniert sowohl mit Kubernetes als auch mit Docker Swarm.  Das Framework fungiert als eine Art Controller - auf Anfrage bereitet es die Laufzeit innerhalb des Clusters vor und f√ºhrt dort eine Funktion aus. <br><br>  Frameworks lassen Raum f√ºr die Toolkonfiguration, die Ihren Anforderungen entspricht.  In Kubeless kann der Entwickler das Zeitlimit f√ºr die Ausf√ºhrung der Funktion festlegen (der Standardwert ist 180 Sekunden).  Die Spaltung bei dem Versuch, das Problem des Kaltstarts zu l√∂sen, bietet die M√∂glichkeit, einen Teil der Container st√§ndig in Betrieb zu halten (obwohl dies die Kosten f√ºr Ausfallzeiten mit sich bringt).  Und OpenFaaS bietet eine Reihe von Triggern f√ºr jeden Geschmack und jede Farbe: HTTP, Kafka, Redis, MQTT, Cron, AWS SQS, NATs und andere. <br><br>  Anweisungen f√ºr den Einstieg finden Sie in der offiziellen Dokumentation der Frameworks.  Die Arbeit mit ihnen erfordert etwas mehr F√§higkeiten als die Arbeit mit einem Anbieter - dies ist zumindest die M√∂glichkeit, einen Kubernetes-Cluster √ºber die CLI zu starten.  F√ºgen Sie maximal andere Open-Source-Tools hinzu (z. B. den Warteschlangenmanager von Kafka). <br><br>  Unabh√§ngig davon, wie wir mit Serverless arbeiten - √ºber einen Anbieter oder Open Source - erhalten wir eine Reihe von Vor- und Nachteilen des Serverless-Ansatzes. <br><br><h2>  Aus der Perspektive der Vor- und Nachteile </h2><br>  Serverless entwickelt die Ideen der Containerinfrastruktur und des Microservice-Ansatzes, bei denen Teams im mehrsprachigen Modus arbeiten k√∂nnen, ohne an eine Plattform gebunden zu sein.  Das Erstellen eines Systems wird vereinfacht und das Beheben von Fehlern wird einfacher.  Mit der Microservice-Architektur k√∂nnen Sie dem System viel schneller neue Funktionen hinzuf√ºgen als bei einer monolithischen Anwendung. <br><br>  <strong>Serverless reduziert die Entwicklungszeit noch weiter, da sich</strong> der Entwickler ausschlie√ülich auf die Gesch√§ftslogik und <strong>-codierung</strong> der Anwendung konzentrieren kann.  Infolgedessen wird die Markteinf√ºhrungszeit f√ºr die Entwicklung verk√ºrzt. <br><br>  <strong>Als Bonus erhalten wir eine automatische Skalierung der Last</strong> und zahlen nur f√ºr die verwendeten Ressourcen und nur zu dem Zeitpunkt, zu dem sie verwendet werden. <br><br>  Serverless hat wie jede Technologie Nachteile. <br><br>  <em>Ein solcher Nachteil kann beispielsweise eine Kaltstartzeit sein (durchschnittlich bis zu 1 Sekunde f√ºr Sprachen wie JavaScript, Python, Go, Java, Ruby).</em> <br><br>  Einerseits h√§ngt die Zeit eines Kaltstarts von vielen Variablen ab: der Sprache, in der die Funktion geschrieben ist, der Anzahl der Bibliotheken, der Codemenge, der Kommunikation mit zus√§tzlichen Ressourcen (denselben Datenbanken oder Authentifizierungsservern).  Da der Entwickler diese Variablen steuert, kann er die Startzeit verk√ºrzen.  Andererseits kann der Entwickler die Startzeit des Containers nicht steuern - alles h√§ngt vom Anbieter ab. <br><br>  Ein Kaltstart kann sich in einen Warmstart verwandeln, wenn die Funktion den vom vorherigen Ereignis gestarteten Container wiederverwendet.  Diese Situation tritt in drei F√§llen auf: <br><br><ul><li>  wenn Kunden den Service h√§ufig nutzen und die Anzahl der Aufrufe der Funktion zunimmt; </li><li>  wenn der Anbieter, die Plattform oder das Framework es Ihnen erm√∂glicht, einen Teil der Container st√§ndig laufen zu lassen; </li><li>  wenn der Entwickler Timer-Funktionen ausf√ºhrt (z. B. alle 3 Minuten). </li></ul><br>  F√ºr viele Anwendungen ist ein Kaltstart kein Problem.  Hier m√ºssen Sie auf dem Typ und den Aufgaben des Dienstes aufbauen.  Ein verz√∂gerter Start f√ºr eine Sekunde ist f√ºr eine Gesch√§ftsanwendung nicht immer kritisch, kann jedoch f√ºr medizinische Dienstleistungen kritisch werden.  In diesem Fall ist der Ansatz ohne Server wahrscheinlich nicht mehr geeignet. <br><br>  <em>Der n√§chste Nachteil von Serverless ist die kurze Lebensdauer der Funktion (das Zeitlimit, f√ºr das die Funktion ausgef√ºhrt werden muss).</em> <br><br>  Wenn Sie jedoch mit langlebigen Aufgaben arbeiten m√ºssen, k√∂nnen Sie eine Hybridarchitektur verwenden - kombinieren Sie Serverless mit anderer Technologie. <br><br>  <em>Nicht alle Systeme k√∂nnen nach dem Serverless-Schema arbeiten.</em> <br><br>  Einige Anwendungen speichern weiterhin Daten und Status zur Laufzeit.  Einige Architekturen bleiben monolithisch und einige Funktionen sind langlebig.  Serverless ist jedoch (wie fr√ºher Cloud-Technologien und dann Container) eine Technologie mit gro√üer Zukunft. <br><br>  In diesem Sinne m√∂chte ich reibungslos auf das Problem der Anwendung des Ansatzes ohne Server eingehen. <br><br><h2>  Auf der Anwendungsseite </h2><br>  Im Jahr 2018 stieg der Prozentsatz der serverlosen Nutzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">um das Eineinhalbfache</a> .  Unter den Unternehmen, die die Technologie bereits in ihren Diensten implementiert haben, befinden sich Marktriesen wie Twitter, PayPal, Netflix, T-Mobile und Coca-Cola.  Gleichzeitig m√ºssen Sie verstehen, dass Serverless kein Allheilmittel ist, sondern ein Werkzeug zur L√∂sung einer bestimmten Reihe von Aufgaben: <br><br><ul><li>  <strong>Reduzieren Sie Ausfallzeiten.</strong>  Sie m√ºssen die virtuelle Maschine nicht st√§ndig unter Diensten halten, auf die nicht viel zugegriffen wird. </li><li>  <strong>"On the fly" verarbeitet die Daten.</strong>  Komprimieren Sie Bilder, schneiden Sie den Hintergrund aus, √§ndern Sie die Videokodierung, arbeiten Sie mit IoT-Sensoren und f√ºhren Sie mathematische Operationen durch. <br></li><li>  <strong>Andere Dienstleistungen zusammenkleben.</strong>  Git-Repository mit internen Programmen, Chat-Bot in Slack mit Jira und mit einem Kalender. </li><li>  <strong>Last ausgleichen.</strong>  Hier werden wir n√§her darauf eingehen. </li></ul><br>  Nehmen wir an, es gibt einen Service, zu dem 50 Personen kommen.  Darunter befindet sich eine virtuelle Maschine mit schwacher Hardware.  In regelm√§√üigen Abst√§nden steigt die Belastung des Dienstes erheblich an.  Dann kommt das schwache Eisen nicht zurecht. <br><br>  Sie k√∂nnen einen Balancer in das System aufnehmen, der die Last beispielsweise auf drei virtuelle Maschinen verteilt.  Zu diesem Zeitpunkt k√∂nnen wir die Last nicht genau vorhersagen, sodass wir eine bestimmte Menge an Ressourcen ‚Äûin Reserve‚Äú halten.  Und √úberzahlung f√ºr Ausfallzeiten. <br><br>  In dieser Situation k√∂nnen wir das System durch einen hybriden Ansatz optimieren: F√ºr den Load Balancer verlassen wir eine virtuelle Maschine und stellen eine Verkn√ºpfung zu Serverless Endpoint mit Funktionen her.  Wenn die Last den Schwellenwert √ºberschreitet, startet der Balancer Instanzen von Funktionen, die einen Teil der Anforderungsverarbeitung √ºbernehmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r6/xv/ew/r6xvewex6fwzcnjiaciro92xeuy.png" title="Hybrid Load Balancer-Architektur"></div><br>  Somit kann Serverless dort eingesetzt werden, wo es nicht zu oft vorkommt, sondern um eine gro√üe Anzahl von Anfragen intensiv zu verarbeiten.  In diesem Fall ist es rentabler, mehrere Funktionen 15 Minuten lang auszuf√ºhren, als st√§ndig eine virtuelle Maschine oder einen virtuellen Server zu halten. <br><br>  Bei allen Vorteilen von Serverless Computing sollten Sie vor der Implementierung zun√§chst die Anwendungslogik bewerten und verstehen, welche Aufgaben Serverless in einem bestimmten Fall l√∂sen kann. <br><br><h2>  Serverless und Selectel </h2><br>  Bei Selectel haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Arbeit mit Kubernetes</a> in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">virtuellen privaten Cloud bereits</a> √ºber unser Control Panel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">vereinfacht</a> .  Jetzt bauen wir unsere eigene FaaS-Plattform.  Wir m√∂chten, dass Entwickler ihre Probleme mit Serverless √ºber eine bequeme, flexible Oberfl√§che l√∂sen k√∂nnen. <br><br>  M√∂chten Sie den Entwicklungsprozess der neuen FaaS-Plattform verfolgen?  Abonnieren Sie den Selectel-Newsletter ‚ÄûCloud Functions‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Serviceseite</a> .  Wir werden √ºber den Entwicklungsprozess sprechen und die geschlossene Version von Cloud-Funktionen bekannt geben. <br><br>  Wenn Sie Ideen haben, was eine ideale FaaS-Plattform sein sollte und wie Sie Serverless in Ihren Projekten verwenden m√∂chten, teilen Sie diese in den Kommentaren mit.  Wir werden Ihre W√ºnsche bei der Entwicklung der Plattform ber√ºcksichtigen. <br><br>  Im Artikel verwendete Materialien: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">1,5-fache serverlose Auslastung (vollst√§ndiger RightScale-Bericht)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Wie die Kaltstartzeit ist, h√§ngt von der Anwendungssprache ab</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452266/">https://habr.com/ru/post/de452266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452252/index.html">Sicherheit im Google-Stil</a></li>
<li><a href="../de452254/index.html">Tipps und Tricks zur digitalen Forensik: So finden Sie die Gl√ºcksm√ºnze eines Eindringlings</a></li>
<li><a href="../de452258/index.html">Corda - Open Source Blockchain f√ºr Unternehmen</a></li>
<li><a href="../de452262/index.html">Angular: Erstellen und Ver√∂ffentlichen einer Bibliothek</a></li>
<li><a href="../de452264/index.html">Wie wir die Seite f√ºr den Mascot Car Award gemacht haben</a></li>
<li><a href="../de452268/index.html">C # WPF analog Window.ShowDialog () oder mit DispatcherFrame umgehen</a></li>
<li><a href="../de452270/index.html">Die Xamarin-API-Dokumentation ist jetzt √∂ffentlich verf√ºgbar</a></li>
<li><a href="../de452272/index.html">M√§dchen unter dem Wasserfall</a></li>
<li><a href="../de452276/index.html">Dropbox Client Reverse Engineering</a></li>
<li><a href="../de452278/index.html">Bluetooth LE ist nicht so be√§ngstigend oder wie man die Benutzererfahrung ohne gro√üen Aufwand verbessert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>