<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❎ 🤲🏽 👩🏿‍🎨 Créez un jeu de tir zombie à la troisième personne avec DOTS 👩‍👧‍👦 👨🏿‍🎨 👨🏻‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Khabrovsk. Comme nous l'avons déjà écrit, janvier est riche en nouveaux lancements et aujourd'hui nous annonçons un ensemble pour un nouveau co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créez un jeu de tir zombie à la troisième personne avec DOTS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/484094/">  <i>Salut, Khabrovsk.</i>  <i>Comme nous l'avons déjà écrit, janvier est riche en nouveaux lancements et aujourd'hui nous annonçons un ensemble pour un nouveau cours d'OTUS - <a href="https://otus.pw/YRoY/">"Game Developer for Unity"</a> .</i>  <i>En prévision du début du cours, nous partageons avec vous la traduction de matériel intéressant.</i> <i><br></i> <br><img src="https://habrastorage.org/webt/o-/2d/iz/o-2diz_bo0cjb7cksohmc8zeoxc.png"><br><br><hr><blockquote>  Nous reconstruisons le noyau Unity avec notre <a href="https://unity.com/dots%3F_ga%3D2.241875339.889742683.1579017753-927430519.1579017753">pile technologique orientée données</a> .  Comme de nombreux studios de jeux, nous voyons également de grands avantages à utiliser l'Entity Component System (ECS), le système de tâches C # (C # Job System) et Burst Compiler.  À Unite Copenhagen, nous avons eu l'occasion de discuter avec Far North Entertainment et de découvrir comment ils implémentent cette fonctionnalité DOTS dans les projets Unity traditionnels. </blockquote><a name="habracut"></a>  Far North Entertainment est un studio suédois appartenant à cinq amis ingénieurs.  Depuis la sortie de Down to Dungeon pour Gear VR au début de 2018, la société travaille sur un jeu qui appartient au genre classique des jeux PC, à savoir un jeu post-apocalyptique en mode de survie zombie.  Ce qui distingue le projet des autres, c'est le nombre de zombies qui vous poursuivent.  La vision de l'équipe à cet égard a attiré des milliers de zombies affamés vous suivant dans d'énormes hordes. <br><br>  Cependant, ils ont rapidement rencontré de nombreux problèmes de performances au stade du prototypage.  La création, la mort, le renouvellement et l'animation de tout ce nombre d'ennemis sont restés le principal goulot d'étranglement, même après que l'équipe ait essayé de résoudre le problème avec la <i>mise en commun oblique</i> et une <i>instanciation de nimation</i> . <br><br>  Cela a forcé le directeur technique du studio Andres Ericsson à tourner son attention vers DOTS et à changer l'état d'esprit orienté objet vers orienté données.  "L'idée clé qui a contribué à provoquer ce changement était que vous deviez arrêter de penser aux objets et aux hiérarchies d'objets et commencer à penser aux données, comment elles sont transformées et comment y accéder", at-il déclaré. .  Ses mots signifient qu'il n'est pas nécessaire de construire une architecture de code avec un œil sur les objets de la vie réelle de telle manière qu'elle résout le problème le plus général et abstrait.  Il a de nombreux conseils pour ceux qui, comme lui, sont confrontés à un changement de vision du monde: <br><br>  <i>«Demandez-vous quel est le véritable problème que vous essayez de résoudre et quelles données sont importantes pour obtenir une solution.</i>  <i>Allez-vous convertir le même ensemble de données de la même manière encore et encore?</i>  <i>Combien de données utiles pouvez-vous tenir dans une ligne du cache du processeur?</i>  <i>Si vous apportez des modifications au code existant, évaluez la quantité de données indésirables que vous ajoutez à la ligne de cache.</i>  <i>Est-il possible de diviser les calculs en plusieurs threads ou dois-je utiliser un seul flux de commandes? "</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QGM4feh0fRA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'équipe a compris que les entités du système de composants Unity ne sont que des identifiants de recherche dans les flux de composants.  Les composants ne sont que des données, tandis que les systèmes contiennent toute la logique et filtrent les entités avec une signature spécifique, appelées archétypes.  «Je pense que l'une des informations qui nous a aidés à visualiser nos idées a été d'introduire ECS en tant que base de données SQL.  Chaque archétype est une table dans laquelle chaque colonne est un composant et chaque ligne est une entité unique.  En gros, vous utilisez des systèmes pour créer des requêtes pour ces tables d'archétype et effectuer des opérations sur des entités », explique Anders. <br><br><h3>  Présentation de DOTS </h3><br>  Pour arriver à cette compréhension, il a étudié la documentation du système <a href="https://docs.unity3d.com/Packages/com.unity.entities%400.1/manual/index.html%3F_ga%3D2.233150103.889742683.1579017753-927430519.1579017753">Entity Component</a> , des exemples <a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">ECS</a> et <a href="https://github.com/Unity-Technologies/UniteAustinTechnicalPresentation">un exemple</a> que nous avons fait avec Nordeus et présenté à Unite Austin.  Des informations générales sur l'architecture orientée données ont également été très utiles à l'équipe.  «Le rapport de <a href="https://www.youtube.com/watch%3Fv%3DrX0ItVEVjHc">Mike Acton</a> sur l'architecture orientée données avec CppCon 2014 est exactement ce qui nous a ouvert les yeux sur ce mode de programmation.» <br><br>  L'équipe de Far North a publié ce qu'elle a appris sur son <a href="http://www.farnorthentertainment.com/2019/04/10/what-we-have-been-up-to-why-ecs-is-the-way-to-gigantic-hordes/">blog Dev</a> , en septembre de cette année, elle est venue à Copenhague pour parler de ses expériences avec la transition vers une approche orientée données dans Unity. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yTGhg905SCs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Cet article est basé sur un rapport, il explique plus en détail les spécificités de leur implémentation d'ECS, du système de tâches C # et du compilateur Burst.  Far North a également aimablement partagé de nombreux exemples de code de leur projet. <br><br><h3>  Organisation des données Zombie </h3><br>  «Le problème auquel nous étions confrontés était d'interpoler les déplacements et les rotations de milliers d'objets côté client», explique Anders.  Leur approche initiale orientée objet consistait à créer un script <i>ZombieView</i> abstrait qui héritait de la classe parent <i>EntityView</i> générique.  <i>EntityView</i> est un <i>MonoBehaviour</i> attaché à un <i>GameObject</i> .  Il agit comme une représentation visuelle du modèle de jeu.  Chaque <i>ZombieView</i> était responsable de gérer sa propre interpolation de mouvement et de rotation dans sa fonction de <i>mise à jour</i> . <br><br>  Cela semble normal, jusqu'à ce que vous compreniez que chaque entité se trouve en mémoire dans un endroit arbitraire.  Cela signifie que si vous accédez à des milliers d'objets, le processeur doit les retirer de la mémoire un par un, et cela se produit extrêmement lentement.  Si vous placez vos données dans des blocs ordonnés disposés en série, le processeur peut mettre en cache tout un tas de données en même temps.  La plupart des processeurs modernes peuvent recevoir environ 128 ou 256 bits du cache en un cycle. <br><br>  L'équipe a décidé de convertir les ennemis en DOTS dans l'espoir de résoudre les problèmes de performances côté client.  Le premier en ligne était la fonction de <i>mise à jour</i> dans <i>ZombieView</i> .  L'équipe a déterminé quelles parties devaient être divisées en différents systèmes et déterminé les données nécessaires.  La première chose et la plus évidente était l'interpolation des positions et des virages, car le monde du jeu est une grille à deux dimensions.  Deux variables flottantes sont responsables de l'endroit où les zombies vont, et le dernier composant est la position cible, il suit la position du serveur pour l'ennemi. <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> PositionData2D : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 Position; } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HeadingData2D : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 Heading; } [Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TargetPositionData : IComponentData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float2 TargetPosition; }</code> </pre> <br>  L'étape suivante consistait à créer un archétype pour les ennemis.  L'archétype est un ensemble de composants qui appartiennent à une certaine entité, en d'autres termes, c'est la signature du composant. <br><br>  Le projet utilise des préfabriqués pour déterminer les archétypes, car les ennemis nécessitent plus de composants, et certains d'entre eux ont besoin de liens vers <i>GameObject</i> .  Cela fonctionne de sorte que vous puissiez envelopper les données de votre composant dans <i>ComponentDataProxy</i> , qui le transformera en <i>MonoBehaviour</i> , qui à son tour peut être attaché au préfabriqué.  Lorsque vous créez une instance à l'aide d' <i>EntityManager</i> et passez le préfabriqué, il crée une entité avec toutes les données des composants qui ont été attachés au préfabriqué.  Toutes les données des composants sont stockées dans des blocs de mémoire de 16 kilo-octets appelés <i>ArchetypeChunk</i> . <br><br>  Voici une visualisation de la façon dont les flux de composants seront organisés dans notre bloc d'archétype: <br><br><img src="https://habrastorage.org/webt/mh/cn/r9/mhcnr9qjgpsr6lkej2l0ezq0jmi.png"><br><br>  <i>«L'un des principaux avantages des blocs d'archétype est que vous n'avez pas souvent besoin de réaffecter un groupe lors de la création de nouveaux objets, car la mémoire a déjà été allouée à l'avance.</i>  <i>Cela signifie que la création d'entités consiste à écrire des données à la fin des flux de composants à l'intérieur de blocs d'archétype.</i>  <i>Le seul cas où il est nécessaire d'effectuer à nouveau l'allocation de segments est lors de la création d'une entité qui ne rentre pas dans les bordures du bloc.</i>  <i>Dans ce cas, soit l'allocation d'un nouveau morceau d'un archétype de 16 Ko sera lancée, soit s'il existe un fragment vide du même archétype, il peut être réutilisé.</i>  <i>Ensuite, les données des nouveaux objets seront enregistrées dans les flux de composants du nouveau morceau »,</i> explique Anders. <br><br><h3>  Le multithreading de vos zombies </h3><br>  Maintenant que les données étaient densément compressées et placées en mémoire de manière pratique pour la mise en cache, l'équipe pouvait facilement utiliser le système de tâches C # pour exécuter son code sur plusieurs cœurs de processeur en parallèle. <br><br>  L'étape suivante consistait à créer un système qui filtrait toutes les entités de tous les blocs d'archétype <i>contenant des composants</i> <i>PositionData2D</i> , <i>HeadingData2D</i> et <i>TargetPositionData</i> . <br><br>  Pour ce faire, Anders et son équipe ont créé <i>JobComponentSystem</i> et construit leur demande dans la fonction <i>OnCreate</i> .  Cela ressemble à ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EntityQuery m_Group; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCreate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnCreate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntityQueryDesc { All = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { ComponentType.ReadWrite&lt;PositionData2D&gt;(), ComponentType.ReadWrite&lt;HeadingData2D&gt;(), ComponentType.ReadOnly&lt;TargetPositionData&gt;() }, }; m_Group = GetEntityQuery(query); }</code> </pre> <br>  Le code annonce une demande qui filtre tous les objets du monde qui ont une position, une direction et un but.  Ensuite, ils voulaient planifier des tâches pour chaque trame à l'aide du système de tâches C # pour distribuer les calculs sur plusieurs workflows. <br><br>  <i>"La chose la plus intéressante à propos du système de tâches C # est qu'il s'agit du même système que Unity utilise dans son code, nous n'avons donc pas eu à nous soucier que les threads exécutables se bloquent les uns les autres, nécessitant les mêmes cœurs de processeur et provoquant des problèmes de performances. ",</i> Dit Anders. <br><br>  L'équipe a décidé d'utiliser <i>IJobChunk</i> , car des milliers d'ennemis impliquaient la présence d'un grand nombre de morceaux d'archétype qui devraient correspondre à la demande au moment de l'exécution.  <i>IJobChunk</i> distribue les bons morceaux sur différents workflows. <br><br>  Chaque image, une nouvelle tâche <i>UpdatePositionAndHeadingJob,</i> est chargée de gérer l'interpolation des positions et des tours des ennemis dans le jeu. <br><br>  Le code de planification des tâches est le suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> JobHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JobHandle inputDeps</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> positionDataType = GetArchetypeChunkComponentType&lt;PositionData2D&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headingDataType = GetArchetypeChunkComponentType&lt;HeadingData2D&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetPositionDataType = GetArchetypeChunkComponentType&lt;TargetPositionData&gt;(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updatePosAndHeadingJob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UpdatePositionAndHeadingJob { PositionDataType = positionDataType, HeadingDataType = headingDataType, TargetPositionDataType = targetPositionDataType, DeltaTime = Time.deltaTime, RotationLerpSpeed = <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, MovementLerpSpeed = <span class="hljs-number"><span class="hljs-number">4.0f</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updatePosAndHeadingJob.Schedule(m_Group, inputDeps); }</code> </pre> <br>  Voici à quoi ressemble la tâche: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> UpdatePositionAndHeadingJob : IJobChunk { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;PositionData2D&gt; PositionDataType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;HeadingData2D&gt; HeadingDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;TargetPositionData&gt; TargetPositionDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RotationLerpSpeed; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MovementLerpSpeed; }</code> </pre> <br>  Lorsqu'un thread de travail récupère une tâche de sa file d'attente, il appelle le cœur de la tâche. <br><br>  Voici à quoi ressemble le noyau d'exécution: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArchetypeChunk chunk, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstEntityIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkPositionData = chunk.GetNativeArray(PositionDataType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkHeadingData = chunk.GetNativeArray(HeadingDataType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunkTargetPositionData = chunk.GetNativeArray(TargetPositionDataType); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunk.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = chunkTargetPositionData[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> positionData = chunkPositionData[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headingData = chunkHeadingData[i]; float2 toTarget = target.TargetPosition - positionData.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = math.length(toTarget); headingData.Heading = math.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>( headingData.Heading, math.lerp(headingData.Heading, math.normalize(toTarget), math.mul(DeltaTime, RotationLerpSpeed)), distance &gt; <span class="hljs-number"><span class="hljs-number">0.008</span></span> ); positionData.Position = math.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>( target.TargetPosition, math.lerp( positionData.Position, target.TargetPosition, math.mul(DeltaTime, MovementLerpSpeed)), distance &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ); chunkPositionData[i] = positionData; chunkHeadingData[i] = headingData; } }</code> </pre><br>  <i>«Vous remarquerez peut-être que nous utilisons select au lieu de branchement, cela nous permet de nous débarrasser de l'effet appelé prédiction de branchement incorrecte.</i>  <i>La fonction select évaluera les deux expressions et sélectionnera celle qui correspond à la condition, et si vos expressions ne sont pas si difficiles à calculer, je recommanderais d'utiliser select, car c'est souvent moins cher que d'attendre que le CPU se rétablisse d'une prédiction de branche incorrecte. "</i> Anders. <br><br><h3>  Augmentez la productivité avec Burst </h3><br>  La dernière étape de la conversion de DOTS en position ennemie et interpolation de cap consiste à activer le compilateur Burst.  La tâche semblait assez simple pour Anders: «Puisque les données sont situées dans des tableaux adjacents et que nous utilisons la nouvelle bibliothèque de mathématiques d'Unity, tout ce que nous avions à faire était d'ajouter l'attribut <i>BurstCompile</i> à notre tâche.» <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">BurstCompile</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> UpdatePositionAndHeadingJob : IJobChunk { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;PositionData2D&gt; PositionDataType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;HeadingData2D&gt; HeadingDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArchetypeChunkComponentType&lt;TargetPositionData&gt; TargetPositionDataType; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RotationLerpSpeed; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MovementLerpSpeed; }</code> </pre><br>  Le compilateur Burst nous donne des données multiples à instruction unique (SIMD);  des instructions machine qui peuvent fonctionner avec plusieurs ensembles de données d'entrée et créer plusieurs ensembles de données de sortie avec une seule instruction.  Cela nous aide à remplir plus de places sur le bus de cache 128 bits avec les données correctes.  Le compilateur Burst, combiné à une composition de données compatible avec le cache et à un système de travail, a permis à l'équipe d'augmenter considérablement sa productivité.  Voici le tableau qu'ils ont compilé en mesurant les performances après chaque étape de conversion. <br><br><img src="https://habrastorage.org/webt/bo/gu/8i/bogu8ir1i0apb5cwuhrjfjyk-bk.png"><br><br>  Cela signifie que Far North s'est complètement débarrassé des problèmes liés à l'interpolation de la position côté client et de la direction des zombies.  Leurs données sont désormais stockées sous une forme pratique pour la mise en cache et les lignes de cache ne sont remplies que de données utiles.  La charge est répartie sur tous les cœurs de CPU et le compilateur Burst produit un code machine hautement optimisé avec des instructions SIMD. <br><br><h4>  Far North Entertainment DOTS Trucs et astuces </h4><br><ul><li>  Commencez à penser en termes de flux de données, car dans ECS, les entités sont simplement des index de recherche dans des flux de données de composants parallèles. </li><li>  Imaginez ECS comme une base de données relationnelle dans laquelle les archétypes sont des tables, les composants sont des colonnes et les entités sont des indices dans une table (ligne). </li><li>  Organisez vos données en tableaux séquentiels pour utiliser le cache du processeur et la prélecture du matériel. </li><li>  Oubliez de vouloir créer des hiérarchies d'objets et d'essayer de trouver une solution commune avant de comprendre le vrai problème que vous essayez de résoudre. </li><li>  Pensez à la collecte des ordures.  Évitez de surallouer des tas dans les zones critiques pour les performances.  Utilisez plutôt les nouveaux conteneurs Unity natifs.  Mais attention, vous devez vous occuper du nettoyage manuel. </li><li>  Reconnaissez la valeur de vos abstractions, méfiez-vous des frais généraux liés à l'invocation de fonctions virtuelles. </li><li>  Utilisez tous les cœurs de processeur avec le système de tâches C #. </li><li>  Analysez le niveau matériel.  Le compilateur Burst génère-t-il réellement des instructions SIMD?  Utilisez l'inspecteur de rafale pour l'analyse. </li><li>  Arrêtez de gaspiller les lignes de cache en vide.  Considérez le regroupement des données dans des lignes de cache comme le regroupement des données dans des paquets UDP. </li></ul><br>  Le principal conseil que Anders Ericsson souhaite partager est un conseil plus général pour ceux dont le projet est déjà en développement: <i>«Essayez d'identifier les zones spécifiques de votre jeu où vous avez des problèmes de performances et voyez si vous pouvez appliquer DOTS spécifiquement dans cette zone isolée.</i>  <i>Vous n'avez pas besoin de changer toute la base de code! »</i> <br><br><h3>  Plans futurs </h3><br>  «Nous voulons utiliser DOTS dans d'autres domaines de notre jeu, et nous avons été ravis des annonces sur Unite concernant les animations DOTS, Unity Physics et Live Link.  Nous aimerions apprendre à convertir davantage d'objets de jeu en objets ECS, et il semble que Unity ait fait des progrès significatifs dans la mise en œuvre de cela », conclut Anders. <br><br>  Si vous avez des questions supplémentaires pour l'équipe du Grand Nord, nous vous recommandons de rejoindre leur <a href="https://discord.gg/jXJyxUh">Discord</a> ! <br>  Consultez la liste de lecture <a href="https://www.youtube.com/playlist%3Flist%3DPLX2vGYjWbI0S1wHRTyDiPtKLEPTWFi4cd">DOTS Unite Copenhagen</a> pour découvrir comment d'autres studios de jeux modernes utilisent DOTS pour créer de superbes jeux haute performance et comment les composants basés sur DOTS comme DOTS Physics, le nouveau Conversion Workflow et le compilateur Burst fonctionnent ensemble. <br><br>  La traduction est terminée et nous <b>vous invitons à assister à un <a href="https://otus.pw/YRoY/">webinaire gratuit</a> , dans lequel nous <i>vous expliquerons comment créer votre propre jeu de tir zombie dans une heure</i> .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484094/">https://habr.com/ru/post/fr484094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484076/index.html">Où stocker les crypto-monnaies: taxation des crypto-monnaies dans différents pays</a></li>
<li><a href="../fr484084/index.html">1C-Bitrix et une tentative de l'introduire</a></li>
<li><a href="../fr484088/index.html">Défilé de mots de passe (analyse d'environ 5 milliards de mots de passe de fuites)</a></li>
<li><a href="../fr484090/index.html">Nouvelle infrastructure informatique pour le centre de données de la poste russe</a></li>
<li><a href="../fr484092/index.html">Princes et nobles un peu habillés</a></li>
<li><a href="../fr484096/index.html">La bataille des deux Yakozun, ou Cassandra vs HBase. Expérience de l'équipe Sberbank</a></li>
<li><a href="../fr484100/index.html">Utilisation de l'interface dans le SDK Google Maps pour Android</a></li>
<li><a href="../fr484102/index.html">PHP vs Python vs Ruby on Rails: comparaison détaillée</a></li>
<li><a href="../fr484106/index.html">MVCC dans PostgreSQL-6. Le vide</a></li>
<li><a href="../fr484108/index.html">Encapsuleur Etherblade.net et substitution d'importation pour les composants réseau (deuxième partie)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>