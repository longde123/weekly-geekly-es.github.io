<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👫 🤽🏻 🖼️ Componentes de reação final 🧙🏿 🤹🏿 👋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que eu gosto no ecossistema React é que a IDEA está por trás de muitas decisões. Vários autores escrevem vários artigos em apoio à ordem existente e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Componentes de reação final</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434830/"><p>  O que eu gosto no ecossistema React é que a IDEA está por trás de muitas decisões.  Vários autores escrevem vários artigos em apoio à ordem existente e explicam por que tudo está “certo”, para que todos entendam que a festa está no caminho certo. </p><br><p>  Depois de algum tempo, a IDEA muda um pouco e tudo começa do começo. </p><br><p>  E o começo desta história é a separação de componentes em contêineres e não contêineres (popularmente chamados Dumb Components, desculpe pelo meu francês). </p><br><p><img src="https://habrastorage.org/webt/p3/cl/nl/p3clnlwh5eus18t7l4xkoxgc09a.jpeg"></p><a name="habracut"></a><br><h3 id="problema">  O problema </h3><br><p>  O problema é muito simples - testes de unidade.  Recentemente, houve algum movimento em direção aos testes de integração - bem, você sabe <em>"Escrever testes. Não muitos. Principalmente integração".</em>  .  Esta não é uma má ideia, e se o tempo for curto (e os testes não forem particularmente necessários) - é isso que você precisa fazer.  Vamos chamar de testes de fumaça - para verificar se nada <em>parece</em> explodir. </p><br><p> Se houver muito tempo e forem necessários testes, é melhor não seguir esse caminho, porque escrever bons testes de integração é muito, muito longo.  Só porque eles crescerão e crescerão, e para testar o terceiro botão à direita, primeiro você precisará clicar em 3 botões no menu e não se esqueça de fazer login.  Em geral - aqui está uma <u>explosão combinatória</u> em uma bandeja de prata. </p><br><p>  A solução aqui é uma e simples (por definição) - testes de unidade.  A capacidade de iniciar testes com algum estado pronto de alguma parte do aplicativo.  Mais precisamente, reduzir (restringir) a área de teste do Aplicativo ou do <em>Big Block</em> para algo pequeno - uma unidade, não importa o que seja.  Não é necessário usar enzimas - você pode executar testes no navegador, se a alma perguntar.  A coisa mais importante aqui é poder testar algo <em>isoladamente</em> .  E sem muita dificuldade. </p><br><p>  O isolamento é um dos pontos-chave no teste de unidade, e é por isso que os testes de unidade não gostam.  Eles não gostam disso por várias razões: </p><br><ul><li>  por exemplo, sua "unidade" é removida do aplicativo e não funciona em sua composição, mesmo quando seus próprios testes são verdes. </li><li>  ou, por exemplo, porque o isolamento é um cavalo tão esférico no vácuo que ninguém viu.  Como alcançá-lo e como mensurá-lo? </li></ul><br><p>  Pessoalmente, não vejo problemas aqui.  No primeiro parágrafo, é <em>claro,</em> você pode recomendar testes de integração, eles foram inventados para isso - para verificar como os componentes pré-testados são montados corretamente.  Você confia nos pacotes npm que testam, é claro, apenas eles próprios e não eles próprios como parte do seu aplicativo.  Como seus "componentes" diferem dos pacotes "não seus"? </p><br><p>  Com o segundo parágrafo, tudo é um pouco mais complicado.  E este artigo será exatamente sobre esse ponto (e tudo o que era antes - uma introdução) - sobre como tornar uma unidade " <em>unitária</em> " <em>testável</em> . </p><br><h3 id="razdelyay-i-vlastvuy">  Dividir e conquistar </h3><br><p>  A idéia de separar os componentes do React em "Container" e "Presentation" não é nova, bem descrita e já conseguiu ficar um pouco desatualizada.  Se tomarmos como base (o que 99% dos desenvolvedores fazem) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo de Dan Abramov</a> , o Componente de Apresentação: </p><br><ul><li>  Preocupam-se com a aparência das coisas </li><li> Podem conter componentes de apresentação e de contêiner <code>**</code> internos e geralmente têm sua própria marcação e estilos DOM) </li><li>  Slots de suporte (muitas vezes permitem a contenção por this.props.children) </li><li>  Independente do aplicativo (não possui dependências no restante do aplicativo, como ações ou lojas do Flux) </li><li>  Não dependa de dados (não especifique como os dados são carregados ou alterados) </li><li>  A interface é baseada em adereços (Receba dados e retornos de chamada exclusivamente via adereços) </li><li>  Frequentemente sem estado (raramente têm seu próprio estado (quando o fazem, é o estado da interface do usuário em vez de dados)) </li><li>  Frequentemente SFC (são escritos como componentes funcionais, a menos que precisem de estado, ganchos de ciclo de vida ou otimizações de desempenho) </li></ul><br><p>  Bem, os contêineres são toda a lógica, todo o acesso aos dados e todo o aplicativo em princípio. </p><br><blockquote>  Em um mundo ideal, os contêineres são o tronco e os componentes da apresentação são as folhas. </blockquote><p>  Existem dois pontos principais na definição de Dan: <em>"Independente de aplicativo"</em> , que é quase uma definição acadêmica de "unidade" e * "Pode conter outros componentes de apresentação e recipientes <code>**</code> " *, onde essas estrelas são especialmente interessantes. </p><br><blockquote>  (tradução gratuita) ** Nas versões anteriores do meu artigo, eu (Dan) disse que os componentes de apresentação deveriam conter apenas outros componentes de apresentação.  Acho que não.  O tipo de componente é os detalhes e pode mudar com o tempo.  Em geral, não compartilhe e tudo ficará bem. </blockquote><p>  Vamos lembrar o que acontece depois disso: </p><br><ul><li>  No livro de histórias, tudo cai, porque algum tipo de contêiner, no terceiro botão à esquerda, rasteja para o lado do qual não há nenhum.  Saudações especiais para graphql, react-router e outros react-intl. </li><li>  A capacidade de usar mount nos testes é perdida, porque renderiza tudo de A a Z e, novamente, em algum lugar nas profundezas da árvore de renderização, alguém faz alguma coisa e os testes caem. </li><li>  A capacidade de controlar o estado do aplicativo é perdida, pois (figurativamente falando) a capacidade de molhar seletores / resolvedores (especialmente com proxyquire) é perdida e todo o portão precisa estar molhado.  E isso é legal para testes de unidade. </li></ul><br><blockquote>  Se você acha que os problemas são um pouco exagerados, tente trabalhar em equipe quando esses contêineres, que serão usados ​​nos seus não contêineres, mudarem em outros departamentos e, como resultado, você e eles analisam os testes e não conseguem entender por que ontem tudo funcionou, e agora novamente. </blockquote><p>  Como resultado, você deve usar o superficial, que <em>por design</em> elimina todos os efeitos colaterais prejudiciais (e inesperados).  Aqui está um exemplo simples do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Por que eu sempre uso superficial"</a> </p><br><p>  Imagine que a dica de ferramenta renderize "?". Quando clicado, o próprio tipo será mostrado. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Tooltip <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { &lt;Tooltip&gt; hint: {veryImportantTextYouHaveToTest} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Tooltip&gt; }</span></span></code> </pre> <br><p>  Como testá-lo?  Monte + clique + verifique o que é visível.  Este é um teste de integração, não uma unidade, e a questão é como clicar em um componente "externo" para você.  Não há problema com o superficial, pois não há <em>cérebro</em> e o próprio "componente alienígena".  Mas existem cérebros aqui, já que a dica de ferramenta é um contêiner, enquanto o MyComponent é <em>praticamente uma</em> apresentação. </p><br><pre> <code class="javascript hljs">jest.mock(<span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> childlren});</code> </pre> <br><p>  Mas se você reagir, dica legal, não haverá problemas com o teste.  O "componente" tornou-se muito mais estúpido, muito mais curto, muito mais <em>finito</em> . </p><br><p>  <strong>Componente final</strong> </p><br><ul><li>  um componente com um tamanho conhecido, que pode incluir outros componentes finais anteriormente conhecidos ou que não os contenham. </li><li>  não contém outros contêineres, pois eles contêm um estado não controlado e um tamanho "aumentado", ou seja,  tornar o componente atual <em>infinito</em> . </li><li>  caso contrário, é um componente de apresentação regular.  De fato, exatamente como descrito na <em>primeira</em> versão do artigo de Dan. </li></ul><br><p>  O componente final é apenas uma engrenagem retirada de um grande mecanismo. </p><br><p>  A questão toda é como retirá-lo. </p><br><h3 id="reshenie-1---di">  Solução 1 - DI </h3><br><p>  Meu favorito é injeção de dependência.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dan também o ama</a> .  Em geral, isso não é DI, mas "slots".  Em poucas palavras - não é necessário usar recipientes dentro da apresentação - eles precisam ser <em>injetados</em> lá.  E nos testes será possível injetar outra coisa. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    mount     const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); //     shallow,       //     mount ? , ,   wiring? const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</span></span></code> </pre> <br><p>  É exatamente esse o caso quando <em>"os contêineres são o tronco e os componentes da apresentação são folhas"</em> </p><br><h3 id="reshenie-2---granicy">  Solução 2 - Limites </h3><br><p>  O DI geralmente pode ser legal.  Provavelmente agora% username% pensa em como pode ser aplicado na base de código atual e a solução não foi inventada ... </p><br><p>  Nesses casos, o <strong>Borders</strong> salvará você. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Boundary = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'test'</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : children <span class="hljs-comment"><span class="hljs-comment">// //  jest.mock ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</span></span></code> </pre> <br><p>  Aqui, em vez de "slots", todos os "pontos de transição" simplesmente se transformam em Fronteira, que renderiza <em>qualquer coisa</em> durante os testes.  <em>Declarativamente</em> , e exatamente o que você precisa para "tirar o equipamento". </p><br><h3 id="reshenie-3---tier">  Solução 3 - Camada </h3><br><p>  As bordas podem ser um pouco difíceis, e pode ser mais fácil torná-las um pouco mais inteligentes adicionando um pouco de conhecimento sobre a Camada. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> tier === currentTier; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> WrapperComponent =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process.env.NODE_ENV !== </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'test'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || checkTier(tier</span></span></span><span class="hljs-function">)) &amp;&amp; &lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WrapperComponent</span></span></span><span class="hljs-function">{...</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">} /&gt; ); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PageChrome</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASideContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = withTier(<span class="hljs-string"><span class="hljs-string">'Page'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChromeContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(PageChrome);</code> </pre> <br><p>  Sob o nome Camada / Camada, pode haver coisas diferentes - recurso, duck, módulo ou apenas essa camada / camada.  O ponto não é importante, o principal é que você pode puxar a marcha, talvez não uma, mas o número final, de <em>alguma forma</em> traçando uma linha entre o que você precisa e o que não precisa (para testes diferentes, essa é uma borda diferente). </p><br><p>  E nada impede de marcar esses limites de alguma maneira diferente. </p><br><h3 id="reshenie-4separate-concerns">  Solução 4 - Preocupações separadas </h3><br><p>  Se a solução (por definição) reside na separação de entidades - o que acontecerá se as tomarmos e separarmos? </p><br><p>  Os "contêineres", dos quais tanto não gostamos, são geralmente chamados de <em>contêineres</em> .  E se não - nada impede agora de começar a nomear componentes de alguma maneira mais sonora.  Ou eles têm um determinado padrão em seu nome - Connect (WrappedComonent) ou GraphQL / Query. </p><br><p>  E se, em tempo de execução, traçar uma linha entre entidades com base em um nome? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChrome = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-comment"><span class="hljs-comment">// remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</span></span></code> </pre> <br><p>  Além de uma linha nos testes, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reag-remock</a> removerá todos os recipientes que possam interferir nos testes. </p><br><p>  Em princípio, essa abordagem pode ser usada para testar os próprios contêineres - você só precisa <em>remover</em> tudo, exceto o primeiro. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createElement, remock} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-remock'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // ""     &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // "" : null )} &lt;/ContainerCondition.Consumer&gt; )</span></span></code> </pre> <br><p>  Mais uma vez - algumas linhas e equipamentos removidos. </p><br><h2 id="itogo">  Total </h2><br><p>  No ano passado, o teste de componentes do React se tornou mais complicado, especialmente para montagem - você precisa sobrescrever todos os 10 provedores, contextos e está ficando cada vez mais difícil testar o componente certo no estilo certo - há muitas cordas para puxar. <br>  Alguém cospe e entra no mundo raso.  Alguém acenou com as mãos em testes de unidade e transferiu tudo para Cypress (ande como ande!). </p><br><p>  Outra pessoa cutuca um dedo com a reação, diz que esses são <em>efeitos algébricos</em> e você pode fazer o que quiser.  Todos os exemplos acima são essencialmente o uso desses <em>efeitos</em> e zombes <em>algébricos</em> .  Para mim e DI estes são moki. </p><br><blockquote>  PS: Este post foi escrito como uma resposta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aos comentários no React / RFC sobre o fato de que a equipe do React quebrou tudo, e todos os polímeros de lá também</a> <br>  PPS: Este post é na verdade uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradução muito gratuita de outro</a> <br>  PPPS: em geral, para isolamento real, observe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rewiremock</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434830/">https://habr.com/ru/post/pt434830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434818/index.html">Acidente no CenturyLink Data Center causou 911 falhas no serviço</a></li>
<li><a href="../pt434822/index.html">Programa da RPC "Carros com novas fontes de energia". O que esperar em 2019</a></li>
<li><a href="../pt434824/index.html">Engenharia Politécnica. Modelagem de processos sócio-políticos por circuitos elétricos</a></li>
<li><a href="../pt434826/index.html">O campo da cama na hora certa, ou 5 sinais de problemas ocultos na equipe</a></li>
<li><a href="../pt434828/index.html">Torne-se um profissional. Hábitos úteis dos designers de UX</a></li>
<li><a href="../pt434836/index.html">Anotação da versão maravilhosa na JPA</a></li>
<li><a href="../pt434838/index.html">Criando um bot para participar da Russian AI Cup 2018 CodeBall</a></li>
<li><a href="../pt434840/index.html">Como eu fiz o "Seu Diário" - ou a situação no mercado de diários eletrônicos</a></li>
<li><a href="../pt434842/index.html">As fazendas da cidade podem ser extremamente eficazes, mas não agora</a></li>
<li><a href="../pt434844/index.html">Recuperação de habilidades cognitivas de 100 pacientes (tradução de um artigo de Dale Bredesen)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>