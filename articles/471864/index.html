<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüíª üìù ü§òüèæ Generador de analizador PEG üï∫üèø üëÄ üë®üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ahora que he esbozado los conceptos b√°sicos de un analizador patentado, pasemos a generar sus m√©todos a partir de la gram√°tica, como promet√≠. Tambi√©n ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generador de analizador PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471864/"><p> Ahora que he esbozado los conceptos b√°sicos de un analizador patentado, pasemos a generar sus m√©todos a partir de la gram√°tica, como promet√≠.  Tambi√©n mostrar√© c√≥mo implementar un analizador Packrat usando el decorador <code>@memoize</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Contenido de la serie Python PEG Parser</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analizadores de clavijas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n del analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generador de analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visualizaci√≥n del analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gram√°tica de PEG recursiva izquierda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Agregar acciones a la gram√°tica PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meta gram√°tica para el analizador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementando las caracter√≠sticas restantes de PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PEG en Core Developer Sprint</a> </li></ul></div></div><br><p>  La √∫ltima vez, vimos algunos m√©todos de analizador sint√°ctico.  Con algunas restricciones que eliminaremos un poco m√°s adelante, son f√°ciles de generar autom√°ticamente a partir de la gram√°tica. </p><a name="habracut"></a><br><p>  Necesitamos dos cosas: algo que lea la gram√°tica y construya una estructura de datos apropiada;  y algo que toma esta estructura de datos y genera un analizador sint√°ctico.  Tambi√©n necesitamos otros m√©todos auxiliares, pero no son interesantes, por lo que los omitir√©. </p><br><p>  Entonces, estamos creando un compilador compilador simple.  Simplificar√© un poco la notaci√≥n gramatical en la medida en que solo tengamos reglas y alternativas;  En realidad, esto es suficiente para la gram√°tica del juguete que utilic√© en las partes anteriores: </p><br><pre> <code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  Usando la notaci√≥n completa, podemos describir la gram√°tica como: </p><br><pre> <code class="plaintext hljs">grammar: rule+ ENDMARKER rule: NAME ':' alternative ('|' alternative)* NEWLINE alternative: item+ item: NAME | STRING</code> </pre> <br><p>  Este es nuestro primer meta-gram√°tica (gram√°tica para gram√°ticas), y nuestro generador de analizadores ser√° un metacompilador (un compilador es un programa que traduce programas de un lenguaje a otro; un metacompilador es un compilador donde la entrada es una gram√°tica, y la salida es un analizador sint√°ctico). </p><br><p>  Una manera f√°cil de describir una metagram√°tica es usar solo los tipos de datos integrados: la parte correcta de la regla es una lista de listas de elementos, cada uno de los cuales puede ser solo una cadena.  (Por cierto, podemos separar <code>NAME</code> y <code>STRING</code> comprobando si el primer car√°cter es una comilla) </p><br><p>  Para las reglas, uso la clase de <code>Rule</code> simple, y toda la gram√°tica es una lista de dichos objetos.  Aqu√≠ est√° la clase <code>Rule</code> , excluyendo <code>__repr__</code> y <code>__eq__</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rule</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, alts)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.alts = alts</code> </pre> <br><p>  Y aqu√≠ est√° la clase <code>GrammarParser</code> que lo usa: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GrammarParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grammar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rule := self.rule(): rules = [rule] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> rule := self.rule(): rules.append(rule) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.expect(ENDMARKER): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rules <span class="hljs-comment"><span class="hljs-comment"># &lt;------------- final result self.reset(pos) return None def rule(self): pos = self.mark() if name := self.expect(NAME): if self.expect(":"): if alt := self.alternative(): alts = [alt] apos = self.mark() while (self.expect("|") and (alt := self.alternative())): alts.append(alt) apos = self.mark() self.reset(apos) if self.expect(NEWLINE): return Rule(name.string, alts) self.reset(pos) return None def alternative(self): items = [] while item := self.item(): items.append(item) return items def item(self): if name := self.expect(NAME): return name.string if string := self.expect(STRING): return string.string return None</span></span></code> </pre> <br><p>  Presta atenci√≥n al uso de <code>ENDMARKER</code> .  All√≠ me aseguro de que no quede nada despu√©s de la √∫ltima regla (y esto puede suceder si hay un error tipogr√°fico en la gram√°tica).  Tambi√©n se√±al√© el lugar donde el m√©todo <code>grammar()</code> devuelve una lista de reglas.  Todo lo dem√°s es muy similar a la clase <code>ToyParser</code> del √∫ltimo art√≠culo, por lo que no me detendr√© en eso.  Solo observe que <code>item()</code> devuelve una cadena, la <code>alternative()</code> devuelve una lista de cadenas y la variable <code>alts</code> dentro de <code>rule()</code> recopila una lista de la lista de cadenas.  Luego, el m√©todo <code>rule()</code> combina el nombre de la regla (string) y la convierte en un objeto <code>Rule</code> . </p><br><p>  Si aplicamos este algoritmo a nuestra gram√°tica de juguetes, el m√©todo <code>grammar()</code> devolver√° la siguiente lista de reglas: </p><br><pre> <code class="plaintext hljs">[ Rule('statement', [['assignment'], ['expr'], ['if_statement']]), Rule('expr', [['term', "'+'", 'expr'], ['term', "'-'", 'term'], ['term']]), Rule('term', [['atom', "'*'", 'term'], ['atom', "'/'", 'atom'], ['atom']]), Rule('atom', [['NAME'], ['NUMBER'], ["'('", 'expr', "')'"]]), Rule('assignment', [['target', "'='", 'expr']]), Rule('target', [['NAME']]), Rule('if_statement', [["'if'", 'expr', "':'", 'statement']]), ]</code> </pre> <br><p>  Ahora que tenemos la parte de an√°lisis de nuestro metacompilador, hagamos un generador de c√≥digo.  Juntos forman un metacompilador elemental: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_parser_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rules)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">f"class ToyParser(Parser):"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rules: print() print(<span class="hljs-string"><span class="hljs-string">f" @memoize"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" def </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name}</span></span></span><span class="hljs-string">(self):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" pos = self.mark()"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: items = [] print(<span class="hljs-string"><span class="hljs-string">f" if (True"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> alt: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'"'</span></span>, <span class="hljs-string"><span class="hljs-string">"'"</span></span>): print(<span class="hljs-string"><span class="hljs-string">f" and self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: var = item.lower() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items: var += str(len(items)) items.append(var) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item.isupper(): print(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">())"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" ):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"return Node(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name!r}</span></span></span><span class="hljs-string">, [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">', '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.join(items)}</span></span></span><span class="hljs-string">])"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" self.reset(pos)"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" return None"</span></span>)</code> </pre> <br><p>  Este c√≥digo es bastante feo, pero funciona (m√°s o menos), y en el futuro lo reescribir√© de todos modos. </p><br><p>  Algunas l√≠neas dentro del <code>for alt in rule.alts</code> pueden requerir explicaci√≥n: para cada elemento de la alternativa, elegimos una de las 3 opciones: </p><br><ul><li>  si el elemento es un literal de cadena, por ejemplo <code>'+'</code> , generamos <code>self.expect('+')</code> </li><li>  si el elemento est√° completamente en may√∫scula, por ejemplo <code>NAME</code> , generamos <code>(name := self.expect(NAME))</code> </li><li>  de lo contrario, por ejemplo, si es <code>expr</code> , generamos <code>(expr := self.expr())</code> </li></ul><br><p>  Si hay varios elementos con el mismo nombre en una variante (por ejemplo, <code>term '-' term</code> ), entonces agregamos un d√≠gito al segundo.  Tambi√©n hay un peque√±o error aqu√≠ que corregir√© en el pr√≥ximo episodio. </p><br><p>  Aqu√≠ hay un poco del resultado de su trabajo (toda la clase ser√≠a muy aburrida).  No se preocupe por el c√≥digo redundante <code>if (True and</code> ... <code>)</code> que se necesita para que cada condici√≥n generada pueda comenzar con <code>and</code> .  El compilador de bytes de Python optimiza esto. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> @memoize <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (assignment := self.assignment()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [assignment]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (expr := self.expr()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [expr]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (if_statement := self.if_statement()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [if_statement]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ...</code> </pre> <br><p>  Presta atenci√≥n al decorador <code>@memoize</code> : lo <code>@memoize</code> para pasar a otro tema: usar la memorizaci√≥n para hacer que el analizador generado sea lo suficientemente r√°pido. </p><br><p>  Aqu√≠ est√° la funci√≥n <code>memoize()</code> que implementa este decorador: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  Como en otros decoradores, contiene una funci√≥n anidada que reemplaza (o envuelve) una funci√≥n decorada, por ejemplo, el m√©todo de la <code>statement()</code> de la clase <code>ToyParser</code> .  Dado que la funci√≥n que se est√° envolviendo es un m√©todo, el contenedor tambi√©n es en realidad un m√©todo: su primer argumento se llama <code>self</code> y se refiere a la instancia de <code>ToyParser</code> para la que se llama al m√©todo decorado. </p><br><p>  El reiniciador almacena en cach√© el resultado de la llamada al m√©todo para cada posici√≥n de entrada, ¬°por eso se llama el analizador de paquete!  [aprox.  trans.  packrat es un "ladr√≥n", pero este t√©rmino no se traduce en fuentes en ruso.] Cach√© es un diccionario de diccionarios, que se almacena en una instancia de <code>Parser</code> .  La clave del diccionario externo es la posici√≥n en el flujo de datos de entrada;  Tambi√©n agregu√© <code>self.memos = {}</code> al <code>Parser .__ init__()</code> para inicializarlo.  Los diccionarios internos se agregan seg√∫n sea necesario;  sus claves consisten en un m√©todo y sus argumentos.  (No hay argumentos en el dise√±o actual, pero podr√≠amos memorizar la funci√≥n <code>expect()</code> que tiene una, lo cual es bastante trivial) </p><br><p>  El resultado del m√©todo del analizador se presenta en forma de tupla, porque en realidad hay dos valores: el resultado en s√≠ (para nuestros m√©todos generados, este es <code>Node</code> para la regla de coincidencia) y un puntero a la posici√≥n actual en la secuencia de entrada, que obtenemos de <code>self.mark()</code> .  Por lo tanto, almacenamos en cach√© tanto el valor de retorno ( <code>res</code> ) como la nueva posici√≥n ( <code>endpos</code> ) en el diccionario interno con valores memorizados.  En llamadas posteriores al mismo m√©todo de an√°lisis con los mismos argumentos en la misma posici√≥n de entrada, los tomaremos del cach√©.  Para hacer esto, simplemente mueva el puntero a la posici√≥n de entrada usando <code>self.reset()</code> y mire en el cach√©. </p><br><p>  Tambi√©n es importante almacenar en cach√© los resultados negativos; de hecho, la mayor√≠a de las llamadas ser√°n negativas.  En este caso, el valor de retorno es <code>None</code> y la posici√≥n de entrada no cambia.  Puede agregar <code>assert</code> para verificar esto. </p><br><p>  Nota  En Python, es costumbre implementar un cach√© en una variable local en la funci√≥n <code>memoize()</code> .  En nuestro caso, esto no funcionar√°: como descubr√≠ al final de la depuraci√≥n, cada instancia de <code>Parser</code> debe tener su propio cach√©.  Sin embargo, puede deshacerse de los diccionarios anidados utilizando ( <code>pos</code> , <code>func</code> , <code>args</code> ) como clave. </p><br><p>  La pr√≥xima semana preparar√© c√≥digos y trazas para mostrar c√≥mo se ensambla y ejecuta todo esto al analizar un programa de ejemplo.  Todav√≠a estoy buscando una mejor manera de visualizar la colaboraci√≥n del b√∫fer de tokenizaci√≥n, el analizador y el cach√©.  Tal vez pueda crear un gif animado en ASCII en lugar de solo mostrar las listas de seguimiento como texto. </p><br><p>  Licencia para este art√≠culo y c√≥digo citado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471864/">https://habr.com/ru/post/471864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471852/index.html">Noticias del mundo de OpenStreetMap No. 481 (01/10/2019 - 07/10/2019)</a></li>
<li><a href="../471854/index.html">Heat Death 5G</a></li>
<li><a href="../471856/index.html">Resolvemos las 42 versiones del rompecabezas de pociones de Harry Potter</a></li>
<li><a href="../471858/index.html">RabbitMQ vs. Kafka: conmutaci√≥n por error y alta disponibilidad en cl√∫steres</a></li>
<li><a href="../471860/index.html">Analizadores de clavijas</a></li>
<li><a href="../471866/index.html">Visualizaci√≥n del analizador PEG</a></li>
<li><a href="../471868/index.html">Gen√©tica del amor: conflicto entre g√©neros como base para la cooperaci√≥n en parejas de p√°jaros mon√≥gamos</a></li>
<li><a href="../471870/index.html">Uso efectivo de libdispatch</a></li>
<li><a href="../471874/index.html">C√≥mo pasamos por alto las pautas de revisi√≥n y lanzamos un servidor en el tel√©fono</a></li>
<li><a href="../471876/index.html">PDU y All-All-All: distribuci√≥n de energ√≠a en rack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>