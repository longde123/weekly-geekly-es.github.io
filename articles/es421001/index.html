<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õÖÔ∏è üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üå≠ RPC: una ocasi√≥n para probar nuevos en C ++ 14/17 üé≠ ü§∑üèø üßòüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace varios a√±os, los desarrolladores de C ++ recibieron el tan esperado est√°ndar C ++ 11, que trajo muchas cosas nuevas. Y me interesaba cambiar r√°pi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RPC: una ocasi√≥n para probar nuevos en C ++ 14/17</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421001/"><img src="https://habrastorage.org/webt/r5/fg/-w/r5fg-wsld9ujbwxghq54s-kpaso.jpeg" width="250" height="180" align="left">  Hace varios a√±os, los desarrolladores de C ++ recibieron el tan esperado est√°ndar C ++ 11, que trajo muchas cosas nuevas.  Y me interesaba cambiar r√°pidamente a su uso en las tareas cotidianas.  Vaya a C ++ 14 y 17 esto no fue as√≠.  Parec√≠a que no hab√≠a un conjunto de caracter√≠sticas que ser√≠an de inter√©s.  En la primavera, decid√≠ mirar las innovaciones del lenguaje e intentar algo.  Para experimentar con innovaciones, ten√≠a que idear una tarea para usted.  No tuve que pensar mucho.  Se decidi√≥ escribir su RPC con estructuras de datos personalizadas como par√°metros y sin usar macros y generaci√≥n de c√≥digo, todo en C ++.  Esto fue posible gracias a las nuevas caracter√≠sticas del lenguaje. <br><br>  La idea, implementaci√≥n, retroalimentaci√≥n con Reddit, mejoras: todo apareci√≥ en la primavera, a principios del verano.  Al final, lograron terminar el post en Habr. <br><br>  ¬øHas pensado en tu propio RPC?  Quiz√°s el material de la publicaci√≥n lo ayudar√° a determinar el objetivo, los m√©todos, los medios y decidir a favor del terminado o implementar algo usted mismo ... <br><a name="habracut"></a><br><h1>  Introduccion </h1><br>  RPC (llamada a procedimiento remoto) no es un tema nuevo.  Hay muchas implementaciones en diferentes lenguajes de programaci√≥n.  Las implementaciones utilizan varios formatos de datos y modos de transporte.  Todo esto se puede reflejar en algunos puntos: <br><br><ul><li>  Serializaci√≥n / Deserializaci√≥n </li><li>  Transporte </li><li>  Ejecuci√≥n remota de m√©todos </li><li>  Resultado devuelto </li></ul><br>  La implementaci√≥n est√° determinada por el objetivo deseado.  Por ejemplo, puede establecerse el objetivo de garantizar una alta velocidad de llamada a un m√©todo remoto y sacrificar la usabilidad, o viceversa, para proporcionar la m√°xima comodidad para escribir c√≥digo, posiblemente perdiendo un poco de rendimiento.  Los objetivos y las herramientas son diferentes ... Quer√≠a comodidad y un rendimiento aceptable. <br><br><h1>  Implementaci√≥n </h1><br>  A continuaci√≥n se detallan algunos pasos para implementar RPC en C ++ 14/17, y se hace hincapi√© en algunas de las innovaciones de lenguaje que hicieron que apareciera este material. <br><br>  El material est√° destinado a aquellos que por alguna raz√≥n est√°n interesados ‚Äã‚Äãen su RPC y, quiz√°s, hasta ahora, necesitan informaci√≥n adicional.  En los comentarios, ser√≠a interesante ver una descripci√≥n de la experiencia de otros desarrolladores que enfrentan tareas similares. <br><br><h2>  Serializaci√≥n </h2><br>  Antes de comenzar a escribir c√≥digo, formar√© una tarea: <br><br><ul><li>  Todos los par√°metros del m√©todo y el resultado devuelto se pasan a trav√©s de la tupla. </li><li>  Los m√©todos llamados en s√≠ mismos no est√°n obligados a aceptar y devolver tuplas. </li><li>  El resultado de empacar una tupla debe ser un b√∫fer cuyo formato no sea fijo </li></ul><br>  El siguiente es un c√≥digo de serializador de cadena simplificado. <br><br><div class="spoiler">  <b class="spoiler_title">string_serializer</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer</span></span></code> </pre> </div></div><br>  Y el c√≥digo de funci√≥n principal que demuestra el funcionamiento del serializador. <br><br><div class="spoiler">  <b class="spoiler_title">Funci√≥n principal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple args{<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"Test string !!!"</span></span>}, <span class="hljs-number"><span class="hljs-number">3.14</span></span>}; rpc::packer::string_serializer serializer; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = serializer.save(args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Pack data: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{begin(pack), end(pack)} &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args) params; serializer.load(pack, params); <span class="hljs-comment"><span class="hljs-comment">// For test { auto pack = serializer.save(params); std::cout &lt;&lt; "Deserialized pack: " &lt;&lt; std::string{begin(pack), end(pack)} &lt;&lt; std::endl; } } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></code> </pre></div></div><br>  <b>Acentos acreditados</b> <br><br>  En primer lugar, debe determinar el b√∫fer con el que se realizar√° todo el intercambio de datos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type</span></span></code> </pre><br>  El serializador tiene m√©todos para guardar una tupla en el b√∫fer (guardar) y cargarla desde el b√∫fer (cargar) <br><br>  El m√©todo de guardar toma una tupla y devuelve un b√∫fer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... T&gt; type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T ... &gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str = to_string(tuple, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_index_sequence&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (T)&gt;{}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {begin(str), end(str)}; }</code> </pre><br>  Una tupla es una plantilla con un n√∫mero variable de par√°metros.  Tales patrones aparecieron en C ++ 11 y funcionaron bien.  Aqu√≠ debe ir de alguna manera a trav√©s de todos los elementos de dicha plantilla.  Puede haber varias opciones.  Usar√© una de las caracter√≠sticas de C ++ 14: una secuencia de enteros (√≠ndices).  El tipo make_index_sequence ha aparecido en la biblioteca est√°ndar, lo que permite obtener la siguiente secuencia: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ints</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">integer_sequence</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_integer_sequence</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:integer_sequence&lt;T, <span class="hljs-comment"><span class="hljs-comment">/* a sequence 0, 1, 2, ..., N-1 */</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> make_index_sequence = make_integer_sequence&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, N&gt;;</code> </pre><br>  Se puede implementar un similar en C ++ 11 y luego llevarlo de un proyecto a otro. <br><br>  Tal secuencia de √≠ndices hace posible "atravesar" la tupla: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... I&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::index_sequence&lt;I ... &gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> put_item = [&amp;stream] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(i)&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;) stream &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::quoted(i) &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stream &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; }; (put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(stream.str()); }</code> </pre><br>  El m√©todo to_string utiliza varias caracter√≠sticas de los √∫ltimos est√°ndares de C ++. <br><br>  <b>Acentos acreditados</b> <br><br>  En C ++ 14, se hizo posible usar auto como par√°metros para las funciones lambda.  Esto a menudo no era suficiente, por ejemplo, cuando se trabaja con los algoritmos de la biblioteca est√°ndar. <br><br>  Apareci√≥ una <b>convoluci√≥n</b> en C ++ 17, que le permite escribir c√≥digo como: <br><br><pre> <code class="cpp hljs">(put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... );</code> </pre><br>  En el fragmento dado, se llama a la funci√≥n put_item lambda para cada uno de los elementos de la tupla transferida.  Esto garantiza una secuencia independiente de la plataforma y el compilador.  Algo similar podr√≠a escribirse en C ++ 11. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ‚Ä¶ T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unused</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp; ‚Ä¶ )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// ... unused(put_item(std::get&lt;I&gt;(tuple)) ... );</span></span></code> </pre><br>  Pero en qu√© orden se almacenar√≠an los elementos depender√≠a del compilador. <br><br>  Muchos alias aparecieron en la biblioteca est√°ndar de C ++ 17, por ejemplo, decay_t, lo que redujo los registros de la forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> decay&lt;T&gt;::type</code> </pre><br>  El deseo de escribir construcciones m√°s cortas tiene un lugar para estar.  El dise√±o de la plantilla, donde se encuentran un par de nombres de tipos y plantillas en una l√≠nea, separados por dos puntos y corchetes, parece espeluznante.  ¬øC√≥mo puedes asustar a algunos de tus colegas?  En el futuro, prometen reducir la cantidad de lugares donde necesita escribir la plantilla, typename. <br><br>  El deseo de concisi√≥n dio otra construcci√≥n interesante del lenguaje "si constexpr", evita escribir muchas especializaciones privadas de plantillas. <br><br>  Hay un punto interesante.  A muchos se les ha ense√±ado que las construcciones de conmutadores y similares no son muy buenas en t√©rminos de escalabilidad de c√≥digo.  Es preferible utilizar el polimorfismo en tiempo de ejecuci√≥n / tiempo de compilaci√≥n y la sobrecarga con argumentos a favor de la "elecci√≥n correcta".  Y luego "si constexpr" ... La posibilidad de compacidad no deja a todos indiferentes.  La posibilidad del lenguaje no significa la necesidad de usarlo. <br><br>  Era necesario escribir una serializaci√≥n separada para el tipo de cadena.  Para un trabajo conveniente con cadenas, por ejemplo, al guardar en un flujo y leerlo, apareci√≥ la funci√≥n std :: quoted.  Le permite filtrar cadenas y hace posible guardar en una secuencia y cargar fechas desde ella sin pensar en el delimitador. <br><br>  Puede detenerse con la descripci√≥n de la serializaci√≥n por ahora.  La deserializaci√≥n (carga) se implementa de manera similar. <br><br><h2>  Transporte </h2><br>  El transporte es simple.  Esta es una funci√≥n que recibe y devuelve un b√∫fer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-comment"><span class="hljs-comment">// ... using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type</span></span></code> </pre><br>  Al formar tal objeto "ejecutor" usando std :: bind, funciones lambda, etc., puede usar cualquiera de sus implementaciones de transporte.  No se considerar√°n los detalles de la implementaci√≥n del transporte dentro de esta publicaci√≥n.  Puede echar un vistazo a la implementaci√≥n de RPC completada, un enlace al que se proporcionar√° al final. <br><br><h2>  Cliente </h2><br>  A continuaci√≥n se muestra un c√≥digo de cliente de prueba.  El cliente genera solicitudes y las env√≠a al servidor, teniendo en cuenta el transporte seleccionado.  En el c√≥digo de prueba a continuaci√≥n, todas las solicitudes de los clientes se muestran en la consola.  Y en el siguiente paso de implementaci√≥n, el cliente ya se comunicar√° directamente con el servidor. <br><br><div class="spoiler">  <b class="spoiler_title">Cliente</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TPacker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: client(type::executor executor) : executor_{executor} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-function">result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;func_name, TArgs &amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(func_name, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args) ... ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = packer_.save(request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> responce = executor_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {responce}; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = TPacker; packer_type packer_; type::executor executor_; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: result(type::buffer buffer) : buffer_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(tuple)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: packer_type packer_; type::buffer buffer_; }; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc</span></span></code> </pre></div></div><br>  El cliente se implementa como una clase de plantilla.  El par√°metro de plantilla es un serializador.  Si es necesario, la clase se puede rehacer no en la plantilla uno y pasar al constructor un objeto que implemente el serializador. <br><br>  En la implementaci√≥n actual, el constructor de la clase acepta un objeto en ejecuci√≥n.  El contratista oculta la implementaci√≥n del transporte por s√≠ mismo y hace posible en este punto del c√≥digo no pensar en m√©todos para intercambiar datos entre procesos.  En el caso de prueba, la implementaci√≥n de transporte muestra solicitudes a la consola. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [] (rpc::type::buffer buffer) { <span class="hljs-comment"><span class="hljs-comment">// Print request data std::cout &lt;&lt; "Request pack: " &lt;&lt; std::string{begin(buffer), end(buffer)} &lt;&lt; std::endl; return buffer; };</span></span></code> </pre><br>  El c√≥digo personalizado a√∫n no ha tratado de aprovechar el resultado del trabajo del cliente, ya que no hay de d√≥nde obtenerlo. <br><br>  <b>M√©todo de llamada del cliente:</b> <br><br><ul><li>  El uso del serializador incluye el nombre del m√©todo llamado y sus par√°metros. </li><li>  El uso del objeto en ejecuci√≥n env√≠a una solicitud al servidor y recibe una respuesta </li><li>  pasa la respuesta recibida a una clase que recupera el resultado recibido </li></ul><br>  La implementaci√≥n b√°sica del cliente est√° lista.  Algo m√°s queda.  M√°s sobre esto m√°s tarde. <br><br><h2>  Servidor </h2><br>  Antes de comenzar a considerar los detalles de implementaci√≥n del lado del servidor, sugiero una mirada r√°pida y diagonal al ejemplo completo de interacci√≥n cliente-servidor. <br><br>  Por simplicidad, la demostraci√≥n es todo en un proceso.  La implementaci√≥n de transporte es una funci√≥n lambda que pasa un b√∫fer entre el cliente y el servidor. <br><br><div class="spoiler">  <b class="spoiler_title">Interacci√≥n cliente-servidor.</b>  <b class="spoiler_title">Caso de prueba</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;cstdlib&gt; #include &lt;functional&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;tuple&gt; #include &lt;vector&gt; #include &lt;utility&gt; namespace rpc::type { using buffer = std::vector&lt;char&gt;; using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type namespace rpc::detail { template &lt;typename&gt; struct function_meta; template &lt;typename TRes, typename ... TArgs&gt; struct function_meta&lt;std::function&lt;TRes (TArgs ... )&gt;&gt; { using result_type = std::decay_t&lt;TRes&gt;; using args_type = std::tuple&lt;std::decay_t&lt;TArgs&gt; ... &gt;; using request_type = std::tuple&lt;std::string, std::decay_t&lt;TArgs&gt; ... &gt;; }; } // namespace rpc::detail namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer namespace rpc { template &lt;typename TPacker&gt; class client final { private: class result; public: client(type::executor executor) : executor_{executor} { } template &lt;typename ... TArgs&gt; result call(std::string const &amp;func_name, TArgs &amp;&amp; ... args) { auto request = std::make_tuple(func_name, std::forward&lt;TArgs&gt;(args) ... ); auto pack = packer_.save(request); auto responce = executor_(std::move(pack)); return {responce}; } private: using packer_type = TPacker; packer_type packer_; type::executor executor_; class result final { public: result(type::buffer buffer) : buffer_{std::move(buffer)} { } template &lt;typename T&gt; auto as() const { std::tuple&lt;std::decay_t&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); return std::move(std::get&lt;0&gt;(tuple)); } private: packer_type packer_; type::buffer buffer_; }; }; template &lt;typename TPacker&gt; class server final { public: template &lt;typename ... THandler&gt; server(std::pair&lt;char const *, THandler&gt; const &amp; ... handlers) { auto make_executor = [&amp;packer = packer_] (auto const &amp;handler) { auto executor = [&amp;packer, function = std::function{handler}] (type::buffer buffer) { using meta = detail::function_meta&lt;std::decay_t&lt;decltype(function)&gt;&gt;; typename meta::request_type request; packer.load(buffer, request); auto response = std::apply([&amp;function] (std::string const &amp;, auto &amp;&amp; ... args) { return function(std::forward&lt;decltype(args)&gt;(args) ... ); }, std::move(request) ); return packer.save(std::make_tuple(std::move(response))); }; return executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); } type::buffer execute(type::buffer buffer) { std::tuple&lt;std::string&gt; pack; packer_.load(buffer, pack); auto func_name = std::move(std::get&lt;0&gt;(pack)); auto const iter = handlers_.find(func_name); if (iter == end(handlers_)) throw std::runtime_error{"Function \"" + func_name + "\" not found."}; return iter-&gt;second(std::move(buffer)); } private: using packer_type = TPacker; packer_type packer_; using handlers_type = std::map&lt;std::string, type::executor&gt;; handlers_type handlers_; }; } // namespace rpc int main() { try { using packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ std::pair{"hello", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"hello\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return "Hello " + s + "!"; }}, std::pair{"to_int", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"to_int\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return std::stoi(s); }} }; auto executor = [&amp;server] (rpc::type::buffer buffer) { return server.execute(std::move(buffer)); }; rpc::client&lt;packer_type&gt; client{std::move(executor)}; std::cout &lt;&lt; client.call("hello", std::string{"world"}).as&lt;std::string&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; "Convert to int: " &lt;&lt; client.call("to_int", std::string{"100500"}).as&lt;int&gt;() &lt;&lt; std::endl; } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></span></span></code> </pre></div></div><br>  En la implementaci√≥n anterior de la clase de servidor, lo m√°s interesante es su constructor y el m√©todo de ejecuci√≥n. <br><br>  <b>Constructor de clase de servidor</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> make_executor = [&amp;packer = packer_] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;handler) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;packer, function = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function{handler}] (type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> meta = detail::function_meta&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(function)&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> meta::request_type request; packer.load(buffer, request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([&amp;function] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; ... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args)&gt;(args) ... ); }, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packer.save(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response))); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</code> </pre><br>  El constructor de la clase es repetitivo.  En la entrada toma una lista de pares.  Cada par es un nombre de m√©todo y un controlador.  Y dado que el constructor es una plantilla con un n√∫mero variable de par√°metros, al crear el objeto del servidor, todos los controladores disponibles en el servidor se registran de inmediato.  Eso permitir√° no realizar m√©todos de registro adicionales llamados en los controladores del servidor.  Y, a su vez, lo libera a uno de pensar si el objeto de clase de servidor se usar√° en un entorno multiproceso y si se necesita sincronizaci√≥n. <br><br>  <b>Un fragmento del constructor de la clase del servidor.</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</span></span></code> </pre><br>  Pone muchos manejadores heterog√©neos pasados ‚Äã‚Äãen el mapa de funciones del mismo tipo.  Para esto, tambi√©n se usa la convoluci√≥n, lo que facilita poner en el mapa std :: el conjunto completo de controladores pasados ‚Äã‚Äãen una l√≠nea sin bucles y algoritmos <br><br><pre> <code class="cpp hljs">(handlers_.emplace(handlers.first, make_executor(handlers.second)), ... );</code> </pre><br>  Las funciones de Lambda que permiten usar auto como par√°metros facilitaron la implementaci√≥n del mismo tipo de envoltorio sobre los controladores.  Las envolturas del mismo tipo se registran en el mapa de m√©todos disponibles en el servidor (std :: map).  Cuando se procesan las solicitudes, se realiza una b√∫squeda en dicha tarjeta y el mismo controlador llama al controlador encontrado, independientemente de los par√°metros recibidos y el resultado devuelto.  La funci√≥n std :: apply que apareci√≥ en la biblioteca est√°ndar llama a la funci√≥n que se le pasa con los par√°metros pasados ‚Äã‚Äãcomo una tupla.  La funci√≥n std :: apply tambi√©n se puede implementar en C ++ 11.  Ahora est√° disponible "fuera de la caja" y no hay necesidad de transferirlo de un proyecto a otro. <br><br>  <b>M√©todo de ejecuci√≥n</b> <br><br><pre> <code class="cpp hljs">type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type::buffer buffer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; pack; packer_.load(buffer, pack); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func_name = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(pack)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = handlers_.find(func_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter == end(handlers_)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error{<span class="hljs-string"><span class="hljs-string">"Function \""</span></span> + func_name + <span class="hljs-string"><span class="hljs-string">"\" not found."</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter-&gt;second(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }</code> </pre><br>  Recupera el nombre de la funci√≥n llamada, busca el m√©todo en el mapa de controladores registrados, llama al controlador y devuelve el resultado.  Todo interesante en los wrappers preparados en el constructor de la clase del servidor.  Es posible que alguien haya notado la excepci√≥n, y tal vez surgi√≥ la pregunta: "¬øLas excepciones se manejan de alguna manera?"  S√≠, en la implementaci√≥n completa, que se proporcionar√° como referencia al final, se proporciona la clasificaci√≥n de excepciones.  All√≠ mismo, para simplificar el material, no se pasan excepciones entre el cliente y el servidor. <br><br>  Eche otro vistazo a la funci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">principal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"hello\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> + s + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; }}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"to_int\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::stoi(s); }} }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;server] (rpc::type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.execute(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }; rpc::client&lt;packer_type&gt; client{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(executor)}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"world"</span></span>}).as&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Convert to int: "</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"100500"</span></span>}).as&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_FAILURE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_SUCCESS; }</code> </pre></div></div><br>  Implementa una interacci√≥n cliente-servidor completa.  Para no complicar el material, el cliente y el servidor trabajan en un solo proceso.  Reemplazando la implementaci√≥n del ejecutor, puede utilizar el transporte necesario. <br><br>  En el est√°ndar C ++ 17, a veces es posible no especificar par√°metros de plantilla en la instanciaci√≥n.  En la funci√≥n principal anterior, esto se utiliza al registrar controladores de servidor (std :: pair sin par√°metros de plantilla) y simplifica el c√≥digo. <br><br>  La implementaci√≥n b√°sica de RPC est√° lista.  Queda por agregar la capacidad prometida de pasar estructuras de datos personalizadas como par√°metros y devolver resultados. <br><br><h2>  Estructuras de datos personalizados </h2><br>  Para transferir datos a trav√©s del l√≠mite del proceso, deben ser serializados en algo.  Por ejemplo, puede enviar todo a una secuencia est√°ndar.  Mucho ser√° compatible fuera de la caja.  Para estructuras de datos personalizadas, deber√° implementar los operadores de salida usted mismo.  Cada estructura necesita su propio operador de salida.  A veces no quieres hacer esto.  Para ordenar todos los campos de la estructura y enviar cada campo a la secuencia, necesita alg√∫n m√©todo generalizado.  La reflexi√≥n podr√≠a ayudar bien en esto.  Todav√≠a no est√° en C ++.  Puede recurrir a la generaci√≥n de c√≥digo y al uso de una combinaci√≥n de macros y plantillas.  Pero la idea era hacer la interfaz de la biblioteca en C ++ puro. <br><br>  No hay una reflexi√≥n completa en C ++ todav√≠a.  Por lo tanto, la soluci√≥n a continuaci√≥n se puede usar con algunas limitaciones. <br><br>  La soluci√≥n se basa en el uso de la nueva funci√≥n de "enlaces estructurados" de C ++ 17.  A menudo, en los cuadros de di√°logo puede encontrar mucha jerga, por lo que rechac√© cualquier opci√≥n para el nombre de esta funci√≥n en ruso. <br><br>  A continuaci√≥n se muestra una soluci√≥n que le permite transferir los campos de la estructura de datos transferidos a la tupla. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is_braces_constructible_v&lt;type, dummy_type, dummy_type, dummy_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2, f3] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2, f3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(); } }</code> </pre><br>  En Internet puede encontrar muchas soluciones similares. <br><br>  Mucho de lo que se us√≥ aqu√≠ se dijo anteriormente, excepto los enlaces estructurados.  La funci√≥n to_tuple acepta un tipo personalizado, determina el n√∫mero de campos y, con la ayuda de enlaces estructurados, "transfiere" los campos de estructura a una tupla.  Y "if constexpr" le permite seleccionar la rama de implementaci√≥n deseada.  Como no hay reflejo en C ++, no se puede construir una soluci√≥n completa que tenga en cuenta todos los aspectos del tipo.  Existen restricciones sobre los tipos utilizados.  Uno de ellos: el tipo debe ser sin constructores personalizados. <br><br>  To_tuple usa is_braces_constructible_v.  Este tipo le permite determinar la capacidad de inicializar la estructura transferida utilizando llaves y determinar el n√∫mero de campos. <br><br><div class="spoiler">  <b class="spoiler_title">is_braces_constructible_v</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T{</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TArgs&gt;() ... }), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::true_type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_braces_constructible_v = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(is_braces_constructible&lt;T, TArgs ... &gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>))&gt;::value;</code> </pre></div></div><br>  La funci√≥n to_tuple anterior puede transformar estructuras de datos de usuario que contienen no m√°s de tres campos en tuplas.  Para aumentar el n√∫mero posible de campos "desplazados" de la estructura, puede copiar las ramas "if constexpr" con una peque√±a inclusi√≥n de la mente, o recurrir a la biblioteca no m√°s simple de boost.preprocessor.  Si selecciona la segunda opci√≥n, el c√≥digo ser√° dif√≠cil de leer y permitir√° usar estructuras con una gran cantidad de campos. <br><br><div class="spoiler">  <b class="spoiler_title">Implementando to_tuple con boost.preprocessor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NANORPC_TO_TUPLE_LIMIT_FIELDS 64 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// you can try to use BOOST_PP_LIMIT_REPEAT #define NANORPC_TO_TUPLE_DUMMY_TYPE_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data #define NANORPC_TO_TUPLE_PARAM_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data ## n #define NANORPC_TO_TUPLE_ITEM_N(_, n, __) \ if constexpr (is_braces_constructible_v&lt;type, \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_DUMMY_TYPE_N, dummy_type) \ &gt;) { auto &amp;&amp;[ \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ] = value; return std::make_tuple( \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ); } else #define NANORPC_TO_TUPLE_ITEMS(n) \ BOOST_PP_REPEAT_FROM_TO(0, n, NANORPC_TO_TUPLE_ITEM_N, nil) NANORPC_TO_TUPLE_ITEMS(NANORPC_TO_TUPLE_LIMIT_FIELDS) { return std::make_tuple(); } #undef NANORPC_TO_TUPLE_ITEMS #undef NANORPC_TO_TUPLE_ITEM_N #undef NANORPC_TO_TUPLE_PARAM_N #undef NANORPC_TO_TUPLE_DUMMY_TYPE_N #undef NANORPC_TO_TUPLE_LIMIT_FIELDS }</span></span></span></span></code> </pre></div></div><br>  Si alguna vez ha intentado hacer algo como boost.bind para C ++ 03, donde tuvo que hacer muchas implementaciones con un n√∫mero diferente de par√°metros, la implementaci√≥n de to_tuple usando boost.preprocessor no parece extra√±o o complicado. <br><br>  Y si se agrega soporte de tupla al serializador, la funci√≥n to_tuple permitir√° la serializaci√≥n de las estructuras de datos del usuario.  Y se hace posible traicionarlos como par√°metros y devolver resultados en su RPC. <br><br>  Adem√°s de las estructuras de datos definidas por el usuario, C ++ tiene otros tipos integrados para los que no se implementa la salida a la secuencia est√°ndar.  El deseo de reducir el n√∫mero de operadores de salida sobrecargados en el flujo conduce a un c√≥digo generalizado que permite que un m√©todo procese la mayor√≠a de los contenedores de C ++, como std :: list, std :: vector, std :: map.  Sin olvidarse de SFINAE y std :: enable_if_t, puede continuar extendiendo el serializador.  En este caso, ser√° necesario determinar indirectamente de alguna manera las propiedades de los tipos, similar a lo que se hace en la implementaci√≥n de is_braces_constructible_v. <br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuera del alcance de la publicaci√≥n est√° la excepci√≥n de clasificaci√≥n, transporte, serializaci√≥n de contenedores stl y mucho m√°s. </font><font style="vertical-align: inherit;">Para no complicar mucho la publicaci√≥n, solo se dieron principios generales sobre los cuales pude construir mi biblioteca RPC y resolver el conjunto de tareas original por m√≠ mismo: probar nuevas caracter√≠sticas de C ++ 14/17. Y la implementaci√≥n resultante le permite llamar a m√©todos remotos utilizando el extendido HTTP / HTTPS y contiene ejemplos de uso bastante detallados. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">C√≥digo de la</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NanoRPC en GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Gracias por su atencion! <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421001/">https://habr.com/ru/post/es421001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486174/index.html">Ich habe keinen Umsatz</a></li>
<li><a href="../es420993/index.html">5 pasos simples para crear un servidor para probar solicitudes REST de Android</a></li>
<li><a href="../es420995/index.html">Seleccionamos la contrase√±a para el TIN indio en dos segundos, o por qu√© las matem√°ticas de fuerza bruta</a></li>
<li><a href="../es420997/index.html">KDD 2018, d√≠a cuatro, realiza el premio Nobel</a></li>
<li><a href="../es420999/index.html">Kivy Xamarin Reaccionar nativo. Tres marcos: un experimento (parte 2)</a></li>
<li><a href="../es421005/index.html">RESTO-asegurado: consejos √∫tiles</a></li>
<li><a href="../es421007/index.html">Grabadora de cinta: una herramienta para grabar autotests</a></li>
<li><a href="../es421009/index.html">25 y 26 de agosto: conferencia en l√≠nea sobre gesti√≥n operativa</a></li>
<li><a href="../es421011/index.html">Preguntas en la entrevista que crees que son est√∫pidas. Pero no realmente</a></li>
<li><a href="../es421015/index.html">Encuesta de sostenibilidad 2018 de segmentos nacionales de Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>