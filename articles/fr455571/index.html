<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú°Ô∏è üí™üèº ‚¨ÜÔ∏è DB Cursors in Doctrine ‚ô®Ô∏è üõ∂ ‚úçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä l'aide de curseurs, vous pouvez recevoir par lots de la base de donn√©es et traiter une grande quantit√© de donn√©es sans gaspiller la m√©moire de l'app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DB Cursors in Doctrine</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/455571/"><p><img src="https://habrastorage.org/webt/a_/l9/rc/a_l9rcqm9ubhpc_gstic1u-rxtq.jpeg" alt="image"></p><br><p>  √Ä l'aide de curseurs, vous pouvez recevoir par lots de la base de donn√©es et traiter une grande quantit√© de donn√©es sans gaspiller la m√©moire de l'application.  Je suis s√ªr que chaque d√©veloppeur Web a fait face √† une t√¢che similaire au moins une fois, et pas seulement une fois avant moi.  Dans cet article, je vous dirai dans quelles t√¢ches les curseurs peuvent √™tre utiles, et je donnerai du code pr√™t √† l'emploi pour travailler avec eux √† partir de PHP + Doctrine en utilisant l'exemple de PostrgeSQL. </p><a name="habracut"></a><br><h3 id="problema">  Le probl√®me </h3><br><p>  Imaginons que nous ayons un projet PHP, gros et lourd.  Certes, il a √©t√© √©crit √† l'aide d'un cadre.  Par exemple, Symfony.  Il utilise √©galement une base de donn√©es, par exemple, PostgreSQL, et la base de donn√©es a une plaque pour 2 000 000 d'enregistrements avec des informations sur les commandes.  Et le projet lui-m√™me est une interface vers ces commandes, qui peut les afficher et les filtrer.  Et, permettez-moi de dire, cela se passe plut√¥t bien. </p><br><p>  Maintenant, on nous a demand√© (ne vous a-t-on pas encore demand√©? Ils le seront certainement) de t√©l√©charger le r√©sultat des commandes de filtrage dans un fichier Excel.  Pr√©parons un bouton avec une ic√¥ne de tableau, qui crachera un fichier avec des commandes √† l'utilisateur. </p><br><h3 id="kak-obychno-reshayut-i-chem-eto-ploho">  Comment est-il g√©n√©ralement d√©cid√© et pourquoi est-il mauvais? </h3><br><p>  Comment un programmeur qui n'a pas encore rencontr√© une telle t√¢che?  Il cr√©e SELECT dans la base de donn√©es, lit les r√©sultats de la requ√™te, convertit la r√©ponse en fichier Excel et la transmet au navigateur de l'utilisateur.  La t√¢che fonctionne, les tests sont termin√©s, mais des probl√®mes commencent dans la production. </p><br><p> Certes, nous avons fix√© une limite de m√©moire pour PHP √† environ 1 Go raisonnable (sans doute) par processus, et d√®s que ces 2 millions de lignes ne rentrent plus dans ce gigaoctet, tout casse.  PHP se bloque avec une erreur de ¬´m√©moire insuffisante¬ª et les utilisateurs se plaignent que le fichier n'est pas t√©l√©charg√©.  Cela se produit parce que nous avons choisi une fa√ßon assez na√Øve de d√©charger les donn√©es de la base de donn√©es - toutes sont d'abord transf√©r√©es de la m√©moire de la base de donn√©es (et du disque en dessous) vers la RAM du processus PHP, puis elles sont trait√©es et t√©l√©charg√©es vers le navigateur. </p><br><p>  Pour que les donn√©es soient toujours plac√©es en m√©moire, vous devez les extraire de la base de donn√©es en morceaux.  Par exemple, 10 000 enregistrements ont √©t√© lus, trait√©s, √©crits dans un fichier, et tant de fois. </p><br><p>  Eh bien, pense le programmeur qui a rempli notre t√¢che pour la premi√®re fois.  Ensuite, je vais faire une boucle et d√©gonfler les r√©sultats de la requ√™te en morceaux, en indiquant LIMIT et OFFSET.  Cela fonctionne, mais c'est une op√©ration tr√®s co√ªteuse pour la base de donn√©es, et donc le t√©l√©chargement du rapport ne commence pas √† prendre 30 secondes, mais 30 minutes (ce n'est pas si mal!).  Soit dit en passant, si √† part OFFSET en ce moment, rien ne vient plus √† l'esprit du programmeur, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il existe encore de nombreuses fa√ßons de r√©aliser</a> la m√™me chose sans violer la base de donn√©es. </p><br><p>  Dans le m√™me temps, la base de donn√©es elle-m√™me a une capacit√© int√©gr√©e d'enfiler des donn√©es lues - des curseurs. </p><br><h3 id="kursory">  Curseurs </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un curseur</a> est un pointeur sur une ligne dans les r√©sultats d'une requ√™te qui r√©side dans la base de donn√©es.  Lorsque vous les utilisez, nous pouvons effectuer SELECT non pas dans le mode de t√©l√©chargement imm√©diat des donn√©es, mais ouvrir le curseur avec cette s√©lection.  Ensuite, nous commen√ßons √† recevoir le flux de donn√©es de la base de donn√©es √† mesure que le curseur avance.  Cela nous donne le m√™me r√©sultat: nous lisons les donn√©es par portions, mais la base de donn√©es ne fait pas le m√™me travail de recherche de la ligne avec laquelle elle doit commencer, comme c'est le cas avec OFFSET. </p><br><p>  Le curseur est ouvert uniquement √† l'int√©rieur de la transaction et reste en vie jusqu'√† ce que la transaction soit active (il existe une exception, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WITH HOLD</a> ).  Cela signifie que si nous lisons lentement beaucoup de donn√©es de la base de donn√©es, nous aurons une longue transaction.  C'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parfois mauvais</a> , vous devez comprendre et accepter ce risque. </p><br><h3 id="kursory-v-doctrine">  Curseurs dans la doctrine </h3><br><p>  Essayons d'impl√©menter le travail avec les curseurs dans Doctrine.  Tout d'abord, √† quoi ressemble une demande d'ouverture d'un curseur? </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> mycursor1 <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> huge_table );</code> </pre> <br><p>  DECLARE cr√©e et ouvre le curseur pour la requ√™te SELECT sp√©cifi√©e.  Apr√®s avoir cr√©√© le curseur, vous pouvez commencer √† en lire les donn√©es: </p><br><pre> <code class="sql hljs">FETCH FORWARD 10000 FROM mycursor1; &lt; 10 000 &gt; FETCH FORWARD 10000 FROM mycursor1; &lt;  10 000 &gt; ...</code> </pre> <br><p>  Et ainsi de suite, jusqu'√† ce que FETCH renvoie une liste vide.  Cela signifie qu'ils ont d√©fil√© jusqu'√† la fin. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br><p>  Nous d√©crivons une classe compatible avec Doctrine qui encapsulera le travail avec le curseur.  Et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour r√©soudre 80% du probl√®me en 20% du temps</a> , cela ne fonctionnera qu'avec les requ√™tes natives.  Appelons-le donc PgSqlNativeQueryCursor. </p><br><p>  Constructeur: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NativeQuery $query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query = $query; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection = $query-&gt;getEntityManager()-&gt;getConnection(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName = uniqid(<span class="hljs-string"><span class="hljs-string">'cursor_'</span></span>); assert(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;getDriver() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> PDOPgSqlDriver); }</code> </pre> <br><p>  Ici, je g√©n√®re un nom pour le futur curseur. </p><br><p>  √âtant donn√© que la classe contient du code SQL sp√©cifique √† PostgreSQL, il est pr√©f√©rable de v√©rifier que notre pilote est PG. </p><br><p>  De la classe, nous avons besoin de trois choses: </p><br><ol><li>  Pouvoir ouvrir le curseur. </li><li>  √ätre en mesure de nous renvoyer des donn√©es. </li><li>  Pouvoir fermer le curseur. </li></ol><br><p>  <strong>Ouvrez le curseur:</strong> </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;getTransactionNestingLevel() === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \BadMethodCallException(<span class="hljs-string"><span class="hljs-string">'Cursor must be used inside a transaction'</span></span>); } $query = <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query; $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'DECLARE %s CURSOR FOR (%s)'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName), <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query-&gt;getSQL() )); $query-&gt;execute(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query-&gt;getParameters()); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Comme je l'ai dit, les curseurs s'ouvrent dans une transaction.  Par cons√©quent, je v√©rifie ici que nous n'avons pas oubli√© d'appeler cette m√©thode dans une transaction d√©j√† ouverte.  (Dieu merci, le temps est pass√© o√π je serais amen√© √† ouvrir une transaction ici!) </p><br><p>  Pour simplifier la t√¢che de cr√©ation et d'initialisation d'une nouvelle NativeQuery, je viens de cloner celle qui a √©t√© introduite dans le constructeur et de l'envelopper dans DECLARE ... CURSOR FOR (here_original_query).  Je le r√©alise. </p><br><p>  <strong>Faisons la m√©thode getFetchQuery.</strong>  Il ne renverra pas de donn√©es, mais une autre demande qui peut √™tre utilis√©e √† votre guise pour obtenir les donn√©es souhait√©es dans des lots donn√©s.  Cela donne au code appelant plus de libert√©. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFetchQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeQuery</span></span></span><span class="hljs-function"> </span></span>{ $query = <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query; $query-&gt;setParameters([]); $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'FETCH FORWARD %d FROM %s'</span></span>, $count, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName) )); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $query; }</code> </pre> <br><p>  La m√©thode a un param√®tre - c'est la taille du bundle, qui fera partie de la demande retourn√©e par cette m√©thode.  J'applique la m√™me astuce avec le clonage de requ√™te, j'√©crase les param√®tres qu'il contient et je remplace SQL par la construction FETCH ... FROM ... ;. </p><br><p>  Afin de ne pas oublier d'ouvrir le curseur avant le premier appel √† getFetchQuery () (du coup je ne dormirai pas assez), j'en ferai une ouverture implicite directement dans la m√©thode getFetchQuery (): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFetchQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeQuery</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;openCursor(); } ‚Ä¶</code> </pre> <br><p>  Et la m√©thode openCursor () elle-m√™me sera rendue priv√©e.  Je ne vois aucun cas lorsque je dois l'appeler explicitement. </p><br><p>  Dans getFetchQuery (), j'ai cod√© en dur FORWARD pour d√©placer le curseur vers l'avant un nombre donn√© de lignes.  Mais les modes d'appel FETCH sont tr√®s diff√©rents.  Ajoutons-les aussi? </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_NEXT = <span class="hljs-string"><span class="hljs-string">'NEXT'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_PRIOR = <span class="hljs-string"><span class="hljs-string">'PRIOR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_FIRST = <span class="hljs-string"><span class="hljs-string">'FIRST'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_LAST = <span class="hljs-string"><span class="hljs-string">'LAST'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DIRECTION_ABSOLUTE = <span class="hljs-string"><span class="hljs-string">'ABSOLUTE'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// with count const DIRECTION_RELATIVE = 'RELATIVE'; // with count const DIRECTION_FORWARD = 'FORWARD'; // with count const DIRECTION_FORWARD_ALL = 'FORWARD ALL'; const DIRECTION_BACKWARD = 'BACKWARD'; // with count const DIRECTION_BACKWARD_ALL = 'BACKWARD ALL';</span></span></code> </pre> <br><p>  La moiti√© d'entre eux accepte le nombre de lignes dans le param√®tre, et l'autre moiti√© ne l'accepte pas.  Voici ce que j'ai obtenu: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFetchQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, string $direction = self::DIRECTION_FORWARD)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeQuery</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;openCursor(); } $query = <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;query; $query-&gt;setParameters([]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_ABSOLUTE || $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_RELATIVE || $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_FORWARD || $direction == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::DIRECTION_BACKWARD ) { $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'FETCH %s %d FROM %s'</span></span>, $direction, $count, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName) )); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $query-&gt;setSQL(sprintf( <span class="hljs-string"><span class="hljs-string">'FETCH %s FROM %s'</span></span>, $direction, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName) )); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $query; }</code> </pre> <br><p>  <strong>Fermez le curseur</strong> avec CLOSE, il n'est pas n√©cessaire d'attendre la fin de la transaction: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;exec(<span class="hljs-string"><span class="hljs-string">'CLOSE '</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection-&gt;quoteIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cursorName)); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><p>  Destructeur: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__destruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isOpen) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;close(); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici la classe enti√®re dans son int√©gralit√©</a> .  Essayons en action? </p><br><p>  J'ouvre un Writer conditionnel dans un XLSX conditionnel. </p><br><pre> <code class="php hljs">$writer-&gt;openToFile($targetFile);</code> </pre> <br><p>  Ici, je re√ßois NativeQuery pour extraire la liste des commandes de la base de donn√©es. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> NativeQuery $query */</span></span> $query = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getOrdersRepository($em) -&gt;getOrdersFiltered($dateFrom, $dateTo, $filters);</code> </pre> <br><p>  Sur la base de cette requ√™te, je d√©clare un curseur. </p><br><pre> <code class="php hljs">$cursor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PgSqlNativeQueryCursor($query);</code> </pre> <br><p>  Et pour lui, je re√ßois une demande pour recevoir des donn√©es par lots de 10 000 lignes. </p><br><pre> <code class="php hljs">$fetchQuery = $cursor-&gt;getFetchQuery(<span class="hljs-number"><span class="hljs-number">10000</span></span>);</code> </pre> <br><p>  J'it√®re jusqu'√† ce que j'obtienne un r√©sultat vide.  √Ä chaque it√©ration, j'ex√©cute FETCH, je traite le r√©sultat et j'√©cris dans un fichier. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { $result = $fetchQuery-&gt;getArrayResult(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $row) { $writer-&gt;addRow(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;toXlsxRow($row)); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($result);</code> </pre> <br><p>  Je ferme le curseur et Writer. </p><br><pre> <code class="php hljs">$cursor-&gt;close(); $writer-&gt;close();</code> </pre> <br><p>  Le fichier lui-m√™me que j'√©cris sur le disque dans un r√©pertoire pour les fichiers temporaires, et une fois l'enregistrement termin√©, je le donne au navigateur pour √©viter, encore une fois, la mise en m√©moire tampon. </p><br><p>  RAPPORT PRET!  Nous avons utilis√© une quantit√© constante de m√©moire de PHP pour traiter toutes les donn√©es et n'avons pas tortur√© la base de donn√©es avec une s√©rie de requ√™tes lourdes.  Et le d√©chargement lui-m√™me a pris un peu plus de temps que la base requise pour r√©pondre √† la demande. </p><br><p>  Voir s'il y a des endroits dans vos projets qui peuvent acc√©l√©rer / √©conomiser de la m√©moire avec le curseur? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455571/">https://habr.com/ru/post/fr455571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455555/index.html">Pi√®ce pour le gestionnaire m√©canique</a></li>
<li><a href="../fr455559/index.html">Comment un ordinateur quantique peut-il p√©n√©trer dans les syst√®mes de cryptage modernes et r√©duire le co√ªt de production d'ammoniac?</a></li>
<li><a href="../fr455563/index.html">Petites entreprises: automatiser ou non?</a></li>
<li><a href="../fr455565/index.html">L'esprit peut-il truquer l'univers?</a></li>
<li><a href="../fr455569/index.html">Nous vous invitons √† la conf√©rence Tarantool du 17 juin</a></li>
<li><a href="../fr455575/index.html">Neural Matching: comment adapter le contenu aux r√©alit√©s de Google</a></li>
<li><a href="../fr455577/index.html">Le√ßons SDL 2: Le√ßon 3 - √âv√©nements</a></li>
<li><a href="../fr455579/index.html">Tupperware: le tueur de Facebook Kubernetes?</a></li>
<li><a href="../fr455580/index.html">Animations d'applications mobiles incontournables</a></li>
<li><a href="../fr455582/index.html">Navigation dans le magasin: de la r√©alit√© augment√©e √† l'√©tag√®re souhait√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>