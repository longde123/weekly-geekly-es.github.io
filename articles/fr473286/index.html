<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöæ ü§∞üèΩ üôÅ Nous √©crivons une protection contre les attaques DDoS sur XDP. Partie nucl√©aire üôãüèæ üëè ü§î</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La technologie EXpress Data Path (XDP) permet un traitement arbitraire du trafic sur les interfaces Linux avant l'arriv√©e des paquets sur la pile r√©se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons une protection contre les attaques DDoS sur XDP. Partie nucl√©aire</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473286/"><p>  La technologie EXpress Data Path (XDP) permet un traitement arbitraire du trafic sur les interfaces Linux avant l'arriv√©e des paquets sur la pile r√©seau du noyau.  Application de XDP - protection contre les attaques DDoS (CloudFlare), filtres sophistiqu√©s, collecte de statistiques (Netflix).  Les programmes XDP sont ex√©cut√©s par la machine virtuelle eBPF, par cons√©quent, ils ont des restrictions √† la fois sur leur code et sur les fonctions du noyau disponibles, selon le type de filtre. </p><br><p>  L'article est destin√© √† combler les lacunes de nombreux mat√©riaux XDP.  Premi√®rement, ils fournissent du code pr√™t √† l'emploi qui contourne imm√©diatement les fonctionnalit√©s de XDP: pr√©par√© pour la v√©rification ou trop simple pour causer des probl√®mes.  Lorsque vous essayez d'√©crire votre code √† partir de z√©ro, vous ne savez pas quoi faire avec les erreurs typiques.  Deuxi√®mement, les m√©thodes de test local de XDP sans VM ni mat√©riel ne sont pas couvertes, malgr√© le fait qu'elles aient leurs propres pi√®ges.  Le texte est destin√© aux programmeurs familiers avec les r√©seaux et Linux qui sont int√©ress√©s par XDP et eBPF. </p><a name="habracut"></a><br><p> Dans cette partie, nous examinerons en d√©tail comment le filtre XDP est assembl√© et comment le tester, puis nous √©crirons une version simple du m√©canisme de cookie SYN bien connu au niveau du traitement des paquets.  Bien que nous ne formions pas de ¬´liste blanche¬ª <br>  clients v√©rifi√©s, garder des compteurs et g√©rer le filtre - suffisamment de journaux. </p><br><p>  Nous √©crirons en C - ce n'est pas √† la mode, mais pratique.  Tout le code est disponible sur GitHub via le lien √† la fin et est divis√© en commits selon les √©tapes d√©crites dans l'article. </p><br><p>  <strong>Clause de non-responsabilit√©.</strong>  Au cours de l'article, une mini-solution sera d√©velopp√©e pour repousser les attaques DDoS, car il s'agit d'une t√¢che r√©aliste pour XDP et ma r√©gion.  Cependant, l'objectif principal est de traiter avec la technologie, ce n'est pas un guide pour cr√©er une protection toute faite.  Le code de formation n'est pas optimis√© et omet certaines nuances. </p><br><h2 id="kratkiy-obzor-xdp">  XDP en bref </h2><br><p>  Je ne soulignerai que les points cl√©s afin de ne pas dupliquer la documentation et les articles existants. </p><br><p> Ainsi, le code du filtre est charg√© dans le noyau.  Les paquets entrants sont envoy√©s au filtre.  Par cons√©quent, le filtre doit prendre une d√©cision: ignorer le paquet vers le noyau ( <code>XDP_PASS</code> ), jeter le paquet ( <code>XDP_DROP</code> ) ou le renvoyer ( <code>XDP_TX</code> ).  Le filtre peut changer le package, c'est particuli√®rement vrai pour <code>XDP_TX</code> .  Vous pouvez √©galement planter le programme ( <code>XDP_ABORTED</code> ) et <code>XDP_ABORTED</code> le package, mais il s'agit d'un analogue d' <code>assert(0)</code> pour le d√©bogage. </p><br><p>  La machine virtuelle eBPF (Berkley Packet Filter √©tendu) est sp√©cialement simplifi√©e pour que le noyau puisse v√©rifier que le code ne boucle pas et n'endommage pas la m√©moire de quelqu'un d'autre.  Restrictions et contr√¥les agr√©g√©s: </p><br><ul><li>  Cycles interdits (saut en arri√®re). </li><li>  Il existe une pile de donn√©es, mais aucune fonction (toutes les fonctions C doivent √™tre int√©gr√©es). </li><li>  L'acc√®s √† la m√©moire en dehors de la pile et du tampon de paquets est interdit. </li><li>  La taille du code est limit√©e, mais en pratique ce n'est pas tr√®s significatif. </li><li>  Les appels ne sont autoris√©s que vers des fonctions sp√©ciales du noyau (assistants eBPF). </li></ul><br><p>  La conception et l'installation du filtre ressemblent √† ceci: </p><br><ol><li>  Le code source (par exemple, <code>kernel.c</code> ) est compil√© dans l'objet ( <code>kernel.o</code> ) sous l'architecture de la machine virtuelle eBPF.  Depuis octobre 2019, la compilation dans eBPF est prise en charge par Clang et promise dans GCC 10.1. </li><li>  Si dans ce code objet il y a des appels √† des structures de noyau (par exemple, des tables et des compteurs), des z√©ros sont utilis√©s √† la place de leurs ID, c'est-√†-dire qu'un tel code ne peut pas √™tre ex√©cut√©.  Avant de charger dans le noyau, vous devez remplacer ces z√©ros par l'ID d'objets sp√©cifiques cr√©√©s via les appels du noyau (code de lien).  Vous pouvez le faire avec des utilitaires externes ou vous pouvez √©crire un programme qui liera et chargera un filtre sp√©cifique. </li><li>  Le noyau v√©rifie le programme charg√©.  L'absence de boucles et l'absent√©isme au-del√† des limites du paquet et de la pile sont v√©rifi√©s.  Si le v√©rificateur ne peut pas prouver que le code est correct, le programme est rejet√© - vous devez pouvoir le satisfaire. </li><li>  Apr√®s une v√©rification r√©ussie, le noyau compile le code objet de l'architecture eBPF dans le code machine de l'architecture syst√®me (juste √† temps). </li><li>  Le programme s'attache √† l'interface et commence √† traiter les paquets. </li></ol><br><p>  √âtant donn√© que XDP fonctionne dans le noyau, le d√©bogage est effectu√© par les journaux de trace et, en fait, par les paquets que le programme filtre ou g√©n√®re.  Cependant, eBPF assure la s√©curit√© du code charg√© pour le syst√®me, vous pouvez donc exp√©rimenter avec XDP directement sur Linux local. </p><br><h2 id="podgotovka-okruzheniya">  Pr√©paration de l'environnement </h2><br><h3 id="sborka">  Assemblage </h3><br><p>  Clang ne peut pas √©mettre directement de code objet pour l'architecture eBPF, le processus se compose donc de deux √©tapes: </p><br><ol><li>  Compilez le code C en bytecode LLVM ( <code>clang -emit-llvm</code> ). </li><li>  Convertissez le bytecode en code objet eBPF ( <code>llc -march=bpf -filetype=obj</code> ). </li></ol><br><p>  Lors de l'√©criture d'un filtre, quelques fichiers avec des fonctions auxiliaires et des macros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des tests du noyau</a> sont utiles.  Il est important qu'ils correspondent √† la version du noyau ( <code>KVER</code> ).  T√©l√©chargez-les dans les <code>helpers/</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KVER=v5.3.7 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> BASE=https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/plain/tools/testing/selftests/bpf wget -P helpers --content-disposition <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_helpers.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_endian.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span> KVER BASE</code> </pre> <br><p>  Makefile pour Arch Linux (noyau 5.3.7): </p><br><pre> <code class="plaintext hljs">CLANG ?= clang LLC ?= llc KDIR ?= /lib/modules/$(shell uname -r)/build ARCH ?= $(subst x86_64,x86,$(shell uname -m)) CFLAGS = \ -Ihelpers \ \ -I$(KDIR)/include \ -I$(KDIR)/include/uapi \ -I$(KDIR)/include/generated/uapi \ -I$(KDIR)/arch/$(ARCH)/include \ -I$(KDIR)/arch/$(ARCH)/include/generated \ -I$(KDIR)/arch/$(ARCH)/include/uapi \ -I$(KDIR)/arch/$(ARCH)/include/generated/uapi \ -D__KERNEL__ \ \ -fno-stack-protector -O2 -g xdp_%.o: xdp_%.c Makefile $(CLANG) -c -emit-llvm $(CFLAGS) $&lt; -o - | \ $(LLC) -march=bpf -filetype=obj -o $@ .PHONY: all clean all: xdp_filter.o clean: rm -f ./*.o</code> </pre> <br><p>  <code>KDIR</code> contient le chemin vers les en-t√™tes du noyau, <code>ARCH</code> - l'architecture du syst√®me.  Les chemins et les outils peuvent varier l√©g√®rement entre les distributions. </p><br><div class="spoiler">  <b class="spoiler_title">Exemple de diff√©rence pour Debian 10 (noyau 4.19.67)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   CLANG ?= clang LLC ?= llc-7 #   KDIR ?= /usr/src/linux-headers-$(shell uname -r) ARCH ?= $(subst x86_64,x86,$(shell uname -m)) #    -I CFLAGS = \ -Ihelpers \ \ -I/usr/src/linux-headers-4.19.0-6-common/include \ -I/usr/src/linux-headers-4.19.0-6-common/arch/$(ARCH)/include \ #   </code> </pre> </div></div><br><p>  <code>CFLAGS</code> incluent un r√©pertoire avec des en-t√™tes auxiliaires et plusieurs r√©pertoires avec des en-t√™tes de noyau.  Le symbole <code>__KERNEL__</code> signifie que les en-t√™tes UAPI (API de l'espace utilisateur) sont d√©finis pour le code du noyau, car le filtre s'ex√©cute dans le noyau. </p><br><p>  La protection de la pile peut √™tre d√©sactiv√©e ( <code>-fno-stack-protector</code> ), car le v√©rificateur de code eBPF recherche toujours un moyen de sortir de la pile.  L'optimisation doit √™tre incluse imm√©diatement car la taille du bytecode eBPF est limit√©e. </p><br><p>  Commen√ßons par un filtre qui ignore tous les paquets et ne fait rien: </p><br><pre> <code class="plaintext hljs">#include &lt;uapi/linux/bpf.h&gt; #include &lt;bpf_helpers.h&gt; SEC("prog") int xdp_main(struct xdp_md* ctx) { return XDP_PASS; } char _license[] SEC("license") = "GPL";</code> </pre> <br><p>  La commande <code>make</code> <code>xdp_filter.o</code> .  O√π le tester maintenant? </p><br><h3 id="testovyy-stend">  Banc d'essai </h3><br><p>  Le stand doit comprendre deux interfaces: sur lesquelles il y aura un filtre et √† partir desquelles les paquets seront envoy√©s.  Ceux-ci doivent √™tre des appareils Linux √† part enti√®re avec leur IP afin de v√©rifier le fonctionnement des applications r√©guli√®res avec notre filtre. </p><br><p>  Des appareils comme veth (Ethernet virtuel) nous conviennent: ce sont deux interfaces r√©seau virtuelles qui sont ¬´connect√©es¬ª directement entre elles.  Vous pouvez les cr√©er comme ceci (dans cette section, toutes les commandes <code>ip</code> sont ex√©cut√©es en tant que <code>root</code> ): </p><br><pre> <code class="bash hljs">ip link add xdp-remote <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> veth peer name xdp-local</code> </pre> <br><p>  Ici <code>xdp-remote</code> et <code>xdp-local</code> sont des noms de p√©riph√©riques.  Un filtre sera attach√© √† <code>xdp-local</code> (192.0.2.1/24), et le trafic entrant sera envoy√© depuis <code>xdp-remote</code> (192.0.2.2/24).  Cependant, il y a un probl√®me: les interfaces sont sur la m√™me machine, et Linux n'enverra pas de trafic √† l'une via l'autre.  Vous pouvez r√©soudre ce probl√®me avec les r√®gles <code>iptables</code> d√©licates, mais ils devront modifier les packages, ce qui n'est pas pratique lors du d√©bogage.  Il est pr√©f√©rable d'utiliser des espaces de noms r√©seau (espaces de noms r√©seau, ci-apr√®s netns). </p><br><p>  L'espace de noms r√©seau contient un ensemble d'interfaces, de tables de routage et de r√®gles NetFilter, isol√©es d'objets similaires dans d'autres r√©seaux.  Chaque processus s'ex√©cute dans un espace de noms et seuls les objets de ce r√©seau lui sont accessibles.  Par d√©faut, le syst√®me poss√®de un seul espace de noms r√©seau pour tous les objets, vous pouvez donc travailler sur Linux et ne pas conna√Ætre les r√©seaux. </p><br><p>  Cr√©ez un nouvel espace de noms <code>xdp-test</code> et d√©placez <code>xdp-remote</code> . </p><br><pre> <code class="bash hljs">ip netns add xdp-test ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-remote netns xdp-test</code> </pre> <br><p>  Ensuite, le processus ex√©cut√© dans <code>xdp-test</code> ne ¬´verra¬ª pas <code>xdp-local</code> (il restera dans netns par d√©faut) et l'enverra via <code>xdp-remote</code> lors de l'envoi d'un paquet √† 192.0.2.1, car il s'agit de la seule interface de 192.0.2.0/ 24 disponibles pour ce processus.  Cela fonctionne √©galement dans la direction oppos√©e. </p><br><p>  Lorsque vous vous d√©placez entre des r√©seaux, l'interface tombe et perd l'adresse.  Pour configurer l'interface dans netns, vous devez ex√©cuter <code>ip ...</code> dans cet espace de noms de commande <code>ip netns exec</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip address add 192.0.2.2/24 dev xdp-remote ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-remote up</code> </pre> <br><p>  Comme vous pouvez le voir, cela ne diff√®re pas de la d√©finition de <code>xdp-local</code> dans l'espace de noms par d√©faut: </p><br><pre> <code class="bash hljs"> ip address add 192.0.2.1/24 dev xdp-local ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-local up</code> </pre> <br><p>  Si vous ex√©cutez <code>tcpdump -tnevi xdp-local</code> , vous pouvez voir que les paquets envoy√©s depuis <code>xdp-test</code> sont livr√©s √† cette interface: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test ping 192.0.2.1</code> </pre> <br><p>  Il est pratique d'ex√©cuter le shell dans <code>xdp-test</code> .  Il existe un script dans le r√©f√©rentiel qui automatise le travail avec le support, par exemple, vous pouvez configurer le support avec la commande <code>sudo ./stand up</code> et le supprimer avec la commande <code>sudo ./stand down</code> . </p><br><h3 id="trassirovka">  Trace </h3><br><p>  Le filtre est fix√© √† l'appareil comme suit: </p><br><pre> <code class="bash hljs">ip -force link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp object xdp_filter.o verbose</code> </pre> <br><p>  Le <code>-force</code> n√©cessaire pour lier un nouveau programme si un autre est d√©j√† li√©.  ¬´Aucune nouvelle n'est une bonne nouvelle¬ª ne concerne pas cette commande, la conclusion est en tout cas volumineuse.  <code>verbose</code> facultatif, mais avec lui, un rapport appara√Æt sur le travail du v√©rificateur de code avec la liste d'assembly: </p><br><pre> <code class="plaintext hljs">Verifier analysis: 0: (b7) r0 = 2 1: (95) exit</code> </pre> <br><p>  D√©tachez le programme de l'interface: </p><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp off</code> </pre> <br><p>  Dans le script, ce sont les commandes <code>sudo ./stand attach</code> et <code>sudo ./stand detach</code> . </p><br><p>  En attachant un filtre, vous pouvez v√©rifier que le <code>ping</code> continue de fonctionner, mais le programme fonctionne-t-il?  Ajoutez les journaux.  La fonction <a href=""><code>bpf_trace_printk()</code></a> est similaire √† <code>printf()</code> , mais ne prend en charge que jusqu'√† trois arguments, √† l'exception du mod√®le, et une liste limit√©e de qualificatifs.  La macro <code>bpf_printk()</code> simplifie l'appel. </p><br><pre> <code class="diff hljs"> SEC("prog") int xdp_main(struct xdp_md* ctx) { + bpf_printk("got packet: %p\n", ctx); return XDP_PASS; }</code> </pre> <br><p>  La sortie va au canal de trace du noyau, que vous devez activer: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n 1 | sudo tee /sys/kernel/debug/tracing/options/trace_printk</code> </pre> <br><p>  Afficher le flux de messages: </p><br><pre> <code class="bash hljs">cat /sys/kernel/debug/tracing/trace_pipe</code> </pre> <br><p>  Ces deux commandes appellent le <code>sudo ./stand log</code> . </p><br><p>  Ping devrait maintenant d√©clencher les messages suivants: </p><br><pre> <code class="plaintext hljs">&lt;...&gt;-110930 [004] ..s1 78803.244967: 0: got packet: 00000000ac510377</code> </pre> <br><p>  Si vous regardez attentivement la sortie du v√©rificateur, vous remarquerez d'√©tranges calculs: </p><br><pre> <code class="plaintext hljs">0: (bf) r3 = r1 1: (18) r1 = 0xa7025203a7465 3: (7b) *(u64 *)(r10 -8) = r1 4: (18) r1 = 0x6b63617020746f67 6: (7b) *(u64 *)(r10 -16) = r1 7: (bf) r1 = r10 8: (07) r1 += -16 9: (b7) r2 = 16 10: (85) call bpf_trace_printk#6 &lt;...&gt;</code> </pre> <br><p>  Le fait est que les programmes eBPF n'ont pas de section de donn√©es, donc la seule fa√ßon de coder une cha√Æne de format est avec les arguments imm√©diats des commandes VM: </p><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">"import binascii; print(bytes(reversed(binascii.unhexlify('0a7025203a74656b63617020746f67'))))"</span></span> b<span class="hljs-string"><span class="hljs-string">'got packet: %p\n'</span></span></code> </pre> <br><p>  Pour cette raison, la sortie de d√©bogage gonfle consid√©rablement le code r√©sultant. </p><br><h3 id="otpravka-paketov-xdp">  Envoi de packages XDP </h3><br><p>  Changeons le filtre: laissez-le renvoyer tous les paquets entrants.  Ceci est incorrect du point de vue du r√©seau, car il serait n√©cessaire de changer les adresses dans les en-t√™tes, mais maintenant le travail est important en principe. </p><br><pre> <code class="diff hljs"> bpf_printk("got packet: %p\n", ctx); - return XDP_PASS; + return XDP_TX; }</code> </pre> <br><p>  Ex√©cutez <code>tcpdump</code> sur <code>xdp-remote</code> .  Il doit afficher la demande d'√©cho ICMP sortante et entrante identique et cesser d'afficher la r√©ponse d'√©cho ICMP.  Mais ne montre pas.  Il s'av√®re que pour que <code>XDP_TX</code> fonctionne dans un programme sur <code>xdp-local</code> <a href="">il est n√©cessaire</a> que l'interface du <code>xdp-remote</code> soit <code>xdp-remote</code> interface <code>xdp-remote</code> , m√™me si elle est vide, et elle <a href="">doit</a> √™tre augment√©e. </p><br><div class="spoiler">  <b class="spoiler_title">Comment ai-je d√©couvert?</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le</a> m√©canisme des √©v√©nements perf, en passant, utilisant la m√™me machine virtuelle permet de suivre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le chemin du package dans le noyau</a> , c'est-√†-dire que eBPF est utilis√© pour le d√©montage avec eBPF. </p><br><blockquote>  Il faut faire le bien du mal, car il n'y a plus rien √† en faire. </blockquote><br><pre> <code class="bash hljs">$ sudo perf trace --call-graph dwarf -e <span class="hljs-string"><span class="hljs-string">'xdp:*'</span></span> 0.000 ping/123455 xdp:xdp_bulk_tx:ifindex=19 action=TX sent=0 drops=1 err=-6 veth_xdp_flush_bq ([veth]) veth_xdp_flush_bq ([veth]) veth_poll ([veth]) &lt;...&gt;</code> </pre> <br><p>  Qu'est-ce que le code 6? </p><br><pre> <code class="bash hljs">$ errno 6 ENXIO 6 No such device or address</code> </pre> <br><p>  La fonction <code>veth_xdp_flush_bq()</code> re√ßoit un code d'erreur de <code>veth_xdp_xmit()</code> , o√π nous recherchons par <code>ENXIO</code> et trouvons un commentaire. </p></div></div><br><p>  Restaurez le filtre minimum ( <code>XDP_PASS</code> ) dans le fichier <code>xdp_dummy.c</code> , ajoutez-le au Makefile, attachez-le √† <code>xdp-remote</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> remote \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev int xdp object dummy.o</code> </pre> <br><p>  Maintenant <code>tcpdump</code> montre ce qui est attendu: </p><br><pre> <code class="plaintext hljs">62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64 62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64</code> </pre> <br><p>  Si seul ARP est affich√© √† la place, vous devez supprimer les filtres (cela se fait par <code>sudo ./stand detach</code> ), d√©marrer le <code>ping</code> , puis d√©finir les filtres et r√©essayer.  Le probl√®me est que le filtre <code>XDP_TX</code> affecte √† la fois ARP et si la pile <br>  <code>xdp-test</code> espace de noms <code>xdp-test</code> r√©ussi √† ¬´oublier¬ª l'adresse MAC 192.0.2.1, il ne pourra pas r√©soudre cette IP. </p><br><h2 id="postanovka-zadachi">  √ânonc√© du probl√®me </h2><br><p>  Passons √† la t√¢che indiqu√©e: √©crire le m√©canisme des cookies SYN sur XDP. </p><br><p>  Jusqu'√† pr√©sent, SYN flood reste une attaque DDoS populaire, dont l'essence est la suivante.  Lors de l'√©tablissement d'une connexion (prise de contact TCP), le serveur re√ßoit un SYN, alloue des ressources pour une future connexion, r√©pond avec un paquet SYNACK et attend un ACK.  L'attaquant envoie simplement des paquets SYN √† partir de fausses adresses au nombre de milliers par seconde de chaque h√¥te √† partir d'un botnet de plusieurs milliers.  Le serveur est oblig√© d'allouer des ressources imm√©diatement √† l'arriv√©e du paquet, et lib√®re par un d√©lai d'attente important, en cons√©quence, la m√©moire ou les limites sont √©puis√©es, les nouvelles connexions ne sont pas accept√©es, le service n'est pas disponible. </p><br><p>  Si vous n'allouez pas de ressources pour le paquet SYN, mais r√©pondez uniquement avec un paquet SYNACK, alors comment le serveur peut-il comprendre que le paquet ACK qui est venu plus tard fait r√©f√©rence √† un paquet SYN qui n'a pas √©t√© enregistr√©?  Apr√®s tout, un attaquant peut √©galement g√©n√©rer de faux ACK.  L'essence du cookie SYN est d'encoder les param√®tres de <code>seqnum</code> en <code>seqnum</code> sous forme de hachage √† partir d'adresses, de ports et de sel de changement.  Si l'ACK a r√©ussi √† arriver avant le changement de sel, vous pouvez √† nouveau calculer le hachage et le comparer avec <code>acknum</code> .  L'attaquant ne peut pas <code>acknum</code> , car le sel contient un secret et n'aura pas le temps de trier en raison du canal limit√©. </p><br><p>  Le cookie SYN est implant√© depuis longtemps dans le noyau Linux et peut m√™me s'allumer automatiquement si SYN arrive trop rapidement et en masse. </p><br><div class="spoiler">  <b class="spoiler_title">Programme √©ducatif sur la prise de contact TCP</b> <div class="spoiler_text"><p>  TCP fournit le transfert de donn√©es sous forme de flux d'octets, par exemple, les requ√™tes HTTP sont envoy√©es via TCP.  Le flux est transmis par morceaux en paquets.  Tous les paquets TCP ont des indicateurs logiques et des num√©ros de s√©quence 32 bits: </p><br><ul><li><p>  La combinaison de drapeaux d√©termine le r√¥le d'un package particulier.  L'indicateur SYN signifie qu'il s'agit du premier paquet exp√©diteur dans la connexion.  L'indicateur ACK signifie que l'exp√©diteur a re√ßu toutes les donn√©es de connexion avant l'octet <code>acknum</code> .  Un paquet peut avoir plusieurs drapeaux et est appel√© par leur combinaison, par exemple, un paquet SYNACK. </p><br></li><li><p>  Le num√©ro de s√©quence (seqnum) d√©finit le d√©calage dans le flux de donn√©es pour le premier octet qui est transmis dans ce paquet.  Par exemple, si dans le premier paquet avec X octets de donn√©es ce nombre √©tait N, dans le paquet suivant avec de nouvelles donn√©es ce sera N + X.  Au d√©but de la connexion, chaque c√¥t√© s√©lectionne ce num√©ro arbitrairement. </p><br></li><li><p>  Num√©ro d'accus√© de r√©ception (acknum) - le m√™me d√©calage que le seqnum, mais ne d√©termine pas le nombre d'octets √† transmettre, mais le num√©ro du premier octet du destinataire que l'exp√©diteur n'a pas vu. </p><br></li></ul><br><p>  Au d√©but de la connexion, les parties doivent s'entendre sur le <code>seqnum</code> et l' <code>acknum</code> .  Le client envoie un paquet SYN avec son <code>seqnum = X</code>  Le serveur r√©pond avec un paquet SYNACK, o√π il √©crit son <code>seqnum = Y</code> et d√©finit <code>acknum = X + 1</code> .  Le client r√©pond √† SYNACK avec un paquet ACK, o√π <code>seqnum = X + 1</code> , <code>acknum = Y + 1</code> .  Apr√®s cela, le transfert de donn√©es proprement dit commence. </p><br><p>  Si l'interlocuteur ne confirme pas la r√©ception du paquet, TCP le renvoie √† nouveau par timeout. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Pourquoi les cookies SYN ne sont-ils pas toujours utilis√©s?</b> <div class="spoiler_text"><p>  Premi√®rement, si SYNACK ou ACK est perdu, vous devrez attendre la r√©√©mission - la connexion est ralentie.  Deuxi√®mement, dans le package SYN - et uniquement dans celui-ci!  - un certain nombre d'options sont transmises qui affectent le fonctionnement ult√©rieur de la connexion.  Sans se souvenir des paquets SYN entrants, le serveur ignore donc ces options, dans les prochains paquets le client ne les enverra plus.  Dans ce cas, TCP peut fonctionner, mais au moins au stade initial, la qualit√© de la connexion diminuera. </p></div></div><br><p>  En termes de packages, un programme XDP devrait faire ce qui suit: </p><br><ul><li>  SYNACK avec cookie pour r√©pondre √† SYN; </li><li>  r√©pondre √† ACK RST (d√©connecter); </li><li>  jetez les autres paquets. </li></ul><br><p>  Pseudocode d'algorithme avec analyse du package: </p><br><pre> <code class="plaintext hljs">   Ethernet,  .    IPv4,  .     , (*)    ,  .    TCP,  . (**)   SYN,  SYN-ACK  cookie.   ACK,   acknum   cookie,  .      N  . (*)  RST. (**)     .</code> </pre> <br><p>  Un <code>(*)</code> indique les points dans lesquels contr√¥ler l'√©tat du syst√®me - √† la premi√®re √©tape, vous pouvez vous en passer en impl√©mentant simplement une prise de contact TCP avec la g√©n√©ration d'un cookie SYN en tant que s√©quence. </p><br><p>  En place <code>(**)</code> , alors que nous n'avons pas de table, nous allons sauter le paquet. </p><br><h2 id="realizaciya-tcp-handshake">  Impl√©mentation du protocole TCP </h2><br><h3 id="razbor-paketa-i-verifikaciya-koda">  Analyser le package et v√©rifier le code </h3><br><p>  Nous avons besoin de structures d'en-t√™te de r√©seau: Ethernet ( <code>uapi/linux/if_ether.h</code> ), IPv4 ( <code>uapi/linux/ip.h</code> ) et TCP ( <code>uapi/linux/tcp.h</code> ).  Le dernier que je n'ai pas pu connecter en raison d'erreurs li√©es √† <code>atomic64_t</code> , j'ai d√ª copier les d√©finitions n√©cessaires dans le code. </p><br><p>  Toutes les fonctions qui sont allou√©es en C pour la lisibilit√© doivent √™tre int√©gr√©es √† l'endroit de l'appel, car le v√©rificateur eBPF dans le noyau interdit les transitions de retour, c'est-√†-dire, en fait, les boucles et les appels de fonction. </p><br><pre> <code class="plaintext hljs">#define INTERNAL static __attribute__((always_inline))</code> </pre> <br><p>  La macro <code>LOG()</code> d√©sactive l'impression dans la version finale. </p><br><p>  Le programme est un convoyeur de fonctions.  Chacun re√ßoit un paquet dans lequel l'en-t√™te du niveau correspondant est mis en √©vidence, par exemple, <code>process_ether()</code> s'attend <code>ether</code> ce que l' <code>ether</code> soit plein.  Sur la base des r√©sultats de l'analyse de champ, la fonction peut transf√©rer le paquet √† un niveau sup√©rieur.  Le r√©sultat de la fonction est l'action XDP.  Jusqu'√† pr√©sent, les gestionnaires SYN et ACK transmettent tous les paquets. </p><br><pre> <code class="plaintext hljs">struct Packet { struct xdp_md* ctx; struct ethhdr* ether; struct iphdr* ip; struct tcphdr* tcp; }; INTERNAL int process_tcp_syn(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp_ack(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp(struct Packet* packet) { ... } INTERNAL int process_ip(struct Packet* packet) { ... } INTERNAL int process_ether(struct Packet* packet) { struct ethhdr* ether = packet-&gt;ether; LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto)); if (ether-&gt;h_proto != bpf_ntohs(ETH_P_IP)) { return XDP_PASS; } // B struct iphdr* ip = (struct iphdr*)(ether + 1); if ((void*)(ip + 1) &gt; (void*)packet-&gt;ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } packet-&gt;ip = ip; return process_ip(packet); } SEC("prog") int xdp_main(struct xdp_md* ctx) { struct Packet packet; packet.ctx = ctx; // A struct ethhdr* ether = (struct ethhdr*)(void*)ctx-&gt;data; if ((void*)(ether + 1) &gt; (void*)ctx-&gt;data_end) { return XDP_PASS; } packet.ether = ether; return process_ether(&amp;packet); }</code> </pre> <br><p>  J'attire l'attention sur les v√©rifications marqu√©es A et B. Si vous commentez A, le programme s'assemblera, mais il y aura une erreur de v√©rification lors du chargement: </p><br><pre> <code class="plaintext hljs">Verifier analysis: &lt;...&gt; 11: (7b) *(u64 *)(r10 -48) = r1 12: (71) r3 = *(u8 *)(r7 +13) invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0) R7 offset is outside of the packet processed 11 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Error fetching program/map!</code> </pre> <br><p>  La ligne de cl√© est un <code>invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0)</code> : il existe des chemins d'ex√©cution lorsque le treizi√®me octet √† partir du d√©but du tampon est en dehors du paquet.  Selon la liste, il est difficile de comprendre de quelle ligne nous parlons, mais il y a un num√©ro d'instruction (12) et un d√©sassembleur montrant les lignes du code source: </p><br><pre> <code class="bash hljs">llvm-objdump -S xdp_filter.o | less</code> </pre> <br><p>  Dans ce cas, il pointe vers une cha√Æne </p><br><pre> <code class="plaintext hljs">LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto));</code> </pre> <br><p>  par lequel il est clair que le probl√®me est dans l' <code>ether</code> .  Il en serait toujours ainsi. </p><br><h3 id="otvet-na-syn">  R√©pondre √† SYN </h3><br><p>  Le but √† ce stade est de former un paquet SYNACK correct avec un <code>seqnum</code> fixe, qui sera remplac√© par un cookie SYN √† l'avenir.  Tous les changements se produisent dans <code>process_tcp_syn()</code> et dans les environs. </p><br><h4 id="proverka-paketa">  V√©rification du paquet </h4><br><p>  Curieusement, voici la ligne la plus remarquable, plus pr√©cis√©ment, un commentaire √† ce sujet: </p><br><pre> <code class="plaintext hljs">/* Required to verify checksum calculation */ const void* data_end = (const void*)ctx-&gt;data_end;</code> </pre> <br><p>  Lors de l'√©criture de la premi√®re version du code, le noyau 5.1 a √©t√© utilis√©, pour le v√©rificateur dont il y avait une diff√©rence entre <code>data_end</code> et <code>(const void*)ctx-&gt;data_end</code> .  Lors de l'√©criture de l'article, le noyau 5.3.1 n'avait pas un tel probl√®me.  Peut-√™tre que le compilateur a acc√©d√© √† la variable locale diff√©remment du champ.  Moral - un code simplifi√© peut aider √† beaucoup d'imbrication. </p><br><p>  Autres v√©rifications de routine des longueurs en l'honneur du v√©rificateur;  environ <code>MAX_CSUM_BYTES</code> ci-dessous. </p><br><pre> <code class="plaintext hljs">const u32 ip_len = ip-&gt;ihl * 4; if ((void*)ip + ip_len &gt; data_end) { return XDP_DROP; /* malformed packet */ } if (ip_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ } const u32 tcp_len = tcp-&gt;doff * 4; if ((void*)tcp + tcp_len &gt; (void*)ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } if (tcp_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ }</code> </pre> <br><h4 id="razvorot-paketa">  R√©partition des colis </h4><br><p>  Remplissez <code>seqnum</code> et <code>acknum</code> , d√©finissez ACK (SYN est d√©j√† d√©fini): </p><br><pre> <code class="plaintext hljs">const u32 cookie = 42; tcp-&gt;ack_seq = bpf_htonl(bpf_ntohl(tcp-&gt;seq) + 1); tcp-&gt;seq = bpf_htonl(cookie); tcp-&gt;ack = 1;</code> </pre> <br><p>  √âchangez les ports TCP, l'adresse IP et l'adresse MAC.  La biblioth√®que standard n'est pas accessible √† partir du programme XDP, donc <code>memcpy()</code> est une macro qui cache l'intrins√®que de Clang. </p><br><pre> <code class="plaintext hljs">const u16 temp_port = tcp-&gt;source; tcp-&gt;source = tcp-&gt;dest; tcp-&gt;dest = temp_port; const u32 temp_ip = ip-&gt;saddr; ip-&gt;saddr = ip-&gt;daddr; ip-&gt;daddr = temp_ip; struct ethhdr temp_ether = *ether; memcpy(ether-&gt;h_dest, temp_ether.h_source, ETH_ALEN); memcpy(ether-&gt;h_source, temp_ether.h_dest, ETH_ALEN);</code> </pre> <br><h4 id="pereschet-kontrolnyh-summ">  Recalcul du total de contr√¥le </h4><br><p>  Les sommes de contr√¥le IPv4 et TCP n√©cessitent l'ajout de tous les mots 16 bits dans les en-t√™tes, et la taille des en-t√™tes y est √©crite, c'est-√†-dire qu'au moment de la compilation, elle n'est pas connue.  Il s'agit d'un probl√®me car le v√©rificateur ne sautera pas une boucle r√©guli√®re vers une limite variable.  Mais la taille des en-t√™tes est limit√©e: jusqu'√† 64 octets chacun.  Vous pouvez faire une boucle avec un nombre fixe d'it√©rations, qui peut se terminer plus t√¥t que pr√©vu. </p><br><p>  Je note qu'il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC 1624</a> sur la fa√ßon de recalculer la somme de contr√¥le partiellement si seuls les mots de paquets fixes sont modifi√©s.  Cependant, la m√©thode n'est pas universelle et sa mise en ≈ìuvre serait plus difficile √† maintenir. </p><br><p>  Fonction de calcul de la somme de contr√¥le: </p><br><pre> <code class="plaintext hljs">#define MAX_CSUM_WORDS 32 #define MAX_CSUM_BYTES (MAX_CSUM_WORDS * 2) INTERNAL u32 sum16(const void* data, u32 size, const void* data_end) { u32 s = 0; #pragma unroll for (u32 i = 0; i &lt; MAX_CSUM_WORDS; i++) { if (2*i &gt;= size) { return s; /* normal exit */ } if (data + 2*i + 1 + 1 &gt; data_end) { return 0; /* should be unreachable */ } s += ((const u16*)data)[i]; } return s; }</code> </pre> <br><p>   ,  <code>size</code>   ,    ,      . </p><br><p>  32-     : </p><br><pre> <code class="plaintext hljs">INTERNAL u32 sum16_32(u32 v) { return (v &gt;&gt; 16) + (v &amp; 0xffff); }</code> </pre> <br><p>        : </p><br><pre> <code class="plaintext hljs">ip-&gt;check = 0; ip-&gt;check = carry(sum16(ip, ip_len, data_end)); u32 tcp_csum = 0; tcp_csum += sum16_32(ip-&gt;saddr); tcp_csum += sum16_32(ip-&gt;daddr); tcp_csum += 0x0600; tcp_csum += tcp_len &lt;&lt; 8; tcp-&gt;check = 0; tcp_csum += sum16(tcp, tcp_len, data_end); tcp-&gt;check = carry(tcp_csum); return XDP_TX;</code> </pre> <br><p>  <code>carry()</code>   32-  16-   ,  RFC 791. </p><br><h4 id="proverka-rukopozhatiya-tcp">   TCP </h4><br><p>      <code>netcat</code> ,   ACK,   Linux  RST-,       SYN ‚Äî     SYNACK    -       ,     . </p><br><pre> <code class="bash hljs">$ sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>        <code>tcpdump</code>  <code>xdp-remote</code>  , , <code>hping3</code>      . </p><br><h3 id="syn-cookie"> SYN cookie </h3><br><p>    XDP   .    , ,    .  Linux, ,   SipHash,     XDP     . </p><br><p>    TODO,    : </p><br><ul><li><p> XDP-    <code>cookie_seed</code> (  )   ,    ,         . </p><br></li><li><p>   SYN cookie  ACK-    ,   IP  ,     . </p><br></li></ul><br><p>   : </p><br><pre> <code class="bash hljs">$ sudoip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>      ( <code>flags=0x2</code> ‚Äî  SYN, <code>flags=0x10</code> ‚Äî  ACK): </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x20e6e11a dst=0x20e6e11e proto=6) TCP(sport=50836 dport=6666 flags=0x2) Ether(proto=0x800) IP(src=0xfe2cb11a dst=0xfe2cb11e proto=6) TCP(sport=50836 dport=6666 flags=0x10) cookie matches for client 20200c0</code> </pre> <br><p>     IP,    SYN flood  ,     ACK flood,   : </p><br><pre> <code class="bash hljs">sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test hping3 --flood -A -s 1111 -p 2222 192.0.2.1</code> </pre> <br><p>   : </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x15bd11a dst=0x15bd11e proto=6) TCP(sport=3236 dport=2222 flags=0x10) cookie mismatch</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  eBPF   XDP        ,     . , XDP ‚Äî      ,     ,  DPDK    kernel bypass.   , XDP     , ,   ,       .     ,          userspace-. </p><br><p>   ,   ,       ,     userspace-   . </p><br><p>  R√©f√©rences: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>   GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bpftrace Cheat Sheet</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BPF and XDP Reference Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XDP Tutorial</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PoC: compiling to eBPF from Rust</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473286/">https://habr.com/ru/post/fr473286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473274/index.html">√âv√©nements num√©riques √† Moscou du 28 octobre au 3 novembre</a></li>
<li><a href="../fr473276/index.html">√âv√©nements num√©riques √† Saint-P√©tersbourg du 28 octobre au 3 novembre</a></li>
<li><a href="../fr473278/index.html">Mise √† jour du terminal Windows: aper√ßu 1910</a></li>
<li><a href="../fr473282/index.html">Parth√©non. Slumdog milliardaires: comment les fr√®res Bukhman sont devenus milliardaires et Vologda en ligne - Global</a></li>
<li><a href="../fr473284/index.html">Senior, TechLead, Architecte - quelle est la prochaine √©tape? Comment g√©rer une routine de travail et o√π aller?</a></li>
<li><a href="../fr473288/index.html">Construisez votre code √† partir de z√©ro, il pompera votre niveau</a></li>
<li><a href="../fr473290/index.html">Julia. Par o√π commencer le projet? ...</a></li>
<li><a href="../fr473292/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 319 (du 21 au 27 octobre)</a></li>
<li><a href="../fr473294/index.html">Gestion de la m√©moire ou moins souvent vous tirer une balle dans le pied</a></li>
<li><a href="../fr473296/index.html">D√©marrage sans argent. Exp√©rience personnelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>