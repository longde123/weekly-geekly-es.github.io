<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏿 🧔 👩🏽‍🚒 Arbeiten Sie mit IPv6 in PHP 🍥 📊 🧑🏿‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben kürzlich den LIR-Status und / 29 IPv6-Block erhalten. Und dann mussten die festgelegten Subnetze nachverfolgt werden. Und da unsere Abrechnu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten Sie mit IPv6 in PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/484586/">  Wir haben kürzlich den LIR-Status und / 29 IPv6-Block erhalten.  Und dann mussten die festgelegten Subnetze nachverfolgt werden.  Und da unsere Abrechnung in PHP geschrieben war, musste ich mich ein wenig von dem Problem inspirieren lassen und feststellen, dass diese Sprache im Hinblick auf die Arbeit mit IPv6 nicht die freundlichste ist.  Under the cut - unsere Lösung für die Probleme bei der Arbeit mit Adressen und Bereichen.  Möglicherweise nicht das eleganteste, aber es führt die Aufgaben durch. <br><br><img src="https://habrastorage.org/webt/bk/on/p9/bkonp9-y-sxfdqvirte2ehjunr0.jpeg"><a name="habracut"></a><br><br><h3>  Ein bisschen Theorie </h3><br><blockquote>  <b>Haftungsausschluss.</b>  Wenn Sie wissen, was IPv6 ist und womit es gegessen wird, kann dieser Teil für Sie langweilig sein.  Es kann nicht sein. </blockquote><br>  Personen, die die IPv6-Annotation zum ersten Mal sehen, werden möglicherweise entmutigt.  Nach dem eleganten <i>64.233.177.101</i> stoßen wir plötzlich auf <i>2607: f8b0: 4002: c08 :: 8b</i> und können verwirrt werden.  Sowohl das als auch eine andere - nur für Menschen lesbare Darstellung von 32 bzw. 128 Bits.  Jedes IP-Paket enthält einen Header mit einer streng standardisierten Zuweisung jedes Bits.  Ohne noch tiefer in die Struktur der Header einzusteigen, müssen wir eines herausholen: Für Operationen mit IP-Adressen und -Bereichen ist es im Allgemeinen bequem, binäre Mathematik und bitweise Operationen zu verwenden.  Es ist auch am bequemsten, sie in der Datenbank als <i>BINARY (4)</i> für IPv4 und <i>BINARY (16)</i> für IPv6 zu speichern. <br><br>  Ein weiterer wichtiger Aspekt, der angesprochen werden sollte, sind Netzwerkmasken und die CIDR-Notation.  CIDR ist eine Abkürzung für Classless Inter-Domain Routing.  Dieses Konzept ersetzte die erste Klasse bei der Bestimmung, welcher Teil der IP-Adresse das Netzwerkpräfix und welcher Teil die Netzwerkschnittstellenadresse innerhalb dieses Netzwerks ist.  In der Praxis werden die ersten n Bits, die dem Präfix entsprechen, auf 1 gesetzt, der Rest auf 0. <br><br>  In lesbarer Form ist dies als <i>ip.add.re.ss. / cidr geschrieben</i> .  Zum Beispiel bedeutet <i>64.233.177.0/24</i> , dass sich die ersten 24 Bits auf das Präfix beziehen.  Die letzten 8 Bits, die letzte Nummer in einem für Menschen lesbaren Eintrag, beziehen sich auf die Adresse innerhalb des Subnetzes.  Noch ein paar Übungen.  <i>64.233.177.101/32</i> und <i>2607: f8b0: 4002: c08 :: 8b / 128</i> - eine bestimmte Adresse.  <i>2607: f8b0: 4002: c08 :: / 64</i> - die ersten 64 Bits (die ersten 4 Gruppen) - das Präfix, die restlichen 64 Bits - der lokale Teil.  Übrigens, wenn jemand durch das "::" im Eintrag in Verlegenheit gebracht wird, ersetzt ein Doppelpunkt eine beliebige Anzahl von Abschnitten, die 0 enthalten. Sie kann in der Annotation nur einmal vorkommen.  Mit anderen Worten, <i>2607: f8b0: 4002: c08 :: 8b = 2607: f8b0: 4002: c08: 0: 0: 0: 8b</i> . <br><br>  Was müssen wir daraus lernen?  Erstens können die erste und die letzte Subnetzadresse unter Verwendung von binärem UND und ODER erhalten werden, wobei die Maske in binärer Form bekannt ist.  Zweitens kann das nächste Teilnetz der Größe (d. H. Mit CIDR) <b>n</b> berechnet werden, indem 1 zur <b>n-</b> ten Position in binärer Darstellung addiert wird.  Mit binärer Sicht meine ich das Ergebnis der Verwendung der Funktionen <i>pack ()</i> und <i>inet_pton ()</i> und die weitere Verwendung von <a href="https://www.php.net/manual/ru/language.operators.bitwise.php">bitweisen Operatoren</a> durch binär - eine Darstellung im binären System, die beispielsweise mit <i>base_convert () erhalten werden kann</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Historischer Hintergrund</b> <div class="spoiler_text"> Der klassenlosen <s>Trennung der</s> Adressierung ging die klassenlose voraus.  In jenen fernen Jahren hatte niemand damit gerechnet, dass es so viele Subnetze geben würde, sie waren rechts und links in großen Blöcken verteilt: Klasse A - die ersten 8 Bits (d. H. Die erste Zahl) wurden mit dem führenden Bit 0 vorangestellt;  Klasse B - die ersten 16 (die ersten beiden Zahlen), die führenden Bits von 10;  Klasse C - die ersten 24 Bits, die führenden Bits von 110. Diese führenden Bits legen die Bereiche fest, in denen die Adresse einer Klasse ausgegeben wurde: <i>0.0.0.0 - 127.255.255.255</i> für Klasse A, <i>128.0.0.0 - 191.255.255.255</i> - Klasse B, 192.0 .0.0 - 223.255.255.255 - Klasse C. Als sich das Internet rund um den Planeten ausbreitete, stellten die Regulierungsbehörden fest, dass sie es versäumt hatten, und entwickelten in den frühen 90er Jahren ein klassenloses Konzept, das es ihnen ermöglichte, sich nicht an die führenden Bits zu binden.  Ein bisschen mehr Details findet man zum Beispiel im <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Großen und Allwissenden</a> . </div></div><br><br><h3>  Lass uns weiter üben </h3><br>  In der Praxis setzen wir die drei wahrscheinlichsten Aufgaben um, wie es mir schien: <br><br><ol><li>  Abrufen der ersten und letzten Adresse des Bereichs; </li><li>  Erhalten des nächsten Bereichs einer gegebenen Größe (CIDR); </li><li>  Überprüfen Sie, ob die Adresse zu einem Bereich gehört. </li></ol><br>  Die Implementierung erfolgt für IPv6, die Logik kann jedoch bei Bedarf einfach angepasst werden.  Ich habe einige Ideen von <a href="https://intsystem.org/coding/kak-rabotat-s-ipv6-v-php/">hier</a> , aber ein wenig anders umgesetzt.  Auch in den Beispielen wird nicht auf Eingabefehler geprüft.  Also lass uns gehen. <br><br>  Wie bereits erwähnt, können die erste und die letzte Adresse eines Bereichs mithilfe von bitweisen Operationen ermittelt werden, wobei der Bereichsanfang und die binäre Subnetzmaske bekannt sind.  Dementsprechend müssen wir zuerst CIDR in eine binäre Maske umwandeln.  Sammeln Sie dazu die hexadezimale Darstellung und packen Sie sie in eine Binärdatei. <br><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cidrToMask</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cidr)</span></span></span><span class="hljs-function"> </span></span>{ $mask = str_repeat(<span class="hljs-string"><span class="hljs-string">'f'</span></span>, ceil($cidr / <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask .= dechex(<span class="hljs-number"><span class="hljs-number">4</span></span> * ($cidr % <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask = str_pad($mask, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $mask); }</code> </pre> <br>  Call <i>Pack ('H *', $ mask)</i> packt die hexadezimale Darstellung auf dieselbe Weise wie <i>inet_pton ()</i> .  Der einzige Unterschied besteht darin, dass beim Aufruf von <i>pack ()</i> alle 0 vorhanden sein müssen und der Eintrag im Gegensatz zum lesbaren Eintrag keinen Doppelpunkt enthalten darf. <br><br>  Der nächste Schritt besteht darin, den Anfang und das Ende des Bereichs zu berechnen.  Und hier gibt es Nuancen.  Bitweise Operationen sind durch die Prozessorkapazität begrenzt.  Dementsprechend können auf meinem 32-Bit-CubieTruck, den ich manchmal für Testverwöhnungen verwende, nicht alle 128 Bit der Adresse in einem Vorgang verarbeitet werden.  Nichts hindert uns jedoch daran, es in 32-Bit-Gruppen aufzuteilen (nur für den Fall, wer weiß, auf welchen Prozessoren wir ausgeführt werden). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeBoundary</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $cidr, $which, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ $mask = cidrToMask($cidr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ip = inet_pton($ip); } $ipParts = str_split($ip, <span class="hljs-number"><span class="hljs-number">4</span></span>); $maskParts = str_split($mask, <span class="hljs-number"><span class="hljs-number">4</span></span>); $rangeParts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; count($ipParts); $i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($which == <span class="hljs-string"><span class="hljs-string">'start'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  &amp;       . */</span></span> $rangeParts[$i] = $ipParts[$i] &amp; $maskParts[$i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*  |    (~)           1. */</span></span> $rangeParts[$i] = $ipParts[$i] | ~$maskParts[$i]; } } $rangeBoundary = implode($rangeParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rangeBoundary; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($rangeBoundary); } }</code> </pre> <br>  Für die zukünftige Verwendung bieten wir die Möglichkeit, IP zu übertragen und das Ergebnis sowohl in binärer als auch in lesbarer Form zu erhalten.  Der <i>$ which-</i> Parameter hier legt fest, ob wir den Anfang oder das Ende des Bereichs abrufen möchten (die Werte sind <i>'start'</i> bzw. <i>'end'</i> ). <br><br>  Die nächste Aufgabe (neben der für unser Unternehmen praktischsten) ist die Berechnung des nächsten Bereichs.  Für diese Aufgabe fiel mir nichts Besseres ein, als wie man die Adresse in einen Binärstring zerlegt und an der gewünschten Position 1 addiert und dann alles zurückklappt.  Um zu verhindern, dass Artefakte irgendwo auftauchen, habe ich mich entschlossen, die Adresse während der Zerlegung und Assemblierung nach Bytes zu teilen. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ipStart, $cidr, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ipStart = inet_pton($ipStart); } $ipParts = str_split($ipStart, <span class="hljs-number"><span class="hljs-number">1</span></span>); $ipBin = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $ipPart) { $ipBin .= str_pad(base_convert(unpack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $ipPart)[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT); } <span class="hljs-comment"><span class="hljs-comment">/*  1       "" :) */</span></span> $i = $cidr - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($ipBin[$i] == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'0'</span></span>; } $i--; } $ipBinParts = str_split($ipBin, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipBinParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $ipBinPart) { $ipParts[$key] = pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, str_pad(base_convert($ipBinPart, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT)); } $nextIp = implode($ipParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $nextIp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($nextIp); } }</code> </pre> <br>  Die Ausgabe ist das Präfix des nächsten in <i>$ cidr</i> angegebenen <i>Größenbereichs</i> .  Mit dieser Funktion vergeben wir Adressblöcke an unsere Kunden. <br><br>  Überprüfen Sie abschließend, ob die Adresse zum Bereich gehört.  Zum Beispiel haben wir einen / 48-Block für die Verteilung von / 64-Blöcken an Kunden zugewiesen, und wir müssen sicherstellen, dass wir während des Termins nicht über den zugewiesenen Block hinausgehen (in der Praxis wird dies bald geschehen, aber es besteht immer noch eine Chance).  Hier ist alles einfach.  Wir erhalten den Anfang und das Ende des Bereichs in binärer Form und prüfen, ob die Adresse innerhalb liegt. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ipInRange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $rangeStart, $cidr)</span></span></span><span class="hljs-function"> </span></span>{ $start = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'start'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $end = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'end'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $ipBin = inet_pton($ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($ipBin &gt;= $start &amp;&amp; $ipBin &lt;= $end); }</code> </pre> <br>  Hoffe es war hilfreich.  Welche anderen Adressierungsfunktionen könnten für Sie hilfreich sein?  Ergänzungen, Kommentare und Codeüberprüfungen sind in den Kommentaren ausdrücklich erwünscht. <br><br>  Wenn Sie bereits Kunde bei uns sind oder nur daran denken, einer zu werden, empfehlen wir Ihnen anlässlich der Veröffentlichung dieses Artikels, block / 64 kostenlos für alle vps-Dienste oder einen dedizierten Server im Equinix Tier IV-Rechenzentrum in den Niederlanden zu erhalten, indem Sie auf Anfrage an die Vertriebsabteilung einen Link zu senden dieser Artikel im Ticket.  Das Angebot gilt bis März 2020. <br><br><h3>  Ein bisschen Werbung :) </h3><br>  Vielen Dank für Ihren Aufenthalt bei uns.  Mögen Sie unsere Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung aufgeben oder Ihren Freunden <a href="https://ua-hosting.company/cloudvps/nl">Cloud-basiertes VPS für Entwickler ab 4,99 US-Dollar</a> empfehlen, ein <b>einzigartiges Analogon zu Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">Die ganze Wahrheit über VPS (KVM) E5-2697 v3 (6 Kerne) 10 GB DDR4 480 GB SSD 1 Gbit / s ab 19 Dollar oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br>  <b>Dell R730xd 2-mal billiger im Equinix Tier IV-Rechenzentrum in Amsterdam?</b>  Nur wir haben <b><a href="https://ua-hosting.company/serversnl">2 x Intel TetraDeca-Core Xeon 2 x E5-2697v3 2,6 GHz 14C 64 GB DDR4 4 x 960 GB SSD 1 Gbit / s 100 TV ab 199 US-Dollar</a> in den Niederlanden!</b>  <b><b>Dell R420 - 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s 100 TB - ab 99 US-Dollar!</b></b>  Lesen Sie mehr über <a href="https://habr.com/company/ua-hosting/blog/329618/">das Erstellen von Infrastruktur-Bldg.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484586/">https://habr.com/ru/post/de484586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484574/index.html">Keine Zecken! Pflanzen gegen Lyme-Borreliose-Vektor</a></li>
<li><a href="../de484578/index.html">Service Level-Ziele - Google Experience (Übersetzung des Google SRE-Buchkapitels)</a></li>
<li><a href="../de484580/index.html">Was Sie über Simulatoren für das Gedächtnis wissen müssen</a></li>
<li><a href="../de484582/index.html">ASP.NET MVC - Entity Framework, MySQL und Verwenden von Dependency Resolver zum Auswählen eines Repositorys</a></li>
<li><a href="../de484584/index.html">Warum brauchen wir einen Manager in einem IT-Projekt und was passiert, wenn dies nicht der Fall ist?</a></li>
<li><a href="../de484588/index.html">Automatisiertes Programmverwaltungsmodell</a></li>
<li><a href="../de484590/index.html">Damit sich die Jungs nicht schämen zu zeigen</a></li>
<li><a href="../de484592/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 398 (13. - 19. Januar 2020)</a></li>
<li><a href="../de484596/index.html">Blazor Client Side Online Store: Teil 1 - Autorisierung oidc (oauth2) + Identity Server4</a></li>
<li><a href="../de484600/index.html">Microsoft Ignite The Tour Prague - Technische Konferenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>