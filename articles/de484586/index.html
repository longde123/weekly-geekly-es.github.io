<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèø üßî üë©üèΩ‚Äçüöí Arbeiten Sie mit IPv6 in PHP üç• üìä üßëüèø‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben k√ºrzlich den LIR-Status und / 29 IPv6-Block erhalten. Und dann mussten die festgelegten Subnetze nachverfolgt werden. Und da unsere Abrechnu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten Sie mit IPv6 in PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/484586/">  Wir haben k√ºrzlich den LIR-Status und / 29 IPv6-Block erhalten.  Und dann mussten die festgelegten Subnetze nachverfolgt werden.  Und da unsere Abrechnung in PHP geschrieben war, musste ich mich ein wenig von dem Problem inspirieren lassen und feststellen, dass diese Sprache im Hinblick auf die Arbeit mit IPv6 nicht die freundlichste ist.  Under the cut - unsere L√∂sung f√ºr die Probleme bei der Arbeit mit Adressen und Bereichen.  M√∂glicherweise nicht das eleganteste, aber es f√ºhrt die Aufgaben durch. <br><br><img src="https://habrastorage.org/webt/bk/on/p9/bkonp9-y-sxfdqvirte2ehjunr0.jpeg"><a name="habracut"></a><br><br><h3>  Ein bisschen Theorie </h3><br><blockquote>  <b>Haftungsausschluss.</b>  Wenn Sie wissen, was IPv6 ist und womit es gegessen wird, kann dieser Teil f√ºr Sie langweilig sein.  Es kann nicht sein. </blockquote><br>  Personen, die die IPv6-Annotation zum ersten Mal sehen, werden m√∂glicherweise entmutigt.  Nach dem eleganten <i>64.233.177.101</i> sto√üen wir pl√∂tzlich auf <i>2607: f8b0: 4002: c08 :: 8b</i> und k√∂nnen verwirrt werden.  Sowohl das als auch eine andere - nur f√ºr Menschen lesbare Darstellung von 32 bzw. 128 Bits.  Jedes IP-Paket enth√§lt einen Header mit einer streng standardisierten Zuweisung jedes Bits.  Ohne noch tiefer in die Struktur der Header einzusteigen, m√ºssen wir eines herausholen: F√ºr Operationen mit IP-Adressen und -Bereichen ist es im Allgemeinen bequem, bin√§re Mathematik und bitweise Operationen zu verwenden.  Es ist auch am bequemsten, sie in der Datenbank als <i>BINARY (4)</i> f√ºr IPv4 und <i>BINARY (16)</i> f√ºr IPv6 zu speichern. <br><br>  Ein weiterer wichtiger Aspekt, der angesprochen werden sollte, sind Netzwerkmasken und die CIDR-Notation.  CIDR ist eine Abk√ºrzung f√ºr Classless Inter-Domain Routing.  Dieses Konzept ersetzte die erste Klasse bei der Bestimmung, welcher Teil der IP-Adresse das Netzwerkpr√§fix und welcher Teil die Netzwerkschnittstellenadresse innerhalb dieses Netzwerks ist.  In der Praxis werden die ersten n Bits, die dem Pr√§fix entsprechen, auf 1 gesetzt, der Rest auf 0. <br><br>  In lesbarer Form ist dies als <i>ip.add.re.ss. / cidr geschrieben</i> .  Zum Beispiel bedeutet <i>64.233.177.0/24</i> , dass sich die ersten 24 Bits auf das Pr√§fix beziehen.  Die letzten 8 Bits, die letzte Nummer in einem f√ºr Menschen lesbaren Eintrag, beziehen sich auf die Adresse innerhalb des Subnetzes.  Noch ein paar √úbungen.  <i>64.233.177.101/32</i> und <i>2607: f8b0: 4002: c08 :: 8b / 128</i> - eine bestimmte Adresse.  <i>2607: f8b0: 4002: c08 :: / 64</i> - die ersten 64 Bits (die ersten 4 Gruppen) - das Pr√§fix, die restlichen 64 Bits - der lokale Teil.  √úbrigens, wenn jemand durch das "::" im Eintrag in Verlegenheit gebracht wird, ersetzt ein Doppelpunkt eine beliebige Anzahl von Abschnitten, die 0 enthalten. Sie kann in der Annotation nur einmal vorkommen.  Mit anderen Worten, <i>2607: f8b0: 4002: c08 :: 8b = 2607: f8b0: 4002: c08: 0: 0: 0: 8b</i> . <br><br>  Was m√ºssen wir daraus lernen?  Erstens k√∂nnen die erste und die letzte Subnetzadresse unter Verwendung von bin√§rem UND und ODER erhalten werden, wobei die Maske in bin√§rer Form bekannt ist.  Zweitens kann das n√§chste Teilnetz der Gr√∂√üe (d. H. Mit CIDR) <b>n</b> berechnet werden, indem 1 zur <b>n-</b> ten Position in bin√§rer Darstellung addiert wird.  Mit bin√§rer Sicht meine ich das Ergebnis der Verwendung der Funktionen <i>pack ()</i> und <i>inet_pton ()</i> und die weitere Verwendung von <a href="https://www.php.net/manual/ru/language.operators.bitwise.php">bitweisen Operatoren</a> durch bin√§r - eine Darstellung im bin√§ren System, die beispielsweise mit <i>base_convert () erhalten werden kann</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Historischer Hintergrund</b> <div class="spoiler_text"> Der klassenlosen <s>Trennung der</s> Adressierung ging die klassenlose voraus.  In jenen fernen Jahren hatte niemand damit gerechnet, dass es so viele Subnetze geben w√ºrde, sie waren rechts und links in gro√üen Bl√∂cken verteilt: Klasse A - die ersten 8 Bits (d. H. Die erste Zahl) wurden mit dem f√ºhrenden Bit 0 vorangestellt;  Klasse B - die ersten 16 (die ersten beiden Zahlen), die f√ºhrenden Bits von 10;  Klasse C - die ersten 24 Bits, die f√ºhrenden Bits von 110. Diese f√ºhrenden Bits legen die Bereiche fest, in denen die Adresse einer Klasse ausgegeben wurde: <i>0.0.0.0 - 127.255.255.255</i> f√ºr Klasse A, <i>128.0.0.0 - 191.255.255.255</i> - Klasse B, 192.0 .0.0 - 223.255.255.255 - Klasse C. Als sich das Internet rund um den Planeten ausbreitete, stellten die Regulierungsbeh√∂rden fest, dass sie es vers√§umt hatten, und entwickelten in den fr√ºhen 90er Jahren ein klassenloses Konzept, das es ihnen erm√∂glichte, sich nicht an die f√ºhrenden Bits zu binden.  Ein bisschen mehr Details findet man zum Beispiel im <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Gro√üen und Allwissenden</a> . </div></div><br><br><h3>  Lass uns weiter √ºben </h3><br>  In der Praxis setzen wir die drei wahrscheinlichsten Aufgaben um, wie es mir schien: <br><br><ol><li>  Abrufen der ersten und letzten Adresse des Bereichs; </li><li>  Erhalten des n√§chsten Bereichs einer gegebenen Gr√∂√üe (CIDR); </li><li>  √úberpr√ºfen Sie, ob die Adresse zu einem Bereich geh√∂rt. </li></ol><br>  Die Implementierung erfolgt f√ºr IPv6, die Logik kann jedoch bei Bedarf einfach angepasst werden.  Ich habe einige Ideen von <a href="https://intsystem.org/coding/kak-rabotat-s-ipv6-v-php/">hier</a> , aber ein wenig anders umgesetzt.  Auch in den Beispielen wird nicht auf Eingabefehler gepr√ºft.  Also lass uns gehen. <br><br>  Wie bereits erw√§hnt, k√∂nnen die erste und die letzte Adresse eines Bereichs mithilfe von bitweisen Operationen ermittelt werden, wobei der Bereichsanfang und die bin√§re Subnetzmaske bekannt sind.  Dementsprechend m√ºssen wir zuerst CIDR in eine bin√§re Maske umwandeln.  Sammeln Sie dazu die hexadezimale Darstellung und packen Sie sie in eine Bin√§rdatei. <br><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cidrToMask</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cidr)</span></span></span><span class="hljs-function"> </span></span>{ $mask = str_repeat(<span class="hljs-string"><span class="hljs-string">'f'</span></span>, ceil($cidr / <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask .= dechex(<span class="hljs-number"><span class="hljs-number">4</span></span> * ($cidr % <span class="hljs-number"><span class="hljs-number">4</span></span>)); $mask = str_pad($mask, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $mask); }</code> </pre> <br>  Call <i>Pack ('H *', $ mask)</i> packt die hexadezimale Darstellung auf dieselbe Weise wie <i>inet_pton ()</i> .  Der einzige Unterschied besteht darin, dass beim Aufruf von <i>pack ()</i> alle 0 vorhanden sein m√ºssen und der Eintrag im Gegensatz zum lesbaren Eintrag keinen Doppelpunkt enthalten darf. <br><br>  Der n√§chste Schritt besteht darin, den Anfang und das Ende des Bereichs zu berechnen.  Und hier gibt es Nuancen.  Bitweise Operationen sind durch die Prozessorkapazit√§t begrenzt.  Dementsprechend k√∂nnen auf meinem 32-Bit-CubieTruck, den ich manchmal f√ºr Testverw√∂hnungen verwende, nicht alle 128 Bit der Adresse in einem Vorgang verarbeitet werden.  Nichts hindert uns jedoch daran, es in 32-Bit-Gruppen aufzuteilen (nur f√ºr den Fall, wer wei√ü, auf welchen Prozessoren wir ausgef√ºhrt werden). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeBoundary</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $cidr, $which, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ $mask = cidrToMask($cidr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ip = inet_pton($ip); } $ipParts = str_split($ip, <span class="hljs-number"><span class="hljs-number">4</span></span>); $maskParts = str_split($mask, <span class="hljs-number"><span class="hljs-number">4</span></span>); $rangeParts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; count($ipParts); $i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($which == <span class="hljs-string"><span class="hljs-string">'start'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  &amp;       . */</span></span> $rangeParts[$i] = $ipParts[$i] &amp; $maskParts[$i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*  |    (~)           1. */</span></span> $rangeParts[$i] = $ipParts[$i] | ~$maskParts[$i]; } } $rangeBoundary = implode($rangeParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $rangeBoundary; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($rangeBoundary); } }</code> </pre> <br>  F√ºr die zuk√ºnftige Verwendung bieten wir die M√∂glichkeit, IP zu √ºbertragen und das Ergebnis sowohl in bin√§rer als auch in lesbarer Form zu erhalten.  Der <i>$ which-</i> Parameter hier legt fest, ob wir den Anfang oder das Ende des Bereichs abrufen m√∂chten (die Werte sind <i>'start'</i> bzw. <i>'end'</i> ). <br><br>  Die n√§chste Aufgabe (neben der f√ºr unser Unternehmen praktischsten) ist die Berechnung des n√§chsten Bereichs.  F√ºr diese Aufgabe fiel mir nichts Besseres ein, als wie man die Adresse in einen Bin√§rstring zerlegt und an der gew√ºnschten Position 1 addiert und dann alles zur√ºckklappt.  Um zu verhindern, dass Artefakte irgendwo auftauchen, habe ich mich entschlossen, die Adresse w√§hrend der Zerlegung und Assemblierung nach Bytes zu teilen. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ipStart, $cidr, $ipIsBin = false, $returnBin = false)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$ipIsBin) { $ipStart = inet_pton($ipStart); } $ipParts = str_split($ipStart, <span class="hljs-number"><span class="hljs-number">1</span></span>); $ipBin = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $ipPart) { $ipBin .= str_pad(base_convert(unpack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, $ipPart)[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT); } <span class="hljs-comment"><span class="hljs-comment">/*  1       "" :) */</span></span> $i = $cidr - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($ipBin[$i] == <span class="hljs-string"><span class="hljs-string">'0'</span></span>) { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $ipBin[$i] = <span class="hljs-string"><span class="hljs-string">'0'</span></span>; } $i--; } $ipBinParts = str_split($ipBin, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ipBinParts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $ipBinPart) { $ipParts[$key] = pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, str_pad(base_convert($ipBinPart, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT)); } $nextIp = implode($ipParts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($returnBin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $nextIp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inet_ntop($nextIp); } }</code> </pre> <br>  Die Ausgabe ist das Pr√§fix des n√§chsten in <i>$ cidr</i> angegebenen <i>Gr√∂√üenbereichs</i> .  Mit dieser Funktion vergeben wir Adressbl√∂cke an unsere Kunden. <br><br>  √úberpr√ºfen Sie abschlie√üend, ob die Adresse zum Bereich geh√∂rt.  Zum Beispiel haben wir einen / 48-Block f√ºr die Verteilung von / 64-Bl√∂cken an Kunden zugewiesen, und wir m√ºssen sicherstellen, dass wir w√§hrend des Termins nicht √ºber den zugewiesenen Block hinausgehen (in der Praxis wird dies bald geschehen, aber es besteht immer noch eine Chance).  Hier ist alles einfach.  Wir erhalten den Anfang und das Ende des Bereichs in bin√§rer Form und pr√ºfen, ob die Adresse innerhalb liegt. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ipInRange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ip, $rangeStart, $cidr)</span></span></span><span class="hljs-function"> </span></span>{ $start = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'start'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $end = getRangeBoundary($rangeStart, $cidr, <span class="hljs-string"><span class="hljs-string">'end'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $ipBin = inet_pton($ip); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($ipBin &gt;= $start &amp;&amp; $ipBin &lt;= $end); }</code> </pre> <br>  Hoffe es war hilfreich.  Welche anderen Adressierungsfunktionen k√∂nnten f√ºr Sie hilfreich sein?  Erg√§nzungen, Kommentare und Code√ºberpr√ºfungen sind in den Kommentaren ausdr√ºcklich erw√ºnscht. <br><br>  Wenn Sie bereits Kunde bei uns sind oder nur daran denken, einer zu werden, empfehlen wir Ihnen anl√§sslich der Ver√∂ffentlichung dieses Artikels, block / 64 kostenlos f√ºr alle vps-Dienste oder einen dedizierten Server im Equinix Tier IV-Rechenzentrum in den Niederlanden zu erhalten, indem Sie auf Anfrage an die Vertriebsabteilung einen Link zu senden dieser Artikel im Ticket.  Das Angebot gilt bis M√§rz 2020. <br><br><h3>  Ein bisschen Werbung :) </h3><br>  Vielen Dank f√ºr Ihren Aufenthalt bei uns.  M√∂gen Sie unsere Artikel?  M√∂chten Sie weitere interessante Materialien sehen?  Unterst√ºtzen Sie uns, indem Sie eine Bestellung aufgeben oder Ihren Freunden <a href="https://ua-hosting.company/cloudvps/nl">Cloud-basiertes VPS f√ºr Entwickler ab 4,99 US-Dollar</a> empfehlen, ein <b>einzigartiges Analogon zu Einstiegsservern, das wir f√ºr Sie erfunden haben:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">Die ganze Wahrheit √ºber VPS (KVM) E5-2697 v3 (6 Kerne) 10 GB DDR4 480 GB SSD 1 Gbit / s ab 19 Dollar oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verf√ºgbar). <br><br>  <b>Dell R730xd 2-mal billiger im Equinix Tier IV-Rechenzentrum in Amsterdam?</b>  Nur wir haben <b><a href="https://ua-hosting.company/serversnl">2 x Intel TetraDeca-Core Xeon 2 x E5-2697v3 2,6 GHz 14C 64 GB DDR4 4 x 960 GB SSD 1 Gbit / s 100 TV ab 199 US-Dollar</a> in den Niederlanden!</b>  <b><b>Dell R420 - 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s 100 TB - ab 99 US-Dollar!</b></b>  Lesen Sie mehr √ºber <a href="https://habr.com/company/ua-hosting/blog/329618/">das Erstellen von Infrastruktur-Bldg.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">Klasse mit Dell R730xd E5-2650 v4 Servern f√ºr 9.000 Euro f√ºr einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484586/">https://habr.com/ru/post/de484586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484574/index.html">Keine Zecken! Pflanzen gegen Lyme-Borreliose-Vektor</a></li>
<li><a href="../de484578/index.html">Service Level-Ziele - Google Experience (√úbersetzung des Google SRE-Buchkapitels)</a></li>
<li><a href="../de484580/index.html">Was Sie √ºber Simulatoren f√ºr das Ged√§chtnis wissen m√ºssen</a></li>
<li><a href="../de484582/index.html">ASP.NET MVC - Entity Framework, MySQL und Verwenden von Dependency Resolver zum Ausw√§hlen eines Repositorys</a></li>
<li><a href="../de484584/index.html">Warum brauchen wir einen Manager in einem IT-Projekt und was passiert, wenn dies nicht der Fall ist?</a></li>
<li><a href="../de484588/index.html">Automatisiertes Programmverwaltungsmodell</a></li>
<li><a href="../de484590/index.html">Damit sich die Jungs nicht sch√§men zu zeigen</a></li>
<li><a href="../de484592/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 398 (13. - 19. Januar 2020)</a></li>
<li><a href="../de484596/index.html">Blazor Client Side Online Store: Teil 1 - Autorisierung oidc (oauth2) + Identity Server4</a></li>
<li><a href="../de484600/index.html">Microsoft Ignite The Tour Prague - Technische Konferenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>