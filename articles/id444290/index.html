<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗣️ 🥪 👉🏻 Dasar-dasar pemrograman reaktif menggunakan RxJS. Bagian 2. Operator dan pipa 🦁 🙏🏼 👩🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, kami melihat aliran apa dan apa yang mereka makan. Pada bagian baru, kita akan berkenalan dengan metode apa yang disediakan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar pemrograman reaktif menggunakan RxJS. Bagian 2. Operator dan pipa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444290/"><img src="https://habrastorage.org/webt/rj/7g/bm/rj7gbmr84swtbidqadkbgh5bg3q.png"><br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> kami melihat aliran apa dan apa yang mereka makan.  Pada bagian baru, kita akan berkenalan dengan metode apa yang disediakan RxJS untuk menciptakan aliran, apa itu operator, pipa, dan cara bekerja dengannya. <br><br>  Seri artikel "Dasar-dasar pemrograman reaktif menggunakan RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1. Reaktivitas dan aliran</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3. Observasi Tingkat Tinggi</a> </li></ul><br><br>  RxJS memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">API yang</a> kaya.  Dokumentasi menjelaskan lebih dari seratus metode.  Untuk mengenal mereka sedikit, kita akan menulis aplikasi sederhana dan dalam praktiknya kita akan melihat seperti apa kode reaktif itu.  Anda akan melihat bahwa tugas yang sama, yang dulunya tampak rutin dan mengharuskan penulisan banyak kode, memiliki solusi yang elegan jika dilihat dari perspektif reaktivitas.  Tetapi sebelum kita mulai berlatih, kita akan melihat bagaimana aliran dapat direpresentasikan secara grafis dan berkenalan dengan metode yang mudah untuk membuat dan memprosesnya. <a name="habracut"></a><br><br><h4>  Representasi grafis utas </h4><br>  Untuk menunjukkan dengan jelas bagaimana aliran tertentu berperilaku, saya akan menggunakan notasi yang diadopsi dalam pendekatan reaktif.  Ingat contoh kami dari artikel sebelumnya: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); });</code> </pre> <br>  Berikut ini tampilan grafiknya: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Aliran biasanya digambarkan sebagai garis lurus.  Jika aliran memancarkan nilai apa pun, maka itu ditampilkan pada garis sebagai lingkaran.  Garis lurus di layar adalah sinyal untuk mengakhiri aliran.  Untuk menampilkan kesalahan, gunakan simbol - "×". <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.error(); });</code> </pre><br><img src="https://habrastorage.org/webt/qo/7i/ut/qo7iutxhycufjmujmhhbvjzxz5w.png"><br><br><h4>  Satu baris mengalir </h4><br>  Dalam praktik saya, saya jarang harus membuat contoh saya sendiri yang bisa diamati secara langsung.  Sebagian besar metode untuk membuat utas sudah ada di RxJS.  Untuk membuat aliran yang memancarkan nilai 1 dan 2, cukup menggunakan metode: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Metode menerima sejumlah argumen dan mengembalikan contoh selesai dari Observable.  Setelah berlangganan, itu akan memancarkan nilai yang diterima dan menyelesaikan: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Jika Anda ingin mewakili array sebagai aliran, maka Anda dapat menggunakan metode from.  Metode from sebagai argumen mengharapkan objek iterable (array, string, dll.) Atau janji, dan memproyeksikan objek ini ke aliran.  Beginilah tampilan aliran dari string: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/y7/ky/nd/y7kynd1a6oolkik-adnjnriav6e.png"><br><br>  Jadi, Anda dapat membungkus janji dalam aliran: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(promise);</code> </pre><br><img src="https://habrastorage.org/webt/rc/us/sr/rcussrgfjolqzykg9ao3lkj_aj4.png"><br><br>  <b>Catatan:</b> sering utas dibandingkan dengan janji.  Bahkan, mereka hanya memiliki satu kesamaan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strategi dorong untuk</a> menyebarkan perubahan.  Sisanya adalah entitas yang sama sekali berbeda.  Janji tidak dapat menghasilkan banyak nilai.  Itu hanya dapat mengeksekusi tekad atau penolakan, mis.  hanya memiliki dua negara.  Aliran dapat mengirimkan beberapa nilai, dan dapat digunakan kembali. <br><br>  Apakah Anda ingat contoh dengan interval dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> ?  Aliran ini adalah penghitung waktu yang menghitung waktu dalam detik dari saat berlangganan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  Inilah cara Anda dapat menerapkan hal yang sama dalam satu baris: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/yd/ju/ks/ydjuksn4esnkrup6euizzcnqwm8.png"><br><br>  Dan akhirnya, metode yang memungkinkan Anda untuk membuat aliran peristiwa untuk elemen DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = fromEvent(domElementRef, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);</code> </pre><br>  Sebagai nilai, aliran ini akan menerima dan memancarkan objek acara keyup. <br><br><h4>  Pipa &amp; Operator </h4><br>  Pipe adalah metode kelas yang dapat diobservasi ditambahkan dalam RxJS dalam versi 5.5.  Berkat itu, kami dapat membangun rantai operator untuk pemrosesan berurutan dari nilai yang diterima dalam aliran.  Pipa adalah saluran searah yang menghubungkan operator.  Operator itu sendiri adalah fungsi normal yang dijelaskan dalam RxJS yang memproses nilai dari aliran. <br><br>  Misalnya, mereka dapat mengonversi nilai dan meneruskannya lebih lanjut ke aliran, atau mereka dapat bertindak sebagai filter dan tidak melewatkan nilai apa pun jika tidak memenuhi kondisi yang ditentukan. <br><br>  Mari kita lihat operator yang sedang beraksi.  Lipat gandakan setiap nilai dari aliran dengan 2 menggunakan operator peta: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value * <span class="hljs-number"><span class="hljs-number">2</span></span>) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Inilah yang terlihat seperti aliran sebelum menerapkan operator peta: <br><br><img src="https://habrastorage.org/webt/ns/a_/fh/nsa_fhvt6qqz_yktb4yl4jgac-k.png"><br><br>  Setelah pernyataan peta: <br><br><img src="https://habrastorage.org/webt/5_/vt/ku/5_vtku2aaynipw8jt4gae9iotlc.png"><br><br>  Mari kita gunakan operator filter.  Pernyataan ini berfungsi seperti fungsi filter di kelas Array.  Metode mengambil fungsi sebagai argumen pertama, yang menggambarkan suatu kondisi.  Jika nilai dari aliran memenuhi kondisi, maka diteruskan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( <span class="hljs-comment"><span class="hljs-comment">//     filter(value =&gt; value % 2 !== 0), map(value = value * 2) ).subscribe({ next: console.log });</span></span></code> </pre><br>  Dan inilah bagaimana keseluruhan skema aliran kita akan terlihat: <br><br><img src="https://habrastorage.org/webt/ke/ne/wm/kenewmpioakcrwofit2b2x2k-je.png"><br><br>  Setelah filter: <br><br><img src="https://habrastorage.org/webt/l1/xr/z1/l1xrz1kaxs96xuz7t35k_6safny.png"><br><br>  Setelah peta: <br><br><img src="https://habrastorage.org/webt/uv/za/va/uvzavasqypswdfiqk51esahuu0g.png"><br><br>  <b>Catatan:</b> pipa! == berlangganan.  Metode pipa menyatakan perilaku aliran, tetapi tidak berlangganan.  Sampai Anda memanggil metode berlangganan, streaming Anda tidak akan mulai berfungsi. <br><br><h4>  Kami sedang menulis aplikasi </h4><br>  Sekarang kita telah mengetahui apa itu pipa dan operator, Anda dapat langsung berlatih.  Aplikasi kita akan melakukan satu tugas sederhana: menampilkan daftar repositori github terbuka dengan nama panggilan pemilik yang dimasukkan. <br><br>  Akan ada beberapa persyaratan: <br><br><ul><li>  Jangan jalankan permintaan API jika string yang dimasukkan dalam input berisi kurang dari 3 karakter; </li><li>  Agar tidak memenuhi permintaan untuk setiap karakter yang dimasukkan oleh pengguna, perlu mengatur penundaan (debounce) 700 milidetik sebelum mengakses API; </li></ul><br>  Untuk mencari repositori, kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">API github</a> .  Saya sarankan menjalankan contohnya sendiri di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">stackblitz</a> .  Di sana saya meletakkan implementasi selesai.  Tautan disediakan di akhir artikel. <br><br>  Mari kita mulai dengan markup html.  Mari kita jelaskan elemen input dan ul: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Kemudian, dalam file js atau ts, kita mendapatkan tautan ke elemen saat ini menggunakan API browser: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>);</code> </pre><br>  Kami juga membutuhkan metode yang akan menjalankan permintaan ke API github.  Di bawah ini adalah kode untuk fungsi getUsersRepsFromAPI, yang menerima nama panggilan pengguna dan melakukan permintaan ajax menggunakan fetch.  Kemudian ia mengembalikan janji, mengubah respons sukses ke json di sepanjang jalan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(response.ok) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>); }); }</code> </pre><br>  Selanjutnya, kami menulis metode yang akan mencantumkan nama-nama repositori: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> recordRepsToList = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reps.length; i++) { <span class="hljs-comment"><span class="hljs-comment">//    ,    if (!ul.children[i]) { const newEl = document.createElement('li'); ul.appendChild(newEl); } //      const li = ul.children[i]; li.innerHTML = reps[i].name; } //    while (ul.children.length &gt; reps.length) { ul.removeChild(ul.lastChild); } }</span></span></code> </pre><br>  Persiapan sudah selesai.  Saatnya untuk melihat tindakan RxJS.  Kita perlu mendengarkan acara masukan kami.  Pertama-tama, kita harus memahami bahwa dalam pendekatan reaktif, kita bekerja dengan aliran.  Untungnya, RxJS sudah menyediakan opsi serupa.  Ingat metode fromEvent yang saya sebutkan di atas.  Kami menggunakannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyUp = fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>); keyUp.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Sekarang acara kami disajikan sebagai streaming.  Jika kita melihat apa yang ditampilkan di konsol, kita akan melihat objek bertipe KeyboardEvent.  Tetapi kita membutuhkan nilai yang dimasukkan pengguna.  Di sinilah metode pipa dan operator peta berguna: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Kami melanjutkan ke implementasi persyaratan.  Untuk memulainya, kami akan menjalankan kueri ketika nilai yang dimasukkan berisi lebih dari dua karakter.  Untuk melakukan ini, gunakan operator filter: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Kami berurusan dengan persyaratan pertama.  Kita lanjutkan ke yang kedua.  Kita perlu menerapkan debounce.  RxJS memiliki pernyataan debounceTime.  Operator ini sebagai argumen pertama mengambil jumlah milidetik selama nilai akan ditahan sebelum diteruskan.  Dalam hal ini, setiap nilai baru akan mengatur ulang timer.  Jadi, pada output kita mendapatkan nilai terakhir, setelah 700 milidetik berlalu. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Inilah yang tampak seperti aliran kami tanpa debounceTime: <br><br><img src="https://habrastorage.org/webt/c4/tl/lc/c4tllccvfohixydheaohwj2wcvy.png"><br><br>  Dan ini adalah bagaimana aliran yang sama melewati pernyataan ini akan terlihat seperti: <br><br><img src="https://habrastorage.org/webt/o0/lg/lx/o0lglx4knoa6ulhkaafuvxyhl1o.png"><br><br>  Dengan debounceTime, kita cenderung menggunakan API, yang akan menghemat lalu lintas dan membongkar server. <br><br>  Untuk optimasi tambahan, saya sarankan menggunakan operator lain - differUntilChanged.  Metode ini akan menyelamatkan kita dari duplikat.  Yang terbaik adalah menunjukkan hasil kerjanya menggunakan contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'aaabccc'</span></span>).pipe( distinctUntilChanged() )</code> </pre><br>  Tanpa perubahan khusus Hingga: <br><br><img src="https://habrastorage.org/webt/ti/ng/7j/ting7jpkqbe1bgfb713x5wleaki.png"><br><br>  Dengan differentUntilChanged: <br><br><img src="https://habrastorage.org/webt/kv/is/-1/kvis-1lx1hwylsyg4dfvuf4tgoa.png"><br><br>  Tambahkan pernyataan ini segera setelah pernyataan debounceTime.  Dengan demikian, kami tidak akan mengakses API jika nilai baru karena beberapa alasan bertepatan dengan yang sebelumnya.  Situasi serupa dapat terjadi ketika pengguna memasukkan karakter baru dan kemudian menghapusnya lagi.  Karena kami telah menerapkan penundaan, hanya nilai terakhir yang akan jatuh ke aliran, jawaban yang sudah kami miliki. <br><br><h4>  Pergi ke server </h4><br>  Sudah sekarang kita dapat menggambarkan logika permintaan dan pemrosesan respons.  Sementara kita hanya bisa bekerja dengan janji.  Oleh karena itu, kami menggambarkan operator peta lain yang akan memanggil metode getUsersRepsFromAPI.  Di pengamat, kami menggambarkan logika pemrosesan janji kami: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  !     RxJS    promise,      */</span></span> fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> getUsersRepsFromAPI(value)) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function"> =&gt;</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps)) });</code> </pre><br>  Saat ini, kami telah mengimplementasikan semua yang kami inginkan.  Tetapi contoh kita memiliki satu kelemahan besar: tidak ada penanganan kesalahan.  Pengamat kami hanya menerima janji dan tidak tahu bahwa ada sesuatu yang salah. <br><br>  Tentu saja, kita dapat menggantungkan janji pada metode berikutnya, tetapi karena ini, kode kita akan mulai semakin menyerupai "panggilan balik neraka".  Jika tiba-tiba kita perlu menjalankan satu permintaan lagi, maka kompleksitas kode akan meningkat. <br><br>  <b>Catatan:</b> menggunakan janji dalam kode RxJS dianggap antipattern.  Janji memiliki banyak kelemahan dibandingkan dengan yang bisa diamati.  Itu tidak bisa diurungkan, dan tidak bisa digunakan kembali.  Jika Anda punya pilihan, pilih yang bisa diamati.  Hal yang sama berlaku untuk metode toPromise dari kelas Observable.  Metode ini diterapkan untuk kompatibilitas dengan perpustakaan yang tidak dapat bekerja dengan aliran. <br><br>  Kita dapat menggunakan metode dari untuk memproyeksikan janji ke aliran, tetapi metode ini penuh dengan panggilan tambahan untuk metode berlangganan, dan juga akan mengarah pada pertumbuhan dan kompleksitas kode. <br><br>  Masalah ini dapat dipecahkan menggunakan operator mergeMap: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Sekarang kita tidak perlu menulis logika pemrosesan janji.  Metode from membuat aliran janji, dan operator mergeMap memprosesnya.  Jika janji itu terpenuhi dengan sukses, maka metode selanjutnya disebut, dan pengamat kita akan menerima objek yang sudah jadi.  Jika kesalahan terjadi, metode kesalahan akan dipanggil, dan pengamat kami akan menampilkan kesalahan di konsol. <br><br>  Operator mergeMap sedikit berbeda dari operator yang pernah bekerja sama dengan kami, ini milik apa yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Observable Order Tinggi</a> , yang akan saya bahas di artikel selanjutnya.  Tetapi, melihat ke depan, saya akan mengatakan bahwa metode mergeMap sendiri berlangganan aliran. <br><br><h4>  Menangani kesalahan </h4><br>  Jika utas kami menerima kesalahan, maka itu akan berakhir.  Dan jika kita mencoba berinteraksi dengan aplikasi setelah kesalahan, maka kita tidak akan mendapatkan reaksi, karena utas kita telah selesai. <br><br>  Di sini operator catchError akan membantu kami.  catchError dimunculkan hanya ketika kesalahan terjadi di aliran.  Ini memungkinkan Anda untuk mencegatnya, memprosesnya dan kembali ke aliran nilai biasa, yang tidak akan mengarah pada penyelesaiannya. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Kami menangkap kesalahan dalam catchError dan sebagai gantinya mengembalikan aliran dengan array kosong.  Sekarang, ketika kesalahan terjadi, kami akan menghapus daftar repositori.  Namun kemudian aliran berakhir kembali. <br><br>  Masalahnya adalah bahwa catchError menggantikan aliran asli kami dengan yang baru.  Dan kemudian pengamat kami hanya mendengarkannya.  Ketika aliran memancarkan array kosong, metode lengkap akan dipanggil. <br><br>  Agar tidak mengganti utas asli kami, kami memanggil operator catchError di utas dari dalam operator mergeMap. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Dengan demikian, aliran asli kami tidak akan melihat apa pun.  Alih-alih kesalahan, itu akan mendapatkan array kosong. <br><br><h4>  Kesimpulan </h4><br>  Kami akhirnya mulai berlatih dan melihat apa gunanya pipa dan operator.  Kami melihat cara mengurangi kode menggunakan API kaya yang disediakan oleh RxJS.  Tentu saja, aplikasi kami belum selesai, di bagian selanjutnya kami akan menganalisis bagaimana Anda dapat memproses yang lain dalam satu utas dan cara membatalkan permintaan http kami untuk menghemat lebih banyak lalu lintas dan sumber daya aplikasi kami.  Dan agar Anda dapat melihat perbedaannya, saya memberikan contoh tanpa menggunakan RxJS, Anda dapat melihatnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> .  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">tautan ini</a> Anda akan menemukan kode lengkap dari aplikasi saat ini.  Untuk menghasilkan sirkuit, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">visualizer RxJS</a> . <br><br>  Saya harap artikel ini membantu Anda lebih memahami cara kerja RxJS.  Saya berharap Anda berhasil dalam studi Anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444290/">https://habr.com/ru/post/id444290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444278/index.html">Cara membuat puluhan ribu orang membaca artikel berbahasa Inggris Anda untuk Habr: 3 tips sederhana</a></li>
<li><a href="../id444282/index.html">7 Ekstensi Chrome Untuk Belajar Bahasa Inggris</a></li>
<li><a href="../id444284/index.html">komposer dan penyelesaian baris perintah</a></li>
<li><a href="../id444286/index.html">Penguraian kamera PTZ: apa yang ada di dalamnya dan cara kerjanya</a></li>
<li><a href="../id444288/index.html">Aplikasi mobile baru LampTest.ru</a></li>
<li><a href="../id444294/index.html">Bagaimana penerbangan bisnis bekerja di Rusia (pusat FBO)</a></li>
<li><a href="../id444296/index.html">6 sumber daya dan layanan yang bermanfaat bagi calon emigran ke AS, Jerman, dan Kanada</a></li>
<li><a href="../id444298/index.html">Para ilmuwan mengatakan mereka dapat mengubah bentuk dinosaurus hidup selama 5 tahun</a></li>
<li><a href="../id444300/index.html">Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 1</a></li>
<li><a href="../id444302/index.html">Evolusi arsitektur sistem perdagangan dan kliring Bursa Moskow. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>