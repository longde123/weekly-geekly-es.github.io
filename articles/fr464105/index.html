<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏻 🎚️ 👁‍🗨 Serveur natif Commento avec Docker Compose 🌅 👩‍👧‍👧 ⚪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque: il s'agit d'une traduction de mon article (en anglais), décrivant la mise en œuvre du serveur de commentaires utilisé sur le même site où se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serveur natif Commento avec Docker Compose</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464105/"><p>  <em>Remarque: il s'agit d'une traduction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon article</a> (en anglais), décrivant la mise en œuvre du serveur de commentaires utilisé sur le même site où se trouve l'original.</em> </p><br><blockquote>  Version TL; DR: J'ai développé la configuration du serveur Commento, qui se déploie facilement et simplement en mode semi-automatique.  Copiez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce référentiel</a> à partir de GitHub et suivez les instructions du <a href="">fichier README</a> . </blockquote><p>  Il y a quelque temps, je voulais irrésistiblement changer Disqus - qui est peut-être le système le plus courant pour ajouter des commentaires aux pages - en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Commento</a> gratuit et ouvert. </p><br>
<h2 id="pochemu-imenno-commento">  Pourquoi Commento? </h2><br><p>  Le problème avec Disqus, comme beaucoup d'autres produits "gratuits", c'est que le produit dans ce cas est l'utilisateur - c'est-à-dire vous.  De plus, Disqus «enrichit» chaque page où il est utilisé avec des mégaoctets de scripts et plus d'une <em>centaine de</em> requêtes HTTP supplémentaires. </p><br><p>  De plus, sa version gratuite affiche des publicités à partir desquelles vous pouvez payer "seulement" pour 9 $ par mois (plan Plus).  Cela suffit à lui seul pour vouloir trouver quelque chose de mieux. </p><br><p>  À un moment donné, je suis tombé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce post</a> et j'ai découvert l'existence d'un serveur de commentaires gratuit appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Commento</a> .  Par une heureuse coïncidence, Commento est récemment devenu complètement ouvert - avant qu'il ne soit disponible en deux versions, <em>Communauté</em> gratuite et <em>Entreprise</em> commerciale.  Merci à son développeur Adhityaa Chandrasekar. </p><a name="habracut"></a><br><p>  Commento est des <em>ordres de grandeur</em> plus efficaces que Disqus, la taille typique de la charge supplémentaire est d'environ <strong>11 Ko</strong> , plus les commentaires eux-mêmes, bien sûr.  Environ la même situation avec les requêtes HTTP requises. </p><br><p>  Un autre avantage du serveur Commento est qu'il est très rapide, car il est écrit en Go. </p><br><p>  Eh bien, cerise sur le gâteau, il a une importation de commentaires de Disqus, de quoi d'autre pourrait-il rêver? </p><br><h2 id="varianty-ispolzovaniya-commento">  Cas d'utilisation de Commento </h2><br><p>  Pour les utilisateurs non avancés (techniquement), Commento dispose d'un service cloud prêt à l'emploi sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commento.io</a> .  L'auteur vous propose de choisir vous-même le tarif mensuel, mais il ne peut être inférieur à 3 $ "pour des raisons techniques". </p><br><p>  M. Chandrasekar offre également généreusement un compte gratuit sur Commento.io en échange de «correctifs non triviaux» pour le produit. </p><br><p>  Eh bien, j'ai choisi la troisième option: augmenter moi-même le serveur Commento.  Dans ce cas, vous ne dépendez de personne (à part l'hébergeur, bien sûr), et j'aime l'indépendance. </p><br><h2 id="trudnosti">  Des difficultés </h2><br><p>  Je suis un grand fan des conteneurs Docker et j'utilise aussi souvent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker Compose</a> , un outil pour gérer des groupes de plusieurs conteneurs associés.  Commento a une image Docker prête à l'emploi dans le registre des conteneurs GitLab. </p><br><p>  Par conséquent, la décision d'utiliser des conteneurs a mûri par elle-même - mais d'abord quelques choses ont dû être décidées. </p><br><h3 id="trudnost-1-postgresql">  Difficulté n ° 1: PostgreSQL </h3><br><p>  Commento nécessite une version assez récente du serveur PostgreSQL, malheureusement aucun autre serveur SQL n'est pris en charge. </p><br><p>  Eh bien, nous exécutons toujours tout dans des conteneurs, c'est donc assez simple. </p><br><h3 id="trudnost-2-net-podderzhki-https">  Difficulté n ° 2: pas de support HTTPS </h3><br><p>  Commento lui-même est un serveur Web, mais il ne prend en charge que le protocole HTTP non sécurisé. </p><br><p>  Il convient de noter que cette pratique est assez courante de nos jours: dans ce cas, le serveur est caché derrière le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">proxy inverse</a> , qui effectue également le déchargement SSL.  Le fait est que le support SSL / HTTPS est absolument nécessaire dans ce cas, après tout, dans la cour 2019 et examiner les tentatives d'autorisation d'un utilisateur à l'aide d'un protocole Internet non sécurisé sera très ironique. </p><br><p>  J'ai décidé d'utiliser le serveur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nginx</a> , d'une part, j'avais une grande expérience de travail avec lui, et d'autre part, il est très rapide, économique et stable.  Et publie les versions officielles des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">images Docker</a> . </p><br><p>  Le deuxième ingrédient de la recette HTTPS est le certificat SSL du domaine.  Je suis éternellement reconnaissant à EFF et Mozilla d'avoir créé l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autorité de</a> certification <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Let's Encrypt</a> , qui émet des millions de certificats gratuits chaque mois. </p><br><p>  Let's Encrypt fournit également un utilitaire de ligne de commande gratuit appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certbot</a> , qui simplifie considérablement le processus d'obtention et de mise à jour d'un certificat.  Eh bien, et - bien sûr - une image Docker pour lui! </p><br><h3 id="trudnost-3-problema-kuricy-yayca-certbot">  Difficulté n ° 3: Problème d'oeufs de poulet Certbot </h3><br><p>  Mais cette astuce est plus délicate. </p><br><p>  Nous voulons faire référence au certificat SSL dans la configuration de notre proxy inverse sur Nginx, ce qui signifie que sans certificat, il refuse simplement de démarrer.  Dans le même temps, pour <em>obtenir un</em> certificat SSL pour un domaine, vous avez besoin d'un serveur HTTP fonctionnel, qui Let's Encrypt prouvera votre propriété de ce domaine. </p><br><p>  J'ai réussi à résoudre ce problème et, il me semble, assez élégamment: </p><br><ol><li>  Tout d'abord, un certificat factice non valide est généré, dont le seul but est de laisser Nginx démarrer. </li><li>  Nginx et certbot reçoivent conjointement un nouveau certificat, désormais valide. </li><li>  Dès réception du certificat, certbot passe en «mode veille», se réveillant toutes les 12 heures pour vérifier s'il doit être mis à jour - selon les recommandations de Let's Encrypt. </li><li>  Lorsque le moment est venu et que le certificat a été renouvelé, certbot signalera à Nginx de redémarrer. </li></ol><br><h3 id="trudnost-4-chto-to-dolzhno-sohranyatsya">  Difficulté n ° 4: quelque chose doit être préservé </h3><br><p>  Je soupçonne fortement que vous souhaitez que les commentaires des utilisateurs soient enregistrés après un redémarrage ou une mise à jour du système. </p><br><p>  De plus, afin que Let's Encrypt ne vous interdise pas en raison de demandes trop fréquentes, il serait bon de conserver les certificats reçus pour toute la date d'expiration. </p><br><p> Les deux points ont été résolus dans la configuration proposée en utilisant les volumes du Docker, créés automatiquement par <em>systemd</em> lors du premier lancement de Commento.  Les volumes sont marqués comme <code>external</code> , donc Docker les ignore lors de la suppression des conteneurs à l'aide de <code>docker-compose down -v</code> . </p><br><h2 id="svodim-vsyo-voedino">  Rassemblez tout </h2><br><p>  Vous pouvez maintenant voir comment tout cela fonctionne ensemble. </p><br><p>  La figure ci-dessous montre l'interaction et le trafic entre les quatre conteneurs: </p><br><p><img src="https://habrastorage.org/webt/zl/kr/y3/zlkry3l9lxx8mfwzzlsnuvubi6a.png"></p><br><p>  J'ai appliqué l'option <code>depends_on</code> Docker Compose <code>depends_on</code> pour garantir que les conteneurs démarrent dans le bon ordre. </p><br><p>  Si vous souhaitez uniquement démarrer votre propre serveur Commento, vous pouvez ignorer le reste de l'article et accéder directement au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code sur GitHub</a> . </p><br><p>  Eh bien, je parlerai plus en détail de cette implémentation plus tard. </p><br><h2 id="kak-eto-vsyo-rabotaet">  Comment ça marche </h2><br><h3 id="fayl-compose">  Composer un fichier </h3><br><p>  Comme vous pouvez le voir sur l'image ci-dessus, ma «composition» se compose de quatre services: </p><br><ol><li>  <code>certbot</code> - utilitaire <code>certbot</code> d'EFF </li><li>  <code>nginx</code> - proxy inverse implémentant le déchargement SSL </li><li>  <code>app</code> - serveur Commento </li><li>  <code>postgres</code> - Base de données PostgreSQL </li></ol><br><p>  Le <a href=""><code>docker-compose.yml</code></a> contient des déclarations de son propre réseau Docker, appelé <code>commento_network</code> , et trois volumes, dont deux externes (c'est-à-dire qu'ils doivent être créés en dehors de Compose): </p><br><ul><li>  <code>commento_postgres_volume</code> stocke les données du serveur PostgreSQL pour Commento: utilisateurs, modérateurs, commentaires, etc. </li><li>  <code>certbot_etc_volume</code> contient les certificats reçus par <code>certbot</code> . </li></ul><br><h3 id="nginx">  Nginx </h3><br><p>  Le conteneur Nginx est basé sur une image officielle légère basée sur Alpine et utilise le script suivant pour s'exécuter: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait for the certificate file to arrive wait_for_certs() { echo 'Waiting for config files from certbot...' i=0 while [[ ! -f /etc/letsencrypt/options-ssl-nginx.conf ]]; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo 'No files after 10 seconds, aborting' &amp;&amp; exit 2 done } # Watches for a "reload flag" (planted by certbot container) file and reloads nginx config once it's there watch_restart_flag() { while :; do [[ -f /var/www/certbot/.nginx-reload ]] &amp;&amp; rm -f /var/www/certbot/.nginx-reload &amp;&amp; echo 'Reloading nginx' &amp;&amp; nginx -s reload sleep 10 done } # Wait for certbot wait_for_certs # Start "reload flag" watcher watch_restart_flag &amp; # Run nginx in the foreground echo 'Starting nginx' exec nginx -g 'daemon off;'</span></span></code> </pre> <br><ul><li>  Ligne <strong>3</strong> ( <em>ARRGHHH, Habr ne prend pas en charge l'affichage des numéros de ligne dans le code - environ la traduction</em> ) <em>.</em> Un gestionnaire d'interruption est enregistré afin que Nginx et le processus de surveillance en arrière-plan terminent avec succès le travail lorsque le conteneur s'arrête. </li><li>  La ligne <strong>27</strong> appelle la fonction d'attente, qui suspend le processus de démarrage de Nginx jusqu'à ce que les fichiers de configuration SSL créés par le conteneur <code>certbot</code> .  Sans cela, Nginx refuserait de commencer. </li><li>  La ligne <strong>30</strong> crée un processus d'arrière-plan qui vérifie régulièrement, toutes les dix secondes, la présence d'un fichier indicateur avec le nom <code>.nginx-reload</code> , et dès qu'il le détecte, demande à Nginx de recharger la configuration.  Ce fichier crée également certbot lorsque le certificat est mis à jour. </li><li>  La ligne <strong>34</strong> démarre Nginx en mode normal.  Dans ce cas, <code>exec</code> signifie que le processus shell actuel est <em>remplacé par</em> le processus Nginx. </li></ul><br><p>  Un autre fichier important de cette image est la configuration du serveur virtuel Commento, qui force Nginx à transmettre les requêtes HTTPS au conteneur <code>commento</code> : </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">443</span></span> ssl ipv6only=<span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">443</span></span> ssl; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/html; <span class="hljs-attribute"><span class="hljs-attribute">index</span></span> index.html index.htm index.nginx-debian.html; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://app:8080/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$http_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-variable"><span class="hljs-variable">$proxy_add_x_forwarded_for</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /etc/letsencrypt/live/__DOMAIN__/fullchain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /etc/letsencrypt/live/__DOMAIN__/privkey.pem; <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="hljs-attribute"><span class="hljs-attribute">ssl_dhparam</span></span> /etc/letsencrypt/ssl-dhparams.pem; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /.well-known/acme-challenge/ { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/certbot; } <span class="hljs-comment"><span class="hljs-comment"># Redirect to HTTPS on port 80 location / { return 301 https://$host$request_uri; } }</span></span></code> </pre> <br><p>  Le premier bloc serveur (lignes <strong>1-21</strong> ) décrit comment travailler avec HTTPS et la règle de transfert.  C'est là que les fichiers de certificat Let's Encrypt sont mentionnés (ou les talons utilisés à la place). </p><br><p>  Le domaine servi par le serveur est passé en argument lors de la construction de l'image;  il remplace la ligne <code>__DOMAIN__</code> dans la configuration du serveur. </p><br><p>  Le deuxième bloc (lignes <strong>23-38</strong> ) est la configuration du serveur HTTP, qui est utilisé par le certbot pour confirmer la propriété du domaine (le soi-disant «défi ACME»).  Toutes les autres demandes entraînent une redirection vers l'adresse correspondante via HTTPS. </p><br><h3 id="certbot">  certbot </h3><br><p>  Notre image certbot est basée sur la version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">officielle</a> avec le script suivant: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait until nginx is up and running, up to 10 seconds wait_for_nginx() { echo 'Waiting for nginx...' i=0 while ! nc -z nginx 80 &amp;&gt;/dev/null; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo "nginx isn't online after 10 seconds, aborting" &amp;&amp; exit 4 done echo 'nginx is up and running' } # Check vars [[ -z "$DOMAIN" ]] &amp;&amp; echo "Environment variable 'DOMAIN' isn't defined" &amp;&amp; exit 2 [[ -z "$EMAIL" ]] &amp;&amp; echo "Environment variable 'EMAIL' isn't defined" &amp;&amp; exit 2 TEST="${TEST:-false}" # Check external mounts data_dir='/etc/letsencrypt' www_dir='/var/www/certbot' [[ ! -d "$data_dir" ]] &amp;&amp; echo "Directory $data_dir must be externally mounted" [[ ! -d "$www_dir" ]] &amp;&amp; echo "Directory $www_dir must be externally mounted" # If the config/certificates haven't been initialised yet if [[ ! -e "$data_dir/options-ssl-nginx.conf" ]]; then # Copy config over from the initial location echo 'Initialising nginx config' cp /conf/options-ssl-nginx.conf /conf/ssl-dhparams.pem "$data_dir/" # Copy dummy certificates mkdir -p "$data_dir/live/$DOMAIN" cp /conf/privkey.pem /conf/fullchain.pem "$data_dir/live/$DOMAIN/" # Wait for nginx wait_for_nginx # Remove dummy certificates rm -rf "$data_dir/live/$DOMAIN/" # Run certbot to validate/renew certificate test_arg= $TEST &amp;&amp; test_arg='--test-cert' certbot certonly --webroot -w /var/www/certbot -n -d "$DOMAIN" $test_arg -m "$EMAIL" --rsa-key-size 4096 --agree-tos --force-renewal # Reload nginx config touch /var/www/certbot/.nginx-reload # nginx config has been already initialised - just give nginx time to come up else wait_for_nginx fi # Run certbot in a loop for renewals while :; do certbot renew # Reload nginx config touch /var/www/certbot/.nginx-reload sleep 12h done</span></span></code> </pre> <br><p>  Un bref tour d'horizon de ses lignes: </p><br><ul><li>  La ligne <strong>3</strong> , comme dans le script précédent, est requise pour l'achèvement régulier du conteneur. </li><li>  Les lignes <strong>17-19</strong> vérifient les variables requises. </li><li>  Et dans les lignes <strong>22-25</strong> - que les répertoires nécessaires au fonctionnement de certbot sont montés correctement. </li><li>  La fourche suit: <br><ul><li>  Les lignes <strong>30-50</strong> sont exécutées uniquement au premier démarrage du conteneur: <br><ul><li>  Un certificat factice est copié, permettant à Nginx de démarrer normalement. </li><li>  Nginx, quant à lui, attend la fin de ce processus, après quoi il continue de se télécharger. </li><li>  Une fois Nginx démarré, certbot lance le processus d'obtention d'un certificat valide auprès de Let's Encrypt. </li><li>  Et enfin, dès que le certificat est reçu, le fichier <code>.nginx-reload</code> est créé, <code>.nginx-reload</code> entendre à Nginx qu'il est temps de recharger la configuration. </li></ul></li><li>  La ligne <strong>54</strong> attend le démarrage de Nginx - dans le cas où un certificat complet est déjà disponible. </li></ul></li><li>  Après tout cela (lignes <strong>58-63</strong> ), il continue de faire du vélo, une fois toutes les 12 heures vérifiant la nécessité de renouveler le certificat et signalant à Nginx de redémarrer. </li></ul><br><h3 id="commento-i-postgresql">  Commento et PostgreSQL </h3><br><p>  L' <code>app</code> et les conteneurs <code>postgres</code> utilisent les images originales fournies par les développeurs sans aucune modification. </p><br><h3 id="servis-systemd">  Service Systemd </h3><br><p>  La dernière pièce de ce puzzle est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier d'unité systemd</a> <code>commento.service</code> , sur lequel vous devez créer un lien symbolique dans <code>/etc/systemd/system/commento.service</code> pour qu'il démarre au bon moment au démarrage du système: </p><br><pre> <code class="plaintext hljs">[Unit] Description=Commento server [Service] TimeoutStopSec=30 WorkingDirectory=/opt/commento ExecStartPre=-/usr/bin/docker volume create commento_postgres_volume ExecStartPre=-/usr/bin/docker volume create certbot_etc_volume ExecStartPre=-/usr/local/bin/docker-compose -p commento down -v ExecStart=/usr/local/bin/docker-compose -p commento up --abort-on-container-exit ExecStop=/usr/local/bin/docker-compose -p commento down -v [Install] WantedBy=multi-user.target</code> </pre> <br><p>  Rangées: </p><br><ul><li>  La ligne <strong>6</strong> implique que le code du projet est cloné dans le répertoire <code>/opt/commento</code> - c'est beaucoup plus simple. </li><li>  Les lignes <strong>7 à 8</strong> créent des volumes externes, s'ils ne le sont pas déjà. </li><li>  À la ligne <strong>9</strong> , les restes éventuels des conteneurs précédents sont supprimés.  Les volumes extérieurs sont conservés. </li><li>  La ligne <strong>10</strong> marque le lancement réel de Docker Compose.  L' <code>--abort-on-container-exit</code> tout le troupeau de conteneurs lorsque l'un d'eux est <code>--abort-on-container-exit</code> .  Grâce à cela, systemd sera au moins conscient que le service est arrêté. </li><li>  La ligne <strong>11</strong> nettoie et supprime à nouveau les conteneurs, les réseaux et les volumes. </li></ul><br><h2 id="ishodnyy-kod">  Code source </h2><br><p>  Une implémentation pleinement fonctionnelle, ne nécessitant que la configuration des variables dans <code>docker-compose.yml</code> , est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> .  Il vous suffit de suivre attentivement les étapes décrites dans le <a href="">fichier README</a> . </p><br><p>  Le code est soumis à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">licence MIT</a> . </p><br><p>  Merci d'avoir lu cet endroit, les commentaires sont frénétiquement les bienvenus! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464105/">https://habr.com/ru/post/fr464105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464093/index.html">Produits numériques: que faire si un client vient chercher un achat dans un an?</a></li>
<li><a href="../fr464095/index.html">Getters et Setters à Dart et Flutter</a></li>
<li><a href="../fr464097/index.html">L'évolution de l'intelligence: pourquoi les robots ont besoin d'émotions</a></li>
<li><a href="../fr464099/index.html">Analyse du langage VKScript: JavaScript, êtes-vous?</a></li>
<li><a href="../fr464103/index.html">Projet de norme nationale IoT OpenUNB: examen critique</a></li>
<li><a href="../fr464107/index.html">Événements numériques à Moscou du 19 au 25 août</a></li>
<li><a href="../fr464109/index.html">Parachutes supersoniques spatiaux</a></li>
<li><a href="../fr464111/index.html">Natas Web. Passage de la plateforme CTF visant à exploiter les vulnérabilités du Web</a></li>
<li><a href="../fr464113/index.html">"CAD pour tout le monde, gratuitement et ne laissez personne partir ..." ou les premières étapes de la programmation de FreeCAD en Python</a></li>
<li><a href="../fr464115/index.html">Comment se faire des amis en tant que designer, maquettiste et «Figma» en utilisant un système de design, un pied-de-biche et une sorte de mère ™</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>