<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜ üë∞üèº üë©üèΩ‚Äçüç≥ Datenorientiertes Design (oder warum Sie sich mit OOP wahrscheinlich in den Fu√ü schie√üen) üåí üßëüèø üî§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stellen Sie sich dieses Bild vor: Das Ende des Entwicklungszyklus r√ºckt n√§her, Ihr Spiel schleicht sich kaum ein, aber im Profiler finden Sie keine of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenorientiertes Design (oder warum Sie sich mit OOP wahrscheinlich in den Fu√ü schie√üen)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472052/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="Bild"></div><br>  Stellen Sie sich dieses Bild vor: Das Ende des Entwicklungszyklus r√ºckt n√§her, Ihr Spiel schleicht sich kaum ein, aber im Profiler finden Sie keine offensichtlichen Problembereiche.  Wer ist schuld?  Arbeitsspeichermuster mit wahlfreiem Zugriff und anhaltende Cache-Fehler.  Wenn Sie versuchen, die Leistung zu verbessern, versuchen Sie, Teile des Codes zu parallelisieren, aber es lohnt sich, heldenhaft zu arbeiten, und am Ende ist die Beschleunigung aufgrund der hinzuzuf√ºgenden Synchronisation kaum sp√ºrbar.  Dar√ºber hinaus ist der Code so kompliziert, dass das Beheben von Fehlern noch mehr Probleme verursacht und der Gedanke, neue Funktionen hinzuzuf√ºgen, sofort verworfen wird.  Kommt Ihnen das bekannt vor? <br><br>  Eine solche Entwicklung von Ereignissen beschreibt ziemlich genau fast jedes Spiel, an dessen Entwicklung ich in den letzten zehn Jahren teilgenommen habe.  Die Gr√ºnde liegen nicht in Programmiersprachen oder Entwicklungswerkzeugen oder sogar in mangelnder Disziplin.  Nach meiner Erfahrung sollte weitgehend die objektorientierte Programmierung (OOP) und ihre umgebende Kultur verantwortlich gemacht werden.  OOP hilft vielleicht nicht, st√∂rt aber Ihre Projekte! <br><a name="habracut"></a><br><h2>  Es geht nur um Daten </h2><br>  OOP ist so weit in die bestehende Kultur der Videospielentwicklung eingedrungen, dass man sich kaum etwas anderes als Objekte vorstellen kann, wenn man an ein Spiel denkt.  Seit vielen Jahren schaffen wir Klassen f√ºr Autos, Spieler und Staatsmaschinen.  Was sind die Alternativen?  Prozedurale Programmierung?  Funktionssprachen?  Exotische Programmiersprachen? <br><br>  Datenorientiertes Design ist eine weitere M√∂glichkeit, Software zu entwickeln, mit der all diese Probleme gel√∂st werden k√∂nnen.  Das Hauptelement der prozeduralen Programmierung sind Prozeduraufrufe, und OOP befasst sich haupts√§chlich mit Objekten.  Beachten Sie, dass in beiden F√§llen der Code in die Mitte gestellt wird: In einem Fall handelt es sich um normale Prozeduren (oder Funktionen), in dem anderen um gruppierten Code, der einem bestimmten internen Status zugeordnet ist.  Datenorientiertes Design verlagert den Fokus der Aufmerksamkeit von Objekten auf die Daten selbst: die Art der Daten, ihre Position im Speicher, die Methoden zum Lesen und Verarbeiten im Spiel. <br><br>  Das Programmieren per Definition ist eine Methode zum Konvertieren von Daten: das Erstellen einer Folge von Maschinenanweisungen, die den Prozess der Verarbeitung von Eingabedaten und der Erstellung von Ausgabedaten beschreiben.  Ein Spiel ist nichts anderes als ein interaktives Programm. W√§re es nicht logischer, sich haupts√§chlich auf Daten zu konzentrieren und nicht auf den Code, der sie verarbeitet? <br><br>  Um Sie nicht zu verwirren, erkl√§re ich sofort: Datenorientiertes Design bedeutet nicht, dass das Programm datengesteuert ist.  Ein datengesteuertes Spiel ist normalerweise ein Spiel, dessen Funktionalit√§t weitgehend au√üerhalb des Codes liegt.  Es erm√∂glicht Daten, das Spielverhalten zu bestimmen.  Dieses Konzept ist unabh√§ngig vom datenorientierten Design und kann in jeder Programmiermethode verwendet werden. <br><br><h2>  Perfekte Daten </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/100/4e9/bb7/1004e9bb72c374929c1b914a344c43b9.png" alt="Anruffolge mit objektorientiertem Ansatz" width="229" height="247"></div><br>  <i>Abbildung 1a.</i>  <i>Aufrufsequenz mit objektorientiertem Ansatz</i> <br><br>  Wenn wir das Programm in Bezug auf Daten betrachten, wie sehen dann die idealen Daten aus?  Dies h√§ngt von den Daten selbst und ihrer Verwendung ab.  Im Allgemeinen liegen ideale Daten in einem Format vor, das mit minimalem Aufwand verwendet werden kann.  Im besten Fall stimmt das Format vollst√§ndig mit dem erwarteten Ausgabeergebnis √ºberein, dh die Verarbeitung besteht nur aus dem Kopieren der Daten.  Sehr oft sieht ein ideales Datenschema aus wie gro√üe Bl√∂cke benachbarter homogener Daten, die nacheinander verarbeitet werden k√∂nnen.  Wie auch immer, das Ziel ist es, die Anzahl der Transformationen zu minimieren.  Wenn m√∂glich, "backen" Sie die Daten in diesem idealen Format im Voraus, w√§hrend Sie Spielressourcen erstellen. <br><br>  Da beim datenorientierten Design die Daten an erster Stelle stehen, k√∂nnen wir die Architektur eines gesamten Programms um ein ideales Datenformat herum erstellen.  Es wird uns nicht immer gelingen, es vollst√§ndig zu perfektionieren (so wie der Code selten OOP aus einem Lehrbuch √§hnelt), aber dies ist unser Hauptziel, an das wir uns immer erinnern.  Wenn wir dies erreichen, l√∂sen sich die meisten der am Anfang des Artikels erw√§hnten Probleme einfach auf (mehr dazu im n√§chsten Abschnitt). <br><br>  Wenn wir an Objekte denken, erinnern wir uns sofort an die B√§ume - Vererbungsb√§ume, Nestb√§ume oder Nachrichtenb√§ume - und unsere Daten sind nat√ºrlich auf diese Weise geordnet.  Wenn wir eine Operation an einem Objekt ausf√ºhren, f√ºhrt dies normalerweise dazu, dass das Objekt wiederum auf andere Objekte im Baum zugreift.  Wenn Sie √ºber mehrere Objekte iterieren und dieselbe Operation ausf√ºhren, werden f√ºr jedes Objekt nachgeschaltete, v√∂llig unterschiedliche Operationen generiert (siehe Abbildung 1a). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="Anruffolge mit datenorientiertem Ansatz" width="233" height="297"></div><br>  <i>Abbildung 1b.</i>  <i>Anruffolge in datenorientierter Technik</i> <br><br>  Um das beste Datenspeicherungsschema zu erhalten, kann es n√ºtzlich sein, jedes Objekt in verschiedene Komponenten aufzuteilen und Komponenten desselben Typs im Speicher zu gruppieren, unabh√§ngig davon, von welchem ‚Äã‚ÄãObjekt wir sie genommen haben.  Eine solche Reihenfolge f√ºhrt zur Erstellung gro√üer Bl√∂cke homogener Daten, sodass wir die Daten nacheinander verarbeiten k√∂nnen (siehe Abbildung 1b).  Der Hauptgrund f√ºr die Leistungsf√§higkeit des datenorientierten Entwurfskonzepts liegt darin, dass es sehr gut mit gro√üen Gruppen von Objekten funktioniert.  OOP funktioniert per Definition mit einem einzelnen Objekt.  Erinnern Sie sich an das letzte Spiel, an dem Sie gearbeitet haben: Wie oft gab es im Code Stellen, an denen Sie nur mit einem Element arbeiten mussten?  Ein Feind?  Ein Fahrzeug?  Ein Weg Knoten finden?  Eine Kugel?  Ein St√ºck?  Niemals!  Wo es einen gibt, gibt es noch mehrere.  OOP ignoriert dies und arbeitet mit jedem Objekt einzeln.  Daher k√∂nnen wir die Arbeit f√ºr uns und die Ausr√ºstung vereinfachen, indem wir die Daten so anordnen, dass viele Elemente desselben Typs verarbeitet werden m√ºssen. <br><br>  Kommt Ihnen dieser Ansatz seltsam vor?  Aber wei√üt du was?  H√∂chstwahrscheinlich verwenden Sie es bereits in einigen Teilen des Codes: n√§mlich im Partikelsystem!  Datenorientiertes Design verwandelt die gesamte Codebasis in ein riesiges Partikelsystem.  Es ist m√∂glich, dass diese Methode den Spieleentwicklern vertrauter erschien, sie m√ºsste als partikelgesteuerte Programmierung bezeichnet werden. <br><br><h2>  Vorteile von datenorientiertem Design </h2><br>  Wenn wir zun√§chst √ºber Daten nachdenken und auf dieser Grundlage die Architektur des Programms erstellen, ergeben sich daraus viele Vorteile. <br><br><h3>  Parallelit√§t </h3><br>  Heutzutage ist es unm√∂glich, die Tatsache loszuwerden, dass wir mit mehreren Kernen arbeiten m√ºssen.  Diejenigen, die versucht haben, den OOP-Code zu parallelisieren, k√∂nnen best√§tigen, wie komplex, fehleranf√§llig und m√∂glicherweise nicht besonders effizient die Aufgabe ist.  Oft m√ºssen Sie viele Synchronisationsprimitive hinzuf√ºgen, um den gleichzeitigen Zugriff auf Daten von mehreren Threads zu vermeiden. In der Regel sind viele Threads lange Zeit inaktiv und warten darauf, dass andere Threads nicht mehr funktionieren.  Infolgedessen sind Produktivit√§tssteigerungen ziemlich mittelm√§√üig. <br><br>  Wenn wir datenorientiertes Design anwenden, wird die Parallelisierung viel einfacher: Wir haben Eingabedaten, eine kleine Funktion, die sie verarbeitet und Daten ausgibt.  √Ñhnliches kann leicht in mehrere Streams mit minimaler Synchronisation zwischen ihnen unterteilt werden.  Sie k√∂nnen sogar noch einen Schritt weiter gehen und diesen Code auf Prozessoren mit lokalem Speicher ausf√ºhren (z. B. in SPUs von Cell-Prozessoren), ohne Vorg√§nge zu √§ndern. <br><br><h3>  Cache-Nutzung </h3><br>  Neben der Verwendung von Multi-Core ist die Implementierung eines Datenzugriffs, der f√ºr das Caching geeignet ist, eine der wichtigsten M√∂glichkeiten, um auf modernen Ger√§ten mit Deep-Instruction-Pipelines und langsamen Speichersystemen mit mehreren Cache-Ebenen eine hohe Leistung zu erzielen.  Das datenorientierte Design erm√∂glicht eine sehr effiziente Verwendung des Befehls-Cache, da st√§ndig derselbe Code darin ausgef√ºhrt wird.  Wenn wir die Daten in gro√üen benachbarten Bl√∂cken anordnen, k√∂nnen wir die Daten au√üerdem nacheinander verarbeiten, wodurch eine nahezu perfekte Nutzung des Datencaches und eine hervorragende Leistung erzielt werden. <br><br><h2>  Optimierungsoption </h2><br>  Wenn wir an Objekte oder Funktionen denken, konzentrieren wir uns normalerweise auf die Optimierung auf der Ebene einer Funktion oder sogar eines Algorithmus: Wir versuchen, die Reihenfolge der Funktionsaufrufe zu √§ndern, die Sortiermethode zu √§ndern oder sogar einen Teil des C-Codes in Assemblersprache neu zu schreiben. <br><br>  Solche Optimierungen sind sicherlich n√ºtzlich, aber wenn Sie zuerst √ºber die Daten nachdenken, k√∂nnen wir einen Schritt zur√ºcktreten und ehrgeizigere und wichtigere Optimierungen erstellen.  Vergessen Sie nicht, dass sich das Spiel nur mit der Konvertierung bestimmter Daten (Ressourcen, Benutzereingaben, Status) in andere Daten (Grafikbefehle, neue Spielzust√§nde) befasst.  In Anbetracht dieses Datenstroms k√∂nnen wir fundiertere Entscheidungen auf h√∂herer Ebene treffen, basierend darauf, wie Daten konvertiert und angewendet werden.  Solche Optimierungen bei traditionelleren OOP-Techniken k√∂nnen √§u√üerst komplex und zeitaufw√§ndig sein. <br><br><h3>  Modularit√§t </h3><br>  Alle oben genannten Vorteile des datenorientierten Designs standen im Zusammenhang mit der Leistung: Cache-Nutzung, Optimierung und Parallelisierung.  Es besteht kein Zweifel, dass f√ºr uns Spielprogrammierer die Leistung √§u√üerst wichtig ist.  Oft gibt es einen Konflikt zwischen Techniken, die die Produktivit√§t steigern, und Techniken, die die Lesbarkeit des Codes und die einfache Entwicklung f√∂rdern.  Wenn wir beispielsweise einen Teil des Codes in Assemblersprache umschreiben, verbessern wir die Leistung. Dies f√ºhrt jedoch normalerweise zu einer Verringerung der Lesbarkeit und erschwert die Unterst√ºtzung des Codes. <br><br>  Gl√ºcklicherweise f√∂rdert datenorientiertes Design sowohl die Produktivit√§t als auch die einfache Entwicklung.  Wenn Sie Code speziell f√ºr die Datenkonvertierung schreiben, erhalten Sie kleine Funktionen mit einer sehr geringen Anzahl von Abh√§ngigkeiten zu anderen Teilen des Codes.  Die Codebasis bleibt sehr "flach", mit vielen "Blatt" -Funktionen, die keine gro√üen Abh√§ngigkeiten aufweisen.  Dieser Grad an Modularit√§t und das Fehlen von Abh√§ngigkeiten vereinfachen das Verst√§ndnis, Ersetzen und Aktualisieren von Code erheblich. <br><br><h3>  Testen </h3><br>  Der letzte gro√üe Vorteil des datenorientierten Designs ist die einfache Pr√ºfung.  Viele Menschen wissen, dass das Schreiben von Komponententests zum Testen der Interaktion von Objekten keine triviale Aufgabe ist.  Sie m√ºssen Layouts und Testelemente indirekt erstellen.  Ehrlich gesagt ist das ziemlich schmerzhaft.  Andererseits ist es absolut einfach, Unit-Tests direkt mit Daten zu schreiben: Wir erstellen einige eingehende Daten, rufen die Funktion auf, die sie konvertiert, und pr√ºfen, ob die Ausgabe mit den erwarteten Daten √ºbereinstimmt.  Und das ist alles.  Tats√§chlich ist dies ein gro√üer Vorteil, der das Testen von Codes erheblich vereinfacht, sei es die testgetriebene Entwicklung oder das Schreiben von Komponententests nach dem Code. <br><br><h2>  Nachteile des datenorientierten Designs </h2><br>  Datenorientiertes Design ist keine "Silberkugel", die alle Probleme bei der Spieleentwicklung l√∂st.  Es hilft wirklich beim Schreiben von Hochleistungscode und beim Erstellen von Programmen, die besser lesbar und einfacher zu warten sind, aber an sich einige Nachteile haben. <br><br>  Das Hauptproblem beim datenorientierten Design: Es unterscheidet sich von dem, was die meisten Programmierer gelernt und gewohnt sind.  Es erfordert, unser mentales Modell des Programms um neunzig Grad zu drehen und die Sichtweise darauf zu √§ndern.  Damit dieser Ansatz zur zweiten Natur wird, ist √úbung erforderlich. <br><br>  Aufgrund der unterschiedlichen Ans√§tze kann es au√üerdem zu Schwierigkeiten bei der Interaktion mit vorhandenem Code kommen, der in einem prozeduralen oder OOP-Stil geschrieben wurde.  Es ist schwierig, eine Funktion separat zu schreiben, aber sobald Sie ein datenorientiertes Design auf ein gesamtes Subsystem anwenden k√∂nnen, k√∂nnen Sie viele Vorteile erzielen. <br><br><h2>  Verwenden von datenorientiertem Design </h2><br>  Genug Theorie und Rezensionen.  Wie beginne ich mit der Implementierung der datenorientierten Entwurfsmethode?  W√§hlen Sie zun√§chst einen bestimmten Bereich Ihres Codes aus: Navigation, Animationen, Kollisionen oder etwas anderes.  Wenn sich der Hauptteil der Spiel-Engine sp√§ter auf Daten konzentriert, k√∂nnen Sie den Datenfluss entlang des gesamten Pfads vom Anfang des Frames bis zum Ende optimieren. <br><br>  Als n√§chstes m√ºssen die vom System ben√∂tigten Eingabedaten und die Art der Daten, die es generieren soll, klar identifiziert werden.  M√∂glicherweise denken Sie vorerst in der OOP-Terminologie, nur um die Daten zu identifizieren.  Bei einem Animationssystem sind beispielsweise Skelette, Grundposen, Animationsdaten und der aktuelle Status Teil der Eingabedaten.  Das Ergebnis ist kein ‚Äûanimierter Animationscode‚Äú, sondern Daten, die von den aktuell wiedergegebenen Animationen generiert werden.  In diesem Fall besteht die Ausgabe aus einem neuen Satz von Posen und einem aktualisierten Status. <br><br>  Es ist wichtig, einen Schritt zur√ºckzutreten und eingehende Daten anhand ihrer Verwendung zu klassifizieren.  Sind sie schreibgesch√ºtzt, schreibgesch√ºtzt oder schreibgesch√ºtzt?  Eine solche Klassifizierung hilft bei Entscheidungen dar√ºber, wo Daten gespeichert und wann sie verarbeitet werden sollen, da Abh√§ngigkeiten von anderen Teilen des Programms bestehen. <br><br>  In diesem Stadium m√ºssen Sie aufh√∂ren, √ºber die f√ºr einen Vorgang erforderlichen Daten nachzudenken, und dar√ºber nachdenken, sie auf Dutzende oder Hunderte von Elementen anzuwenden.  Wir haben nicht mehr ein Skelett, eine Grundhaltung und einen aktuellen Zustand: Wir haben einen Block von jedem dieser Typen mit vielen Instanzen in jedem der Bl√∂cke. <br><br>  √úberlegen Sie genau, wie die Daten im Transformationsprozess von der Eingabe zur Ausgabe verwendet werden.  M√∂glicherweise stellen Sie fest, dass Sie zum √úbertragen von Daten ein bestimmtes Feld in der Struktur scannen und dann die Ergebnisse verwenden m√ºssen, um einen weiteren Durchgang durchzuf√ºhren.  In diesem Fall ist es m√∂glicherweise logischer, dieses Quellfeld in einen separaten Speicherblock aufzuteilen, der separat verarbeitet werden kann, um den Cache besser zu nutzen und den Code f√ºr eine m√∂gliche Parallelisierung vorzubereiten.  Oder Sie m√ºssen m√∂glicherweise einen Teil des Codes vektorisieren, wenn Sie Daten von verschiedenen Orten empfangen m√ºssen, damit diese in ein Vektorregister gestellt werden.  In diesem Fall werden die Daten nebeneinander gespeichert, so dass Vektoroperationen ohne unn√∂tige Konvertierungen direkt angewendet werden k√∂nnen. <br><br>  Sie sollten jetzt ein sehr gutes Verst√§ndnis Ihrer Daten haben.  Das Schreiben von Code zum Konvertieren wird viel einfacher.  Es wird so sein, als w√ºrde man Code durch Ausf√ºllen von Leerzeichen erstellen.  Sie werden angenehm √ºberrascht sein, dass der Code im Vergleich zum gleichen OOP-Code viel einfacher und kompakter war als urspr√ºnglich angenommen. <br><br>  Die meisten Beitr√§ge in meinem Blog haben Sie auf diese Art von Design vorbereitet.  Jetzt m√ºssen wir vorsichtig sein, wie die Daten angeordnet sind, die Daten im Eingabeformat backen, damit sie effizient verwendet werden k√∂nnen, und Verkn√ºpfungen ohne Zeiger zwischen den Datenbl√∂cken verwenden, damit sie leicht verschoben werden k√∂nnen. <br><br><h2>  Ist noch Platz f√ºr die Verwendung von OOP? </h2><br>  Bedeutet dies, dass OOP nutzlos ist und niemals beim Erstellen von Programmen verwendet werden sollte?  Das kann ich nicht sagen.  Das Denken im Kontext von Objekten ist nicht sch√§dlich, wenn es sich nur um eine Instanz jedes Objekts handelt (z. B. ein Grafikger√§t, einen Protokollmanager usw.). In diesem Fall kann der Code jedoch auf der Grundlage einfacherer C-Funktionen und statischer Funktionen implementiert werden Daten auf Dateiebene.  Und selbst in dieser Situation ist es immer noch wichtig, dass Objekte mit Schwerpunkt auf Datentransformation entworfen werden. <br><br>  Eine andere Situation, in der ich immer noch OOP verwende, sind GUI-Systeme.  Vielleicht liegt dies daran, dass wir hier mit einem System arbeiten, das bereits objektorientiert entworfen wurde, oder vielleicht daran, dass Leistung und Komplexit√§t keine kritischen Faktoren f√ºr den GUI-Code sind.  Wie dem auch sei, ich bevorzuge GUI-APIs, die die Vererbung nur wenig nutzen und die Verschachtelung maximieren (gute Beispiele hierf√ºr sind Cocoa und CocoaTouch).  Es ist wahrscheinlich, dass Sie f√ºr Spiele gut aussehende GUI-Systeme mit Datenorientierung schreiben k√∂nnen, aber bisher habe ich solche nicht gesehen. <br><br>  Am Ende hindert Sie nichts daran, ein mentales Bild zu erstellen, das auf Objekten basiert, wenn Sie das Spiel lieber auf diese Weise betrachten.  Es ist nur so, dass die Essenz des Feindes nicht einen physischen Platz im Ged√§chtnis einnimmt, sondern in kleinere Unterkomponenten unterteilt wird, von denen jede Teil einer gro√üen Datentabelle √§hnlicher Komponenten ist. <br><br>  Datenorientiertes Design ist ein bisschen weit von herk√∂mmlichen Programmiermethoden entfernt. Wenn Sie jedoch immer √ºber Daten und die erforderlichen Transformationsmethoden nachdenken, erhalten Sie gro√üe Vorteile in Bezug auf Produktivit√§t und einfache Entwicklung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472052/">https://habr.com/ru/post/de472052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472036/index.html">Formel zur Berechnung von Primzahlen und zur Optimierung von Brute-Force-Teilern</a></li>
<li><a href="../de472040/index.html">Balancing Red-Black Trees - Drei F√§lle</a></li>
<li><a href="../de472042/index.html">Volle Mandantenf√§higkeit in Zimbra OSE mit Zextras Admin</a></li>
<li><a href="../de472044/index.html">√úbersicht √ºber ISPmanager - Hosting- und Site-Control-Panels</a></li>
<li><a href="../de472046/index.html">Konferenzen: der Anfang des Weges</a></li>
<li><a href="../de472054/index.html">Organisatoren und Lehrassistenten zu CS Center Online-Programmen</a></li>
<li><a href="../de472060/index.html">Die deutsche Polizei st√ºrmte einen Milit√§rbunker, in dem sich das neu deklarierte Rechenzentrum befand</a></li>
<li><a href="../de472062/index.html">√úberwachung + Stresstest = Prognose und keine Fehler</a></li>
<li><a href="../de472064/index.html">Ansible + Auto Git Pull im Cluster der virtuellen Maschine in der Cloud</a></li>
<li><a href="../de472068/index.html">Verwenden der NVME-SSD als Systemlaufwerk auf Computern mit altem BIOS und Linux-Betriebssystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>