<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆 👰🏼 👩🏽‍🍳 Datenorientiertes Design (oder warum Sie sich mit OOP wahrscheinlich in den Fuß schießen) 🌒 🧑🏿 🔤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stellen Sie sich dieses Bild vor: Das Ende des Entwicklungszyklus rückt näher, Ihr Spiel schleicht sich kaum ein, aber im Profiler finden Sie keine of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenorientiertes Design (oder warum Sie sich mit OOP wahrscheinlich in den Fuß schießen)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472052/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="Bild"></div><br>  Stellen Sie sich dieses Bild vor: Das Ende des Entwicklungszyklus rückt näher, Ihr Spiel schleicht sich kaum ein, aber im Profiler finden Sie keine offensichtlichen Problembereiche.  Wer ist schuld?  Arbeitsspeichermuster mit wahlfreiem Zugriff und anhaltende Cache-Fehler.  Wenn Sie versuchen, die Leistung zu verbessern, versuchen Sie, Teile des Codes zu parallelisieren, aber es lohnt sich, heldenhaft zu arbeiten, und am Ende ist die Beschleunigung aufgrund der hinzuzufügenden Synchronisation kaum spürbar.  Darüber hinaus ist der Code so kompliziert, dass das Beheben von Fehlern noch mehr Probleme verursacht und der Gedanke, neue Funktionen hinzuzufügen, sofort verworfen wird.  Kommt Ihnen das bekannt vor? <br><br>  Eine solche Entwicklung von Ereignissen beschreibt ziemlich genau fast jedes Spiel, an dessen Entwicklung ich in den letzten zehn Jahren teilgenommen habe.  Die Gründe liegen nicht in Programmiersprachen oder Entwicklungswerkzeugen oder sogar in mangelnder Disziplin.  Nach meiner Erfahrung sollte weitgehend die objektorientierte Programmierung (OOP) und ihre umgebende Kultur verantwortlich gemacht werden.  OOP hilft vielleicht nicht, stört aber Ihre Projekte! <br><a name="habracut"></a><br><h2>  Es geht nur um Daten </h2><br>  OOP ist so weit in die bestehende Kultur der Videospielentwicklung eingedrungen, dass man sich kaum etwas anderes als Objekte vorstellen kann, wenn man an ein Spiel denkt.  Seit vielen Jahren schaffen wir Klassen für Autos, Spieler und Staatsmaschinen.  Was sind die Alternativen?  Prozedurale Programmierung?  Funktionssprachen?  Exotische Programmiersprachen? <br><br>  Datenorientiertes Design ist eine weitere Möglichkeit, Software zu entwickeln, mit der all diese Probleme gelöst werden können.  Das Hauptelement der prozeduralen Programmierung sind Prozeduraufrufe, und OOP befasst sich hauptsächlich mit Objekten.  Beachten Sie, dass in beiden Fällen der Code in die Mitte gestellt wird: In einem Fall handelt es sich um normale Prozeduren (oder Funktionen), in dem anderen um gruppierten Code, der einem bestimmten internen Status zugeordnet ist.  Datenorientiertes Design verlagert den Fokus der Aufmerksamkeit von Objekten auf die Daten selbst: die Art der Daten, ihre Position im Speicher, die Methoden zum Lesen und Verarbeiten im Spiel. <br><br>  Das Programmieren per Definition ist eine Methode zum Konvertieren von Daten: das Erstellen einer Folge von Maschinenanweisungen, die den Prozess der Verarbeitung von Eingabedaten und der Erstellung von Ausgabedaten beschreiben.  Ein Spiel ist nichts anderes als ein interaktives Programm. Wäre es nicht logischer, sich hauptsächlich auf Daten zu konzentrieren und nicht auf den Code, der sie verarbeitet? <br><br>  Um Sie nicht zu verwirren, erkläre ich sofort: Datenorientiertes Design bedeutet nicht, dass das Programm datengesteuert ist.  Ein datengesteuertes Spiel ist normalerweise ein Spiel, dessen Funktionalität weitgehend außerhalb des Codes liegt.  Es ermöglicht Daten, das Spielverhalten zu bestimmen.  Dieses Konzept ist unabhängig vom datenorientierten Design und kann in jeder Programmiermethode verwendet werden. <br><br><h2>  Perfekte Daten </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/100/4e9/bb7/1004e9bb72c374929c1b914a344c43b9.png" alt="Anruffolge mit objektorientiertem Ansatz" width="229" height="247"></div><br>  <i>Abbildung 1a.</i>  <i>Aufrufsequenz mit objektorientiertem Ansatz</i> <br><br>  Wenn wir das Programm in Bezug auf Daten betrachten, wie sehen dann die idealen Daten aus?  Dies hängt von den Daten selbst und ihrer Verwendung ab.  Im Allgemeinen liegen ideale Daten in einem Format vor, das mit minimalem Aufwand verwendet werden kann.  Im besten Fall stimmt das Format vollständig mit dem erwarteten Ausgabeergebnis überein, dh die Verarbeitung besteht nur aus dem Kopieren der Daten.  Sehr oft sieht ein ideales Datenschema aus wie große Blöcke benachbarter homogener Daten, die nacheinander verarbeitet werden können.  Wie auch immer, das Ziel ist es, die Anzahl der Transformationen zu minimieren.  Wenn möglich, "backen" Sie die Daten in diesem idealen Format im Voraus, während Sie Spielressourcen erstellen. <br><br>  Da beim datenorientierten Design die Daten an erster Stelle stehen, können wir die Architektur eines gesamten Programms um ein ideales Datenformat herum erstellen.  Es wird uns nicht immer gelingen, es vollständig zu perfektionieren (so wie der Code selten OOP aus einem Lehrbuch ähnelt), aber dies ist unser Hauptziel, an das wir uns immer erinnern.  Wenn wir dies erreichen, lösen sich die meisten der am Anfang des Artikels erwähnten Probleme einfach auf (mehr dazu im nächsten Abschnitt). <br><br>  Wenn wir an Objekte denken, erinnern wir uns sofort an die Bäume - Vererbungsbäume, Nestbäume oder Nachrichtenbäume - und unsere Daten sind natürlich auf diese Weise geordnet.  Wenn wir eine Operation an einem Objekt ausführen, führt dies normalerweise dazu, dass das Objekt wiederum auf andere Objekte im Baum zugreift.  Wenn Sie über mehrere Objekte iterieren und dieselbe Operation ausführen, werden für jedes Objekt nachgeschaltete, völlig unterschiedliche Operationen generiert (siehe Abbildung 1a). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="Anruffolge mit datenorientiertem Ansatz" width="233" height="297"></div><br>  <i>Abbildung 1b.</i>  <i>Anruffolge in datenorientierter Technik</i> <br><br>  Um das beste Datenspeicherungsschema zu erhalten, kann es nützlich sein, jedes Objekt in verschiedene Komponenten aufzuteilen und Komponenten desselben Typs im Speicher zu gruppieren, unabhängig davon, von welchem ​​Objekt wir sie genommen haben.  Eine solche Reihenfolge führt zur Erstellung großer Blöcke homogener Daten, sodass wir die Daten nacheinander verarbeiten können (siehe Abbildung 1b).  Der Hauptgrund für die Leistungsfähigkeit des datenorientierten Entwurfskonzepts liegt darin, dass es sehr gut mit großen Gruppen von Objekten funktioniert.  OOP funktioniert per Definition mit einem einzelnen Objekt.  Erinnern Sie sich an das letzte Spiel, an dem Sie gearbeitet haben: Wie oft gab es im Code Stellen, an denen Sie nur mit einem Element arbeiten mussten?  Ein Feind?  Ein Fahrzeug?  Ein Weg Knoten finden?  Eine Kugel?  Ein Stück?  Niemals!  Wo es einen gibt, gibt es noch mehrere.  OOP ignoriert dies und arbeitet mit jedem Objekt einzeln.  Daher können wir die Arbeit für uns und die Ausrüstung vereinfachen, indem wir die Daten so anordnen, dass viele Elemente desselben Typs verarbeitet werden müssen. <br><br>  Kommt Ihnen dieser Ansatz seltsam vor?  Aber weißt du was?  Höchstwahrscheinlich verwenden Sie es bereits in einigen Teilen des Codes: nämlich im Partikelsystem!  Datenorientiertes Design verwandelt die gesamte Codebasis in ein riesiges Partikelsystem.  Es ist möglich, dass diese Methode den Spieleentwicklern vertrauter erschien, sie müsste als partikelgesteuerte Programmierung bezeichnet werden. <br><br><h2>  Vorteile von datenorientiertem Design </h2><br>  Wenn wir zunächst über Daten nachdenken und auf dieser Grundlage die Architektur des Programms erstellen, ergeben sich daraus viele Vorteile. <br><br><h3>  Parallelität </h3><br>  Heutzutage ist es unmöglich, die Tatsache loszuwerden, dass wir mit mehreren Kernen arbeiten müssen.  Diejenigen, die versucht haben, den OOP-Code zu parallelisieren, können bestätigen, wie komplex, fehleranfällig und möglicherweise nicht besonders effizient die Aufgabe ist.  Oft müssen Sie viele Synchronisationsprimitive hinzufügen, um den gleichzeitigen Zugriff auf Daten von mehreren Threads zu vermeiden. In der Regel sind viele Threads lange Zeit inaktiv und warten darauf, dass andere Threads nicht mehr funktionieren.  Infolgedessen sind Produktivitätssteigerungen ziemlich mittelmäßig. <br><br>  Wenn wir datenorientiertes Design anwenden, wird die Parallelisierung viel einfacher: Wir haben Eingabedaten, eine kleine Funktion, die sie verarbeitet und Daten ausgibt.  Ähnliches kann leicht in mehrere Streams mit minimaler Synchronisation zwischen ihnen unterteilt werden.  Sie können sogar noch einen Schritt weiter gehen und diesen Code auf Prozessoren mit lokalem Speicher ausführen (z. B. in SPUs von Cell-Prozessoren), ohne Vorgänge zu ändern. <br><br><h3>  Cache-Nutzung </h3><br>  Neben der Verwendung von Multi-Core ist die Implementierung eines Datenzugriffs, der für das Caching geeignet ist, eine der wichtigsten Möglichkeiten, um auf modernen Geräten mit Deep-Instruction-Pipelines und langsamen Speichersystemen mit mehreren Cache-Ebenen eine hohe Leistung zu erzielen.  Das datenorientierte Design ermöglicht eine sehr effiziente Verwendung des Befehls-Cache, da ständig derselbe Code darin ausgeführt wird.  Wenn wir die Daten in großen benachbarten Blöcken anordnen, können wir die Daten außerdem nacheinander verarbeiten, wodurch eine nahezu perfekte Nutzung des Datencaches und eine hervorragende Leistung erzielt werden. <br><br><h2>  Optimierungsoption </h2><br>  Wenn wir an Objekte oder Funktionen denken, konzentrieren wir uns normalerweise auf die Optimierung auf der Ebene einer Funktion oder sogar eines Algorithmus: Wir versuchen, die Reihenfolge der Funktionsaufrufe zu ändern, die Sortiermethode zu ändern oder sogar einen Teil des C-Codes in Assemblersprache neu zu schreiben. <br><br>  Solche Optimierungen sind sicherlich nützlich, aber wenn Sie zuerst über die Daten nachdenken, können wir einen Schritt zurücktreten und ehrgeizigere und wichtigere Optimierungen erstellen.  Vergessen Sie nicht, dass sich das Spiel nur mit der Konvertierung bestimmter Daten (Ressourcen, Benutzereingaben, Status) in andere Daten (Grafikbefehle, neue Spielzustände) befasst.  In Anbetracht dieses Datenstroms können wir fundiertere Entscheidungen auf höherer Ebene treffen, basierend darauf, wie Daten konvertiert und angewendet werden.  Solche Optimierungen bei traditionelleren OOP-Techniken können äußerst komplex und zeitaufwändig sein. <br><br><h3>  Modularität </h3><br>  Alle oben genannten Vorteile des datenorientierten Designs standen im Zusammenhang mit der Leistung: Cache-Nutzung, Optimierung und Parallelisierung.  Es besteht kein Zweifel, dass für uns Spielprogrammierer die Leistung äußerst wichtig ist.  Oft gibt es einen Konflikt zwischen Techniken, die die Produktivität steigern, und Techniken, die die Lesbarkeit des Codes und die einfache Entwicklung fördern.  Wenn wir beispielsweise einen Teil des Codes in Assemblersprache umschreiben, verbessern wir die Leistung. Dies führt jedoch normalerweise zu einer Verringerung der Lesbarkeit und erschwert die Unterstützung des Codes. <br><br>  Glücklicherweise fördert datenorientiertes Design sowohl die Produktivität als auch die einfache Entwicklung.  Wenn Sie Code speziell für die Datenkonvertierung schreiben, erhalten Sie kleine Funktionen mit einer sehr geringen Anzahl von Abhängigkeiten zu anderen Teilen des Codes.  Die Codebasis bleibt sehr "flach", mit vielen "Blatt" -Funktionen, die keine großen Abhängigkeiten aufweisen.  Dieser Grad an Modularität und das Fehlen von Abhängigkeiten vereinfachen das Verständnis, Ersetzen und Aktualisieren von Code erheblich. <br><br><h3>  Testen </h3><br>  Der letzte große Vorteil des datenorientierten Designs ist die einfache Prüfung.  Viele Menschen wissen, dass das Schreiben von Komponententests zum Testen der Interaktion von Objekten keine triviale Aufgabe ist.  Sie müssen Layouts und Testelemente indirekt erstellen.  Ehrlich gesagt ist das ziemlich schmerzhaft.  Andererseits ist es absolut einfach, Unit-Tests direkt mit Daten zu schreiben: Wir erstellen einige eingehende Daten, rufen die Funktion auf, die sie konvertiert, und prüfen, ob die Ausgabe mit den erwarteten Daten übereinstimmt.  Und das ist alles.  Tatsächlich ist dies ein großer Vorteil, der das Testen von Codes erheblich vereinfacht, sei es die testgetriebene Entwicklung oder das Schreiben von Komponententests nach dem Code. <br><br><h2>  Nachteile des datenorientierten Designs </h2><br>  Datenorientiertes Design ist keine "Silberkugel", die alle Probleme bei der Spieleentwicklung löst.  Es hilft wirklich beim Schreiben von Hochleistungscode und beim Erstellen von Programmen, die besser lesbar und einfacher zu warten sind, aber an sich einige Nachteile haben. <br><br>  Das Hauptproblem beim datenorientierten Design: Es unterscheidet sich von dem, was die meisten Programmierer gelernt und gewohnt sind.  Es erfordert, unser mentales Modell des Programms um neunzig Grad zu drehen und die Sichtweise darauf zu ändern.  Damit dieser Ansatz zur zweiten Natur wird, ist Übung erforderlich. <br><br>  Aufgrund der unterschiedlichen Ansätze kann es außerdem zu Schwierigkeiten bei der Interaktion mit vorhandenem Code kommen, der in einem prozeduralen oder OOP-Stil geschrieben wurde.  Es ist schwierig, eine Funktion separat zu schreiben, aber sobald Sie ein datenorientiertes Design auf ein gesamtes Subsystem anwenden können, können Sie viele Vorteile erzielen. <br><br><h2>  Verwenden von datenorientiertem Design </h2><br>  Genug Theorie und Rezensionen.  Wie beginne ich mit der Implementierung der datenorientierten Entwurfsmethode?  Wählen Sie zunächst einen bestimmten Bereich Ihres Codes aus: Navigation, Animationen, Kollisionen oder etwas anderes.  Wenn sich der Hauptteil der Spiel-Engine später auf Daten konzentriert, können Sie den Datenfluss entlang des gesamten Pfads vom Anfang des Frames bis zum Ende optimieren. <br><br>  Als nächstes müssen die vom System benötigten Eingabedaten und die Art der Daten, die es generieren soll, klar identifiziert werden.  Möglicherweise denken Sie vorerst in der OOP-Terminologie, nur um die Daten zu identifizieren.  Bei einem Animationssystem sind beispielsweise Skelette, Grundposen, Animationsdaten und der aktuelle Status Teil der Eingabedaten.  Das Ergebnis ist kein „animierter Animationscode“, sondern Daten, die von den aktuell wiedergegebenen Animationen generiert werden.  In diesem Fall besteht die Ausgabe aus einem neuen Satz von Posen und einem aktualisierten Status. <br><br>  Es ist wichtig, einen Schritt zurückzutreten und eingehende Daten anhand ihrer Verwendung zu klassifizieren.  Sind sie schreibgeschützt, schreibgeschützt oder schreibgeschützt?  Eine solche Klassifizierung hilft bei Entscheidungen darüber, wo Daten gespeichert und wann sie verarbeitet werden sollen, da Abhängigkeiten von anderen Teilen des Programms bestehen. <br><br>  In diesem Stadium müssen Sie aufhören, über die für einen Vorgang erforderlichen Daten nachzudenken, und darüber nachdenken, sie auf Dutzende oder Hunderte von Elementen anzuwenden.  Wir haben nicht mehr ein Skelett, eine Grundhaltung und einen aktuellen Zustand: Wir haben einen Block von jedem dieser Typen mit vielen Instanzen in jedem der Blöcke. <br><br>  Überlegen Sie genau, wie die Daten im Transformationsprozess von der Eingabe zur Ausgabe verwendet werden.  Möglicherweise stellen Sie fest, dass Sie zum Übertragen von Daten ein bestimmtes Feld in der Struktur scannen und dann die Ergebnisse verwenden müssen, um einen weiteren Durchgang durchzuführen.  In diesem Fall ist es möglicherweise logischer, dieses Quellfeld in einen separaten Speicherblock aufzuteilen, der separat verarbeitet werden kann, um den Cache besser zu nutzen und den Code für eine mögliche Parallelisierung vorzubereiten.  Oder Sie müssen möglicherweise einen Teil des Codes vektorisieren, wenn Sie Daten von verschiedenen Orten empfangen müssen, damit diese in ein Vektorregister gestellt werden.  In diesem Fall werden die Daten nebeneinander gespeichert, so dass Vektoroperationen ohne unnötige Konvertierungen direkt angewendet werden können. <br><br>  Sie sollten jetzt ein sehr gutes Verständnis Ihrer Daten haben.  Das Schreiben von Code zum Konvertieren wird viel einfacher.  Es wird so sein, als würde man Code durch Ausfüllen von Leerzeichen erstellen.  Sie werden angenehm überrascht sein, dass der Code im Vergleich zum gleichen OOP-Code viel einfacher und kompakter war als ursprünglich angenommen. <br><br>  Die meisten Beiträge in meinem Blog haben Sie auf diese Art von Design vorbereitet.  Jetzt müssen wir vorsichtig sein, wie die Daten angeordnet sind, die Daten im Eingabeformat backen, damit sie effizient verwendet werden können, und Verknüpfungen ohne Zeiger zwischen den Datenblöcken verwenden, damit sie leicht verschoben werden können. <br><br><h2>  Ist noch Platz für die Verwendung von OOP? </h2><br>  Bedeutet dies, dass OOP nutzlos ist und niemals beim Erstellen von Programmen verwendet werden sollte?  Das kann ich nicht sagen.  Das Denken im Kontext von Objekten ist nicht schädlich, wenn es sich nur um eine Instanz jedes Objekts handelt (z. B. ein Grafikgerät, einen Protokollmanager usw.). In diesem Fall kann der Code jedoch auf der Grundlage einfacherer C-Funktionen und statischer Funktionen implementiert werden Daten auf Dateiebene.  Und selbst in dieser Situation ist es immer noch wichtig, dass Objekte mit Schwerpunkt auf Datentransformation entworfen werden. <br><br>  Eine andere Situation, in der ich immer noch OOP verwende, sind GUI-Systeme.  Vielleicht liegt dies daran, dass wir hier mit einem System arbeiten, das bereits objektorientiert entworfen wurde, oder vielleicht daran, dass Leistung und Komplexität keine kritischen Faktoren für den GUI-Code sind.  Wie dem auch sei, ich bevorzuge GUI-APIs, die die Vererbung nur wenig nutzen und die Verschachtelung maximieren (gute Beispiele hierfür sind Cocoa und CocoaTouch).  Es ist wahrscheinlich, dass Sie für Spiele gut aussehende GUI-Systeme mit Datenorientierung schreiben können, aber bisher habe ich solche nicht gesehen. <br><br>  Am Ende hindert Sie nichts daran, ein mentales Bild zu erstellen, das auf Objekten basiert, wenn Sie das Spiel lieber auf diese Weise betrachten.  Es ist nur so, dass die Essenz des Feindes nicht einen physischen Platz im Gedächtnis einnimmt, sondern in kleinere Unterkomponenten unterteilt wird, von denen jede Teil einer großen Datentabelle ähnlicher Komponenten ist. <br><br>  Datenorientiertes Design ist ein bisschen weit von herkömmlichen Programmiermethoden entfernt. Wenn Sie jedoch immer über Daten und die erforderlichen Transformationsmethoden nachdenken, erhalten Sie große Vorteile in Bezug auf Produktivität und einfache Entwicklung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472052/">https://habr.com/ru/post/de472052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472036/index.html">Formel zur Berechnung von Primzahlen und zur Optimierung von Brute-Force-Teilern</a></li>
<li><a href="../de472040/index.html">Balancing Red-Black Trees - Drei Fälle</a></li>
<li><a href="../de472042/index.html">Volle Mandantenfähigkeit in Zimbra OSE mit Zextras Admin</a></li>
<li><a href="../de472044/index.html">Übersicht über ISPmanager - Hosting- und Site-Control-Panels</a></li>
<li><a href="../de472046/index.html">Konferenzen: der Anfang des Weges</a></li>
<li><a href="../de472054/index.html">Organisatoren und Lehrassistenten zu CS Center Online-Programmen</a></li>
<li><a href="../de472060/index.html">Die deutsche Polizei stürmte einen Militärbunker, in dem sich das neu deklarierte Rechenzentrum befand</a></li>
<li><a href="../de472062/index.html">Überwachung + Stresstest = Prognose und keine Fehler</a></li>
<li><a href="../de472064/index.html">Ansible + Auto Git Pull im Cluster der virtuellen Maschine in der Cloud</a></li>
<li><a href="../de472068/index.html">Verwenden der NVME-SSD als Systemlaufwerk auf Computern mit altem BIOS und Linux-Betriebssystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>