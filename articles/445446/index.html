<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèΩ üë®üèæ‚Äçü§ù‚Äçüë®üèΩ ‚õπüèø C√≥mo utilizamos la replicaci√≥n diferida para la recuperaci√≥n ante desastres con PostgreSQL üíí üí≥ üßñüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La replicaci√≥n no es una copia de seguridad. O no? As√≠ es como usamos la replicaci√≥n diferida para la recuperaci√≥n al eliminar accesos directos accide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo utilizamos la replicaci√≥n diferida para la recuperaci√≥n ante desastres con PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/445446/"><p><img src="https://habrastorage.org/webt/d5/ij/ht/d5ijhtuldyyxn2aomtg2r4sdvum.jpeg"></p><br><p>  La replicaci√≥n no es una copia de seguridad.  O no?  As√≠ es como usamos la replicaci√≥n diferida para la recuperaci√≥n al eliminar accesos directos accidentalmente. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los especialistas</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">infraestructura</a> de GitLab son responsables de ejecutar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitLab.com</a> , la mayor instancia de GitLab en la naturaleza.  Hay 3 millones de usuarios y casi 7 millones de proyectos, y este es uno de los sitios SaaS de c√≥digo abierto m√°s grandes con una arquitectura dedicada.  Sin el sistema de base de datos PostgreSQL, la infraestructura de GitLab.com no ir√° muy lejos, y simplemente no lo hacemos por tolerancia a fallas en caso de fallas cuando se pueden perder datos.  Es poco probable que ocurra tal cat√°strofe, pero estamos bien preparados y equipados con diferentes mecanismos de copia de seguridad y replicaci√≥n. </p><br><p> La replicaci√≥n no es una herramienta de respaldo de la base de datos para usted ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver m√°s abajo</a> ).  Pero ahora veremos c√≥mo recuperar r√°pidamente los datos eliminados accidentalmente mediante la replicaci√≥n retrasada: en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitLab.com, el</a> usuario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">elimin√≥ el acceso directo</a> para el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>gitlab-ce</code></a> y perdi√≥ contacto con solicitudes y tareas de fusi√≥n. </p><br><p>  Con una r√©plica retrasada, recuperamos datos en solo 1.5 horas.  Mira c√≥mo fue. </p><a name="habracut"></a><br><h3 id="vosstanovlenie-na-moment-vremeni-s-postgresql">  Recuperaci√≥n de punto en el tiempo con PostgreSQL </h3><br><p>  PostgreSQL tiene una funci√≥n integrada que restaura el estado de la base de datos en un momento espec√≠fico.  Se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Point-in-Time Recovery</a> (PITR) y utiliza los mismos mecanismos que mantienen la relevancia de la r√©plica: comenzando con una instant√°nea confiable de todo el cl√∫ster de la base de datos (copia de seguridad b√°sica), aplicamos una serie de cambios de estado hasta cierto punto en el tiempo. </p><br><p>  Para usar esta funci√≥n para una copia de seguridad en fr√≠o, regularmente hacemos una copia de seguridad b√°sica de la base de datos y la almacenamos en un archivo (los archivos de GitLab viven en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">almacenamiento</a> en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube de Google</a> ).  Tambi√©n supervisamos los cambios en el estado de la base de datos archivando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro de escritura anticipada</a> (WAL).  Y con todo esto, podemos realizar PITR para la recuperaci√≥n ante desastres: comenzamos con la imagen tomada antes del error y aplicamos los cambios desde el archivo WAL hasta la falla. </p><br><h3 id="chto-takoe-otlozhennaya-replikaciya">  ¬øQu√© es la replicaci√≥n diferida? </h3><br><p>  La replicaci√≥n diferida es la aplicaci√≥n de cambios WAL retrasados.  Es decir, la transacci√≥n ocurri√≥ en la hora <code>X</code> , pero aparecer√° en la r√©plica con un retraso de <code>d</code> en la hora <code>X + d</code> . </p><br><p>  PostgreSQL tiene 2 formas de configurar la r√©plica f√≠sica de la base de datos: restaurar desde el archivo y la replicaci√≥n de transmisi√≥n.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La restauraci√≥n desde el archivo</a> , de hecho, funciona como PITR, pero continuamente: extraemos constantemente los cambios del archivo WAL y los aplicamos a la r√©plica.  Y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la replicaci√≥n de transmisi√≥n</a> recupera directamente la transmisi√≥n WAL del host de la base de datos ascendente.  Preferimos la recuperaci√≥n del archivo: es m√°s f√°cil de administrar y tiene un rendimiento normal, que no va a la zaga del cl√∫ster de trabajo. </p><br><h3 id="kak-nastroit-otlozhennoe-vosstanovlenie-iz-arhiva">  C√≥mo configurar la recuperaci√≥n diferida del archivo </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las opciones de recuperaci√≥n se</a> describen en el archivo <code>recovery.conf</code> .  Un ejemplo: </p><br><pre> <code class="plaintext hljs">standby_mode = 'on' restore_command = '/usr/bin/envdir /etc/wal-ed/env /opt/wal-e/bin/wal-e wal-fetch -p 4 "%f" "%p"' recovery_min_apply_delay = '8h' recovery_target_timeline = 'latest'</code> </pre> <br><p>  Con estos par√°metros, configuramos una r√©plica perezosa con recuperaci√≥n del archivo.  Aqu√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wal-e se usa</a> para extraer segmentos WAL ( <code>restore_command</code> ) del archivo, y los cambios se aplicar√°n despu√©s de ocho horas ( <code>recovery_min_apply_delay</code> ).  La r√©plica supervisar√° los cambios en la l√≠nea de tiempo en el archivo, por ejemplo, debido a la conmutaci√≥n por error en el cl√∫ster ( <code>recovery_target_timeline</code> ). </p><br><p>  Con <code>recovery_min_apply_delay</code> puede configurar la replicaci√≥n de transmisi√≥n diferida, pero hay un par de trucos asociados con las ranuras de replicaci√≥n, retroalimentaci√≥n de repuesto din√°mico, etc.  El archivo WAL le permite evitarlos. </p><br><p>  El par√°metro <code>recovery_min_apply_delay</code> apareci√≥ solo en PostgreSQL 9.3.  En versiones anteriores, para la replicaci√≥n diferida, debe configurar una combinaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de funciones de administraci√≥n de recuperaci√≥n</a> ( <code>pg_xlog_replay_pause(), pg_xlog_replay_resume()</code> ) o mantener segmentos WAL en el archivo para el retraso de tiempo. </p><br><h3 id="kak-postgresql-eto-delaet">  ¬øC√≥mo hace esto PostgreSQL? </h3><br><p>  Curioso por ver c√≥mo PostgreSQL implementa la recuperaci√≥n diferida.  Veamos <a href=""><code>recoveryApplyDelay(XlogReaderState)</code></a> .  Se llama desde el <a href="">bucle principal</a> para cada entrada en el WAL. </p><br><pre> <code class="plaintext hljs">static bool recoveryApplyDelay(XLogReaderState *record) { uint8 xact_info; TimestampTz xtime; long secs; int microsecs; /* nothing to do if no delay configured */ if (recovery_min_apply_delay &lt;= 0) return false; /* no delay is applied on a database not yet consistent */ if (!reachedConsistency) return false; /* * Is it a COMMIT record? * * We deliberately choose not to delay aborts since they have no effect on * MVCC. We already allow replay of records that don't have a timestamp, * so there is already opportunity for issues caused by early conflicts on * standbys. */ if (XLogRecGetRmid(record) != RM_XACT_ID) return false; xact_info = XLogRecGetInfo(record) &amp; XLOG_XACT_OPMASK; if (xact_info != XLOG_XACT_COMMIT &amp;&amp; xact_info != XLOG_XACT_COMMIT_PREPARED) return false; if (!getRecordTimestamp(record, &amp;xtime)) return false; recoveryDelayUntilTime = TimestampTzPlusMilliseconds(xtime, recovery_min_apply_delay); /* * Exit without arming the latch if it's already past time to apply this * record */ TimestampDifference(GetCurrentTimestamp(), recoveryDelayUntilTime, &amp;secs, &amp;microsecs); if (secs &lt;= 0 &amp;&amp; microsecs &lt;= 0) return false; while (true) { // Shortened: // Use WaitLatch until we reached recoveryDelayUntilTime // and then break; } return true; }</code> </pre> <br><p>  La conclusi√≥n es que el retraso se basa en el tiempo f√≠sico registrado en la marca de tiempo de confirmaci√≥n de transacci√≥n ( <code>xtime</code> ).  Como puede ver, la demora se aplica solo a las confirmaciones y no toca otros registros: todos los cambios se aplican directamente y la confirmaci√≥n se retrasa, de modo que veremos los cambios solo despu√©s de que se configure la demora. </p><br><h3 id="kak-ispolzovat-otlozhennuyu-repliku-dlya-vosstanovleniya-dannyh">  C√≥mo usar la r√©plica perezosa para recuperar datos </h3><br><p>  Digamos que tenemos un cl√∫ster de base de datos en producci√≥n y una r√©plica con un retraso de ocho horas.  Veamos c√≥mo recuperar datos usando el ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eliminar accesos directos accidentalmente</a> . </p><br><p>  Cuando descubrimos el problema, detuvimos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recuperaci√≥n del archivo</a> para la r√©plica diferida: </p><br><pre> <code class="plaintext hljs">SELECT pg_xlog_replay_pause();</code> </pre> <br><p>  Con una pausa, no ten√≠amos riesgo de que la r√©plica repitiera la solicitud <code>DELETE</code> .  Lo √∫til si necesita tiempo para resolverlo. </p><br><p>  La conclusi√≥n es que la r√©plica diferida debe llegar al punto anterior a la solicitud <code>DELETE</code> .  Aproximadamente conocimos el tiempo f√≠sico de la remoci√≥n.  Eliminamos <code>recovery_min_apply_delay</code> y agregamos <code>recovery_target_time</code> a <code>recovery.conf</code> .  Entonces la r√©plica llega sin demora al momento correcto: </p><br><pre> <code class="plaintext hljs">recovery_target_time = '2018-10-12 09:25:00+00'</code> </pre> <br><p>  Con marcas de tiempo, es mejor reducir el exceso para no perderse.  Es cierto que cuanto mayor es la disminuci√≥n, m√°s datos perdemos.  Una vez m√°s, si pasamos por <code>DELETE</code> solicitud <code>DELETE</code> , todo se eliminar√° nuevamente y tendr√° que comenzar de nuevo (o incluso tomar una copia de seguridad en fr√≠o para PITR). </p><br><p>  Reiniciamos la instancia diferida de Postgres, y los segmentos WAL se repitieron hasta el tiempo especificado.  Puede realizar un seguimiento del progreso en esta etapa mediante solicitud: </p><br><pre> <code class="plaintext hljs">SELECT -- current location in WAL pg_last_xlog_replay_location(), -- current transaction timestamp (state of the replica) pg_last_xact_replay_timestamp(), -- current physical time now(), -- the amount of time still to be applied until recovery_target_time has been reached '2018-10-12 09:25:00+00'::timestamptz - pg_last_xact_replay_timestamp() as delay;</code> </pre> <br><p>  Si la marca de tiempo ya no cambia, la recuperaci√≥n est√° completa.  Puede configurar la acci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>recovery_target_action</code></a> para cerrar, avanzar o pausar una instancia despu√©s de una reproducci√≥n (de forma predeterminada, se detiene). </p><br><p>  La base de datos lleg√≥ a un estado anterior a esa solicitud desafortunada.  Ahora puede, por ejemplo, exportar datos.  Exportamos los datos eliminados sobre el acceso directo y todas las conexiones con tareas y solicitudes de fusi√≥n y los transferimos a la base de datos de trabajo.  Si las p√©rdidas son a gran escala, simplemente puede promocionar la r√©plica y usarla como la principal.  Pero entonces todos los cambios se perder√°n despu√©s del momento en que nos hayamos recuperado. </p><br><p>  En lugar de marcas de tiempo, es mejor usar ID de transacci√≥n.  Es √∫til escribir estos ID, por ejemplo, para sentencias DDL (como <code>DROP TABLE</code> ), usando <code>log_statements = 'ddl'</code> .  Si tuvi√©ramos una ID de transacci√≥n, tomar√≠amos <code>recovery_target_xid</code> y ejecutaremos todo hasta la transacci√≥n antes de la solicitud <code>DELETE</code> . </p><br><p>  Volver al trabajo es muy simple: elimine todos los cambios de <code>recovery.conf</code> y reinicie Postgres.  Pronto, una demora de ocho horas aparecer√° nuevamente en la r√©plica, y estamos listos para futuros problemas. </p><br><h3 id="preimuschestva-dlya-vosstanovleniya">  Beneficios de recuperaci√≥n </h3><br><p>  Con una r√©plica retrasada, en lugar de una copia de seguridad en fr√≠o, no tiene que restaurar la imagen completa del archivo durante horas.  Por ejemplo, necesitamos cinco horas para obtener la copia de seguridad b√°sica completa de 2 TB.  Y luego todav√≠a tiene que aplicar el WAL diario completo para recuperarse al estado deseado (en el peor de los casos). </p><br><p>  Una r√©plica retrasada es mejor que una copia de seguridad en fr√≠o de dos maneras: </p><br><ol><li>  No es necesario obtener toda la copia de seguridad base del archivo. </li><li>  Hay una ventana fija de ocho horas de segmentos WAL que deben repetirse. </li></ol><br><p>  Tambi√©n verificamos constantemente si es posible hacer PITR desde WAL, y notamos r√°pidamente da√±os u otros problemas con el archivo WAL, monitoreando el retraso de la r√©plica demorada. </p><br><p>  En este ejemplo, nos tom√≥ 50 minutos recuperarnos, es decir, la velocidad era de 110 GB de datos WAL por hora (el archivo todav√≠a estaba en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AWS S3</a> ).  En total, resolvimos el problema y restauramos los datos en 1,5 horas. </p><br><h3 id="itogi-gde-prigoditsya-otlozhennaya-replika-a-gde-net">  En pocas palabras: donde la r√©plica retrasada es √∫til (y donde no) </h3><br><p>  Utilice la replicaci√≥n diferida como primeros auxilios si pierde accidentalmente datos y nota este desastre dentro del retraso configurado. </p><br><blockquote>  Pero tenga en cuenta: la replicaci√≥n no es una copia de seguridad. </blockquote><p>  La copia de seguridad y la replicaci√≥n tienen diferentes objetivos.  Una copia de seguridad en fr√≠o es √∫til si accidentalmente realiz√≥ una <code>DELETE</code> o <code>DROP TABLE</code> .  Hacemos una copia de seguridad desde el almacenamiento en fr√≠o y restauramos el estado anterior de la tabla o la base de datos completa.  Pero al mismo tiempo, la consulta <code>DROP TABLE</code> se reproduce casi instant√°neamente en todas las r√©plicas en el cl√∫ster de trabajo, por lo que la replicaci√≥n regular no lo salvar√° aqu√≠.  La replicaci√≥n en s√≠ misma mantiene la base de datos accesible cuando se alquilan servidores separados y distribuye la carga. </p><br><p>  Incluso con una r√©plica retrasada, a veces realmente necesitamos una copia de seguridad fr√≠a en un lugar seguro si un centro de datos falla, da√±os ocultos u otros eventos que no se notan de inmediato.  No tiene sentido una r√©plica. </p><br><p>  <strong>Nota</strong>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitLab.com,</a> ahora protegemos contra la p√©rdida de datos solo a nivel de sistema y no restauramos datos a nivel de usuario. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445446/">https://habr.com/ru/post/445446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445434/index.html">Mejor trabajo peor del mundo: buscando un Habraautor</a></li>
<li><a href="../445436/index.html">Reentrenamiento en DevOps: para qu√© prepararse</a></li>
<li><a href="../445438/index.html">Conocimiento del elemento iluminado y los componentes web basados ‚Äã‚Äãen √©l.</a></li>
<li><a href="../445440/index.html">Revisi√≥n de c√≥digo: malos consejos para contribuidor y revisor</a></li>
<li><a href="../445444/index.html">Actualizaci√≥n de m√≥dulos solares de alto rendimiento de REC y Trina (Solar)</a></li>
<li><a href="../445448/index.html">Configuraci√≥n de la recepci√≥n autom√°tica de certificados de letsencrypt usando docker en linux</a></li>
<li><a href="../445450/index.html">Extensi√≥n del navegador para toster.ru</a></li>
<li><a href="../445452/index.html">Repositorios √∫tiles con Eloquent?</a></li>
<li><a href="../445454/index.html">Pantalla Braille Raspberry Pi Zero Inside Handy Tech Active Star 40</a></li>
<li><a href="../445456/index.html">Buscar a 1 TB / s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>