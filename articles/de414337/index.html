<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ì üñºÔ∏è ü§¢ Ramda Style Thinking: Unver√§nderlichkeit und Objekte ü§Æ üí® üë®‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Erste Schritte 
 2. Kombinieren Sie die Funktionen 
 3. Teilweise Verwendung (Currying) 
 4. Deklarative Programmierung 
 5. Grundlegende Notation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ramda Style Thinking: Unver√§nderlichkeit und Objekte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414337/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Erste Schritte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Kombinieren Sie die Funktionen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Teilweise Verwendung (Currying)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Deklarative Programmierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Grundlegende Notation</a> <br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Unver√§nderlichkeit und Gegenst√§nde</a></strong> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Unver√§nderlichkeit und Arrays</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Objektive</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9. Fazit</a> </p><br><p>  Dieser Beitrag ist der sechste Teil einer Reihe von Artikeln zur funktionalen Programmierung mit dem Titel Ramda Style Thinking. </p><br><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºnften Teil haben</a> wir √ºber das Schreiben von Funktionen im Stil der sinnlosen Notation gesprochen, wobei das Hauptargument mit den Daten f√ºr unsere Funktion nicht explizit angegeben ist. </p><br><p>  Zu diesem Zeitpunkt konnten wir nicht alle unsere Funktionen in einem bitlosen Stil umschreiben, da wir nicht √ºber die daf√ºr erforderlichen Tools verf√ºgten.  Es ist Zeit, sie zu studieren. <a name="habracut"></a></p><br>
<h2 id="chtenie-svoystv-obekta">  Objekteigenschaften lesen </h2><br><p>  Schauen wir uns noch einmal das Beispiel der Definition von Personen mit Stimmrecht an, das wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºnften Teil untersucht haben</a> : </p><br><pre><code class="plaintext hljs">const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRY const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; person.age &gt;= 18 const isCitizen = either(wasBornInCountry, wasNaturalized) const isEligibleToVote = both(isOver18, isCitizen)</code> </pre> <br><p>  Wie Sie sehen, schlie√üen wir <code>isCitizen</code> und <code>isEligibleToVote</code> , k√∂nnen dies jedoch mit den ersten drei Funktionen nicht tun. </p><br><p>  Wie wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierten Teil</a> gelernt haben, k√∂nnen wir unsere Funktionen durch die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">equals</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gte deklarativer machen</a> .  Beginnen wir damit: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(person.naturalizationDate) const isOver18 = person =&gt; gte(person.age, 18)</code> </pre> <br><p>  Um diese Funktionen sinnlos zu machen, ben√∂tigen wir eine M√∂glichkeit, die Funktion so zu konstruieren, dass wir die <code>person</code> am Ende des Ausdrucks anwenden.  Das Problem ist, dass wir auf die Eigenschaften der <code>person</code> zugreifen m√ºssen, jetzt wissen wir, wie dies nur m√∂glich ist - und das ist unbedingt erforderlich. </p><br><h2 id="prop">  St√ºtze </h2><br><p>  Zum Gl√ºck hilft uns Ramda erneut.  Es bietet eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Requisitenfunktion</a> f√ºr den Zugriff auf die Eigenschaften von Objekten. </p><br><p>  Mit <code>prop</code> k√∂nnen wir <code>person.birthCountry</code> in <code>prop('birthCountry', person)</code> umschreiben.  Lass es uns tun: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(prop('birthCountry', person), OUR_COUNTRY) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  Wow, jetzt sieht es viel schlimmer aus.  Aber lassen Sie uns unser Refactoring fortsetzen.  Lassen Sie uns die Reihenfolge der Argumente √§ndern, die wir an <code>equals</code> damit die <code>prop</code> letzter Stelle steht.  <code>equals</code> funktioniert genauso in umgekehrter Reihenfolge, sodass wir nichts kaputt machen: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY, prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(prop('age', person), 18)</code> </pre> <br><p>  Als n√§chstes verwenden wir Currying, die nat√ºrliche Eigenschaft von <code>equals</code> und <code>gte</code> , um neue Funktionen zu erstellen, f√ºr die das Ergebnis des <code>prop</code> Aufrufs gilt: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry', person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate', person)) const isOver18 = person =&gt; gte(__, 18)(prop('age', person))</code> </pre> <br><p>  Es sieht immer noch nach der schlechtesten Option aus, aber fahren wir fort.  Lassen Sie uns das Currying f√ºr alle <code>prop</code> : </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; equals(OUR_COUNTRY)(prop('birthCountry')(person)) const wasNaturalized = person =&gt; Boolean(prop('naturalizationDate')(person)) const isOver18 = person =&gt; gte(__, 18)(prop('age')(person))</code> </pre> <br><p>  Wieder irgendwie nicht sehr.  Aber jetzt sehen wir ein bekanntes Muster.  Alle unsere Funktionen haben das gleiche Bild <code>f(g(person))</code> , und wie wir aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Teil</a> wissen, entspricht dies der Zusammensetzung <code>compose(f, g)(person)</code> . </p><br><p>  Wenden wir diesen Vorteil auf unseren Code an: </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = person =&gt; compose(equals(OUR_COUNTRY), prop('birthCountry'))(person) const wasNaturalized = person =&gt; compose(Boolean, prop('naturalizationDate'))(person) const isOver18 = person =&gt; compose(gte(__, 18), prop('age'))(person)</code> </pre> <br><p>  Jetzt haben wir etwas.  Alle unsere Funktionen sehen aus wie <code>person =&gt; f(person)</code> .  Und wir wissen bereits aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºnften Teil,</a> dass wir diese Funktionen sinnlos machen k√∂nnen. </p><br><pre> <code class="plaintext hljs">const wasBornInCountry = compose(equals(OUR_COUNTRY), prop('birthCountry')) const wasNaturalized = compose(Boolean, prop('naturalizationDate')) const isOver18 = compose(gte(__, 18), prop('age'))</code> </pre> <br><p>  Als wir anfingen, war es nicht offensichtlich, dass unsere Methoden zwei Dinge taten.  Sie wandten sich der Eigenschaft des Objekts zu und bereiteten einige Operationen mit seinem Wert vor.  Dieses Refactoring in einen sinnlosen Stil machte dies sehr deutlich. </p><br><p>  Schauen wir uns einige der anderen Tools an, die Ramda f√ºr die Arbeit mit Objekten bereitstellt. </p><br><h2 id="pick">  w√§hlen </h2><br><p>  Wenn <code>prop</code> eine Eigenschaft eines Objekts liest und seinen Wert zur√ºckgibt, liest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pick</a> viele Eigenschaften aus dem Objekt und gibt nur mit ihnen ein neues Objekt zur√ºck. </p><br><p>  Wenn wir zum Beispiel nur die Namen und Jahre von Personen ben√∂tigen, k√∂nnen wir <code>pick(['name','age'], person)</code> . </p><br><h2 id="has">  hat </h2><br><p>  Wenn wir nur wissen m√∂chten, dass unser Objekt eine Eigenschaft hat, ohne seinen Wert zu lesen, k√∂nnen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">has-</a> Funktion verwenden, um seine Eigenschaften zu √ºberpr√ºfen, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hasIn</a> , um die Prototypkette zu √ºberpr√ºfen: <code>has('name', person)</code> . </p><br><h2 id="path">  Pfad </h2><br><p>  Wenn <code>prop</code> eine Objekteigenschaft <code>prop</code> , geht der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfad</a> tiefer in verschachtelte Objekte.  Zum Beispiel m√∂chten wir die Postleitzahl aus einer tieferen Struktur ziehen: <code>path(['address','zipCode'], person)</code> . </p><br><p>  Beachten Sie, dass der <code>path</code> verzeihender ist als die <code>prop</code> .  <code>path</code> gibt <code>undefined</code> wenn etwas im Pfad (einschlie√ülich des urspr√ºnglichen Arguments) <code>null</code> oder <code>undefined</code> , w√§hrend <code>prop</code> in solchen Situationen einen Fehler verursacht. </p><br><h2 id="propor--pathor">  propOr / pathOr </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">propOr</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pathOr</a> √§hneln <code>prop</code> und <code>path</code> Kombination mit <code>defaultTo</code> .  Sie bieten Ihnen die M√∂glichkeit, einen Standardwert f√ºr eine Eigenschaft oder einen Pfad anzugeben, der / die im untersuchten Objekt nicht gefunden werden kann. </p><br><p>  Beispielsweise k√∂nnen wir einen Platzhalter <code>propOr('&lt;Unnamed&gt;, 'name', person)</code> wenn wir den Namen der Person nicht kennen: <code>propOr('&lt;Unnamed&gt;, 'name', person)</code> .  Beachten Sie, dass <code>propOr</code> im Gegensatz zu <code>prop</code> keinen Fehler verursacht, wenn <code>person</code> <code>null</code> oder <code>undefined</code> .  Stattdessen wird der Standardwert zur√ºckgegeben. </p><br><h2 id="keys--values">  Schl√ºssel / Werte </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keys</a> gibt ein Array zur√ºck, das alle Namen aller bekannten Eigenschaften des Objekts enth√§lt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Werte</a> geben die Werte dieser Eigenschaften zur√ºck.  Diese Funktionen k√∂nnen n√ºtzlich sein, wenn sie mit den Iterationsfunktionen f√ºr Sammlungen kombiniert werden, die wir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil kennengelernt haben</a> . </p><br><h2 id="dobavlenie-obnovlenie-i-udalenie-svoystv">  Hinzuf√ºgen, Aktualisieren und L√∂schen von Eigenschaften </h2><br><p>  Jetzt haben wir viele Werkzeuge zum Lesen von Objekten in einem deklarativen Stil, aber was ist mit √Ñnderungen? </p><br><p>  Da Unver√§nderlichkeit f√ºr uns wichtig ist, m√∂chten wir Objekte nicht direkt √§ndern.  Stattdessen m√∂chten wir neue Objekte zur√ºckgeben, die sich wie gew√ºnscht ge√§ndert haben. </p><br><p>  Ramda bietet uns erneut viele Vorteile. </p><br><h2 id="assoc--assocpath">  assoc / assocPath </h2><br><p>  Wenn wir in einem imperativen Stil programmieren, k√∂nnen wir den Namen der Person √ºber den Zuweisungsoperator festlegen oder √§ndern: <code>person.name = 'New name'</code> . </p><br><p>  In unserer funktionalen, unver√§nderlichen Welt k√∂nnen wir stattdessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">assoc</a> verwenden: <code>const updatedPerson = assoc('name', 'newName', person)</code> . </p><br><p>  <code>assoc</code> gibt ein neues Objekt mit einem hinzugef√ºgten oder aktualisierten Eigenschaftswert zur√ºck, wobei das urspr√ºngliche Objekt unver√§ndert <code>assoc</code> . </p><br><p>  Wir haben auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">assocPath</a> zur Verf√ºgung, um die angeh√§ngte Eigenschaft zu aktualisieren: <code>const updatedPerson = assocPath(['address', 'zipCode'], '97504', person)</code> . </p><br><h2 id="dissoc--dissocpath--omit">  dissoc / dissocPath / weglassen </h2><br><p>  Was ist mit dem L√∂schen von Eigenschaften?  Wir m√∂chten <code>delete person.age</code> .  In Ramda verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dissoc</a> : `const updatedPerson = dissoc ('age', person) </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dissocPath ist</a> ungef√§hr gleich, arbeitet jedoch mit tieferen Objektstrukturen: <code>dissocPath(['address', 'zipCode'], person)</code> . </p><br><p>  Und wir haben auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auslassen</a> , wodurch mehrere Eigenschaften gleichzeitig entfernt werden k√∂nnen: <code>const updatedPerson = omit(['age', 'birthCountry'], person)</code> . </p><br><p>  Bitte beachten Sie, dass <code>pick</code> und <code>omit</code> etwas √§hnlich sind und sich sehr gut erg√§nzen.  Sie eignen sich sehr gut f√ºr Whitelists (speichern Sie nur einen bestimmten Satz von Eigenschaften mit <code>pick</code> ) und Blacklists (um bestimmte Eigenschaften durch Auslassen zu <code>omit</code> ). </p><br><h2 id="transformaciya-obektov">  Objekttransformation </h2><br><p>  Jetzt wissen wir genug, um mit Objekten in einem deklarativen und unver√§nderlichen Stil zu arbeiten.  Schreiben wir eine <code>celebrateBirthday</code> Funktion, die das Alter der Person an ihrem Geburtstag aktualisiert. </p><br><pre> <code class="plaintext hljs">const nextAge = compose(inc, prop('age')) const celebrateBirthday = person =&gt; assoc('age', nextAge(person), person)</code> </pre> <br><p>  Dies ist ein sehr verbreitetes Muster.  Anstatt die Eigenschaft mit einem neuen Wert zu aktualisieren, m√∂chten wir den Wert wirklich √§ndern, indem wir die Funktion wie hier auf den alten Wert anwenden. </p><br><p>  Ich kenne keinen guten Weg, dies mit weniger Duplikaten und in einem weniger strengen Stil zu schreiben, wenn ich die Werkzeuge habe, die wir zuvor kennengelernt haben. </p><br><p>  Ramda rettet uns erneut mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklungsfunktion</a> .  <code>evolve</code> akzeptiert ein Objekt und erm√∂glicht es Ihnen, Transformationsfunktionen f√ºr die Eigenschaften anzugeben, die wir √§ndern m√∂chten.  Lassen Sie uns <code>celebrateBirthday</code> Geburtstag zu <code>celebrateBirthday</code> indem Sie "Entwickeln" verwenden: </p><br><pre> <code class="plaintext hljs">const celebrateBirthday = evolve({ age: inc })</code> </pre> <br><p>  Dieser Code besagt, dass wir das angegebene Objekt (das aufgrund des brutalen Stils nicht angezeigt wird) konvertieren, indem wir ein neues Objekt mit denselben Eigenschaften und Werten erstellen. Die Eigenschaft <code>age</code> wird jedoch durch Anwenden von <code>inc</code> auf den urspr√ºnglichen Wert der Eigenschaft <code>age</code> erhalten. </p><br><p>  <code>evolve</code> k√∂nnen viele Eigenschaften gleichzeitig und sogar auf mehreren Verschachtelungsebenen transformiert werden.  Die Transformation des Objekts kann dasselbe Bild haben wie das ver√§nderbare Objekt, und die <code>evolve</code> wird unter Verwendung der Transformationsfunktionen in der angegebenen Form rekursiv zwischen den Strukturen √ºbertragen. </p><br><p>  Beachten Sie, dass <code>evolve</code> keine neuen Eigenschaften hinzuf√ºgt.  Wenn Sie eine Transformation f√ºr eine Eigenschaft angeben, die in dem zu verarbeitenden Objekt nicht vorkommt, wird sie von <code>evolve</code> einfach ignoriert. </p><br><p>  Ich habe festgestellt, dass die <code>evolve</code> in meinen Anwendungen schnell zu einem Arbeitstier wird. </p><br><h2 id="sliyanie-obektov">  Objekte zusammenf√ºhren </h2><br><p>  Manchmal m√ºssen Sie zwei Objekte miteinander kombinieren.  Ein typischer Fall ist, wenn Sie eine Funktion haben, die benannte Optionen akzeptiert, und diese mit den Standardoptionen kombinieren m√∂chten.  Ramda bietet zu diesem Zweck eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenf√ºhrungsfunktion</a> . </p><br><pre> <code class="plaintext hljs">function f(a, b, options = {}) { const defaultOptions = { value: 42, local: true } const finalOptions = merge(defaultOptions, options) }</code> </pre> <br><p>  <code>merge</code> gibt ein neues Objekt zur√ºck, das alle Eigenschaften und Werte beider Objekte enth√§lt.  Wenn beide Objekte dieselbe Eigenschaft haben, wird der Wert des zweiten Arguments erhalten. </p><br><p>  Das Vorhandensein dieser Regel mit einem gewinnenden zweiten Argument macht es sinnvoll, <code>merge</code> als eigenst√§ndiges Werkzeug zu verwenden, in F√∂rderersituationen jedoch weniger aussagekr√§ftig.  In diesem Fall m√ºssen Sie h√§ufig eine Reihe von Transformationen f√ºr ein Objekt vorbereiten. Eine dieser Transformationen ist die Vereinigung einiger neuer Eigenschaftswerte.  In diesem Fall soll das erste Argument anstelle des zweiten gewinnen. </p><br><p>  Der Versuch, nur <code>merge(newValues)</code> in der Pipeline zu verwenden, gibt nicht das, was wir gerne h√§tten. </p><br><p>  In dieser Situation erstelle ich normalerweise mein eigenes Dienstprogramm namens <code>reverseMerge</code> .  Es kann als <code>const reverseMerge = flip(merge)</code> .  Der <code>flip</code> Call tauscht die ersten beiden Argumente der f√ºr ihn geltenden Funktion aus. </p><br><p>  <code>merge</code> f√ºhrt eine Oberfl√§chenzusammenf√ºhrung durch.  Wenn Objekte in Kombination eine Eigenschaft haben, deren Wert ein Unterobjekt ist, werden diese Unterobjekte nicht zusammengef√ºhrt. <del>  Ramda verf√ºgt derzeit nicht √ºber eine Deep-Merge-F√§higkeit </del>  (Der <em>Originalartikel, den ich √ºbersetze, enth√§lt bereits veraltete Informationen zu diesem Thema. Heute verf√ºgt Ramda √ºber Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mergeDeepLeft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mergeDeepRight</a> zum rekursiv tiefen Zusammenf√ºhren von Objekten und andere Methoden zum Zusammenf√ºhren.</em> ) </p><br><p>  Beachten Sie, dass beim <code>merge</code> nur zwei Argumente akzeptiert werden.  Wenn Sie viele Objekte zu einem kombinieren m√∂chten, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mergeAll verwenden</a> , f√ºr dessen Kombination ein Array von Objekten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erforderlich</a> ist. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Heute haben wir eine wunderbare Reihe von Werkzeugen f√ºr die Arbeit mit Objekten in einem deklarativen und unver√§nderlichen Stil.  Jetzt k√∂nnen wir Eigenschaften in Objekten lesen, hinzuf√ºgen, aktualisieren, l√∂schen und transformieren, ohne die urspr√ºnglichen Objekte zu √§ndern.  Und wir k√∂nnen all diese Dinge in einem Stil tun, der es einfach macht, Funktionen miteinander zu kombinieren. </p><br><h2 id="dalee">  Weiter </h2><br><p>  Jetzt k√∂nnen wir mit Objekten in einem unver√§nderlichen Stil arbeiten, aber was ist mit Arrays?  "Immunit√§t und Arrays" werden uns sagen, was wir mit ihnen machen sollen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414337/">https://habr.com/ru/post/de414337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414325/index.html">Fragen Sie Ethan: Vielleicht ist die fehlende Antimaterie in schwarzen L√∂chern versteckt?</a></li>
<li><a href="../de414327/index.html">Was ist Depression und warum tritt sie h√§ufiger auf?</a></li>
<li><a href="../de414329/index.html">Worauf bereiten sich die "√úberlebenden" genau vor?</a></li>
<li><a href="../de414331/index.html">Werden Wissenschaftler jemals Leben finden, das nicht auf dem Planeten erschienen ist?</a></li>
<li><a href="../de414335/index.html">Hintergrund. Roskomnadzor, was bist du?</a></li>
<li><a href="../de414339/index.html">Tolle Fototour durch die neue Seite von Moskau Coworking #tceh</a></li>
<li><a href="../de414341/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 256 (vom 3. bis 12. Juni)</a></li>
<li><a href="../de414343/index.html">Google Neural Machine Translation</a></li>
<li><a href="../de414345/index.html">R√ºckentwicklung des Zeitschalters VL-76-S</a></li>
<li><a href="../de414347/index.html">Passive Aggression: Wie sie unser Arbeitsleben zerst√∂rt und wie man damit umgeht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>