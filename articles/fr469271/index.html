<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üò® üòÜ S√©rialisation et d√©s√©rialisation des donn√©es .NET Core vs Go üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üòÉ üë®üèª‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut% username% 


 Ma t√¢che consistait √† comparer les performances de s√©rialisation pour .NET Core et Golang. Apr√®s avoir cherch√© sur Internet, je s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S√©rialisation et d√©s√©rialisation des donn√©es .NET Core vs Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/homecredit/blog/469271/"><p>  Salut% username% </p><br><p>  Ma t√¢che consistait √† comparer les performances de s√©rialisation pour .NET Core et Golang.  Apr√®s avoir cherch√© sur Internet, je suis tomb√© sur un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> .  Un exemple simple d'un microservice REST est consid√©r√©.  C'est exactement ce dont j'ai besoin, pensai-je.  Apr√®s avoir vu les r√©sultats des tests, j'ai √©t√© surpris.  Apr√®s avoir regard√© le code source, j'ai r√©alis√© ce qui n'allait pas.  Voici ce que je n'ai pas aim√©: </p><br><ul><li>  Pour la s√©rialisation et la d√©s√©rialisation, un tableau de 3 √©l√©ments est s√©lectionn√©.  Ce n'est clairement pas suffisant. </li><li>  Pour Golang, toutes les fonctionnalit√©s du langage ne sont pas utilis√©es, mais, comme vous le savez, la biblioth√®que int√©gr√©e d'encodage / json est lente. </li><li>  En cons√©quence, l'auteur compare les performances des serveurs Web kestrel et net / http. </li></ul><br><p>  Ce sont ces lacunes qui ont conduit √† un examen plus d√©taill√© des performances dans le cadre de l'exemple d√©crit ci-dessus.  J'esp√®re que vous trouvez int√©ressant de conna√Ætre les r√©sultats. </p><a name="habracut"></a><br><h3 id="sostav-i-opisanie-po">  Composition et description du logiciel </h3><br><p>  Le code source du r√©f√©rentiel ci-dessus a √©galement √©t√© pris comme base.  Ce qui a √©t√© finalis√©: </p><br><ul><li>  Pour l'API serveur, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/valyala/fast">fasthttp est</a> utilis√©. </li><li>  Le serveur API r√©pond avec des tableaux d'enregistrements. </li><li>  Chaque client dispose de plusieurs m√©thodes de v√©rification. </li></ul><br><p>  Le code modifi√© est disponible dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> . </p><br><p>  Pour plus de clart√©, un exemple de r√©ponse JSON de l'API du serveur: </p><br><pre><code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>:<span class="hljs-string"><span class="hljs-string">"id_8299119732867115081"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>:<span class="hljs-string"><span class="hljs-string">"name_5541535679032008745"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Time"</span></span>:<span class="hljs-number"><span class="hljs-number">1566731141</span></span> }, ... { <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>:<span class="hljs-string"><span class="hljs-string">"id_2804604318195309547"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>:<span class="hljs-string"><span class="hljs-string">"name_5914011395631118540"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Time"</span></span>:<span class="hljs-number"><span class="hljs-number">1566731142</span></span> } ]</code> </pre> <br><h3 id="klienty">  Les clients </h3><br><p>  Pour √©valuer les performances de chaque service, trois m√©thodes sont mises en ≈ìuvre: </p><br><ul><li>  recevoir des donn√©es de l'API du serveur et les envoyer sans traitement [/ testNoProcess]. </li><li>  recevoir des donn√©es de l'API du serveur - d√©s√©rialisation, s√©rialisation en utilisant la r√©flexion et l'envoi [/ testReflection].  Pour .NETCore, le package Newtonsoft.Json a √©t√© utilis√©, pour Golang, le codage / json a √©t√© utilis√©. </li><li>  recevoir des donn√©es de l'API du serveur - d√©s√©rialisation, s√©rialisation sans utiliser la r√©flexion et l'envoi [/ testNoReflection].  Pour .NETCore, une solution bas√©e sur Span a √©t√© impl√©ment√©e pour minimiser le nombre d'allocations de m√©moire.  Golang a une solution toute faite - la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">easyjson</a> , qui a fait ses preuves exclusivement du c√¥t√© positif. </li></ul><br><p>  Sur la base de ces tests, vous pouvez √©valuer les performances relatives des serveurs Web (kestrel et net / http), la baisse des performances lors du traitement des donn√©es en utilisant la r√©flexion et sans elle pour les impl√©mentations dans les deux langues. </p><br><h3 id="opisanie-metodiki-testirovaniya">  Description de la m√©thodologie de test </h3><br><p>  Les tests ont √©t√© effectu√©s en plusieurs √©tapes afin d'√©valuer les performances de chaque langue et de chaque impl√©mentation. <br>  Pour cr√©er une charge, l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bombardier a</a> √©t√© s√©lectionn√©.  L'utilitaire a √©t√© lanc√© avec les param√®tres suivants: -c 125 ‚Äìd 120s, qui peut √™tre interpr√©t√© comme suit: comment utiliser 125 threads avec un temps de test de 120 secondes. </p><br><p>  La mesure des performances a √©t√© r√©alis√©e en 3 √©tapes: </p><br><ol><li>  Dimension du serveur API RPS.  Les mesures ont √©t√© effectu√©es afin de pouvoir √©valuer l'influence des m√©thodes de traitement sur les performances de chaque m√©thode. </li><li>  Mesure RPS du traitement des r√©ponses par r√©flexion. </li><li>  Mesurer le traitement des r√©ponses RPS sans utiliser de r√©flexion. </li></ol><br><p>  Sur la base de ces mesures, des donn√©es ont √©t√© obtenues sur les performances du traitement des r√©ponses.  L'utilisation de tous les c≈ìurs de processeur √©tait de 99,8 √† 100%.  Pour l'√©valuation, les donn√©es initiales de 10, 30, 100 et 500 enregistrements ont √©t√© s√©lectionn√©es.  Les tableaux de 500 enregistrements en production ne sont pas courants, mais j'√©tais int√©ress√© de voir comment chacune des langues se comportait. </p><br><h3 id="testovyy-stend">  Banc d'essai </h3><br><p>  Tous les tests ont √©t√© ex√©cut√©s sur une machine virtuelle ex√©cutant Ubuntu Server 18.04 avec toutes les mises √† jour pour ao√ªt 2019.  Il pr√©sente les caract√©ristiques suivantes: </p><br><ul><li>  Processeur Core I7-3770K - 4 c≈ìurs. </li><li>  RAM - 4 Go. </li></ul><br><p>  Pour comparer les performances, .NET Core 2.2 et Golang 1.12 ont √©t√© install√©s. </p><br><p>  Eh bien, il est maintenant temps de passer au plus int√©ressant - les r√©sultats. </p><br><h3 id="rezultaty">  R√©sultats </h3><br><p>  Voici un tableau avec les r√©sultats des tests. </p><br><p><img src="https://habrastorage.org/webt/y7/0o/qa/y70oqawydgs0k7dieoumddehicc.png" alt="alt text" title="Tableau 1. Tableau r√©capitulatif des r√©sultats des tests."></p><br><p>  Vous pouvez imm√©diatement remarquer que Golang a un serveur Web plus productif.  La diff√©rence est d'environ 12% par rapport √† Kestrel dans .NET Core. <br>  Sur la base des donn√©es ci-dessus, 2 graphiques ont √©t√© construits.  Ensuite, vous pouvez voir clairement la comparaison des RPS. </p><br><p><img src="https://habrastorage.org/webt/jt/ow/rp/jtowrpsxtiidgccxehrh7qkq1t8.png" alt="alt text" title="Figure 1. Comparaison de RPS"></p><br><p>  En raison de la biblioth√®que net / http plus rapide, Golang affiche de bons r√©sultats pour les petites donn√©es.  Avec une augmentation du volume de donn√©es, les performances sont compar√©es √† Kestrel. </p><br><p>  Lorsque vous utilisez la r√©flexion sur une petite taille de donn√©es, le RPS est approximativement le m√™me, compte tenu de l'erreur de mesure.  Avec l'augmentation de la taille des donn√©es, .NET Core affiche plus de RPS. </p><br><p>  Lors des tests sans utilisation de la r√©flexion, les deux langues ont montr√© un gain de performances.  Golang affiche de meilleures performances car il a initialement un RPS plus √©lev√© (requ√™tes par seconde) sur les tests sans traitement.  Sur les petites donn√©es, l'avantage est significatif.  Avec l'augmentation de la taille des donn√©es, RPS est presque compar√©.  Sur le plus gros test de 500 records, Golang est de nouveau en t√™te. </p><br><p><img src="https://habrastorage.org/webt/jd/6f/rq/jd6frqyzi1unjzhiicpbibm8dkw.png" alt="alt text" title="Figure 2. Comparaison de la d√©gradation des performances pendant le traitement JSON, moins c'est mieux."></p><br><p>  Lors des tests utilisant la r√©flexion, Golang a perdu sur tous les fronts.  La baisse des performances dans les pires sc√©narios √©tait sup√©rieure √† 60%.  L'impl√©mentation de la s√©rialisation pr√™te √† l'emploi pour les performances est g√©n√©ralement sans valeur. <br>  Sans r√©flexion, Golang a √©t√© plus rapide dans tous les tests.  Et avec la croissance des donn√©es, l'avantage de Golang ne fait que cro√Ætre.  Dans tous les cas, le refus d'utiliser la r√©flexion donne une am√©lioration significative des performances √† la fois pour Golang et .NETCore, ce qui, en g√©n√©ral, devrait √™tre attendu. </p><br><h3 id="vyvody">  Conclusions </h3><br><p>  Quelles conclusions peut-on tirer de cette petite comparaison de performances?  Je voudrais formuler cela sous la forme d'avantages et d'inconv√©nients pour chacune des solutions.  Commen√ßons par Golang: </p><br><ul><li>  Il a de meilleures performances et peut √™tre encore am√©lior√©, par exemple, en utilisant fasthttp comme serveur Web. </li><li>  Gr√¢ce √† la g√©n√©ration de code - utilisation pratique des m√©thodes de traitement sans r√©flexion. </li><li>  Moins de consommation de m√©moire. </li></ul><br><p>  .NET Core pr√©sente √©galement plusieurs avantages: </p><br><ul><li>  Les performances conviennent √† la plupart des cas. </li><li>  √Ä mon avis, c'est l'un des environnements de d√©veloppement les meilleurs et les plus pratiques pour Visual Studio. </li></ul><br><p>  Le r√©sultat peut √™tre r√©sum√© comme suit: si vous avez une API REST et que vous pr√©voyez une charge importante, une logique m√©tier pas trop compliqu√©e, il est pr√©f√©rable d'utiliser Golang, dans d'autres cas, vous pouvez le faire avec .NET Core.  Dois-je r√©√©crire des solutions pr√™tes √† l'emploi de .NET Core vers Golang?  Chacun d√©cidera pour lui-m√™me. </p><br><p>  J'esp√®re que vous trouverez ce mat√©riel utile.  Tout va bien </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469271/">https://habr.com/ru/post/fr469271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469257/index.html">Nous int√©grons des commandes Linux dans Windows √† l'aide de PowerShell et WSL</a></li>
<li><a href="../fr469259/index.html">Changement climatique: nous analysons la temp√©rature dans diff√©rentes villes au cours des 100 derni√®res ann√©es</a></li>
<li><a href="../fr469263/index.html">Pourquoi le karma sur Habr√© est-il bon?</a></li>
<li><a href="../fr469265/index.html">Multiprocessing Intel Neural Computer Stick Access via REST</a></li>
<li><a href="../fr469267/index.html">Gestion des appels syst√®me √† l'aide de LD_PRELOAD avec un seul point d'entr√©e</a></li>
<li><a href="../fr469275/index.html">Comme je l'ai fait dans 18 universit√©s am√©ricaines</a></li>
<li><a href="../fr469277/index.html">Qui est DevOps?</a></li>
<li><a href="../fr469287/index.html">Combattez les Golems des cartes. Comment nous avons transform√© le jeu en Parobot Card League</a></li>
<li><a href="../fr469289/index.html">Qu'est-ce que le trading sur marge sur la bourse et comment √ßa marche</a></li>
<li><a href="../fr469291/index.html">Initialisation et fonctionnement de l'interpr√©teur de bytecode dans JVM HotSpot sous x86</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>