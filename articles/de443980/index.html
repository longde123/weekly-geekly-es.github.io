<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ë üë∞üèº üïç Speicher und Spanne Punkt 3 üîà üå∂Ô∏è üíÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speicher <T> und ReadOnlyMemory <T> 


 Es gibt zwei visuelle Unterschiede zwischen Memory<T> und Span<T> . Der erste ist, dass der Memory<T> -Typ kei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Speicher und Spanne Punkt 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443980/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="memorylttgt-and-readonlymemorylttgt">  Speicher &lt;T&gt; und ReadOnlyMemory &lt;T&gt; </h2><br><p> Es gibt zwei visuelle Unterschiede zwischen <code>Memory&lt;T&gt;</code> und <code>Span&lt;T&gt;</code> .  Der erste ist, dass der <code>Memory&lt;T&gt;</code> -Typ keinen <code>ref</code> Modifikator im Header des Typs enth√§lt.  Mit anderen Worten, der <code>Memory&lt;T&gt;</code> kann sowohl auf dem Stapel als auch als lokale Variable oder als Methodenparameter oder als R√ºckgabewert als auch auf dem Heap zugewiesen werden, wobei von dort aus auf einige Daten im Speicher verwiesen wird.  Dieser kleine Unterschied f√ºhrt jedoch zu einem gro√üen Unterschied im Verhalten und den F√§higkeiten von <code>Memory&lt;T&gt;</code> Vergleich zu <code>Span&lt;T&gt;</code> .  Im Gegensatz zu <code>Span&lt;T&gt;</code> , einem <em>Instrument</em> f√ºr einige Methoden zur Verwendung eines Datenpuffers, dient der Typ <code>Memory&lt;T&gt;</code> zum Speichern von Informationen √ºber den Puffer, jedoch nicht zum Behandeln.  Somit gibt es den Unterschied in der API. </p><br><ul><li>  <code>Memory&lt;T&gt;</code> verf√ºgt nicht √ºber Methoden, um auf die Daten zuzugreifen, f√ºr die er verantwortlich ist.  Stattdessen verf√ºgt es √ºber die <code>Span</code> Eigenschaft und die <code>Slice</code> Methode, die eine Instanz vom Typ <code>Span</code> . </li><li>  Dar√ºber hinaus enth√§lt <code>Memory&lt;T&gt;</code> die <code>Pin()</code> -Methode, die f√ºr Szenarien verwendet wird, in denen gespeicherte Pufferdaten an <code>unsafe</code> Code √ºbergeben werden sollen.  Wenn diese Methode aufgerufen wird, wenn Speicher in .NET zugewiesen wird, wird der Puffer fixiert und nicht verschoben, wenn GC aktiv ist.  Diese Methode gibt eine Instanz der <code>MemoryHandle</code> Struktur zur√ºck, die <code>GCHandle</code> kapselt, um ein Segment einer Lebensdauer anzugeben und den Array-Puffer im Speicher zu <code>GCHandle</code> . </li></ul><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Ich schlage jedoch vor, dass wir uns mit der gesamten Klasse vertraut machen.  Schauen wir uns zun√§chst die <code>Memory&lt;T&gt;</code> -Struktur selbst an (hier zeige ich nur die Typmitglieder, die ich am wichtigsten fand): </p><br><pre> <code class="plaintext hljs"> public readonly struct Memory&lt;T&gt; { private readonly object _object; private readonly int _index, _length; public Memory(T[] array) { ... } public Memory(T[] array, int start, int length) { ... } internal Memory(MemoryManager&lt;T&gt; manager, int length) { ... } internal Memory(MemoryManager&lt;T&gt; manager, int start, int length) { ... } public int Length =&gt; _length &amp; RemoveFlagsBitMask; public bool IsEmpty =&gt; (_length &amp; RemoveFlagsBitMask) == 0; public Memory&lt;T&gt; Slice(int start, int length); public void CopyTo(Memory&lt;T&gt; destination) =&gt; Span.CopyTo(destination.Span); public bool TryCopyTo(Memory&lt;T&gt; destination) =&gt; Span.TryCopyTo(destination.Span); public Span&lt;T&gt; Span { get; } public unsafe MemoryHandle Pin(); }</code> </pre> <br><p>  Wie wir sehen, enth√§lt die Struktur den Konstruktor basierend auf Arrays, speichert jedoch Daten im Objekt.  Hiermit werden zus√§tzlich auf Zeichenfolgen verwiesen, f√ºr die kein Konstruktor entwickelt wurde, die jedoch mit der <code>AsMemory()</code> verwendet werden k√∂nnen. Es wird <code>AsMemory()</code> .  Da beide Typen jedoch bin√§r √§hnlich sein sollten, ist <code>Object</code> der Typ des <code>_object</code> . </p><br><p>  Als n√§chstes sehen wir zwei Konstruktoren, die auf <code>MemoryManager</code> basieren.  Wir werden sp√§ter dar√ºber sprechen.  Die Eigenschaften zum <code>IsEmpty</code> von <code>Length</code> (Gr√∂√üe) und <code>IsEmpty</code> pr√ºfen auf einen leeren Satz.  Es gibt auch die <code>Slice</code> Methode zum <code>CopyTo</code> einer Teilmenge sowie die <code>CopyTo</code> und <code>TryCopyTo</code> Kopiermethoden. </p><br><p>  Apropos <code>Memory</code> Ich m√∂chte zwei Methoden dieses Typs im Detail beschreiben: die <code>Span</code> Eigenschaft und die <code>Pin</code> Methode. </p><br><h3 id="memorylttgtspan">  Speicher &lt;T&gt; .Span </h3><br><pre> <code class="plaintext hljs">public Span&lt;T&gt; Span { get { if (_index &lt; 0) { return ((MemoryManager&lt;T&gt;)_object).GetSpan().Slice(_index &amp; RemoveFlagsBitMask, _length); } else if (typeof(T) == typeof(char) &amp;&amp; _object is string s) { // This is dangerous, returning a writable span for a string that should be immutable. // However, we need to handle the case where a ReadOnlyMemory&lt;char&gt; was created from a string // and then cast to a Memory&lt;T&gt;. Such a cast can only be done with unsafe or marshaling code, // in which case that's the dangerous operation performed by the dev, and we're just following // suit here to make it work as best as possible. return new Span&lt;T&gt;(ref Unsafe.As&lt;char, T&gt;(ref s.GetRawStringData()), s.Length).Slice(_index, _length); } else if (_object != null) { return new Span&lt;T&gt;((T[])_object, _index, _length &amp; RemoveFlagsBitMask); } else { return default; } } }</code> </pre> <br><p>  N√§mlich die Zeilen, die die Zeichenfolgenverwaltung √ºbernehmen.  Sie sagen, wenn wir <code>ReadOnlyMemory&lt;T&gt;</code> in <code>Memory&lt;T&gt;</code> konvertieren (diese Dinge sind in der bin√§ren Darstellung gleich und es gibt sogar einen Kommentar, m√ºssen diese Typen auf bin√§re Weise zusammenfallen, da einer durch den Aufruf von <code>Unsafe.As</code> aus einem anderen <code>Unsafe.As</code> ). Wir erhalten Zugang zu einer geheimen Kammer mit der M√∂glichkeit, die Saiten zu wechseln.  Dies ist ein √§u√üerst gef√§hrlicher Mechanismus: </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var str = "Hello!"; ReadOnlyMemory&lt;char&gt; ronly = str.AsMemory(); Memory&lt;char&gt; mem = (Memory&lt;char&gt;)Unsafe.As&lt;ReadOnlyMemory&lt;char&gt;, Memory&lt;char&gt;&gt;(ref ronly); mem.Span[5] = '?'; Console.WriteLine(str); } --- Hello?</code> </pre> <br><p>  Dieser Mechanismus in Kombination mit der Internierung von Zeichenfolgen kann schwerwiegende Folgen haben. </p><br><h3 id="memorylttgtpin">  Speicher &lt;T&gt; .Pin </h3><br><p>  Die zweite Methode, die gro√üe Aufmerksamkeit auf sich zieht, ist <code>Pin</code> : </p><br><pre> <code class="plaintext hljs">public unsafe MemoryHandle Pin() { if (_index &lt; 0) { return ((MemoryManager&lt;T&gt;)_object).Pin((_index &amp; RemoveFlagsBitMask)); } else if (typeof(T) == typeof(char) &amp;&amp; _object is string s) { // This case can only happen if a ReadOnlyMemory&lt;char&gt; was created around a string // and then that was cast to a Memory&lt;char&gt; using unsafe / marshaling code. This needs // to work, however, so that code that uses a single Memory&lt;char&gt; field to store either // a readable ReadOnlyMemory&lt;char&gt; or a writable Memory&lt;char&gt; can still be pinned and // used for interop purposes. GCHandle handle = GCHandle.Alloc(s, GCHandleType.Pinned); void* pointer = Unsafe.Add&lt;T&gt;(Unsafe.AsPointer(ref s.GetRawStringData()), _index); return new MemoryHandle(pointer, handle); } else if (_object is T[] array) { // Array is already pre-pinned if (_length &lt; 0) { void* pointer = Unsafe.Add&lt;T&gt;(Unsafe.AsPointer(ref array.GetRawSzArrayData()), _index); return new MemoryHandle(pointer); } else { GCHandle handle = GCHandle.Alloc(array, GCHandleType.Pinned); void* pointer = Unsafe.Add&lt;T&gt;(Unsafe.AsPointer(ref array.GetRawSzArrayData()), _index); return new MemoryHandle(pointer, handle); } } return default; }</code> </pre> <br><p>  Es ist auch ein wichtiges Instrument f√ºr die Vereinheitlichung, denn wenn wir einen Puffer an nicht verwalteten Code √ºbergeben m√∂chten, m√ºssen wir nur die <code>Pin()</code> -Methode aufrufen und einen Zeiger auf diesen Code √ºbergeben, unabh√§ngig davon, auf welche Art von Daten sich <code>Memory&lt;T&gt;</code> bezieht.  Dieser Zeiger wird in der Eigenschaft einer resultierenden Struktur gespeichert. </p><br><pre> <code class="plaintext hljs">void PinSample(Memory&lt;byte&gt; memory) { using(var handle = memory.Pin()) { WinApi.SomeApiMethod(handle.Pointer); } }</code> </pre> <br><p>  Es spielt keine Rolle, wof√ºr <code>Pin()</code> in diesem Code aufgerufen wurde: Es kann sich um <code>Memory</code> , der entweder <code>T[]</code> , oder um eine <code>string</code> oder einen Puffer nicht verwalteten Speichers.  Nur Arrays und Strings erhalten ein echtes <code>GCHandle.Alloc(array, GCHandleType.Pinned)</code> und im Falle eines nicht verwalteten Speichers passiert nichts. </p><br><h2 id="memorymanager-imemoryowner-memorypool">  MemoryManager, IMemoryOwner, MemoryPool </h2><br><p>  Neben der Angabe von Strukturfeldern m√∂chte ich darauf hinweisen, dass es zwei weitere <code>internal</code> <code>MemoryManager</code> gibt, die auf einer anderen Entit√§t basieren - <code>MemoryManager</code> .  Dies ist kein klassischer Speichermanager, an den Sie vielleicht gedacht haben, und wir werden sp√§ter dar√ºber sprechen.  klassischer Speichermanager, an den Sie vielleicht gedacht haben, und wir werden sp√§ter dar√ºber sprechen.  Wie <code>Span</code> hat <code>Memory</code> einen Verweis auf ein navigiertes Objekt, einen Offset und die Gr√∂√üe eines internen Puffers.  Beachten Sie, dass Sie den <code>new</code> Operator verwenden k√∂nnen, um <code>Memory</code> aus einem Array zu erstellen.  Sie k√∂nnen auch Erweiterungsmethoden verwenden, um <code>Memory</code> aus einer Zeichenfolge, einem Array oder einem <code>ArraySegment</code> zu erstellen.  Ich meine, es ist nicht daf√ºr ausgelegt, manuell aus nicht verwaltetem Speicher erstellt zu werden.  Wir k√∂nnen jedoch sehen, dass es eine interne Methode gibt, um diese Struktur mit <code>MemoryManager</code> zu erstellen. </p><br><p>  <strong>Datei <a href="">MemoryManager.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public abstract class MemoryManager&lt;T&gt; : IMemoryOwner&lt;T&gt;, IPinnable { public abstract MemoryHandle Pin(int elementIndex = 0); public abstract void Unpin(); public virtual Memory&lt;T&gt; Memory =&gt; new Memory&lt;T&gt;(this, GetSpan().Length); public abstract Span&lt;T&gt; GetSpan(); protected Memory&lt;T&gt; CreateMemory(int length) =&gt; new Memory&lt;T&gt;(this, length); protected Memory&lt;T&gt; CreateMemory(int start, int length) =&gt; new Memory&lt;T&gt;(this, start, length); void IDisposable.Dispose() protected abstract void Dispose(bool disposing); }</code> </pre> <br><p>  Diese Struktur gibt den Eigent√ºmer eines Speicherbereichs an.  Mit anderen Worten, <code>Span</code> ist ein Instrument zum Arbeiten mit dem Speicher, <code>Memory</code> ist ein Tool zum Speichern der Informationen √ºber einen bestimmten Speicherbereich und <code>MemoryManager</code> ist ein Tool zum Steuern der Lebensdauer dieses Bereichs, d. H. Des Besitzers.  Zum Beispiel k√∂nnen wir uns den Typ <code>NativeMemoryManager&lt;T&gt;</code> ansehen.  Obwohl es f√ºr Tests verwendet wird, repr√§sentiert dieser Typ eindeutig das Konzept des ‚ÄûEigentums‚Äú. </p><br><p>  <strong>Datei <a href="">NativeMemoryManager.cs</a></strong> </p><br><pre> <code class="plaintext hljs">internal sealed class NativeMemoryManager : MemoryManager&lt;byte&gt; { private readonly int _length; private IntPtr _ptr; private int _retainedCount; private bool _disposed; public NativeMemoryManager(int length) { _length = length; _ptr = Marshal.AllocHGlobal(length); } public override void Pin() { ... } public override void Unpin() { lock (this) { if (_retainedCount &gt; 0) { _retainedCount--; if (_retainedCount== 0) { if (_disposed) { Marshal.FreeHGlobal(_ptr); _ptr = IntPtr.Zero; } } } } } // Other methods }</code> </pre> <br><p>  Das bedeutet, dass die Klasse verschachtelte Aufrufe der <code>Pin()</code> -Methode zul√§sst und somit generierte Referenzen aus der <code>unsafe</code> Welt z√§hlt. </p><br><p>  Eine andere Entit√§t, die eng mit <code>Memory</code> ist, ist <code>MemoryPool</code> , das <code>MemoryManager</code> Instanzen zusammenfasst ( <code>IMemoryOwner</code> in der Tat): </p><br><p>  <strong>Datei <a href="">MemoryPool.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public abstract class MemoryPool&lt;T&gt; : IDisposable { public static MemoryPool&lt;T&gt; Shared =&gt; s_shared; public abstract IMemoryOwner&lt;T&gt; Rent(int minBufferSize = -1); public void Dispose() { ... } }</code> </pre> <br><p>  Es wird verwendet, um Puffer einer f√ºr die vor√ºbergehende Verwendung erforderlichen Gr√∂√üe zu leasen.  Die geleasten Instanzen mit der implementierten <code>IMemoryOwner&lt;T&gt;</code> -Schnittstelle verf√ºgen √ºber die <code>Dispose()</code> -Methode, um das geleaste Array an den Array-Pool zur√ºckzugeben.  Standardm√§√üig k√∂nnen Sie den gemeinsam nutzbaren Pufferpool verwenden, der auf <code>ArrayMemoryPool</code> : </p><br><p>  <strong>Datei <a href="">ArrayMemoryPool.cs</a></strong> </p><br><pre> <code class="plaintext hljs">internal sealed partial class ArrayMemoryPool&lt;T&gt; : MemoryPool&lt;T&gt; { private const int MaximumBufferSize = int.MaxValue; public sealed override int MaxBufferSize =&gt; MaximumBufferSize; public sealed override IMemoryOwner&lt;T&gt; Rent(int minimumBufferSize = -1) { if (minimumBufferSize == -1) minimumBufferSize = 1 + (4095 / Unsafe.SizeOf&lt;T&gt;()); else if (((uint)minimumBufferSize) &gt; MaximumBufferSize) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.minimumBufferSize); return new ArrayMemoryPoolBuffer(minimumBufferSize); } protected sealed override void Dispose(bool disposing) { } }</code> </pre> <br><p>  Basierend auf dieser Architektur haben wir das folgende Bild: </p><br><ul><li>  <code>Span</code> Datentyp sollte als Methodenparameter verwendet werden, wenn Sie Daten lesen ( <code>ReadOnlySpan</code> ) oder Daten lesen und schreiben ( <code>Span</code> ) m√∂chten.  Es sollte jedoch nicht f√ºr die zuk√ºnftige Verwendung in einem Feld einer Klasse gespeichert werden. </li><li>  Wenn Sie eine Referenz aus einem Feld einer Klasse in einem Datenpuffer speichern m√ºssen, m√ºssen Sie je nach Ihren Zielen <code>Memory&lt;T&gt;</code> oder <code>ReadOnlyMemory&lt;T&gt;</code> . </li><li>  <code>MemoryManager&lt;T&gt;</code> ist der Eigent√ºmer eines Datenpuffers (optional).  Dies kann erforderlich sein, wenn Sie beispielsweise <code>Pin()</code> -Aufrufe z√§hlen m√ºssen.  Oder wenn Sie wissen m√ºssen, wie Speicher freigegeben wird. </li><li>  Wenn der <code>Memory</code> um einen nicht verwalteten Speicherbereich herum aufgebaut ist, kann <code>Pin()</code> nichts tun.  Diese Uniformen arbeiten jedoch mit verschiedenen Puffertypen: Sowohl f√ºr verwalteten als auch f√ºr nicht verwalteten Code ist die Interaktionsschnittstelle identisch. </li><li>  Jeder Typ hat √∂ffentliche Konstruktoren.  Das hei√üt, Sie k√∂nnen <code>Span</code> direkt verwenden oder seine Instanz aus dem <code>Memory</code> .  F√ºr den <code>Memory</code> als solchen k√∂nnen Sie ihn einzeln erstellen oder einen Speicherbereich erstellen, der <code>IMemoryOwner</code> und auf den der <code>Memory</code> verweist.  Jeder auf <code>MemoryManger</code> basierende <code>MemoryManger</code> kann als ein spezifischer Fall betrachtet werden, dem ein lokaler Speicherbereich geh√∂rt (z. B. begleitet vom Z√§hlen der Referenzen aus der <code>unsafe</code> Welt).  Wenn Sie solche Puffer b√ºndeln m√ºssen (der h√§ufige Verkehr von fast gleich gro√üen Puffern wird erwartet), k√∂nnen Sie au√üerdem den <code>MemoryPool</code> Typ verwenden. </li><li>  Wenn Sie mit <code>unsafe</code> Code arbeiten <code>unsafe</code> , indem Sie dort einen Datenpuffer √ºbergeben, sollten Sie den <code>Memory</code> verwenden, der √ºber die <code>Pin()</code> -Methode verf√ºgt, mit der ein Puffer automatisch auf dem .NET-Heap fixiert wird, wenn er dort erstellt wurde. </li><li>  Wenn Sie etwas Pufferverkehr haben (z. B. wenn Sie einen Programmtext oder DSL analysieren), ist es besser, den <code>MemoryPool</code> Typ zu verwenden.  Sie k√∂nnen es ordnungsgem√§√ü implementieren, um die Puffer einer erforderlichen Gr√∂√üe aus einem Pool auszugeben (z. B. einen etwas gr√∂√üeren Puffer, wenn kein geeigneter vorhanden ist, aber <code>originalMemory.Slice(requiredSize)</code> , um eine Poolfragmentierung zu vermeiden). </li></ul><br><h2 id="performance">  Leistung </h2><br><p>  Um die Leistung neuer Datentypen zu messen, habe ich mich f√ºr eine Bibliothek entschieden, die bereits zum Standard von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BenchmarkDotNet geworden ist</a> : </p><br><pre> <code class="plaintext hljs">[Config(typeof(MultipleRuntimesConfig))] public class SpanIndexer { private const int Count = 100; private char[] arrayField; private ArraySegment&lt;char&gt; segment; private string str; [GlobalSetup] public void Setup() { str = new string(Enumerable.Repeat('a', Count).ToArray()); arrayField = str.ToArray(); segment = new ArraySegment&lt;char&gt;(arrayField); } [Benchmark(Baseline = true, OperationsPerInvoke = Count)] public int ArrayIndexer_Get() { var tmp = 0; for (int index = 0, len = arrayField.Length; index &lt; len; index++) { tmp = arrayField[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public void ArrayIndexer_Set() { for (int index = 0, len = arrayField.Length; index &lt; len; index++) { arrayField[index] = '0'; } } [Benchmark(OperationsPerInvoke = Count)] public int ArraySegmentIndexer_Get() { var tmp = 0; var accessor = (IList&lt;char&gt;)segment; for (int index = 0, len = accessor.Count; index &lt; len; index++) { tmp = accessor[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public void ArraySegmentIndexer_Set() { var accessor = (IList&lt;char&gt;)segment; for (int index = 0, len = accessor.Count; index &lt; len; index++) { accessor[index] = '0'; } } [Benchmark(OperationsPerInvoke = Count)] public int StringIndexer_Get() { var tmp = 0; for (int index = 0, len = str.Length; index &lt; len; index++) { tmp = str[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public int SpanArrayIndexer_Get() { var span = arrayField.AsSpan(); var tmp = 0; for (int index = 0, len = span.Length; index &lt; len; index++) { tmp = span[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public int SpanArraySegmentIndexer_Get() { var span = segment.AsSpan(); var tmp = 0; for (int index = 0, len = span.Length; index &lt; len; index++) { tmp = span[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public int SpanStringIndexer_Get() { var span = str.AsSpan(); var tmp = 0; for (int index = 0, len = span.Length; index &lt; len; index++) { tmp = span[index]; } return tmp; } [Benchmark(OperationsPerInvoke = Count)] public void SpanArrayIndexer_Set() { var span = arrayField.AsSpan(); for (int index = 0, len = span.Length; index &lt; len; index++) { span[index] = '0'; } } [Benchmark(OperationsPerInvoke = Count)] public void SpanArraySegmentIndexer_Set() { var span = segment.AsSpan(); for (int index = 0, len = span.Length; index &lt; len; index++) { span[index] = '0'; } } } public class MultipleRuntimesConfig : ManualConfig { public MultipleRuntimesConfig() { Add(Job.Default .With(CsProjClassicNetToolchain.Net471) // Span not supported by CLR .WithId(".NET 4.7.1")); Add(Job.Default .With(CsProjCoreToolchain.NetCoreApp20) // Span supported by CLR .WithId(".NET Core 2.0")); Add(Job.Default .With(CsProjCoreToolchain.NetCoreApp21) // Span supported by CLR .WithId(".NET Core 2.1")); Add(Job.Default .With(CsProjCoreToolchain.NetCoreApp22) // Span supported by CLR .WithId(".NET Core 2.2")); } }</code> </pre> <br><p>  Lassen Sie uns nun die Ergebnisse sehen. </p><br><p><img src="https://habrastorage.org/webt/x-/o3/gt/x-o3gt-syqsd6aj6d5k8b7lyc2i.png" alt="Leistungsdiagramm"></p><br><p>  Wenn wir sie uns ansehen, k√∂nnen wir folgende Informationen erhalten: </p><br><ul><li>  <code>ArraySegment</code> ist schrecklich.  Aber wenn Sie es in <code>Span</code> einwickeln, k√∂nnen Sie es weniger schrecklich machen.  In diesem Fall erh√∂ht sich die Leistung um das 7-fache. </li><li>  Wenn wir .NET Framework 4.7.1 in Betracht ziehen (dasselbe gilt f√ºr 4.5), verringert die Verwendung von <code>Span</code> die Leistung beim Arbeiten mit Datenpuffern erheblich.  Sie wird um 30‚Äì35% abnehmen. </li><li>  Wenn wir uns jedoch .NET Core 2.1+ ansehen, bleibt die Leistung √§hnlich oder steigt sogar, da <code>Span</code> einen Teil eines Datenpuffers verwenden kann, um den Kontext zu erstellen.  Die gleiche Funktionalit√§t ist in <code>ArraySegment</code> zu finden, funktioniert jedoch sehr langsam. </li></ul><br><p>  Somit k√∂nnen wir einfache Schlussfolgerungen hinsichtlich der Verwendung dieser Datentypen ziehen: </p><br><ul><li>  F√ºr <code>.NET Framework 4.5+</code> und <code>.NET Core</code> haben sie den einzigen Vorteil: Sie sind schneller als <code>ArraySegment</code> wenn sie mit einer Teilmenge eines urspr√ºnglichen Arrays arbeiten. </li><li>  In <code>.NET Core 2.1+</code> bietet ihre Verwendung einen unbestreitbaren Vorteil gegen√ºber <code>ArraySegment</code> und jeder manuellen Implementierung von <code>Slice</code> . </li><li>  Alle drei M√∂glichkeiten sind so produktiv wie m√∂glich und dies kann mit keinem Tool zur Vereinheitlichung von Arrays erreicht werden. <br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. </blockquote><br></li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443980/">https://habr.com/ru/post/de443980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443968/index.html">Wie wir ein Haus mit Sonnenkollektoren gekauft haben und was daraus wurde</a></li>
<li><a href="../de443972/index.html">Yandex wird mit einem Roboter nach Piraten suchen</a></li>
<li><a href="../de443974/index.html">Speicher und Spanne Punkt 1</a></li>
<li><a href="../de443976/index.html">Speicher und Spanne Punkt 2</a></li>
<li><a href="../de443978/index.html">ATtiny13 vs PLC, oder wie man 14 E / A von einem 8-Fu√ü-Controller erh√§lt</a></li>
<li><a href="../de443984/index.html">Der neue Standard auf Basis von PCIe 5.0 wird die CPU und die GPU ‚Äûverbinden‚Äú - was dar√ºber bekannt ist</a></li>
<li><a href="../de443986/index.html">Wie ein Eichh√∂rnchen in einem Rad oder ein wenig √ºber Benutzerforschung in einer Behinderungssituation</a></li>
<li><a href="../de443988/index.html">Microservice Architecture = Distributed Computing</a></li>
<li><a href="../de443990/index.html">13 neue Spiele, die im Rahmen des ID @ Xbox-Programms eingef√ºhrt wurden</a></li>
<li><a href="../de443992/index.html">Spiele mit MonoGame erstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>