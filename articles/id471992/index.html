<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏿 💣 🥈 Menerapkan fitur PEG yang tersisa 🧙🏽 🍣 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah saya mengumpulkan semua bagian dari generator parser PEG bersama di posting sebelumnya, saya siap untuk menunjukkan bagaimana menerapkan beber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menerapkan fitur PEG yang tersisa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471992/"><p>  Setelah saya mengumpulkan semua bagian dari generator parser PEG bersama di posting sebelumnya, saya siap untuk menunjukkan bagaimana menerapkan beberapa hal menarik lainnya. </p><br><div class="spoiler">  <b class="spoiler_title">Konten Seri Parser Python PEG</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengurai pasak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visualisasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata Bahasa PEG Rekursif Kiri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menambahkan Tindakan ke Tata Bahasa PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata bahasa meta untuk pengurai PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menerapkan fitur PEG yang tersisa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEG pada Core Developer Sprint</a> </li></ul></div></div><br><p>  Kami akan mempertimbangkan fitur PEG berikut: </p><a name="habracut"></a><br><ul><li> Item bernama: <code>NAME=item</code> (nama dapat digunakan dalam aksi) </li><li>  Lihat-lihat: <code>&amp;item</code> (positif) dan <code>!item</code> (negatif) </li><li>  Mengelompokkan item dalam tanda kurung: ( <code>item item ...</code> ) </li><li>  Item opsional: <code>[item item ...]</code> dan <code>item?</code> </li><li>  Duplikat item: <code>item*</code> (nol atau lebih) dan <code>item+</code> (satu atau lebih) </li></ul><br><h2 id="imenovannye-argumenty">  Argumen Bernama </h2><br><p>  Mari kita mulai dengan elemen bernama.  Ini nyaman ketika kita memiliki beberapa dari mereka dalam satu alternatif untuk aturan yang sama, misalnya: </p><br><pre> <code class="plaintext hljs">expr: term '+' term</code> </pre> <br><p>  Kita bisa merujuk ke <code>term</code> kedua dengan menambahkan angka <code>1</code> ke nama variabel, sehingga dalam tindakan ternyata seperti ini: </p><br><pre> <code class="plaintext hljs">expr: term '+' term { term + term1 }</code> </pre> <br><p>  Tetapi tidak semua orang menyukainya, dan secara pribadi, saya lebih suka menulis sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs">expr: left=term '+' right=term { left + right }</code> </pre> <br><p>  Ini mudah didukung dalam tata bahasa meta dengan mengubah aturan untuk <code>item</code> sebagai berikut: </p><br><pre> <code class="plaintext hljs">item: | NAME = atom { NamedItem(name.string, atom) } | atom { atom } atom: | NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  (Di mana <code>atom</code> hanyalah <code>item</code> lama) </p><br><p>  Ini mengharuskan kami untuk menambahkan definisi kelas <code>NamedItem</code> ke <code>grammar.py</code> .  Ini adalah salah satu kelas data yang saya sebutkan sebelumnya - juga memiliki atribut <code>name</code> dan <code>item</code> . </p><br><p>  Kita juga perlu membuat perubahan kecil pada generator kode, yang akan saya tinggalkan sebagai latihan untuk pembaca (atau Anda dapat melihat ke repositori saya :-).  Kode yang dihasilkan sekarang akan menetapkan hasil pencocokan setiap elemen ke variabel dengan nama yang ditentukan, dan bukan dengan nama yang diperoleh dari nama aturan elemen.  Ini juga akan berfungsi untuk elemen yang token (salah satu dari bentuk <code>NAME</code> atau string literal seperti <code>':='</code> ). </p><br><h2 id="lookahead">  Lihat ke depan </h2><br><p>  Diikuti oleh lookahead.  Anda mungkin menemukan konsep ini dalam ekspresi reguler.  Selama pencarian maju, alternatif yang diuraikan dapat segera ditolak atau diterima, tanpa menggeser pointer tokenizer. </p><br><p>  Bahkan, lookahead dapat digunakan sebagai cara yang lebih elegan untuk menghilangkan kebingungan dengan pengecualian parser, yang saya tulis di artikel sebelumnya.  Alih-alih mengizinkan tindakan untuk menolak alternatif yang sudah diterima dengan mengembalikan Tidak Ada, kita dapat menambahkan instruksi sebelum <code>OP</code> untuk mengecualikan <code>"}"</code> .  Aturan lama tampak seperti ini: </p><br><pre> <code class="plaintext hljs"> | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Versi baru terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"> | !"}" OP { op.string }</code> </pre> <br><p>  Ini mentransfer braket keriting yang memproses dari aksi ke tata bahasa, di mana tempatnya.  Kita tidak perlu memeriksa <code>"{"</code> , karena itu sesuai dengan alternatif sebelumnya (pada kenyataannya, ini juga berlaku untuk versi lama, tapi saya lupa tentang hal itu :-). </p><br><p>  Kami menambahkan tata bahasa untuk lookaheads ke aturan untuk <code>item</code> sebagai berikut: </p><br><pre> <code class="plaintext hljs">item: | NAME = atom { NamedItem(name.string, atom) } | atom { atom } | "&amp;" atom { Lookahead(atom, True) } | "!" atom { Lookahead(atom, False) }</code> </pre> <br><p>  Sekali lagi, kita perlu menambahkan dataclass <code>Lookahead</code> ke <code>grammar.py</code> (dan mengimpornya ke <code>@subheader</code> !) Dan memodifikasi generator sedikit dengan menambahkan metode pembantu berikut: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookahead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, positive, func, *args)</span></span></span><span class="hljs-function">:</span></span> mark = self.mark() ok = func(*args) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.reset(mark) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok == positive</code> </pre> <br><p>  Dalam kasus kami, kode yang dihasilkan untuk alternatif ini terlihat seperti ini: </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.lookahead(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, self.expect, <span class="hljs-string"><span class="hljs-string">"}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (op := self.expect(OP)) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op . string</code> </pre> <br><p>  Seperti yang dapat Anda lihat dari fragmen tata bahasa di atas, lookahead tidak bisa mendapatkan nama yang tepat.  Ini mudah untuk diperbaiki, tetapi saya masih tidak tahu seberapa berguna itu.  Selain itu, untuk prakiraan negatif, nilainya akan selalu <code>None</code> . </p><br><h2 id="gruppirovka-v-skobkah">  Pengelompokan dalam kurung </h2><br><p>  Sekarang mari kita implementasikan grup dengan tanda kurung.  Tempat terbaik untuk menambahkannya ke metagram adalah aturan untuk <code>atom</code> : </p><br><pre> <code class="plaintext hljs">atom: | NAME { name.string } | STRING { string.string } | "(" alts ")" { self.synthetic_rule(alts) }</code> </pre> <br><p>  Dua alternatif pertama tidak berubah.  Tindakan untuk alternatif baru menggunakan peretasan (yang implementasinya tetap tidak dapat dijelaskan), yang memungkinkan meta-parser untuk menambahkan aturan baru ke tata bahasa dengan cepat.  Fungsi helper ini (didefinisikan dalam meta-parser) mengembalikan nama objek aturan baru.  Ini akan terdiri dari awalan tetap diikuti oleh angka, yang membuatnya unik, misalnya, <code>_synthetic_rule_1</code> . </p><br><p>  Anda mungkin bertanya apa yang terjadi jika aturan sintetis akhirnya dibatalkan.  Saya tidak tahu bagaimana cara menghindari ini, tetapi seharusnya tidak ada masalah - dalam kasus terburuk akan ada aturan yang tidak digunakan dalam tata bahasa.  Dan berkat memoisasi, tindakan yang sama tidak akan pernah dieksekusi dua kali untuk posisi input yang sama, jadi ini bukan masalah juga (tetapi bahkan jika itu masalahnya, dalam kasus terburuk kita akan memiliki aturan mati). </p><br><p>  Menggunakan <code>alts</code> di dalam tanda kurung berarti kita dapat mendefinisikan bar vertikal sebagai pembatas dalam grup.  Misalnya, bahwa solusi tindakan baru kami tidak akan secara kebetulan cocok dengan <code>{</code> , kami dapat mengubah negasi menjadi ini: </p><br><pre> <code class="plaintext hljs"> | !("{" | "}") OP { op.string }</code> </pre> <br><p>  Selain itu, grup juga dapat memuat aksi!  Ini tidak akan membantu dalam menyelesaikan masalah dengan tindakan, tetapi dalam situasi lain mungkin bermanfaat.  Dan karena kita dalam hal apa pun menghasilkan aturan sintetik, itu tidak memerlukan pekerjaan tambahan untuk mengimplementasikannya (kecuali untuk implementasi <code>synthetic_rule</code> :-). </p><br><h2 id="opcionalnye-elementy">  Item opsional </h2><br><p>  Seperti pada pgen lama, saya menggunakan tanda kurung siku untuk menunjukkan sekelompok token opsional.  Di sinilah ternyata bermanfaat.  Misalnya, aturan tata bahasa yang menjelaskan Python <code>for</code> loop dapat menggunakannya untuk menunjukkan bahwa ekstensi yang <code>else</code> bisa ada.  Dan lagi kita dapat memperluas tata bahasa untuk <code>atom</code> sebagai berikut: </p><br><pre> <code class="plaintext hljs">atom: | NAME { name.string } | STRING { string.string } | "(" alts ")" { self.synthetic_rule(alts) } | "[" alts "]" { Maybe(self.synthetic_rule(alts)) }</code> </pre> <br><p>  Di sini <code>Maybe</code> adalah kelas data lain, dengan atribut <code>item</code> tunggal.  Kami memodifikasi pembuat kode sehingga hasil dari fungsi sintetis tidak gagal jika nilai ini <code>None</code> .  Untuk melakukan ini, Anda dapat menambahkan <code>or True</code> dalam implementasi.  Misalnya, untuk <code>[term]</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((term := self.term()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> term</code> </pre> <br><h2 id="povtoryayuschiesya-elementy">  Item duplikat </h2><br><p>  Beralih ke pengulangan adalah fungsi PEG lain yang bermanfaat (notasi dipinjam dari ekspresi reguler dan juga digunakan dalam pgen).  Ada dua bentuk: menambahkan <code>*</code> ke atom berarti "nol atau lebih pengulangan", sementara menambahkan <code>+</code> berarti "satu atau lebih pengulangan".  Untuk alasan lain, saya harus menulis ulang aturan tata bahasa untuk <code>item</code> dan <code>atom</code> , menambahkan aturan perantara, yang saya sebut <code>molecule</code> : </p><br><pre> <code class="plaintext hljs">item: | NAME '=' molecule { NamedItem(name.string, molecule) } | "&amp;" atom { Lookahead(atom) } | "!" atom { Lookahead(atom, False) } | molecule { molecule } molecule: | atom "?" { Maybe(atom) } | atom "*" { Loop(atom, False) } | atom "+" { Loop(atom, True) } | atom { atom } | "[" alts "]" { Maybe(self.synthetic_rule(alts)) } atom: | NAME { name.string } | STRING {string.string } | "(" alts ")" { self.synthetic_rule(alts) }</code> </pre> <br><p>  Perhatikan bahwa ini memperkenalkan sintaks alternatif untuk elemen opsional ( <code>atom?</code> ).  Itu tidak memerlukan upaya implementasi tambahan, karena ini hanyalah cara lain untuk membuat simpul <code>Maybe</code> . </p><br><p>  Refactoring aturan ini diperlukan karena saya tidak ingin membuat situasi tertentu valid: </p><br><ul><li>  pengulangan opsional (karena ini hanya pengulangan nol atau lebih); </li><li>  pengulangan (internal akan menangkap semua pertandingan, karena PEG selalu menggunakan algoritma serakah) </li><li>  nilai opsional yang diulangi (yang akan mengganggu analisis jika elemen opsional tidak cocok). </li></ul><br><p>  Namun, ini masih bukan solusi ideal, karena Anda dapat menulis sesuatu seperti <code>(foo?)*</code> .  Penting untuk menambahkan tanda centang pada situasi ini di generator parser, tapi saya akan melakukan ini di luar artikel. </p><br><p>  Kelas data <code>Loop</code> memiliki dua atribut: <code>item</code> dan <code>nonempty</code> .  Kode yang dihasilkan akan menggunakan metode helper parser <code>loop()</code> .  Ini sangat mirip dengan metode <code>lookahead()</code> yang ditunjukkan sebelumnya: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, nonempty, func, *args)</span></span></span><span class="hljs-function">:</span></span> mark = self.mark() nodes = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node := func(*args) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: nodes.append(node) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(nodes) &gt;= nonempty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodes self.reset(mark) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Jika <code>nonempty</code> <code>False</code> (dalam arti tata bahasa adalah <code>*</code> ), maka ini tidak akan menyebabkan kesalahan.  Tidak ada entri yang ditemukan, dan daftar kosong akan dikembalikan.  Untuk mewujudkannya, kami mengimplementasikan parser generator sehingga <code>is not None</code> ditambahkan.  Pemeriksaan yang lebih lunak dari pos sebelumnya akan mengembalikan <code>False</code> jika daftar kosong. </p><br><p>  Itu saja untuk hari ini!  Saya akan membahas "cut" ( <code>~</code> ) operator yang hadir di TatSu, tetapi sejauh ini saya belum memiliki kesempatan untuk menghadapinya.  Saya bahkan belum siap untuk membahasnya - dokumentasi TatSu hanya memberikan contoh sederhana yang sedikit menarik minat saya.  Saya tidak menemukannya di generator PEG-parser lain, jadi, mungkin, fitur ini hanya TatSu.  Mungkin suatu hari nanti saya akan menceritakan tentang dia.  (Sementara itu, saya menerapkannya untuk berjaga-jaga, Anda tidak pernah tahu. :-) </p><br><p>  Saya pikir artikel selanjutnya adalah tentang pengalaman saya menulis tata bahasa PEG yang dapat menganalisis tata bahasa Python.  Saya akan memberi tahu Anda bagaimana sprint pengembang kernel Python terjadi, yang berada di London minggu ini dengan dukungan logistik dari Bloomberg dan dukungan keuangan dari PSF dan beberapa perusahaan lain (misalnya, Dropbox membayar saya hotel dan penerbangan).  Terima kasih khusus kepada Emily Morhouse dan Pablo Galindo Salgado, yang banyak membantu dalam mengimplementasikan alat dan tes.  Selanjutnya, kita akan menulis tes kinerja, dan kemudian kita akan menambahkan tindakan ke tata bahasa ini sehingga dapat membuat pohon AST yang dapat dikompilasi oleh kompiler kode byte CPython.  Ada banyak hal yang lebih menarik di depan! </p><br><p>  Lisensi untuk artikel ini dan kode yang dikutip: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471992/">https://habr.com/ru/post/id471992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471980/index.html">Penipu telepon. Babak Empat, Final ...</a></li>
<li><a href="../id471982/index.html">Membahas masa depan PHP</a></li>
<li><a href="../id471986/index.html">Tata Bahasa PEG Rekursif Kiri</a></li>
<li><a href="../id471988/index.html">Menambahkan Tindakan ke Tata Bahasa PEG</a></li>
<li><a href="../id471990/index.html">Tata bahasa meta untuk pengurai PEG</a></li>
<li><a href="../id471994/index.html">Bekerja pada PEG pada Core Developer Sprint</a></li>
<li><a href="../id471998/index.html">F # 10: Daftar</a></li>
<li><a href="../id472000/index.html">“Sangat penting bagi masyarakat untuk menetapkan standar”: Marchin Moskala tentang Kotlin</a></li>
<li><a href="../id472002/index.html">Pengemasan Paket dalam Gradle</a></li>
<li><a href="../id472004/index.html">Tingkatkan. Spirit, atau Tambahkan "Spiritualitas" ke Daftar Filter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>