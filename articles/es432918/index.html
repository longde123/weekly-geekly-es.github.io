<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöí üôÖüèæ üèñÔ∏è Lo siento, romp√≠ tu recovery.conf üë®üèæ‚Äçüíº ü§¶üèΩ ü§µüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En PostgreSQL, desde tiempos muy antiguos, ya la versi√≥n 8.0 que se lanz√≥ en 2005, se utiliz√≥ un archivo de configuraci√≥n recovery.conf especial para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo siento, romp√≠ tu recovery.conf</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432918/"><img src="https://habrastorage.org/webt/fa/rt/zs/fartzsjcnmws2vzxpx4qhiw5ykq.jpeg" alt="te rompo la recuperaci√≥n" align="left">  En PostgreSQL, desde tiempos muy antiguos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya la versi√≥n 8.0 que se</a> lanz√≥ en 2005, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> utiliz√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo de configuraci√≥n recovery.conf</a> especial para restaurar a un punto espec√≠fico en el tiempo.  Posteriormente, el mismo archivo comenz√≥ a usarse para el modo de espera y la replicaci√≥n de transmisi√≥n. <br><br>  Sin embargo, desde la pr√≥xima versi√≥n de PostgreSQL 12, recovery.conf ya no funcionar√°: lo romp√≠. <br>  Pero por que? <br><a name="habracut"></a><br>  Recovery.conf ten√≠a una caracter√≠stica: se le√≠a solo al comienzo del DBMS.  Y si la recuperaci√≥n en un punto en el tiempo, que se necesita menos de una vez al a√±o, a√∫n puede conciliarse, entonces la necesidad de reiniciar toda la base de datos para cambiar la direcci√≥n del servidor de replicaci√≥n ascendente es algo deprimente.  Vi varias formas de perversiones para eludir esta limitaci√≥n, como el uso de enrutamiento L3, esquemas de replicaci√≥n en cascada (de modo que no todas las r√©plicas, pero al menos solo una parte de ellas, respectivamente) e incluso (incluso si no lo he visto en producci√≥n) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">walbouncer</a> . <br><br>  Despu√©s del pr√≥ximo reinicio programado de las r√©plicas, solo por la necesidad de cambiar los par√°metros de replicaci√≥n, decid√≠ retomarlo, pero ¬øqu√© costar√≠a ense√±arle a PostgreSQL a volver a leer primary_conninfo en SIGHUP?  <s>Todo sali√≥ mal.</s>  En principio, debe cambiar solo una variable en el proceso de inicio y, a partir de ah√≠, solicitar un reinicio de WalReceiver, y eso es todo, la replicaci√≥n continuar√° con la nueva direcci√≥n correctamente.  Queda por implementar esto correctamente.  Unas semanas m√°s tarde termin√© el parche con la implementaci√≥n de relectura recovery.conf en la se√±al SIGHUP, mientras que ese parche no rompi√≥ el comportamiento de la base de datos existente. <br><br>  Luego, teniendo el coraje, <a href="">lo envi√≥</a> a la lista de correo de desarrolladores de PostgreSQL.  Lo que Michael Paquier respondi√≥ bastante r√°pido: <br><blockquote>  Antes de hacer que algunos de ellos sean recargables, cambiemos primero a GUC y no reinventemos el manejo de los par√°metros SIGHUP como lo hace su parche. </blockquote>  Vaya, result√≥ que le hice una pregunta incorrecta al motor de b√∫squeda.  La pregunta no era acerca de volver a leer recovery.conf, sino acerca de la conversi√≥n de par√°metros desde un recovery.conf separado a la infraestructura GUC (gran configuraci√≥n unificada) utilizada para todos los dem√°s par√°metros DBMS.  Es decir, definitivamente no, no necesitamos ese parche, no queremos esto.  Primero transfiramos todas estas configuraciones desde recovery.conf a nuestra infraestructura de configuraciones est√°ndar. <br><br>  En esta triste noticia, me quem√© y pens√©: "¬°Pero transfir√°monos!".  Le√≠ las discusiones archivadas sobre la consulta de b√∫squeda correcta, abr√≠ la √∫ltima <a href="">discusi√≥n</a> encontrada <a href="">sobre la transferencia de configuraciones</a> (el enlace fue proporcionado amablemente por Michael Paquier en su respuesta, por lo cual le agradezco por separado, as√≠ como por la respuesta r√°pida).  En ese momento, en mayo de 2018, el parche fue abandonado por m√°s de un a√±o.  Entonces, aqu√≠ comenzamos.  ¬øO es m√°s correcto decir "continuar"?  Seg√∫n el plan de entretenimiento: <br><br><ol><li>  lea y enumere los cambios a la √∫ltima versi√≥n publicada del parche </li><li>  analizar los cambios en el parche y transferir lo necesario a la versi√≥n actual de la base de c√≥digo </li><li>  arregle todas las referencias a recovery.conf y sus par√°metros en la documentaci√≥n </li><li>  pruebas de reparaci√≥n </li><li>  enviar un nuevo parche a la lista de correo </li><li>  obtener cualquier comentario </li><li>  corregir algo de acuerdo con los deseos y volver al p√°rrafo 5 </li><li>  recibir una negativa a aceptar el parche nuevamente (en un a√±o y medio) </li></ol><br>  ¬øSuena como un plan de acci√≥n?  Bueno, aqu√≠ vamos! <br><br>  Cu√°nto tiempo, brevemente, llegu√© al punto cinco y el 21 de junio de 2018 publiqu√© una nueva versi√≥n del parche <a href="">en un nuevo hilo de discusi√≥n</a> .  Luego 3 meses en el silencio opresivo del silencio escalofriante de los peces Baskerville.  A finales de septiembre, Peter Eisentraut, uno de los desarrolladores principales con derecho a comprometerse, de repente mostr√≥ inter√©s en el parche.  Despu√©s de varias iteraciones de correcciones, mientras me alejaba tranquilamente durante unos d√≠as para dar un paseo, ver Budapest y ver los lugares de inter√©s, llega una carta desalentadora de Peter Eisentraut: <br><blockquote>  Revis√© el parche e hice un mont√≥n de peque√±os refinamientos.  Tambi√©n he actualizado la documentaci√≥n m√°s ampliamente.  El parche adjunto es comprometible para m√≠. </blockquote>  Es decir, Peter Eisentraut corrigi√≥ algunas peque√±as cosas m√°s a su discreci√≥n, actualiz√≥ la documentaci√≥n, grab√≥ toda la secci√≥n recovery-config.sgml y cree que de esta forma el parche ya puede ser aceptado.  Ah, y pens√© que suceder√≠a solo para postgresql 13, incluso si es tan afortunado que el parche generalmente alcance un estado de preparaci√≥n para el compromiso. <br><br>  Y unos d√≠as despu√©s, es decir, el 25 de noviembre de este 2018, Peter Eisentraut realmente <a href="">acepta este parche</a> : <br><blockquote>  La configuraci√≥n de recovery.conf ahora se establece en postgresql.conf (u otras fuentes de GUC).  Actualmente, todas las configuraciones afectadas son PGC_POSTMASTER;  Esto podr√≠a ser refinado en el futuro caso por caso. <br>  La recuperaci√≥n ahora se inicia mediante un archivo recovery.signal.  El modo de espera se inicia mediante un archivo standby.signal.  La configuraci√≥n standby_mode se ha ido.  Si se encuentra un archivo recovery.conf, se emite un error. <br>  Se ha cambiado el nombre de la configuraci√≥n de archivo_activador para promover_archivo_activador como parte del movimiento. <br>  El cap√≠tulo de documentaci√≥n "Configuraci√≥n de recuperaci√≥n" se ha integrado en "Configuraci√≥n del servidor". <br>  pg_basebackup -R ahora agrega configuraciones a postgresql.auto.conf y crea un archivo standby.signal. <br>  Autor: Fujii Masao &lt;masao (dot) fujii (at) gmail (dot) com&gt; <br>  Autor: Simon Riggs &lt;simon (at) 2ndquadrant (dot) com&gt; <br>  Autor: Abhijit Menon-Sen &lt;ams (at) 2ndquadrant (dot) com&gt; <br>  Autor: Sergei Kornilov &lt;sk (at) zsrv (dot) org&gt; </blockquote>  Han pasado dos semanas y este compromiso no se ha revertido.  Asombroso  Y parece que ni siquiera lo har√°n.  Es asombroso.  No se sabe si la comunidad decidir√° cambiar el comportamiento en alguna direcci√≥n nuevamente, especialmente dado que a√∫n queda un poco de tiempo antes de que la funci√≥n congele el lanzamiento de postgresql 12 en abril.  Pero parece que no tendremos m√°s recovery.conf. <br><br><h3>  Entonces, ¬øqu√© ha cambiado? </h3><br>  En primer lugar, el DBMS se negar√° a iniciarse si encuentra un archivo recovery.conf; esto se hizo espec√≠ficamente para que el usuario, utilizando una de las muchas instrucciones antiguas, no se sorprenda por qu√© la base de datos ignora la configuraci√≥n en este archivo. <br><br>  La antigua configuraci√≥n standby_mode ha desaparecido.  Ahora, as√≠ como el hecho mismo de la existencia de recovery.conf para habilitar el modo de recuperaci√≥n, se reemplaza por dos archivos (de cualquier contenido, generalmente vac√≠o): <br><br><ul><li>  $ PGDATA / recovery.signal - sucesor ideol√≥gico standby_mode = off, la restauraci√≥n del archivo se realizar√° al punto especificado en las configuraciones; </li><li>  $ PGDATA / standby.signal - respectivamente, standby_mode = on.  Veremos este archivo en todas las r√©plicas. </li></ul><br>  Si el proceso de inicio de la base de datos encontr√≥ ambos archivos, consideramos que estamos en modo de espera. <br><br>  Si, para mayor claridad, para reducir los cambios de par√°metros en una placa: <br><table><tbody><tr><th>  antigua recovery.conf <br></th><th>  PostgreSQL 12+ postgresql.conf <br></th></tr><tr><td>  primary_conninfo <br></td><td>  primary_conninfo <br></td></tr><tr><td>  nombre_slot_primaria <br></td><td>  nombre_slot_primaria <br></td></tr><tr><td>  archivo_activador <br></td><td>  promover_archivo_activador <br></td></tr><tr><td>  recovery_min_apply_delay <br></td><td>  recovery_min_apply_delay <br></td></tr><tr><td>  objetivo_recuperaci√≥n <br></td><td>  objetivo_recuperaci√≥n <br></td></tr><tr><td>  recovery_target_name <br></td><td>  recovery_target_name <br></td></tr><tr><td>  recovery_target_time <br></td><td>  recovery_target_time <br></td></tr><tr><td>  recovery_target_xid <br></td><td>  recovery_target_xid <br></td></tr><tr><td>  recovery_target_lsn <br></td><td>  recovery_target_lsn <br></td></tr><tr><td>  recovery_target_inclusive <br></td><td>  recovery_target_inclusive <br></td></tr><tr><td>  recovery_target_timeline <br></td><td>  recovery_target_timeline <br></td></tr><tr><td>  recovery_target_action <br></td><td>  recovery_target_action <br></td></tr><tr><td>  restaurar_comando <br></td><td>  restaurar_comando <br></td></tr><tr><td>  archive_cleanup_command <br></td><td>  archive_cleanup_command <br></td></tr><tr><td>  recovery_end_command <br></td><td>  recovery_end_command <br></td></tr></tbody></table><br>  Puedes ver que un poco menos que nada ha cambiado.  En este momento (con la √∫nica excepci√≥n del prefijo promover_ para archivo_activador_activador), todos los par√°metros nuevos se nombran como los anteriores y toman los mismos valores posibles.  Aunque, de hecho, todav√≠a hay un cambio con respecto a la configuraci√≥n del objetivo de recuperaci√≥n.  No s√© si alguien us√≥ esto antes, pero fue un comportamiento documentado y fue posible especificar varios recovery_target, recovery_target_lsn, recovery_target_name, recovery_target_time o recovery_target_xid al mismo tiempo.  Por ejemplo <br><br><pre><code class="plaintext hljs">recovery_target_lsn = '1/1D9FEA00' recovery_target_xid = '5238954'</code> </pre> <br>  La √∫ltima l√≠nea de recovery.conf se us√≥ realmente para la recuperaci√≥n.  Esto ya no es posible, el objetivo de recuperaci√≥n debe indicarse por un m√°ximo de uno.  Sin embargo, debido a la l√≥gica de la infraestructura de GUC, a√∫n puede especificar el par√°metro del mismo nombre varias veces: <br><br><pre> <code class="plaintext hljs">recovery_target_lsn = '1/1D9FEA00' recovery_target_lsn = '1/16AC7D0'</code> </pre> <br>  Esto es aceptable, se restablecer√° el valor de configuraci√≥n especificado en √∫ltimo lugar. <br><br>  Y, en general, esto es todo lo que hay que decir sobre los cambios visibles desde fuera de PostgreSQL.  pg_basebackup -R (--write-recovery-conf) permaneci√≥ en su lugar y hace lo que se pretende, solo que ahora agregar√° par√°metros a postgresql.auto.conf en lugar de recovery.conf y crear√° un archivo standby.signal <br><br>  Desafortunadamente, cuando digo que estos son todos los cambios que est√°n visibles actualmente, esto es exactamente lo que quiero decir.  Todos los par√°metros nuevos todav√≠a se configuran como PGC_POSTMASTER, es decir, solo se pueden cambiar cuando se inicia PostgreSQL.  Como ya se mencion√≥, este fue un requisito por parte de la comunidad de desarrolladores: primero, transfiera todas las configuraciones, y solo luego vea si se pueden cambiar en la base de datos en ejecuci√≥n.  As√≠ que ahora PostgreSQL se encuentra en una etapa maravillosa de desarrollo, cuando el comportamiento anterior ya se ha roto y a√∫n no se han introducido cambios para mejorar. <br><br>  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publiqu√© un parche</a> que permitir√° cambiar primary_conninfo y primary_slot_name sobre la marcha.  Veamos que pasa. <br><br>  Lo siento, romp√≠ tu recovery.conf <br><br><h3>  UPD 7 de abril de 2019 </h3><br>  En el √∫ltimo d√≠a antes de la funci√≥n de congelaci√≥n de la versi√≥n 12, puede resumir.  Cambiar la configuraci√≥n de replicaci√≥n no se incluy√≥ en la versi√≥n.  Por supuesto, esta tambi√©n es una historia curiosa.  √ârase una vez, el parche Simon Riggs que tom√© como base ya conten√≠a ediciones para reiniciar walreceiver al cambiar la configuraci√≥n de conexi√≥n.  Los seleccion√© en un parche separado que complementa la documentaci√≥n y las pruebas.  Y despu√©s de 6 actualizaciones de parches y un par de meses de discusi√≥n, surge el hecho obvio de que si reinicia walreceiver, la base de datos intentar√° cambiar a la restauraci√≥n de archivos desde restore_command.  Un comportamiento bastante simple de la m√°quina de estados, que se desencadena al apagar el receptor de red por cualquier motivo.  Pero esto resulta ser "algo que no queremos".  Bueno, antes era imposible decir?  Ok, lo rehice de alguna manera, pero el calendario ya ten√≠a el √∫ltimo commitfest para la versi√≥n 12 y nadie mir√≥ aqu√≠.  En general, esto no es algo r√°pido, lo hacen los parches en PostgreSQL.  Pero tengo todo el derecho de incluirme en la lista de personas, ¬°gracias a quienes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> incluy√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">REINDEX CONCURRENTEMENTE sin terminar m√°s √©pico sin terminar</a> en la versi√≥n 12! <br><br>  Vale la pena mencionar al final que una serie de configuraciones tienen <a href="">la oportunidad</a> de cambiar sobre la marcha: archive_cleanup_command, promote_trigger_file, recovery_end_command, recovery_min_apply_delay </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432918/">https://habr.com/ru/post/es432918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432906/index.html">Edici√≥n de archivos CSV para no romper datos</a></li>
<li><a href="../es432908/index.html">En Rusia, planean introducir un control adicional sobre los pagos en Internet.</a></li>
<li><a href="../es432910/index.html">Es peligroso considerar la realidad virtual como una m√°quina para la empat√≠a.</a></li>
<li><a href="../es432912/index.html">C√≥mo obtener una pasant√≠a en Google</a></li>
<li><a href="../es432914/index.html">Un bot de chat muy simple para Telegram para los m√°s peque√±os.</a></li>
<li><a href="../es432920/index.html">El factor humano en la empresa: ¬øes peligroso?</a></li>
<li><a href="../es432922/index.html">C√≥mo buscamos durante dos semanas el error NFS en el kernel de Linux</a></li>
<li><a href="../es432924/index.html">Run, Gecko, run: un mecanismo de movimiento de agua h√≠brido gecko</a></li>
<li><a href="../es432926/index.html">24 recetas sobre c√≥mo una startup puede tener √©xito en una gran exposici√≥n mundial, utilizando la Web Summit 2018 como ejemplo</a></li>
<li><a href="../es432928/index.html">Lo que est√° sucediendo en Intel y por qu√© Amazon no transferir√° AWS por completo a sus chips a pesar de los fuertes titulares</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>