<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’ ğŸ™ğŸ» ğŸ¦ Lembar Curang Gradle ğŸ€ ğŸ¤¦ğŸ¾ ğŸ’†ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tampak bagi saya bahwa kebanyakan orang mulai berurusan dengan gradle hanya ketika sesuatu perlu ditambahkan ke proyek atau sesuatu tiba-tiba rusak - ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lembar Curang Gradle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458046/"><p> Tampak bagi saya bahwa kebanyakan orang mulai berurusan dengan gradle hanya ketika sesuatu perlu ditambahkan ke proyek atau sesuatu tiba-tiba rusak - dan setelah menyelesaikan masalah "diperoleh dengan bekerja terlalu keras" pengalaman itu dilupakan dengan aman.  Selain itu, banyak contoh di Internet mirip dengan mantra khusus yang tidak menambah pemahaman tentang apa yang terjadi: </p><br><pre><code class="java hljs">android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">28</span></span> defaultConfig { applicationId <span class="hljs-string"><span class="hljs-string">"com.habr.hello"</span></span> minSdkVersion <span class="hljs-number"><span class="hljs-number">20</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">28</span></span> } buildTypes { release { minifyEnabled <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } } }</code> </pre> <br><p>  Saya tidak akan menjelaskan secara rinci untuk apa setiap baris di atas - ini adalah detail pribadi dari penerapan plugin android.  Ada sesuatu yang lebih berharga - pemahaman tentang bagaimana semuanya diatur.  Informasi ini tersebar di berbagai situs / dokumentasi resmi / sumber hujan es dan plugin untuk itu - secara umum, ini adalah pengetahuan yang sedikit lebih universal yang tidak ingin saya lupakan. </p><br><p>  Teks lebih lanjut dapat dianggap sebagai lembar contekan bagi mereka yang hanya menguasai gradle atau sudah lupa. </p><a name="habracut"></a><br><h2 id="poleznye-ssylki">  Tautan yang bermanfaat </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> cukup banyak, tetapi di beberapa tempat mungkin ada kurang detail. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber pada github</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javadoc</a> - karena pengetikan dinamis pada groovy, lingkungan pengembangan jauh dari selalu dapat memberikan daftar bidang / metode yang tersedia, dan dengan nama pendek metode dan tipe argumen (Penutupan penutupan) tidak selalu mungkin untuk memahami mengapa mereka diperlukan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel di hub dengan banyak contoh</a> adalah terjemahan dari bab kedua dari buku "Membangun dan menguji dengan gradle".  Buku ini juga dapat dibaca, tersedia secara gratis. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu artikel lagi - tentang buildSrc</a> </li></ul><br><h1 id="konsol">  Konsol </h1><br><p>  Android studio / IDEA susah payah menyembunyikan perintah gradle dari pengembang, dan bahkan ketika mengubah file build.gradle itu mulai membodohi atau memulai kembali proyek. </p><br><p>  Dalam kasus seperti itu, memanggil gradle dari konsol jauh lebih mudah dan lebih cepat.  Grapper wrapper biasanya datang dengan proyek dan berfungsi dengan baik di linux / macos / windows, kecuali di yang terakhir Anda perlu memanggil file bat bukan wrapper. </p><br><h2 id="vyzov-zadach">  Tugas tantangan </h2><br><pre> <code class="plaintext hljs">./gradlew tasks</code> </pre> <br><p>  menulis tugas yang tersedia. </p><br><pre> <code class="plaintext hljs">./gradlew subprojectName:tasks --all</code> </pre> <br><p>  Anda dapat menampilkan tugas-tugas dari sub proyek yang terpisah, dan bahkan dengan opsi <code>--all</code> , semua tugas, termasuk yang sekunder, akan ditampilkan. </p><br><p>  Anda dapat memanggil tugas apa pun, dan semua tugas yang bergantung padanya akan dipanggil. </p><br><pre> <code class="plaintext hljs">./gradlew app:assembleDevelopDebug</code> </pre> <br><p>  Jika Anda terlalu malas untuk menulis seluruh nama, Anda dapat membuang surat-surat kecil: </p><br><pre> <code class="plaintext hljs">./gradlew app:assembleDD</code> </pre> <br><p>  Jika hujan es tidak dapat dengan jelas menebak tugas yang mereka pikirkan, itu akan menampilkan daftar opsi yang sesuai. </p><br><h2 id="logging">  Penebangan </h2><br><p>  Jumlah informasi yang ditampilkan di konsol saat memulai tugas sangat bergantung pada tingkat pencatatan. <br>  Selain default, ada <code>-q, -w, -i, -d</code> , well, atau <code>--quiet, --warn, --info, --debug</code> dalam meningkatkan jumlah informasi.  Pada proyek yang kompleks, output dengan -d dapat memakan waktu lebih dari satu megabyte, dan karena itu lebih baik menyimpannya ke file segera dan mencari di sana dengan mencari kata kunci: </p><br><pre> <code class="bash hljs">./gradlew app:build -d &gt; myLog.txt</code> </pre> <br><p>  Jika pengecualian dilemparkan ke suatu tempat, opsi <code>-s</code> untuk stacktrace. </p><br><p>  Anda dapat menulis ke log sendiri: </p><br><pre> <code class="java hljs">logger.warn(<span class="hljs-string"><span class="hljs-string">'A warning log message.'</span></span>)</code> </pre> <br><p>  logger adalah implementasi dari SLF4J. </p><br><h2 id="groovy">  Asyik </h2><br><p>  Apa yang terjadi di file <code>build.gradle</code> hanyalah kode asyik. </p><br><p>  Untuk beberapa alasan, Groovy, sebagai bahasa pemrograman, tidak terlalu populer, meskipun, menurut saya, itu sendiri layak untuk setidaknya dipelajari sedikit.  Bahasa lahir kembali pada tahun 2003 dan perlahan berkembang.  Fitur menarik: </p><br><ul><li>  Hampir semua kode java adalah kode asyik yang valid.  Sangat membantu untuk menulis kode kerja secara intuitif. </li><li>  Bersamaan dengan statis, pengetikan dinamis didukung dalam alur, daripada <code>String a = "a"</code> Anda dapat dengan aman menulis <code>def a = "a"</code> atau bahkan <code>def map = ['one':1, 'two':2, 'list' = [1,false]]</code> </li><li>  Ada beberapa penutupan di mana Anda dapat secara dinamis menentukan konteks eksekusi.  Blok <code>android {...}</code> sama ditutup dan dieksekusi untuk beberapa objek. </li><li>  Ada interpolasi string <code>"$a, ${b}"</code> , string multiline <code>"""yep, ${c}"""</code> , dan string java biasa dibingkai oleh tanda kutip tunggal: <code>'text'</code> </li><li>  Ada kemiripan metode penyuluhan.  Kumpulan bahasa standar sudah memiliki metode seperti findAll, setiap, masing-masing.  Bagi saya pribadi, nama-nama metode itu tampak tidak biasa, tetapi yang terpenting adalah metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">itu</a> . </li><li>  Gula sintaksis yang lezat, kodenya jauh lebih pendek dan sederhana.  Anda tidak harus menulis tanda kurung di sekitar argumen fungsi, untuk deklarasi daftar dan <code>[a,b,c], [key1: value1, key2: value2]</code> hash <code>[a,b,c], [key1: value1, key2: value2]</code> sintaks yang bagus adalah: <code>[a,b,c], [key1: value1, key2: value2]</code> </li></ul><br><p>  Secara umum, mengapa bahasa seperti Python / Javascript telah meroket dan Groovy tidak - itu adalah misteri bagi saya.  Pada masanya, ketika tidak ada lambdas di Jawa, dan alternatif seperti kotlin / scala baru saja muncul atau belum ada, Groovy harus terlihat seperti bahasa yang sangat menarik. </p><br><p>  Itu adalah fleksibilitas dari sintaks groovy dan pengetikan dinamis yang memungkinkan kami untuk membuat DSL ringkas secara bertahap. </p><br><p>  Sekarang dalam dokumentasi resmi Gradle, contohnya digandakan di Kotlin, dan sepertinya direncanakan untuk beralih ke sana, tetapi kode itu tidak lagi terlihat begitu sederhana dan menjadi lebih seperti kode normal: </p><br><pre> <code class="java hljs">task hello { doLast { println <span class="hljs-string"><span class="hljs-string">"hello"</span></span> } }</code> </pre> <br><p>  vs. </p><br><pre> <code class="kotlin hljs">tasks.register(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) { doLast { println(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) } }</code> </pre> <br><p>  Namun, penggantian nama di Kradle belum direncanakan. </p><br><h2 id="stadii-sborki">  Tahap perakitan </h2><br><p>  Mereka dibagi menjadi inisialisasi, konfigurasi, dan eksekusi. </p><br><p>  Idenya adalah bahwa gradle mengumpulkan grafik ketergantungan asiklik dan hanya memanggil minimum yang diperlukan.  Jika saya mengerti benar, tahap inisialisasi terjadi pada saat ketika kode dari build.gradle dieksekusi. </p><br><p>  Sebagai contoh, ini: </p><br><pre> <code class="java hljs">copy { from source to dest }</code> </pre> <br><p>  Atau seperti ini: </p><br><pre> <code class="java hljs">task epicFail { copy{ from source to dest } }</code> </pre> <br><p>  Mungkin ini tidak jelas, tetapi di atas akan memperlambat inisialisasi.  Agar tidak terlibat dalam menyalin file di setiap inisialisasi, Anda perlu menggunakan <code>doLast{...}</code> atau <code>doFirst{...}</code> dalam tugas - maka kode akan dibungkus dalam penutup dan akan dipanggil ketika tugas selesai. </p><br><pre> <code class="java hljs">task properCopy { doLast { copy { from dest to source } } }</code> </pre> <br><p>  atau lebih </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">properCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Copy)</span></span></span><span class="hljs-function"> </span></span>{ from dest to source }</code> </pre> <br><p>  Dalam contoh lama, <code>doLast</code> dapat melihat operator <code>&lt;&lt;</code> bukannya <code>doLast</code> , tetapi mereka kemudian mengabaikannya karena perilaku yang tidak jelas. </p><br><pre> <code class="java hljs">task properCopy &lt;&lt; { println(<span class="hljs-string"><span class="hljs-string">"files copied"</span></span>) }</code> </pre> <br><h2 id="tasksall">  semua tugas </h2><br><p>  Apa yang lucu, dengan <code>doLast</code> dan <code>doFirst</code> Anda dapat menggantung beberapa jenis tindakan pada tugas apa pun: </p><br><pre> <code class="kotlin hljs">tasks.all { doFirst { println(<span class="hljs-string"><span class="hljs-string">"task </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> started"</span></span>) } }</code> </pre> <br><p>  IDE menyarankan bahwa <code>tasks</code> memiliki metode <code>whenTaskAdded(Closure ...)</code> , tetapi metode <code>all(Closure ...)</code> bekerja jauh lebih menarik - penutup dipanggil untuk semua tugas yang ada, serta untuk tugas baru saat ditambahkan. </p><br><p>  Buat tugas yang mencetak dependensi semua tugas: </p><br><pre> <code class="kotlin hljs">task printDependencies { doLast { tasks.all { println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> dependsOn </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dependsOn</span></span></span><span class="hljs-string">"</span></span>) } } }</code> </pre> <br><p>  atau lebih: </p><br><pre> <code class="kotlin hljs">task printDependencies { doLast { tasks.all { Task task -&gt; println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${task.name}</span></span></span><span class="hljs-string"> dependsOn </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${task.dependsOn}</span></span></span><span class="hljs-string">"</span></span>) } } }</code> </pre> <br><p>  Jika <code>tasks.all{}</code> dipanggil saat runtime (di blok <code>doLast</code> ), maka kita akan melihat semua tugas dan dependensi. <br>  Jika Anda melakukan hal yang sama tanpa <code>doLast</code> (mis., Selama inisialisasi), maka tugas yang dicetak mungkin tidak memiliki dependensi, karena belum ditambahkan. </p><br><p>  Oh ya, kecanduan!  Jika tugas lain harus bergantung pada hasil implementasi kami, maka ada baiknya menambahkan ketergantungan: </p><br><pre> <code class="java hljs">anotherTask.dependsOn properCopy</code> </pre> <br><p>  Atau bahkan seperti ini: </p><br><pre> <code class="kotlin hljs">tasks.all{ task -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task.name.toLowerCase().contains(<span class="hljs-string"><span class="hljs-string">"debug"</span></span>)) { task.dependsOn properCopy } }</code> </pre> <br><h2 id="inputs-outputs-i-inkrementalnaya-sborka">  input, output dan rakitan tambahan </h2><br><p>  Tugas umum akan dipanggil setiap waktu.  Jika Anda menentukan bahwa tugas yang didasarkan pada file A menghasilkan file B, maka gradle akan melewatkan tugas jika file-file ini tidak berubah.  Dan gradle tidak memeriksa tanggal modifikasi file, tetapi isinya. </p><br><pre> <code class="kotlin hljs">task generateCode(type: Exec) { commandLine <span class="hljs-string"><span class="hljs-string">"generateCode.sh"</span></span>, <span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"output.java"</span></span> inputs.file <span class="hljs-string"><span class="hljs-string">"input.txt"</span></span> output.file <span class="hljs-string"><span class="hljs-string">"output.java"</span></span> }</code> </pre> <br><p>  Demikian pula, Anda dapat menentukan folder, serta beberapa nilai: <code>inputs.property(name, value)</code> . </p><br><h2 id="task-description">  deskripsi tugas </h2><br><p>  Saat memanggil <code>./gradlew tasks --all</code> tugas standar memiliki deskripsi yang indah dan entah bagaimana dikelompokkan.  Untuk tugas Anda, ini ditambahkan dengan sangat sederhana: </p><br><pre> <code class="kotlin hljs">task hello { group <span class="hljs-string"><span class="hljs-string">"MyCustomGroup"</span></span> description <span class="hljs-string"><span class="hljs-string">"Prints 'hello'"</span></span> doLast{ print <span class="hljs-string"><span class="hljs-string">'hello'</span></span> } }</code> </pre> <br><h3 id="taskenabled">  task.enabled </h3><br><p>  Anda dapat "mematikan" tugas - maka dependensinya masih akan dipanggil, tetapi itu sendiri tidak akan. </p><br><pre> <code class="java hljs">taskName.enabled <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br><h2 id="neskolko-proektov-moduley">  beberapa proyek (modul) </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multi-proyek dibangun dalam dokumentasi</a> </p><br><p>  Di proyek utama, Anda dapat menempatkan beberapa modul lagi.  Sebagai contoh, ini digunakan dalam proyek android - hampir tidak ada dalam proyek root, plugin android termasuk dalam subproyek.  Jika Anda ingin menambahkan modul baru, Anda dapat menambahkan yang lain, dan di sana, misalnya, Anda juga dapat menghubungkan plugin android, tetapi gunakan pengaturan lain untuk itu. </p><br><p>  Contoh lain: saat menerbitkan proyek menggunakan jitpack, proyek root menjelaskan dengan pengaturan apa untuk menerbitkan modul anak yang bahkan mungkin tidak mencurigai publikasi. </p><br><p>  Modul anak ditentukan dalam settings.gradle: </p><br><pre> <code class="java hljs">include <span class="hljs-string"><span class="hljs-string">'name'</span></span></code> </pre> <br><p>  Baca lebih lanjut tentang dependensi antar proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </p><br><h2 id="buildsrc">  buildSrc </h2><br><p>  Jika <code>build.gradle</code> banyak kode dalam <code>build.gradle</code> atau digandakan, itu bisa dipindahkan ke modul terpisah.  Kami membutuhkan folder dengan nama ajaib <code>buildSrc</code> , di mana Anda dapat menempatkan kode di groovy atau java.  (baik, atau lebih tepatnya, di <code>buildSrc/src/main/java/com/smth/</code> code, tes dapat ditambahkan ke <code>buildSrc/src/test</code> ).  Jika Anda menginginkan sesuatu yang lain, misalnya, tulis tugas Anda di scala atau gunakan beberapa dependensi, maka langsung di <code>buildSrc</code> Anda perlu membuat <code>build.gradle</code> dan tentukan dependensi yang diperlukan di dalamnya / aktifkan plugin. </p><br><p>  Sayangnya, dengan sebuah proyek di <code>buildSrc</code> IDE dapat <code>buildSrc</code> dengan petunjuk, di sana Anda harus menulis impor dan kelas / tugas dari sana <code>build.gradle</code> juga harus mengimpornya ke <code>build.gradle</code> biasa.  <code>import com.smth.Taskname</code> tidak sulit, Anda hanya perlu mengingat ini dan tidak memikirkan mengapa tugas dari <code>buildSrc</code> tidak ditemukan). </p><br><p>  Untuk alasan ini, mudah untuk terlebih dahulu menulis sesuatu yang bekerja langsung di <code>build.gradle</code> , dan baru kemudian mentransfer kode ke <code>buildSrc</code> . </p><br><h2 id="svoy-tip-zadachi">  Jenis tugas sendiri </h2><br><p>  Tugas ini diturunkan dari <code>DefaultTask</code> , di mana ada banyak, banyak bidang, metode, dan hal lainnya.  <a href="">Kode AbstractTask diwarisi dari DefaultTask.</a> </p><br><p>  Poin yang berguna: </p><br><ul><li>  alih-alih menambahkan <code>inputs</code> dan <code>outputs</code> secara manual <code>outputs</code> Anda dapat menggunakan bidang dan anotasi <code>@Input, @OutputFile</code> : <code>@Input, @OutputFile</code> , dll. </li><li>  metode yang akan dijalankan saat tugas dijalankan: <code>@TaskAction</code> . </li><li>  metode yang mudah digunakan seperti <code>copy{from ... , into... }</code> masih dapat dipanggil, tetapi Anda harus memanggilnya secara eksplisit untuk proyek: <code>project.copy{...}</code> </li></ul><br><p>  Ketika seseorang di <code>build.gradle</code> menulis untuk tugas kita </p><br><pre> <code class="java hljs">taskName { ... <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre> <br><p>  metode <code>configure(Closure)</code> dipanggil pada tugas. </p><br><p>  Saya tidak yakin apakah ini adalah pendekatan yang tepat, tetapi jika sebuah tugas memiliki beberapa bidang yang kondisi timbal baliknya sulit dikendalikan dengan pengambil-pengambil, maka tampaknya cukup mudah untuk mendefinisikan kembali metode sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Closure closure)</span></span></span></span>{ def result = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>().configure(closure) <span class="hljs-comment"><span class="hljs-comment">//    / - return result; }</span></span></code> </pre> <br><p>  Dan bahkan jika Anda menulis </p><br><pre> <code class="java hljs">taskName.fieldName value</code> </pre> <br><p>  maka metode <code>configure</code> akan tetap dipanggil. </p><br><h2 id="svoy-plagin">  Plugin sendiri </h2><br><p>  Seperti tugas, Anda dapat menulis plugin sendiri, yang akan mengonfigurasi sesuatu atau membuat tugas.  Misalnya, apa yang terjadi di <code>android{...}</code> sepenuhnya merupakan prestasi <del>  ilmu hitam </del>  Plug-in Android, yang selain itu menciptakan banyak tugas seperti aplikasi: assembleDevelopDebug untuk semua kemungkinan kombinasi rasa / tipe build / dimenstion.  Tidak ada yang rumit dalam menulis plugin Anda, untuk pemahaman yang lebih baik Anda dapat melihat kode plugin lain. </p><br><p>  Ada langkah ketiga - Anda dapat menempatkan kode tidak di <code>buildSrc</code> , tetapi menjadikannya proyek yang terpisah.  Kemudian, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jitpack.io</a> atau yang lainnya, publikasikan plugin dan sambungkan dengan yang lain. </p><br><h2 id="the-end">  Akhirnya </h2><br><p>  Contoh di atas mungkin termasuk kesalahan ketik dan ketidakakuratan.  Tulis dalam catatan pribadi atau tandai dengan <code>ctrl+enter</code> - Saya akan memperbaikinya.  Contoh spesifik diambil dari dokumentasi, dan lihat artikel ini sebagai sedikit daftar "cara melakukannya". </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458046/">https://habr.com/ru/post/id458046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458026/index.html">Perbandingan Format Serialisasi</a></li>
<li><a href="../id458030/index.html">JavaScript Fungsional: lima cara untuk menemukan rata-rata aritmatika elemen array dan metode .reduce ()</a></li>
<li><a href="../id458040/index.html">Dari Moskow ke Tomsk. Kisah satu langkah</a></li>
<li><a href="../id458042/index.html">Bagaimana saya mengatur pelatihan pembelajaran mesin di NSU</a></li>
<li><a href="../id458044/index.html">Keamanan informasi provinsi - stagnasi atau pembangunan?</a></li>
<li><a href="../id458048/index.html">Delegasi sebagai alat manajer</a></li>
<li><a href="../id458050/index.html">Bagaimana Piter Mobius 2019 (dan sedikit tentang Mobius berikutnya)</a></li>
<li><a href="../id458052/index.html">AMA dengan Habr. 10. Terakhir * Masalah</a></li>
<li><a href="../id458056/index.html">Wawancara besar dengan Martin Kleppmann: â€œMencari masa depan sistem data terdistribusiâ€</a></li>
<li><a href="../id458060/index.html">Membuat shader rumput di mesin Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>