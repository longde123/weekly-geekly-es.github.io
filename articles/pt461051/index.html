<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏼 🖐🏻 🔮 Os 10 erros mais comuns que encontrei nos projetos Go 🤛🏼 🏂🏼 🤹🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este post é o principal dos erros mais comuns que encontrei nos projetos Go. Ordem não importa. 



 Valor desconhecido de Enum 
 Vamos dar uma olhada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Os 10 erros mais comuns que encontrei nos projetos Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Este post é o principal dos erros mais comuns que encontrei nos projetos Go.</i></b>  Ordem não importa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="imagem"><br><br><h3>  Valor desconhecido de Enum </h3><br>  Vamos dar uma olhada em um exemplo simples: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Aqui, criamos um enumerador usando iota, o que levará a este estado: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Agora vamos imaginar que esse tipo de status faça parte da solicitação JSON que será compactada / descompactada.  Podemos projetar a seguinte estrutura: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Então obtemos este resultado da consulta: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Em geral, nada de especial - o status será descompactado no StatusOpen. <br>  Agora, vamos obter outra resposta na qual o valor do status não está definido: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  Nesse caso, o campo Status da estrutura da solicitação será inicializado como zero (para uint32 é 0).  Portanto, novamente obtemos StatusOpen em vez de StatusUnknown. <br><br>  Nesse caso, é melhor definir o valor desconhecido do enumerador primeiro - ou seja,  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Se o status não fizer parte da solicitação JSON, será inicializado em StatusUnknown, como esperamos. <br><br><h3>  Benchmarking </h3><br>  O benchmarking correto é bastante difícil.  Muitos fatores podem influenciar o resultado. <br><br>  Um erro comum está sendo enganado pelas otimizações do compilador.  Vamos ver um exemplo específico da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca teivah / bitvector</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Esta função limpa bits em um determinado intervalo.  Podemos testar o desempenho desta maneira: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  Neste teste, o compilador notará que clear não chama nenhuma outra função, portanto, simplesmente a incorpora como está.  Uma vez incorporado, o compilador verá que nenhum efeito colateral ocorre.  Assim, a chamada clara será simplesmente excluída, o que levará a resultados imprecisos. <br><br>  Uma solução pode ser definir o resultado para uma variável global, como esta: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Aqui, o compilador não saberá se a chamada cria um efeito colateral.  Portanto, a referência será precisa. <br><br><h3>  Ponteiros!  Ponteiros estão por toda parte! </h3><br>  Passar uma variável por valor criará uma cópia dessa variável.  Ao passar pelo ponteiro, basta copiar o endereço na memória. <br><br>  Conseqüentemente, passar um ponteiro sempre será mais rápido, certo? <br><br>  Se você pensa assim, dê uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste exemplo</a> .  Esta é uma referência para uma estrutura de dados de 0,3 KB que primeiro transmitimos e recebemos por ponteiro e depois por valor.  0,3 KB é um pouco - sobre as estruturas de dados comuns com as quais trabalhamos todos os dias ocupam muito disso. <br><br>  Quando executo esses testes em um ambiente local, a transmissão valor por valor é mais de 4 vezes mais rápida.  Muito inesperado, certo? <br><br>  A explicação desse resultado está relacionada ao entendimento de como o gerenciamento de memória ocorre no Go.  Não posso explicar isso de maneira tão brilhante quanto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">William Kennedy</a> , mas vamos tentar resumir em poucas palavras. <br><br>  Uma variável pode ser colocada na pilha ou pilha: <br><ul><li>  A pilha contém as variáveis ​​atuais deste programa.  Assim que a função retornar, as variáveis ​​serão salvas da pilha. </li><li>  O heap contém variáveis ​​comuns (variáveis ​​globais, etc.). </li></ul><br>  Vejamos um exemplo simples em que retornamos um valor: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Aqui a variável resultante é criada pela goroutine atual.  Esta variável é enviada para a pilha atual.  Assim que a função retornar, o cliente receberá uma cópia dessa variável.  A variável em si é removida da pilha.  Ele ainda existe na memória até que outra variável seja substituída, mas não pode mais ser acessada. <br>  Agora o mesmo exemplo, mas com um ponteiro: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  A variável resultante ainda é criada pela goroutine atual, mas o cliente receberá um ponteiro (uma cópia do endereço da variável).  Se a variável de resultado foi removida da pilha, o cliente desta função não poderá acessá-la. <br><br>  Nesse cenário, o compilador Go exibirá a variável de resultado para onde as variáveis ​​podem ser compartilhadas, ou seja,  em um monte. <br><br>  Outro script para passar ponteiros: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Como chamamos f no mesmo programa, a variável p não precisa ser empilhada.  É simplesmente empurrado para a pilha e uma subfunção pode acessá-la. <br><br>  Por exemplo, dessa maneira, uma fatia é obtida no método Read do io.Reader.  Retornar uma fatia (que é um ponteiro) coloca-a em uma pilha. <br><br>  Por que a pilha é tão rápida?  Existem dois motivos: <br><ul><li>  Não é necessário usar o coletor de lixo na pilha.  Como já dissemos, uma variável é simplesmente pressionada após ser criada e, em seguida, removida da pilha quando a função retorna.  Não é necessário agitar um processo complicado para retornar variáveis ​​não utilizadas, etc. </li><li>  A pilha pertence a uma goroutine; portanto, o armazenamento da variável não precisa ser sincronizado, como acontece com o armazenamento no heap, o que também leva a um aumento no desempenho. </li></ul><br>  Concluindo, quando criamos uma função, nossa ação padrão deve ser usar valores em vez de ponteiros.  Um ponteiro só deve ser usado se quisermos compartilhar uma variável. <br><br>  Além disso, se sofrermos de problemas de desempenho, uma das possíveis otimizações é verificar se os indicadores ajudam em situações específicas?  Se o compilador gera uma variável para o heap pode ser encontrado com o seguinte comando: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Mas, novamente, para a maioria de nossas tarefas diárias, é melhor usar valores. <br><br><h3>  Interrompendo / alternar ou selecionar / </h3><br>  O que acontece no exemplo a seguir se f retornar verdadeiro? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  Nós chamamos de pausa.  Somente essa interrupção interrompe o interruptor, não o loop for. <br><br>  O mesmo problema aqui: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  A quebra está associada a uma instrução select, não a um loop for. <br><br>  Uma solução possível para interromper / alternar ou selecionar / é usar um rótulo: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Tratamento de erros </h3><br>  Go ainda é jovem, especialmente na área de tratamento de erros.  Superar essa falha é uma das inovações mais esperadas no Go 2. <br><br>  A biblioteca padrão atual (anterior ao Go 1.13) oferece apenas funções para construir erros.  Portanto, será interessante dar uma olhada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>pacote pkg / errors</i></a> . <br><br>  Esta biblioteca é uma boa maneira de seguir uma regra que nem sempre é respeitada: <br><blockquote>  O erro deve ser processado apenas uma vez.  O registro de erros é o tratamento de erros </blockquote>  .  Assim, o erro deve ser registrado ou lançado mais alto. <br><br>  Na biblioteca padrão atual, esse princípio é difícil de observar, pois podemos adicionar contexto ao erro e ter algum tipo de hierarquia. <br><br>  Vejamos um exemplo com uma chamada REST que leva a um erro no banco de dados: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Se usarmos pkg / errors, podemos fazer o seguinte: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  O erro inicial (se não for retornado pela biblioteca externa) pode ser criado usando errors.New.  A camada do meio, inserção, envolve esse erro, adicionando mais contexto a ele.  Em seguida, o pai registra.  Assim, cada nível retorna ou processa um erro. <br><br>  Também podemos querer encontrar a causa do erro, por exemplo, para retornar a ligação.  Suponha que tenhamos um pacote db de uma biblioteca externa que tenha acesso a um banco de dados.  Esta biblioteca pode retornar um erro temporário chamado db.DBError.  Para determinar se precisamos tentar novamente, devemos estabelecer a causa do erro: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Isso é feito usando errors.Cause, que também está incluído no <i>pkg / errors</i> : <br><br>  Um dos erros comuns que encontrei foi o uso de <i>pkg / errors</i> apenas parcialmente.  Uma verificação de erro, por exemplo, foi realizada da seguinte maneira: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  Neste exemplo, se o db.DBError estiver quebrado, ele nunca fará uma segunda chamada. <br><br><h3>  Inicialização de fatia </h3><br>  Às vezes, sabemos qual será o comprimento final da fatia.  Por exemplo, suponha que desejamos converter uma fatia de Foo em uma fatia de barra, o que significa que essas duas fatias terão o mesmo comprimento. <br><br>  Costumo encontrar fatias inicializadas desta maneira: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Fatia não é uma estrutura mágica.  Sob o capô, ele implementa uma estratégia para aumentar o tamanho se não houver mais espaço livre.  Nesse caso, uma nova matriz é criada automaticamente (com uma capacidade maior) e todos os elementos são copiados para ela. <br><br>  Agora vamos imaginar que precisamos repetir essa operação para aumentar o tamanho várias vezes, pois nosso [] Foo contém milhares de elementos.  A complexidade do algoritmo de inserção permanecerá O (1), mas na prática isso afetará o desempenho. <br><br>  Portanto, se sabemos o comprimento final, podemos: <br><br><ul><li>  Inicialize-o com um comprimento predefinido: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  Ou inicialize-o com um comprimento de 0 e uma capacidade predeterminada: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  Qual é a melhor opção?  O primeiro é um pouco mais rápido.  No entanto, você pode preferir o último porque é mais consistente: independentemente de sabermos o tamanho inicial, a adição de um elemento no final da fatia é feita usando o acréscimo. <br><br><h3>  Gerenciamento de contexto </h3><br>  context.Context geralmente é mal interpretado pelos desenvolvedores.  De acordo com a documentação oficial: <br><blockquote>  O contexto transporta o prazo final, o sinal de cancelamento e outros valores através dos limites da API. <br>  Esta descrição é bastante geral, portanto, pode confundir o programador como usá-lo corretamente. </blockquote><br>  Vamos tentar descobrir.  O contexto pode conter: <br><ul><li>  Prazo - significa a duração (por exemplo, 250 ms) ou a data e hora (por exemplo, 08-01-2019 01:00:00), segundo a qual acreditamos que, se for atingida, a ação atual deverá ser cancelada (solicitação de E / S ), aguardando a entrada do canal etc.). </li><li>  Cancele o sinal (basicamente &lt;-chan struct {}).  Aqui o comportamento é semelhante.  Assim que recebermos um sinal, devemos parar o trabalho atual.  Por exemplo, digamos que recebemos dois pedidos.  Um para inserir dados e o outro para cancelar a primeira solicitação (porque não é mais relevante, por exemplo).  Isso pode ser conseguido usando o contexto cancelado na primeira chamada, que será cancelada assim que recebermos a segunda solicitação. </li><li>  Lista de chave / valor (ambos baseados no tipo de interface {}). </li></ul><br>  Mais dois pontos.  Primeiro, o contexto é compostável.  Portanto, podemos ter um contexto que contenha o prazo e a lista de chave / valor, por exemplo.  Além disso, várias goroutines podem compartilhar o mesmo contexto, portanto, um sinal de cancelamento pode potencialmente interromper vários trabalhos. <br><br>  Voltando ao nosso tópico, aqui está um erro que eu encontrei. <br><br>  O aplicativo Go foi baseado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>urfave / cli</i></a> (se você não souber, é uma boa biblioteca para criar aplicativos de linha de comando no Go).  Uma vez iniciado, o desenvolvedor herda um tipo de contexto de aplicativo.  Isso significa que, quando o aplicativo for parado, a biblioteca usará o contexto para enviar um sinal de cancelamento. <br><br>  Percebi que esse contexto foi transmitido diretamente, por exemplo, quando um ponto final de gRPC foi chamado.  Não é disso que precisamos. <br><br>  Em vez disso, queremos informar à biblioteca gRPC: cancele a solicitação quando o aplicativo for parado ou após 100 ms, por exemplo. <br><br>  Para conseguir isso, podemos simplesmente criar um contexto composto.  Se pai é o nome do contexto do aplicativo (criado por <i>urfave / cli</i> ), podemos simplesmente fazer isso: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Os contextos não são tão difíceis de entender e, na minha opinião, esse é um dos melhores recursos da linguagem. <br><br><h3>  Não está usando a opção -race </h3><br>  Testar um aplicativo Go sem a opção -race é um bug que eu sempre encontro. <br><br>  Conforme escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> , embora o Go tenha sido " <i>projetado para tornar a programação paralela mais simples e menos propensa a erros</i> ", ainda sofremos muito com problemas de simultaneidade. <br><br>  Obviamente, o detector de corrida Go não ajudará em nenhum problema.  No entanto, é uma ferramenta valiosa, e devemos sempre incluí-la ao testar nossos aplicativos. <br><br><h3>  Usando o nome do arquivo como entrada </h3><br>  Outro erro comum é passar o nome do arquivo para uma função. <br><br>  Suponha que precisamos implementar uma função para contar o número de linhas vazias em um arquivo.  A implementação mais natural seria algo como isto: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  O nome do arquivo é definido como uma entrada; portanto, abrimos e implementamos nossa lógica, certo? <br><br>  Agora, suponha que desejamos cobrir essa função com testes de unidade.  Testaremos com um arquivo comum, um arquivo vazio, um arquivo com um tipo diferente de codificação, etc. Pode ser muito difícil gerenciá-lo. <br><br>  Além disso, se quisermos implementar a mesma lógica, por exemplo, para o corpo HTTP, precisaremos criar outra função para isso. <br><br>  Go vem com duas grandes abstrações: io.Reader e io.Writer.  Em vez de passar o nome do arquivo, podemos simplesmente passar io.Reader, que abstrairá a fonte de dados. <br>  Isso é um arquivo?  Corpo HTTP?  Buffer de bytes?  Não importa, pois ainda usaremos o mesmo método de leitura. <br><br>  No nosso caso, podemos até armazenar em buffer a entrada para lê-la linha por linha.  Para fazer isso, você pode usar o bufio.Reader e seu método ReadLine: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  Agora, a responsabilidade de abrir o arquivo foi delegada ao cliente de contagem: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  Em uma segunda implementação, uma função pode ser chamada independentemente da fonte de dados real.  Enquanto isso, isso facilitará nossos testes de unidade, pois podemos simplesmente criar o bufio.Reader a partir da linha: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutines e variáveis ​​de ciclo </h3><br>  O último erro comum que encontrei foi ao usar goroutines com variáveis ​​de loop. <br><br>  Qual será a conclusão do exemplo a seguir? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 aleatoriamente?  Não. <br><br>  Neste exemplo, cada goroutine usa a mesma instância de uma variável e, portanto, gera 3 3 3 (provavelmente). <br><br>  Existem duas soluções para esse problema.  O primeiro é passar o valor da variável i para o fechamento (função interna): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  O segundo é criar outra variável dentro do loop for: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Atribuir i: = i pode parecer um pouco estranho, mas esse design é perfeitamente válido.  Estar em loop significa estar em um escopo diferente.  Portanto, i: = i cria outra instância da variável i.  Claro, podemos chamá-lo com um nome diferente para facilitar a leitura. <br><br>  <i>Se você conhece outros erros comuns, sinta-se à vontade para escrever sobre eles nos comentários.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461051/">https://habr.com/ru/post/pt461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461041/index.html">Arredondado ou com ângulo agudo?</a></li>
<li><a href="../pt461043/index.html">Gerenciamento de conflitos em um ato de equilíbrio de equipe ou uma necessidade vital?</a></li>
<li><a href="../pt461045/index.html">Obtenha uma extração do Rosreestr através do FSIS USRN e python. Parte 1</a></li>
<li><a href="../pt461047/index.html">Escrever ou não escrever. Cartas às autoridades durante os eventos</a></li>
<li><a href="../pt461049/index.html">ONYX BOOX Faust - Quem procura não é obrigado a passear</a></li>
<li><a href="../pt461053/index.html">Conectamos mapas on-line ao navegador no smartphone. Parte 2 - cartões de vetor</a></li>
<li><a href="../pt461055/index.html">Rekko Challenge 2019: como foi</a></li>
<li><a href="../pt461057/index.html">Canais de telegrama sobre desenvolvimento de jogos</a></li>
<li><a href="../pt461059/index.html">Escrevendo um aplicativo Android para fãs de filmes - Parte 1 (prototipagem)</a></li>
<li><a href="../pt461061/index.html">Ligas de magnésio, limites duplos e segregação</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>