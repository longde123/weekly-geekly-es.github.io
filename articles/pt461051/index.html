<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèº üñêüèª üîÆ Os 10 erros mais comuns que encontrei nos projetos Go ü§õüèº üèÇüèº ü§πüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este post √© o principal dos erros mais comuns que encontrei nos projetos Go. Ordem n√£o importa. 



 Valor desconhecido de Enum 
 Vamos dar uma olhada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Os 10 erros mais comuns que encontrei nos projetos Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Este post √© o principal dos erros mais comuns que encontrei nos projetos Go.</i></b>  Ordem n√£o importa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="imagem"><br><br><h3>  Valor desconhecido de Enum </h3><br>  Vamos dar uma olhada em um exemplo simples: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Aqui, criamos um enumerador usando iota, o que levar√° a este estado: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Agora vamos imaginar que esse tipo de status fa√ßa parte da solicita√ß√£o JSON que ser√° compactada / descompactada.  Podemos projetar a seguinte estrutura: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Ent√£o obtemos este resultado da consulta: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Em geral, nada de especial - o status ser√° descompactado no StatusOpen. <br>  Agora, vamos obter outra resposta na qual o valor do status n√£o est√° definido: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  Nesse caso, o campo Status da estrutura da solicita√ß√£o ser√° inicializado como zero (para uint32 √© 0).  Portanto, novamente obtemos StatusOpen em vez de StatusUnknown. <br><br>  Nesse caso, √© melhor definir o valor desconhecido do enumerador primeiro - ou seja,  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Se o status n√£o fizer parte da solicita√ß√£o JSON, ser√° inicializado em StatusUnknown, como esperamos. <br><br><h3>  Benchmarking </h3><br>  O benchmarking correto √© bastante dif√≠cil.  Muitos fatores podem influenciar o resultado. <br><br>  Um erro comum est√° sendo enganado pelas otimiza√ß√µes do compilador.  Vamos ver um exemplo espec√≠fico da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca teivah / bitvector</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Esta fun√ß√£o limpa bits em um determinado intervalo.  Podemos testar o desempenho desta maneira: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  Neste teste, o compilador notar√° que clear n√£o chama nenhuma outra fun√ß√£o, portanto, simplesmente a incorpora como est√°.  Uma vez incorporado, o compilador ver√° que nenhum efeito colateral ocorre.  Assim, a chamada clara ser√° simplesmente exclu√≠da, o que levar√° a resultados imprecisos. <br><br>  Uma solu√ß√£o pode ser definir o resultado para uma vari√°vel global, como esta: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Aqui, o compilador n√£o saber√° se a chamada cria um efeito colateral.  Portanto, a refer√™ncia ser√° precisa. <br><br><h3>  Ponteiros!  Ponteiros est√£o por toda parte! </h3><br>  Passar uma vari√°vel por valor criar√° uma c√≥pia dessa vari√°vel.  Ao passar pelo ponteiro, basta copiar o endere√ßo na mem√≥ria. <br><br>  Conseq√ºentemente, passar um ponteiro sempre ser√° mais r√°pido, certo? <br><br>  Se voc√™ pensa assim, d√™ uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste exemplo</a> .  Esta √© uma refer√™ncia para uma estrutura de dados de 0,3 KB que primeiro transmitimos e recebemos por ponteiro e depois por valor.  0,3 KB √© um pouco - sobre as estruturas de dados comuns com as quais trabalhamos todos os dias ocupam muito disso. <br><br>  Quando executo esses testes em um ambiente local, a transmiss√£o valor por valor √© mais de 4 vezes mais r√°pida.  Muito inesperado, certo? <br><br>  A explica√ß√£o desse resultado est√° relacionada ao entendimento de como o gerenciamento de mem√≥ria ocorre no Go.  N√£o posso explicar isso de maneira t√£o brilhante quanto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">William Kennedy</a> , mas vamos tentar resumir em poucas palavras. <br><br>  Uma vari√°vel pode ser colocada na pilha ou pilha: <br><ul><li>  A pilha cont√©m as vari√°veis ‚Äã‚Äãatuais deste programa.  Assim que a fun√ß√£o retornar, as vari√°veis ‚Äã‚Äãser√£o salvas da pilha. </li><li>  O heap cont√©m vari√°veis ‚Äã‚Äãcomuns (vari√°veis ‚Äã‚Äãglobais, etc.). </li></ul><br>  Vejamos um exemplo simples em que retornamos um valor: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Aqui a vari√°vel resultante √© criada pela goroutine atual.  Esta vari√°vel √© enviada para a pilha atual.  Assim que a fun√ß√£o retornar, o cliente receber√° uma c√≥pia dessa vari√°vel.  A vari√°vel em si √© removida da pilha.  Ele ainda existe na mem√≥ria at√© que outra vari√°vel seja substitu√≠da, mas n√£o pode mais ser acessada. <br>  Agora o mesmo exemplo, mas com um ponteiro: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  A vari√°vel resultante ainda √© criada pela goroutine atual, mas o cliente receber√° um ponteiro (uma c√≥pia do endere√ßo da vari√°vel).  Se a vari√°vel de resultado foi removida da pilha, o cliente desta fun√ß√£o n√£o poder√° acess√°-la. <br><br>  Nesse cen√°rio, o compilador Go exibir√° a vari√°vel de resultado para onde as vari√°veis ‚Äã‚Äãpodem ser compartilhadas, ou seja,  em um monte. <br><br>  Outro script para passar ponteiros: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Como chamamos f no mesmo programa, a vari√°vel p n√£o precisa ser empilhada.  √â simplesmente empurrado para a pilha e uma subfun√ß√£o pode acess√°-la. <br><br>  Por exemplo, dessa maneira, uma fatia √© obtida no m√©todo Read do io.Reader.  Retornar uma fatia (que √© um ponteiro) coloca-a em uma pilha. <br><br>  Por que a pilha √© t√£o r√°pida?  Existem dois motivos: <br><ul><li>  N√£o √© necess√°rio usar o coletor de lixo na pilha.  Como j√° dissemos, uma vari√°vel √© simplesmente pressionada ap√≥s ser criada e, em seguida, removida da pilha quando a fun√ß√£o retorna.  N√£o √© necess√°rio agitar um processo complicado para retornar vari√°veis ‚Äã‚Äãn√£o utilizadas, etc. </li><li>  A pilha pertence a uma goroutine; portanto, o armazenamento da vari√°vel n√£o precisa ser sincronizado, como acontece com o armazenamento no heap, o que tamb√©m leva a um aumento no desempenho. </li></ul><br>  Concluindo, quando criamos uma fun√ß√£o, nossa a√ß√£o padr√£o deve ser usar valores em vez de ponteiros.  Um ponteiro s√≥ deve ser usado se quisermos compartilhar uma vari√°vel. <br><br>  Al√©m disso, se sofrermos de problemas de desempenho, uma das poss√≠veis otimiza√ß√µes √© verificar se os indicadores ajudam em situa√ß√µes espec√≠ficas?  Se o compilador gera uma vari√°vel para o heap pode ser encontrado com o seguinte comando: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Mas, novamente, para a maioria de nossas tarefas di√°rias, √© melhor usar valores. <br><br><h3>  Interrompendo / alternar ou selecionar / </h3><br>  O que acontece no exemplo a seguir se f retornar verdadeiro? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  N√≥s chamamos de pausa.  Somente essa interrup√ß√£o interrompe o interruptor, n√£o o loop for. <br><br>  O mesmo problema aqui: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  A quebra est√° associada a uma instru√ß√£o select, n√£o a um loop for. <br><br>  Uma solu√ß√£o poss√≠vel para interromper / alternar ou selecionar / √© usar um r√≥tulo: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Tratamento de erros </h3><br>  Go ainda √© jovem, especialmente na √°rea de tratamento de erros.  Superar essa falha √© uma das inova√ß√µes mais esperadas no Go 2. <br><br>  A biblioteca padr√£o atual (anterior ao Go 1.13) oferece apenas fun√ß√µes para construir erros.  Portanto, ser√° interessante dar uma olhada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>pacote pkg / errors</i></a> . <br><br>  Esta biblioteca √© uma boa maneira de seguir uma regra que nem sempre √© respeitada: <br><blockquote>  O erro deve ser processado apenas uma vez.  O registro de erros √© o tratamento de erros </blockquote>  .  Assim, o erro deve ser registrado ou lan√ßado mais alto. <br><br>  Na biblioteca padr√£o atual, esse princ√≠pio √© dif√≠cil de observar, pois podemos adicionar contexto ao erro e ter algum tipo de hierarquia. <br><br>  Vejamos um exemplo com uma chamada REST que leva a um erro no banco de dados: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Se usarmos pkg / errors, podemos fazer o seguinte: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  O erro inicial (se n√£o for retornado pela biblioteca externa) pode ser criado usando errors.New.  A camada do meio, inser√ß√£o, envolve esse erro, adicionando mais contexto a ele.  Em seguida, o pai registra.  Assim, cada n√≠vel retorna ou processa um erro. <br><br>  Tamb√©m podemos querer encontrar a causa do erro, por exemplo, para retornar a liga√ß√£o.  Suponha que tenhamos um pacote db de uma biblioteca externa que tenha acesso a um banco de dados.  Esta biblioteca pode retornar um erro tempor√°rio chamado db.DBError.  Para determinar se precisamos tentar novamente, devemos estabelecer a causa do erro: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Isso √© feito usando errors.Cause, que tamb√©m est√° inclu√≠do no <i>pkg / errors</i> : <br><br>  Um dos erros comuns que encontrei foi o uso de <i>pkg / errors</i> apenas parcialmente.  Uma verifica√ß√£o de erro, por exemplo, foi realizada da seguinte maneira: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  Neste exemplo, se o db.DBError estiver quebrado, ele nunca far√° uma segunda chamada. <br><br><h3>  Inicializa√ß√£o de fatia </h3><br>  √Äs vezes, sabemos qual ser√° o comprimento final da fatia.  Por exemplo, suponha que desejamos converter uma fatia de Foo em uma fatia de barra, o que significa que essas duas fatias ter√£o o mesmo comprimento. <br><br>  Costumo encontrar fatias inicializadas desta maneira: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Fatia n√£o √© uma estrutura m√°gica.  Sob o cap√¥, ele implementa uma estrat√©gia para aumentar o tamanho se n√£o houver mais espa√ßo livre.  Nesse caso, uma nova matriz √© criada automaticamente (com uma capacidade maior) e todos os elementos s√£o copiados para ela. <br><br>  Agora vamos imaginar que precisamos repetir essa opera√ß√£o para aumentar o tamanho v√°rias vezes, pois nosso [] Foo cont√©m milhares de elementos.  A complexidade do algoritmo de inser√ß√£o permanecer√° O (1), mas na pr√°tica isso afetar√° o desempenho. <br><br>  Portanto, se sabemos o comprimento final, podemos: <br><br><ul><li>  Inicialize-o com um comprimento predefinido: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  Ou inicialize-o com um comprimento de 0 e uma capacidade predeterminada: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  Qual √© a melhor op√ß√£o?  O primeiro √© um pouco mais r√°pido.  No entanto, voc√™ pode preferir o √∫ltimo porque √© mais consistente: independentemente de sabermos o tamanho inicial, a adi√ß√£o de um elemento no final da fatia √© feita usando o acr√©scimo. <br><br><h3>  Gerenciamento de contexto </h3><br>  context.Context geralmente √© mal interpretado pelos desenvolvedores.  De acordo com a documenta√ß√£o oficial: <br><blockquote>  O contexto transporta o prazo final, o sinal de cancelamento e outros valores atrav√©s dos limites da API. <br>  Esta descri√ß√£o √© bastante geral, portanto, pode confundir o programador como us√°-lo corretamente. </blockquote><br>  Vamos tentar descobrir.  O contexto pode conter: <br><ul><li>  Prazo - significa a dura√ß√£o (por exemplo, 250 ms) ou a data e hora (por exemplo, 08-01-2019 01:00:00), segundo a qual acreditamos que, se for atingida, a a√ß√£o atual dever√° ser cancelada (solicita√ß√£o de E / S ), aguardando a entrada do canal etc.). </li><li>  Cancele o sinal (basicamente &lt;-chan struct {}).  Aqui o comportamento √© semelhante.  Assim que recebermos um sinal, devemos parar o trabalho atual.  Por exemplo, digamos que recebemos dois pedidos.  Um para inserir dados e o outro para cancelar a primeira solicita√ß√£o (porque n√£o √© mais relevante, por exemplo).  Isso pode ser conseguido usando o contexto cancelado na primeira chamada, que ser√° cancelada assim que recebermos a segunda solicita√ß√£o. </li><li>  Lista de chave / valor (ambos baseados no tipo de interface {}). </li></ul><br>  Mais dois pontos.  Primeiro, o contexto √© compost√°vel.  Portanto, podemos ter um contexto que contenha o prazo e a lista de chave / valor, por exemplo.  Al√©m disso, v√°rias goroutines podem compartilhar o mesmo contexto, portanto, um sinal de cancelamento pode potencialmente interromper v√°rios trabalhos. <br><br>  Voltando ao nosso t√≥pico, aqui est√° um erro que eu encontrei. <br><br>  O aplicativo Go foi baseado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>urfave / cli</i></a> (se voc√™ n√£o souber, √© uma boa biblioteca para criar aplicativos de linha de comando no Go).  Uma vez iniciado, o desenvolvedor herda um tipo de contexto de aplicativo.  Isso significa que, quando o aplicativo for parado, a biblioteca usar√° o contexto para enviar um sinal de cancelamento. <br><br>  Percebi que esse contexto foi transmitido diretamente, por exemplo, quando um ponto final de gRPC foi chamado.  N√£o √© disso que precisamos. <br><br>  Em vez disso, queremos informar √† biblioteca gRPC: cancele a solicita√ß√£o quando o aplicativo for parado ou ap√≥s 100 ms, por exemplo. <br><br>  Para conseguir isso, podemos simplesmente criar um contexto composto.  Se pai √© o nome do contexto do aplicativo (criado por <i>urfave / cli</i> ), podemos simplesmente fazer isso: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Os contextos n√£o s√£o t√£o dif√≠ceis de entender e, na minha opini√£o, esse √© um dos melhores recursos da linguagem. <br><br><h3>  N√£o est√° usando a op√ß√£o -race </h3><br>  Testar um aplicativo Go sem a op√ß√£o -race √© um bug que eu sempre encontro. <br><br>  Conforme escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> , embora o Go tenha sido " <i>projetado para tornar a programa√ß√£o paralela mais simples e menos propensa a erros</i> ", ainda sofremos muito com problemas de simultaneidade. <br><br>  Obviamente, o detector de corrida Go n√£o ajudar√° em nenhum problema.  No entanto, √© uma ferramenta valiosa, e devemos sempre inclu√≠-la ao testar nossos aplicativos. <br><br><h3>  Usando o nome do arquivo como entrada </h3><br>  Outro erro comum √© passar o nome do arquivo para uma fun√ß√£o. <br><br>  Suponha que precisamos implementar uma fun√ß√£o para contar o n√∫mero de linhas vazias em um arquivo.  A implementa√ß√£o mais natural seria algo como isto: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  O nome do arquivo √© definido como uma entrada; portanto, abrimos e implementamos nossa l√≥gica, certo? <br><br>  Agora, suponha que desejamos cobrir essa fun√ß√£o com testes de unidade.  Testaremos com um arquivo comum, um arquivo vazio, um arquivo com um tipo diferente de codifica√ß√£o, etc. Pode ser muito dif√≠cil gerenci√°-lo. <br><br>  Al√©m disso, se quisermos implementar a mesma l√≥gica, por exemplo, para o corpo HTTP, precisaremos criar outra fun√ß√£o para isso. <br><br>  Go vem com duas grandes abstra√ß√µes: io.Reader e io.Writer.  Em vez de passar o nome do arquivo, podemos simplesmente passar io.Reader, que abstrair√° a fonte de dados. <br>  Isso √© um arquivo?  Corpo HTTP?  Buffer de bytes?  N√£o importa, pois ainda usaremos o mesmo m√©todo de leitura. <br><br>  No nosso caso, podemos at√© armazenar em buffer a entrada para l√™-la linha por linha.  Para fazer isso, voc√™ pode usar o bufio.Reader e seu m√©todo ReadLine: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  Agora, a responsabilidade de abrir o arquivo foi delegada ao cliente de contagem: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  Em uma segunda implementa√ß√£o, uma fun√ß√£o pode ser chamada independentemente da fonte de dados real.  Enquanto isso, isso facilitar√° nossos testes de unidade, pois podemos simplesmente criar o bufio.Reader a partir da linha: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutines e vari√°veis ‚Äã‚Äãde ciclo </h3><br>  O √∫ltimo erro comum que encontrei foi ao usar goroutines com vari√°veis ‚Äã‚Äãde loop. <br><br>  Qual ser√° a conclus√£o do exemplo a seguir? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 aleatoriamente?  N√£o. <br><br>  Neste exemplo, cada goroutine usa a mesma inst√¢ncia de uma vari√°vel e, portanto, gera 3 3 3 (provavelmente). <br><br>  Existem duas solu√ß√µes para esse problema.  O primeiro √© passar o valor da vari√°vel i para o fechamento (fun√ß√£o interna): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  O segundo √© criar outra vari√°vel dentro do loop for: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Atribuir i: = i pode parecer um pouco estranho, mas esse design √© perfeitamente v√°lido.  Estar em loop significa estar em um escopo diferente.  Portanto, i: = i cria outra inst√¢ncia da vari√°vel i.  Claro, podemos cham√°-lo com um nome diferente para facilitar a leitura. <br><br>  <i>Se voc√™ conhece outros erros comuns, sinta-se √† vontade para escrever sobre eles nos coment√°rios.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461051/">https://habr.com/ru/post/pt461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461041/index.html">Arredondado ou com √¢ngulo agudo?</a></li>
<li><a href="../pt461043/index.html">Gerenciamento de conflitos em um ato de equil√≠brio de equipe ou uma necessidade vital?</a></li>
<li><a href="../pt461045/index.html">Obtenha uma extra√ß√£o do Rosreestr atrav√©s do FSIS USRN e python. Parte 1</a></li>
<li><a href="../pt461047/index.html">Escrever ou n√£o escrever. Cartas √†s autoridades durante os eventos</a></li>
<li><a href="../pt461049/index.html">ONYX BOOX Faust - Quem procura n√£o √© obrigado a passear</a></li>
<li><a href="../pt461053/index.html">Conectamos mapas on-line ao navegador no smartphone. Parte 2 - cart√µes de vetor</a></li>
<li><a href="../pt461055/index.html">Rekko Challenge 2019: como foi</a></li>
<li><a href="../pt461057/index.html">Canais de telegrama sobre desenvolvimento de jogos</a></li>
<li><a href="../pt461059/index.html">Escrevendo um aplicativo Android para f√£s de filmes - Parte 1 (prototipagem)</a></li>
<li><a href="../pt461061/index.html">Ligas de magn√©sio, limites duplos e segrega√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>