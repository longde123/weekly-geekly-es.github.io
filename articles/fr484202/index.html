<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî§ üêù ü§≥üèª Apprentissage automatique dans l'analyse statique du code source du programme üõ¨ üöá üíÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'apprentissage automatique est solidement ancr√© dans une vari√©t√© de domaines humains, de la reconnaissance vocale au diagnostic m√©dical. La popularit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprentissage automatique dans l'analyse statique du code source du programme</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484202/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Apprentissage automatique dans l'analyse statique du code source du programme"></div><br>  L'apprentissage automatique est solidement ancr√© dans une vari√©t√© de domaines humains, de la reconnaissance vocale au diagnostic m√©dical.  La popularit√© de cette approche est si grande que les gens essaient de l'utiliser partout o√π ils le peuvent.  Certaines tentatives pour remplacer les approches classiques par des r√©seaux de neurones √©chouent.  Cette fois, nous consid√©rerons l'apprentissage automatique en termes de cr√©ation d'analyseurs de code statique efficaces pour trouver des bogues et des vuln√©rabilit√©s potentielles. <br><a name="habracut"></a><br>  On demande souvent √† l'√©quipe PVS-Studio si nous voulons commencer √† utiliser l'apprentissage automatique pour trouver des bogues dans le code source du logiciel.  La r√©ponse courte est oui, mais dans une mesure limit√©e.  Nous pensons qu'avec l'apprentissage automatique, de nombreux pi√®ges se cachent dans les t√¢ches d'analyse de code.  Dans la deuxi√®me partie de l'article, nous en parlerons.  Commen√ßons par un examen des nouvelles solutions et id√©es. <br><br><h2>  De nouvelles approches </h2><br>  De nos jours, il existe de nombreux analyseurs statiques bas√©s sur ou utilisant l'apprentissage automatique, y compris l'apprentissage en profondeur et la PNL pour la d√©tection des erreurs.  Non seulement les amateurs ont doubl√© le potentiel d'apprentissage automatique, mais aussi les grandes entreprises, par exemple, Facebook, Amazon ou Mozilla.  Certains projets ne sont pas des analyseurs statiques √† part enti√®re, car ils ne trouvent que certaines erreurs dans les validations. <br><br>  Fait int√©ressant, presque tous sont positionn√©s comme des produits r√©volutionnaires qui feront une perc√©e dans le processus de d√©veloppement gr√¢ce √† l'intelligence artificielle. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br><br>  Regardons quelques-uns des exemples bien connus: <br><br><ol><li>  Deepcode </li><li>  Infer, Sapienz, SapFix </li><li>  Enhardir </li><li>  Source {d} </li><li>  Clever-Commit, Commit Assistant </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code est un outil de recherche de vuln√©rabilit√©s pour le code logiciel Java, JavaScript, TypeScript et Python qui comprend l'apprentissage automatique en tant que composant.  Selon Boris Paskalev, plus de 250 000 r√®gles sont d√©j√† en place.  Cet outil apprend des modifications apport√©es par les d√©veloppeurs dans le code source des projets open source (un million de r√©f√©rentiels).  La soci√©t√© elle-m√™me dit que leur projet est une sorte de grammaire pour les d√©veloppeurs. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  En fait, cet analyseur compare votre solution avec sa base de projets et vous offre la meilleure solution pr√©vue √† partir de l'exp√©rience d'autres d√©veloppeurs. <br><br>  En mai 2018, les d√©veloppeurs ont d√©clar√© que la prise en charge de C ++ √©tait en cours, mais jusqu'√† pr√©sent, ce langage n'est pas pris en charge.  Bien que, comme indiqu√© sur le site, le nouveau support de langue puisse √™tre ajout√© en quelques semaines en raison du fait que la langue ne d√©pend que d'une √©tape, qui est l'analyse. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Une s√©rie d'articles sur les m√©thodes de base de l'analyseur est √©galement disponible sur le site. <br><br><h3>  Inf√©rer </h3><br>  Facebook est assez z√©l√© dans ses tentatives d'introduire de nouvelles approches compl√®tes dans ses produits.  L'apprentissage automatique n'est pas rest√© √† l'√©cart non plus.  En 2013, ils ont achet√© une startup qui a d√©velopp√© un analyseur statique bas√© sur l'apprentissage automatique.  Et en 2015, le code source du projet <a href="https://github.com/facebook/infer">est devenu ouvert</a> . <br><br>  Infer est un analyseur statique pour les projets en Java, C, C ++ et Objective-C, d√©velopp√© par Facebook.  Selon le site, il est √©galement utilis√© dans Amazon Web Services, Oculus, Uber et d'autres projets populaires. <br><br>  Actuellement, Infer est capable de trouver des erreurs li√©es au d√©r√©f√©rencement de pointeur nul et aux fuites de m√©moire.  Infer est bas√© sur la logique de Hoare, la logique de s√©paration et la bi-abduction, ainsi que sur la th√©orie de l'interpr√©tation abstraite.  L'utilisation de ces approches permet √† l'analyseur de diviser le programme en morceaux et de les analyser ind√©pendamment. <br><br>  Vous pouvez essayer d'utiliser Infer sur vos projets, mais les d√©veloppeurs avertissent que m√™me si les projets Facebook g√©n√®rent environ 80% des avertissements utiles, un faible nombre de faux positifs n'est pas garanti sur les autres projets.  Voici quelques erreurs qu'Infer ne peut pas d√©tecter jusqu'√† pr√©sent, mais les d√©veloppeurs travaillent sur l'impl√©mentation de ces avertissements: <br><br><ul><li>  index de tableau hors limites; </li><li>  exceptions de transtypage de type; </li><li>  fuites de donn√©es non v√©rifi√©es; </li><li>  condition de course. </li></ul><br><h3>  Sapfix </h3><br>  SapFix est un outil d'√©dition automatis√©.  Il re√ßoit des informations de Sapienz, un outil d'automatisation des tests et de l'analyseur statique Infer.  Sur la base des modifications et des messages r√©cents, Infer s√©lectionne l'une des nombreuses strat√©gies pour corriger les bogues. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  Dans certains cas, SapFix annule toutes les modifications ou parties de celles-ci.  Dans d'autres cas, il essaie de r√©soudre le probl√®me en g√©n√©rant un correctif √† partir de son ensemble de mod√®les de correction.  Cet ensemble est form√© de mod√®les de correctifs collect√©s par les programmeurs eux-m√™mes √† partir d'un ensemble de correctifs d√©j√† effectu√©s.  Si un tel mod√®le ne corrige pas une erreur, SapFix essaie de l'ajuster √† la situation en faisant de petites modifications dans un arbre de syntaxe abstraite jusqu'√† ce que la solution potentielle soit trouv√©e. <br><br>  Mais une solution potentielle ne suffit pas, donc SapFix recueille plusieurs solutions sur la base de quelques points: s'il y a des erreurs de compilation, s'il se bloque, s'il introduit de nouveaux plantages.  Une fois les modifications enti√®rement test√©es, les correctifs sont examin√©s par un programmeur, qui d√©cidera laquelle des modifications r√©sout le mieux le probl√®me. <br><br><h3>  Enhardir </h3><br>  Embold est une plateforme de d√©marrage pour l'analyse statique du code source du logiciel qui s'appelait Gamma avant le changement de nom.  L'analyseur statique fonctionne sur la base des propres diagnostics de l'outil, ainsi qu'en utilisant des analyseurs int√©gr√©s, tels que Cppcheck, SpotBugs, SQL Check et autres. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  En plus des diagnostics eux-m√™mes, la plate-forme se concentre sur des infographies vives sur la charge de la base de code et la visualisation pratique des erreurs trouv√©es, ainsi que sur la recherche d'une √©ventuelle refactorisation.  En outre, cet analyseur poss√®de un ensemble d'anti-mod√®les qui vous permet de d√©tecter des probl√®mes dans la structure du code au niveau de la classe et de la m√©thode, et diverses mesures pour calculer la qualit√© d'un syst√®me. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  L'un des principaux avantages est le syst√®me intelligent proposant des solutions et des modifications qui, en plus des diagnostics conventionnels, v√©rifie les modifications sur la base des informations sur les modifications pr√©c√©dentes. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Avec NLP, Embold brise le code et recherche les interconnexions et les d√©pendances entre les fonctions et les m√©thodes, ce qui fait gagner du temps au refactoring. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  De cette fa√ßon, Embold offre essentiellement une visualisation pratique de vos r√©sultats d'analyse de code source par divers analyseurs, ainsi que par ses propres diagnostics, dont certains sont bas√©s sur l'apprentissage automatique. <br><br><h3>  Source {d} </h3><br>  La source {d} est l'outil le plus ouvert en termes de modes de mise en ≈ìuvre par rapport aux analyseurs que nous avons examin√©s.  C'est √©galement une <a href="https://github.com/src-d/sourced-ce">solution de code open source</a> .  Sur leur site Web, en √©change de votre adresse e-mail, vous pouvez obtenir une brochure produit d√©crivant les technologies qu'ils utilisent.  En outre, le site Web donne un <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">lien</a> vers la base de donn√©es des publications li√©es √† l'utilisation de l'apprentissage automatique pour l'analyse de code, ainsi que le <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">r√©f√©rentiel</a> avec l'ensemble de donn√©es pour l'apprentissage bas√© sur le code.  Le produit lui-m√™me est une plate-forme enti√®re pour analyser le code source et le produit logiciel, et n'est pas ax√© sur les d√©veloppeurs, mais plut√¥t sur les gestionnaires.  Parmi ses capacit√©s figurent le calcul de la taille de la dette technique, les goulets d'√©tranglement dans le processus de d√©veloppement et d'autres statistiques mondiales sur le projet. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Leur approche de l'analyse de code par apprentissage automatique est bas√©e sur l'hypoth√®se naturelle, comme indiqu√© dans l'article " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Sur le caract√®re naturel du logiciel</a> ". <br><br>  <i>"Les langages de programmation, en th√©orie, sont complexes, flexibles et puissants, mais les programmes que les vraies personnes √©crivent sont en fait simples et plut√¥t r√©p√©titifs, et ils ont donc des propri√©t√©s statistiques pr√©visibles utiles qui peuvent √™tre captur√©es dans des mod√®les de langage statistique et exploit√©es pour l'ing√©nierie logicielle. t√¢ches. "</i> <br><br>  Sur la base de cette hypoth√®se, plus la base de code est grande, plus les propri√©t√©s statistiques sont grandes et plus les m√©triques, obtenues gr√¢ce √† l'apprentissage, seront pr√©cises. <br><br>  Pour analyser le code dans la source {d}, le service Babelfish est utilis√©, qui peut analyser le fichier de code dans n'importe quelle langue disponible, obtenir un arbre de syntaxe abstrait et le convertir en un arbre de syntaxe universel. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Cependant, la source {d} ne recherche pas d'erreurs dans le code.  Sur la base de l'arborescence utilisant ML sur l'ensemble du projet, la source {d} d√©tecte la mise en forme du code, le style appliqu√© dans le projet et dans une validation.  Si le nouveau code ne correspond pas au style de code du projet, il effectue quelques modifications. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  L'apprentissage se concentre sur plusieurs √©l√©ments de base: espaces, tabulation, sauts de ligne, etc. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  En savoir plus √† ce sujet dans leur publication: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: correction des incoh√©rences de style de code avec des algorithmes interpr√©tables non supervis√©s</a> ". <br><br>  Dans l'ensemble, source {d} est une large plate-forme pour collecter diverses statistiques sur le code source et le processus de d√©veloppement de projet: des calculs d'efficacit√© des d√©veloppeurs aux co√ªts de temps pour la r√©vision du code. <br><br><h3>  Engagement intelligent </h3><br>  Clever-Commit est un analyseur cr√©√© par Mozilla en collaboration avec Ubisoft.  Il est bas√© sur une <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">√©tude CLEVER</a> (Combining Levels of Bug Prevention and Resolution Techniques) d'Ubisoft et de son produit enfant Commit Assistant, qui d√©tecte les validations suspectes susceptibles de contenir une erreur.  √âtant donn√© que CLEVER est bas√© sur une comparaison de code, il peut √† la fois pointer du code dangereux et faire des suggestions de modifications possibles.  Selon la description, dans 60 √† 70% des cas, Clever-Commit trouve les endroits probl√©matiques et propose des modifications correctes avec la m√™me probabilit√©.  En g√©n√©ral, il y a peu d'informations sur ce projet et sur les erreurs qu'il peut trouver. <br><br><h3>  CodeGuru </h3><br>  R√©cemment, CodeGuru, qui est un produit d'Amazon, s'est align√© sur les analyseurs utilisant l'apprentissage automatique.  Il s'agit d'un service d'apprentissage automatique qui vous permet de trouver des erreurs dans le code, ainsi que d'identifier des zones co√ªteuses.  Jusqu'√† pr√©sent, l'analyse n'est disponible que pour le code Java, mais les auteurs promettent de prendre en charge d'autres langages √† l'avenir.  Bien qu'il ait √©t√© annonc√© assez r√©cemment, Andy Jassy, ‚Äã‚ÄãPDG d'AWS (Amazon Web Services) dit qu'il est utilis√© depuis longtemps sur Amazon. <br><br>  Le site Web indique que CodeGuru apprenait sur la base de code Amazon, ainsi que sur plus de 10 000 projets open source. <br><br>  Fondamentalement, le service est divis√© en deux parties: CodeGuru Reviewer, enseign√© √† l'aide de la recherche de r√®gles associatives et √† la recherche d'erreurs dans le code, et CodeGuru Profiler, surveillant les performances des applications. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  En g√©n√©ral, il n'y a pas beaucoup d'informations disponibles sur ce projet.  Comme l'indique le site Web, le r√©viseur analyse les bases de code Amazon et recherche les demandes d'extraction, contenant les appels d'API AWS afin d'apprendre √† d√©tecter les √©carts par rapport aux "meilleures pratiques".  Ensuite, il examine les modifications apport√©es et les compare aux donn√©es de la documentation, qui sont analys√©es en m√™me temps.  Le r√©sultat est un mod√®le de ¬´meilleures pratiques¬ª. <br><br>  Il est √©galement dit que les recommandations pour le code de l'utilisateur ont tendance √† s'am√©liorer apr√®s avoir re√ßu des commentaires √† leur sujet. <br><br>  La liste des erreurs auxquelles Reviewer r√©pond est assez floue, car aucune documentation d'erreur sp√©cifique n'a √©t√© publi√©e: <br><br><ul><li>  Meilleures pratiques AWS </li><li>  Acc√®s simultan√© </li><li>  Fuites de ressources </li><li>  Fuite d'informations confidentielles </li><li>  "Meilleures pratiques" g√©n√©rales de codage </li></ul><br><h2>  Notre scepticisme </h2><br>  Examinons maintenant la recherche d'erreurs du point de vue de notre √©quipe, qui d√©veloppe des analyseurs statiques depuis de nombreuses ann√©es.  Nous voyons un certain nombre de probl√®mes de haut niveau d'application des m√©thodes d'apprentissage, que nous aimerions aborder.  Pour commencer, nous diviserons toutes les approches ML en deux types: <br><br><ol><li>  Ceux qui apprennent manuellement √† un analyseur statique √† rechercher divers probl√®mes, en utilisant des exemples de code synth√©tique et r√©el; </li><li>  Celles qui enseignent les algorithmes sur un grand nombre de codes open source et d'historique de r√©vision (GitHub), apr√®s quoi l'analyseur commencera √† d√©tecter les bugs et m√™me √† proposer des modifications. </li></ol><br>  Nous parlerons de chaque direction s√©par√©ment, car elles pr√©sentent des inconv√©nients diff√©rents.  Apr√®s cela, je pense que les lecteurs comprendront pourquoi nous ne nions pas les possibilit√©s de l'apprentissage automatique, mais ne partageons toujours pas l'enthousiasme. <br><br>  <b>Remarque</b>  Nous regardons du point de vue du d√©veloppement d'un analyseur universel statique universel.  Nous nous concentrons sur le d√©veloppement de l'analyseur, que toute √©quipe pourra utiliser, pas celui ax√© sur une base de code sp√©cifique. <br><br><h3>  Apprentissage manuel d'un analyseur statique </h3><br>  Disons que nous voulons utiliser ML pour commencer √† rechercher les types de d√©fauts suivants dans le code: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Il est √©trange de comparer une variable avec elle-m√™me.  Nous pouvons √©crire de nombreux exemples de code correct et incorrect et apprendre √† l'analyseur √† rechercher de telles erreurs.  De plus, vous pouvez ajouter de vrais exemples de bogues d√©j√† trouv√©s aux tests.  Eh bien, la question est de savoir o√π trouver de tels exemples.  Ok, supposons que c'est possible.  Par exemple, nous avons un certain nombre d'exemples de telles erreurs: <a href="https://www.viva64.com/en/examples/v501/">V501</a> , <a href="https://www.viva64.com/en/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/en/examples/v6001/">V6001</a> . <br><br>  Est-il donc possible d'identifier de tels d√©fauts de code en utilisant les algorithmes ML?  Oui, √ßa l'est.  La chose est - pourquoi en avons-nous besoin? <br><br>  Voyez, pour enseigner l'analyseur, nous devrons consacrer beaucoup d'efforts √† la pr√©paration des exemples pour l'enseignement.  Une autre option consiste √† marquer le code des applications r√©elles, en indiquant les fragments o√π l'analyseur doit √©mettre un avertissement.  Dans tous les cas, beaucoup de travail devra √™tre fait, car il devrait y avoir des milliers d'exemples d'apprentissage.  Ou des dizaines de milliers. <br><br>  Apr√®s tout, nous voulons d√©tecter non seulement les cas (A == A), mais aussi: <br><br><ul><li>  si (X &amp;&amp; A == A) </li><li>  si (A + 1 == A + 1) </li><li>  si (A [i] == A [i]) </li><li>  si ((A) == (A)) </li><li>  et ainsi de suite. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br>  Examinons l'impl√©mentation potentielle d'un diagnostic aussi simple dans PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">"Oh boy! Holy cow!"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Et c'est tout!  Vous n'avez besoin d'aucune base d'exemples pour ML! <br><br>  √Ä l'avenir, le diagnostic devra apprendre √† prendre en compte un certain nombre d'exceptions et √† √©mettre des avertissements pour (A [0] == A [1-1]).  Comme nous le savons, il peut √™tre facilement programm√©.  Au contraire, dans ce cas, les choses vont mal avec la base d'exemples. <br><br>  Notez que dans les deux cas, nous aurons besoin d'un syst√®me de test, de documentation, etc.  Quant √† la contribution du travail √† la cr√©ation d'un nouveau diagnostic, l'approche classique, o√π la r√®gle est rigoureusement programm√©e dans le code, prend les devants. <br><br>  Ok, il est temps pour une autre r√®gle.  Par exemple, celui o√π le r√©sultat de certaines fonctions doit √™tre utilis√©.  Il est inutile de les appeler et de ne pas utiliser leur r√©sultat.  Voici certaines de ces fonctions: <br><br><ul><li>  malloc </li><li>  memcmp </li><li>  cha√Æne :: vide </li></ul><br>  C'est ce que fait le diagnostic PVS-Studio <a href="https://www.viva64.com/en/w/v530/">V530</a> . <br><br>  Donc, ce que nous voulons, c'est d√©tecter les appels √† ces fonctions, dont le r√©sultat n'est pas utilis√©.  Pour ce faire, vous pouvez g√©n√©rer de nombreux tests.  Et nous pensons que tout fonctionnera bien.  Mais encore une fois, il n'est pas clair pourquoi cela est n√©cessaire. <br><br>  L'impl√©mentation du diagnostic V530 avec toutes les exceptions a pris 258 lignes de code dans l'analyseur PVS-Studio, dont 64 sont des commentaires.  Il y a aussi un tableau avec des annotations de fonctions, o√π il est √† noter que leur r√©sultat doit √™tre utilis√©.  Il est beaucoup plus facile de recharger ce tableau que de cr√©er des exemples synth√©tiques. <br><br>  Les choses vont encore empirer avec les diagnostics qui utilisent l'analyse du flux de donn√©es.  Par exemple, l'analyseur PVS-Studio peut suivre la valeur des pointeurs, ce qui vous permet de trouver une telle fuite de m√©moire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  L'exemple est tir√© de l'article " <a href="https://www.viva64.com/en/b/0555/">Chrome: fuites de m√©moire</a> ".  Si la condition <i>(pkey.n0inv == 0)</i> est vraie, la fonction se termine sans lib√©rer le tampon, dont le pointeur est stock√© dans la variable <i>n</i> . <br><br>  Du point de vue du PVS-Studio, il n'y a rien de compliqu√© ici.  L'analyseur a √©tudi√© la fonction <i>BnNew</i> et se souvient qu'il a renvoy√© un pointeur sur le bloc de m√©moire allou√©.  Dans une autre fonction, il a remarqu√© que le tampon peut ne pas se lib√©rer et que le pointeur vers celui-ci est perdu au moment de quitter la fonction. <br><br>  C'est un algorithme courant de suivi des valeurs qui fonctionne.  Peu importe comment le code est √©crit.  Peu importe ce qu'il y a d'autre dans la fonction qui ne se rapporte pas au travail du pointeur.  L'algorithme est universel et le diagnostic V773 trouve beaucoup d'erreurs dans divers projets.  Voyez √† quel point les <a href="https://www.viva64.com/en/examples/v773/">fragments de code</a> avec des erreurs d√©tect√©es sont diff√©rents! <br><br>  Nous ne sommes pas des experts en ML, mais nous avons le sentiment que de gros probl√®mes sont √† nos portes ici.  Il existe un nombre incroyable de fa√ßons d'√©crire du code avec des fuites de m√©moire.  M√™me si la machine a bien appris √† suivre les valeurs des variables, elle devrait comprendre qu'il existe √©galement des appels aux fonctions. <br><br>  Nous pensons qu'il faudrait tellement d'exemples d'apprentissage pour que la t√¢che devienne insaisissable.  Nous ne disons pas que c'est irr√©aliste.  Nous doutons que le co√ªt de cr√©ation de l'analyseur soit payant. <br><br>  <b>Analogie</b>  Ce qui me vient √† l'esprit, c'est l'analogie avec une calculatrice, o√π au lieu de diagnostics, il faut programmer des actions arithm√©tiques.  Nous sommes s√ªrs que vous pouvez apprendre √† une calculatrice bas√©e sur ML √† bien r√©sumer les nombres en l'alimentant des r√©sultats des op√©rations 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300 et ainsi de suite .  Comme vous le comprenez, la faisabilit√© de d√©velopper une telle calculatrice est une grande question (sauf si une subvention lui est allou√©e :).  Une calculatrice beaucoup plus simple, plus rapide, plus pr√©cise et plus fiable peut √™tre √©crite en utilisant l'op√©ration simple "+" dans le code. <br><br>  <b>Conclusion</b> Eh bien, cette fa√ßon fonctionnera.  Mais √† notre avis, son utilisation n'a pas de sens pratique.  Le d√©veloppement prendra plus de temps, mais le r√©sultat - moins fiable et pr√©cis, en particulier lorsqu'il s'agit de mettre en ≈ìuvre des diagnostics complexes bas√©s sur l'analyse du flux de donn√©es. <br><br><h3>  Apprendre sur une grande quantit√© de code Open Source </h3><br>  D'accord, nous avons tri√© avec des exemples synth√©tiques manuels, mais il y a aussi GitHub.  Vous pouvez suivre l'historique des validations et en d√©duire les mod√®les de modification / correction de code.  Ensuite, vous pouvez non seulement pointer des fragments de code suspect, mais m√™me sugg√©rer un moyen de corriger le code. <br><br>  Si vous vous arr√™tez √† ce niveau de d√©tail, tout semble bien.  Le diable, comme toujours, est dans les d√©tails.  Parlons donc bien de ces d√©tails. <br><br>  <b>La premi√®re nuance.</b>  <b>Source de donn√©es.</b> <br><br>  Les modifications GitHub sont assez al√©atoires et diverses.  Les gens sont souvent paresseux pour effectuer des validations atomiques et effectuer plusieurs modifications dans le code en m√™me temps.  Vous savez comment cela se produit: vous corrigeriez le bug, et en m√™me temps le remanieriez un peu ("Et ici je vais ajouter la gestion d'un tel cas ...").  M√™me une personne peut alors √™tre incompr√©hensible, que ces probl√®mes soient li√©s les uns aux autres ou non. <br><br>  Le d√©fi est de savoir comment distinguer les erreurs r√©elles de l'ajout de nouvelles fonctionnalit√©s ou autre chose.  Vous pouvez, bien s√ªr, obtenir 1000 personnes qui marqueront manuellement les commits.  Les gens devront signaler: ici une erreur a √©t√© corrig√©e, voici la refactorisation, voici quelques nouvelles fonctionnalit√©s, ici les exigences ont chang√© et ainsi de suite. <br><br>  Un tel balisage est-il possible?  Ouais!  Mais remarquez √† quelle vitesse l'usurpation se produit.  Au lieu de "l'algorithme apprend par lui-m√™me sur la base de GitHub", nous discutons d√©j√† de la fa√ßon de d√©router des centaines de personnes pendant longtemps.  Le travail et le co√ªt de cr√©ation de l'outil augmentent consid√©rablement. <br><br>  Vous pouvez essayer d'identifier automatiquement o√π les bugs ont √©t√© corrig√©s.  Pour ce faire, vous devez analyser les commentaires des commits, faire attention aux petites modifications locales, qui sont tr√®s probablement ces corrections de bugs.  Il est difficile de dire dans quelle mesure vous pouvez rechercher automatiquement les correctifs d'erreurs.  Dans tous les cas, c'est une t√¢che importante qui n√©cessite une recherche et une programmation distinctes. <br><br>  Donc, nous n'avons m√™me pas encore appris, et il y a d√©j√† des nuances :). <br><br>  <b>La deuxi√®me nuance.</b>  <b>Un retard de d√©veloppement.</b> <br><br>  Les analyseurs qui apprendront sur la base de telles plateformes, comme GitHub, seront toujours soumis √† un tel syndrome, comme ¬´retard de retard mental¬ª.  En effet, les langages de programmation changent avec le temps. <br><br>  Depuis C # 8.0, il existe des types de r√©f√©rence Nullable, qui aident √† lutter contre les exceptions de r√©f√©rence Null (NRE).  Dans JDK 12, un nouvel op√©rateur de commutateur ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ) est apparu.  En C ++ 17, il est possible d'effectuer des constructions conditionnelles √† la compilation ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  Et ainsi de suite. <br><br>  Les langages de programmation √©voluent.  De plus, ceux, comme C ++, se d√©veloppent tr√®s rapidement.  De nouvelles constructions apparaissent, de nouvelles fonctions standard sont ajout√©es, etc.  Parall√®lement aux nouvelles fonctionnalit√©s, il existe de nouveaux mod√®les d'erreur que nous aimerions √©galement identifier avec l'analyse de code statique. <br><br>  √Ä ce stade, la m√©thode ML fait face √† un probl√®me: le motif d'erreur est d√©j√† clair, nous aimerions le d√©tecter, mais il n'y a pas de base de code pour l'apprentissage. <br><br>  Examinons ce probl√®me √† l'aide d'un exemple particulier.  La boucle for bas√©e sur une plage est apparue en C ++ 11.  Vous pouvez √©crire le code suivant en parcourant tous les √©l√©ments du conteneur: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  La nouvelle boucle a apport√© le nouveau mod√®le d'erreur avec elle.  Si nous modifions le conteneur √† l'int√©rieur de la boucle, cela entra√Ænera l'invalidation des it√©rateurs "fant√¥mes". <br><br>  Jetons un coup d'≈ìil au code incorrect suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Le compilateur le transformera en quelque chose comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Pendant <i>push_back</i> , les it√©rateurs <i>__begin</i> et <i>__end</i> peuvent √™tre invalid√©s, si la m√©moire est d√©plac√©e √† l'int√©rieur du vecteur.  Le r√©sultat sera le comportement ind√©fini du programme. <br><br>  Par cons√©quent, le mod√®le d'erreur est connu et d√©crit depuis longtemps dans la litt√©rature.  L'analyseur PVS-Studio le diagnostique avec le diagnostic <a href="https://www.viva64.com/en/w/v789/">V789</a> et a d√©j√† trouv√© de <a href="https://www.viva64.com/en/examples/v789/">vraies erreurs</a> dans les projets open source. <br><br>  Dans combien de temps GitHub obtiendra-t-il suffisamment de nouveau code pour remarquer ce mod√®le?  Bonne question ... Il est important de garder √† l'esprit que s'il existe une boucle for bas√©e sur une plage, cela ne signifie pas que tous les programmeurs commenceront imm√©diatement √† l'utiliser en m√™me temps.  Cela peut prendre des ann√©es avant que beaucoup de code n'utilise la nouvelle boucle.  De plus, de nombreuses erreurs doivent √™tre faites, puis elles doivent √™tre corrig√©es pour que l'algorithme puisse remarquer le motif dans les modifications. <br><br>  Combien d'ann√©es cela prendra-t-il?  Cinq?  Dix? <br><br>  Dix, c'est trop ou est-ce une pr√©diction pessimiste?  Loin de l√†.  Au moment o√π l'article a √©t√© √©crit, cela faisait huit ans qu'une boucle for bas√©e sur une plage √©tait apparue en C ++ 11.  Mais jusqu'√† pr√©sent dans notre base de donn√©es, il n'y a que <a href="https://www.viva64.com/en/examples/v789/">trois cas</a> d'une telle erreur.  Trois erreurs, ce n'est pas beaucoup et pas peu.  Il ne faut tirer aucune conclusion de ce chiffre.  L'essentiel est de confirmer qu'un tel mod√®le d'erreur est r√©el et qu'il est logique de le d√©tecter. <br><br>  Comparez maintenant ce nombre, par exemple, avec ce mod√®le d'erreur: le <a href="https://www.viva64.com/en/examples/v595/">pointeur est d√©r√©f√©renc√© avant la v√©rification</a> .  Au total, nous avons d√©j√† identifi√© 1 716 de ces cas lors de la v√©rification de projets open source. <br><br>  Peut-√™tre que nous ne devrions pas du tout rechercher des erreurs dans les boucles bas√©es sur la plage?  Non.  C'est juste que les programmeurs sont inertiels, et cet op√©rateur devient tr√®s populaire tr√®s lentement.  Progressivement, il y aura respectivement plus de code et d'erreurs. <br><br>  Cela ne devrait se produire que 10 √† 15 ans apr√®s l'apparition du C ++ 11.  Cela conduit √† une question philosophique.  Supposons que nous connaissions d√©j√† le mod√®le d'erreur, nous attendrons simplement de nombreuses ann√©es jusqu'√† ce que nous ayons de nombreuses erreurs dans les projets open source.  En sera-t-il ainsi? <br><br>  Si ¬´oui¬ª, il est s√ªr de diagnostiquer un ¬´retard de d√©veloppement mental¬ª pour tous les analyseurs bas√©s sur ML. <br><br>  Si "non", que devons-nous faire?  Il n'y a pas d'exemples.  Les √©crire manuellement?  Mais de cette fa√ßon, nous revenons au chapitre pr√©c√©dent, o√π nous avons donn√© une description d√©taill√©e de l'option lorsque les gens √©criraient un ensemble complet d'exemples d'apprentissage. <br><br>  Cela peut √™tre fait, mais la question de l'opportunit√© se pose √† nouveau.  L'impl√©mentation du diagnostic V789 avec toutes les exceptions dans l'analyseur PVS-Studio ne prend que 118 lignes de code, dont 13 lignes sont des commentaires.  Autrement dit, il s'agit d'un diagnostic tr√®s simple, qui peut √™tre facilement programm√© de mani√®re classique. <br><br>  La situation sera similaire √† toutes les autres innovations qui apparaissent dans toutes les autres langues.  Comme on dit, il y a quelque chose √† penser. <br><br>  <b>La troisi√®me nuance.</b>  <b>La documentation</b> <br><br>  Un √©l√©ment important de tout analyseur statique est la documentation d√©crivant chaque diagnostic.  Sans lui, il sera extr√™mement difficile, voire impossible, d'utiliser l'analyseur.  Dans la <a href="https://www.viva64.com/en/w/">documentation de</a> PVS-Studio, nous avons une description de chaque diagnostic, qui donne un exemple de code erron√© et comment le corriger.  Nous donnons √©galement le lien vers <a href="https://cwe.mitre.org/">CWE</a> , o√π l'on peut lire une description alternative du probl√®me.  Et pourtant, parfois, les utilisateurs ne comprennent pas quelque chose, et ils nous posent des questions de clarification. <br><br>  Dans le cas des analyseurs statiques bas√©s sur ML, le probl√®me de documentation est en quelque sorte √©touff√©.  Il est suppos√© que l'analyseur pointera simplement vers un endroit qui lui semble suspect et peut m√™me sugg√©rer comment le corriger.  La d√©cision de faire un montage ou non appartient √† la personne.  C'est l√† que le probl√®me commence ... Il n'est pas facile de prendre une d√©cision sans pouvoir lire, ce qui fait que l'analyseur semble suspect d'un endroit particulier dans le code. <br><br>  Bien s√ªr, dans certains cas, tout sera √©vident.  Supposons que l'analyseur pointe vers ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Et nous sugg√©rons de le remplacer par: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Il est imm√©diatement clair que le programmeur a fait une faute de frappe et a ajout√© 1 au mauvais endroit.  Par cons√©quent, moins de m√©moire sera allou√©e que n√©cessaire. <br><br>  Ici, tout est clair m√™me sans documentation.  Mais ce ne sera pas toujours le cas. <br><br>  Imaginez que l'analyseur pointe "silencieusement" vers ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Et sugg√®re que nous modifions le type char de la valeur de retour pour int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Il n'y a aucune documentation pour l'avertissement.  Apparemment, il n'y aura pas non plus de texte dans le message d'avertissement, si nous parlons d'un analyseur compl√®tement ind√©pendant. <br><br>  Que ferons-nous?  Quelle est la diff√©rence?  Vaut-il la peine de faire un tel remplacement? <br><br>  En fait, je pourrais tenter ma chance et accepter de corriger le code.  Bien qu'accepter des correctifs sans les comprendre est une pratique grossi√®re ... :) Vous pouvez regarder la description de la fonction <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> et d√©couvrir que la fonction retourne vraiment des valeurs comme <i>int</i> : 0, plus de z√©ro et moins de z√©ro.  Mais il est toujours difficile de savoir pourquoi effectuer des modifications, si le code fonctionne d√©j√† bien. <br><br>  Maintenant, si vous ne savez pas en quoi consiste la modification, consultez la description du diagnostic <a href="https://www.viva64.com/en/w/v642/">V642</a> .  Il devient imm√©diatement clair qu'il s'agit d'un v√©ritable bug.  De plus, cela peut provoquer une vuln√©rabilit√©. <br><br>  Peut-√™tre que l'exemple ne semblait pas convaincant.  Apr√®s tout, l'analyseur a sugg√©r√© un code susceptible d'√™tre meilleur.  Ok  Regardons un autre exemple de pseudocode, cette fois, pour un changement, en Java. <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Il y a un objet.  C'est la s√©rialisation.  Ensuite, l'√©tat de l'objet change et il re-s√©rialise.  √áa a l'air bien.  Imaginez maintenant que, tout d'un coup, l'analyseur n'aime pas le code et qu'il veuille le remplacer par ce qui suit: <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">// The line is added obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Au lieu de modifier l'objet et de le r√©√©crire, un nouvel objet est cr√©√© et il sera s√©rialis√©. <br><br>  Il n'y a pas de description du probl√®me.  Pas de documentation.  Le code est devenu plus long.  Pour une raison quelconque, un nouvel objet est cr√©√©.  √ätes-vous pr√™t √† effectuer une telle modification dans votre code? <br><br>  Vous direz que ce n'est pas clair.  En effet, c'est incompr√©hensible.  Et il en sera toujours ainsi.  Travailler avec un tel analyseur "silencieux" sera une √©tude sans fin pour tenter de comprendre pourquoi l'analyseur n'aime rien. <br><br>  S'il y a de la documentation, tout devient transparent.  La classe <i>java.io.ObjectOuputStream</i> utilis√©e pour la s√©rialisation met en cache les objets √©crits.  Cela signifie que le m√™me objet ne sera pas s√©rialis√© deux fois.  La classe s√©rialise l'objet une fois, et la deuxi√®me fois √©crit simplement dans le flux une r√©f√©rence au m√™me premier objet.  En savoir plus: <a href="https://www.viva64.com/en/w/v6076/">V6076</a> - La s√©rialisation r√©currente utilisera l'√©tat d'objet mis en cache √† partir de la premi√®re s√©rialisation. <br><br>  Nous esp√©rons avoir r√©ussi √† expliquer l'importance de la documentation.  Voici la question.  Comment la documentation de l'analyseur bas√© sur ML appara√Ætra-t-elle? <br><br>  Lorsqu'un analyseur de code classique est d√©velopp√©, tout est simple et clair.  Il y a un sch√©ma d'erreurs.  Nous le d√©crivons dans la documentation et impl√©mentons le diagnostic. <br><br>  Dans le cas du ML, le processus est inverse.  Oui, l'analyseur peut remarquer une anomalie dans le code et la signaler.  Mais il ne sait rien de l'essence du d√©faut.  Il ne comprend pas et ne vous dira pas pourquoi vous ne pouvez pas √©crire du code comme √ßa.  Ce sont des abstractions de trop haut niveau.  De cette fa√ßon, l'analyseur doit √©galement apprendre √† lire et √† <b>comprendre la</b> documentation des fonctions. <br><br>  Comme je l'ai dit, comme le probl√®me de la documentation est √©vit√© dans les articles sur l'apprentissage automatique, nous ne sommes pas pr√™ts √† nous y attarder davantage.  Juste une autre nuance importante dont nous avons parl√©. <br><br>  <b>Remarque</b>  Vous pourriez faire valoir que la documentation est facultative.  L'analyseur peut se r√©f√©rer √† de nombreux exemples de correctifs sur GitHub et la personne, en parcourant les commits et les commentaires, comprendra ce qui est quoi.  Oui, c'est vrai.  Mais l'id√©e n'a pas l'air attrayante.  Ici, l'analyseur est le mauvais gars, qui va plut√¥t intriguer un programmeur que l'aider. <br><br>  <b>Quatri√®me nuance.</b>  <b>Langues hautement sp√©cialis√©es.</b> <br><br>  L'approche d√©crite n'est pas applicable aux langages hautement sp√©cialis√©s, pour lesquels l'analyse statique peut √©galement √™tre extr√™mement utile.  La raison en est que GitHub et d'autres sources n'ont tout simplement pas une base de code source suffisamment grande pour fournir un apprentissage efficace. <br><br>  Voyons cela √† l'aide d'un exemple concret.  Tout d'abord, allons sur GitHub et recherchons des r√©f√©rentiels pour le langage Java populaire. <br><br>  R√©sultat: langue: "Java": 3 <b>128 884</b> r√©sultats de r√©f√©rentiel disponibles <br><br>  Prenons maintenant le langage sp√©cialis√© ¬´1C Enterprise¬ª utilis√© dans les applications comptables produites par la soci√©t√© russe <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  R√©sultat: langue: ¬´1C Enterprise¬ª: <b>551</b> r√©sultats de r√©f√©rentiel disponibles <br><br>  Peut-√™tre que les analyseurs ne sont pas n√©cessaires pour ce langage?  Non, ils le sont.  Il existe un besoin pratique d'analyser de tels programmes et il existe d√©j√† des analyseurs appropri√©s.  Par exemple, il existe le plug-in SonarQube 1C (BSL), produit par la soci√©t√© " <a href="https://silverbulleters.org/">Silver Bullet</a> ". <br><br>  Je pense qu'aucune explication sp√©cifique n'est n√©cessaire pour expliquer pourquoi l'approche ML sera difficile pour les langues sp√©cialis√©es. <br><br>  <b>La cinqui√®me nuance.</b>  <b>C, C ++, #include</b> . <br><br>  Les articles sur l'analyse de code statique bas√©e sur ML concernent principalement des langages tels que Java, JavaScript et Python.  Cela s'explique par leur extr√™me popularit√©.  Quant √† C et C ++, ils sont en quelque sorte ignor√©s, m√™me si vous ne pouvez pas les appeler impopulaires. <br><br>  Nous sugg√©rons qu'il ne s'agit pas de leur popularit√© / perspectives prometteuses, mais des probl√®mes avec les langages C et C ++.  Et maintenant, nous allons mettre en lumi√®re un probl√®me inconfortable. <br><br>  Un fichier c / cpp abstrait peut √™tre tr√®s difficile √† compiler.  Au moins, vous ne pouvez pas charger un projet √† partir de GitHub, choisissez un fichier cpp al√©atoire et compilez-le simplement.  Nous allons maintenant expliquer ce que tout cela a √† voir avec le ML. <br><br>  Nous voulons donc enseigner l'analyseur.  Nous avons t√©l√©charg√© un projet depuis GitHub.  Nous connaissons le correctif et supposons qu'il corrige le bogue.  Nous voulons que cette modification soit un exemple d'apprentissage.  En d'autres termes, nous avons un fichier .cpp avant et apr√®s l'√©dition. <br><br>  C'est l√† que le probl√®me commence.  Il ne suffit pas d'√©tudier les correctifs.  Un contexte complet est √©galement requis.  Vous devez conna√Ætre la d√©claration des classes utilis√©es, vous devez conna√Ætre les prototypes des fonctions utilis√©es, vous devez savoir comment les macros se d√©veloppent et ainsi de suite.  Et pour ce faire, vous devez effectuer un <a href="https://en.wikipedia.org/wiki/C_preprocessor">pr√©traitement</a> complet des fichiers. <br><br>  Regardons l'exemple.  Au d√©but, le code ressemblait √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>  Il a √©t√© fix√© de cette fa√ßon: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  L'analyseur doit-il commencer √† apprendre afin de proposer <i>(x == "y") un</i> remplacement pour strcmp (x, "y")? <br><br>  Vous ne pouvez pas r√©pondre √† cette question sans savoir comment le membre <i>m_name</i> est d√©clar√© dans la classe.  Il pourrait y avoir, par exemple, de telles options: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>  Des modifications seront apport√©es au cas o√π nous parlons d'un pointeur ordinaire.  Si nous ne prenons pas en compte le type de variable, l'analyseur peut apprendre √† √©mettre des avertissements bons et mauvais (pour le cas avec <i>std :: string</i> ). <br><br>  Les d√©clarations de classe se trouvent g√©n√©ralement dans les fichiers d'en-t√™te.  Ici, il √©tait n√©cessaire d'effectuer un pr√©traitement pour disposer de toutes les informations n√©cessaires.  C'est extr√™mement important pour C et C ++. <br><br>  Si quelqu'un dit qu'il est possible de se passer de pr√©traitement, c'est soit une fraude, soit il ne conna√Æt pas les langages C ou C ++. <br><br>  Pour rassembler toutes les informations n√©cessaires, vous avez besoin d'un pr√©traitement correct.  Pour ce faire, vous devez savoir o√π et quels fichiers d'en-t√™te se trouvent, quelles macros sont d√©finies pendant le processus de g√©n√©ration.  Vous devez √©galement savoir comment un fichier cpp particulier est compil√©. <br><br>  Voil√† le probl√®me.  On ne compile pas simplement le fichier (ou, plut√¥t, sp√©cifiez la cl√© du compilateur pour qu'il g√©n√®re un fichier de pr√©traitement).  Nous devons comprendre comment ce fichier est compil√©.  Ces informations se trouvent dans les scripts de construction, mais la question est de savoir comment les obtenir √† partir de l√†.  En g√©n√©ral, la t√¢che est compliqu√©e. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91b/aaf/95a/91baaf95a62415697b40f23298d115c2.png"></div><br><br>  De plus, de nombreux projets sur GitHub sont un g√¢chis.  Si vous prenez un projet abstrait √† partir de l√†, vous devez souvent bricoler pour le compiler.  Un jour, il vous manque une biblioth√®que et vous devez la trouver et la t√©l√©charger manuellement.  Un autre jour, une sorte de syst√®me de construction auto-√©crit est utilis√©, qui doit √™tre trait√©.  √áa pourrait √™tre n'importe quoi.  Parfois, le projet t√©l√©charg√© refuse simplement de se construire et il doit √™tre en quelque sorte modifi√©.  Vous ne pouvez pas simplement prendre et obtenir automatiquement une repr√©sentation pr√©trait√©e (.i) pour les fichiers .cpp.  Cela peut √™tre d√©licat m√™me lorsque vous le faites manuellement. <br><br>  Nous pouvons dire, eh bien, le probl√®me des projets non li√©s √† la construction est compr√©hensible, mais pas crucial.  Ne travaillons qu'avec des projets qui peuvent √™tre construits.  Il reste la t√¢che de pr√©traiter un fichier particulier.  Sans parler des cas o√π nous avons affaire √† certains compilateurs sp√©cialis√©s, par exemple pour les syst√®mes embarqu√©s. <br><br>  Apr√®s tout, le probl√®me d√©crit n'est pas insurmontable.  Cependant, tout cela est tr√®s difficile et demande beaucoup de main-d'≈ìuvre.  Dans le cas de C et C ++, le code source situ√© sur GitHub ne fait rien.  Il y a beaucoup de travail √† faire pour apprendre √† ex√©cuter automatiquement les compilateurs. <br><br>  <b>Remarque</b>  Si le lecteur ne comprend toujours pas la profondeur du probl√®me, nous vous invitons √† participer √† l'exp√©rience suivante.  Prenez dix projets al√©atoires de taille moyenne de GitHub et essayez de les compiler, puis obtenez leur version pr√©trait√©e pour les fichiers .cpp.  Apr√®s cela, la question de la p√©nibilit√© de cette t√¢che dispara√Ætra :). <br><br>  Il peut y avoir des probl√®mes similaires avec d'autres langages, mais ils sont particuli√®rement √©vidents en C et C ++. <br><br>  <b>Sixi√®me nuance.</b>  <b>Le prix de l'√©limination des faux positifs.</b> <br><br>  Les analyseurs statiques sont susceptibles de g√©n√©rer des faux positifs et nous devons constamment affiner les diagnostics pour r√©duire le nombre de faux avertissements. <br><br>  Nous allons maintenant revenir au diagnostic <a href="https://www.viva64.com/en/w/v789/">V789</a> pr√©c√©demment consid√©r√©, d√©tectant les changements de conteneur √† l'int√©rieur de la boucle for bas√©e sur la plage.  Disons que nous n'avons pas fait assez attention lors de sa r√©daction et que le client rapporte un faux positif.  Il √©crit que l'analyseur ne prend pas en compte le sc√©nario o√π la boucle se termine apr√®s le changement du conteneur, et donc il n'y a pas de probl√®me.  Il donne ensuite l'exemple de code suivant o√π l'analyseur donne un faux positif: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// or, for example, return } }</span></span></code> </pre> <br>  Oui, c'est un d√©faut.  Dans un analyseur classique, son √©limination est extr√™mement rapide et bon march√©.  Dans PVS-Studio, l'impl√©mentation de cette exception se compose de 26 lignes de code. <br><br>  Cette faille peut √©galement √™tre corrig√©e lorsque l'analyseur est bas√© sur des algorithmes d'apprentissage.  Bien s√ªr, il peut √™tre enseign√© en collectant des dizaines ou des centaines d'exemples de code qui doivent √™tre consid√©r√©s comme corrects. <br><br>  Encore une fois, la question n'est pas de faisabilit√©, mais d'approche pratique.  Nous pensons que lutter contre des faux positifs sp√©cifiques, qui d√©rangent les clients, est beaucoup plus co√ªteux en cas de blanchiment d'argent.  Autrement dit, le support client en termes d'√©limination des faux positifs co√ªtera plus cher. <br><br>  <b>Septi√®me nuance.</b>  <b>Caract√©ristiques rarement utilis√©es et longue queue.</b> <br><br>  Auparavant, nous nous sommes attaqu√©s au probl√®me des langages hautement sp√©cialis√©s, pour lesquels le code source n'est peut-√™tre pas suffisant pour l'apprentissage.  Un probl√®me similaire se produit avec les fonctions rarement utilis√©es (celles du syst√®me, WinAPI, des biblioth√®ques populaires, etc.). <br><br>  Si nous parlons de telles fonctions du langage C, comme <i>strcmp</i> , alors il y a en fait une base d'apprentissage.  GitHub, r√©sultats de code disponibles: <br><br><ul><li>  strcmp - 40,462,158 </li><li>  strictmp - 1,256,053 </li></ul><br>  Oui, il existe de nombreux exemples d'utilisation.  Peut-√™tre que l'analyseur apprendra √† remarquer, par exemple, les mod√®les suivants: <br><br><ul><li>  C'est √©trange si la cha√Æne est compar√©e √† elle-m√™me.  Il se corrige. </li><li>  C'est √©trange si l'un des pointeurs est NULL.  Il se corrige. </li><li>  Il est √©trange que le r√©sultat de cette fonction ne soit pas utilis√©.  Il se corrige. </li><li>  Et ainsi de suite. </li></ul><br>  N'est-ce pas cool?  Non.  Ici, nous sommes confront√©s au probl√®me de la "longue queue".  Tr√®s bri√®vement le point de la "longue queue" dans ce qui suit.  Il est impossible de vendre uniquement le Top50 des livres les plus populaires et les plus lus dans une librairie.  Oui, chacun de ces livres sera achet√©, disons, 100 fois plus souvent que les livres ne figurant pas sur cette liste.  Cependant, la plupart des recettes seront constitu√©es d'autres livres qui, comme on dit, trouvent leur lecteur.  Par exemple, une boutique en ligne Amazon.com re√ßoit plus de la moiti√© des b√©n√©fices de ce qui ne fait pas partie des 130 000 ¬´articles les plus populaires¬ª. <br><br>  Il existe des fonctions populaires et peu nombreuses.  Il y a des impopulaires, mais il y en a beaucoup.  Par exemple, il existe les variantes suivantes de la fonction de comparaison de cha√Ænes: <br><br><ul><li>  g_ascii_strncasecmp - 35,695 </li><li>  lstrcmpiA - 27,512 </li><li>  _wcsicmp_l - 5 737 </li><li>  _strnicmp_l - 5,848 </li><li>  _mbscmp_l - 2,458 </li><li>  et d'autres. </li></ul><br>  Comme vous pouvez le voir, ils sont utilis√©s beaucoup moins fr√©quemment, mais lorsque vous les utilisez, vous pouvez faire les m√™mes erreurs.  Il y a trop peu d'exemples pour identifier les mod√®les.  Cependant, ces fonctions ne peuvent pas √™tre ignor√©es.  Individuellement, ils sont rarement utilis√©s, mais beaucoup de code est √©crit avec leur utilisation, ce qui vaut mieux √™tre v√©rifi√©.  C'est l√† que la "longue queue" se montre. <br><br>  Chez PVS-Studio, nous annotons manuellement les fonctionnalit√©s.  Par exemple, √† l'heure actuelle, environ 7 200 fonctions avaient √©t√© annot√©es pour C et C ++.  Voici ce que nous marquons: <br><br><ul><li>  Winapi </li><li>  Biblioth√®que C standard, </li><li>  Biblioth√®que de mod√®les standard (STL), </li><li>  glibc (biblioth√®que GNU C) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  et d'autres. </li></ul><br>  D'une part, cela semble √™tre une voie sans issue.  Vous ne pouvez pas tout annoter.  D'un autre c√¥t√©, cela fonctionne. <br><br>  Voici maintenant la question.  Quels avantages le ML peut-il avoir?  Les avantages significatifs ne sont pas si √©vidents, mais vous pouvez voir la complexit√©. <br><br>  Vous pourriez faire valoir que les algorithmes construits sur ML eux-m√™mes trouveront des mod√®les avec des fonctions fr√©quemment utilis√©es et qu'ils n'ont pas besoin d'√™tre annot√©s.  Oui c'est vrai.  Cependant, il n'y a aucun probl√®me √† annoter ind√©pendamment des fonctions populaires telles que <i>strcmp</i> ou <i>malloc</i> . <br><br>  N√©anmoins, la longue queue pose des probl√®mes.  Vous pouvez enseigner en faisant des exemples synth√©tiques.  Cependant, nous revenons ici √† la partie article, o√π nous disions qu'il √©tait plus facile et plus rapide d'√©crire des diagnostics classiques, plut√¥t que de g√©n√©rer de nombreux exemples. <br><br>  Prenons par exemple une fonction, telle que <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> .  Bien s√ªr, il est utilis√© moins fr√©quemment que le <i>fread</i> .  Mais lorsque vous l'utilisez, vous pouvez faire les m√™mes erreurs.  Par exemple, le tampon doit √™tre suffisamment grand.  Cette taille ne doit pas √™tre inf√©rieure au r√©sultat de la multiplication des deuxi√®me et troisi√®me arguments.  Autrement dit, vous voulez trouver un tel code incorrect: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>  Voici √† quoi ressemble l'annotation de cette fonction dans PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  √Ä premi√®re vue, une telle annotation peut sembler difficile, mais en fait, lorsque vous commencez √† les √©crire, cela devient simple.  De plus, c'est du code en √©criture seule.  A √©crit et oubli√©.  Les annotations changent rarement. <br><br>  Parlons maintenant de cette fonction du point de vue de ML.  GitHub ne nous aidera pas.  Il y a environ 15 000 mentions de cette fonction.  Il y a encore moins de bon code.  Une partie importante des r√©sultats de recherche reprend les √©l√©ments suivants: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>  Quelles sont les options? <ol><li>  Ne fais rien.  C'est un chemin vers nulle part. </li><li>  Imaginez, enseignez l'analyseur en √©crivant des centaines d'exemples juste pour une fonction afin que l'analyseur comprenne l'interconnexion entre le tampon et les autres arguments.  Oui, vous pouvez le faire, mais c'est √©conomiquement irrationnel.  C'est une rue sans issue. </li><li>  Vous pouvez trouver un moyen similaire au n√¥tre lorsque les annotations des fonctions seront d√©finies manuellement.  C'est une bonne fa√ßon sens√©e.  C'est juste ML, ce qui n'a rien √† voir avec √ßa :).  C'est un retour √† la mani√®re classique d'√©crire des analyseurs statiques. </li></ol><br>  Comme vous pouvez le voir, ML et la longue queue des fonctionnalit√©s rarement utilis√©es ne vont pas ensemble. <br><br>  √Ä ce stade, des personnes li√©es au ML se sont oppos√©es et ont d√©clar√© que nous n'avions pas pris en compte l'option lorsque l'analyseur apprendrait toutes les fonctions et tirerait des conclusions de ce qu'elles faisaient.  Ici, apparemment, soit nous ne comprenons pas les experts, soit ils ne comprennent pas notre point de vue. <br><br>  Les corps de fonctions peuvent √™tre inconnus.  Par exemple, il peut s'agir d'une fonction li√©e √† WinAPI.  S'il s'agit d'une fonction rarement utilis√©e, comment l'analyseur comprendra-t-il ce qu'il fait?  On peut imaginer que l'analyseur utilisera Google lui-m√™me, trouvera une description de la fonction, la lira et la <b>comprendra</b> .  En outre, il devra tirer des conclusions de haut niveau de la documentation.  La description <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> ne dit rien sur l'interconnexion entre le tampon, le deuxi√®me et le troisi√®me argument.  Cette comparaison doit √™tre d√©duite de l'intelligence artificielle seule, bas√©e sur une compr√©hension des principes g√©n√©raux de la programmation et du fonctionnement du langage C ++.  Je pense que nous devrions r√©fl√©chir s√©rieusement √† tout cela dans 20 ans. <br><br>  Des corps de fonctions peuvent √™tre disponibles, mais cela peut ne pas √™tre utile.  Examinons une fonction, telle que <i>memmove</i> .  Il est souvent impl√©ment√© dans quelque chose comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>  Qu'est-ce que <i>__builtin___memmove_chk</i> ?  Il s'agit d'une fonction intrins√®que que le compilateur lui-m√™me impl√©mente d√©j√†.  Cette fonction n'a pas le code source. <br><br>  Ou <i>memmove</i> pourrait ressembler √† ceci: <a href="">la premi√®re version d'assemblage</a> .  Vous pouvez apprendre √† l'analyseur √† comprendre les diff√©rentes options d'assemblage, mais une telle approche semble incorrecte. <br><br>  Ok, parfois des corps de fonctions sont vraiment connus.  De plus, nous connaissons √©galement des corps de fonctions dans le code de l'utilisateur.  Il semblerait que dans ce cas, ML obtienne d'√©normes avantages en lisant et en comprenant ce que font toutes ces fonctions. <br><br>  Cependant, m√™me dans ce cas, nous sommes pleins de pessimisme.  Cette t√¢che est trop complexe.  C'est compliqu√© m√™me pour un humain.  Pensez √† quel point il est difficile pour vous de comprendre le code que vous n'avez pas √©crit.  Si c'est difficile pour une personne, pourquoi cette t√¢che devrait-elle √™tre facile pour une IA?  En fait, l'IA a un gros probl√®me pour comprendre les concepts de haut niveau.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous parlons de comprendre le code, nous ne pouvons pas nous passer de la possibilit√© de faire abstraction des d√©tails de l'impl√©mentation et de consid√©rer l'algorithme √† un niveau √©lev√©. Il semble que cette discussion puisse √©galement √™tre report√©e de 20 ans. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autres nuances</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il y a d'autres points qui devraient √©galement √™tre pris en compte, mais nous ne les avons pas approfondis. Soit dit en passant, l'article s'av√®re assez long. Par cons√©quent, nous √©num√©rerons bri√®vement quelques autres nuances, en les laissant √† la r√©flexion du lecteur.</font></font><br><br><ul><li> <b>Outdated recommendations.</b> As mentioned, languages change, and recommendations for their use change, respectively. If the analyzer learns on old source code, it might start issuing outdated recommendations at some point. Example. Formerly, C++ programmers have been recommended using <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> instead of half-done pointers. This smart pointer is now considered obsolete and it is recommended that you use <i>unique_ptr</i> . </li><li> <b>Data models.</b> At the very least, C and C++ languages have such a thing as a <a href="https://www.viva64.com/en/t/0012/">data model</a> . This means that data types have different number of bits across platforms. If you don't take this into account, you can incorrectly teach the analyzer. For example, in Windows 32/64 the <i>long</i> type always has 32 bits. But in Linux, its size will vary and take 32/64 bits depending on the platform's number of bits. Without taking all this into account, the analyzer can learn to miscalculate the size of the types and structures it forms. But the types also align in different ways. All this, of course, can be taken into account. You can teach the analyzer to know about the size of the types, their alignment and mark the projects (indicate how they are building). However, all this is an additional complexity, which is not mentioned in the research articles. </li><li> <b>Behavioral unambiguousness.</b> Since we're talking about ML, the analysis result is more likely to have probabilistic nature. That is, sometimes the erroneous pattern will be recognized, and sometimes not, depending on how the code is written. From our experience, we know that the user is extremely irritated by the ambiguity of the analyzer's behavior. He wants to know exactly which pattern will be considered erroneous and which will not, and why. In the case of the classical analyzer developing approach, this problem is poorly expressed. Only sometimes we need to explain our clients why there is a/there is no analyzer warning and how the algorithm works, what exceptions are handled in it. Algorithms are clear and everything can always be easily explained. An example of this kind of communication: " <a href="https://www.viva64.com/en/b/0612/">False Positives in PVS-Studio: How Deep the Rabbit Hole Goes</a> ". It's not clear how the described problem will be solved in the analyzers built on ML. </li></ul><br><h2> Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne nions pas les perspectives de la direction ML, y compris son application en termes d'analyse de code statique. ML peut √™tre potentiellement utilis√© dans les t√¢ches de recherche de fautes de frappe, lors du filtrage des faux positifs, lors de la recherche de nouveaux mod√®les d'erreur (non encore d√©crits), etc. Cependant, nous ne partageons pas l'optimisme qui impr√®gne les articles consacr√©s au ML en termes d'analyse de code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, nous avons d√©crit quelques probl√®mes sur lesquels il faudra travailler s'il veut utiliser ML. Les nuances d√©crites nient en grande partie les avantages de la nouvelle approche. De plus, les anciennes approches classiques de mise en ≈ìuvre des analyseurs sont plus rentables et plus √©conomiquement r√©alisables.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fait int√©ressant, les articles des adh√©rents de la m√©thodologie ML ne mentionnent pas ces pi√®ges. </font><font style="vertical-align: inherit;">Eh bien, rien de nouveau. </font><font style="vertical-align: inherit;">ML provoque un certain battage m√©diatique et nous ne devrions probablement pas nous attendre √† une √©valuation √©quilibr√©e de ses apologistes concernant l'applicabilit√© du ML dans les t√¢ches d'analyse de code statique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De notre point de vue, l'apprentissage automatique remplira une niche dans les technologies, utilis√©es dans les analyseurs statiques avec l'analyse des flux de contr√¥le, les ex√©cutions symboliques et autres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thodologie de l'analyse statique peut b√©n√©ficier de l'introduction du ML, mais n'exag√©rez pas les possibilit√©s de cette technologie.</font></font><br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que l'article est g√©n√©ralement critique, certains pourraient penser que nous craignons le nouveau et que les </font></font><a href="https://en.wikipedia.org/wiki/Luddite"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luddites se sont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retourn√©s contre ML de peur de perdre le march√© des outils d'analyse statique.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Luddites"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non, nous n'avons pas peur. Nous ne voyons tout simplement pas l'int√©r√™t de d√©penser de l'argent pour des approches inefficaces dans le d√©veloppement de l'analyseur de code PVS-Studio. Sous une forme ou une autre, nous adopterons le ML. De plus, certains diagnostics contiennent d√©j√† des √©l√©ments d'algorithmes d'auto-apprentissage. Cependant, nous serons certainement tr√®s conservateurs et ne prendrons que ce qui aura clairement un plus grand effet que les approches classiques, construites sur des boucles et des ifs :). Apr√®s tout, nous devons cr√©er un outil efficace, pas travailler sur une subvention :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'article est √©crit parce que de plus en plus de questions sont pos√©es sur le sujet et nous voulions avoir un article explicatif qui met tout √† sa place. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci de votre attention. Nous vous invitons √† lire l'article "</font></font><a href="https://www.viva64.com/en/b/0687/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi devriez-vous choisir l'analyseur statique PVS-Studio pour l'int√©grer dans votre processus de d√©veloppement</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . "</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484202/">https://habr.com/ru/post/fr484202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484192/index.html">Applications faciles et faciles √† d√©ployer sur la cartouche Tarantool (partie 2)</a></li>
<li><a href="../fr484194/index.html">Kubernetes traduit en enfants</a></li>
<li><a href="../fr484196/index.html">Enregistrement du son JS √† partir d'un microphone ou des commentaires vocaux</a></li>
<li><a href="../fr484198/index.html">Revers de la m√©daille: qui a gagn√© et perdu sur la croissance des actions Tesla</a></li>
<li><a href="../fr484200/index.html">Comment fixer des objectifs pour les atteindre</a></li>
<li><a href="../fr484204/index.html">Le ransomware sans fichier FTCODE vole d√©sormais les comptes</a></li>
<li><a href="../fr484206/index.html">Utilisation de mixins dans Dart</a></li>
<li><a href="../fr484208/index.html">Utilisation de l'apprentissage automatique dans l'analyse statique du code source du programme</a></li>
<li><a href="../fr484212/index.html">Des trucs gratuits pour le karma - l'histoire d'une startup bi√©lorusse qui change le principe de la consommation</a></li>
<li><a href="../fr484214/index.html">Tenseurs dans TensorFlow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>