<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏿 🚽 🤦🏿 Neu in SObjectizer-5.5.23: Wunscherfüllung oder Pandoras Box? 👩🏿‍🔬 🏐 🆔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine Fortsetzung eines vor einem Monat veröffentlichten Reflexionsartikels: „ Ist es einfach, dem alten Framework neue Funktionen h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neu in SObjectizer-5.5.23: Wunscherfüllung oder Pandoras Box?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426983/"><img src="https://habrastorage.org/webt/kt/xf/7o/ktxf7oduhnd0zuhd_tpaju7p_em.jpeg"><br><br>  Dieser Artikel ist eine Fortsetzung eines vor einem Monat veröffentlichten Reflexionsartikels: „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ist es einfach, dem alten Framework neue Funktionen hinzuzufügen? Die Qual der Wahl am Beispiel der Entwicklung von SObjectizer</a> “.  In diesem Artikel wurde die Aufgabe beschrieben, die wir in der nächsten Version von SObjectizer lösen wollten, zwei Lösungsansätze untersucht und die Vor- und Nachteile der einzelnen Ansätze aufgelistet. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufe der</a> Zeit wurde einer der Ansätze implementiert und neue Versionen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> sowie das dazugehörige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt so_5_extra</a> , das bereits als „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tief atmen</a> “ bezeichnet wurde.  Sie können buchstäblich nehmen und versuchen. <br><br>  Heute werden wir darüber sprechen, was getan wurde, warum es getan wurde, wozu es geführt hat.  Wenn jemand daran interessiert ist, zu verfolgen, wie sich eines der wenigen Live-, plattformübergreifenden und Open-Actor-Frameworks für C ++ entwickelt, sind Sie bei cat willkommen. <br><a name="habracut"></a><br><h1>  Wie hat alles angefangen? </h1><br>  Alles begann mit dem Versuch, das Problem der garantierten Stornierung von Timern zu lösen.  Das Problem besteht im Wesentlichen darin, dass der Programmierer beim Senden einer verzögerten oder periodischen Nachricht die Zustellung der Nachricht abbrechen kann.  Zum Beispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer_id = so_5::send_periodic&lt;my_message&gt;(my_agent, <span class="hljs-number"><span class="hljs-number">10</span></span>s, <span class="hljs-number"><span class="hljs-number">10</span></span>s, ...); ... <span class="hljs-comment"><span class="hljs-comment">// - . // ,    my_message    . timer_id.release(); //      my_message.</span></span></code> </pre> <br>  Nach dem Aufruf von <i>timer_id.release () sendet der</i> Timer keine neuen Instanzen der my_message-Nachricht mehr.  Aber die Kopien, die bereits gesendet wurden und sich in der Warteschlange der Empfänger befinden, werden nirgendwo hingehen.  Im Laufe der Zeit werden sie aus denselben Warteschlangen extrahiert und zur Verarbeitung an die Empfängeragenten übertragen. <br><br>  Dieses Problem ist eine Folge der Grundprinzipien des Betriebs von SObjectizer-5 und hat keine einfache Lösung, da SObjectizer keine Nachrichten aus Warteschlangen extrahieren kann.  Dies ist nicht möglich, da die Warteschlangen in SObjectizer zu Dispatchern gehören, die Disponenten unterschiedlich sind und ihre Warteschlangen auch unterschiedlich organisiert sind.  Einschließlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es Disponenten, die nicht Teil des SObjectizers sind,</a> und SObjectizer kann im Prinzip nicht wissen, wie diese Dispatcher funktionieren. <br><br>  Im Allgemeinen gibt es eine solche Funktion in den nativen SObjectizer-Timern.  Nicht, dass es Entwickler zu sehr verwöhnt.  Es ist jedoch besondere Vorsicht geboten.  Besonders für Anfänger, die sich gerade erst mit dem Framework vertraut machen. <br><br>  Und schließlich gingen die Hände so weit, eine Lösung für dieses Problem vorzuschlagen. <br><br><h1>  Welcher Lösungsweg wurde gewählt? </h1><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel</a> wurden zwei mögliche Optionen in Betracht gezogen.  Die erste Option erforderte keine Änderungen am Nachrichtenübermittlungsmechanismus in SObjectizer, aber der Programmierer musste den Typ der gesendeten / empfangenen Nachricht explizit ändern. <br><br>  Die zweite Option erforderte eine Änderung des SObjectizer-Nachrichtenübermittlungsmechanismus.  Es wurde dieser Pfad gewählt, da er es dem Empfänger der Nachricht ermöglichte, die Tatsache zu verbergen, dass die Nachricht auf eine bestimmte Weise gesendet wurde. <br><br><h2>  Was hat sich in SObjectizer geändert? </h2><br><h3>  Neues Konzept: Umschlag mit Nachricht im Inneren </h3><br>  Die erste Komponente der implementierten Lösung ist das Hinzufügen eines solchen Konzepts als Umschlag zu SObjectizer.  Ein Umschlag ist eine spezielle Nachricht, in der sich die aktuelle Nachricht (Nutzlast) befindet.  SObjectizer liefert den Umschlag mit der Nachricht fast wie gewohnt an den Empfänger.  Der grundlegende Unterschied in der Briefumschlagverarbeitung wird erst in der allerletzten Lieferphase festgestellt: <br><br><ul><li>  Bei der Zustellung einer regulären Nachricht sucht der Empfängeragent einfach nach einem Handler für diesen Nachrichtentyp. Wenn ein solcher Handler gefunden wird, wird der gefundene Handler aufgerufen und die zugestellte Nachricht als Parameter zurückgegeben. </li><li>  und bei Zustellung des Umschlags mit der Nachricht, nachdem der Handler gefunden wurde, wird zuerst versucht, die Nachricht aus dem Umschlag herauszuholen.  Und nur wenn der Umschlag die darin gespeicherte Nachricht enthält, wird der Handler aufgerufen. </li></ul><br>  Hier gibt es zwei wichtige Punkte, die einen großen Einfluss darauf haben, warum und wie Nachrichtenumschläge verwendet werden können. <br><br>  Der erste wichtige Punkt ist, dass eine Nachricht nur dann von einem Umschlag angefordert wird, wenn beim Empfänger ein Nachrichtenhandler gefunden wird.  Das heißt,  Nur wenn die Nachricht wirklich an den Empfänger übermittelt wurde und der Empfänger hier und jetzt ist, wird diese Nachricht verarbeitet. <br><br>  Der zweite wichtige Punkt hierbei ist, dass der Umschlag die darin enthaltene Nachricht möglicherweise nicht weitergibt.  Das heißt, ein Umschlag kann beispielsweise die aktuelle Uhrzeit überprüfen und feststellen, dass alle Liefertermine versäumt wurden und die Nachricht daher nicht mehr relevant ist und nicht mehr verarbeitet werden kann.  Daher gibt der Umschlag die Nachricht nicht aus.  Dementsprechend ignoriert SObjectizer diesen Umschlag einfach und ergreift keine zusätzlichen Maßnahmen. <br><br><h4>  Wie ist ein Umschlag? </h4><br>  Ein Envelope ist eine Implementierung der Envelope_t-Schnittstelle, die wie folgt definiert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SO_5_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envelope_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-comment"><span class="hljs-comment">// -. //   ,       //    . virtual void handler_found_hook( handler_invoker_t &amp; invoker ) noexcept = 0; //   ,      //     . virtual void transformation_hook( handler_invoker_t &amp; invoker ) noexcept = 0; private : kind_t so5_message_kind() const noexcept override { return kind_t::enveloped_msg; } };</span></span></code> </pre> <br>  Das heißt,  Ein Umschlag ist im Wesentlichen dieselbe Nachricht wie alle anderen.  Aber mit einem speziellen Attribut, das von der Methode so5_message_kind () zurückgegeben wird. <br><br>  Der Programmierer kann seine Hüllkurven entwickeln, die von Envelope_t (oder bequemer von <a href="">so_5 :: extra :: Enveloped_msg :: just_envelope_t</a> ) <a href="">erben,</a> und die Hook-Methoden handler_found_hook () und transformation_hook () überschreiben. <br><br>  Innerhalb der Hook-Methoden entscheidet der Umschlagentwickler, ob er die Nachricht innerhalb des Umschlags zur Verarbeitung / Transformation geben möchte oder nicht.  Wenn er möchte, muss der Entwickler die invoke () -Methode und das invoker-Objekt aufrufen.  Wenn er nicht möchte, ruft er nicht an. In diesem Fall werden der Umschlag und sein Inhalt ignoriert. <br><br><h4>  Wie lösen Umschläge das Problem des Abbrechens von Timern? </h4><br>  Die Lösung, die jetzt in so_5_extra in Form des Namespace so_5 :: extra :: revocable_timer implementiert ist, ist sehr einfach: Durch spezielles Senden einer ausstehenden oder periodischen Nachricht wird ein spezieller Umschlag erstellt, in dem sich nicht nur die Nachricht selbst, sondern auch das widerrufene Atomflag befindet.  Wenn dieses Flag gelöscht ist, wird die Nachricht als relevant angesehen.  Wenn gesetzt, gilt die Nachricht als zurückgezogen. <br><br>  Wenn die Hook-Methode für den Umschlag aufgerufen wird, überprüft der Umschlag den Wert des widerrufenen Flags.  Wenn das Flag gesetzt ist, gibt der Umschlag keine Nachricht aus.  Somit wird die Nachricht nicht verarbeitet, selbst wenn der Timer es bereits geschafft hat, die Nachricht in die Warteschlange des Empfängers zu stellen. <br><br><h3>  Schnittstellenerweiterung abstract_message_box_t </h3><br>  Das Hinzufügen der Envelope_t-Schnittstelle ist nur ein Teil der Implementierung von Envelopes in SObjectizer.  Der zweite Teil berücksichtigt die Tatsache, dass Umschläge im Nachrichtenübermittlungsmechanismus im SObjectizer vorhanden sind. <br><br>  Hier konnte man leider nicht darauf verzichten, Änderungen für den Benutzer sichtbar zu machen.  Insbesondere in der Klasse abstract_message_box_t, die die Schnittstelle aller Postfächer in SObjectizer definiert, musste eine weitere virtuelle Methode hinzugefügt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_deliver_enveloped_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::type_index &amp; msg_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> overlimit_reaction_deep )</span></span></span></span>;</code> </pre> <br>  Diese Methode ist für die Zustellung eines Nachrichtenumschlags mit einer Nachricht vom Typ msg_type an den Empfänger verantwortlich.  Eine solche Lieferung kann sich in den Implementierungsdetails unterscheiden, je nachdem, um welche Art von Mbox es sich handelt. <br><br>  Beim Hinzufügen von do_deliver_enveloped_msg () zu abstract_message_box_t hatten wir die Wahl: es zu einer rein virtuellen Methode zu machen oder eine Standardimplementierung anzubieten. <br><br>  Wenn wir do_deliver_enveloped_msg () zu einer rein virtuellen Methode machen würden, würden wir die Kompatibilität zwischen Versionen von SObjectizer in Zweig 5.5 unterbrechen.  Schließlich müssten Benutzer, die ihre eigenen Mbox-Implementierungen geschrieben haben, beim Wechsel zu SObjectizer-5.5.23 ihre eigenen Mboxes ändern, da sie sonst nicht mit der neuen Version von SObjectizer kompilieren könnten. <br><br>  Wir wollten dies nicht, also haben wir do_deliver_enveloped_msg () in Version 5.5.23 nicht zu einer rein virtuellen Methode gemacht.  Es hat eine Standardimplementierung, die nur eine Ausnahme auslöst.  Auf diese Weise können benutzerdefinierte Benutzer-mbox-s normal mit normalen Nachrichten weiterarbeiten, lehnen jedoch automatisch die Annahme von Umschlägen ab.  Wir fanden dieses Verhalten akzeptabler.  Darüber hinaus ist es unwahrscheinlich, dass Umschläge mit Nachrichten in der Anfangsphase weit verbreitet sind, und es ist unwahrscheinlich, dass in den "wilden" benutzerdefinierten Implementierungen von SObjectizer-Mboxen häufig gefunden werden;) <br><br>  Darüber hinaus besteht bei weitem keine Wahrscheinlichkeit, dass in nachfolgenden Hauptversionen von SObjectizer, in denen die Kompatibilität mit Zweig 5.5 nicht untersucht wird, die Schnittstelle abstract_message_box_t wesentliche Änderungen erfährt.  Aber wir sind uns schon voraus ... <br><br><h2>  So senden Sie Umschläge mit Nachrichten </h2><br>  SObjectizer-5.5.23 selbst bietet keine einfache Möglichkeit zum Senden von Umschlägen.  Es wird davon ausgegangen, dass ein bestimmter Umschlagtyp und geeignete Werkzeuge für eine bestimmte Aufgabe entwickelt werden, um Umschläge eines bestimmten Typs bequem zu versenden.  Ein Beispiel hierfür ist in <a href="">so_5 :: extra :: revocable_timer</a> zu sehen, wo Sie nicht nur den Umschlag senden, sondern dem Benutzer auch eine spezielle timer_id geben müssen. <br><br>  Für einfachere Situationen können Sie die Tools von <a href="">so_5 :: extra :: Enveloped_msg verwenden</a> .  So wird beispielsweise eine Nachricht mit einem festgelegten Limit für die Zustellzeit gesendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// make     . so_5::extra::enveloped_msg::make&lt;my_message&gt;(... /*    */) // envelope         . //  5s        . .envelope&lt;so_5::extra::enveloped_msg::time_limited_delivery_t&gt;(5s) //        . .send_to(destination);</span></span></code> </pre> <br><h2>  Damit alles Spaß macht: Umschläge in Umschlägen </h2><br>  Umschläge sind so konzipiert, dass sie einige Nachrichten in sich tragen.  Aber welche? <br><br>  Beliebig. <br><br>  Und das bringt uns zu einer interessanten Frage: Ist es möglich, einen Umschlag in einen anderen Umschlag zu stecken? <br><br>  Ja, das kannst du.  So viel du willst.  Die Verschachtelungstiefe wird nur durch den gesunden Menschenverstand des Entwicklers und die Tiefe des Stapels für den rekursiven Aufruf handler_found_hook / transformation_hook begrenzt. <br><br>  Gleichzeitig richtet sich SObjectizer an die Entwickler eigener Umschläge: Der Umschlag sollte nicht darüber nachdenken, was sich darin befindet - eine bestimmte Nachricht oder ein anderer Umschlag.  Wenn die Hook-Methode für den Umschlag aufgerufen wird und der Umschlag entscheidet, dass er seinen Inhalt angeben kann, ruft der Umschlag einfach invoke () auf handler_invoker_t auf und übergibt in invoke () einen Link zu seinem Inhalt.  Und schon invoke () im Inneren wird herausfinden, womit es zu tun hat.  Wenn dies ein anderer Umschlag ist, ruft invoke () selbst die erforderliche Hook-Methode für diesen Umschlag auf. <br><br>  Mit dem oben gezeigten Toolkit von so_5 :: extra :: Enveloped_msg kann der Benutzer mehrere verschachtelte Umschläge wie folgt erstellen: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;my_message&gt;(...) <span class="hljs-comment"><span class="hljs-comment">// ,        my_message. .envelope&lt;inner_envelope_type&gt;(...) // ,      inner_envelope_type. .envelope&lt;outer_envelope_type&gt;(...) .send_to(destination);</span></span></code> </pre> <br><h1>  Einige Beispiele für die Verwendung von Umschlägen </h1><br>  Nachdem wir die Interna von SObjectizer-5.5.23 durchgearbeitet haben, ist es an der Zeit, mit dem für Benutzer nützlicheren Anwendungsteil fortzufahren.  Im Folgenden finden Sie einige Beispiele, die entweder auf dem basieren, was bereits in so_5_extra implementiert ist, oder die Tools von so_5_extra verwenden. <br><br><h2>  Widerrufliche Timer </h2><br>  Da diese ganze Küche mit Umschlägen konzipiert wurde, um das Problem des garantierten Abrufs von Timer-Nachrichten zu lösen, wollen wir sehen, was am Ende passiert ist.  Wir werden das Beispiel aus so_5_extra-1.2.0 verwenden, das die Tools aus dem neuen Namespace so_5 :: extra :: revocable_timer verwendet: <br><br><div class="spoiler">  <b class="spoiler_title">Beispielcode mit widerruflichen Timern</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/revocable_timer/pub.hpp&gt; #include &lt;so_5/all.hpp&gt; namespace timer_ns = so_5::extra::revocable_timer; class example_t final : public so_5::agent_t { //  ,       //    . struct first_delayed final : public so_5::signal_t {}; struct second_delayed final : public so_5::signal_t {}; struct last_delayed final : public so_5::signal_t {}; struct periodic final : public so_5::signal_t {}; //    . timer_ns::timer_id_t m_first; timer_ns::timer_id_t m_second; timer_ns::timer_id_t m_last; timer_ns::timer_id_t m_periodic; public : example_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self() .event( &amp;example_t::on_first_delayed ) .event( &amp;example_t::on_second_delayed ) .event( &amp;example_t::on_last_delayed ) .event( &amp;example_t::on_periodic ); } void so_evt_start() override { using namespace std::chrono_literals; //      ... m_first = timer_ns::send_delayed&lt; first_delayed &gt;( *this, 100ms ); m_second = timer_ns::send_delayed&lt; second_delayed &gt;( *this, 200ms ); m_last = timer_ns::send_delayed&lt; last_delayed &gt;( *this, 300ms ); // ...    . m_periodic = timer_ns::send_periodic&lt; periodic &gt;( *this, 75ms, 75ms ); //    220ms.       //    first_delaye, second_delayed  //    periodic. std::cout &lt;&lt; "hang the agent..." &lt;&lt; std::flush; std::this_thread::sleep_for( 220ms ); std::cout &lt;&lt; "done" &lt;&lt; std::endl; } private : void on_first_delayed( mhood_t&lt;first_delayed&gt; ) { std::cout &lt;&lt; "first_delayed received" &lt;&lt; std::endl; //   second_delayed  periodic. //          ,  //       . m_second.revoke(); m_periodic.revoke(); } void on_second_delayed( mhood_t&lt;second_delayed&gt; ) { std::cout &lt;&lt; "second_delayed received" &lt;&lt; std::endl; } void on_last_delayed( mhood_t&lt;last_delayed&gt; ) { std::cout &lt;&lt; "last_delayed received" &lt;&lt; std::endl; so_deregister_agent_coop_normally(); } void on_periodic( mhood_t&lt;periodic&gt; ) { std::cout &lt;&lt; "periodic received" &lt;&lt; std::endl; } }; int main() { so_5::launch( [](so_5::environment_t &amp; env) { env.register_agent_as_coop( "example", env.make_agent&lt;example_t&gt;() ); } ); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Was haben wir hier? <br><br>  Wir haben einen Agenten, der zuerst mehrere Timer-Nachrichten initiiert und dann seinen Arbeitsthread für eine Weile blockiert.  Während dieser Zeit schafft es der Zeitgeber, dem Agenten aufgrund der ausgelösten Zeitgeber mehrere Anforderungen in die Warteschlange zu stellen: mehrere periodische Instanzen, jeweils eine erste und eine zweite Verzögerung. <br><br>  Wenn ein Agent seinen Thread entsperrt, sollte er dementsprechend die erste periodische und die erste Verzögerung erhalten.  Bei der Verarbeitung von first_delayed bricht der Agent die Zustellung von periodic und second_delayed ab.  Daher sollten diese Signale den Agenten nicht erreichen, unabhängig davon, ob sie sich bereits in der Warteschlange des Agenten befinden oder nicht (und sie sind es). <br><br>  Wir betrachten das Ergebnis des Beispiels: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">hang</span></span> the agent...done periodic received first_delayed received last_delayed received</code> </pre> <br>  Ja, das ist es.  Habe die erste periodische und erste_verzögerte.  Dann gibt es weder periodische noch zweite Verzögerungen. <br><br>  Wenn wir im Beispiel jedoch die "Timer" von so_5 :: extra :: revocable_timer durch die Standard-Timer von SObjectizer ersetzen, ist das Ergebnis anders: Alle periodischen und zweiten verzögerten Signalinstanzen, die bereits in die Warteschlange des Agenten eingetreten sind, erreichen den Agenten. <br><br><h2>  Nachrichten mit eingeschränkter Lieferzeit </h2><br>  Eine andere nützliche Sache, die manchmal in so_5_extra-1.2.0 verfügbar sein wird, ist die zeitliche Zustellung von Nachrichten.  Beispielsweise sendet der request_handler-Agent eine verify_signature-Nachricht an den crypto_master-Agenten.  Gleichzeitig möchte request_handler, dass verify_signature innerhalb von 5 Sekunden geliefert wird.  Wenn dies nicht der Fall ist, macht die Verarbeitung von verity_signature keinen Sinn. Der request_handler-Agent beendet seine Arbeit bereits. <br><br>  Und der crypto_master-Agent ist so ein Kamerad, der sich gerne als „Engpass“ herausstellt: Manchmal beginnt er langsamer zu werden.  In einem solchen Moment werden Nachrichten in der Warteschlange angesammelt, z. B. die obige verify_signature, die warten kann, bis crypto_master entlastet wird. <br><br>  Angenommen, request_handler hat eine verify_signature-Nachricht an den crypto_master-Agenten gesendet, aber dann war crypto_master festgefahren und blieb 10 Sekunden lang hängen.  Der request_handler-Agent ist bereits "abgefallen", d. H.  schickte bereits allen einen Denial-of-Service und beendete seine Arbeit.  Die Nachricht verify_signature bleibt jedoch in der Warteschlange crypto_master!  Wenn crypto_master also "entklebt", nimmt es diese Nachricht auf und verarbeitet sie.  Dies ist zwar nicht mehr notwendig. <br><br>  Mit dem neuen Umschlag so_5 :: extra :: Enveloped_msg :: time_limited_delivery_t können wir dieses Problem lösen: Der Request_handler-Agent sendet die im Umschlag enthaltene verify_signature time_limited_delivery_t mit einem Lieferzeitlimit: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;verify_signature&gt;(...) .envelope&lt;so_5::extra::enveloped_msg::<span class="hljs-keyword"><span class="hljs-keyword">time_limited_delivery_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>s) .send_to(crypto_master_mbox);</code> </pre> <br>  Wenn crypto_master nun "klebt" und es nicht schafft, innerhalb von 5 Sekunden die Verifizierungssignatur zu erreichen, sendet der Umschlag diese Nachricht einfach nicht zur Verarbeitung.  Und crypto_master wird keine Arbeit machen, die sonst niemand braucht. <br><br><h2>  Empfängerlieferberichte </h2><br>  Und schließlich ein Beispiel für eine merkwürdige Sache, die weder in SObjectizer noch in so_5_extra regelmäßig implementiert wird, sondern unabhängig voneinander ausgeführt werden kann. <br><br>  Manchmal möchten Sie vom SObjectizer so etwas wie eine "Zustellungsbericht" -Nachricht an den Empfänger erhalten.  Immerhin ist es eine Sache, als die Nachricht den Empfänger erreichte, aber der Empfänger aus irgendeinem Grund nicht darauf antwortete.  Eine andere Sache ist, wenn die Nachricht den Empfänger überhaupt nicht erreicht hat.  Beispielsweise wurde es durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Agentenüberlastungsschutzmechanismus</a> blockiert.  Im ersten Fall kann eine Nachricht, auf die wir nicht auf eine Antwort gewartet haben, weggelassen werden.  Im zweiten Fall kann es jedoch sinnvoll sein, die Nachricht nach einiger Zeit erneut zu senden. <br><br>  Nun werden wir uns überlegen, wie der einfachste Mechanismus von „Lieferberichten“ mithilfe von Umschlägen implementiert werden kann. <br><br>  Also machen wir zuerst die notwendigen vorbereitenden Schritte: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/enveloped_msg/just_envelope.hpp&gt; #include &lt;so_5_extra/enveloped_msg/send_functions.hpp&gt; #include &lt;so_5/all.hpp&gt; using namespace std::chrono_literals; namespace envelope_ns = so_5::extra::enveloped_msg; using request_id_t = int;</span></span></span></span></code> </pre><br>  Jetzt können wir die Nachrichten definieren, die im Beispiel verwendet werden.  Die erste Nachricht ist eine Aufforderung, einige von uns benötigte Aktionen auszuführen.  Und die zweite Nachricht ist eine Bestätigung, dass die erste Nachricht den Empfänger erreicht hat: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_id_t</span></span> m_id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delivery_receipt_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   request_t::m_id   request_t. request_id_t m_id; };</span></span></code> </pre> <br>  Als nächstes können wir einen Agentenprozessor_t definieren, der Nachrichten vom Typ request_t verarbeitet.  Die Verarbeitung erfolgt jedoch mit der Nachahmung des „Klebens“.  Das heißt,  Es verarbeitet request_t und ändert anschließend seinen Status von st_normal in st_busy.  Im Zustand st_busy wird nichts unternommen und alle eingehenden Nachrichten werden ignoriert. <br><br>  Dies bedeutet, dass wenn der Prozessor_t-Agent drei aufeinanderfolgende request_t-Nachrichten sendet, er die erste verarbeitet und die anderen beiden ausgelöst werden, weil  Bei der Verarbeitung der ersten Nachricht wechselt der Agent zu st_busy und ignoriert, was zu ihm kommt, während er sich in st_busy befindet. <br><br>  In st_busy verbringt Agent process_t 2 Sekunden. Danach kehrt er wieder zu st_normal zurück und ist bereit, neue Nachrichten zu verarbeiten. <br><br>  So sieht der Agent process_t aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   .     //   . state_t st_normal{this, "normal"}; //  " ".   . state_t st_busy{this, "busy"}; public: processor_t(context_t ctx) : so_5::agent_t{std::move(ctx)} { this &gt;&gt;= st_normal; st_normal.event(&amp;processor_t::on_request); //     ,    . //  2   ,    st_normal. st_busy.time_limit(2s, st_normal); } private: void on_request(mhood_t&lt;request_t&gt; cmd) { std::cout &lt;&lt; "processor: on_request(" &lt;&lt; cmd-&gt;m_id &lt;&lt; ", " &lt;&lt; cmd-&gt;m_data &lt;&lt; ")" &lt;&lt; std::endl; this &gt;&gt;= st_busy; } };</span></span></code> </pre> <br>  Jetzt können wir den Agenten request_generator_t definieren, der eine Reihe von Anforderungen enthält, die an processor_t gesendet werden müssen.  Der Agent request_generator_t sendet alle 3 Sekunden das gesamte Paket und wartet dann auf die Zustellbestätigung in Form von Delivery_receipt_t. <br><br>  Wenn Delivery_Recept_t eintrifft, wirft der Agent request_generator_t die gelieferte Anfrage aus dem Bundle.  Wenn die Packung vollständig leer ist, ist das Beispiel abgeschlossen.  Wenn noch etwas übrig ist, wird das verbleibende Paket erneut gesendet, wenn das nächste Mal erneut gesendet wird. <br><br>  Hier ist also der Agent-Code request_generator_t.  Es ist ziemlich voluminös, aber primitiv.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie können nur auf die Interna der Methode send_requests () achten, in der request_t-Nachrichten gesendet werden, die in einem speziellen Umschlag eingeschlossen sind. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requests_generator_t Agentencode</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests_generator_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_processor; //  ,       . std::map&lt;request_id_t, std::string&gt; m_requests; struct resend_requests final : public so_5::signal_t {}; public: requests_generator_t(context_t ctx, so_5::mbox_t processor) : so_5::agent_t{std::move(ctx)} , m_processor{std::move(processor)} { so_subscribe_self() .event(&amp;requests_generator_t::on_delivery_receipt) .event(&amp;requests_generator_t::on_resend); } void so_evt_start() override { //    . m_requests.emplace(0, "First"); m_requests.emplace(1, "Second"); m_requests.emplace(2, "Third"); m_requests.emplace(3, "Four"); //  . send_requests(); } private: void on_delivery_receipt(mhood_t&lt;delivery_receipt_t&gt; cmd) { std::cout &lt;&lt; "request delivered: " &lt;&lt; cmd-&gt;m_id &lt;&lt; std::endl; m_requests.erase(cmd-&gt;m_id); if(m_requests.empty()) //    .  . so_deregister_agent_coop_normally(); } void on_resend(mhood_t&lt;resend_requests&gt;) { std::cout &lt;&lt; "time to resend requests, pending requests: " &lt;&lt; m_requests.size() &lt;&lt; std::endl; send_requests(); } void send_requests() { for(const auto &amp; item : m_requests) { std::cout &lt;&lt; "sending request: (" &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; ")" &lt;&lt; std::endl; envelope_ns::make&lt;request_t&gt;(item.first, item.second) .envelope&lt;custom_envelope_t&gt;(so_direct_mbox(), item.first) .send_to(m_processor); } //       3 . so_5::send_delayed&lt;resend_requests&gt;(*this, 3s); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir Nachrichten und Agenten, die diese Nachrichten zur Kommunikation verwenden müssen. </font><font style="vertical-align: inherit;">Es war nur noch eine Kleinigkeit übrig - irgendwie kamen Zustellungsnachrichten an, wenn request_t an processor_t übermittelt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht mit diesem Umschlag:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> custom_envelope_t final : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> envelope_ns::just_envelope_t { //     . const so_5::mbox_t m_to; // ID  . const request_id_t m_id; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: custom_envelope_t(so_5::message_ref_t payload, so_5::mbox_t <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, request_id_t id) : envelope_ns::just_envelope_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(payload)} , m_to{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>)} , m_id{id} {} <span class="hljs-type"><span class="hljs-type">void</span></span> handler_found_hook(handler_invoker_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>) noexcept override { //    ,     . //     . so_5::send&lt;delivery_receipt_t&gt;(m_to, m_id); //      . envelope_ns::just_envelope_t::handler_found_hook(<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen gibt es nichts Kompliziertes. </font><font style="vertical-align: inherit;">Wir erben von so_5 :: extra :: Enveloped_msg :: just_envelope_t. </font><font style="vertical-align: inherit;">Dies ist ein zusätzlicher Umschlagtyp, der die darin enthaltene Nachricht speichert und die grundlegende Implementierung der Hooks </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handler_found_hook () und transformation_hook () bereitstellt. </font><font style="vertical-align: inherit;">Daher können wir nur die Attribute speichern, die wir in custom_envelope_t benötigen, und Delivery_receipt_t innerhalb des Hooks handler_found_hook () senden.</font></font><br><br>  Das ist in der Tat alles.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir dieses Beispiel ausführen, erhalten wir Folgendes: </font></font><br><br><pre> <code class="hljs vbscript">sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, First) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">0</span></span>, First) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">3</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">2</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">1</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem muss ich sagen, dass in der Praxis ein so einfacher custom_envelope_t zum Generieren von Lieferberichten kaum geeignet ist. </font><font style="vertical-align: inherit;">Wenn sich jedoch jemand für dieses Thema interessiert, kann es in den Kommentaren besprochen werden, ohne das Volumen des Artikels zu erhöhen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was könnte man noch mit Umschlägen machen? </font></font></h1><br>  Gute Frage!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf die wir selbst keine umfassende Antwort haben. </font><font style="vertical-align: inherit;">Wahrscheinlich sind die Möglichkeiten nur durch die Vorstellungskraft der Benutzer begrenzt. </font><font style="vertical-align: inherit;">Nun, wenn für die Verwirklichung von Fantasien in SObjectizer etwas fehlt, dann kann uns dies gesagt werden. </font><font style="vertical-align: inherit;">Wir hören immer zu. </font><font style="vertical-align: inherit;">Und vor allem manchmal sogar :)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integration von Agenten in mchain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etwas ernster gesagt, das ist eine weitere Funktion, die ich von Zeit zu Zeit haben möchte und die sogar für so_5_extra-1.2.0 geplant war. Was aber höchstwahrscheinlich nicht in Release 1.2.0 fallen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es geht darum, die Integration von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Agenten zu </font><font style="vertical-align: inherit;">vereinfachen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsache ist, dass ursprünglich Ketten zu SObjectizer hinzugefügt wurden, um die Kommunikation von Agenten mit anderen Teilen der Anwendung zu vereinfachen, die ohne Agenten geschrieben wurden. Beispielsweise gibt es den Hauptthread der Anwendung, auf dem der Benutzer über die GUI interagiert. Und es gibt mehrere Agenten, die im Hintergrund "harte" Arbeit leisten. Das Senden einer Nachricht an einen Agenten aus dem Hauptthread ist kein Problem: Rufen Sie einfach reguläres Senden auf. Aber wie übertrage ich Informationen zurück?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierzu wurden mchain-s hinzugefügt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Laufe der Zeit stellte sich jedoch heraus, dass Ketten eine viel größere Rolle spielen können. Grundsätzlich ist es möglich, Multithread-Anwendungen auf SObjectizer ohne Agenten zu erstellen, nur auf mchain-ahs (weitere Details </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Und Sie können mchain-s verwenden, um die Belastung der Agenten auszugleichen. Als Mechanismus zur Lösung von Produzenten-Konsumenten-Problemen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem mit dem Produzenten-Konsumenten ist, dass wir in Schwierigkeiten sind, wenn der Produzent Nachrichten schneller generiert, als der Konsument sie verarbeiten kann. Die Nachrichtenwarteschlangen werden größer, die Leistung kann sich mit der Zeit verschlechtern oder die Anwendung stürzt aufgrund von Speicherauslastung vollständig ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die übliche Lösung, die wir in diesem Fall vorgeschlagen haben, ist die Verwendung</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Paar Sammler-Performer-Agenten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie können auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachrichtenlimits verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (entweder als Hauptschutzmechanismus oder als Ergänzung zu Collector-Performer). Das Schreiben von Collector-Performer erfordert jedoch zusätzliche Arbeit vom Programmierer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber Ketten könnten für diese Zwecke mit minimalem Aufwand des Entwicklers verwendet werden. Der Produzent würde also die nächste Nachricht in die Kette einfügen, und der Verbraucher würde Nachrichten aus dieser Kette entgegennehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist jedoch, dass es für einen Agenten als Agent nicht sehr bequem ist, mit mchain über die verfügbaren Funktionen receive () und select () zu arbeiten. Und diese Unannehmlichkeiten könnten mit Hilfe eines Tools zur Integration von Agenten und Mchain-s behoben werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Entwicklung eines solchen Tools müssen mehrere Probleme gelöst werden. Wenn eine Nachricht beispielsweise in mchain eintrifft, an welchem ​​Punkt sollte sie aus mchain extrahiert werden? Wenn der Verbraucher frei ist und nichts verarbeitet, können Sie die Nachricht sofort von mchain abholen und an den Verbraucheragenten weitergeben. Wenn eine Nachricht bereits von mchain an den Verbraucher gesendet wurde, konnte er diese Nachricht noch nicht verarbeiten, aber eine neue Nachricht ist bereits in mchain eingetroffen ... Was ist in diesem Fall zu tun? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Spekulationen, dass Umschläge in diesem Fall helfen könnten. Wenn wir also die erste Nachricht von mchain nehmen und an den Verbraucher senden, verpacken wir diese Nachricht in einen speziellen Umschlag. Wenn der Umschlag feststellt, dass die Nachricht zugestellt und verarbeitet wurde, fordert er die nächste Nachricht von mchain an (falls vorhanden).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich ist hier nicht alles so einfach. </font><font style="vertical-align: inherit;">Aber bisher sieht es ziemlich lösbar aus. </font><font style="vertical-align: inherit;">Und ich hoffe, ein ähnlicher Mechanismus wird in einer der nächsten Versionen von so_5_extra erscheinen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Öffnen wir die Büchse der Pandora? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte beachtet werden, dass bei uns die zusätzlichen Fähigkeiten selbst doppelte Gefühle hervorrufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits haben Umschläge bereits erlaubt / erlaubt, Dinge zu tun, die zuvor erwähnt wurden (aber nur von etwas geträumt haben). </font><font style="vertical-align: inherit;">Dies ist beispielsweise eine garantierte Stornierung von Zeitgebern und eine Einschränkung der Zustellzeit, Zustellberichte und die Möglichkeit, eine zuvor gesendete Nachricht abzurufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits ist nicht klar, wozu dies später führen wird. </font><font style="vertical-align: inherit;">Schließlich können Sie aus jeder Gelegenheit ein Problem machen, wenn Sie diese Gelegenheit nutzen, wo Sie sie brauchen und wo nicht. </font><font style="vertical-align: inherit;">Vielleicht öffnen wir die Büchse von Pandora und stellen uns immer noch nicht vor, was uns erwartet? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt nur geduldig zu sein und zu sehen, wohin uns das alles führen wird.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Über die unmittelbaren Entwicklungspläne von SObjectizer, anstatt abzuschließen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle einer Schlussfolgerung möchte ich darüber sprechen, wie wir die nahe (und nicht nur) Zukunft von SObjectizer sehen. Wenn jemand mit etwas in unseren Plänen nicht zufrieden ist, können Sie sich äußern und beeinflussen, wie sich SObjectizer-5 entwickeln wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ersten Beta-Versionen von SObjectizer-5.5.23 und so_5_extra-1.2.0 sind bereits behoben und stehen zum Download und für Experimente zur Verfügung. Im Bereich Dokumentation und Anwendungsfälle bleibt noch viel zu tun. Daher ist die offizielle Veröffentlichung im ersten Jahrzehnt des Novembers geplant. Wenn es früher klappt, machen wir es früher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Veröffentlichung von SObjectizer-5.5.23 scheint zu bedeuten, dass die Entwicklung von Zweig 5.5 zu Ende geht. Die allererste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veröffentlichung in diesem Thread fand vor vier Jahren im Oktober 2014 statt.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seitdem hat sich SObjectizer-5 innerhalb des 5.5-Zweigs weiterentwickelt, ohne dass wesentliche Änderungen zwischen den Versionen vorgenommen wurden. Es war nicht einfach. Vor allem angesichts der Tatsache, dass wir die ganze Zeit auf Compiler zurückblicken mussten, die C ++ 11 bei weitem nicht optimal unterstützen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sehen wir keinen Grund, auf die Kompatibilität innerhalb des 5.5-Zweigs und insbesondere auf ältere C ++ - Compiler zurückzublicken. Was 2014 gerechtfertigt sein könnte, als sich C ++ 14 gerade auf die offizielle Einführung vorbereitete und C ++ 17 noch nicht in Sicht war, sieht es jetzt ganz anders aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem hat sich in SObjectizer-5.5 selbst bereits eine ganze Reihe von Rakes und Backups angesammelt, die aufgrund derselben Kompatibilität aufgetreten sind und die weitere Entwicklung von SObjectizer erschweren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher werden wir in den kommenden Monaten nach folgendem Szenario handeln: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Entwicklung der nächsten Version von so_5_extra, in der ich Tools hinzufügen möchte, um das Schreiben von Tests für Agenten zu vereinfachen. Ob es so_5_extra-1.3.0 sein wird (d. H. Mit brechenden Änderungen relativ zu 1.2.0) oder ob es so_5_extra-1.2.1 sein wird (d. H. Ohne brechende Änderungen), ist noch nicht klar. Mal sehen, wie es geht. Es ist nur klar, dass die nächste Version von so_5_extra auf SObjectizer-5.5 basiert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1a. Wenn Sie für die nächste Version von so_5_extra in SObjectizer-5.5 zusätzliche Aktionen ausführen müssen, wird die nächste Version 5.5.24 veröffentlicht. Wenn für so_5_extra keine Verbesserungen am Kernel von SObjectizer erforderlich sind, stellt sich heraus, dass Version 5.5.23 die letzte wichtige Version im Rahmen von Zweig 5.5 ist. Kleinere Bugfixes werden veröffentlicht. Die Entwicklung von Zweig 5.5 selbst stoppt jedoch in Version 5.5.23 oder 5.5.24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Dann wird eine Version von SObjectizer-5.6.0 veröffentlicht, die einen neuen Zweig eröffnet. In Zweig 5.6 werden wir den SObjectizer-Code von allen angesammelten Krücken und Backups sowie von altem Papierkorb entfernen, der seit langem als veraltet markiert ist. Es ist wahrscheinlich, dass einige Dinge einem Refactoring unterzogen werden (z. B. kann abstract_message_box_t geändert werden), aber kaum Kardinal. Die Grundprinzipien der Arbeit und die charakteristischen Merkmale von SObjectizer-5.5 in SObjectizer-5.6 bleiben in derselben Form. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.6 benötigt bereits C ++ 14 (zumindest auf GCC-5.5-Ebene). Visual C ++ - Compiler unter VC ++ 15 (aus Visual Studio 2017) werden nicht unterstützt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir betrachten Zweig 5.6 als einen stabilen Zweig von SObjectizer, der relevant sein wird, bis die erste Version von SObjectizer-5.7 erscheint.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich möchte die Version 5.6.0 Anfang 2019, vorläufig im Februar, veröffentlichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Nach der Stabilisierung von Zweig 5.6 möchten wir mit der Arbeit an Zweig 5.7 beginnen, in dem wir einige Grundprinzipien der Arbeit von SObjectizer überarbeiten können. Verlassen Sie beispielsweise öffentliche Disponenten vollständig und lassen Sie nur private übrig. Wiederholen Sie den Mechanismus der Genossenschaften und ihre Eltern-Kind-Beziehungen, um den Engpass bei der Registrierung / Abmeldung von Genossenschaften zu beseitigen. Entfernen Sie die Teilung durch Nachricht / Signal. Erlauben Sie nur send / send_delayed / send_periodic, Nachrichten zu senden, und verbergen Sie die Methoden Deliver_message und Schedule_Timer "unter der Haube". Ändern Sie den Mechanismus zum Versenden von Nachrichten so, dass Sie dynamic_casts entweder vollständig aus diesem Prozess entfernen oder auf ein Minimum reduzieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen gibt es einen Ort, an dem man sich umdrehen kann. Gleichzeitig benötigt SObjectizer-5.7 bereits C ++ 17, ohne Rücksicht auf C ++ 14. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich Dinge ohne rosa Brille ansehen, ist es gut, wenn Release 5.7.0 im Spätherbst 2019 stattfindet. Die Hauptarbeitsversion von SObjectizer für 2019 wird Zweig 5.6 sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Parallel dazu wird sich so_5_extra entwickeln. Wahrscheinlich wird die Version so_5_extra-2 zusammen mit SObjectizer-5.6 veröffentlicht, das im Laufe des Jahres 2019 neue Funktionen enthalten wird, jedoch auf SObjectizer-5.6 basiert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher sehen wir selbst eine fortschreitende Entwicklung für SObjectizer-5 mit einer schrittweisen Überarbeitung einiger der Grundprinzipien von SObjectizer-5. Gleichzeitig werden wir versuchen, dies so reibungslos wie möglich zu gestalten, damit mit minimalen Schmerzen von einer Version zur anderen gewechselt werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn jedoch jemand dramatischere und bedeutendere Änderungen von SObjectizer wünscht, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben wir einige Gedanken dazu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kurz gesagt: Sie können SObjectizer nach Belieben neu erstellen, um SObjectizer-6 für eine andere Programmiersprache zu implementieren. Wir werden dies jedoch nicht vollständig auf eigene Kosten tun, da dies mit der Entwicklung von SObjectizer-5 geschieht.</font></font><br><br>  Das ist wahrscheinlich alles.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kommentare </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum vorherigen Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erwiesen sich als gute und konstruktive Diskussion. </font><font style="vertical-align: inherit;">Es wäre nützlich für uns, wenn diesmal eine ähnliche Diskussion stattfinden würde. </font><font style="vertical-align: inherit;">Wie immer sind wir bereit, alle Fragen zu beantworten, aber die vernünftigen und mit Vergnügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und den geduldigsten Lesern, die diese Zeilen erreicht haben, vielen Dank für die Zeit, die sie mit dem Lesen des Artikels verbracht haben.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426983/">https://habr.com/ru/post/de426983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426973/index.html">Firmensandwiches</a></li>
<li><a href="../de426975/index.html">Joker 2018: Das Unmögliche ist möglich</a></li>
<li><a href="../de426977/index.html">LibreOffice: der Albtraum eines Buchhalters</a></li>
<li><a href="../de426979/index.html">So lernen Sie kostenlos Englisch: 3 gängige Tools und detaillierte Anweisungen für jedes</a></li>
<li><a href="../de426981/index.html">10 Tricks für erweitertes Dashboarding in Splunk. Teil 1</a></li>
<li><a href="../de426985/index.html">Kubebox und andere Konsolen-Shells für Kubernetes</a></li>
<li><a href="../de426987/index.html">Lerne OpenGL. Lektion 6.3 - Bildbasierte Beleuchtung. Diffuse Bestrahlung</a></li>
<li><a href="../de426991/index.html">Startup Digest: 10 bevorstehende IT-Events in Moskau</a></li>
<li><a href="../de426993/index.html">Muss ich C lernen, um zu verstehen, wie ein Computer funktioniert?</a></li>
<li><a href="../de426995/index.html">Recycling schadet sowohl Produkten als auch Mitarbeitern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>