<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèø üöΩ ü§¶üèø Neu in SObjectizer-5.5.23: Wunscherf√ºllung oder Pandoras Box? üë©üèø‚Äçüî¨ üèê üÜî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine Fortsetzung eines vor einem Monat ver√∂ffentlichten Reflexionsartikels: ‚Äû Ist es einfach, dem alten Framework neue Funktionen h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Neu in SObjectizer-5.5.23: Wunscherf√ºllung oder Pandoras Box?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426983/"><img src="https://habrastorage.org/webt/kt/xf/7o/ktxf7oduhnd0zuhd_tpaju7p_em.jpeg"><br><br>  Dieser Artikel ist eine Fortsetzung eines vor einem Monat ver√∂ffentlichten Reflexionsartikels: ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ist es einfach, dem alten Framework neue Funktionen hinzuzuf√ºgen? Die Qual der Wahl am Beispiel der Entwicklung von SObjectizer</a> ‚Äú.  In diesem Artikel wurde die Aufgabe beschrieben, die wir in der n√§chsten Version von SObjectizer l√∂sen wollten, zwei L√∂sungsans√§tze untersucht und die Vor- und Nachteile der einzelnen Ans√§tze aufgelistet. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufe der</a> Zeit wurde einer der Ans√§tze implementiert und neue Versionen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> sowie das dazugeh√∂rige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt so_5_extra</a> , das bereits als ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tief atmen</a> ‚Äú bezeichnet wurde.  Sie k√∂nnen buchst√§blich nehmen und versuchen. <br><br>  Heute werden wir dar√ºber sprechen, was getan wurde, warum es getan wurde, wozu es gef√ºhrt hat.  Wenn jemand daran interessiert ist, zu verfolgen, wie sich eines der wenigen Live-, plattform√ºbergreifenden und Open-Actor-Frameworks f√ºr C ++ entwickelt, sind Sie bei cat willkommen. <br><a name="habracut"></a><br><h1>  Wie hat alles angefangen? </h1><br>  Alles begann mit dem Versuch, das Problem der garantierten Stornierung von Timern zu l√∂sen.  Das Problem besteht im Wesentlichen darin, dass der Programmierer beim Senden einer verz√∂gerten oder periodischen Nachricht die Zustellung der Nachricht abbrechen kann.  Zum Beispiel: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer_id = so_5::send_periodic&lt;my_message&gt;(my_agent, <span class="hljs-number"><span class="hljs-number">10</span></span>s, <span class="hljs-number"><span class="hljs-number">10</span></span>s, ...); ... <span class="hljs-comment"><span class="hljs-comment">// - . // ,    my_message    . timer_id.release(); //      my_message.</span></span></code> </pre> <br>  Nach dem Aufruf von <i>timer_id.release () sendet der</i> Timer keine neuen Instanzen der my_message-Nachricht mehr.  Aber die Kopien, die bereits gesendet wurden und sich in der Warteschlange der Empf√§nger befinden, werden nirgendwo hingehen.  Im Laufe der Zeit werden sie aus denselben Warteschlangen extrahiert und zur Verarbeitung an die Empf√§ngeragenten √ºbertragen. <br><br>  Dieses Problem ist eine Folge der Grundprinzipien des Betriebs von SObjectizer-5 und hat keine einfache L√∂sung, da SObjectizer keine Nachrichten aus Warteschlangen extrahieren kann.  Dies ist nicht m√∂glich, da die Warteschlangen in SObjectizer zu Dispatchern geh√∂ren, die Disponenten unterschiedlich sind und ihre Warteschlangen auch unterschiedlich organisiert sind.  Einschlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es Disponenten, die nicht Teil des SObjectizers sind,</a> und SObjectizer kann im Prinzip nicht wissen, wie diese Dispatcher funktionieren. <br><br>  Im Allgemeinen gibt es eine solche Funktion in den nativen SObjectizer-Timern.  Nicht, dass es Entwickler zu sehr verw√∂hnt.  Es ist jedoch besondere Vorsicht geboten.  Besonders f√ºr Anf√§nger, die sich gerade erst mit dem Framework vertraut machen. <br><br>  Und schlie√ülich gingen die H√§nde so weit, eine L√∂sung f√ºr dieses Problem vorzuschlagen. <br><br><h1>  Welcher L√∂sungsweg wurde gew√§hlt? </h1><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel</a> wurden zwei m√∂gliche Optionen in Betracht gezogen.  Die erste Option erforderte keine √Ñnderungen am Nachrichten√ºbermittlungsmechanismus in SObjectizer, aber der Programmierer musste den Typ der gesendeten / empfangenen Nachricht explizit √§ndern. <br><br>  Die zweite Option erforderte eine √Ñnderung des SObjectizer-Nachrichten√ºbermittlungsmechanismus.  Es wurde dieser Pfad gew√§hlt, da er es dem Empf√§nger der Nachricht erm√∂glichte, die Tatsache zu verbergen, dass die Nachricht auf eine bestimmte Weise gesendet wurde. <br><br><h2>  Was hat sich in SObjectizer ge√§ndert? </h2><br><h3>  Neues Konzept: Umschlag mit Nachricht im Inneren </h3><br>  Die erste Komponente der implementierten L√∂sung ist das Hinzuf√ºgen eines solchen Konzepts als Umschlag zu SObjectizer.  Ein Umschlag ist eine spezielle Nachricht, in der sich die aktuelle Nachricht (Nutzlast) befindet.  SObjectizer liefert den Umschlag mit der Nachricht fast wie gewohnt an den Empf√§nger.  Der grundlegende Unterschied in der Briefumschlagverarbeitung wird erst in der allerletzten Lieferphase festgestellt: <br><br><ul><li>  Bei der Zustellung einer regul√§ren Nachricht sucht der Empf√§ngeragent einfach nach einem Handler f√ºr diesen Nachrichtentyp. Wenn ein solcher Handler gefunden wird, wird der gefundene Handler aufgerufen und die zugestellte Nachricht als Parameter zur√ºckgegeben. </li><li>  und bei Zustellung des Umschlags mit der Nachricht, nachdem der Handler gefunden wurde, wird zuerst versucht, die Nachricht aus dem Umschlag herauszuholen.  Und nur wenn der Umschlag die darin gespeicherte Nachricht enth√§lt, wird der Handler aufgerufen. </li></ul><br>  Hier gibt es zwei wichtige Punkte, die einen gro√üen Einfluss darauf haben, warum und wie Nachrichtenumschl√§ge verwendet werden k√∂nnen. <br><br>  Der erste wichtige Punkt ist, dass eine Nachricht nur dann von einem Umschlag angefordert wird, wenn beim Empf√§nger ein Nachrichtenhandler gefunden wird.  Das hei√üt,  Nur wenn die Nachricht wirklich an den Empf√§nger √ºbermittelt wurde und der Empf√§nger hier und jetzt ist, wird diese Nachricht verarbeitet. <br><br>  Der zweite wichtige Punkt hierbei ist, dass der Umschlag die darin enthaltene Nachricht m√∂glicherweise nicht weitergibt.  Das hei√üt, ein Umschlag kann beispielsweise die aktuelle Uhrzeit √ºberpr√ºfen und feststellen, dass alle Liefertermine vers√§umt wurden und die Nachricht daher nicht mehr relevant ist und nicht mehr verarbeitet werden kann.  Daher gibt der Umschlag die Nachricht nicht aus.  Dementsprechend ignoriert SObjectizer diesen Umschlag einfach und ergreift keine zus√§tzlichen Ma√ünahmen. <br><br><h4>  Wie ist ein Umschlag? </h4><br>  Ein Envelope ist eine Implementierung der Envelope_t-Schnittstelle, die wie folgt definiert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SO_5_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envelope_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-comment"><span class="hljs-comment">// -. //   ,       //    . virtual void handler_found_hook( handler_invoker_t &amp; invoker ) noexcept = 0; //   ,      //     . virtual void transformation_hook( handler_invoker_t &amp; invoker ) noexcept = 0; private : kind_t so5_message_kind() const noexcept override { return kind_t::enveloped_msg; } };</span></span></code> </pre> <br>  Das hei√üt,  Ein Umschlag ist im Wesentlichen dieselbe Nachricht wie alle anderen.  Aber mit einem speziellen Attribut, das von der Methode so5_message_kind () zur√ºckgegeben wird. <br><br>  Der Programmierer kann seine H√ºllkurven entwickeln, die von Envelope_t (oder bequemer von <a href="">so_5 :: extra :: Enveloped_msg :: just_envelope_t</a> ) <a href="">erben,</a> und die Hook-Methoden handler_found_hook () und transformation_hook () √ºberschreiben. <br><br>  Innerhalb der Hook-Methoden entscheidet der Umschlagentwickler, ob er die Nachricht innerhalb des Umschlags zur Verarbeitung / Transformation geben m√∂chte oder nicht.  Wenn er m√∂chte, muss der Entwickler die invoke () -Methode und das invoker-Objekt aufrufen.  Wenn er nicht m√∂chte, ruft er nicht an. In diesem Fall werden der Umschlag und sein Inhalt ignoriert. <br><br><h4>  Wie l√∂sen Umschl√§ge das Problem des Abbrechens von Timern? </h4><br>  Die L√∂sung, die jetzt in so_5_extra in Form des Namespace so_5 :: extra :: revocable_timer implementiert ist, ist sehr einfach: Durch spezielles Senden einer ausstehenden oder periodischen Nachricht wird ein spezieller Umschlag erstellt, in dem sich nicht nur die Nachricht selbst, sondern auch das widerrufene Atomflag befindet.  Wenn dieses Flag gel√∂scht ist, wird die Nachricht als relevant angesehen.  Wenn gesetzt, gilt die Nachricht als zur√ºckgezogen. <br><br>  Wenn die Hook-Methode f√ºr den Umschlag aufgerufen wird, √ºberpr√ºft der Umschlag den Wert des widerrufenen Flags.  Wenn das Flag gesetzt ist, gibt der Umschlag keine Nachricht aus.  Somit wird die Nachricht nicht verarbeitet, selbst wenn der Timer es bereits geschafft hat, die Nachricht in die Warteschlange des Empf√§ngers zu stellen. <br><br><h3>  Schnittstellenerweiterung abstract_message_box_t </h3><br>  Das Hinzuf√ºgen der Envelope_t-Schnittstelle ist nur ein Teil der Implementierung von Envelopes in SObjectizer.  Der zweite Teil ber√ºcksichtigt die Tatsache, dass Umschl√§ge im Nachrichten√ºbermittlungsmechanismus im SObjectizer vorhanden sind. <br><br>  Hier konnte man leider nicht darauf verzichten, √Ñnderungen f√ºr den Benutzer sichtbar zu machen.  Insbesondere in der Klasse abstract_message_box_t, die die Schnittstelle aller Postf√§cher in SObjectizer definiert, musste eine weitere virtuelle Methode hinzugef√ºgt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_deliver_enveloped_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::type_index &amp; msg_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> overlimit_reaction_deep )</span></span></span></span>;</code> </pre> <br>  Diese Methode ist f√ºr die Zustellung eines Nachrichtenumschlags mit einer Nachricht vom Typ msg_type an den Empf√§nger verantwortlich.  Eine solche Lieferung kann sich in den Implementierungsdetails unterscheiden, je nachdem, um welche Art von Mbox es sich handelt. <br><br>  Beim Hinzuf√ºgen von do_deliver_enveloped_msg () zu abstract_message_box_t hatten wir die Wahl: es zu einer rein virtuellen Methode zu machen oder eine Standardimplementierung anzubieten. <br><br>  Wenn wir do_deliver_enveloped_msg () zu einer rein virtuellen Methode machen w√ºrden, w√ºrden wir die Kompatibilit√§t zwischen Versionen von SObjectizer in Zweig 5.5 unterbrechen.  Schlie√ülich m√ºssten Benutzer, die ihre eigenen Mbox-Implementierungen geschrieben haben, beim Wechsel zu SObjectizer-5.5.23 ihre eigenen Mboxes √§ndern, da sie sonst nicht mit der neuen Version von SObjectizer kompilieren k√∂nnten. <br><br>  Wir wollten dies nicht, also haben wir do_deliver_enveloped_msg () in Version 5.5.23 nicht zu einer rein virtuellen Methode gemacht.  Es hat eine Standardimplementierung, die nur eine Ausnahme ausl√∂st.  Auf diese Weise k√∂nnen benutzerdefinierte Benutzer-mbox-s normal mit normalen Nachrichten weiterarbeiten, lehnen jedoch automatisch die Annahme von Umschl√§gen ab.  Wir fanden dieses Verhalten akzeptabler.  Dar√ºber hinaus ist es unwahrscheinlich, dass Umschl√§ge mit Nachrichten in der Anfangsphase weit verbreitet sind, und es ist unwahrscheinlich, dass in den "wilden" benutzerdefinierten Implementierungen von SObjectizer-Mboxen h√§ufig gefunden werden;) <br><br>  Dar√ºber hinaus besteht bei weitem keine Wahrscheinlichkeit, dass in nachfolgenden Hauptversionen von SObjectizer, in denen die Kompatibilit√§t mit Zweig 5.5 nicht untersucht wird, die Schnittstelle abstract_message_box_t wesentliche √Ñnderungen erf√§hrt.  Aber wir sind uns schon voraus ... <br><br><h2>  So senden Sie Umschl√§ge mit Nachrichten </h2><br>  SObjectizer-5.5.23 selbst bietet keine einfache M√∂glichkeit zum Senden von Umschl√§gen.  Es wird davon ausgegangen, dass ein bestimmter Umschlagtyp und geeignete Werkzeuge f√ºr eine bestimmte Aufgabe entwickelt werden, um Umschl√§ge eines bestimmten Typs bequem zu versenden.  Ein Beispiel hierf√ºr ist in <a href="">so_5 :: extra :: revocable_timer</a> zu sehen, wo Sie nicht nur den Umschlag senden, sondern dem Benutzer auch eine spezielle timer_id geben m√ºssen. <br><br>  F√ºr einfachere Situationen k√∂nnen Sie die Tools von <a href="">so_5 :: extra :: Enveloped_msg verwenden</a> .  So wird beispielsweise eine Nachricht mit einem festgelegten Limit f√ºr die Zustellzeit gesendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// make     . so_5::extra::enveloped_msg::make&lt;my_message&gt;(... /*    */) // envelope         . //  5s        . .envelope&lt;so_5::extra::enveloped_msg::time_limited_delivery_t&gt;(5s) //        . .send_to(destination);</span></span></code> </pre> <br><h2>  Damit alles Spa√ü macht: Umschl√§ge in Umschl√§gen </h2><br>  Umschl√§ge sind so konzipiert, dass sie einige Nachrichten in sich tragen.  Aber welche? <br><br>  Beliebig. <br><br>  Und das bringt uns zu einer interessanten Frage: Ist es m√∂glich, einen Umschlag in einen anderen Umschlag zu stecken? <br><br>  Ja, das kannst du.  So viel du willst.  Die Verschachtelungstiefe wird nur durch den gesunden Menschenverstand des Entwicklers und die Tiefe des Stapels f√ºr den rekursiven Aufruf handler_found_hook / transformation_hook begrenzt. <br><br>  Gleichzeitig richtet sich SObjectizer an die Entwickler eigener Umschl√§ge: Der Umschlag sollte nicht dar√ºber nachdenken, was sich darin befindet - eine bestimmte Nachricht oder ein anderer Umschlag.  Wenn die Hook-Methode f√ºr den Umschlag aufgerufen wird und der Umschlag entscheidet, dass er seinen Inhalt angeben kann, ruft der Umschlag einfach invoke () auf handler_invoker_t auf und √ºbergibt in invoke () einen Link zu seinem Inhalt.  Und schon invoke () im Inneren wird herausfinden, womit es zu tun hat.  Wenn dies ein anderer Umschlag ist, ruft invoke () selbst die erforderliche Hook-Methode f√ºr diesen Umschlag auf. <br><br>  Mit dem oben gezeigten Toolkit von so_5 :: extra :: Enveloped_msg kann der Benutzer mehrere verschachtelte Umschl√§ge wie folgt erstellen: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;my_message&gt;(...) <span class="hljs-comment"><span class="hljs-comment">// ,        my_message. .envelope&lt;inner_envelope_type&gt;(...) // ,      inner_envelope_type. .envelope&lt;outer_envelope_type&gt;(...) .send_to(destination);</span></span></code> </pre> <br><h1>  Einige Beispiele f√ºr die Verwendung von Umschl√§gen </h1><br>  Nachdem wir die Interna von SObjectizer-5.5.23 durchgearbeitet haben, ist es an der Zeit, mit dem f√ºr Benutzer n√ºtzlicheren Anwendungsteil fortzufahren.  Im Folgenden finden Sie einige Beispiele, die entweder auf dem basieren, was bereits in so_5_extra implementiert ist, oder die Tools von so_5_extra verwenden. <br><br><h2>  Widerrufliche Timer </h2><br>  Da diese ganze K√ºche mit Umschl√§gen konzipiert wurde, um das Problem des garantierten Abrufs von Timer-Nachrichten zu l√∂sen, wollen wir sehen, was am Ende passiert ist.  Wir werden das Beispiel aus so_5_extra-1.2.0 verwenden, das die Tools aus dem neuen Namespace so_5 :: extra :: revocable_timer verwendet: <br><br><div class="spoiler">  <b class="spoiler_title">Beispielcode mit widerruflichen Timern</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/revocable_timer/pub.hpp&gt; #include &lt;so_5/all.hpp&gt; namespace timer_ns = so_5::extra::revocable_timer; class example_t final : public so_5::agent_t { //  ,       //    . struct first_delayed final : public so_5::signal_t {}; struct second_delayed final : public so_5::signal_t {}; struct last_delayed final : public so_5::signal_t {}; struct periodic final : public so_5::signal_t {}; //    . timer_ns::timer_id_t m_first; timer_ns::timer_id_t m_second; timer_ns::timer_id_t m_last; timer_ns::timer_id_t m_periodic; public : example_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self() .event( &amp;example_t::on_first_delayed ) .event( &amp;example_t::on_second_delayed ) .event( &amp;example_t::on_last_delayed ) .event( &amp;example_t::on_periodic ); } void so_evt_start() override { using namespace std::chrono_literals; //      ... m_first = timer_ns::send_delayed&lt; first_delayed &gt;( *this, 100ms ); m_second = timer_ns::send_delayed&lt; second_delayed &gt;( *this, 200ms ); m_last = timer_ns::send_delayed&lt; last_delayed &gt;( *this, 300ms ); // ...    . m_periodic = timer_ns::send_periodic&lt; periodic &gt;( *this, 75ms, 75ms ); //    220ms.       //    first_delaye, second_delayed  //    periodic. std::cout &lt;&lt; "hang the agent..." &lt;&lt; std::flush; std::this_thread::sleep_for( 220ms ); std::cout &lt;&lt; "done" &lt;&lt; std::endl; } private : void on_first_delayed( mhood_t&lt;first_delayed&gt; ) { std::cout &lt;&lt; "first_delayed received" &lt;&lt; std::endl; //   second_delayed  periodic. //          ,  //       . m_second.revoke(); m_periodic.revoke(); } void on_second_delayed( mhood_t&lt;second_delayed&gt; ) { std::cout &lt;&lt; "second_delayed received" &lt;&lt; std::endl; } void on_last_delayed( mhood_t&lt;last_delayed&gt; ) { std::cout &lt;&lt; "last_delayed received" &lt;&lt; std::endl; so_deregister_agent_coop_normally(); } void on_periodic( mhood_t&lt;periodic&gt; ) { std::cout &lt;&lt; "periodic received" &lt;&lt; std::endl; } }; int main() { so_5::launch( [](so_5::environment_t &amp; env) { env.register_agent_as_coop( "example", env.make_agent&lt;example_t&gt;() ); } ); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Was haben wir hier? <br><br>  Wir haben einen Agenten, der zuerst mehrere Timer-Nachrichten initiiert und dann seinen Arbeitsthread f√ºr eine Weile blockiert.  W√§hrend dieser Zeit schafft es der Zeitgeber, dem Agenten aufgrund der ausgel√∂sten Zeitgeber mehrere Anforderungen in die Warteschlange zu stellen: mehrere periodische Instanzen, jeweils eine erste und eine zweite Verz√∂gerung. <br><br>  Wenn ein Agent seinen Thread entsperrt, sollte er dementsprechend die erste periodische und die erste Verz√∂gerung erhalten.  Bei der Verarbeitung von first_delayed bricht der Agent die Zustellung von periodic und second_delayed ab.  Daher sollten diese Signale den Agenten nicht erreichen, unabh√§ngig davon, ob sie sich bereits in der Warteschlange des Agenten befinden oder nicht (und sie sind es). <br><br>  Wir betrachten das Ergebnis des Beispiels: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">hang</span></span> the agent...done periodic received first_delayed received last_delayed received</code> </pre> <br>  Ja, das ist es.  Habe die erste periodische und erste_verz√∂gerte.  Dann gibt es weder periodische noch zweite Verz√∂gerungen. <br><br>  Wenn wir im Beispiel jedoch die "Timer" von so_5 :: extra :: revocable_timer durch die Standard-Timer von SObjectizer ersetzen, ist das Ergebnis anders: Alle periodischen und zweiten verz√∂gerten Signalinstanzen, die bereits in die Warteschlange des Agenten eingetreten sind, erreichen den Agenten. <br><br><h2>  Nachrichten mit eingeschr√§nkter Lieferzeit </h2><br>  Eine andere n√ºtzliche Sache, die manchmal in so_5_extra-1.2.0 verf√ºgbar sein wird, ist die zeitliche Zustellung von Nachrichten.  Beispielsweise sendet der request_handler-Agent eine verify_signature-Nachricht an den crypto_master-Agenten.  Gleichzeitig m√∂chte request_handler, dass verify_signature innerhalb von 5 Sekunden geliefert wird.  Wenn dies nicht der Fall ist, macht die Verarbeitung von verity_signature keinen Sinn. Der request_handler-Agent beendet seine Arbeit bereits. <br><br>  Und der crypto_master-Agent ist so ein Kamerad, der sich gerne als ‚ÄûEngpass‚Äú herausstellt: Manchmal beginnt er langsamer zu werden.  In einem solchen Moment werden Nachrichten in der Warteschlange angesammelt, z. B. die obige verify_signature, die warten kann, bis crypto_master entlastet wird. <br><br>  Angenommen, request_handler hat eine verify_signature-Nachricht an den crypto_master-Agenten gesendet, aber dann war crypto_master festgefahren und blieb 10 Sekunden lang h√§ngen.  Der request_handler-Agent ist bereits "abgefallen", d. H.  schickte bereits allen einen Denial-of-Service und beendete seine Arbeit.  Die Nachricht verify_signature bleibt jedoch in der Warteschlange crypto_master!  Wenn crypto_master also "entklebt", nimmt es diese Nachricht auf und verarbeitet sie.  Dies ist zwar nicht mehr notwendig. <br><br>  Mit dem neuen Umschlag so_5 :: extra :: Enveloped_msg :: time_limited_delivery_t k√∂nnen wir dieses Problem l√∂sen: Der Request_handler-Agent sendet die im Umschlag enthaltene verify_signature time_limited_delivery_t mit einem Lieferzeitlimit: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;verify_signature&gt;(...) .envelope&lt;so_5::extra::enveloped_msg::<span class="hljs-keyword"><span class="hljs-keyword">time_limited_delivery_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>s) .send_to(crypto_master_mbox);</code> </pre> <br>  Wenn crypto_master nun "klebt" und es nicht schafft, innerhalb von 5 Sekunden die Verifizierungssignatur zu erreichen, sendet der Umschlag diese Nachricht einfach nicht zur Verarbeitung.  Und crypto_master wird keine Arbeit machen, die sonst niemand braucht. <br><br><h2>  Empf√§ngerlieferberichte </h2><br>  Und schlie√ülich ein Beispiel f√ºr eine merkw√ºrdige Sache, die weder in SObjectizer noch in so_5_extra regelm√§√üig implementiert wird, sondern unabh√§ngig voneinander ausgef√ºhrt werden kann. <br><br>  Manchmal m√∂chten Sie vom SObjectizer so etwas wie eine "Zustellungsbericht" -Nachricht an den Empf√§nger erhalten.  Immerhin ist es eine Sache, als die Nachricht den Empf√§nger erreichte, aber der Empf√§nger aus irgendeinem Grund nicht darauf antwortete.  Eine andere Sache ist, wenn die Nachricht den Empf√§nger √ºberhaupt nicht erreicht hat.  Beispielsweise wurde es durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Agenten√ºberlastungsschutzmechanismus</a> blockiert.  Im ersten Fall kann eine Nachricht, auf die wir nicht auf eine Antwort gewartet haben, weggelassen werden.  Im zweiten Fall kann es jedoch sinnvoll sein, die Nachricht nach einiger Zeit erneut zu senden. <br><br>  Nun werden wir uns √ºberlegen, wie der einfachste Mechanismus von ‚ÄûLieferberichten‚Äú mithilfe von Umschl√§gen implementiert werden kann. <br><br>  Also machen wir zuerst die notwendigen vorbereitenden Schritte: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/enveloped_msg/just_envelope.hpp&gt; #include &lt;so_5_extra/enveloped_msg/send_functions.hpp&gt; #include &lt;so_5/all.hpp&gt; using namespace std::chrono_literals; namespace envelope_ns = so_5::extra::enveloped_msg; using request_id_t = int;</span></span></span></span></code> </pre><br>  Jetzt k√∂nnen wir die Nachrichten definieren, die im Beispiel verwendet werden.  Die erste Nachricht ist eine Aufforderung, einige von uns ben√∂tigte Aktionen auszuf√ºhren.  Und die zweite Nachricht ist eine Best√§tigung, dass die erste Nachricht den Empf√§nger erreicht hat: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_id_t</span></span> m_id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delivery_receipt_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   request_t::m_id   request_t. request_id_t m_id; };</span></span></code> </pre> <br>  Als n√§chstes k√∂nnen wir einen Agentenprozessor_t definieren, der Nachrichten vom Typ request_t verarbeitet.  Die Verarbeitung erfolgt jedoch mit der Nachahmung des ‚ÄûKlebens‚Äú.  Das hei√üt,  Es verarbeitet request_t und √§ndert anschlie√üend seinen Status von st_normal in st_busy.  Im Zustand st_busy wird nichts unternommen und alle eingehenden Nachrichten werden ignoriert. <br><br>  Dies bedeutet, dass wenn der Prozessor_t-Agent drei aufeinanderfolgende request_t-Nachrichten sendet, er die erste verarbeitet und die anderen beiden ausgel√∂st werden, weil  Bei der Verarbeitung der ersten Nachricht wechselt der Agent zu st_busy und ignoriert, was zu ihm kommt, w√§hrend er sich in st_busy befindet. <br><br>  In st_busy verbringt Agent process_t 2 Sekunden. Danach kehrt er wieder zu st_normal zur√ºck und ist bereit, neue Nachrichten zu verarbeiten. <br><br>  So sieht der Agent process_t aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   .     //   . state_t st_normal{this, "normal"}; //  " ".   . state_t st_busy{this, "busy"}; public: processor_t(context_t ctx) : so_5::agent_t{std::move(ctx)} { this &gt;&gt;= st_normal; st_normal.event(&amp;processor_t::on_request); //     ,    . //  2   ,    st_normal. st_busy.time_limit(2s, st_normal); } private: void on_request(mhood_t&lt;request_t&gt; cmd) { std::cout &lt;&lt; "processor: on_request(" &lt;&lt; cmd-&gt;m_id &lt;&lt; ", " &lt;&lt; cmd-&gt;m_data &lt;&lt; ")" &lt;&lt; std::endl; this &gt;&gt;= st_busy; } };</span></span></code> </pre> <br>  Jetzt k√∂nnen wir den Agenten request_generator_t definieren, der eine Reihe von Anforderungen enth√§lt, die an processor_t gesendet werden m√ºssen.  Der Agent request_generator_t sendet alle 3 Sekunden das gesamte Paket und wartet dann auf die Zustellbest√§tigung in Form von Delivery_receipt_t. <br><br>  Wenn Delivery_Recept_t eintrifft, wirft der Agent request_generator_t die gelieferte Anfrage aus dem Bundle.  Wenn die Packung vollst√§ndig leer ist, ist das Beispiel abgeschlossen.  Wenn noch etwas √ºbrig ist, wird das verbleibende Paket erneut gesendet, wenn das n√§chste Mal erneut gesendet wird. <br><br>  Hier ist also der Agent-Code request_generator_t.  Es ist ziemlich volumin√∂s, aber primitiv.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie k√∂nnen nur auf die Interna der Methode send_requests () achten, in der request_t-Nachrichten gesendet werden, die in einem speziellen Umschlag eingeschlossen sind. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requests_generator_t Agentencode</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests_generator_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_processor; //  ,       . std::map&lt;request_id_t, std::string&gt; m_requests; struct resend_requests final : public so_5::signal_t {}; public: requests_generator_t(context_t ctx, so_5::mbox_t processor) : so_5::agent_t{std::move(ctx)} , m_processor{std::move(processor)} { so_subscribe_self() .event(&amp;requests_generator_t::on_delivery_receipt) .event(&amp;requests_generator_t::on_resend); } void so_evt_start() override { //    . m_requests.emplace(0, "First"); m_requests.emplace(1, "Second"); m_requests.emplace(2, "Third"); m_requests.emplace(3, "Four"); //  . send_requests(); } private: void on_delivery_receipt(mhood_t&lt;delivery_receipt_t&gt; cmd) { std::cout &lt;&lt; "request delivered: " &lt;&lt; cmd-&gt;m_id &lt;&lt; std::endl; m_requests.erase(cmd-&gt;m_id); if(m_requests.empty()) //    .  . so_deregister_agent_coop_normally(); } void on_resend(mhood_t&lt;resend_requests&gt;) { std::cout &lt;&lt; "time to resend requests, pending requests: " &lt;&lt; m_requests.size() &lt;&lt; std::endl; send_requests(); } void send_requests() { for(const auto &amp; item : m_requests) { std::cout &lt;&lt; "sending request: (" &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; ")" &lt;&lt; std::endl; envelope_ns::make&lt;request_t&gt;(item.first, item.second) .envelope&lt;custom_envelope_t&gt;(so_direct_mbox(), item.first) .send_to(m_processor); } //       3 . so_5::send_delayed&lt;resend_requests&gt;(*this, 3s); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir Nachrichten und Agenten, die diese Nachrichten zur Kommunikation verwenden m√ºssen. </font><font style="vertical-align: inherit;">Es war nur noch eine Kleinigkeit √ºbrig - irgendwie kamen Zustellungsnachrichten an, wenn request_t an processor_t √ºbermittelt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht mit diesem Umschlag:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> custom_envelope_t final : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> envelope_ns::just_envelope_t { //     . const so_5::mbox_t m_to; // ID  . const request_id_t m_id; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: custom_envelope_t(so_5::message_ref_t payload, so_5::mbox_t <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, request_id_t id) : envelope_ns::just_envelope_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(payload)} , m_to{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>)} , m_id{id} {} <span class="hljs-type"><span class="hljs-type">void</span></span> handler_found_hook(handler_invoker_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>) noexcept override { //    ,     . //     . so_5::send&lt;delivery_receipt_t&gt;(m_to, m_id); //      . envelope_ns::just_envelope_t::handler_found_hook(<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen gibt es nichts Kompliziertes. </font><font style="vertical-align: inherit;">Wir erben von so_5 :: extra :: Enveloped_msg :: just_envelope_t. </font><font style="vertical-align: inherit;">Dies ist ein zus√§tzlicher Umschlagtyp, der die darin enthaltene Nachricht speichert und die grundlegende Implementierung der Hooks </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handler_found_hook () und transformation_hook () bereitstellt. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir nur die Attribute speichern, die wir in custom_envelope_t ben√∂tigen, und Delivery_receipt_t innerhalb des Hooks handler_found_hook () senden.</font></font><br><br>  Das ist in der Tat alles.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir dieses Beispiel ausf√ºhren, erhalten wir Folgendes: </font></font><br><br><pre> <code class="hljs vbscript">sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, First) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">0</span></span>, First) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">3</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">2</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">1</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem muss ich sagen, dass in der Praxis ein so einfacher custom_envelope_t zum Generieren von Lieferberichten kaum geeignet ist. </font><font style="vertical-align: inherit;">Wenn sich jedoch jemand f√ºr dieses Thema interessiert, kann es in den Kommentaren besprochen werden, ohne das Volumen des Artikels zu erh√∂hen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was k√∂nnte man noch mit Umschl√§gen machen? </font></font></h1><br>  Gute Frage!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf die wir selbst keine umfassende Antwort haben. </font><font style="vertical-align: inherit;">Wahrscheinlich sind die M√∂glichkeiten nur durch die Vorstellungskraft der Benutzer begrenzt. </font><font style="vertical-align: inherit;">Nun, wenn f√ºr die Verwirklichung von Fantasien in SObjectizer etwas fehlt, dann kann uns dies gesagt werden. </font><font style="vertical-align: inherit;">Wir h√∂ren immer zu. </font><font style="vertical-align: inherit;">Und vor allem manchmal sogar :)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integration von Agenten in mchain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etwas ernster gesagt, das ist eine weitere Funktion, die ich von Zeit zu Zeit haben m√∂chte und die sogar f√ºr so_5_extra-1.2.0 geplant war. Was aber h√∂chstwahrscheinlich nicht in Release 1.2.0 fallen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es geht darum, die Integration von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Agenten zu </font><font style="vertical-align: inherit;">vereinfachen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsache ist, dass urspr√ºnglich Ketten zu SObjectizer hinzugef√ºgt wurden, um die Kommunikation von Agenten mit anderen Teilen der Anwendung zu vereinfachen, die ohne Agenten geschrieben wurden. Beispielsweise gibt es den Hauptthread der Anwendung, auf dem der Benutzer √ºber die GUI interagiert. Und es gibt mehrere Agenten, die im Hintergrund "harte" Arbeit leisten. Das Senden einer Nachricht an einen Agenten aus dem Hauptthread ist kein Problem: Rufen Sie einfach regul√§res Senden auf. Aber wie √ºbertrage ich Informationen zur√ºck?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierzu wurden mchain-s hinzugef√ºgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Laufe der Zeit stellte sich jedoch heraus, dass Ketten eine viel gr√∂√üere Rolle spielen k√∂nnen. Grunds√§tzlich ist es m√∂glich, Multithread-Anwendungen auf SObjectizer ohne Agenten zu erstellen, nur auf mchain-ahs (weitere Details </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Und Sie k√∂nnen mchain-s verwenden, um die Belastung der Agenten auszugleichen. Als Mechanismus zur L√∂sung von Produzenten-Konsumenten-Problemen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem mit dem Produzenten-Konsumenten ist, dass wir in Schwierigkeiten sind, wenn der Produzent Nachrichten schneller generiert, als der Konsument sie verarbeiten kann. Die Nachrichtenwarteschlangen werden gr√∂√üer, die Leistung kann sich mit der Zeit verschlechtern oder die Anwendung st√ºrzt aufgrund von Speicherauslastung vollst√§ndig ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √ºbliche L√∂sung, die wir in diesem Fall vorgeschlagen haben, ist die Verwendung</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Paar Sammler-Performer-Agenten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie k√∂nnen auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachrichtenlimits verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (entweder als Hauptschutzmechanismus oder als Erg√§nzung zu Collector-Performer). Das Schreiben von Collector-Performer erfordert jedoch zus√§tzliche Arbeit vom Programmierer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber Ketten k√∂nnten f√ºr diese Zwecke mit minimalem Aufwand des Entwicklers verwendet werden. Der Produzent w√ºrde also die n√§chste Nachricht in die Kette einf√ºgen, und der Verbraucher w√ºrde Nachrichten aus dieser Kette entgegennehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist jedoch, dass es f√ºr einen Agenten als Agent nicht sehr bequem ist, mit mchain √ºber die verf√ºgbaren Funktionen receive () und select () zu arbeiten. Und diese Unannehmlichkeiten k√∂nnten mit Hilfe eines Tools zur Integration von Agenten und Mchain-s behoben werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Entwicklung eines solchen Tools m√ºssen mehrere Probleme gel√∂st werden. Wenn eine Nachricht beispielsweise in mchain eintrifft, an welchem ‚Äã‚ÄãPunkt sollte sie aus mchain extrahiert werden? Wenn der Verbraucher frei ist und nichts verarbeitet, k√∂nnen Sie die Nachricht sofort von mchain abholen und an den Verbraucheragenten weitergeben. Wenn eine Nachricht bereits von mchain an den Verbraucher gesendet wurde, konnte er diese Nachricht noch nicht verarbeiten, aber eine neue Nachricht ist bereits in mchain eingetroffen ... Was ist in diesem Fall zu tun? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Spekulationen, dass Umschl√§ge in diesem Fall helfen k√∂nnten. Wenn wir also die erste Nachricht von mchain nehmen und an den Verbraucher senden, verpacken wir diese Nachricht in einen speziellen Umschlag. Wenn der Umschlag feststellt, dass die Nachricht zugestellt und verarbeitet wurde, fordert er die n√§chste Nachricht von mchain an (falls vorhanden).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist hier nicht alles so einfach. </font><font style="vertical-align: inherit;">Aber bisher sieht es ziemlich l√∂sbar aus. </font><font style="vertical-align: inherit;">Und ich hoffe, ein √§hnlicher Mechanismus wird in einer der n√§chsten Versionen von so_5_extra erscheinen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ñffnen wir die B√ºchse der Pandora? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte beachtet werden, dass bei uns die zus√§tzlichen F√§higkeiten selbst doppelte Gef√ºhle hervorrufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits haben Umschl√§ge bereits erlaubt / erlaubt, Dinge zu tun, die zuvor erw√§hnt wurden (aber nur von etwas getr√§umt haben). </font><font style="vertical-align: inherit;">Dies ist beispielsweise eine garantierte Stornierung von Zeitgebern und eine Einschr√§nkung der Zustellzeit, Zustellberichte und die M√∂glichkeit, eine zuvor gesendete Nachricht abzurufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits ist nicht klar, wozu dies sp√§ter f√ºhren wird. </font><font style="vertical-align: inherit;">Schlie√ülich k√∂nnen Sie aus jeder Gelegenheit ein Problem machen, wenn Sie diese Gelegenheit nutzen, wo Sie sie brauchen und wo nicht. </font><font style="vertical-align: inherit;">Vielleicht √∂ffnen wir die B√ºchse von Pandora und stellen uns immer noch nicht vor, was uns erwartet? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt nur geduldig zu sein und zu sehen, wohin uns das alles f√ºhren wird.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úber die unmittelbaren Entwicklungspl√§ne von SObjectizer, anstatt abzuschlie√üen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstelle einer Schlussfolgerung m√∂chte ich dar√ºber sprechen, wie wir die nahe (und nicht nur) Zukunft von SObjectizer sehen. Wenn jemand mit etwas in unseren Pl√§nen nicht zufrieden ist, k√∂nnen Sie sich √§u√üern und beeinflussen, wie sich SObjectizer-5 entwickeln wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ersten Beta-Versionen von SObjectizer-5.5.23 und so_5_extra-1.2.0 sind bereits behoben und stehen zum Download und f√ºr Experimente zur Verf√ºgung. Im Bereich Dokumentation und Anwendungsf√§lle bleibt noch viel zu tun. Daher ist die offizielle Ver√∂ffentlichung im ersten Jahrzehnt des Novembers geplant. Wenn es fr√ºher klappt, machen wir es fr√ºher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ver√∂ffentlichung von SObjectizer-5.5.23 scheint zu bedeuten, dass die Entwicklung von Zweig 5.5 zu Ende geht. Die allererste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver√∂ffentlichung in diesem Thread fand vor vier Jahren im Oktober 2014 statt.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seitdem hat sich SObjectizer-5 innerhalb des 5.5-Zweigs weiterentwickelt, ohne dass wesentliche √Ñnderungen zwischen den Versionen vorgenommen wurden. Es war nicht einfach. Vor allem angesichts der Tatsache, dass wir die ganze Zeit auf Compiler zur√ºckblicken mussten, die C ++ 11 bei weitem nicht optimal unterst√ºtzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sehen wir keinen Grund, auf die Kompatibilit√§t innerhalb des 5.5-Zweigs und insbesondere auf √§ltere C ++ - Compiler zur√ºckzublicken. Was 2014 gerechtfertigt sein k√∂nnte, als sich C ++ 14 gerade auf die offizielle Einf√ºhrung vorbereitete und C ++ 17 noch nicht in Sicht war, sieht es jetzt ganz anders aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem hat sich in SObjectizer-5.5 selbst bereits eine ganze Reihe von Rakes und Backups angesammelt, die aufgrund derselben Kompatibilit√§t aufgetreten sind und die weitere Entwicklung von SObjectizer erschweren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher werden wir in den kommenden Monaten nach folgendem Szenario handeln: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Entwicklung der n√§chsten Version von so_5_extra, in der ich Tools hinzuf√ºgen m√∂chte, um das Schreiben von Tests f√ºr Agenten zu vereinfachen. Ob es so_5_extra-1.3.0 sein wird (d. H. Mit brechenden √Ñnderungen relativ zu 1.2.0) oder ob es so_5_extra-1.2.1 sein wird (d. H. Ohne brechende √Ñnderungen), ist noch nicht klar. Mal sehen, wie es geht. Es ist nur klar, dass die n√§chste Version von so_5_extra auf SObjectizer-5.5 basiert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1a. Wenn Sie f√ºr die n√§chste Version von so_5_extra in SObjectizer-5.5 zus√§tzliche Aktionen ausf√ºhren m√ºssen, wird die n√§chste Version 5.5.24 ver√∂ffentlicht. Wenn f√ºr so_5_extra keine Verbesserungen am Kernel von SObjectizer erforderlich sind, stellt sich heraus, dass Version 5.5.23 die letzte wichtige Version im Rahmen von Zweig 5.5 ist. Kleinere Bugfixes werden ver√∂ffentlicht. Die Entwicklung von Zweig 5.5 selbst stoppt jedoch in Version 5.5.23 oder 5.5.24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Dann wird eine Version von SObjectizer-5.6.0 ver√∂ffentlicht, die einen neuen Zweig er√∂ffnet. In Zweig 5.6 werden wir den SObjectizer-Code von allen angesammelten Kr√ºcken und Backups sowie von altem Papierkorb entfernen, der seit langem als veraltet markiert ist. Es ist wahrscheinlich, dass einige Dinge einem Refactoring unterzogen werden (z. B. kann abstract_message_box_t ge√§ndert werden), aber kaum Kardinal. Die Grundprinzipien der Arbeit und die charakteristischen Merkmale von SObjectizer-5.5 in SObjectizer-5.6 bleiben in derselben Form. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.6 ben√∂tigt bereits C ++ 14 (zumindest auf GCC-5.5-Ebene). Visual C ++ - Compiler unter VC ++ 15 (aus Visual Studio 2017) werden nicht unterst√ºtzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir betrachten Zweig 5.6 als einen stabilen Zweig von SObjectizer, der relevant sein wird, bis die erste Version von SObjectizer-5.7 erscheint.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte die Version 5.6.0 Anfang 2019, vorl√§ufig im Februar, ver√∂ffentlichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Nach der Stabilisierung von Zweig 5.6 m√∂chten wir mit der Arbeit an Zweig 5.7 beginnen, in dem wir einige Grundprinzipien der Arbeit von SObjectizer √ºberarbeiten k√∂nnen. Verlassen Sie beispielsweise √∂ffentliche Disponenten vollst√§ndig und lassen Sie nur private √ºbrig. Wiederholen Sie den Mechanismus der Genossenschaften und ihre Eltern-Kind-Beziehungen, um den Engpass bei der Registrierung / Abmeldung von Genossenschaften zu beseitigen. Entfernen Sie die Teilung durch Nachricht / Signal. Erlauben Sie nur send / send_delayed / send_periodic, Nachrichten zu senden, und verbergen Sie die Methoden Deliver_message und Schedule_Timer "unter der Haube". √Ñndern Sie den Mechanismus zum Versenden von Nachrichten so, dass Sie dynamic_casts entweder vollst√§ndig aus diesem Prozess entfernen oder auf ein Minimum reduzieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen gibt es einen Ort, an dem man sich umdrehen kann. Gleichzeitig ben√∂tigt SObjectizer-5.7 bereits C ++ 17, ohne R√ºcksicht auf C ++ 14. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich Dinge ohne rosa Brille ansehen, ist es gut, wenn Release 5.7.0 im Sp√§therbst 2019 stattfindet. Die Hauptarbeitsversion von SObjectizer f√ºr 2019 wird Zweig 5.6 sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Parallel dazu wird sich so_5_extra entwickeln. Wahrscheinlich wird die Version so_5_extra-2 zusammen mit SObjectizer-5.6 ver√∂ffentlicht, das im Laufe des Jahres 2019 neue Funktionen enthalten wird, jedoch auf SObjectizer-5.6 basiert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher sehen wir selbst eine fortschreitende Entwicklung f√ºr SObjectizer-5 mit einer schrittweisen √úberarbeitung einiger der Grundprinzipien von SObjectizer-5. Gleichzeitig werden wir versuchen, dies so reibungslos wie m√∂glich zu gestalten, damit mit minimalen Schmerzen von einer Version zur anderen gewechselt werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn jedoch jemand dramatischere und bedeutendere √Ñnderungen von SObjectizer w√ºnscht, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben wir einige Gedanken dazu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kurz gesagt: Sie k√∂nnen SObjectizer nach Belieben neu erstellen, um SObjectizer-6 f√ºr eine andere Programmiersprache zu implementieren. Wir werden dies jedoch nicht vollst√§ndig auf eigene Kosten tun, da dies mit der Entwicklung von SObjectizer-5 geschieht.</font></font><br><br>  Das ist wahrscheinlich alles.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kommentare </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum vorherigen Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erwiesen sich als gute und konstruktive Diskussion. </font><font style="vertical-align: inherit;">Es w√§re n√ºtzlich f√ºr uns, wenn diesmal eine √§hnliche Diskussion stattfinden w√ºrde. </font><font style="vertical-align: inherit;">Wie immer sind wir bereit, alle Fragen zu beantworten, aber die vern√ºnftigen und mit Vergn√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und den geduldigsten Lesern, die diese Zeilen erreicht haben, vielen Dank f√ºr die Zeit, die sie mit dem Lesen des Artikels verbracht haben.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426983/">https://habr.com/ru/post/de426983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426973/index.html">Firmensandwiches</a></li>
<li><a href="../de426975/index.html">Joker 2018: Das Unm√∂gliche ist m√∂glich</a></li>
<li><a href="../de426977/index.html">LibreOffice: der Albtraum eines Buchhalters</a></li>
<li><a href="../de426979/index.html">So lernen Sie kostenlos Englisch: 3 g√§ngige Tools und detaillierte Anweisungen f√ºr jedes</a></li>
<li><a href="../de426981/index.html">10 Tricks f√ºr erweitertes Dashboarding in Splunk. Teil 1</a></li>
<li><a href="../de426985/index.html">Kubebox und andere Konsolen-Shells f√ºr Kubernetes</a></li>
<li><a href="../de426987/index.html">Lerne OpenGL. Lektion 6.3 - Bildbasierte Beleuchtung. Diffuse Bestrahlung</a></li>
<li><a href="../de426991/index.html">Startup Digest: 10 bevorstehende IT-Events in Moskau</a></li>
<li><a href="../de426993/index.html">Muss ich C lernen, um zu verstehen, wie ein Computer funktioniert?</a></li>
<li><a href="../de426995/index.html">Recycling schadet sowohl Produkten als auch Mitarbeitern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>