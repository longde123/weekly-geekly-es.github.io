<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòî üçó üë©üèº‚Äçü§ù‚Äçüë©üèª A la cuesti√≥n de las transformaciones y otras operaciones. ‚õèÔ∏è üëµ üëâüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blue Caterpillar: Bueno, no nos decepcionar√°s. Nos sentamos, lo sabemos: est√°n esperando nuestra transformaci√≥n. Que? Pero nada! Nos sentamos, fumamos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A la cuesti√≥n de las transformaciones y otras operaciones.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439578/"><h4>  Blue Caterpillar: Bueno, no nos decepcionar√°s.  Nos sentamos, lo sabemos: est√°n esperando nuestra transformaci√≥n.  Que?  Pero nada!  Nos sentamos, fumamos, esperamos ... <br>  Mu√±eca Alice: ¬øQu√©? <br>  Oruga azul: ¬°qu√©, por qu√©!  De transformaciones.  La casa en humo, el humo en una dama, y ‚Äã‚Äãla dama en una madre.  Ah√≠ tienes.  No interfieras, no saltes hacia adelante, de lo contrario, t√∫ mismo te convertir√°s prematuramente en una especie de mariposa. </h4><br>  Al revisar el c√≥digo en uno de los foros dedicados a Arduino, encontr√© una forma divertida de trabajar con un n√∫mero de coma flotante (PT).  El segundo nombre com√∫n para los n√∫meros en este formato es coma flotante, pero la abreviatura (PP) que surge en este caso personalmente me causa asociaciones completamente diferentes, por lo que utilizaremos esta opci√≥n.  La primera impresi√≥n (del c√≥digo que vi) es qu√© tipo de basura se escribe aqu√≠ (debo decir que la segunda es la misma, aunque hay matices, pero m√°s sobre eso m√°s adelante), pero surge la pregunta: ¬øc√≥mo es realmente necesario? La respuesta a la que se da en Texto adicional. <br><br><h4>  Primera parte: preguntas </h4><br>  Formulamos el problema: necesitamos imprimir en la consola (convertirlo en una representaci√≥n simb√≥lica) un n√∫mero de coma flotante, sin usar las opciones de impresi√≥n, que est√°n destinadas para este prop√≥sito.  ¬øPor qu√© queremos hacer esto por nuestra cuenta? <br><br><ol><li>  El uso del formato% f implica conectar la biblioteca para trabajar con un punto flotante y una versi√≥n extendida de la funci√≥n prntf (o m√°s bien, hace que sea imposible usar su versi√≥n truncada), lo que conduce a un aumento significativo en el tama√±o del m√≥dulo ejecutable, </li><li>  una soluci√≥n est√°ndar requiere un tiempo considerable (siempre funciona con un n√∫mero de doble precisi√≥n), lo que puede ser inaceptable en esta situaci√≥n particular, </li><li>  Bueno (por √∫ltimo, pero no menos importante), es simplemente interesante. </li></ol><br><a name="habracut"></a><br>  Para comenzar, considere la opci√≥n propuesta en el material anterior, algo as√≠ como: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Power10=<span class="hljs-number"><span class="hljs-number">10000.0</span></span>; Power10&gt;<span class="hljs-number"><span class="hljs-number">0.1</span></span>; Power10/=<span class="hljs-number"><span class="hljs-number">10.0</span></span>; ) {<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Fdata/Power10); Fdata -=Power10*c; };</code> </pre> <br>  y estamos de acuerdo en que √©l resuelve completamente el problema.  Adem√°s, esta no es una mala opci√≥n, ya que su velocidad puede ser bastante aceptable.  Echemos un vistazo m√°s de cerca en este momento: vemos la divisi√≥n de los n√∫meros de PT, pero si profundizamos en la esencia del problema, resulta que es casi tan r√°pido como la divisi√≥n de enteros de la profundidad de bits correspondiente.  De hecho, antes de evaluar el rendimiento del algoritmo, debe evaluar el rendimiento de varias operaciones elementales, lo que haremos. <br><br><h4>  Segunda parte: evaluaci√≥n del desempe√±o de las operaciones elementales </h4><br>  La primera operaci√≥n interesante es la suma (resta, en el sentido del tiempo empleado, son equivalentes) de enteros de n√∫meros y podemos suponer que se necesita una unidad de tiempo (ciclo de reloj) con la siguiente advertencia: esto es cierto solo para datos "nativos".  Por ejemplo, para la serie MK AVR es una palabra de 8 bits, para MSP430 es una palabra de 16 bits (y, por supuesto, de menor tama√±o), para Cortex-M es una palabra de 32 bits y as√≠ sucesivamente.  Entonces, la operaci√≥n de sumar n√∫meros con una longitud de H veces mayor que la nativa se puede estimar como H ciclos.  Hay excepciones, por ejemplo, AddW en los controladores AVR, pero no cancela la regla. <br><br>  La siguiente operaci√≥n es la multiplicaci√≥n de enteros (pero no la divisi√≥n, difiere en t√©rminos de velocidad) y para √©l no todo es tan simple.  En primer lugar, la multiplicaci√≥n puede implementarse en hardware y, por ejemplo, en AVR MEGA requiere 2 ciclos de reloj, y en 51 mejorados hasta 6 (para multiplicar n√∫meros nativos). <br><br>  Pero considere el caso cuando no hay implementaci√≥n de hardware y tenemos que implementar la multiplicaci√≥n en forma de subrutina.  Dado que al multiplicar n√∫meros de bit H, se obtiene un producto de 2H bit, entonces la estimaci√≥n de la versi√≥n cl√°sica con turnos se puede encontrar de la siguiente manera: necesitamos turnos H del factor con 1 ciclo de reloj por turno, turnos H del segundo factor con una longitud de 2 H con 2 ciclos de reloj por turno, luego H tomar√° decisiones y , en promedio, N / 2 adiciones de n√∫meros con una longitud de 2H, en conclusi√≥n, la organizaci√≥n de un ciclo de 2 medidas.  Total  + 2 +  + 2 / 2 + 2 = 7 ticks, y realizar operaciones aritm√©ticas con ellos solo requiere N ticks (wow eficiencia, aunque logramos sortear el motor). <br><br>  Es decir, para multiplicar dos n√∫meros de 8p por 8p MK, se requieren 56 ciclos, y para multiplicar n√∫meros de 16p ya hay 112 ciclos (un poco menos, pero descuidamos el valor exacto), que es algo m√°s de lo que quer√≠amos.  Afortunadamente, la direcci√≥n de los cambios se puede modificar y hay una forma √∫nica de multiplicaci√≥n, que requerir√° solo cambios H del n√∫mero de d√≠gitos 2H y adiciones H / 2 de n√∫meros nativos, lo que mejora el tiempo de operaci√≥n del algoritmo de multiplicaci√≥n a 0 + 2 + 1 + 1/2 + 2 = 5.5 - por supuesto, no se puede comparar con la implementaci√≥n de hardware, pero al menos algo de ganancia sin p√©rdida de funcionalidad.  Hay mejoras en este algoritmo, por ejemplo, el an√°lisis de 2 bits por ciclo, pero no cambian dr√°sticamente la situaci√≥n: el tiempo de multiplicaci√≥n por √≥rdenes de magnitud excede el tiempo de adici√≥n. <br><br>  Pero con la divisi√≥n, la situaci√≥n es peor: incluso la divisi√≥n implementada en hardware pierde casi el doble por la multiplicaci√≥n, y hay MK con multiplicaci√≥n por hardware, pero sin divisi√≥n por hardware.  Bajo ciertas condiciones, la divisi√≥n se puede reemplazar por la multiplicaci√≥n por el rec√≠proco, pero estas condiciones son espec√≠ficas y dan un resultado similar: se requieren dos iteraciones de multiplicaci√≥n seguidas de la suma, por lo que hay una p√©rdida de 2 veces.  Si implementamos la divisi√≥n como un subprograma, entonces N desplazamientos del divisor 2H de largo, H sustracciones del divisible 2H de largo, H desplazamientos del resultado, se requiere la organizaci√≥n 2H del ciclo, pero todo esto est√° precedido por la alineaci√≥n, que tomar√° otros 5H ciclos, por lo que la cifra total es 2 + 2 + 1 + 2 + 5 = 12, que es aproximadamente 2 veces peor que la multiplicaci√≥n. <br><br>  Bueno, ahora consideraremos las operaciones de PT, y aqu√≠ la situaci√≥n es algo parad√≥jica: la operaci√≥n de multiplicaci√≥n requiere casi tanto tiempo como para los enteros (correspondientes a la capacidad de bits, como regla, 24 bits), ya que debemos multiplicar la mantisa y sumar las √≥rdenes, la normalizaci√≥n no requerido  Con la divisi√≥n tambi√©n es bueno, dividir la mantisa y restar las √≥rdenes, la normalizaci√≥n nuevamente no es necesaria.  Por lo tanto, para estas dos operaciones, la p√©rdida en comparaci√≥n con los enteros no es demasiado significativa, aunque tiene un lugar. <br><br>  Pero la operaci√≥n de suma y resta requiere, en primer lugar, la alineaci√≥n de las √≥rdenes (y estos son turnos y puede haber muchos, aunque hay matices), luego la operaci√≥n en s√≠ y (al restar) la normalizaci√≥n (al sumar, tambi√©n, pero no requiere m√°s de 1 turno ), que es un desperdicio de tiempo, por lo tanto, las operaciones de esta clase para PT son mucho m√°s lentas que para los enteros, especialmente en t√©rminos relativos. <br><br>  Volvamos a nuestras ovejas y aceptemos que, seg√∫n las estimaciones anteriores, el m√©todo propuesto puede no ser demasiado largo, especialmente porque da el resultado de inmediato, pero tiene una limitaci√≥n significativa: es aplicable a un rango muy limitado de valores de entrada de PT.  Por lo tanto, buscar√° una soluci√≥n universal (m√°s o menos). <br><br>  Inmediatamente haga una reserva de que nuestra soluci√≥n no debe usar operaciones de punto flotante en general (de la palabra) para enfatizar los m√©ritos de nuestra opci√≥n.  Y a la pregunta perpleja de c√≥mo aparecer√° un n√∫mero de este tipo si las operaciones no est√°n disponibles, respondemos: puede aparecer, por ejemplo, al leer informaci√≥n de un sensor de luz (como en el ejemplo original), que produce datos en el formato PT. <br><br>  C√≥mo se organiza exactamente el n√∫mero de PT, puede encontrarlo f√°cilmente en numerosos sitios, hubo un art√≠culo reciente sobre Habr√©, no deber√≠a haber problemas con esto.  Sin embargo, una serie de preguntas son de inter√©s para el formato PT en el estilo "si yo fuera el director", por qu√© esto es as√≠, y no de otra manera.  Dar√© mis respuestas a algunas de ellas, si alguien sabe m√°s correcto, por favor comente. <br><br>  La primera pregunta es ¬øpor qu√© la mantisa se almacena en c√≥digo directo y no en c√≥digo adicional?  Mi respuesta es porque es m√°s f√°cil trabajar con una mantisa normalizada con un bit oculto (opcional). <br><br>  La segunda pregunta es por qu√© el pedido se almacena con un desplazamiento, y no de otra manera.  Mi respuesta es porque en este caso es f√°cil comparar los m√≥dulos de dos PT como enteros, con otros m√©todos es m√°s complicado. <br><br>  La tercera pregunta es ¬øpor qu√© el signo negativo est√° codificado por uno en lugar de cero, porque entonces ser√≠a posible comparar simplemente los dos puntos como enteros?  Mi respuesta es que no lo s√©, es solo "es tan aceptado aqu√≠". <br><br><h4>  Parte tres - Explicaciones requeridas </h4><br>  En el p√°rrafo anterior, podr√≠a dar t√©rminos incomprensibles, un poco sobre la representaci√≥n de n√∫meros.  Por supuesto, son diferentes, de lo contrario no habr√≠a necesidad de discutirlos.  Inmediatamente, notamos que en la memoria de MK (lo mismo es cierto sobre las computadoras, aunque no soy tan categ√≥rico sobre las arquitecturas m√°s modernas, son tan complicadas que todo puede esperarse) no hay n√∫meros, solo hay unidades de almacenamiento elementales, bits agrupados en bytes y m√°s en palabras.  Cuando hablamos de la representaci√≥n de un n√∫mero, significa que interpretamos un conjunto de bits de una longitud espec√≠fica de una forma u otra, es decir, establecemos una ley por la cual podemos encontrar un cierto n√∫mero correspondiente a un conjunto de bits dado, y nada m√°s. <br><br>  Se pueden inventar innumerables leyes de este tipo, pero algunas de ellas tendr√°n una serie de propiedades √∫tiles en t√©rminos de realizar diversas operaciones, por lo que se aplicar√°n con mayor frecuencia en la pr√°ctica.  Una de estas propiedades, que est√° impl√≠citamente impl√≠cita, por ejemplo, es el determinismo, y la otra es la independencia del medio ambiente, propiedades que son, a primera vista, obvias, aunque hay matices.  Otras propiedades del tipo de correspondencia uno a uno ya son tema de discusi√≥n y no siempre tienen lugar en una representaci√≥n concreta.  El tema de representar n√∫meros en s√≠ mismo es inusualmente fascinante; para Knut (en el Volumen Dos) se revela completamente, de modo que va m√°s all√° de las profundidades y pasamos a la superficie. <br><br>  Bajo el supuesto de que el conjunto de bits tiene una longitud n (los numeramos en una fila de 0 a n-1) y se ponderan uniformemente con un paso de 2 y el bit menos significativo (con el n√∫mero 0) tiene un peso de 1 (que, en t√©rminos generales, no es necesario en absoluto, simplemente Nos acostumbramos a tales cosas, y nos parecen obvias) obtenemos una representaci√≥n binaria del n√∫mero, en la cual la f√≥rmula de reducci√≥n se ve as√≠: el n√∫mero que muestra el conjunto de bits <code>(2) = (0)*2^0 + (1)*2^1 + ... + (-1)*2^(-1)</code> o en forma de cascada <code>2() = (0)+2*((1)+2*(...+2*((-1))..)))</code> , en adelante, B (k) denota un bit con el n√∫mero k. Tenga en cuenta que debajo  una vista diferente no impone ninguna restricci√≥n en la ubicaci√≥n de los bytes de n√∫mero en la memoria, pero ser√≠a m√°s l√≥gico colocar el byte bajo en las direcciones m√°s bajas (as√≠ de f√°cil y naturalmente resolv√≠ el "argumento eterno de los eslavos entre ellos" con respecto a qu√© extremo es m√°s conveniente para romper un huevo). <br><br>  Con esta interpretaci√≥n de un conjunto de bits de longitud n (= 8), obtenemos una representaci√≥n de n√∫meros del 0 al (2 ^ n) -1 (= 255) (en lo sucesivo entre par√©ntesis habr√° un valor espec√≠fico para un conjunto de 8 bits), que tiene un n√∫mero de y propiedades √∫tiles, por lo que se ha generalizado.  Desafortunadamente, tambi√©n tiene una serie de inconvenientes, uno de los cuales es que, en principio, no podemos representar n√∫meros negativos en dicho registro. <br><br>  Puede ofrecer una variedad de soluciones a este problema (la representaci√≥n de n√∫meros negativos), entre las cuales tambi√©n hay importancia pr√°ctica, se enumeran a continuaci√≥n. <br><br>  La f√≥rmula H = N2 (n) - desplazamiento (C) describe una representaci√≥n con un desplazamiento, donde N2 es el n√∫mero obtenido en notaci√≥n binaria con n bits, y C es un valor preseleccionado.  Luego representamos n√∫meros de 0-C a 2 ^ (n) -1-C, y si elegimos C = 2 ^ (n-1) -1 (= 127) (esto es completamente opcional, pero muy conveniente), entonces obtenemos el rango de 0- (2 ^ (n-1) -1) (= - 127) a 2 ^ (n-1) (= 128).  La principal ventaja de esta representaci√≥n es la monoton√≠a (adem√°s, aumento) en todo el intervalo, tambi√©n hay desventajas, entre las que destacamos la asimetr√≠a (hay otras relacionadas con la complejidad de realizar operaciones en el n√∫mero en esta representaci√≥n), pero los desarrolladores del est√°ndar IEEE 457 (este es el est√°ndar para PT) convirti√≥ esta falla en una virtud (usando un valor extra para codificar la situaci√≥n nan), que una vez m√°s enfatiza la fidelidad del refr√°n genial: ‚ÄúSi eres m√°s alto que el oponente, esta es tu ventaja.  Si el adversario es m√°s alto que t√∫, entonces esta tambi√©n es tu ventaja. <br><br>  Tenga en cuenta que dado que el n√∫mero total de combinaciones posibles de cualquier n√∫mero de bits es par (si no tiene combinaciones prohibidas por razones religiosas), la simetr√≠a entre n√∫meros representables positivos y negativos es fundamentalmente inalcanzable (o m√°s bien, alcanzable, pero bajo ciertas condiciones adicionales, sobre las cuales, adem√°s) . <br><br>  Representaci√≥n en forma de c√≥digo directo cuando uno de los bits (m√°s significativo) representa el signo codificado del n√∫mero H = (-1) ^ B (n-1) * P2 (n-1) tiene un rango de 0- (2 ^ (n-1) -1) (= -127) a 2 ^ (n-1) -1 (= 127).  Es interesante notar que acabo de declarar la imposibilidad fundamental de la simetr√≠a, y aqu√≠ est√° claramente: el n√∫mero positivo m√°ximo representable es igual al m√≥dulo del n√∫mero negativo m√≠nimo representable.  Este resultado se logra al tener dos representaciones para cero (00 ... 00 y 10 ... 00), que generalmente se considera la principal desventaja de este m√©todo.  Esto es realmente un inconveniente, pero no tan terrible como com√∫nmente se cree, ya que hay otros m√°s importantes que limitan su uso. <br><br>  La representaci√≥n de c√≥digo inverso, cuando en la representaci√≥n directa invertimos todos los bits del valor para n√∫meros negativos H = (1-B (n-1)) * P2 (n-1) + B (n-1) * (2 ^ (n -1) -CH2 (n-1)): esto es de la definici√≥n, puede hacer una f√≥rmula mucho m√°s comprensible H = Ch2 (n-1) -B (n-1) * (2 ^ (n-1) -1), lo que nos permite representar n√∫meros de 0-2 ^ (n-1) +1 (= - 127) a 2 ^ (n-1) -1 (= 127).  Se puede ver que esta representaci√≥n est√° desplazada, pero el desplazamiento cambia paso a paso, lo que hace que esta representaci√≥n no sea mon√≥tona.  Nuevamente, tenemos dos ceros, lo que no da mucho miedo, la ocurrencia de transferencia circular durante la adici√≥n es mucho peor, lo que crea ciertos problemas en la implementaci√≥n de ALU. <br><br>  Para eliminar el √∫ltimo inconveniente de la representaci√≥n anterior es inusualmente simple, es suficiente cambiar el desplazamiento por uno, luego obtenemos = = 22 (n-1) -B (n-1) * 2 ^ (n-1) y podemos representar n√∫meros de 0-2 ^ ( n-1) (= - 128) a 2 ^ (n-1) -1 (= 127).  Es f√°cil ver que la representaci√≥n es asim√©trica, pero cero es √∫nico.  Significativamente m√°s interesante es la siguiente propiedad, "es completamente obvio que" la transferencia de anillo no ocurre para una operaci√≥n de tipo suma, que es la raz√≥n (junto con otras caracter√≠sticas agradables) para la distribuci√≥n universal de este m√©todo particular de codificaci√≥n de n√∫meros negativos. <br><br>  Dibujemos una tabla de valores interesantes para varios m√©todos de codificaci√≥n de n√∫meros, denotando por H el valor 2 ^ (n-1) (128) <br><table><tbody><tr><th>  Pedacitos </th><th>  00..00 </th><th>  11/01 </th><th>  10..00 </th><th>  11.11 </th></tr><tr><td>  H (n) </td><td>  0 0 </td><td>  H-1 (127) </td><td>  H (128) </td><td>  2 * H-1 (255) </td></tr><tr><td>  H (n-1) </td><td>  0 0 </td><td>  H-1 (127) </td><td>  0 0 </td><td>  H-1 (127) </td></tr><tr><td>  Offset  N </td><td>  -H + 1 (-127) </td><td>  0 0 </td><td>  1 </td><td>  H (128) </td></tr><tr><td>  Directo </td><td>  0 0 </td><td>  H-1 (127) </td><td>  0 0 </td><td>  -H + 1 (-127) </td></tr><tr><td>  Reverso </td><td>  0 0 </td><td>  H-1 (127) </td><td>  -H + 1 (-127) </td><td>  0 0 </td></tr><tr><td>  Adem√°s </td><td>  0 0 </td><td>  H-1 (127) </td><td>  -H (-128) </td><td>  -1 </td></tr></tbody></table><br>  Bueno, para concluir el tema, proporcionamos gr√°ficos para las representaciones enumeradas, a partir de las cuales sus ventajas y desventajas son inmediatamente visibles (por supuesto, no todo lo que hace que uno recuerde el dicho interesante "La ventaja de la presentaci√≥n gr√°fica de la informaci√≥n es visual, no tiene otras ventajas"). <br><br><h4>  Cuarta parte: resolver el problema original (m√°s vale tarde que nunca). <br><br>  Peque√±a digresi√≥n </h4><br>  Para empezar, quer√≠a imprimir el PT en formato hexadecimal (y finalmente lo hice), pero de manera bastante inesperada / completamente inesperada (necesitaba sustituirlo) me encontr√© con el siguiente resultado.  ¬øQu√© crees que se imprimir√° como resultado de ejecutar los operadores? <br><br><pre> <code class="plaintext hljs">printf("%f %x", 1.0,1.0); printf("%f %x",2.0,2.0); printf("%x %d",1.0,1.0); printf("%x %d",2.0,2.0);</code> </pre> <br>  , tambi√©n preste atenci√≥n a la siguiente construcci√≥n y su resultado: <br><br><pre> <code class="plaintext hljs">printf("%x %x %f",1.0,1.0);</code> </pre> <br>  No dar√© explicaciones a este fen√≥meno, "lo suficientemente inteligente". <br><br>  Sin embargo, ¬øc√≥mo imprimimos correctamente la representaci√≥n hexadecimal de PT?  La primera soluci√≥n es obvia: uni√≥n, pero la segunda es para los ventiladores de una sola l√≠nea printf ("% x", * ((int *) (&amp; f)));  (Pido disculpas si alguien se ofendi√≥ con corchetes adicionales, pero nunca pude, y nunca tuve la intenci√≥n de recordar las prioridades de las operaciones, especialmente teniendo en cuenta que los par√©ntesis no generan c√≥digo, por lo que continuar√© haciendo lo mismo).  Y aqu√≠ est√°, la soluci√≥n de la tarea: vemos una cadena de caracteres, 0x45678, que determina de forma √∫nica el n√∫mero deseado para nosotros, pero de tal manera que (no s√© sobre ti, definitivamente) no podemos decir nada inteligible sobre este n√∫mero.  Creo que el acad√©mico Karnal, que podr√≠a haber se√±alado un error en la cinta perforada con el c√≥digo fuente, habr√≠a abordado esta tarea, pero no todos est√°n tan avanzados, por lo que continuaremos. <br><br>  Intentaremos obtener informaci√≥n de una forma m√°s comprensible. <br><br>  Para hacer esto, volvemos al formato del PT (en adelante, considero solo flotante), que es un conjunto de bits del que puede extraer (seg√∫n ciertas reglas) tres conjuntos de bits para representar tres n√∫meros: signo (s), mantisa (m) y orden (p), y el n√∫mero deseado codificado por estos n√∫meros estar√° determinado por la siguiente f√≥rmula: Cs * Chm * Chn.  Aqu√≠, los s√≠mbolos  designan los n√∫meros representados por el conjunto de bits correspondiente, por lo tanto, para encontrar el n√∫mero deseado, necesitamos conocer las leyes por las cuales extraemos estos tres conjuntos del conjunto original de bits, as√≠ como el tipo de codificaci√≥n para cada uno de ellos. <br><br>  Al resolver este problema, recurrimos al est√°ndar IEEE y descubrimos que el signo es un bit (principal) del conjunto original y la f√≥rmula para codificar Cs = (- 1) ^ B (0).  El orden ocupa los siguientes 8 bits altos, se escribe en c√≥digo con un desplazamiento de 127 y representa una potencia de dos, luego Cn = 2 ^ (C2 (8) -127).  Mantissa toma el siguiente orden de 23 d√≠gitos y representa el n√∫mero Chm = 1 + Ch2 (23) / 2 ^ 23. <br><br>  Ahora tenemos todos los datos necesarios y podemos resolver completamente la tarea: crear una cadena con caracteres, que, con una cierta lectura, representar√° un n√∫mero igual al codificado.  Para hacer esto, debemos, mediante operaciones simples, extraer los n√∫meros anteriores y luego imprimirlos, proporcionando los atributos necesarios.  Suponemos que somos capaces de convertir un entero con no m√°s de 32 bits en una cadena de caracteres, entonces esto es completamente sencillo. <br><br>  Desafortunadamente, solo estamos al comienzo del viaje, ya que pocos lectores de esta publicaci√≥n en el registro "+ 1.625 * 2 ^ 3" reconocen el n√∫mero desafortunado, que est√° codificado por el decimal m√°s com√∫n "13", y adivinan en el registro "1.953125 * 2 ^ 9 "el simple" 1E3 "o" 1 * 10 ^ 3 "o el muy familiar" 1000 "son capaces de unidades de personas en general, definitivamente no les pertenezco.  Es extra√±o c√≥mo sucedi√≥, porque completamos la tarea inicial, que una vez m√°s demuestra cu√°n cuidadosamente debe tratar las formulaciones.  Y el punto no es que la notaci√≥n decimal sea mejor o peor que la binaria (en este caso, deuce se basa en el grado), sino que estamos acostumbrados al decimal desde la infancia y rehacer a las personas es mucho m√°s dif√≠cil que el programa, por lo que daremos nuestro entrada a lo m√°s familiar. <br><br>  Desde el punto de vista de las matem√°ticas, tenemos una operaci√≥n simple: hay un registro PT = (- 1) ^ s * m * 2 ^ n, y necesitamos convertirlo a la forma PT = (-1) s '* m' * 10 ^ n '.  Equiparamos, transformamos y obtenemos (una de las opciones posibles) soluciones s '= s', m '= m, n' = n * log (2).  Si dejamos los corchetes la necesidad de multiplicar por un n√∫mero expl√≠citamente irracional (esto se puede hacer si el n√∫mero est√° racionalizado, pero hablaremos de esto m√°s adelante), entonces el problema parece estar resuelto hasta que veamos la respuesta, porque si el registro es como "+1.953125 * 2 ^ 9 "nos parece oscuro, el registro" + 1.953125 * 10 ^ 2.70927 "es a√∫n menos aceptable, aunque parec√≠a que no hab√≠a nada peor. <br><br>        ‚Äî       10 '= * 10^{ * lg(2)}, '= [ * lg(2)],             .      (1.953125*10^0.7 0927)*10^2=¬´10*10^2¬ª,     ,    ,    . <br><br>   ,   : <br><br><ol><li>    ()     (lg(2)) (       ); </li><li>          ( ); </li><li>    (10)    (...); </li><li>      (¬´  ,   ...¬ª). </li></ol><br>   ,        ,   ,    1.  ,            * lg(2),   ¬´¬ª  ,     =0 (    =/lg(10)).  ,    ¬´ ¬ª,      ¬´  ¬ª.                     . ,         ,     ' =  * lg(2)    * [lg(2) *256 + 1/2] / 256       ,        1/2/77 = 1/144,   ,   1/100.        ‚Äî                 ,       .    [4.501]=5,  [4.499]=4 ,   ,        0.002/4.5=0.04%,     1/4=25%.  ,       ,     .     ,     ,  ,    ,           ,   , . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para nuestro caso, tal aproximaci√≥n ideal ser√° la funci√≥n n '= n * 77/256. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de continuar con el dise√±o del algoritmo, debemos evaluar la precisi√≥n que necesitamos. Como la mantisa es de 24 bits, el n√∫mero representado tiene un error relativo de 2 ^ -24 = 2 ^ -4 * 2 ^ -20 = 16 ^ -1 * (2 ^ 10) ^ - 2 ~ (10) ^ - 1 * (10 ^ 3) ^ - 2 = 10 ^ -7, lo que significa 7 d√≠gitos decimales exactos. Multiplicar dos n√∫meros de 24 bits ser√° suficiente para mantener la precisi√≥n en este rango (bueno, casi suficiente). Solo tenga en cuenta que la transici√≥n a n√∫meros de 32 bits (ambos factores) reduce el error relativo en m√°s de 100 (256) veces, este hecho ser√° √∫til m√°s adelante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La f√≥rmula m√°s desagradable en t√©rminos de precisi√≥n calcula una nueva mantisa y se ve como </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m '= m * 10 ^ {n * log (2)}</font></font></b> <br><br>     ‚Äî 1)          , 2)          ,      , ,        ,      ,  .    ‚Äî         ,           ,         ,          . <br><br> ¬´ ,  , ¬ª <br><br> q(10^x) = Œî(10^x)/10^x = (10^(x +Œîx) ‚Äî 10^x)/10^x = 10^Œîx -1 = 10^(x*qx)-1, <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 ^ (x * qx)&gt; ~ 10 ^ (x * 0) + (10 ^ (x * 0)) '* qx = 1 + x * ln (10) * 10 ^ (0) * qx = 1 + x * ln (10) * qx, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de aqu√≠ obtenemos</font></font><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>q</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mn>10</mn><mi>x</mi></msup><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>x</mi><mo>&amp;#x2217;</mo><mi>l</mi><mi>n</mi><mo stretchy=&quot;false&quot;>(</mo><mn>10</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mi>q</mi><mi>x</mi><mo>.</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="24.462ex" height="2.66ex" viewBox="0 -832 10532.3 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMATHI-71" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-28" x="460" y="0"></use><g transform="translate(850,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMATHI-78" x="1415" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-29" x="2355" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-3D" x="3023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMATHI-78" x="4079" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-2217" x="4874" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMATHI-6C" x="5596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMATHI-6E" x="5895" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-28" x="6495" y="0"></use><g transform="translate(6885,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-30" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-29" x="7886" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-2217" x="8498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMATHI-71" x="9220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMATHI-78" x="9681" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhjE5ogN9ffk2u3mPsIWYpFWsq8yQQ#MJMAIN-2E" x="10253" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mi>x</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>‚àó</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>‚àó</mo><mi>q</mi><mi>x</mi><mo>.</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1">q(10^x) = x*ln(10)*qx.</script></p>     ‚Äî ,     ,  =127,     292    ,       ,      . <br><br> ,    24  32       (  ,   ),  ,    (*lg(2))    32  ,         ,     1'292'914'005/2^32. ,        ,  (int)((lg(2)*float(2^32))+0.5),         04d104d42,        ,     . <br><br>      ,  ,           , ,  . <br>       10    0  1          . ,    ,       ,  ,              , ''=lg(2)*i+(''-lg(2)*i),         2   ,       (   ),      lg(2)         10^'' (   ). <br><br>   ,      lg(2)        ,   ,     .  ,        , , ,     10-7   9  ,      1+9*2=19  32-  ,     .            '=*lg(2)   ,       . <br><br>               32-    1+19+1=21        <br><br>        ‚Äî   ,     ‚Äî   ,    .   ,           ‚Äî    (  )  ,           ,      . <br><br>   ‚Äî     ‚Äî      (2^8=256)      ['] (    10)  {'} (   ),           .     ‚Äî =*2^=*10^'*(2^/10^')=(*(2^/10^'))*10^'. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso m√°s simple, necesitamos 256 * 3 (un factor de correcci√≥n de 24 bits, ya no es necesario) + 256 * 1 (se garantiza que el orden en la base 10 es menor que el orden en la base 2) = constantes de 1kbyte. En este caso, nos queda hacer una sola multiplicaci√≥n de 24 * 24 bits (lo m√°s probable es que sea 32 * 32), lo que acelera significativamente el trabajo en comparaci√≥n con la versi√≥n de este c√°lculo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos qu√© se puede hacer desde el punto de vista del ahorro de memoria (en este caso, nuevamente tenemos que pagar tiempo, por lo que estamos buscando un compromiso razonable). En primer lugar, si tenemos en cuenta el signo de pedido por separado, podemos administrar solo la mitad de la memoria requerida (de 256 bytes para el pedido 10) e invertir el resultado si es necesario. Desafortunadamente, con el factor de correcci√≥n, no ser√° tan f√°cil, porque</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ^ -n / 10 ^ -n '= 1 / (2 ^ n / 10 ^ n')! = 2 ^ n / 10 ^ n ', </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una pena. Tenemos que dejar una tabla larga, o para indicadores negativos, dividir por una constante para indicadores positivos. Por supuesto, la divisi√≥n no es 18 multiplicaciones, pero a√∫n as√≠ es exactamente equivalente en velocidad a dos multiplicaciones, por lo que el tiempo definitivamente se duplicar√° para ahorrar memoria dos veces, hasta 512 bytes. ¬øVale la pena? La pregunta no es simple, pero, afortunadamente, tenemos una forma mucho m√°s hermosa que nos permite deshacernos del sufrimiento de la elecci√≥n.</font></font><br><br>       -            ,         (  )       .      (  ) <br><br> =*2^=*2^(0+1)=*10^'*(2^(0+1)/10^')=*(2^0/10^')*2^1*10^', <br><br>  0-  ,  1=-0.               ,    . <br><br>     ‚Äî     ,     0          ?  ,         ‚Äî       10        .           ‚Äî     32*32,     24 ,    8             8   .       256/8*4=32*4=128  ‚Äî                8 . <br><br>             0,     ,    32/2=16 ,  ,     (   )  . <br><br> ,          adafruit        <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UINT8 Bits[] = {<span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-number"><span class="hljs-number">0x08</span></span>, <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, <span class="hljs-number"><span class="hljs-number">0x80</span></span>}; ... data = data | Bits[n];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un comentario de que la operaci√≥n 1 &lt;&lt; n en el AVR lleva mucho tiempo. En mi publicaci√≥n, ya mostr√© qu√© milagros hace el compilador con un par√°metro constante, pero este no es el caso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me pareci√≥ dudoso que tomar una m√°scara de bits de una matriz ser√≠a m√°s r√°pido que realizar las operaciones de cambio directamente y el an√°lisis de c√≥digo posterior (usando el sitio web godbolt, aunque es extremadamente improbable que su creador lea el Habr, sin embargo, una vez m√°s, le traigo mi sincero gratitud) demostr√≥ que esto es realmente as√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo generado por el compilador para ambas opciones (aqu√≠ est√° la opci√≥n correcta con turnos, teniendo en cuenta las caracter√≠sticas de la tarea, porque solo necesitamos 1 bit)</font></font><br><br><pre> <code class="cpp hljs"> ldi r18,lo8(<span class="hljs-number"><span class="hljs-number">4</span></span>) sbrs r25,<span class="hljs-number"><span class="hljs-number">1</span></span> ldi r18,lo8(<span class="hljs-number"><span class="hljs-number">1</span></span>) sbrc r25,<span class="hljs-number"><span class="hljs-number">0</span></span> lsl r18 sbrs r25,<span class="hljs-number"><span class="hljs-number">2</span></span> swap r18</code> </pre> <br>      ,       ,       8:7    8   (,             ,    16  ‚Äî     ‚Äî ¬´ ,   ,   ,   ¬ª).     ‚Äî    ,          : ¬´          ‚Äû       12 ‚Äú (¬ª ",    , ). <br><br>            <br><br>  =  * 2^=( * [/8]) * 2^(%8) * 10^[/8], <br><br>        -   - .     ,    32*32(24*24)   .        32     10   ,      ( ,     )   . <br><br>    ‚Äî     ,           <br><br> const uint32_t Data[32] PROGMEM = { 0xF82345,‚Ä¶ } <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el punto, por supuesto, no est√° en los atributos de la descripci√≥n de la matriz, sino en los datos en forma de n√∫meros m√°gicos. </font><font style="vertical-align: inherit;">Como los autores se√±alaron correctamente, definitivamente no es m√°s tonto que yo, un c√≥digo bien escrito es autodocumentado y, si escribimos la constante anterior (y el resto) en el formulario</font></font><br><br><pre> <code class="plaintext hljs">#define POWROUD(pow) ((uint8_t)((pow &amp; 0x07)*log(2)+0.5)) #define MULT(pow) (2^pow / 10^POWROUND(pow)) #define MULTRAW(pow) (uint32_t((MULT(pow) &lt;&lt; 24) +0.5)) #define BYTEMASK 0xFF #define POWDATA(pow) ((POWROUND(pow) &amp; BYTEMASK)| (MULTRAW(pow) &amp; (~BYTEMASK))) const uint32_t Data[(BYTEMASK/8)+1] = { POWDATA(0x00),POWDATA(0x08), ..POWDATA(0xF8)}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entonces nadie nos enviar√° preguntas perplejas, y si alguien nos env√≠a, definitivamente no podemos responderlas, todav√≠a es in√∫til. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos proponer una modificaci√≥n de este m√©todo en el que se calcular√° una potencia adecuada de diez no para el borde derecho del segmento, sino para la izquierda y luego el resultado no se desplazar√° hacia la derecha para tener en cuenta la potencia de dos, sino hacia la izquierda. </font><font style="vertical-align: inherit;">Desde el punto de vista de las matem√°ticas, los m√©todos son absolutamente equivalentes. </font><font style="vertical-align: inherit;">Veamos el resultado: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.953125 * 2 ^ 9 = 1.953125 * 2 ^ (8 + 1) = 1.953125 * 42949673/256/256/256 (2.56) * 2 * 10 ^ 2 = 10 * 10 ^ 2</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ya es muy f√°cil encontrar 1000 aqu√≠. Por supuesto, tambi√©n tendr√≠amos que convertir la mantisa y el orden obtenidos en cadenas, redondear cuidadosamente, ajustar el resultado al formato requerido, agregar un car√°cter, tener en cuenta casos especiales, etc., pero esto ya no es tan interesante, la parte principal transformaciones que realizamos. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439578/">https://habr.com/ru/post/439578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439568/index.html">SSD basados ‚Äã‚Äãen QLC: ¬øun asesino del disco duro? No realmente</a></li>
<li><a href="../439570/index.html">Magia de IPython para editar etiquetas de celda de Jupyter</a></li>
<li><a href="../439572/index.html">Dise√±o asistido por computadora de equipos electr√≥nicos.</a></li>
<li><a href="../439574/index.html">Protocolo SmartCard I2C. Intercambie comandos APDU a trav√©s de la interfaz I2C</a></li>
<li><a href="../439576/index.html">Una amplia descripci√≥n de las entrevistas de Python. Consejos y trucos</a></li>
<li><a href="../439580/index.html">Hacer que Git para Windows funcione en ReactOS</a></li>
<li><a href="../439584/index.html">Proyecto Lenergy como un replanteamiento de las fuentes de alimentaci√≥n port√°tiles.</a></li>
<li><a href="../439586/index.html">El protocolo SPBm como base del Campus Extreme Automated</a></li>
<li><a href="../439588/index.html">ESET descubri√≥ nuevas versiones del troyano DanaBot</a></li>
<li><a href="../439590/index.html">Clasificaciones: CTF 2019 de seguridad cibern√©tica nacional de Arabia Saudita y Om√°n.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>