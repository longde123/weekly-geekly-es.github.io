<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏿 🕺🏽 🍡 Membuat bot untuk berpartisipasi dalam AI mini cup 2018 berdasarkan pada jaringan saraf berulang (bagian 2) 🖖🏾 🐐 🔖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini merupakan kelanjutan dari bagian pertama artikel. 


 Pada bagian pertama artikel, penulis berbicara tentang kondisi kontes untuk game Agario di m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat bot untuk berpartisipasi dalam AI mini cup 2018 berdasarkan pada jaringan saraf berulang (bagian 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417657/"><p><img src="https://habrastorage.org/webt/of/tw/ke/oftwke-wbh5-w_nlsm_p5rmhano.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini merupakan kelanjutan dari bagian pertama artikel.</a> </p><br><p> Pada bagian pertama artikel, penulis berbicara tentang kondisi kontes untuk game Agario di mail.ru, struktur dunia game dan sebagian tentang struktur bot.  Sebagian, karena mereka hanya mempengaruhi perangkat sensor input dan perintah pada output dari jaringan saraf (selanjutnya dalam gambar dan teks akan ada singkatan NN).  Jadi mari kita coba membuka kotak hitam dan memahami bagaimana semuanya diatur di sana. </p><a name="habracut"></a><br><p>  Dan inilah gambar pertama: </p><br><p><img src="https://habrastorage.org/webt/v2/pb/_s/v2pb_sha05gqjtqcqp9bv5mnm0o.jpeg"></p><br><p>  Secara skematis menggambarkan apa yang seharusnya menyebabkan senyum bosan dari pembaca saya, kata mereka lagi di kelas satu, mereka telah dilihat berkali-kali di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbagai sumber</a> .  Tapi kami benar-benar ingin menerapkan gambar ini secara praktis ke manajemen bot, jadi setelah Catatan Penting kami melihat lebih dekat. </p><br><p>  <strong>Catatan penting:</strong> ada sejumlah besar solusi siap pakai (kerangka kerja) untuk bekerja dengan jaringan saraf: </p><br><p><img src="https://habrastorage.org/webt/jt/il/97/jtil97rhtusvazj6iared1q_hnc.png"></p><br><p>  Semua paket ini menyelesaikan tugas utama untuk pengembang jaringan saraf: konstruksi dan pelatihan NN atau pencarian bobot "optimal".  Dan metode utama pencarian ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Backpropagation</a> .  Itu diciptakan pada tahun 70-an abad terakhir, seperti yang ditunjukkan oleh artikel di tautan di atas, selama ini, sebagai bagian bawah kapal, ia telah memperoleh berbagai peningkatan, tetapi intinya sama: menemukan koefisien bobot dengan basis contoh pelatihan dan sangat diinginkan bahwa setiap orang contoh-contoh ini berisi jawaban yang sudah jadi dalam bentuk sinyal keluaran dari jaringan saraf.  Pembaca mungkin keberatan dengan saya.  bahwa jaringan belajar mandiri dari berbagai kelas dan prinsip telah ditemukan, tetapi semuanya tidak berjalan lancar di sana, sejauh yang saya mengerti.  Tentu saja, ada rencana untuk mempelajari kebun binatang ini lebih terinci, tetapi saya pikir saya akan menemukan orang-orang yang berpikiran sama bahwa sepeda buatan DIY, bahkan yang paling melengkung, lebih dekat ke hati pencipta daripada klon pengantar sepeda yang ideal. <br>  Memahami bahwa server game kemungkinan besar tidak akan memiliki perpustakaan ini dan daya komputasi yang dialokasikan oleh penyelenggara karena 1 inti prosesor jelas tidak cukup untuk kerangka kerja yang berat, penulis kemudian membuat sepeda motornya sendiri.  Komentar penting tentang ini berakhir. </p><br><p>  Mari kita kembali ke gambar yang menggambarkan mungkin jaringan syaraf yang paling sederhana dengan lapisan tersembunyi (alias lapisan tersembunyi atau lapisan tersembunyi).  Sekarang penulis sendiri terus menatap gambar dengan ide-ide pada contoh sederhana ini untuk mengungkapkan kepada pembaca kedalaman jaringan saraf tiruan.  Ketika semuanya disederhanakan menjadi primitif, lebih mudah untuk memahami esensinya.  Intinya adalah bahwa neuron lapisan tersembunyi tidak memiliki apa-apa untuk diringkas.  Dan kemungkinan besar ini bahkan bukan jaringan saraf, dalam buku teks NN yang paling sederhana adalah jaringan dengan dua input.  Jadi di sinilah kita, seolah-olah, para penemu jaringan yang paling sederhana. </p><br><p>  Mari kita coba gambarkan jaringan saraf ini (pseudocode): <br>  Kami memperkenalkan topologi jaringan dalam bentuk array, di mana setiap elemen sesuai dengan lapisan dan jumlah neuron di dalamnya: </p><br><p><code>int array Topology= { 1, 1, 1}</code> <br>  Kita juga membutuhkan array float dari bobot jaringan saraf W, mengingat jaringan kami sebagai “feed forward neural networks (FF atau FFNN)”, di mana setiap neuron dari lapisan saat ini terhubung ke masing-masing neuron dari lapisan berikutnya, kita mendapatkan dimensi dari susunan W [jumlah lapisan] , jumlah neuron di lapisan, jumlah neuron di lapisan].  Tidak cukup penyandian yang optimal, tetapi mengingat nafas panas GPU di suatu tempat yang sangat dekat dalam teks, itu bisa dimengerti. <br>  Prosedur <code>CalculateSize</code> singkat untuk menghitung jumlah neuron neuron dan jumlah koneksi mereka di jaringan saraf <code>dendritecount</code> , saya pikir akan menjelaskan lebih baik kepada penulis sifat dari koneksi ini: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> CalculateSize(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Topology, <span class="hljs-type"><span class="hljs-type">int</span></span> neuroncount, <span class="hljs-type"><span class="hljs-type">int</span></span> dendritecount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : Topology) // i         neuroncount += i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> layer = <span class="hljs-number"><span class="hljs-number">0</span></span>, layer &lt;Topology.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>, layer++) //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, i &lt; Topology[layer] + <span class="hljs-number"><span class="hljs-number">1</span></span>, i++) //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, j &lt; Topology[layer + <span class="hljs-number"><span class="hljs-number">1</span></span>], j++) //   dendritecount++; }</code> </pre> <br><p>  Pembaca saya, orang yang sudah mengetahui semua ini, penulis sampai pada pendapat ini pada artikel pertama, tentu tidak akan bertanya: mengapa pada loop ketiga bersarang Topologi [layer1 +1], bukan Topologi [layer1], yang memberi lebih banyak pada neuron daripada pada topologi jaringan .  Saya tidak akan menjawab.  Berguna juga bagi pembaca untuk bertanya pekerjaan rumah. </p><br><p>  Kami hampir selangkah lagi dari membangun jaringan saraf yang berfungsi.  Tetap menambahkan fungsi menjumlahkan sinyal pada input neuron dan aktivasi.  Ada banyak fungsi aktivasi, tetapi yang paling dekat dengan sifat neuron adalah Sigmoid dan Tangensoid <em>(mungkin lebih baik untuk menyebutnya bahwa, meskipun nama ini tidak digunakan dalam literatur, maksimumnya bersinggungan, tetapi ini adalah nama dari grafik, meskipun apa grafik jika itu bukan refleksi dari fungsi?)</em> </p><br><p>  Jadi di sini kita memiliki fungsi aktivasi neuron (mereka ada dalam gambar, di bagian bawahnya) </p><br><pre> <code class="hljs go">float Sigmoid(float x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">-10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (float)(<span class="hljs-number"><span class="hljs-number">1.0f</span></span> / (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> + expf(-x))); }</code> </pre> <br><p>  Sigmoid mengembalikan nilai dari 0 hingga 1. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tanh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">-10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10.0f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(tanhf(x)); }</code> </pre> <br><p>  Nilai tangentoid mengembalikan dari -1 ke 1. </p><br><p>  Gagasan utama dari sinyal yang melewati jaringan saraf adalah gelombang: sinyal diumpankan ke neuron input -&gt; melalui koneksi saraf sinyal menuju ke lapisan kedua -&gt; neuron dari lapisan kedua merangkum sinyal yang telah mencapai mereka diubah oleh bobot interneuronal -&gt; ditambahkan melalui bobot bias tambahan -&gt; kita menggunakan fungsi aktivasi-&gt; dan kita pergi ke lapisan berikutnya (baca siklus pertama dari contoh dengan lapisan), yaitu, mengulangi rantai dari awal hanya neuron dari lapisan berikutnya akan menjadi neuron input.  Dalam penyederhanaan, Anda bahkan tidak perlu menyimpan nilai-nilai neuron dari seluruh jaringan, Anda hanya perlu menyimpan bobot NN dan nilai-nilai neuron dari lapisan aktif. </p><br><p>  Sekali lagi, kami mengirim sinyal ke input NN, gelombang berlari melalui lapisan dan pada lapisan keluaran kami menghapus nilai yang diperoleh. </p><br><p>  Di sini, dari selera pembaca, adalah mungkin untuk menyelesaikan pemrograman dengan menggunakan rekursi atau hanya siklus tiga seperti penulis, untuk mempercepat perhitungan, Anda tidak perlu pagar objek dalam bentuk neuron dan koneksi mereka dan OOP lainnya.  Sekali lagi, ini adalah karena perasaan perhitungan GPU dekat, dan pada GPU, karena sifat paralelisme massa mereka, OOP sedikit terhenti, ini relatif terhadap c # dan C ++. </p><br><p>  Lebih lanjut, pembaca diundang untuk secara independen menggunakan cara membangun jaringan saraf dalam kode, dengan keinginan pembacanya secara sukarela, ketidakhadiran yang cukup jelas dan akrab bagi penulis, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk contoh membangun NN</a> dari awal, ada banyak contoh dalam jaringan, sehingga akan sulit untuk tersesat, seperti itu semudah jaringan saraf distribusi langsung pada gambar di atas. </p><br><p>  Tetapi di mana pembaca akan berseru, yang belum meninggalkan bagian sebelumnya, dan akan benar, di masa kanak-kanak, penulis menentukan nilai buku dengan ilustrasi untuk itu.  Anda disini: </p><br><p><img src="https://habrastorage.org/webt/03/jl/dw/03jldwzryoeaxscxxtfi3deakie.jpeg"></p><br><p>  Dalam gambar kita melihat neuron berulang dan NN yang dibangun dari neuron seperti itu disebut berulang atau RNN.  Jaringan saraf yang ditentukan memiliki memori jangka pendek dan dipilih oleh penulis untuk bot sebagai yang paling menjanjikan dalam hal adaptasi dengan proses permainan.  Tentu saja, penulis membangun jaringan saraf distribusi langsung, tetapi dalam proses mencari solusi "efektif" ia beralih ke RNN. </p><br><p>  Neuron rekuren memiliki status C tambahan, yang terbentuk setelah lewatnya sinyal pertama melalui neuron, Centang + 0 pada timeline.  Dengan kata sederhana, ini adalah salinan sinyal keluaran dari neuron.  Pada langkah kedua, baca Tick + 1 (karena jaringan beroperasi pada frekuensi bot permainan dan server), nilai C kembali ke input dari layer saraf melalui bobot tambahan dan dengan demikian berpartisipasi dalam pembentukan sinyal, tetapi sudah pada Tick + 1 waktu. </p><br><p>  <em>Catatan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam karya kelompok penelitian tentang pengelolaan bot game NN</a> , ada kecenderungan untuk menggunakan dua ritme untuk jaringan saraf, satu ritme adalah frekuensi gim Tick, ritme kedua, misalnya, dua kali lebih lambat dari yang pertama.</em>  <em>Bagian NN yang berbeda beroperasi pada frekuensi yang berbeda, yang memberikan visi berbeda tentang situasi gim di dalam NN, sehingga meningkatkan fleksibilitasnya.</em> </p><br><p>  Untuk membangun RNN dalam kode bot, kami memperkenalkan array tambahan ke dalam topologi, di mana setiap elemen terkait dengan layer dan jumlah status saraf di dalamnya: </p><br><p> <code>int array TopologyNN= { numberofSensors, 16, 8, 4}</code> <br> <code>int array TopologyRNN= { 0, 16, 0, 0 }</code> </p> <br><p>  Dapat dilihat dari topologi di atas bahwa lapisan kedua berulang, karena mengandung keadaan saraf.  Kami juga memperkenalkan bobot tambahan dalam bentuk pelampung dari array WRR, dimensi yang sama dengan array W. </p><br><p>  Hitungan koneksi dalam jaringan saraf kita akan sedikit berubah: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int layer = <span class="hljs-number"><span class="hljs-number">0</span></span>, layer &lt; TopologyNN.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>, layer++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; TopologyNN[layer] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; TopologyNN[layer + <span class="hljs-number"><span class="hljs-number">1</span></span>] , <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) dendritecount++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int layer = <span class="hljs-number"><span class="hljs-number">0</span></span>, layer &lt; TopologyRNN.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>, layer++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt; TopologyRNN[layer] + <span class="hljs-number"><span class="hljs-number">1</span></span> , <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>&lt; TopologyRNN[layer], <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) dendritecount++;</code> </pre> <br><p>  Penulis akan melampirkan kode umum untuk jaringan saraf berulang di akhir artikel ini, tetapi hal utama yang perlu dipahami adalah prinsip: bagian dari gelombang melalui lapisan dalam kasus NN berulang tidak mengubah apa pun secara mendasar, hanya satu istilah lagi ditambahkan ke fungsi aktivasi neuron.  Ini adalah istilah keadaan neuron pada Tick sebelumnya dikalikan dengan berat koneksi saraf. </p><br><p>  Kami berasumsi bahwa teori dan praktik jaringan saraf telah disegarkan, tetapi penulis jelas menyadari bahwa ia belum membawa pembaca lebih dekat untuk memahami bagaimana cara mengajarkan struktur sederhana jaringan saraf ini untuk membuat keputusan apa pun dalam permainan.  Kami tidak memiliki perpustakaan dengan contoh untuk mengajar NN.  Dalam kelompok Internet pengembang bot, ada pendapat: beri kami file log dalam bentuk koordinat bot dan informasi game lainnya untuk membentuk perpustakaan contoh.  Tetapi penulis, sayangnya, tidak dapat menemukan cara menggunakan file log ini untuk pelatihan NN.  Saya akan senang mendiskusikan hal ini dalam komentar di artikel.  Oleh karena itu, satu-satunya metode yang tersedia bagi penulis untuk memahami metode pelatihan, atau lebih tepatnya menemukan keseimbangan saraf yang efektif (koneksi saraf), adalah algoritma genetika. </p><br><p>  Mempersiapkan gambar tentang prinsip-prinsip algoritma genetika: </p><br><p><img src="https://habrastorage.org/webt/-3/ex/ls/-3exlspxldh64avmkbi_3vuewou.jpeg"></p><br><p>  Jadi <strong>algoritma genetika</strong> . </p><br><p>  Penulis akan mencoba untuk tidak mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori proses ini</a> , tetapi hanya mengingat minimum yang diperlukan untuk melanjutkan membaca artikel secara penuh. <br>  Dalam algoritma genetika, fluida kerja utama adalah gen (DNA adalah nama molekul).  Genom dalam kasus kami adalah serangkaian gen berurutan atau array satu dimensi dari float panjang ... </p><br><p>  Pada tahap awal pekerjaan dengan jaringan saraf yang baru dibangun, perlu menginisialisasi itu.  Inisialisasi mengacu pada penugasan nilai acak dari -1 ke 1 untuk keseimbangan saraf.Penulis telah bertemu menyebutkan bahwa kisaran nilai dari -1 hingga 1 terlalu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstrim</a> dan jaringan terlatih memiliki bobot dalam kisaran yang lebih kecil, misalnya, dari -0,5 hingga 0,5 dan bahwa Anda harus mengambil rentang nilai awal yang sangat baik dari -1 hingga 1. Tetapi kita akan menggunakan cara klasik untuk mengumpulkan semua kesulitan dalam satu gerbang dan mengambil segmen seluas mungkin dari variabel acak awal sebagai dasar untuk menginisialisasi jaringan saraf. </p><br><p>  Sekarang sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penambangan</a> akan terjadi.  Kami akan menganggap bahwa panjang (ukuran) genom bot akan sama dengan panjang total array dari jaringan saraf TopologiNN. Panjang + TopologiRNN. Panjang bukan apa-apa yang penulis habiskan waktu pembaca pada prosedur untuk menghitung koneksi saraf. </p><br><p>  <em>Catatan: Seperti yang telah dicatat oleh pembaca untuk dirinya sendiri, kami hanya mentransfer bobot jaringan saraf ke genotipe, struktur koneksi, fungsi aktivasi, dan status neuron tidak ditransmisikan.</em>  <em>Untuk algoritma genetika, hanya koneksi saraf yang cukup, yang menunjukkan bahwa mereka adalah pembawa informasi.</em>  <em>Ada perkembangan di mana algoritma genetika juga mengubah struktur koneksi dalam jaringan saraf dan cukup sederhana untuk mengimplementasikannya.</em>  <em>Di sini, penulis menyisakan ruang untuk kreativitas bagi pembaca, meskipun ia sendiri akan memikirkannya dengan minat: Anda perlu memahami menggunakan dua genom independen dan dua fungsi kebugaran (disederhanakan dua algoritma genetika independen) atau Anda semua dapat menggunakan gen dan algoritma yang sama.</em> </p><br><p>  Dan karena kami menginisialisasi NN dengan variabel acak, kami menginisialisasi genom.  Proses sebaliknya juga dimungkinkan: inisialisasi genotipe dengan variabel acak dan selanjutnya disalin ke bobot saraf.  Pilihan kedua adalah umum.  Karena algoritma genetika dalam program sering kali ada terlepas dari esensi itu sendiri dan dikaitkan dengannya hanya oleh data genom dan nilai fungsi kebugaran ... Hentikan, hentikan, pembaca akan berkata, gambar dengan jelas menunjukkan populasi dan bukan kata tentang genom individu. </p><br><p>  Oke, tambahkan beberapa gambar ke tungku pikiran pembaca: </p><br><p><img src="https://habrastorage.org/webt/h5/dz/ho/h5dzhojhlf6b1xqsol30qo63mdo.jpeg"></p><br><p>  Karena penulis melukis gambar-gambar sebelum menulis teks artikel, mereka mendukung teks, tetapi tidak mengikuti huruf ke huruf dari cerita saat ini. </p><br><p>  Dari informasi yang diambil dapat disimpulkan bahwa badan kerja utama dari algoritma genetika adalah populasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">genom</a> .  Ini agak bertentangan dengan apa yang penulis katakan sebelumnya, tetapi bagaimana di dunia nyata melakukannya tanpa kontradiksi kecil.  Kemarin, matahari berputar mengelilingi bumi, dan hari ini penulis berbicara tentang jaringan saraf di dalam bot perangkat lunak.  Tidak heran dia ingat oven alasan. <br>  Saya percaya pembaca sendiri untuk memilah masalah kontradiksi dunia.  Dunia bot sepenuhnya mandiri untuk artikel ini. </p><br><p>  Tetapi apa yang penulis telah berhasil lakukan, pada bagian artikel ini, adalah membentuk populasi bot. <br>  Mari kita melihatnya dari sisi perangkat lunak: </p><br><p>  Ada Bot (bisa berupa objek di OOP, struktur, meskipun mungkin juga objek atau hanya array data).  Di dalam, Bot berisi informasi tentang koordinatnya, kecepatan, massa, dan informasi lain yang berguna dalam proses permainan, tetapi hal utama bagi kami sekarang adalah bahwa ia berisi tautan ke genotipe atau genotipe itu sendiri, tergantung pada implementasinya.  Kemudian Anda dapat pergi dengan cara yang berbeda, membatasi diri pada array bobot jaringan saraf atau memperkenalkan susunan genotipe tambahan, karena akan lebih mudah bagi pembaca untuk membayangkan ini dalam imajinasi mereka.  Pada tahap pertama, penulis dalam program ini mengalokasikan susunan neurobalansi dan genotipe.  Kemudian dia menolak untuk menggandakan informasi dan membatasi dirinya pada bobot jaringan saraf. </p><br><p>  Mengikuti logika cerita, Anda harus memberi tahu bahwa populasi bot adalah array dari bot di atas.  Game apa itu ... Hentikan lagi, siklus game apa?  para pengembang dengan sopan menyediakan tempat untuk hanya satu Bot di program simulasi dunia game di server atau maksimum empat bot dalam simulator lokal.  Dan jika Anda mengingat topologi jaringan saraf yang dipilih oleh penulis: </p><br><p><img src="https://habrastorage.org/webt/vh/1d/xq/vh1dxqmwqoejzszyh3zpfyykve4.jpeg"></p><br><p>  Dan untuk menyederhanakan cerita, anggaplah bahwa genotipe berisi sekitar 1000 koneksi saraf, omong-omong, dalam simulator, genotipe terlihat seperti ini (merah adalah nilai gen negatif, hijau adalah nilai positif, setiap baris adalah genom terpisah): </p><br><p><img src="https://habrastorage.org/webt/ri/h0/s-/rih0s-ss3gaflldpts95rm9yo4u.jpeg"></p><br><p>  <em>Catatan untuk foto: seiring waktu, pola berubah ke arah dominasi salah satu solusi, garis vertikal adalah gen genotipe yang umum.</em> </p><br><p>  Jadi, kami memiliki 1000 gen dalam genotipe dan maksimum empat bot dalam program simulator dunia game dari penyelenggara kompetisi.  Berapa kali Anda perlu menjalankan simulasi pertempuran bots sehingga dengan kekerasan, bahkan yang paling cerdas, lebih dekat dalam mencari "efektif" <br>  genotipe, baca kombinasi "efektif" koneksi saraf, asalkan masing-masing koneksi saraf bervariasi dari -1 hingga 1 dalam langkah, dan langkah mana?  inisialisasi adalah float acak, itu adalah 15 tempat desimal.  Langkahnya belum jelas bagi kami.  Pada jumlah varian kombinasi bobot saraf, penulis mengasumsikan bahwa ini adalah angka tak terbatas, ketika memilih ukuran langkah tertentu, mungkin angka terbatas, tetapi dalam kasus apa pun, angka-angka ini jauh lebih dari 4 tempat di simulator, bahkan mempertimbangkan peluncuran berurutan dari antrian bot ditambah peluncuran simultan simultan, hingga 10 pada satu komputer (untuk penggemar pemrograman vintage: komputer). </p><br><p><img src="https://habrastorage.org/webt/it/-8/if/it-8ifszotccnx4wguexdtditpm.jpeg"></p><br><p>  Saya harap gambar-gambar ini membantu pembaca. </p><br><p>  Di sini Anda perlu berhenti sejenak dan berbicara tentang arsitektur solusi perangkat lunak.  Karena solusi dalam bentuk bot perangkat lunak terpisah yang diunggah ke situs kompetisi tidak lagi cocok.  Itu perlu untuk memisahkan bermain bot sesuai dengan aturan kompetisi dalam kerangka ekosistem penyelenggara dan program yang mencoba untuk menemukan konfigurasi jaringan saraf untuknya.  Diagram berikut diambil dari presentasi untuk konferensi, tetapi umumnya mencerminkan gambaran nyata. </p><br><p><img src="https://habrastorage.org/webt/-i/hb/ph/-ihbph2b0hlv3lfzxze7ihmu3-q.jpeg"></p><br><p>  Dia mengingat sebuah lelucon berjanggut: </p><br><p>  <em>Organisasi besar.</em> <em><br></em>  <em>Waktu 18.00, semua karyawan bekerja sebagai satu.</em>  <em>Tiba-tiba, salah satu karyawan mematikan komputer, berpakaian dan pergi.</em> <em><br></em>  <em>Semua orang mengikutinya dengan ekspresi terkejut.</em> <em><br></em>  <em>Hari berikutnya</em>  <em>Pada pukul 18.00 karyawan yang sama mematikan komputer dan pergi.</em>  <em>Semua orang terus bekerja dan mulai berbisik dengan perasaan tidak senang.</em> <em><br></em>  <em>Keesokan harinya.</em>  <em>Pada pukul 18.00 karyawan yang sama mematikan komputer ...</em> <em><br></em>  <em>Seorang kolega mendekatinya:</em> <em><br></em>  <em>-Seperti Anda tidak malu, kami bekerja, akhir kuartal, begitu banyak laporan, kami juga ingin pulang tepat waktu dan Anda adalah individu seperti ...</em> <em><br></em>  <em>- Guys, saya pada umumnya LIBURAN!</em> </p><br><p>  ... untuk dilanjutkan. </p><br><p>  Ya, saya hampir lupa melampirkan kode prosedur perhitungan RNN, ini valid dan ditulis secara independen, jadi mungkin ada kesalahan di dalamnya.  Untuk amplifikasi, saya akan membawanya apa adanya, itu dalam c ++ sebagaimana diterapkan pada CUDA (perpustakaan untuk menghitung pada GPU). </p><br><p>  Catatan: array multidimensi tidak cocok dengan GPU, tentu saja ada tekstur dan perhitungan matriks, tetapi mereka merekomendasikan menggunakan array satu dimensi. </p><br><p>  Contoh larik [i, j] dimensi M oleh j berubah menjadi larik bentuk [i * M + j]. </p><br><div class="spoiler">  <b class="spoiler_title">Kode sumber dari prosedur perhitungan RNN</b> <div class="spoiler_text"><pre> <code class="hljs powershell">__global__ void cudaRNN(Bot *bot, argumentsRNN *RNN, ConstantStruct *Const, int *Topology, int *TopologyRNN, int numElements, int gameTick) { int tid = blockIdx.x * blockDim.x + threadIdx.x; int threadN = gridDim.x * blockDim.x; int TopologySize = Const-&gt;TopologySize; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int pos = tid; pos &lt; numElements; pos += threadN) { const int ii = pos; const int iiA = pos*Const-&gt;ArrayDim; int ArrayDim = Const-&gt;ArrayDim; const int iiAT = ii*TopologySize*ArrayDim; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bot[<span class="hljs-type"><span class="hljs-type">pos</span></span>].TTF != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bot[<span class="hljs-type"><span class="hljs-type">pos</span></span>].Mass&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">Topology</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = <span class="hljs-number"><span class="hljs-number">1</span></span>.f; //bias int neuroncount7 = Topology[<span class="hljs-number"><span class="hljs-number">0</span></span>]; neuroncount7++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int layer1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; layer1 &lt; TopologySize - <span class="hljs-number"><span class="hljs-number">1</span></span>; layer1++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j4 = <span class="hljs-number"><span class="hljs-number">0</span></span>; j4 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; j4++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i5 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i5 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>; i5++) { RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j4</span></span>] = RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j4</span></span>] + RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i5</span></span>] * RNN-&gt;NNweights[((<span class="hljs-type"><span class="hljs-type">ii</span></span>*<span class="hljs-type"><span class="hljs-type">TopologySize</span></span> + <span class="hljs-type"><span class="hljs-type">layer1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">i5</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">j4</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TopologyRNN[<span class="hljs-type"><span class="hljs-type">layer1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int j14 = <span class="hljs-number"><span class="hljs-number">0</span></span>; j14 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span>]; j14++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i15 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i15 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span>]; i15++) { RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] = RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] + RNN-&gt;neuronContext[<span class="hljs-type"><span class="hljs-type">iiAT</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> * <span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-type"><span class="hljs-type">i15</span></span>] * RNN-&gt;MNweights[((<span class="hljs-type"><span class="hljs-type">ii</span></span>*<span class="hljs-type"><span class="hljs-type">TopologySize</span></span> + <span class="hljs-type"><span class="hljs-type">layer1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">i15</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>]; } RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] = RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>] + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f* RNN-&gt;MNweights[((<span class="hljs-type"><span class="hljs-type">ii</span></span>*<span class="hljs-type"><span class="hljs-type">TopologySize</span></span> + <span class="hljs-type"><span class="hljs-type">layer1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">Topology</span></span>[<span class="hljs-type"><span class="hljs-type">layer1</span></span>])*<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> + <span class="hljs-type"><span class="hljs-type">j14</span></span>]; //bias=<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int t = <span class="hljs-number"><span class="hljs-number">0</span></span>; t &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; t++) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>] = Tanh(RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>] + RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>]); RNN-&gt;neuronContext[<span class="hljs-type"><span class="hljs-type">iiAT</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span><span class="hljs-type"><span class="hljs-type">Dim</span></span> * <span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>] = RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">t</span></span>]; } //SoftMax /* double sum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt;ArrayDim; ++k) sum += exp(RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">k</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; ArrayDim; ++k) RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">k</span></span>] = exp(RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">k</span></span>]) / sum; */ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; Topology[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; i1++) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i1</span></span>] = Sigmoid(RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i1</span></span>]); //sigma } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layer1 + <span class="hljs-number"><span class="hljs-number">1</span></span> != TopologySize - <span class="hljs-number"><span class="hljs-number">1</span></span>) { RNN-&gt;outputs[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">Topology</span></span>[<span class="hljs-type"><span class="hljs-type">layer1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]] = <span class="hljs-number"><span class="hljs-number">1</span></span>.f; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i2 &lt; ArrayDim; i2++) { RNN-&gt;sums[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>.f; RNN-&gt;sumsContext[<span class="hljs-type"><span class="hljs-type">iiA</span></span> + <span class="hljs-type"><span class="hljs-type">i2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>.f; } } } } }</code> </pre> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417657/">https://habr.com/ru/post/id417657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417647/index.html">RUU tentang perlindungan data pribadi yang disajikan di Belarus - apa yang "di dalamnya"</a></li>
<li><a href="../id417649/index.html">OpenAI Mengatasi Batasan AI yang Signifikan untuk Dota 2</a></li>
<li><a href="../id417651/index.html">Apa yang harus dilakukan pembaca agar Anda membaca lebih lanjut?</a></li>
<li><a href="../id417653/index.html">Buka pelajaran "Konsep dasar basis data"</a></li>
<li><a href="../id417655/index.html">Latar belakang: Roscosmos State Corporation dan pekerjaannya</a></li>
<li><a href="../id417659/index.html">Neuropoet dan bintang pop lainnya di masa depan</a></li>
<li><a href="../id417661/index.html">Aubrey de Gray mengunjungi Joe Rogan</a></li>
<li><a href="../id417665/index.html">Tata bahasa Inggris sebagai matematika. Di mana untuk memulai bagi mereka yang tidak berhasil</a></li>
<li><a href="../id417667/index.html">AI. Pelacak Penghalang Taktis</a></li>
<li><a href="../id417671/index.html">Fitur-fitur baru dari bahasa pemrograman ABAP di webinar dari SAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>