<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèø üêÑ üìñ Advanced Three.js: mat√©riaux de shader et post-traitement ü•õ üò∞ üë®‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe de nombreuses introductions aux bases de l'utilisation de Three.js sur le Web, mais vous remarquerez peut-√™tre une p√©nurie de documents sur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Advanced Three.js: mat√©riaux de shader et post-traitement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436482/"><p><img src="https://habrastorage.org/webt/hh/qv/5o/hhqv5okcynxdjke-qqhtmvokjsw.jpeg"></p><br><p>  Il existe de nombreuses introductions aux bases de l'utilisation de Three.js sur le Web, mais vous remarquerez peut-√™tre une p√©nurie de documents sur des sujets plus avanc√©s.  Et l'un de ces sujets est la combinaison de shaders et de sc√®nes avec des mod√®les tridimensionnels.  Aux yeux de nombreux d√©veloppeurs novices, ce sont des choses apparemment incompatibles de diff√©rents mondes.  Aujourd'hui, en utilisant un exemple simple de ¬´sph√®re de plasma¬ª, nous verrons ce qu'est ShaderMaterial et avec quoi il est mang√©, quel est l'effet Effect et √† quelle vitesse il est possible de faire du post-traitement pour une sc√®ne rendue. </p><a name="habracut"></a><br><p> Il est suppos√© que le lecteur conna√Æt les bases de l'utilisation de Three.js et comprend le fonctionnement des shaders.  Si vous ne l'avez jamais rencontr√© auparavant, je recommande fortement de lire ceci en premier: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction √† la programmation des shaders pour les mises en page</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appliquer la mosa√Øque Voronoi et les masques g√©om√©triques dans les shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentations de produits en trois dimensions sur Three.js pour les plus petits</a> </li></ul><br><p>  Mais commen√ßons ... </p><br><h2 id="shadermaterial--chto-eto">  ShaderMaterial - qu'est-ce que c'est? </h2><br><p>  Nous avons d√©j√† vu comment une texture plate est utilis√©e et comment elle est √©tir√©e sur un objet tridimensionnel.  Comme cette texture √©tait une image ordinaire.  Lorsque nous avons examin√© l'√©criture des shaders de fragments, tout √©tait plat l√† aussi.  Donc: si nous pouvons g√©n√©rer une image plate √† l'aide d'un shader, alors pourquoi ne pas l'utiliser comme texture? </p><br><p>  C'est cette id√©e qui constitue la base du mat√©riau de shader.  Lors de la cr√©ation de mat√©riau pour un objet tridimensionnel, nous indiquons des shaders au lieu d'une texture pour celui-ci.  Dans sa forme de base, il ressemble √† ceci: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// ... }, vertexShader: '...', fragmentShader: '...' });</span></span></code> </pre> <br><p>  Le fragment shader sera utilis√© pour cr√©er la texture du mat√©riau, et vous vous demandez, bien s√ªr, que fera le vertex shader?  Fera-t-il √† nouveau un banal recomptage des coordonn√©es?  Oui, nous allons commencer avec cette option simple, mais nous pouvons √©galement d√©finir un d√©calage ou effectuer d'autres manipulations pour chaque sommet d'un objet tridimensionnel - il n'y a maintenant aucune restriction sur le plan.  Mais il vaut mieux regarder tout cela avec un exemple.  En mots, on comprend peu.  Cr√©ez une sc√®ne et cr√©ez une sph√®re au centre. </p><br><p><img src="https://habrastorage.org/webt/ot/0n/zj/ot0nzjfc89iiwsqqdc2isam_woo.jpeg"></p><br><p>  Comme mat√©riau pour la sph√®re, nous utiliserons ShaderMaterial: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SphereBufferGeometry(<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderMaterial({ <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// . . . }, vertexShader: document.getElementById('sphere-vertex-shader').textContent, fragmentShader: document.getElementById('sphere-fragment-shader').textContent }); const sphere = new THREE.Mesh(geometry, shaderMaterial); SCENE.add(sphere);</span></span></code> </pre> <br><p>  Le vertex shader sera neutre: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Notez que Three.js transmet ses variables uniformes.  Nous n'avons rien √† faire, ils sont implicites.  En eux-m√™mes, ils contiennent toutes sortes de matrices, auxquelles nous avons d√©j√† acc√®s depuis JS, ainsi que la position de la cam√©ra.  Imaginez qu'au d√©but des shaders eux-m√™mes quelque chose soit ins√©r√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// = object.matrixWorld uniform mat4 modelMatrix; // = camera.matrixWorldInverse * object.matrixWorld uniform mat4 modelViewMatrix; // = camera.projectionMatrix uniform mat4 projectionMatrix; // = camera.matrixWorldInverse uniform mat4 viewMatrix; // = inverse transpose of modelViewMatrix uniform mat3 normalMatrix; // = camera position in world space uniform vec3 cameraPosition;</span></span></code> </pre> <br><p>  De plus, plusieurs variables d'attribut sont pass√©es au vertex shader: </p><br><pre> <code class="cpp hljs">attribute vec3 position; attribute vec3 normal; attribute vec2 uv;</code> </pre> <br><p>  Par les noms, il est clair ce que c'est - la position du sommet actuel, la normale √† la surface √† ce point, et les coordonn√©es sur la texture √† laquelle le sommet correspond. </p><br><p>  Traditionnellement, les coordonn√©es dans l'espace sont d√©sign√©es par (x, y, z) et les coordonn√©es sur le plan de texture par (u, v).  D'o√π le nom de la variable.  Vous le rencontrerez souvent dans divers exemples.  En th√©orie, nous devons transf√©rer ces coordonn√©es dans le fragment shader afin d'y travailler avec elles.  Nous le ferons. </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Pour commencer, le shader de fragment devrait ressembler √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EPSILON 0.02 varying vec2 vUv; void main() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((fract(vUv.x * 10.0) &lt; EPSILON) || (fract(vUv.y * 10.0) &lt; EPSILON)) { gl_FragColor = vec4(vec3(0.0), 1.0); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { gl_FragColor = vec4(1.0); } }</span></span></code> </pre> <br><p>  Cr√©ez simplement un maillage.  Si vous r√©fl√©chissez un peu, alors dans l'avion, ce ne sera qu'une grille de carr√©s, mais comme nous la superposons √† une sph√®re, elle est d√©form√©e et se transforme en globe.  Il y a une bonne image sur Wikipedia illustrant ce qui se passe: </p><br><p><img src="https://habrastorage.org/webt/uc/uq/us/ucuqusdhqwfubpgtrpujvwq7uww.png"></p><br><p>  C'est-√†-dire que dans le fragment shader, nous faisons une texture plate, comme au centre de cette illustration, et Three.js la tire ensuite sur la sph√®re.  Tr√®s confortable. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/EGzKOd" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bien s√ªr, pour les mod√®les plus complexes, le balayage sera plus compliqu√©.  Mais g√©n√©ralement, lors de la cr√©ation de divers sites de conception, nous travaillons avec des formes g√©om√©triques simples et il est facile d'imaginer un balayage dans votre t√™te. </p><br><h2 id="ok-a-chto-s-etim-mozhno-delat">  Ok, que pouvez-vous y faire? </h2><br><p>  La principale caract√©ristique est que le mat√©riau du shader peut changer avec le temps.  Ce n'est pas une chose statique que nous avons dessin√©e une fois et oubli√©, nous pouvons l'animer.  De plus, √† la fois en couleur (dans le fragment shader) et en forme (dans le sommet).  Il s'agit d'un outil tr√®s puissant. </p><br><p>  Dans notre exemple, nous ferons un feu enveloppant une sph√®re.  Il y aura deux sph√®res - une ordinaire (√† l'int√©rieur) et la seconde √† partir du mat√©riau du shader (√† l'ext√©rieur, avec un grand rayon).  L'ajout d'une autre sph√®re ne fera aucun commentaire. </p><br><p><img src="https://habrastorage.org/webt/ti/_q/4m/ti_q4mo843ywt0fbjdmd8nmrcmy.jpeg"></p><br><p>  Tout d'abord, ajoutez du temps comme variable uniforme pour les shaders de notre mat√©riau.  Nulle part sans temps.  Nous l'avons d√©j√† fait en JS pur, mais dans Three.js, c'est tout aussi simple.  Laissez le temps dans les shaders √™tre appel√© uTime et stock√© dans la variable TIME: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateUniforms</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ SCENE.traverse(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">child</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> THREE.Mesh &amp;&amp; child.material.type === <span class="hljs-string"><span class="hljs-string">'ShaderMaterial'</span></span>) { child.material.uniforms.uTime.value = TIME; child.material.needsUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); }</code> </pre> <br><p>  Nous mettons √† jour tout √† chaque appel √† la fonction d'animation: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ requestAnimationFrame(animate); TIME += <span class="hljs-number"><span class="hljs-number">0.005</span></span>; updateUniforms(); render(); }</code> </pre> <br><h2 id="ogon">  Le feu </h2><br><p>  La cr√©ation d'un feu est essentiellement tr√®s similaire √† la g√©n√©ration d'un paysage, mais au lieu des hauteurs, la couleur.  Ou la transparence, comme dans notre cas. </p><br><p>  Les fonctions d'al√©atoire et de bruit que nous avons d√©j√† vues, nous ne les analyserons pas en d√©tail.  Tout ce que nous devons faire est de faire du bruit √† diff√©rentes fr√©quences pour ajouter de la vari√©t√© et faire bouger chacun de ces bruits √† des vitesses diff√©rentes.  Vous obtiendrez quelque chose comme des flammes, les grandes se d√©placent lentement, les petites se d√©placent plus rapidement: </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec2 position1 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime); vec2 position2 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">2.0</span></span>); vec2 position3 = vec2(vUv.x * <span class="hljs-number"><span class="hljs-number">4.0</span></span>, vUv.y - uTime * <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color = ( noise(position1 * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + noise(position2 * <span class="hljs-number"><span class="hljs-number">10.0</span></span>) + noise(position3 * <span class="hljs-number"><span class="hljs-number">15.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; gl_FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, color - smoothstep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1.3</span></span>, vUv.y)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 position)</span></span></span><span class="hljs-function"> </span></span>{ vec2 blockPosition = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topLeftValue = rand(blockPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> topRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomLeftValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottomRightValue = rand(blockPosition + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computedValue = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(position)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix(topLeftValue, topRightValue, computedValue.x) + (bottomLeftValue - topLeftValue) * computedValue.y * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - computedValue.x) + (bottomRightValue - topRightValue) * computedValue.x * computedValue.y; }</code> </pre> <br><p>  Pour que la flamme ne couvre pas toute la sph√®re, nous jouons avec le quatri√®me param√®tre de couleur - la transparence - et le lions √† la coordonn√©e y.  Dans notre cas, cette option est tr√®s pratique.  De mani√®re plus g√©n√©rale, nous appliquons un d√©grad√© transparent au bruit. </p><br><blockquote>  Dans des moments comme ceux-ci, il est utile de se souvenir de la fonction smoothstep. </blockquote><p>  En g√©n√©ral, une telle approche pour cr√©er du feu √† l'aide de shaders est un classique.  Vous le rencontrerez souvent √† divers endroits.  Il sera utile de jouer avec des nombres magiques - ils sont d√©finis au hasard dans l'exemple, et √† quoi ressemblera le plasma d√©pend d'eux. </p><br><p>  Pour rendre le feu plus int√©ressant, passons au vertex shader et √† un petit chaman ... </p><br><p>  Comment rendre la flamme un peu "coul√©e" dans l'espace?  Pour les d√©butants, cette question peut poser de grandes difficult√©s, malgr√© sa simplicit√©.  J'ai vu des approches tr√®s complexes pour r√©soudre ce probl√®me, mais essentiellement - nous devons d√©placer en douceur les sommets de la sph√®re le long des lignes ¬´√† partir de son centre¬ª.  √áa va et vient, √ßa va et vient.  Three.js nous a d√©j√† pass√© la position actuelle du sommet et de la normale - nous les utiliserons.  Pour les allers-retours, certaines fonctions limit√©es conviendront, par exemple, √† un sinus.  Vous pouvez bien s√ªr exp√©rimenter, mais le sinus est l'option par d√©faut. </p><br><blockquote>  Je ne sais pas quoi prendre - prenez le sinus.  Mieux encore, la somme des sinus de fr√©quences diff√©rentes. </blockquote><p>  Nous d√©pla√ßons les coordonn√©es normales √† la valeur obtenue et recalculons selon la formule pr√©c√©demment connue. </p><br><pre> <code class="cpp hljs">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; vec3 delta = normal * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(position.x * position.y * uTime / <span class="hljs-number"><span class="hljs-number">10.0</span></span>); vec3 newPosition = position + delta; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Ce que nous obtenons n'est plus tout √† fait une sph√®re.  Ceci ... Je ne sais m√™me pas si celui-ci a un nom.  Mais, encore une fois, n'oubliez pas de jouer avec les cotes - elles affectent beaucoup.  Lors de la cr√©ation de tels effets, souvent quelque chose est s√©lectionn√© par essais et erreurs et il est tr√®s utile de d√©velopper en soi une ¬´intuition math√©matique¬ª - la capacit√© d'imaginer plus ou moins comment une fonction se comporte, comment cela d√©pend de quelles variables. </p><br><p>  √Ä ce stade, nous avons une image int√©ressante, mais un peu maladroite.  Alors d'abord, jetons un coup d'≈ìil au post-traitement, puis passons √† un exemple vivant. </p><br><h2 id="postobrabotka">  Post-traitement </h2><br><p>  La capacit√© de faire quelque chose avec l'image Three.js rendue est une chose tr√®s utile, tout en √©tant injustement oubli√©e dans de nombreuses s√©ries de le√ßons.  Techniquement, cela est impl√©ment√© comme suit: l'image que le rendu nous a donn√©e est envoy√©e √† EffectComposer (tant qu'il s'agit d'une bo√Æte noire), qui chamanise quelque chose en soi et affiche l'image finale sur la toile.  C'est-√†-dire qu'apr√®s le rendu, un module suppl√©mentaire est ajout√©.  Nous transf√©rons les param√®tres √† ce compositeur - que faire de l'image re√ßue.  Un de ces param√®tres est appel√© pass.  Dans un sens, le compositeur fonctionne comme certains Gulp - il ne fait rien, nous lui donnons des plugins qui font d√©j√† le travail.  Il n'est peut-√™tre pas tout √† fait exact de le dire, mais l'id√©e devrait √™tre claire. </p><br><p>  Tout ce que nous utiliserons plus loin n'est pas inclus dans la structure de base de Three.js, nous connectons donc quelques d√©pendances et d√©pendances des d√©pendances elles-m√™mes: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/EffectComposer.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/RenderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/ShaderPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/CopyShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/shaders/LuminosityHighPassShader.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://unpkg.com/three@0.99.0/examples/js/postprocessing/UnrealBloomPass.js'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote>  N'oubliez pas que ces scripts sont inclus dans les trois packages et que vous pouvez mettre tout cela en un seul paquet en utilisant un webpack ou des analogues. </blockquote><p>  Dans sa forme de base, le compositeur est cr√©√© comme ceci: </p><br><pre> <code class="javascript hljs">COMPOSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.EffectComposer(RENDERER); COMPOSER.setSize(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.RenderPass(SCENE, CAMERA); renderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(renderPass);</code> </pre> <br><p>  RenderPass ne fait rien de nouveau.  Il rend juste ce que nous obtenions d'un rendu normal.  En fait, si vous regardez le code source de RenderPass, vous pouvez y trouver le rendu standard.  Puisque maintenant le rendu se passe l√†-bas, nous devons remplacer le rendu par le compositeur dans notre script: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// RENDERER.render(SCENE, CAMERA); COMPOSER.render(SCENE, CAMERA); }</span></span></code> </pre> <br><p>  Cette approche utilisant RenderPass comme premi√®re passe est une pratique standard lorsque vous travaillez avec EffectComposer.  Habituellement, nous devons d'abord obtenir une image rendue de la sc√®ne, puis en faire quelque chose. </p><br><p>  Dans les exemples de Three.js, dans la section de post-traitement, vous pouvez trouver une chose appel√©e UnrealBloomPass.  Il s'agit d'un script port√© par le moteur Unreal.  Il ajoute une petite lueur qui peut √™tre utilis√©e pour cr√©er un √©clairage plus beau.  Ce sera souvent la premi√®re √©tape vers l'am√©lioration de l'image. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bloomPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.UnrealBloomPass( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector2(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth, <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight), <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); bloomPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(bloomPass);</code> </pre> <br><p>  Remarque: l'option renderToScreen est d√©finie uniquement sur le dernier passage que nous avons pass√© au compositeur. </p><br><p>  Mais voyons d√©j√† quel genre d'√©clat ce bloomPass nous a donn√© et comment il s'int√®gre √† la sph√®re: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdegG" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  D'accord, c'est beaucoup plus int√©ressant qu'une simple sph√®re et une source de lumi√®re ordinaire, comme ils sont g√©n√©ralement montr√©s dans les premi√®res le√ßons sur Three.js. </p><br><p>  Mais nous irons encore plus loin ... </p><br><h2 id="bolshe-sheyderov-bogu-sheyderov">  Plus de shaders au dieu shader! </h2><br><p><img src="https://habrastorage.org/webt/kk/ap/ks/kkapksi_a_secwfoh81jjxkgtx4.jpeg"></p><br><p>  Il est tr√®s utile d'utiliser console.log et de regarder la structure du compositeur.  Vous y trouverez des √©l√©ments portant les noms renderTarget1, renderTarget2, etc., o√π les nombres correspondent aux indices des passes pass√©es.  Et puis, il devient clair pourquoi EffectComposer est ainsi appel√©.  Il fonctionne sur le principe des filtres en SVG.  Rappelez-vous, l√†, vous pouvez utiliser le r√©sultat de l'ex√©cution de certains filtres dans d'autres?  Voici la m√™me chose - vous pouvez combiner des effets. </p><br><blockquote>  L'utilisation de console.log pour comprendre la structure interne des objets Three.js et de nombreuses autres biblioth√®ques est tr√®s utile.  Utilisez cette approche plus souvent pour mieux comprendre ce qui est quoi. </blockquote><p>  Ajoutez un autre pass.  Cette fois, ce sera ShaderPass. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = { <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: { <span class="hljs-attr"><span class="hljs-attr">uRender</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: COMPOSER.renderTarget2 }, <span class="hljs-attr"><span class="hljs-attr">uTime</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: TIME } }, <span class="hljs-attr"><span class="hljs-attr">vertexShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-vertex-shader'</span></span>).textContent, <span class="hljs-attr"><span class="hljs-attr">fragmentShader</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'postprocessing-fragment-shader'</span></span>).textContent }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shaderPass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ShaderPass(shader); shaderPass.renderToScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; COMPOSER.addPass(shaderPass);</code> </pre> <br><p>  RenderTarget2 contient le r√©sultat de la passe pr√©c√©dente - bloomPass (c'√©tait le deuxi√®me d'affil√©e), nous l'utilisons comme texture (c'est essentiellement une image rendue plate) et la transmettons comme variable uniforme au nouveau shader. </p><br><p>  Il vaut probablement la peine de freiner et de r√©aliser toute la magie ici ... </p><br><p>  Ensuite, cr√©ez un vertex shader simple.  Dans la plupart des cas, √† ce stade, nous n'avons rien √† faire avec les sommets, nous passons uniquement les coordonn√©es (u, v) au fragment shader: </p><br><pre> <code class="cpp hljs">varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Et de mani√®re fragmentaire, nous pouvons nous amuser √† notre go√ªt et notre couleur.  Par exemple, nous pouvons ajouter un l√©ger effet de p√©pin, tout rendre noir et blanc et jouer avec la luminosit√© / le contraste: </p><br><pre> <code class="cpp hljs">uniform sampler2D uRender; uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> uTime; varying vec2 vUv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> randomValue = rand(vec2(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(vUv.y * <span class="hljs-number"><span class="hljs-number">7.0</span></span>), uTime / <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec4 color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomValue &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { color = texture2D(uRender, vec2(vUv.x + randomValue - <span class="hljs-number"><span class="hljs-number">0.01</span></span>, vUv.y)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { color = texture2D(uRender, vUv); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightness = (color.r + color.g + color.b) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; color.rgb = vec3(smoothstep(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, lightness)); gl_FragColor = color; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec2 seed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(dot(seed, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre> <br><p>  Regardons le r√©sultat: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/MZdeKB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Comme vous pouvez le voir, des filtres ont √©t√© superpos√©s √† la sph√®re.  Il est toujours en trois dimensions, rien n'a cass√©, mais sur la toile nous avons une image trait√©e. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Les mat√©riaux de shader et le post-traitement dans Three.js sont deux petits outils tr√®s puissants qui valent vraiment la peine d'√™tre utilis√©s.  Il existe de nombreuses options pour leur utilisation - tout est limit√© par votre imagination.  M√™me les sc√®nes les plus simples avec leur aide peuvent √™tre modifi√©es au-del√† de la reconnaissance. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436482/">https://habr.com/ru/post/fr436482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436468/index.html">Exp√©rience l√©gislative avec l'innovation num√©rique</a></li>
<li><a href="../fr436472/index.html">Conf√©rence DEFCON 20. Capture en 60 secondes: d'un compte invit√© √† un administrateur de domaine Windows. Partie 1</a></li>
<li><a href="../fr436474/index.html">Conf√©rence DEFCON 20. Capture en 60 secondes: d'un compte invit√© √† un administrateur de domaine Windows. 2e partie</a></li>
<li><a href="../fr436476/index.html">Cloud pour les assureurs</a></li>
<li><a href="../fr436480/index.html">J'ai fait un bot qui communique avec les recruteurs pour moi, et j'ai aim√©</a></li>
<li><a href="../fr436484/index.html">O√π trouver les param√®tres DNS sur MacOS</a></li>
<li><a href="../fr436486/index.html">Que se passe-t-il sur le march√© du podcast audio</a></li>
<li><a href="../fr436488/index.html">Currying et application partielle en C ++ 14</a></li>
<li><a href="../fr436490/index.html">Motorola pr√©voit d'introduire l'incarnation de Razr v3</a></li>
<li><a href="../fr436492/index.html">Nous recherchons des conf√©renciers au 10e DIY Mitap 17 f√©vrier 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>