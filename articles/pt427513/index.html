<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôè ‚ûø üëâüèæ Como analisar o despejo de encadeamento ‚ô¶Ô∏è üåá üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem alguns t√≥picos sobre os internos da JVM no programa de curso Java Developer . Entendemos os mecanismos de trabalho de cole√ß√µes, bytecode, cole...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como analisar o despejo de encadeamento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i>Existem alguns t√≥picos sobre os internos da JVM no programa de curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java Developer</a> .</i>  <i>Entendemos os mecanismos de trabalho de cole√ß√µes, bytecode, coletores de lixo, etc.</i>  <i>Hoje, oferecemos sua aten√ß√£o para a tradu√ß√£o de um artigo bastante interessante sobre despejo de threads.</i>  <i>O que √©, como obt√™-lo e como us√°-lo.</i> <br><br>  Deseja aprender a analisar o despejo de threads?  V√° abaixo do gato para saber mais sobre como obter despejo de encadeamento em Java e o que fazer com ele mais tarde. <br><a name="habracut"></a><br>  A maioria dos aplicativos Java modernos s√£o multithread.  O multithreading pode expandir significativamente a funcionalidade do aplicativo, ao mesmo tempo em que introduz uma complexidade significativa. <br><br>  Em um aplicativo de thread √∫nico, todos os recursos (mem√≥ria compartilhada, opera√ß√µes de entrada / sa√≠da, etc.) podem ser usados ‚Äã‚Äãsem sincroniza√ß√£o, porque  a qualquer momento, apenas um encadeamento usa o recurso. <br><br>  No caso de aplicativos multithread, √© necess√°rio encontrar um compromisso entre complicar o programa e um poss√≠vel aumento no desempenho, quando v√°rios threads podem usar todo o CPU (CPU) dispon√≠vel (geralmente mais de um).  Se tudo for feito corretamente, usando o multithreading (formalizado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lei da Amdahl</a> ), voc√™ poder√° obter um aumento significativo no desempenho do aplicativo.  No entanto, √© preciso lembrar de fornecer acesso simult√¢neo de v√°rios fluxos a um recurso compartilhado.  Na maioria dos casos, estruturas como o Spring encapsulam o trabalho com threads e ocultam muitos detalhes t√©cnicos dos usu√°rios.  No entanto, no caso de usar estruturas complexas modernas, algo pode dar errado, e n√≥s, como usu√°rios, encontraremos dificuldades para solucionar erros de multithreading. <br><br>  Felizmente, o Java est√° equipado com um mecanismo especial para obter informa√ß√µes sobre o estado atual de todos os encadeamentos a qualquer momento - este √© um dump de encadeamento (um tipo de captura instant√¢nea).  Neste artigo, aprenderemos como obter um despejo de segmento para um aplicativo de tamanho realista e como analisar esse despejo. <br><br>  Sup√µe-se que o leitor tenha informa√ß√µes b√°sicas sobre programa√ß√£o multithread e esteja ciente dos problemas de sincroniza√ß√£o de threads e do uso de recursos compartilhados.  No entanto, n√£o ser√° sup√©rfluo atualizar alguns termos e conceitos b√°sicos. <br><br><h4>  Terminologia b√°sica </h4><br>  √Ä primeira vista, os despejos de encadeamento Java podem parecer uma "letra chinesa", os seguintes conceitos s√£o essenciais para entend√™-lo.  Em geral, vamos repetir os termos b√°sicos de multithreading, que usaremos para analisar dumps. <br><br><ul><li> <strong>Thread</strong> ou thread √© uma unidade multithreading discreta gerenciada pela Java Virtual Machine (JVM).  Os encadeamentos da JVM correspondem aos encadeamentos no sistema operacional (SO) - encadeamentos nativos, que implementam o mecanismo de execu√ß√£o de c√≥digo. <br><br>  Cada encadeamento possui um identificador e nome exclusivos.  Os fluxos podem ser "dem√¥nios" e "n√£o dem√¥nios". <br><br>  O programa termina quando todos os encadeamentos n√£o daemon terminam ou o m√©todo <i>Runtime.exit</i> √© <i>chamado</i> .  Os "dem√¥nios" em funcionamento n√£o afetam a conclus√£o do programa.  I.e.  A JVM est√° aguardando a finaliza√ß√£o e o desligamento de todos os "n√£o-dem√¥nios"; eles n√£o est√£o prestando aten√ß√£o aos "n√£o-dem√¥nios". <br><br>  Para mais informa√ß√µes, consulte a documenta√ß√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe Thread</a> . <br>  Um fluxo pode estar em um dos seguintes estados: <br><br><ul><li>  <strong>T√≥pico ativo</strong> ou "ativo" - um t√≥pico que faz algum trabalho (estado normal). </li><li>  <strong>Encadeamento bloqueado</strong> ou "bloqueado" - um encadeamento que tentou entrar na se√ß√£o sincronizada (sincronizada), mas outro encadeamento j√° conseguiu inserir esse bloco primeiro, e todos os encadeamentos a seguir que tentam inserir o mesmo bloco s√£o bloqueados. </li><li>  <strong>Aguardando thread</strong> ou "waiting" - um thread que chamou o m√©todo <i>wait</i> (possivelmente com um tempo limite) e agora aguarda outro m√©todo para executar <i>notify</i> ou <i>nonifyAll</i> no mesmo objeto. <br><br>  Observe que o encadeamento n√£o √© considerado "aguardando" se tiver chamado de espera com tempo limite e esse tempo limite expirar. </li><li>  <strong>Encadeamento adormecido</strong> ou "adormecido" - um encadeamento que n√£o est√° em execu√ß√£o no momento, porque  executou o m√©todo Thread.sleep (indicando a dura√ß√£o do "sono"). </li></ul></li><li>  <strong>O monitor</strong> √© um mecanismo usado pela JVM para fornecer acesso multiencadeado a um √∫nico objeto.  O mecanismo √© iniciado usando a <i>palavra-chave sincronizada</i> especial. <br><br>  Cada objeto em Java possui um monitor com o qual o encadeamento pode ser sincronizado, ou seja,  defina um bloqueio, o que garante que nenhum outro encadeamento tenha acesso a esse objeto at√© que o bloqueio seja liberado, ou seja,  thread - o propriet√°rio do bloqueio n√£o sair√° do bloco <i>sincronizado</i> . <br><br>  Consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">se√ß√£o Sincroniza√ß√£o (17.1) da Java Langauge Specification (JLS) para obter mais informa√ß√µes</a> . <br></li><li>  <strong>Deadlock</strong> √© uma situa√ß√£o em que um encadeamento, digamos A, bloqueia um recurso, ele precisa de outro recurso bloqueado por outro encadeamento, digamos B. O fluxo B n√£o libera esse recurso, porque  Para concluir uma determinada opera√ß√£o, ele precisa de um recurso bloqueado pelo encadeamento A. Acontece que o encadeamento A est√° aguardando o desbloqueio do recurso pelo encadeamento B, que est√° aguardando que outro recurso seja desbloqueado pelo encadeamento A. E, portanto, os encadeamentos est√£o esperando um pelo outro.  Como resultado, o programa inteiro trava e aguarda que os threads sejam desbloqueados e continuem funcionando.  Pode haver muitos encadeamentos em um conflito.  Esse problema √© conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Problema dos Fil√≥sofos do Jantar"</a> . <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> √© uma situa√ß√£o em que o encadeamento A for√ßa o encadeamento B a executar alguma a√ß√£o, que por sua vez faz com que o encadeamento A execute a a√ß√£o inicial, que mais uma vez causa a a√ß√£o do encadeamento B. √â obtida uma depend√™ncia c√≠clica.  Isso pode ser imaginado como um cachorro correndo atr√°s de sua cauda.  Da mesma forma que <i>Deadlock</i> , em uma situa√ß√£o de Livelock, o programa n√£o progride, ou seja,  n√£o executa uma a√ß√£o √∫til, no entanto, nessa situa√ß√£o, os encadeamentos n√£o s√£o bloqueados. <br></li></ul><br>  A terminologia apresentada n√£o √© exaustiva para descrever o mundo do multithreading, mas isso √© suficiente para come√ßar a analisar despejos de encadeamento. <br><br>  Informa√ß√µes mais detalhadas podem ser encontradas nestas fontes: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Se√ß√£o 17 da simultaneidade JLS</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java na pr√°tica</a> <br><br>  Usando esses conceitos simples sobre fluxo em Java, podemos criar um aplicativo de teste.  Para esta aplica√ß√£o, compilaremos o despejo de threads.  Analisaremos o dump resultante e extrairemos informa√ß√µes √∫teis sobre os fluxos de aplicativos atuais. <br><br><h4>  Criando um programa de amostra </h4><br>  Antes de criar o despejo de encadeamento, precisamos desenvolver um aplicativo Java.  O tradicional "ol√°, mundo!"  muito simples para o nosso prop√≥sito, e um despejo de tamanho m√©dio do aplicativo pode ser muito complicado para demonstrar.  Com base nisso, criaremos um aplicativo bastante simples no qual dois threads s√£o criados.  E os t√≥picos entram em conflito: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Este programa cria dois recursos: resourceA e resourceB e inicia dois threads: threadLockingResourceAFirst e threadLockingResourceBFirst, que bloqueiam os recursos um do outro. <br><br>  A causa do conflito √© um bloqueio "cruzado" de recursos por encadeamentos. <br><br>  O motivo da ocorr√™ncia de conflito √© uma tentativa de capturar recursos "mutuamente", ou seja,  O encadeamento threadLockingResourceAFirst captura o recurso resourceA, o encadeamento threadLockingResourceBFirst captura o recurso resourceB.  Depois disso, o threadLockingResourceAFirst, sem liberar seu recurso, tenta capturar o recurso B, e o threadLockingResourceBFirst, sem liberar seu recurso, tenta capturar o recursoA.  Como resultado, os threads est√£o bloqueados.  Um atraso de 1s foi adicionado para garantir o bloqueio.  Os encadeamentos aguardam a libera√ß√£o dos recursos necess√°rios, mas isso nunca acontecer√°. <br><br>  A sa√≠da do programa ser√° assim (os n√∫meros ap√≥s java.lang.Object @ ser√£o diferentes para cada inicializa√ß√£o): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  Ap√≥s a sa√≠da dessas mensagens, o programa parecer√° estar em execu√ß√£o (o processo de execu√ß√£o deste programa n√£o foi conclu√≠do), enquanto o programa n√£o realiza nenhum trabalho.  √â assim que o impasse parece na pr√°tica.  Para resolver o problema, precisamos criar manualmente um despejo de piso e analisar o estado dos encadeamentos. <br><br><h4>  Gera√ß√£o de despejo de segmento </h4><br>  Na pr√°tica, um programa Java pode falhar ao criar um despejo de encadeamento.  No entanto, em alguns casos (por exemplo, no caso de conflitos), o programa n√£o termina e o despejo de encadeamentos n√£o √© criado, apenas trava.  Para criar um despejo desses programas travados, primeiro, voc√™ precisa descobrir o identificador do processo do programa, ou seja,  ID do processo (PID).  Para fazer isso, √© poss√≠vel usar o utilit√°rio JVM Process Status (JPS), que, come√ßando com a vers√£o 7, faz parte do Java Development Kit (JDK).  Para encontrar o PID do processo do nosso programa travado, simplesmente executamos jps no terminal (Windows ou Linux): <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  A primeira coluna √© o identificador da m√°quina virtual local (ID da VM local, ou seja, lvmid) para o processo Java em execu√ß√£o.  No contexto da JVM local, lvmid aponta para o PID do processo Java. <br><br>  Deve-se notar que esse valor provavelmente difere do valor acima.  A segunda coluna √© o nome do aplicativo, que pode apontar para o nome da classe principal, arquivo jar ou igual a "Desconhecido".  Tudo depende de como o aplicativo foi iniciado. <br><br>  No nosso caso, o nome do aplicativo DeadlockProgram √© o nome das principais classes que foram iniciadas quando o programa foi iniciado.  No exemplo acima do PID do programa 11568, essas informa√ß√µes s√£o suficientes para gerar um despejo de encadeamento.  Para gerar o dump, usaremos o utilit√°rio <strong>jstack</strong> , que faz parte do JDK, come√ßando na vers√£o 7. Para obter o dump, <strong>passaremos o</strong> PID do nosso programa para o <strong>jstack</strong> e especificar o sinalizador -l (criando uma lista longa).  A sa√≠da do utilit√°rio ser√° redirecionada para um arquivo de texto, ou seja,  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  O arquivo thread_dump.txt resultante cont√©m o despejo de encadeamento do nosso programa travado e cont√©m informa√ß√µes importantes para diagnosticar as causas do conflito. <br><br>  Se o JDK for usado at√© a vers√£o 7, para gerar um dump, voc√™ poder√° usar o utilit√°rio Linux - <strong>kill</strong> com o sinalizador -3.  Chamar kill -3 enviar√° ao programa um sinal SIGQUIT. <br><br>  No nosso caso, a chamada ser√° assim: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  An√°lise simples de despejo de encadeamento </h4><br>  Abrindo o arquivo thread_dump.txt, veremos algo como o seguinte: <br><br><pre> 2018-06-19 16:44:44
 VM do servidor Java HotSpot (TM) de 64 bits de despejo de thread completo (10.0.1 + 10 modo misto)
 Informa√ß√µes de SMR da classe de threads:
 _java_thread_list = 0x00000250e5488a00, length = 13, elementos = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
 "Daemon Handler de refer√™ncia" n¬∫ 2 prio = 10 os_prio = 2id = 0x00000250e4979000 nid = 0x3c28 aguardando condi√ß√£o [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     em java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     em java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     em java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     em java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Daemon finalizador" n¬∫ 3 prio = 8 os_prio = 1 vez = 0x00000250e4982800 nid = 0x2a54 em Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (no monitor de objeto)
     em java.lang.Object.wait (java.base@10.0.1/Native Method)
     - aguardando &lt;0x0000000089509410&gt; (um bloqueio de java.lang.ref.ReferenceQueue $)
     em java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - aguardando para bloquear novamente em wait () &lt;0x0000000089509410&gt; (um java.lang.ref.ReferenceQueue $ Lock)
     em java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     em java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Signal Dispatcher" # 4 daemon prio = 9 os_prio = 2 vezes = 0x00000250e52f2800 nid = 0x2184 execut√°vel [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 Daemon "Attach Listener" n¬∫ 5 prio = 5 os_prio = 2 vezes = 0x00000250e4992800 nid = 0x1624 aguardando condi√ß√£o [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "C2 CompilerThread0" # 6 daemon prio = 9 os_prio = 2id = 0x00000250e4995800 nid = 0x4198 aguardando condi√ß√£o [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Nenhuma tarefa de compila√ß√£o
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "C2 CompilerThread1" # 7 daemon prio = 9 os_prio = 2id = 0x00000250e49a5800 nid = 0x3b98 aguardando condi√ß√£o [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Nenhuma tarefa de compila√ß√£o
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "C1 CompilerThread2" # 8 daemon prio = 9 os_prio = 2id = 0x00000250e49ae800 nid = 0x1a84 aguardando condi√ß√£o [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Nenhuma tarefa de compila√ß√£o
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Sweeper thread" n¬∫ 9 daemon prio = 9 os_prio = 2 vezes = 0x00000250e5324000 nid = 0x5f0 execut√°vel [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Daemon de servi√ßo" n¬∫ 10 prio = 9 os_prio = 0 por dia = 0x00000250e54cd800 nid = 0x169c execut√°vel [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Common-Cleaner" n¬∫ 11 daemon prio = 8 os_prio = 1 vez = 0x00000250e54cf000 nid = 0x1610 em Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (no monitor de objeto)
     em java.lang.Object.wait (java.base@10.0.1/Native Method)
     - aguardando &lt;0x000000008943e600&gt; (um bloqueio de java.lang.ref.ReferenceQueue $)
     em java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - aguardando para bloquear novamente em wait () &lt;0x000000008943e600&gt; (um java.lang.ref.ReferenceQueue $ Lock)
     em jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     em jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Thread-0" # 12 prio = 5 os_prio = 0 detalhe = 0x00000250e54d1800 nid = 0xdec aguardando entrada do monitor [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (no monitor de objeto)
     em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - aguardando para bloquear &lt;0x00000000894465b0&gt; (um java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (um java.lang.Object)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Thread-1" # 13 prio = 5 os_prio = 0 por dia = 0x00000250e54d2000 nid = 0x415c aguardando entrada do monitor [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (no monitor de objeto)
     em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - aguardando para bloquear &lt;0x00000000894465a0&gt; (um java.lang.Object)
     - bloqueado &lt;0x00000000894465b0&gt; (um java.lang.Object)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 mar√© = 0x00000250e54d0800 nid = 0x2b8c aguardando condi√ß√£o [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
 "Thread da VM" os_prio = 2id = 0x00000250e496d800 nid = 0x1920 execut√°vel  
 "T√≥pico do GC # 0" os_prio = 2id = 0x00000250c35b5800 nid = 0x310c execut√°vel  
 "T√≥pico do GC # 1" os_prio = 2id = 0x00000250c35b8000 nid = 0x12b4 execut√°vel  
 "T√≥pico do GC # 2" os_prio = 2id = 0x00000250c35ba800 nid = 0x43f8 execut√°vel  
 "T√≥pico do GC # 3" os_prio = 2id = 0x00000250c35c0800 nid = 0x20c0 execut√°vel  
 "Marcador principal G1" os_prio = 2 por dia = 0x00000250c3633000 nid = 0x4068 execut√°vel  
 "G1 Conc # 0" os_prio = 2id = 0x00000250c3636000 nid = 0x3e28 execut√°vel  
 "G1 Refine # 0" os_prio = 2 por dia = 0x00000250c367e000 nid = 0x3c0c execut√°vel  
 "G1 Refine # 1" os_prio = 2id = 0x00000250e47fb800 nid = 0x3890 execut√°vel  
 "G1 Refine # 2" os_prio = 2id = 0x00000250e47fc000 nid = 0x32a8 execut√°vel  
 "G1 Refine # 3" os_prio = 2id = 0x00000250e47fd800 nid = 0x3d00 execut√°vel  
 "G1 Young RemSet Sampling" os_prio = 2 por dia = 0x00000250e4800800 nid = 0xef4 execut√°vel  
 "Thread de tarefa peri√≥dica da VM" os_prio = 2id = 0x00000250e54d6800 nid = 0x3468 aguardando condi√ß√£o  
 Refer√™ncias globais da JNI: 2
 Encontrou um impasse no n√≠vel do Java:
 ===============================
 "Thread-0":
   aguardando para bloquear o monitor 0x00000250e4982480 (objeto 0x00000000894465b0, um java.lang.Object),
   que √© mantido pelo "Thread-1"
 "Thread-1":
   aguardando para bloquear o monitor 0x00000250e4982380 (objeto 0x00000000894465a0, um java.lang.Object),
   que √© mantido por "Thread-0"
 Informa√ß√µes da pilha Java para os encadeamentos listados acima:
 ===================================================== =
 "Thread-0":
     em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - aguardando para bloquear &lt;0x00000000894465b0&gt; (um java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (um java.lang.Object)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - aguardando para bloquear &lt;0x00000000894465a0&gt; (um java.lang.Object)
     - bloqueado &lt;0x00000000894465b0&gt; (um java.lang.Object)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Encontrado 1 impasse.
</pre><br><h3>  Informa√ß√µes introdut√≥rias </h3><br>  Embora, √† primeira vista, esse arquivo possa parecer muito complicado e confuso, na realidade √© bastante simples se voc√™ o desmontar em partes, passo a passo. <br><br>  A primeira linha indica a hora em que o dump foi formado, a segunda - informa√ß√µes de diagn√≥stico sobre a JVM, na qual o dump foi recebido: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  N√£o h√° informa√ß√µes de fluxo nesta se√ß√£o.  Aqui, o contexto geral do sistema no qual o dump foi coletado √© definido. <br><br><h4>  Informa√ß√µes gerais sobre fluxo </h4><br>  A se√ß√£o a seguir fornece informa√ß√µes sobre os threads que estavam em execu√ß√£o no sistema no momento da cole√ß√£o de despejo: <br><br><pre> Informa√ß√µes de SMR da classe de threads:
 _java_thread_list = 0x00000250e5488a00, length = 13, elementos = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
</pre><br>  A se√ß√£o a seguir lista: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informa√ß√µes sobre recupera√ß√£o de mem√≥ria segura (SMR)</a> <br><br>  Ele cont√©m informa√ß√µes sobre encadeamentos fora da JVM, ou seja,  esses n√£o s√£o threads de m√°quina virtual ou de coleta de lixo.  Se voc√™ observar os endere√ßos desses encadeamentos, notar√° que eles correspondem ao valor de <i>tid</i> - o endere√ßo "natural, de ferro" (nativo) no sistema operacional, e n√£o o ID do encadeamento. <br><br>  Elipses s√£o usadas para ocultar informa√ß√µes redundantes: <br><br><pre> "Manipulador de refer√™ncia" # 2 ... tid = 0x00000250e4979000 ...
 "Finalizador" # 3 ... tid = 0x00000250e4982800 ...
 "Distribuidor de sinal" # 4 ... tid = 0x00000250e52f2800 ...
 "Anexar ouvinte" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Fio da vassoura" # 9 ... tid = 0x00000250e5324000 ...
 "T√≥pico de servi√ßo" # 10 ... tid = 0x00000250e54cd800 ...
 "Limpador comum" # 11 ... tid = 0x00000250e54cf000 ...
 "T√≥pico-0" # 12 ... tid = 0x00000250e54d1800 ...
 "T√≥pico-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Streams </h3><br>  Logo ap√≥s o bloco SMR, h√° uma lista de threads.  O primeiro segmento da nossa lista √© o manipulador de refer√™ncia: <br><br><pre> "Daemon Handler de refer√™ncia" n¬∫ 2 prio = 10 os_prio = 2id = 0x00000250e4979000 nid = 0x3c28 aguardando condi√ß√£o [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     em java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     em java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     em java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     em java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
</pre><br><h4>  Breve descri√ß√£o do fluxo </h4><br>  A primeira linha de cada thread fornece uma descri√ß√£o geral.  A descri√ß√£o cont√©m os seguintes itens: <br><table><tbody><tr><th width="70">  Se√ß√£o </th><th width="100">  Exemplo </th><th>  Descri√ß√£o do produto </th></tr><tr><td>  Nome </td><td>  "Manipulador de refer√™ncia" </td><td>  Nome do fluxo leg√≠vel por humanos.  O nome pode ser especificado chamando o m√©todo <i>setName</i> do objeto <i>Thread</i> .  E receba uma liga√ß√£o para <i>getName</i> </td></tr><tr><td>  ID </td><td>  # 2 </td><td>  Um ID exclusivo atribu√≠do a cada objeto da classe <i>Thread</i> .  O ID √© gerado para threads no sistema.  O valor inicial √© 1. Cada thread rec√©m-criado recebe seu pr√≥prio ID, aumentado anteriormente em 1. Essa propriedade de thread somente leitura pode ser obtida usando a fun√ß√£o <i>getId</i> de <i>um</i> objeto da classe <i>Thread</i> . </td></tr><tr><td>  Status do daemon </td><td>  daemon </td><td>  A bandeira √© um sinal de que o fio √© um dem√¥nio.  Se for um dem√¥nio, a bandeira ser√° definida.  Por exemplo, o encadeamento <i>-0</i> n√£o <i>√©</i> um daemon. </td></tr><tr><td>  Prioridade </td><td>  prio = 10 </td><td>  A prioridade num√©rica do fluxo Java.  Observe que essa prioridade n√£o corresponde necessariamente √† prioridade do encadeamento associado no sistema operacional.  Para definir a prioridade, voc√™ pode <br>  use o m√©todo <i>setPriority</i> de <i>um</i> objeto da classe <i>Thread</i> e para obter <br>  m√©todo <i>getPriority</i> . </td></tr><tr><td>  Prioridade do encadeamento do SO </td><td>  os_prio = 2 </td><td>  Encadeamento priorit√°rio no sistema operacional.  Essa prioridade pode ser diferente da designada ao encadeamento Java vinculado. </td></tr><tr><td>  Morada </td><td>  tid = 0x00000250e4979000 </td><td>  O endere√ßo do fluxo Java.  Este endere√ßo √© um ponteiro para o objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">nativo Java Native Interface (JNI)</a> da classe <i>Thread</i> (um objeto C ++ <i>Thread</i> conectado ao thread Java atrav√©s da JNI).  Este valor √© obtido lan√ßando um ponteiro para este <br>  (o objeto C ++ que est√° associado a esse encadeamento Java) em n√∫mero inteiro.  Veja <br>  <a href="">linha 879 no ponto de acesso / compartilhamento / tempo de execu√ß√£o / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (isto));
</pre><br>  Embora a chave desse objeto ( <i>tid</i> ) possa parecer um ID de fluxo, <br>  de fato, este √© o endere√ßo do objeto conectado ao <i>Thread JNI C ++</i> e este n√£o √© o valor que <br>  retorna o m√©todo <i>getId</i> do <i>encadeamento</i> Java. </td></tr><tr><td>  ID do encadeamento do SO </td><td>  nid = 0x3c28 </td><td>  O identificador exclusivo do encadeamento do sistema operacional ao qual o encadeamento Java est√° vinculado. <br>  Este valor √© gerado com o seguinte c√≥digo: <br>  <a href="">linha 42 no ponto de acesso / compartilhamento / tempo de execu√ß√£o / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Status </td><td>  esperando sob condi√ß√£o </td><td>  Status leg√≠vel humano do encadeamento atual. <br>  Essa linha exibe informa√ß√µes adicionais sobre o status simples do fluxo (veja abaixo), que pode ser <br>  usado para entender o que o encadeamento iria fazer (ou seja, se o encadeamento estava tentando obter um bloqueio <br>  ou aguardando a condi√ß√£o de desbloqueio). </td></tr><tr><td>  √öltimo ponteiro de pilha Java conhecido </td><td>  [0x000000b82a9ff000] </td><td>  O √∫ltimo ponteiro de pilha conhecido (SP) associado a esse fluxo. <br>  Este valor √© obtido usando o c√≥digo C ++ nativo combinado com o c√≥digo Java usando JNI.  O valor √© retornado pela fun√ß√£o <i>last_Java_sp ()</i> , <br>  <a href="">linha 2886 no ponto de acesso / compartilhamento / tempo de execu√ß√£o / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  Para despejos de encadeamento simples, essas informa√ß√µes s√£o quase in√∫teis.  Entretanto, em casos complexos, SP pode <br>  ser usado para rastrear bloqueios. </td></tr></tbody></table><br><h4>  Status do fluxo </h4><br>  A segunda linha √© o estado atual do fluxo.  Os poss√≠veis estados do fluxo est√£o listados na enumera√ß√£o: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Thread.State</a> : <br><br>  Novo <br>  RUNNABLE <br>  BLOQUEADO <br>  ESPERANDO <br>  TIMED_WAITING <br>  TERMINADO <br><br>  Veja a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">documenta√ß√£o para</a> mais detalhes. <br><br><h4>  Rastreio de Pilha de Encadeamentos </h4><br>  A pr√≥xima se√ß√£o cont√©m o rastreamento de pilha do fluxo no momento em que o despejo foi realizado.  Esse rastreamento de pilha √© muito semelhante a um rastreamento de pilha, lan√ßado por uma exce√ß√£o n√£o capturada.  E cont√©m os nomes de classes e seq√º√™ncias de caracteres que foram executadas no momento em que o despejo foi formado.  No caso do fluxo do manipulador de refer√™ncia, n√£o vemos nada de interessante. <br><br>  No entanto, h√° algo interessante no rastreamento de encadeamento do Thread-02 que √© diferente do rastreamento padr√£o: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 detalhe = 0x00000250e54d1800 nid = 0xdec aguardando entrada do monitor [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (no monitor de objeto)
     em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - aguardando para bloquear &lt;0x00000000894465b0&gt; (um java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (um java.lang.Object)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sincronizadores propriet√°rios bloqueados:
     - nenhum
</pre><br>  No rastreamento, vemos que as informa√ß√µes sobre o bloqueio foram adicionadas.  Esse encadeamento espera um bloqueio no objeto com o endere√ßo 0x00000000894465b0 (tipo de objeto java.lang.Object).  Al√©m disso, o pr√≥prio encadeamento mant√©m o bloqueio com o endere√ßo 0x00000000894465a0 (tamb√©m um java.lang.Object).  Essas informa√ß√µes nos ser√£o √∫teis posteriormente para o diagn√≥stico de conflito. <br><br><h4>  Primitivas de sincroniza√ß√£o capturadas (Ownable Synchronizer) </h4><br>  A √∫ltima se√ß√£o lista as primitivas de sincroniza√ß√£o capturadas pelo fluxo.  Esses s√£o objetos que podem ser usados ‚Äã‚Äãpara sincronizar threads, por exemplo, bloqueios. <br><br>  De acordo com a documenta√ß√£o oficial do Java, o <strong>Ownable Synchronizer</strong> √© o descendente do <i>AbstractOwnableSynchronizer</i> (ou sua subclasse), que pode ser capturado exclusivamente pelo fluxo para fins de sincroniza√ß√£o. <br><br>  <i>ReentrantLock</i> e <i>bloqueio de grava√ß√£o</i> , mas n√£o o <i>bloqueio</i> de <i>leitura</i> da classe <i>ReentrantReadWriteLock,</i> s√£o dois bons exemplos desses "sincronizadores propriet√°rios" oferecidos pela plataforma. <br><br>  Para mais informa√ß√µes sobre este assunto, voc√™ pode consultar este <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">post</a> . <br><br><h4>  Encadeamentos JVM </h4><br>  A pr√≥xima se√ß√£o do dump cont√©m informa√ß√µes sobre os encadeamentos t√©cnicos da JVM que n√£o fazem parte do aplicativo e est√£o associados aos encadeamentos do sistema operacional.  Porque  esses fluxos funcionam fora do aplicativo, eles n√£o t√™m identificadores de fluxo.  Na maioria das vezes, esses s√£o threads do coletor de lixo e outros threads t√©cnicos da JVM: <br><br><pre> "Thread da VM" os_prio = 2id = 0x00000250e496d800 nid = 0x1920 execut√°vel  
 "T√≥pico do GC # 0" os_prio = 2id = 0x00000250c35b5800 nid = 0x310c execut√°vel  
 "T√≥pico do GC # 1" os_prio = 2id = 0x00000250c35b8000 nid = 0x12b4 execut√°vel  
 "T√≥pico do GC # 2" os_prio = 2id = 0x00000250c35ba800 nid = 0x43f8 execut√°vel  
 "T√≥pico do GC # 3" os_prio = 2id = 0x00000250c35c0800 nid = 0x20c0 execut√°vel  
 "Marcador principal G1" os_prio = 2 por dia = 0x00000250c3633000 nid = 0x4068 execut√°vel  
 "G1 Conc # 0" os_prio = 2id = 0x00000250c3636000 nid = 0x3e28 execut√°vel  
 "G1 Refine # 0" os_prio = 2 por dia = 0x00000250c367e000 nid = 0x3c0c execut√°vel  
 "G1 Refine # 1" os_prio = 2id = 0x00000250e47fb800 nid = 0x3890 execut√°vel  
 "G1 Refine # 2" os_prio = 2id = 0x00000250e47fc000 nid = 0x32a8 execut√°vel  
 "G1 Refine # 3" os_prio = 2id = 0x00000250e47fd800 nid = 0x3d00 execut√°vel  
 "G1 Young RemSet Sampling" os_prio = 2 por dia = 0x00000250e4800800 nid = 0xef4 execut√°vel  
 "Thread de tarefa peri√≥dica da VM" os_prio = 2id = 0x00000250e54d6800 nid = 0x3468 aguardando condi√ß√£o
</pre><br><h4>  JNI Global Links </h4><br>  Esta se√ß√£o indica o n√∫mero de refer√™ncias globais usadas pela JVM atrav√©s da JNI.  Esses links n√£o s√£o atendidos pelo coletor de lixo e podem causar vazamento de mem√≥ria em determinadas circunst√¢ncias. <br><br><pre> Refer√™ncias globais da JNI: 2
</pre><br>  Na maioria dos casos simples, essas informa√ß√µes n√£o s√£o usadas.  No entanto, a import√¢ncia das refer√™ncias globais deve ser entendida.  Veja este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">post para</a> mais detalhes. <br><br><h4>  T√≥picos com deadlock </h4><br>  A √∫ltima se√ß√£o cont√©m informa√ß√µes sobre conflitos encontrados. <br>  Se estes n√£o forem encontrados, a se√ß√£o estar√° vazia.  Porque  Desenvolvemos um aplicativo especificamente com bloqueios. No nosso caso, esta se√ß√£o √©.  Um bloqueio foi detectado durante o dumping e √© apresentado com a seguinte mensagem: <br><br><pre> Encontrou um impasse no n√≠vel do Java:
 ===============================
 "Thread-0":
   aguardando para bloquear o monitor 0x00000250e4982480 (objeto 0x00000000894465b0, um java.lang.Object),
   que √© mantido pelo "Thread-1"
 "Thread-1":
   aguardando para bloquear o monitor 0x00000250e4982380 (objeto 0x00000000894465a0, um java.lang.Object),
   que √© mantido por "Thread-0"
 Informa√ß√µes da pilha Java para os encadeamentos listados acima:
 ===================================================== =
 "Thread-0":
     em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - aguardando para bloquear &lt;0x00000000894465b0&gt; (um java.lang.Object)
     - bloqueado &lt;0x00000000894465a0&gt; (um java.lang.Object)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - aguardando para bloquear &lt;0x00000000894465a0&gt; (um java.lang.Object)
     - bloqueado &lt;0x00000000894465b0&gt; (um java.lang.Object)
     em java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Encontrado 1 impasse.
</pre><br>  A primeira subse√ß√£o descreve o cen√°rio de conflito: <br><br>  O thread-0 espera a capacidade de capturar um monitor (isso est√° acessando o bloco <i>sincronizado (secondResource)</i> em nosso aplicativo), enquanto este thread est√° segurando um monitor que est√° tentando capturar o thread-1 (est√° acessando o mesmo fragmento de c√≥digo: <i>)</i> em nossa aplica√ß√£o). <br><br>  Esse bloqueio circular tamb√©m √© chamado de <strong>deadlock</strong> .  Na imagem abaixo <br>  esta situa√ß√£o √© apresentada em forma gr√°fica: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  Na segunda subse√ß√£o, o rastreamento de pilha √© fornecido para os dois threads bloqueados. <br><br>  Esse rastreamento de pilha permite rastrear a opera√ß√£o de cada encadeamento at√© que ocorra um bloqueio. <br>  No nosso caso, se olharmos para a linha: <br><br>  <i>em DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)</i> , veremos o problema como parte do c√≥digo: <br><br><pre> printLockedResource (secondResource);
</pre><br>  Essa linha √© a primeira linha do bloco sincronizado, que √© o motivo do bloqueio, e informa que a sincroniza√ß√£o no secondResource √© o motivo do bloqueio m√∫tuo.  Para remediar a situa√ß√£o, devemos garantir que os dois threads tenham a mesma ordem de sincroniza√ß√£o nos recursos resourceA e resourceB.  Se fizermos isso, chegaremos ao seguinte aplicativo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Este aplicativo terminar√° sem intertravamento e, como resultado, obteremos a seguinte sa√≠da (observe que os endere√ßos da classe Object foram alterados): <br><br><pre> Thread-0: recurso bloqueado -&gt; java.lang.Object@1ad895d1
 Thread-0: recurso bloqueado -&gt; java.lang.Object@6e41d7dd
 T√≥pico-1: recurso bloqueado -&gt; java.lang.Object@1ad895d1
 T√≥pico-1: recurso bloqueado -&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - ‚Äî Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Conclus√£o </h4><br> Thread dump- ‚Äî      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           ‚Äî . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump ‚Äî   ¬´ ¬ª   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427513/">https://habr.com/ru/post/pt427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427499/index.html">Sobre o que eles escrevem no suporte t√©cnico da serpentina de v√≠deo?</a></li>
<li><a href="../pt427501/index.html">Seymour Papert: Divers√£o Dif√≠cil</a></li>
<li><a href="../pt427505/index.html">Presun√ß√£o de esp√≠rito</a></li>
<li><a href="../pt427507/index.html">Seymour Papert: a deliciosa descoberta do "nada"</a></li>
<li><a href="../pt427509/index.html">Servidores da Web: Southbridge Experience and Practice</a></li>
<li><a href="../pt427517/index.html">Vis√£o geral dos relat√≥rios mais interessantes do Joker 2018: vers√£o EastBanc Technologies</a></li>
<li><a href="../pt427519/index.html">Meetup @Kubernetes no Mail.Ru Group: 29 de outubro e sempre</a></li>
<li><a href="../pt427521/index.html">Pr√™mio Breakthrough 2019. Anunciados os vencedores do Pr√™mio de Ci√™ncia Milner, Brin e Zuckerberg.</a></li>
<li><a href="../pt427523/index.html">Sucesso de cobertura</a></li>
<li><a href="../pt427525/index.html">Intel Core 9a gera√ß√£o em n√∫meros e benchmarks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>