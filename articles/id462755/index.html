<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔵 🙆🏻 🛀🏻 Aliran Asinkron dalam C # 8 ♋️ 👶 🥠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fungsi Async / Await diperkenalkan di C # 5 untuk meningkatkan respons antarmuka pengguna dan akses web ke sumber daya. Dengan kata lain, metode asink...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aliran Asinkron dalam C # 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/462755/"><p>  Fungsi Async / Await diperkenalkan di C # 5 untuk meningkatkan respons antarmuka pengguna dan akses web ke sumber daya.  Dengan kata lain, metode asinkron membantu pengembang melakukan operasi asinkron yang tidak memblokir utas dan mengembalikan hasil skalar tunggal.  Setelah berbagai upaya oleh Microsoft untuk menyederhanakan operasi asinkron, templat async / menunggu telah mendapatkan reputasi yang baik di antara para pengembang berkat pendekatan yang sederhana. </p><br><p> Metode asinkron yang ada sangat terbatas karena mereka hanya mengembalikan satu nilai.  Mari kita lihat beberapa <code>async Task&lt;int&gt; DoAnythingAsync()</code> metode yang umum untuk sintaksis seperti itu.  Hasil karyanya adalah makna seseorang.  Karena batasan ini, Anda tidak dapat menggunakan fungsi ini dengan kata kunci <code>yield</code> dan antarmuka <code>IEnumerable&lt;int&gt;</code> sinkron (untuk mengembalikan hasil enumerasi asinkron). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/fp/yf/bo/fpyfbog_pbidr2p7wwilr6ghspa.jpeg"></a> </p><a name="habracut"></a><br><p>  Jika Anda menggabungkan fungsi <code>async/await</code> dan <code>yield</code> , maka Anda dapat menggunakan model pemrograman yang kuat yang dikenal sebagai <strong>tarikan data asinkron</strong> , atau <strong>enumerasi enumerasi berbasis tarikan,</strong> atau <strong>urutan</strong> asinkron <strong>asinkron</strong> , seperti yang disebut dalam F #. </p><br><p>  Kemampuan baru untuk menggunakan utas sinkron di C # 8 menghilangkan batasan yang terkait dengan mengembalikan hasil tunggal dan memungkinkan metode asinkron untuk mengembalikan beberapa nilai.  Perubahan ini akan memberikan Templat asinkron lebih banyak fleksibilitas, dan pengguna akan dapat mengambil data dari suatu tempat (misalnya, dari database) menggunakan urutan asinkron tertunda atau untuk menerima data dari urutan asinkron di bagian yang tersedia. </p><br><p>  Contoh: </p><br><pre> <code class="plaintext hljs">foreach await (var streamChunck in asyncStreams) { Console.WriteLine($“Received data count = {streamChunck.Count}”); }</code> </pre> <br><p>  Pendekatan lain untuk memecahkan masalah yang berkaitan dengan pemrograman asinkron adalah dengan menggunakan ekstensi reaktif (Rx).  <code>Rx</code> semakin penting di antara pengembang dan metode ini digunakan dalam banyak bahasa pemrograman, misalnya Java (RxJava) dan JavaScript (RxJS). </p><br><p>  Rx didasarkan pada model push push (prinsip Tell Don't Ask), juga dikenal sebagai pemrograman reaktif.  Yaitu  tidak seperti IEnumerable, ketika konsumen meminta elemen berikutnya, dalam model Rx, penyedia data memberi sinyal kepada konsumen bahwa elemen baru muncul dalam urutan.  Data didorong ke antrian dalam mode asinkron dan konsumen menggunakannya pada saat penerimaan. </p><br><p>  Pada artikel ini, saya akan membandingkan model berdasarkan mendorong data (seperti Rx) dengan model berdasarkan menarik data (seperti IEnumerable), dan juga menunjukkan skenario mana yang paling cocok untuk model mana.  Seluruh konsep dan manfaat diperiksa dengan berbagai contoh dan kode demo.  Pada akhirnya, saya akan menunjukkan aplikasi dan menunjukkannya dengan contoh kode. </p><br><h2 id="sravnenie-modeli-na-osnove-protalkivaniya-dannyh-s-modelyu-na-osnove-vytyagivaniya-dannyh-pull-">  Perbandingan model berdasarkan mendorong data dengan model berdasarkan menarik data (pull-) </h2><br><p><img src="https://habrastorage.org/webt/h7/hs/o8/h7hso8a8enkl-ujguuyxmzi_ova.jpeg"><br>  <em>Fig.</em>  <em>-1- Perbandingan model berdasarkan penarikan data dengan model berdasarkan mendorong data</em> </p><br><p>  Contoh-contoh ini didasarkan pada hubungan antara penyedia data dan konsumen, seperti yang ditunjukkan pada Gambar.  -1-.  Model berbasis tarikan mudah dimengerti.  Di dalamnya, konsumen meminta dan menerima data dari pemasok.  Pendekatan alternatif adalah model push push.  Di sini, penyedia mempublikasikan data dalam antrian dan konsumen harus berlangganan untuk menerimanya. </p><br><p>  Model tarikan data cocok untuk kasus-kasus di mana penyedia menghasilkan data lebih cepat daripada konsumen menggunakannya.  Dengan demikian, konsumen hanya menerima data yang diperlukan, yang menghindari masalah luapan.  Jika konsumen menggunakan data lebih cepat dari yang dihasilkan oleh pemasok, model yang sesuai dengan mendorong data itu cocok.  Dalam hal ini, pemasok dapat mengirim lebih banyak data ke konsumen sehingga tidak ada penundaan yang tidak perlu. </p><br><p>  Rx dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akka Streams</a> (model pemrograman berbasis aliran) menggunakan metode tekanan balik untuk mengontrol aliran.  Untuk memecahkan masalah pemasok dan penerima yang dijelaskan di atas, metode ini menggunakan mendorong dan menarik data. </p><br><p>  Pada contoh di bawah ini, konsumen yang lambat menarik data dari penyedia yang lebih cepat.  Setelah konsumen memproses elemen saat ini, ia akan meminta pemasok untuk selanjutnya dan seterusnya sampai akhir urutan. </p><br><h2 id="motivaciya-dlya-ispolzovaniya-i-osnovnaya-informaciya">  Motivasi untuk menggunakan dan informasi dasar </h2><br><p>  Untuk memahami seluruh kebutuhan utas asinkron, pertimbangkan kode berikut. </p><br><pre> <code class="plaintext hljs">//       (count) static int SumFromOneToCount(int count) { ConsoleExt.WriteLine("SumFromOneToCount called!"); var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; } return sum; } //  : const int count = 5; ConsoleExt.WriteLine($"Starting the application with count: {count}!"); ConsoleExt.WriteLine("Classic sum starting."); ConsoleExt.WriteLine($"Classic sum result: {SumFromOneToCount(count)}"); ConsoleExt.WriteLine("Classic sum completed."); ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Kesimpulan: <br><img src="https://habrastorage.org/webt/m4/sf/kc/m4sfkcjbubb58prlmy2x_a8rm2u.jpeg"></p><br><p>  Kita dapat membuat metode ditangguhkan menggunakan pernyataan hasil, seperti yang ditunjukkan di bawah ini. </p><br><pre> <code class="plaintext hljs">static IEnumerable&lt;int&gt; SumFromOneToCountYield(int count) { ConsoleExt.WriteLine("SumFromOneToCountYield called!"); var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; yield return sum; } }</code> </pre> <br><p>  Panggilan metode </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("Sum with yield starting."); foreach (var i in SumFromOneToCountYield(count)) { ConsoleExt.WriteLine($"Yield sum: {i}"); } ConsoleExt.WriteLine("Sum with yield completed."); ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Kesimpulan: <br><img src="https://habrastorage.org/webt/oc/if/3l/ocif3lcjnm3pjaob8sje3ladu8u.jpeg"></p><br><p>  Seperti yang ditunjukkan pada jendela output di atas, hasilnya dikembalikan dalam bagian-bagian, bukan nilai tunggal.  Ringkasan hasil yang ditunjukkan di atas dikenal sebagai daftar ditangguhkan.  Namun, masalahnya masih belum terpecahkan: metode penjumlahan memblokir kode.  Jika Anda melihat utas, Anda dapat melihat bahwa semuanya berjalan di utas utama. </p><br><p>  Mari kita terapkan kata ajaib async ke metode SumFromOneToCount pertama (tanpa hasil). </p><br><pre> <code class="plaintext hljs">static async Task&lt;int&gt; SumFromOneToCountAsync(int count) { ConsoleExt.WriteLine("SumFromOneToCountAsync called!"); var result = await Task.Run(() =&gt; { var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; } return sum; }); return result; }</code> </pre> <br><p>  Panggilan metode </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("async example starting."); //      . ,  . ,        . var result = await SumFromOneToCountAsync(count); ConsoleExt.WriteLine("async Result: " + result); ConsoleExt.WriteLine("async completed."); ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Kesimpulan: <br><img src="https://habrastorage.org/webt/hp/7s/_a/hp7s_aqgqzi3aeiemsauitygcbo.jpeg"></p><br><p>  Bagus  Sekarang perhitungan dilakukan di utas yang berbeda, tetapi masalah dengan hasil masih ada.  Sistem mengembalikan hasilnya dengan nilai tunggal. <br>  Bayangkan bahwa kita dapat menggabungkan enumerasi yang ditangguhkan (pernyataan hasil) dan metode asinkron dalam gaya pemrograman imperatif.  Kombinasi ini disebut stream asinkron dan ini adalah fitur baru dalam C # 8. Ini bagus untuk menyelesaikan masalah yang terkait dengan model pemrograman berdasarkan ekstraksi data, misalnya, mengunduh data dari situs atau membaca catatan dalam file atau database dengan cara modern. </p><br><p>  Mari kita coba melakukan ini dalam versi C # saat ini.  Saya akan menambahkan kata kunci async ke metode SumFromOneToCountYield sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/se/3a/lw/se3alwvhqedkwzkmxti4ewc8sgc.jpeg"><br>  <em>Fig.</em>  <em>-2- Kesalahan saat menggunakan kata kunci hasil dan async secara bersamaan.</em> </p><br><p>  Ketika kami mencoba menambahkan async ke SumFromOneToCountYield, kesalahan terjadi seperti yang ditunjukkan di atas. <br>  Mari kita coba secara berbeda.  Kami dapat menghapus kata kunci hasil dan menerapkan IEnumerable dalam tugas, seperti yang ditunjukkan di bawah ini: </p><br><pre> <code class="plaintext hljs">static async Task&lt;IEnumerable&lt;int&gt;&gt; SumFromOneToCountTaskIEnumerable(int count) { ConsoleExt.WriteLine("SumFromOneToCountAsyncIEnumerable called!"); var collection = new Collection&lt;int&gt;(); var result = await Task.Run(() =&gt; { var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; collection.Add(sum); } return collection; }); return result; }</code> </pre> <br><p>  Panggilan metode </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("SumFromOneToCountAsyncIEnumerable started!"); var scs = await SumFromOneToCountTaskIEnumerable(count); ConsoleExt.WriteLine("SumFromOneToCountAsyncIEnumerable done!"); foreach (var sc in scs) { //   ,  .     . ConsoleExt.WriteLine($"AsyncIEnumerable Result: {sc}"); } ConsoleExt.WriteLine("################################################"); ConsoleExt.WriteLine(Environment.NewLine);</code> </pre> <br><p>  Kesimpulan: <br><img src="https://habrastorage.org/webt/_f/ze/zl/_fzezlq44tw70sojrtlq-3wyvvw.jpeg"></p><br><p>  Seperti yang Anda lihat dari contoh, semuanya dihitung dalam mode asinkron, tetapi masalahnya masih ada.  Hasil (semua hasil dikumpulkan dalam koleksi) dikembalikan sebagai satu blok.  Dan ini bukan yang kita butuhkan.  Jika Anda ingat, tujuan kami adalah untuk menggabungkan mode perhitungan asinkron dengan kemungkinan penundaan. </p><br><p>  Untuk melakukan ini, Anda perlu menggunakan perpustakaan eksternal, misalnya, Ix (bagian dari Rx), atau utas asinkron, disajikan dalam C #. </p><br><p>  Mari kita kembali ke kode kita.  Untuk menunjukkan perilaku asinkron, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan eksternal</a> . </p><br><pre> <code class="plaintext hljs">static async Task ConsumeAsyncSumSeqeunc(IAsyncEnumerable&lt;int&gt; sequence) { ConsoleExt.WriteLineAsync("ConsumeAsyncSumSeqeunc Called"); await sequence.ForEachAsync(value =&gt; { ConsoleExt.WriteLineAsync($"Consuming the value: {value}"); //    Task.Delay(TimeSpan.FromSeconds(1)).Wait(); }); } static IEnumerable&lt;int&gt; ProduceAsyncSumSeqeunc(int count) { ConsoleExt.WriteLineAsync("ProduceAsyncSumSeqeunc Called"); var sum = 0; for (var i = 0; i &lt;= count; i++) { sum = sum + i; //    Task.Delay(TimeSpan.FromSeconds(0,5)).Wait(); yield return sum; } }</code> </pre> <br><p>  Panggilan metode </p><br><pre> <code class="plaintext hljs">const int count = 5; ConsoleExt.WriteLine("Starting Async Streams Demo!"); //   .       . IAsyncEnumerable&lt;int&gt; pullBasedAsyncSequence = ProduceAsyncSumSeqeunc(count).ToAsyncEnumerable(); ConsoleExt.WriteLineAsync("X#X#X#X#X#X#X#X#X#X# Doing some other work X#X#X#X#X#X#X#X#X#X#"); //    ;      . var consumingTask = Task.Run(() =&gt; ConsumeAsyncSumSeqeunc(pullBasedAsyncSequence)); //   . ,    . consumingTask.Wait(); ConsoleExt.WriteLineAsync("Async Streams Demo Done!");</code> </pre> <br><p>  Kesimpulan: <br><img src="https://habrastorage.org/webt/-7/62/sa/-762saqp5wmuttffq6aykba57r8.jpeg"></p><br><p>  Akhirnya, kita melihat perilaku yang diinginkan.  Anda dapat menjalankan loop enumerasi dalam mode asinkron. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihat kode sumber di sini</a> . </p><br><h2 id="vytyagivanie-dannyh-v-asinhronnom-rezhime-na-primere-klient-servernoy-arhitektury">  Contohnya, data yang tidak sinkron menggunakan arsitektur client-server </h2><br><p>  Mari kita lihat konsep ini dengan contoh yang lebih realistis.  Semua manfaat fitur ini paling baik dilihat dalam konteks arsitektur client-server. </p><br><h3 id="sinhronnyy-vyzov-v-sluchae-klient-servernoy-arhitektury">  Panggilan sinkron jika arsitektur klien-server </h3><br><p>  Saat mengirim permintaan ke server, klien dipaksa untuk menunggu (mis., Diblokir) hingga respons datang, seperti yang ditunjukkan pada Gambar.  -3-. </p><br><p><img src="https://habrastorage.org/webt/dd/kd/ys/ddkdysirir5ubotfcyidzmywice.jpeg"><br>  <em>Fig.</em>  <em>-3- Menarik data sinkron, di mana klien menunggu sampai pemrosesan permintaan selesai</em> </p><br><h3 id="asinhronnoe-vytyagivanie-dannyh">  Menarik data yang tidak sinkron </h3><br><p>  Dalam hal ini, klien meminta data dan beralih ke tugas lain.  Setelah data diterima, klien akan terus melakukan pekerjaan. </p><br><p><img src="https://habrastorage.org/webt/nj/gl/k1/njglk1v-exfbnbsm157zihblhbm.jpeg"><br>  <em>Fig.</em>  <em>-4- Menarik data yang tidak sinkron di mana klien dapat melakukan tugas-tugas lain saat data sedang diminta</em> </p><br><h2 id="vytyagivanie-dannyh-v-vide-asinhronnoy-posledovatelnosti">  Menarik data secara tidak sinkron </h2><br><p>  Dalam hal ini, klien meminta bagian dari data dan terus melakukan tugas-tugas lain.  Kemudian, setelah menerima data, klien memprosesnya dan meminta bagian selanjutnya, dan seterusnya, sampai semua data diterima.  Dari skenario inilah ide tentang thread asinkron muncul.  Dalam gbr.  -5- menunjukkan bagaimana klien dapat memproses data yang diterima atau melakukan tugas lain. </p><br><p><img src="https://habrastorage.org/webt/tk/f9/5q/tkf95qdq3w_5bg4hiqmkpx4k2y0.jpeg"><br>  <em>Fig.</em>  <em>-5- Menarik data sebagai urutan asinkron (stream asinkron).</em>  <em>Klien tidak diblokir.</em> </p><br><h2 id="asinhronnye-potoki">  Utas asinkron </h2><br><p>  Seperti <code>IEnumerable&lt;T&gt;</code> dan <code>IEnumerator&lt;T&gt;</code> ada dua antarmuka baru, <code>IAsyncEnumerable&lt;T&gt;</code> dan <code>IAsyncEnumerator&lt;T&gt;</code> , yang didefinisikan seperti yang ditunjukkan di bawah ini: </p><br><pre> <code class="plaintext hljs">public interface IAsyncEnumerable&lt;out T&gt; { IAsyncEnumerator&lt;T&gt; GetAsyncEnumerator(); } public interface IAsyncEnumerator&lt;out T&gt; : IAsyncDisposable { Task&lt;bool&gt; MoveNextAsync(); T Current { get; } } //      public interface IAsyncDisposable { Task DiskposeAsync(); }</code> </pre> <br><p>  Di InfoQ, Jonathan Allen memperbaiki topik ini.  Di sini saya tidak akan masuk ke detail, jadi saya sarankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca artikelnya</a> . </p><br><p>  Fokusnya adalah pada nilai pengembalian <code>Task&lt;bool&gt; MoveNextAsync()</code> (diubah dari bool menjadi <code>Task&lt;bool&gt;</code> , <code>bool IEnumerator.MoveNext()</code> ).  Berkat dia, semua perhitungan, serta iterasi mereka, akan terjadi secara serempak.  Konsumen memutuskan kapan untuk mendapatkan nilai berikutnya.  Meskipun model asinkron, masih menggunakan penarikan data.  Untuk pembersihan sumber daya yang tidak sinkron, Anda dapat menggunakan antarmuka <code>IAsyncDisposable</code> .  <a href="">Informasi lebih lanjut tentang utas sinkron dapat ditemukan di sini</a> . </p><br><h2 id="sintaksis">  Sintaks </h2><br><p>  Sintaks terakhir akan terlihat seperti berikut ini: </p><br><pre> <code class="plaintext hljs">foreach await (var dataChunk in asyncStreams) { //        yield    . }</code> </pre> <br><p>  Dari contoh di atas, jelas bahwa alih-alih menghitung nilai tunggal, kami, secara teoritis, dapat secara berurutan menghitung serangkaian nilai, sambil menunggu operasi asinkron lainnya. </p><br><h2 id="pererabotannyy-primer-microsoft">  Contoh Microsoft yang didesain ulang </h2><br><p>  Saya menulis ulang kode demo Microsoft.  Itu dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diunduh seluruhnya dari repositori GitHub saya</a> . </p><br><p>  Contoh ini didasarkan pada gagasan untuk menciptakan aliran besar dalam memori (array 20.000 byte) dan secara berurutan mengekstraksi elemen darinya dalam mode asinkron.  Selama setiap iterasi, 8 KB ditarik dari array. </p><br><p><img src="https://habrastorage.org/webt/dc/e8/su/dce8suk_2kzcxekmrxv0uxuxse0.jpeg"></p><br><p><img src="https://habrastorage.org/webt/-r/nx/dk/-rnxdkdf61nc4acry7xknhhubyq.jpeg"></p><br><p>  Pada langkah (1), array data besar dibuat, diisi dengan nilai dummy.  Kemudian, selama langkah (2), variabel yang disebut checksum didefinisikan.  Variabel yang mengandung checksum ini dimaksudkan untuk memverifikasi kebenaran jumlah penjumlahan.  Array dan checksum dibuat dalam memori dan dikembalikan sebagai urutan elemen pada langkah (3). </p><br><p>  Langkah (4) melibatkan penerapan <code>AsEnumarble</code> ekstensi <code>AsEnumarble</code> (nama yang lebih cocok AsAsyncEnumarble), yang membantu mensimulasikan aliran asinkron 8 KB (BufferSize = 8000 elemen (6)) </p><br><p>  Biasanya tidak diperlukan untuk mewarisi dari IAsyncEnumerable, tetapi dalam contoh yang ditunjukkan di atas, operasi ini dilakukan untuk menyederhanakan kode demo, seperti yang ditunjukkan pada langkah (5). </p><br><p>  Langkah (7) melibatkan penggunaan kata kunci <code>foreach</code> , yang mengekstrak 8 KB potongan data dari aliran asinkron dalam memori.  Proses menarik terjadi secara berurutan: ketika konsumen (bagian dari kode yang berisi <code>foreach</code> ) siap menerima potongan data berikutnya, ia menariknya dari penyedia (array yang terkandung dalam aliran dalam memori).  Akhirnya, ketika siklus selesai, program akan memeriksa nilai 'c' untuk checksum dan jika mereka cocok, itu akan menampilkan pesan "Checksums cocok!", Menurut langkah (8). </p><br><p>  Jendela output demo Microsoft: </p><br><p><img src="https://habrastorage.org/webt/_l/cw/2o/_lcw2ofjh0vkrnmwtymlnowxdr8.jpeg"></p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Kami melihat utas asinkron, yang bagus untuk menarik data secara asinkron dan menulis kode yang menghasilkan beberapa nilai dalam mode asinkron. <br>  Menggunakan model ini, Anda dapat meminta elemen data berikutnya secara berurutan dan mendapatkan respons.  Ini berbeda dari model push data <code>IObservable&lt;T&gt;</code> , menggunakan nilai mana yang dihasilkan terlepas dari keadaan konsumen.  Aliran asinkron memungkinkan Anda untuk secara sempurna mewakili sumber data asinkron yang dikendalikan oleh konsumen ketika ia sendiri menentukan kesediaan untuk menerima bagian data berikutnya.  Contohnya termasuk menggunakan aplikasi web atau membaca catatan dalam database. </p><br><p>  Saya mendemonstrasikan cara membuat enumerasi dalam mode asinkron dan menggunakannya menggunakan perpustakaan eksternal dengan urutan asinkron.  Saya juga menunjukkan manfaat apa yang disediakan fitur ini saat mengunduh konten dari Internet.  Akhirnya, kami melihat sintaks baru untuk utas asinkron, serta contoh lengkap penggunaannya berdasarkan Microsoft Build Demo Code ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7–9 Mei, 2018 // Seattle, WA</a> ) </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462755/">https://habr.com/ru/post/id462755/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462743/index.html">Moscow SPA Meetup # 5 - Pengumuman Rapat</a></li>
<li><a href="../id462747/index.html">Saya menulis artikel ini tanpa pernah melihat keyboard</a></li>
<li><a href="../id462749/index.html">Manajemen kebahagiaan: cara merawat dan mengembangkan tim kantor pusat dari 30+ kota</a></li>
<li><a href="../id462751/index.html">Lingkungan Android</a></li>
<li><a href="../id462753/index.html">Kekuatan generik di Swift. Bagian 1</a></li>
<li><a href="../id462763/index.html">GAZ-66 mainan di panel kontrol. Bagian 3</a></li>
<li><a href="../id462765/index.html">ONYX BOOX Note Pro ulasan: pembaca PDF top-end</a></li>
<li><a href="../id462769/index.html">Penerapan pembelajaran mesin dan ilmu data dalam industri</a></li>
<li><a href="../id462771/index.html">Mereka tidak menyembunyikan apa pun</a></li>
<li><a href="../id462773/index.html">Cara bekerja dengan Google Trends: panduan lengkap untuk pemula</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>