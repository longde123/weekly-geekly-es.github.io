<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏾 ⏺️ 👉🏼 Java：对于经验丰富的开发人员而言似乎有些好奇的事情 👨🏿‍🌾 🍐 💃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一天中的好时光！ 

 这篇文章是在另一位作者发表在“您可能不了解Java的事情”一书之后撰写的，我将其归类为“面向初学者”。 通过阅读和评论它，我意识到我学到了很多相当有趣的东西，已经用Java编程了一年多。 也许这些事情对其他人似乎很好奇。 

 从我的角度来看，这一事实可能对初学者有用，因此我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java：对于经验丰富的开发人员而言似乎有些好奇的事情</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482950/">一天中的好时光！ <br><br> 这篇文章是在另一位作者发表在<a href="https://habr.com/ru/post/482364">“您可能不了解Java的事情”</a>一书之后撰写的，我将其归类为“面向初学者”。 通过阅读和评论它，我意识到我学到了很多相当有趣的东西，已经用Java编程了一年多。 也许这些事情对其他人似乎很好奇。 <br><br><a name="habracut"></a> 从我的角度来看，这一事实可能对初学者有用，因此我删除了“破坏者”。 对于一些经验丰富的人来说，有些事情可能仍然很有趣。 例如，我自己直到编写Boolean.hashCode（true）== 1231和Boolean.hashCode（false）== 1237时才知道。 <br><br><div class="spoiler">  <b class="spoiler_title">对于初学者</b> <div class="spoiler_text"><ul><li>  Boolean.hashCode（true）== 1231 </li><li>  Boolean.hashCode（false）== 1237 </li><li>  Float.hashCode（值）== Float.floatToIntBits（值） </li><li>  Double.hashCode（值）-第一个和第二个32位半字的Double（双精度）Double.doubleToLongBits（值） </li></ul></div></div><br><h2>  Object.hashCode（）不再是内存中对象的地址 </h2><br> 免责声明：这是Oracle（HotSpot）的jvm详细信息。 <br><br><div class="spoiler">  <b class="spoiler_title">很久以前就是这样。</b> <div class="spoiler_text"> 从jdk1.2.1 / docs / api / java / lang / Object.html＃hashCode（）： <blockquote> 在合理可行的范围内，由Object类定义的hashCode方法确实为不同的对象返回不同的整数。  （通常通过将对象的内部地址转换为整数来实现，但是JavaTM编程语言不需要此实现技术。） </blockquote></div></div><br> 然后他们拒绝了。 这就是<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Object.html" rel="nofollow">javadoc对jdk 12的描述</a> 。 <br><br>  <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko</a>建议可以使用-XX恢复旧行为：hashCode = 4。 行为更改本身几乎来自Java 1.2版本。 <br><br><h2>  Integer.valueOf（15）== Integer.valueOf（15）;  Integer.valueOf（128）！= Integer.valueOf（128） </h2><br> 免责声明：这是<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html" rel="nofollow">jls的</a>一部分。 <br><br> 显然，将两个包装器与==（！=）运算符进行比较时，不会发生自动装箱。 一般而言，这是混淆的第一个平等。 事实是对于整数值i：-129 &lt;i &lt;128整数包装器对象被缓存。 因此，对于此范围内的i，Integer.valueOf（i）不会每次都创建一个新对象，而是返回一个已经创建的对象。 对于不属于此范围的i，Integer.valueOf（i）始终创建一个新对象。 因此，如果您不密切监视精确比较的内容以及比较的精确程度，则可以编写似乎有效并且甚至包含测试的代码，但同时包含此类“耙”。 <br><br> 在Oracle（HotSpot）的jvm中，可以通过属性<a href="" rel="nofollow">“ java.lang.Integer.IntegerCache.high”</a>更改缓存的上限。 <br><br><h2> 在某些情况下，另一个类的原始或字符串最终静态字段的值在编译时解析 </h2><br> 这听起来令人困惑，并且声明有点长。 意思是这个。 如果我们有一个类将原始类型或字符串的常量定义为具有立即初始化的最终静态字段， <br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_1 = <span class="hljs-string"><span class="hljs-string">"case_1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_2 = <span class="hljs-string"><span class="hljs-string">"case_2"</span></span>; }</code> </pre> <br> 当在其他类中使用时， <pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TheClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... public static int getCaseNumber(String caseName) { switch (caseName) { case AnotherClass.CASE_1: return 1; case AnotherClass.CASE_2: return 2; default: throw new IllegalArgumentException("value of the argument caseName does not belong to the allowed value set"); } } }</span></span></code> </pre><br> 这些常量的值（“ case_1”，“ case_2”）在编译时解析。 它们作为值而不是链接插入到代码中。 也就是说，如果我们从库中使用了此类常量，然后获得了其中常量值已更改的库的新版本，则应重新编译项目。 否则，旧的常量值可能会继续在代码中使用。 <br><br> 在必须使用常量表达式（例如，switch / case）的所有位置都可以观察到此行为，或者允许编译器将表达式转换为常量，并且他可以执行此操作。 <br><br> 一旦通过将初始化转移到静态块中删除了立即初始化，就不能在常量表达式中使用这些字段。 <br><br><div class="spoiler">  <b class="spoiler_title">对于初学者</b> <div class="spoiler_text"><h2> 在某些情况下，垃圾收集器可能永远不会运行。 </h2><br> 结果，将不会启动finalize（）。 因此，您不应编写依赖finalize（）始终有效的事实的代码。 是的，如果对象在程序结束之前进入垃圾箱，则很可能收集器不会收集该对象。 <br><br><h2> 特定对象的finalize（）方法只能被调用一次。 </h2><br> 在finalize（）中，我们可以使对象再次可见，并且垃圾收集器这次不会“删除”该对象。 当该对象再次掉入垃圾桶时，它将被“编译”，而无需调用finalize（）。 如果在finalize（）中引发了异常，并且该对象仍然对任何人都不可见，则它将被“汇编”。  Finalize（）将不再被调用。 <br><br><h2> 事先不知道将在其中调用finalize（）的流 </h2><br> 仅保证该线程没有主程序可见的锁。 <br><br><h2> 对象上存在覆盖的finalize（）方法会减慢垃圾收集过程 </h2><br> 表面上是需要仔细检查对象的可用性-在调用finalize（）之前一次，在以下垃圾回收之一中运行一次。 <br><br><h2> 最终确定（）时，很难与僵局作斗争 </h2><br> 在非平凡的finalize（）中，可能有必要使用锁，鉴于上述特定情况，锁很难调试。 <br><br><h2> 自Java版本9以来，Object.finalize（）已被标记为已弃用！ </h2><br> 考虑到上述细节，这不足为奇。 </div></div><br><h2> 经典的懒惰单例初始化：需要双重锁定 </h2><br> 在此主题上存在一个误解，即看起来很合逻辑的以下方法（双重检查惯用语）总是可行的： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// read 1, check 1 synchronized (this) { if (instance == null) { // read 2, check 2 instance = new Singleton(); } } } return instance; // read 3 } }</span></span></code> </pre><br> 我们查看是否创建了对象（读取1，检查1）。 如果是这样，则将其返回。 如果不是，则设置锁，确保未创建对象，创建对象（删除锁），然后返回对象。 <br><br> 由于以下原因，该方法不起作用。  <s>（读取1，检查1）和（读取3）不同步。</s>  <s>根据Java内存模型的概念，在另一个线程中所做的更改可能直到我们同步才对我们的线程可见。</s> 感谢<a href="https://habr.com/ru/users/mk2/" class="user_link">mk2</a>的评论，这是问题的正确描述： <br><blockquote> 是的，read1和read3没有同步，但是问题不在另一个线程中。 不同步的读数可以重新排序的事实，即  read1！= null，但read3 == null。 同时，由于“ instance = new Singleton（）;”，我们可以在对象完全构建之前获得对该对象的引用，这实际上是与另一个线程的同步问题，但不是read1和read3，而是read3和access实例成员。 </blockquote> 通过在读取过程中添加同步，或通过标记指向单例链接的变量是易变的，可以对其进行处理。  （使用volatile的解决方案仅适用于Java 5+。在此之前，Java的内存模型在这种情况下具有不确定性。）这是一个可行的版本（具有附加的优化功能-添加了局部变量`res`以减少从volatile字段读取的次数）。 <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SafeLocalDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Singleton res = instance; <span class="hljs-comment"><span class="hljs-comment">// read 1 if (res == null) { // check 1 synchronized (this) { res = instance; // read 2 if (res == null) { // check 2 res = new Singleton(); instance = res; } } } return res; } }</span></span></code> </pre><br> 该代码是<a href="https://shipilev.net/blog/2014/safe-public-construction/" rel="nofollow">从此处获取的</a> ，来自Alexei Shipilev的站点。 可以找到有关此问题的更多详细信息。 <br><br><h2>  “按需初始化持有人惯用语”-非常漂亮的“懒惰”单例初始化 </h2><br>  java仅在必要时初始化类（Class对象），当然也仅初始化一次。 您可以利用这一优势！ 按需初始化的持有人惯用机制就是这样做的。  （代码<a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom" rel="nofollow">从这里开始</a> 。） <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Something</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Something INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Something(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Something </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LazyHolder.INSTANCE; } }</code> </pre><br>  LazyHolder类将仅在首次调用Something.getInstance（）时初始化。  Jvm将确保这种情况仅发生一次，而且非常高效-如果该类已经初始化，则不会有开销。 因此，LazyHolder.INSTANCE也将被初始化一次，“惰性”且线程安全。 <div class="spoiler">  <b class="spoiler_title">有关开销的规范</b> <div class="spoiler_text"> 如果此初始化过程正常完成，并且Class对象已完全初始化并且可以使用，则不再需要调用初始化过程，并且可以从代码中删除它（例如，通过打补丁或以其他方式重新生成代码） 。 <br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" rel="nofollow">来源</a> </div></div><br> 一般来说，单调不被视为最佳实践。 <br><br> 材料尚未结束。 因此，如果需要“伸出手”和已经写过的东西，我将在这个话题上以其他方式写更多。 <br><br> 感谢您的建设性意见。 感谢<a href="https://habr.com/ru/users/sergey-gornostaev/" class="user_link">sergey-gornostaev</a> ， <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko</a> ， <a href="https://habr.com/ru/users/olehkurpiak/" class="user_link">OlehKurpiak</a> ， <a href="https://habr.com/ru/users/mk2/" class="user_link">mk2</a> ，扩大了本文中的几个位置。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482950/">https://habr.com/ru/post/zh-CN482950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482940/index.html">上周第396期（2019年12月30日至2020年1月5日）的前端世界摘要</a></li>
<li><a href="../zh-CN482942/index.html">古代Fediverse的神话传说</a></li>
<li><a href="../zh-CN482944/index.html">多组分输送机</a></li>
<li><a href="../zh-CN482946/index.html">1СDSS和通过COCOMO II方法估算项目的条款和成本</a></li>
<li><a href="../zh-CN482948/index.html">“一，二，三-烧圣诞树！”或者我第一次看到CANNY 3微型控制器</a></li>
<li><a href="../zh-CN482956/index.html">WCS 5.2-用于Webcast和Webcam开发人员的WebRTC服务器的评论</a></li>
<li><a href="../zh-CN482958/index.html">“成长规则：从初级到首席技术官”，Fedor Borshchev的网络研讨会摘要</a></li>
<li><a href="../zh-CN482960/index.html">WCS 5.2概述-用于在线广播和视频聊天的Web开发人员的WebRTC服务器</a></li>
<li><a href="../zh-CN482968/index.html">Quarkus-云原生Java的新外观</a></li>
<li><a href="../zh-CN482970/index.html">哈克盒子-演练工艺。 我们深入研究Git，利用API中的漏洞，处理保险柜</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>