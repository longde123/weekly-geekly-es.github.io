<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚪 🤲🏾 📄 Deskripsi arsitektur prosesor dalam LLVM menggunakan TableGen 🧔🏿 🖇️ 🏝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, LLVM telah menjadi sistem yang sangat populer, yang banyak orang gunakan secara aktif untuk membuat berbagai kompiler, analisa, dll. Sejumla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deskripsi arsitektur prosesor dalam LLVM menggunakan TableGen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474460/"> Saat ini, LLVM telah menjadi sistem yang sangat populer, yang banyak orang gunakan secara aktif untuk membuat berbagai kompiler, analisa, dll.  Sejumlah besar bahan berguna tentang topik ini telah ditulis, termasuk dalam bahasa Rusia, yang merupakan berita baik.  Namun, dalam kebanyakan kasus, bias utama dalam artikel dibuat di LLVM frontend dan midend.  Tentu saja, ketika menggambarkan skema penuh operasi LLVM, pembuatan kode mesin tidak dilewati, tetapi pada dasarnya topik ini disentuh dengan santai, terutama dalam publikasi di Rusia.  Pada saat yang sama, LLVM memiliki mekanisme yang agak fleksibel dan menarik untuk menggambarkan arsitektur prosesor.  Oleh karena itu, materi ini akan dikhususkan untuk TableGen utilitas yang agak terabaikan, yang merupakan bagian dari LLVM. <br><br>  Alasan kompiler perlu memiliki informasi tentang arsitektur masing-masing platform target cukup jelas.  Secara alami, setiap model prosesor memiliki set register sendiri, instruksi mesinnya sendiri, dll.  Dan kompiler perlu memiliki semua informasi yang diperlukan tentang mereka agar dapat menghasilkan kode mesin yang valid dan efisien.  Kompiler menyelesaikan berbagai tugas khusus platform: mendistribusikan register, dll.  Selain itu, backend LLVM juga melakukan optimasi pada mesin IR, yang lebih dekat dengan instruksi aktual, atau pada instruksi assembler sendiri.  Dalam optimisasi semacam itu, instruksi perlu diganti dan diubah, sehingga semua informasi tentangnya harus tersedia. <br><a name="habracut"></a><br>  Untuk memecahkan masalah menggambarkan arsitektur prosesor, LLVM mengadopsi format tunggal untuk menentukan properti prosesor yang diperlukan untuk kompiler.  Untuk setiap arsitektur yang didukung, <code>.td</code> berisi deskripsi dalam bahasa formal khusus.  Itu dikonversi ke file <code>.inc</code> ketika membangun kompiler menggunakan utilitas TableGen yang disertakan dengan LLVM.  File yang dihasilkan, pada kenyataannya, adalah sumber C, tetapi kemungkinan besar memiliki ekstensi yang terpisah, hanya agar file-file yang dihasilkan secara otomatis ini dapat dengan mudah dibedakan dan difilter.  Dokumentasi resmi untuk TableGen ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan memberikan semua informasi yang diperlukan, ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi resmi bahasa</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengantar umum</a> . <br><br>  Tentu saja, ini adalah topik yang sangat luas, di mana ada banyak detail tentang mana Anda dapat menulis artikel individual.  Dalam artikel ini, kami hanya mempertimbangkan poin dasar dari deskripsi prosesor bahkan tanpa tinjauan umum dari semua fitur. <br><br><h2>  Deskripsi arsitektur dalam file .td </h2><br>  Jadi, bahasa deskripsi formal yang digunakan dalam TableGen memiliki fitur yang mirip dengan bahasa pemrograman biasa dan memungkinkan Anda untuk menggambarkan karakteristik arsitektur dalam gaya deklaratif.  Dan seperti yang saya pahami, bahasa ini juga biasa disebut TableGen.  Yaitu  Dalam artikel ini, TableGen menggunakan nama bahasa formal itu sendiri dan utilitas yang menghasilkan artefak yang dihasilkan dari itu. <br><br>  Prosesor modern adalah sistem yang sangat kompleks, sehingga tidak mengherankan bahwa deskripsi mereka cukup banyak.  Oleh karena itu, untuk membuat struktur dan menyederhanakan pemeliharaan file <code>.td</code> dapat menyertakan satu sama lain menggunakan arahan <code>#include</code> biasa untuk programmer C.  Dengan bantuan arahan ini, file <code>Target.td</code> selalu disertakan pertama kali, yang berisi antarmuka platform independen yang harus diimplementasikan untuk memberikan semua informasi TableGen yang diperlukan.  File ini sudah termasuk file <code>.td</code> dengan deskripsi intrinsik LLVM, tetapi dengan sendirinya sebagian besar berisi kelas dasar, seperti <code>Register</code> , <code>Instruction</code> , <code>Processor</code> , dll., Dari mana Anda perlu mewarisi untuk membuat arsitektur Anda sendiri untuk kompiler berdasarkan LLVM.  Dari kalimat sebelumnya, jelas bahwa TableGen memiliki gagasan tentang kelas yang dikenal oleh semua programmer. <br><br>  Secara umum, TableGen hanya memiliki dua entitas dasar: <b>kelas</b> dan <b>definisi</b> . <br><br><h3>  Kelas </h3><br>  Kelas TableGen juga abstraksi, seperti dalam semua bahasa pemrograman berorientasi objek, tetapi mereka adalah entitas yang lebih sederhana. <br><br>  Kelas dapat memiliki parameter dan bidang, dan mereka juga bisa mewarisi kelas lain. <br>  Sebagai contoh, salah satu kelas dasar disajikan di bawah ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A class representing the register size, spill size and spill alignment // in bits of a register. class RegInfo&lt;int RS, int SS, int SA&gt; { int RegSize = RS; // Register size in bits. int SpillSize = SS; // Spill slot size in bits. int SpillAlignment = SA; // Spill slot alignment in bits. }</span></span></code> </pre> <br>  Kurung sudut menunjukkan parameter input yang ditugaskan ke properti kelas.  Dari contoh ini, Anda juga dapat melihat bahwa bahasa TableGen diketik secara statis.  Tipe-tipe yang ada di TableGen: <code>bit</code> (analog dari tipe Boolean dengan nilai 0 dan 1), <code>int</code> , <code>string</code> , <code>code</code> (sepotong kode, ini adalah tipe, hanya karena TableGen tidak memiliki metode dan fungsi dalam arti biasa, baris kode ditulis dalam <code>[{ ... }]</code> ), bit &lt;n&gt;, daftar &lt;type&gt; (nilai-nilai diatur menggunakan tanda kurung siku [...] seperti dalam Python dan beberapa bahasa pemrograman lain), <code>class type</code> , <code>dag</code> . <br><br>  Sebagian besar jenis harus dipahami, tetapi jika mereka memiliki pertanyaan, mereka semua dijelaskan secara rinci dalam spesifikasi bahasa, tersedia di tautan yang diberikan di awal artikel. <br><br>  Warisan juga dijelaskan oleh sintaks yang cukup akrab dengan <code>:</code> <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemOperand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printMethod</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmOperandClass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parserMatchClass</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemAsmOperand</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iPTR</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PrintMethod</span></span> = printMethod; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">MIOperandInfo</span></span> = (ops ptr_rc, i8imm, ptr_rc_nosp, i32imm, <span class="hljs-type"><span class="hljs-type">SEGMENT_REG</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">ParserMatchClass</span></span> = parserMatchClass; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">OperandType</span></span> = <span class="hljs-string"><span class="hljs-string">"OPERAND_MEMORY"</span></span>; }</code> </pre> <br>  Dalam hal ini, kelas yang dibuat, tentu saja, dapat menimpa nilai bidang yang ditentukan dalam kelas dasar menggunakan kata kunci <code>let</code> .  Dan itu dapat menambahkan bidangnya sendiri mirip dengan deskripsi yang diberikan dalam contoh sebelumnya, menunjukkan jenis bidang. <br><br><h3>  Definisi </h3><br>  Definisi sudah entitas konkret, Anda dapat membandingkannya dengan yang akrab dengan semua objek.  Definisi didefinisikan menggunakan kata kunci <code>def</code> dan dapat mengimplementasikan kelas, mendefinisikan kembali bidang kelas dasar dengan cara yang persis sama seperti yang dijelaskan di atas, dan juga memiliki bidangnya sendiri. <br><br><pre> <code class="swift hljs">def i8mem : <span class="hljs-type"><span class="hljs-type">X86MemOperand</span></span>&lt;<span class="hljs-string"><span class="hljs-string">"printbytemem"</span></span>, <span class="hljs-type"><span class="hljs-type">X86Mem8AsmOperand</span></span>&gt;; def <span class="hljs-type"><span class="hljs-type">X86AbsMemAsmOperand</span></span> : <span class="hljs-type"><span class="hljs-type">AsmOperandClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"AbsMem"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">SuperClasses</span></span> = [<span class="hljs-type"><span class="hljs-type">X86MemAsmOperand</span></span>]; }</code> </pre><br><h3>  Multiclasses </h3><br>  Secara alami, sejumlah besar instruksi dalam prosesor memiliki semantik yang serupa.  Misalnya, mungkin ada satu set instruksi tiga alamat yang mengambil dua bentuk <code>“reg = reg op reg”</code> dan <code>“reg = reg op imm”</code> .  Dalam satu kasus, nilai diambil dari register dan hasilnya juga disimpan dalam register, dan dalam kasus lain, operan kedua adalah nilai konstan (operan tidak langsung). <br><br>  Mendaftar semua kombinasi secara manual agak membosankan, risiko membuat kesalahan meningkat.  Tentu saja, mereka dapat dihasilkan secara otomatis dengan menulis skrip sederhana, tetapi ini tidak perlu, karena konsep seperti multiclasses ada dalam bahasa TableGen. <br><br><pre> <code class="cpp hljs">multiclass ri_inst&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> asmstr&gt; { def _rr : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;; def _ri : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;; }</code> </pre> <br>  Di dalam multiclasses, Anda perlu menjelaskan semua bentuk instruksi yang mungkin menggunakan kata kunci <code>def</code> .  Tapi ini bukan bentuk instruksi yang lengkap untuk dihasilkan.  Pada saat yang sama, Anda dapat mendefinisikan ulang bidang di dalamnya dan melakukan segala sesuatu yang mungkin dalam definisi yang biasa.  Untuk membuat definisi nyata berdasarkan multiclass, Anda perlu menggunakan kata kunci <code>defm</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Instantiations of the ri_inst multiclass. defm ADD : ri_inst&lt;0b111, "add"&gt;; defm SUB : ri_inst&lt;0b101, "sub"&gt;; defm MUL : ri_inst&lt;0b100, "mul"&gt;;</span></span></code> </pre> <br>  Dan sebagai hasilnya, untuk setiap definisi yang diberikan melalui <code>defm</code> pada kenyataannya, beberapa definisi akan dibangun yang merupakan kombinasi dari instruksi utama dan semua bentuk yang mungkin dijelaskan dalam multiclass.  Sebagai hasilnya, instruksi berikut akan dihasilkan dalam contoh ini: <code>ADD_rr</code> , <code>ADD_ri</code> , <code>SUB_rr</code> , <code>SUB_ri</code> , <code>MUL_rr</code> , <code>MUL_ri</code> . <br><br>  Multiclasses dapat berisi tidak hanya definisi dengan <code>def</code> , tetapi juga <code>defm</code> bersarang, sehingga memungkinkan pembentukan bentuk instruksi yang kompleks.  Contoh yang menggambarkan pembuatan rantai semacam itu dapat ditemukan dalam dokumentasi resmi. <br><br><h3>  Subtarget </h3><br>  Hal dasar dan berguna lainnya untuk prosesor yang memiliki variasi set instruksi yang berbeda adalah dukungan subtarget dalam LLVM.  Contoh penggunaan adalah implementasi LLVM SPARC, yang mencakup tiga versi utama arsitektur mikroprosesor SPARC sekaligus: Versi 8 (V8, arsitektur 32-bit), Versi 9 (V9, arsitektur 64-bit) dan arsitektur UltraSPARC.  Perbedaan antara arsitektur cukup besar, jumlah register yang berbeda dari jenis yang berbeda, urutan byte yang didukung, dll.  Dalam kasus seperti itu, jika ada beberapa konfigurasi, ada baiknya menerapkan kelas <code>XXXSubtarget</code> untuk arsitektur.  Menggunakan kelas ini dalam deskripsi akan menghasilkan opsi baris perintah baru <code>-mcpu=</code> dan <code>-mattr=</code> . <br><br>  Selain kelas <code>Subtarget</code> itu sendiri, kelas <code>Subtarget</code> penting. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubtargetFeature</span></span></span><span class="hljs-class">&lt;string n, string a, string v, string d, list&lt;SubtargetFeature&gt; i = []&gt; {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Name = n; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Attribute = a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Value = v; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Desc = d; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;SubtargetFeature&gt; Implies = i; }</code> </pre> <br>  Dalam file <code>Sparc.td</code> , Anda dapat menemukan contoh implementasi <code>SubtargetFeature</code> , yang memungkinkan Anda untuk menggambarkan ketersediaan serangkaian instruksi untuk setiap subtipe individu arsitektur. <br><br><pre> <code class="cpp hljs">def FeatureV9 : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsV9"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable SPARC-V9 instructions"</span></span>&gt;; def FeatureV8Deprecated : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"deprecated-v8"</span></span>, <span class="hljs-string"><span class="hljs-string">"V8DeprecatedInsts"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable deprecated V8 instructions in V9 mode"</span></span>&gt;; def FeatureVIS : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"vis"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsVIS"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable UltraSPARC Visual Instruction Set extensions"</span></span>&gt;;</code> </pre><br>  Dalam kasus ini, <code>Sparc.td</code> masih mendefinisikan kelas <code>Proc</code> , yang digunakan untuk menggambarkan subtipe spesifik dari prosesor SPARC, yang mungkin memiliki sifat-sifat yang dijelaskan di atas, termasuk set instruksi yang berbeda. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Proc</span></span></span><span class="hljs-class">&lt;string Name, list&lt;SubtargetFeature&gt; Features&gt; :</span></span> Processor&lt;Name, NoItineraries, Features&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"generic"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v8"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"supersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"f934"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"hypersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite86x"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclet"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"tsc701"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, [FeatureV9]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3-vis"</span></span>, [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</code> </pre> <br><h2>  Hubungan antara sifat-sifat instruksi di TableGen dan kode backend LLVM </h2><br>  Properti kelas dan definisi memungkinkan Anda untuk menghasilkan dan mengatur fitur arsitektur dengan benar, tetapi tidak ada akses langsung ke mereka dari kode sumber backend LLVM.  Namun, kadang-kadang Anda ingin mendapatkan beberapa properti khusus platform secara langsung dalam kode kompiler. <br><br><h3>  TSFlags </h3><br>  Untuk melakukan ini, kelas dasar <code>Instruction</code> memiliki bidang <code>TSFlags</code> khusus, <code>TSFlags</code> 64 bit, yang dikonversi oleh TableGen ke bidang objek C ++ kelas <code>MCInstrDesc</code> , yang dihasilkan berdasarkan data yang diterima dari deskripsi TableGen.  Anda dapat menentukan jumlah bit yang Anda perlukan untuk menyimpan informasi.  Ini mungkin beberapa nilai Boolean, misalnya, untuk menunjukkan bahwa kami menggunakan ALU skalar. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">TSFlags</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>} = <span class="hljs-type"><span class="hljs-type">SALU</span></span>;</code> </pre> <br>  Atau kita bisa menyimpan jenis instruksinya.  Maka kita perlu, tentu saja, lebih dari satu bit. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Instruction type according to the ISA. IType Type = type; let TSFlags{7-1} = Type.Value;</span></span></code> </pre> <br>  Akibatnya, menjadi mungkin untuk mendapatkan properti ini dari instruksi di kode backend. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSALU = MI.getDesc().TSFlags &amp; SIInstrFlags::SALU;</code> </pre> <br>  Jika properti lebih kompleks, maka Anda dapat membandingkannya dengan nilai yang dijelaskan dalam TableGen, yang akan ditambahkan ke enumerasi yang dibuat secara otomatis. <br><br><pre> <code class="cpp hljs">(Desc.TSFlags &amp; X86II::FormMask) == X86II::MRMSrcMem</code> </pre> <br><br><h3>  Predikat fungsi </h3><br>  Juga, predikat fungsi dapat digunakan untuk mendapatkan informasi yang diperlukan tentang instruksi.  Dengan bantuan mereka, Anda bisa menunjukkan kepada TableGen bahwa Anda perlu membuat fungsi yang sesuai akan tersedia dalam kode backend.  Kelas dasar yang dengannya Anda dapat membuat definisi fungsi disajikan di bawah ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base class for function predicates. class FunctionPredicateBase&lt;string name, MCStatement body&gt; { string FunctionName = name; MCStatement Body = body; }</span></span></code> </pre> <br>  Anda dapat dengan mudah menemukan contoh penggunaan di backend untuk X86.  Jadi ada kelas menengahnya sendiri, dengan bantuan definisi fungsi yang diperlukan sudah dibuat. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Check that a call to method `Name` in class "XXXInstrInfo" (where XXX is // the name of a target) returns true. // // TIIPredicate definitions are used to model calls to the target-specific // InstrInfo. A TIIPredicate is treated specially by the InstrInfoEmitter // tablegen backend, which will use it to automatically generate a definition in // the target specific `InstrInfo` class. // // There cannot be multiple TIIPredicate definitions with the same name for the // same target class TIIPredicate&lt;string Name, MCStatement body&gt; : FunctionPredicateBase&lt;Name, body&gt;, MCInstPredicate; // This predicate evaluates to true only if the input machine instruction is a // 3-operands LEA. Tablegen automatically generates a new method for it in // X86GenInstrInfo. def IsThreeOperandsLEAFn : TIIPredicate&lt;"isThreeOperandsLEA", IsThreeOperandsLEABody&gt;; //   -    ,  -  ,       // Used to generate the body of a TII member function. def IsThreeOperandsLEABody : MCOpcodeSwitchStatement&lt;[LEACases], MCReturnStatement&lt;FalsePred&gt;&gt;;</span></span></code> </pre> <br>  Sebagai hasilnya, Anda dapat menggunakan metode <code>isThreeOperandsLEA</code> dalam kode C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(TII-&gt;isThreeOperandsLEA(MI) || hasInefficientLEABaseReg(Base, Index)) || !TII-&gt;isSafeToClobberEFLAGS(MBB, MI) || Segment.getReg() != X86::NoRegister) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  Di sini TII adalah info instruksi target, yang dapat diperoleh dengan menggunakan metode <code>getInstrInfo()</code> dari <code>MCSubtargetInfo</code> untuk arsitektur yang diinginkan. <br><br><h2>  Transformasi instruksi selama optimisasi.  Pemetaan instruksi </h2><br>  Selama sejumlah besar optimasi dilakukan pada tahap akhir kompilasi, tugas tersebut sering muncul untuk mengubah semua atau hanya sebagian dari instruksi dari satu formulir menjadi instruksi dari formulir lain.  Mengingat penerapan multiclasses yang dijelaskan di awal, kita dapat memiliki sejumlah besar instruksi dengan semantik dan properti yang serupa.  Dalam kode, transformasi ini, tentu saja, dapat ditulis dalam bentuk konstruksi <code>switch-case</code> besar, yang untuk setiap instruksi menghancurkan transformasi yang sesuai.  Sebagian, konstruksi besar ini dapat dikurangi dengan bantuan makro, yang akan membentuk nama instruksi yang diperlukan sesuai dengan aturan yang terkenal.  Namun tetap saja, pendekatan ini sangat merepotkan, sulit dipertahankan karena fakta bahwa semua nama instruksi didaftar secara eksplisit.  Menambahkan instruksi baru dapat dengan mudah menyebabkan kesalahan, karena  Anda harus ingat untuk menambahkannya ke semua konversi yang relevan.  Setelah disiksa dengan pendekatan ini, LLVM menciptakan mekanisme khusus untuk secara efisien mengubah satu bentuk instruksi ke <code>Instruction Mapping</code> lainnya. <br><br>  Idenya sangat sederhana, perlu untuk menggambarkan model yang mungkin untuk mengubah instruksi secara langsung di TableGen.  Oleh karena itu, dalam TableGen LLVM ada kelas dasar untuk menggambarkan model seperti itu. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrMapping</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Used to reduce search space only to the instructions using this // relation model. string FilterClass; // List of fields/attributes that should be same for all the instructions in // a row of the relation table. Think of this as a set of properties shared // by all the instructions related by this relationship. list&lt;string&gt; RowFields = []; // List of fields/attributes that are same for all the instructions // in a column of the relation table. list&lt;string&gt; ColFields = []; // Values for the fields/attributes listed in 'ColFields' corresponding to // the key instruction. This is the instruction that will be transformed // using this relation model. list&lt;string&gt; KeyCol = []; // List of values for the fields/attributes listed in 'ColFields', one for // each column in the relation table. These are the instructions a key // instruction will be transformed into. list&lt;list&lt;string&gt; &gt; ValueCols = []; }</span></span></code> </pre> <br>  Mari kita lihat contoh yang diberikan dalam dokumentasi.  Contoh-contoh yang dapat ditemukan dalam kode sumber sekarang bahkan lebih sederhana, karena hanya dua kolom yang diperoleh pada tabel akhir.  Dalam kode backend Anda dapat menemukan konversi formulir lama ke bentuk baru instruksi, instruksi dsp dalam mmdsp, dll., Dijelaskan menggunakan Pemetaan Instruksi.  Sebenarnya, mekanisme ini tidak begitu banyak digunakan sejauh ini, hanya karena sebagian besar backend mulai dibuat sebelum muncul, dan agar bisa berfungsi, Anda masih perlu mengatur properti yang benar untuk instruksi, jadi beralih ke itu tidak selalu mudah, Anda mungkin memerlukan beberapa refactoring. <br><br>  Jadi misalnya.  Misalkan kita memiliki bentuk instruksi tanpa predikat dan instruksi di mana predikatnya masing-masing benar dan salah.  Kami menggambarkannya dengan bantuan multiklass dan kelas khusus, yang hanya akan kami gunakan sebagai filter.  Deskripsi yang disederhanakan tanpa parameter dan banyak properti mungkin seperti ini. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PredRel</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">multiclass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInstruction</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">BaseOpcode</span></span> = name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { def : <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; } def _pt: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span>; } def _pf: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; } } } defm <span class="hljs-type"><span class="hljs-type">ADD</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;”<span class="hljs-type"><span class="hljs-type">ADD</span></span>”&gt;; defm <span class="hljs-type"><span class="hljs-type">SUB</span></span>: <span class="hljs-type"><span class="hljs-type">MyIntruction</span></span>&lt;”<span class="hljs-type"><span class="hljs-type">SUB</span></span>”&gt;; defm <span class="hljs-type"><span class="hljs-type">MUL</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;”<span class="hljs-type"><span class="hljs-type">MUL</span></span>”&gt;; …</code> </pre> <br>  Dalam contoh ini, omong-omong, juga ditunjukkan bagaimana menimpa properti untuk beberapa definisi sekaligus menggunakan <code>let … in</code> konstruk.  Sebagai hasilnya, kami memiliki banyak instruksi yang menyimpan nama dasar dan properti mereka yang secara unik menggambarkan formulir mereka.  Kemudian Anda dapat membuat model transformasi. <br><br><pre> <code class="swift hljs">def getPredOpcode : <span class="hljs-type"><span class="hljs-type">InstrMapping</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,       - PredRel  let FilterClass = "PredRel"; //         ,      let RowFields = ["BaseOpcode"]; //          PredSense. let ColFields = ["PredSense"]; //  ,  ,       ,     PredSense=”” let KeyCol = [""]; //   PredSense      let ValueCols = [["true"], ["false"]]; }</span></span></code> </pre> <br>  Hasilnya, tabel berikut akan dihasilkan dari deskripsi ini. <br><br><div class="scrollable-table"><table><tbody><tr><th>  PredSense = "" </th><th>  PredSense = "true" </th><th>  PredSense = ”false” </th></tr><tr><td>  ADD </td><td>  ADD_pt </td><td>  ADD_pf </td></tr><tr><td>  SUB </td><td>  SUB_pt </td><td>  SUB_pf </td></tr><tr><td>  Mul </td><td>  MUL_pt </td><td>  MUL_pf </td></tr></tbody></table></div><br>  Suatu fungsi akan dihasilkan dalam file <code>.inc</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPredOpcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Opcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PredSense inPredSense)</span></span></span></span></code> </pre> <br>  Dengan demikian, yang menerima kode instruksi untuk konversi dan nilai enumerasi otomatis yang dihasilkan PredSense, yang berisi semua nilai yang mungkin dalam kolom.  Implementasi fungsi ini sangat sederhana, karena  itu mengembalikan elemen array yang diinginkan untuk instruksi yang menarik bagi kami. <br><br>  Dan dalam kode backend, alih-alih menulis <code>switch-case</code> cukup dengan memanggil fungsi yang dihasilkan, yang akan mengembalikan kode dari instruksi yang dikonversi.  Solusi sederhana, di mana menambahkan instruksi baru, tidak akan mengarah pada perlunya tindakan tambahan. <br><br><h2>  Artefak yang dibuat secara otomatis (file <code>.inc</code> ) </h2><br>  Semua interaksi antara deskripsi TableGen dan kode backend LLVM dipastikan oleh file <code>.inc</code> dihasilkan yang berisi kode C.  Untuk mendapatkan gambar yang lengkap, mari kita lihat sedikit apa sebenarnya mereka. <br><br>  Setelah masing-masing membangun, untuk setiap arsitektur, akan ada beberapa file <code>.inc</code> dalam direktori build, masing-masing menyimpan potongan informasi terpisah tentang arsitektur.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi ada file </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang berisi informasi tentang petunjuk </font></font><code>&lt;TargetName&gt;GenRegisterInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, masing-masing, yang berisi informasi tentang register, ada file untuk bekerja secara langsung dengan assembler dan output </font></font><code>&lt;TargetName&gt;GenAsmMatcher.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>&lt;TargetName&gt;GenAsmWriter.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lain-lain </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi terdiri dari apakah file-file ini? Secara umum, mereka berisi enumerasi, array, struktur, dan fungsi sederhana. Misalnya, Anda dapat melihat informasi yang dikonversi pada instruksi di </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian pertama, di namespace dengan nama target adalah enumerasi yang berisi semua instruksi yang telah dijelaskan.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> X86 { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PHI = <span class="hljs-number"><span class="hljs-number">0</span></span>, … ADD16i16 = <span class="hljs-number"><span class="hljs-number">287</span></span>, ADD16mi = <span class="hljs-number"><span class="hljs-number">288</span></span>, ADD16mi8 = <span class="hljs-number"><span class="hljs-number">289</span></span>, ADD16mr = <span class="hljs-number"><span class="hljs-number">290</span></span>, ADD16ri = <span class="hljs-number"><span class="hljs-number">291</span></span>, ADD16ri8 = <span class="hljs-number"><span class="hljs-number">292</span></span>, ADD16rm = <span class="hljs-number"><span class="hljs-number">293</span></span>, ADD16rr = <span class="hljs-number"><span class="hljs-number">294</span></span>, ADD16rr_REV = <span class="hljs-number"><span class="hljs-number">295</span></span>, … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikutnya adalah array yang menggambarkan properti instruksi </font></font><code>const MCInstrDesc X86Insts[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Array berikut berisi informasi tentang nama instruksi, dll. </font><font style="vertical-align: inherit;">Pada dasarnya, semua informasi disimpan dalam transfer dan array. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada juga fungsi yang telah dijelaskan menggunakan predikat. </font><font style="vertical-align: inherit;">Berdasarkan definisi predikat fungsi yang dibahas di bagian sebelumnya, fungsi berikut akan dihasilkan.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> X86InstrInfo::isThreeOperandsLEA(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MachineInstr &amp;MI) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(MI.getOpcode()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64_32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA16r: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ( ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isImm() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).getImm() != <span class="hljs-number"><span class="hljs-number">0</span></span> ) || (MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isGlobal()) ) ); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// end of switch-stmt }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi ada data dalam file dan struktur yang dihasilkan. </font><font style="vertical-align: inherit;">Di </font></font><code>X86GenSubtargetInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menemukan contoh struktur yang harus digunakan dalam kode backend untuk mendapatkan informasi tentang arsitektur, melalui itu di bagian sebelumnya ternyata TTI.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86GenMCSubtargetInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MCSubtargetInfo { X86GenMCSubtargetInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triple &amp;TT, StringRef CPU, StringRef FS, ArrayRef&lt;SubtargetFeatureKV&gt; PF, ArrayRef&lt;SubtargetSubTypeKV&gt; PD, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteProcResEntry *WPR, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteLatencyEntry *WL, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCReadAdvanceEntry *RA, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InstrStage *IS, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *OC, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *FP) : MCSubtargetInfo(TT, CPU, FS, PF, PD, WPR, WL, RA, IS, OC, FP) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveVariantSchedClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SchedClass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MCInst *MI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPUID)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X86_MC::resolveVariantSchedClassImpl(SchedClass, MI, CPUID); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika digunakan </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menggambarkan berbagai konfigurasi </font></font><code>XXXGenSubtarget.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, enumerasi akan dibuat dengan properti yang dijelaskan menggunakan </font></font><code>SubtargetFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array dengan nilai konstan untuk menunjukkan karakteristik dan subtipe CPU, dan sebuah fungsi akan dihasilkan </font></font><code>ParseSubtargetFeatures</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memproses string dengan set opsi </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selain itu, implementasi metode </font></font><code>XXXSubtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kode backend harus sesuai dengan pseudo-code berikut, di mana perlu untuk menggunakan fungsi ini:</font></font><br><br><pre> <code class="cpp hljs">XXXSubtarget::XXXSubtarget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Module &amp;M, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;FS) { <span class="hljs-comment"><span class="hljs-comment">// Set the default features // Determine default and user specified characteristics of the CPU // Call ParseSubtargetFeatures(FS, CPU) to parse the features string // Perform any additional operations }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlepas dari kenyataan bahwa </font></font><code>.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file sangat tebal dan mengandung array besar, ini memungkinkan kami untuk mengoptimalkan waktu akses ke informasi, karena mengakses elemen array memiliki waktu yang konstan. </font><font style="vertical-align: inherit;">Fungsi pencarian yang dihasilkan dengan instruksi diimplementasikan menggunakan algoritma pencarian biner untuk meminimalkan waktu operasi. </font><font style="vertical-align: inherit;">Jadi penyimpanan dalam bentuk ini cukup dibenarkan.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasilnya, terima kasih kepada TableGen di LLVM, kami memiliki deskripsi arsitektur yang mudah dibaca dan didukung dalam format tunggal dengan berbagai mekanisme untuk berinteraksi dan mengakses informasi dari kode sumber backend LLVM untuk optimasi dan pembuatan kode. </font><font style="vertical-align: inherit;">Pada saat yang sama, deskripsi seperti itu tidak mempengaruhi kinerja kompiler karena kode yang dihasilkan secara otomatis yang menggunakan solusi dan struktur data yang efisien.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474460/">https://habr.com/ru/post/id474460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474444/index.html">5 proyek pelatihan lebih berani untuk pengembang (Layer, Squoosh, Kalkulator, Crawler Situs Web, Music Player)</a></li>
<li><a href="../id474448/index.html">Apa yang mampu dimiliki otak seorang siswa di dunia komputer</a></li>
<li><a href="../id474450/index.html">Berhenti menggunakan TTL yang sangat kecil untuk DNS</a></li>
<li><a href="../id474452/index.html">Laporan Status Musim Gugur Haxe</a></li>
<li><a href="../id474458/index.html">Total kumulatif dalam SQL</a></li>
<li><a href="../id474462/index.html">Dataset terbuka yang besar untuk bahasa Rusia versi 1.0</a></li>
<li><a href="../id474466/index.html">Sejarah Diablo pertama</a></li>
<li><a href="../id474470/index.html">Serangan DDoS pada layanan RDP: kenali dan atasi. Pengalaman sukses dari Tucha</a></li>
<li><a href="../id474472/index.html">Daftar periksa UX 30 poin untuk aplikasi seluler</a></li>
<li><a href="../id474474/index.html">Buka tolok ukur untuk memuat pengujian server dan aplikasi web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>