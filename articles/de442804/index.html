<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚈 🌑 🙋🏾 MVCC-1. Isolierung 👩🏻‍🤝‍👨🏽 🕕 👻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Mit diesem Artikel beginne ich eine Reihe von Schleifen (oder eine Reihe von Schleifen? Im Allgemeinen eine großartige Idee) über die inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-1. Isolierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442804/">  Hallo Habr!  Mit diesem Artikel beginne ich eine Reihe von Schleifen (oder eine Reihe von Schleifen? Im Allgemeinen eine großartige Idee) über die interne Struktur von PostgreSQL. <br><br>  Das Material basiert auf Verwaltungsschulungen, die wir mit Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">pluzanov durchführen</a> .  Nicht jeder sieht sich gerne ein Video an (ich mag es definitiv nicht), aber das Lesen von Folien, auch mit Kommentaren, ist völlig "falsch". <br><br>  Natürlich wiederholen die Artikel den Inhalt der Kurse nicht eins zu eins.  Ich werde nur darüber sprechen, wie alles funktioniert, wobei die Verwaltung selbst weggelassen wird, aber ich werde versuchen, dies detaillierter und detaillierter zu tun.  Und ich glaube, dass dieses Wissen für den Anwendungsentwickler nicht weniger nützlich ist als für den Administrator. <br><br>  Ich werde mich auf diejenigen konzentrieren, die bereits Erfahrung mit PostgreSQL haben, und mir zumindest allgemein vorstellen, was passiert.  Für Anfänger wird der Text etwas schwer sein.  Zum Beispiel werde ich kein Wort darüber sagen, wie man PostgreSQL installiert und psql ausführt. <br><br>  Dinge, die besprochen werden, ändern sich nicht viel von Version zu Version, aber ich werde das aktuelle 11. "Vanilla" PostgreSQL verwenden. <br><br>  Der erste Zyklus ist Fragen im Zusammenhang mit Isolation und Multiversion gewidmet und hat folgenden Plan: <br><br><ol><li>  Isolation im Sinne von Standard und PostgreSQL (dieser Artikel); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ebenen, Dateien, Seiten</a> - was passiert auf physischer Ebene? </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeilenversionen, virtuelle und verschachtelte Transaktionen</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenschnappschüsse und Sichtbarkeit von Zeilenversionen, Ereignishorizont</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In-Page-Reinigung und HOT-Updates</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Reinigung</a> (Vakuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatische Reinigung</a> (Autovakuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überlauf und Einfrieren des Transaktionszählers</a> . </li></ol><br>  Nun, lass uns gehen. <br><a name="habracut"></a><br><h1>  Was ist Isolierung und warum ist sie wichtig? </h1><br>  Wahrscheinlich weiß zumindest jeder über die Existenz von Transaktionen Bescheid, traf das Akronym ACID und hörte von Isolationsstufen.  Man muss sich aber immer noch der Meinung stellen, dass dies eine Theorie ist, die in der Praxis nicht notwendig ist.  Daher werde ich einige Zeit damit verbringen, zu erklären, warum dies wirklich wichtig ist. <br><br>  Es ist unwahrscheinlich, dass Sie sich freuen werden, wenn die Anwendung falsche Daten aus der Datenbank empfängt oder wenn die Anwendung falsche Daten in die Datenbank schreibt. <br><br>  Aber was sind "richtige" Daten?  Es ist bekannt, dass Sie auf Datenbankebene Integritätsbeschränkungen erstellen können (z. B. NOT NULL oder UNIQUE).  Wenn die Daten immer die Integritätsbedingungen erfüllen (und dies liegt daran, dass das DBMS dies garantiert), sind sie ganzheitlich. <br><br>  <em>Sind richtig</em> und <em>ganzheitlich</em> - dasselbe?  Nicht wirklich.  Nicht alle Einschränkungen können auf Datenbankebene formuliert werden.  Ein Teil der Einschränkungen ist zu kompliziert, z. B. werden mehrere Tabellen gleichzeitig abgedeckt.  Und selbst wenn die Einschränkung im Prinzip in der Datenbank definiert werden könnte, aber aus irgendeinem Grund nicht, bedeutet dies nicht, dass sie verletzt werden kann. <br><br>  <em>Korrektheit ist also</em> strenger als <em>Integrität</em> , aber wir wissen nicht genau, was es ist.  Es bleibt abzuwarten, dass der Standard der Korrektheit eine Anwendung ist, die, wie wir glauben wollen, <em>korrekt</em> geschrieben ist und niemals falsch ist.  In jedem Fall wird das DBMS nichts davon wissen und seine Hand nicht fangen, wenn die Anwendung nicht die Integrität, sondern die Richtigkeit verletzt. <br><br>  Von nun an nennen wir Korrektheit den Begriff Konsistenz. <br><br>  Nehmen wir jedoch an, dass die Anwendung nur die richtige Reihenfolge von Anweisungen ausführt.  Welche Rolle spielt das DBMS dann, wenn die Anwendung korrekt ist? <br><br>  Erstens stellt sich heraus, dass eine korrekte Folge von Anweisungen die Datenkonsistenz vorübergehend stören kann, und dies ist - seltsamerweise - normal.  Ein abgedroschenes, aber verständliches Beispiel ist die Überweisung von Geldern von einem Konto auf ein anderes.  Die Konsistenzregel mag folgendermaßen klingen: Eine <em>Überweisung ändert niemals den Gesamtbetrag auf Konten</em> (eine solche Regel ist als Integritätsbedingung in SQL nur schwer zu schreiben, daher existiert sie auf Anwendungsebene und ist für das DBMS unsichtbar).  Eine Überweisung besteht aus zwei Vorgängen: Der erste reduziert das Guthaben auf einem Konto, der zweite erhöht sich auf einem anderen.  Die erste Operation verletzt die Datenkonsistenz, die zweite - stellt wieder her. <br><br><blockquote>  Eine gute Übung besteht darin, die oben beschriebene Regel auf der Ebene der Integritätsbeschränkungen zu implementieren.  Bist du schwach  © <br></blockquote><br>  Was ist, wenn die erste Operation abgeschlossen ist und die zweite nicht?  Immerhin ist es einfach: Während der zweiten Operation kann Strom verloren gehen, der Server kann herunterfallen, es kann eine Division durch Null auftreten - aber Sie wissen es nie.  Es ist klar, dass die Konsistenz verletzt wird, und dies sollte nicht erlaubt sein.  Grundsätzlich ist es möglich, solche Situationen auf Anwendungsebene auf Kosten eines unglaublichen Aufwands zu lösen, aber zum Glück ist dies nicht erforderlich: Das DBMS kümmert sich darum.  Dafür muss sie jedoch wissen, dass zwei Operationen ein unteilbares Ganzes bilden.  Das ist eine <em>Transaktion</em> . <br><br>  Es stellt sich als interessant heraus: Da das DBMS weiß, dass Operationen eine Transaktion darstellen, hilft es, die Konsistenz aufrechtzuerhalten, indem es die Atomizität von Transaktionen garantiert, ohne etwas über bestimmte Konsistenzregeln zu wissen. <br><br>  Aber es gibt noch einen zweiten, subtileren Punkt.  Sobald mehrere gleichzeitige Transaktionen im System erscheinen, die nacheinander absolut korrekt sind, können sie zusammen falsch funktionieren.  Dies liegt an der Tatsache, dass die Reihenfolge der Operationen gemischt ist: Es kann nicht davon ausgegangen werden, dass alle Operationen einer Transaktion zuerst ausgeführt werden und erst dann alle Operationen einer anderen. <br><br>  Ein Hinweis zur Gleichzeitigkeit.  Gleichzeitig können Transaktionen auf einem System mit einem Mehrkernprozessor, einem Festplattenarray usw. ausgeführt werden. Für einen Server, der Befehle nacheinander im Time-Sharing-Modus ausführt, gelten jedoch dieselben Überlegungen: So viele Zyklen, eine Transaktion wird ausgeführt, so viele Zyklen sind unterschiedlich .  Manchmal wird der Begriff <em>Wettbewerbsausführung</em> verwendet, um zusammenzufassen. <br><br>  Situationen, in denen korrekte Transaktionen nicht korrekt zusammenarbeiten, werden als gleichzeitige Ausführungsanomalien bezeichnet. <br><br>  Ein einfaches Beispiel: Wenn eine Anwendung die richtigen Daten aus der Datenbank abrufen möchte, sollte sie zumindest keine Änderungen bei anderen nicht festgeschriebenen Transaktionen sehen.  Andernfalls können Sie nicht nur inkonsistente Daten abrufen, sondern auch etwas sehen, das noch nie in der Datenbank vorhanden war (wenn die Transaktion abgebrochen wird).  Diese Anomalie wird als <em>schmutziges Lesen bezeichnet</em> . <br><br>  Wenn es andere, komplexere Anomalien gibt, auf die wir etwas später eingehen werden. <br><br>  Natürlich ist es unmöglich, die gleichzeitige Ausführung abzulehnen. Welche Art von Aufführung kann sonst diskutiert werden?  Sie können jedoch nicht mit falschen Daten arbeiten. <br><br>  Und wieder kommt das DBMS zur Rettung.  Sie können Transaktionen <em>wie</em> nacheinander ausführen, <em>als ob sie</em> nacheinander ausgeführt würden.  Mit anderen Worten, <em>isoliert</em> voneinander.  In der Realität kann das DBMS Operationen gemischt ausführen, gleichzeitig aber sicherstellen, dass das Ergebnis der gleichzeitigen Ausführung mit dem Ergebnis einer der möglichen sequentiellen Ausführungen übereinstimmt.  Und das beseitigt mögliche Anomalien. <br><br>  Also kommen wir zur Definition: <br><br><blockquote>  Eine Transaktion ist der Satz von Operationen, die von einer Anwendung ausgeführt werden, die die Datenbank von einem korrekten Zustand in einen anderen korrekten Zustand überträgt (Konsistenz), vorausgesetzt, die Transaktion ist vollständig (Atomizität) und ohne Störung durch andere Transaktionen (Isolation). <br></blockquote><br>  Diese Definition kombiniert die ersten drei Buchstaben des Akronyms ACID.  Sie sind so eng miteinander verwandt, dass es einfach keinen Sinn macht, eins ohne das andere zu betrachten.  Tatsächlich ist es schwierig, den Buchstaben D (Haltbarkeit) abzureißen.  Schließlich bleiben im Falle eines Systemabsturzes Änderungen an nicht festgeschriebenen Transaktionen darin, mit denen Sie etwas tun müssen, um die Datenkonsistenz wiederherzustellen. <br><br>  Alles wäre in Ordnung, aber die Implementierung einer vollständigen Isolierung ist eine technisch schwierige Aufgabe, verbunden mit einer Verringerung des Systemdurchsatzes.  Daher wird in der Praxis sehr oft (nicht immer, aber fast immer) eine geschwächte Isolierung angewendet, die einige, aber nicht alle Anomalien verhindert.  Dies bedeutet, dass ein Teil der Arbeit zur Sicherstellung der Richtigkeit der Daten auf die Anwendung fällt.  Aus diesem Grund ist es sehr wichtig zu verstehen, welche Isolationsstufe im System verwendet wird, welche Garantien es gibt und welche nicht und wie der richtige Code unter solchen Bedingungen geschrieben wird. <br><br><h1>  SQL-Isolationsstufen und Anomalien </h1><br>  Der SQL-Standard hat lange Zeit vier Isolationsstufen beschrieben.  Diese Ebenen werden durch Auflisten der Anomalien ermittelt, die bei der Ausführung von Transaktionen auf dieser Ebene zulässig oder nicht zulässig sind.  Um über diese Ebenen zu sprechen, müssen Sie sich daher mit den Anomalien vertraut machen. <br><br>  Ich betone, dass wir in diesem Teil über den Standard sprechen, dh über eine bestimmte Theorie, auf die sich die Praxis stark stützt, die aber gleichzeitig im Widerspruch steht.  Daher sind alle Beispiele hier spekulativ.  Sie werden die gleichen Operationen auf Kundenkonten anwenden: Dies ist ziemlich offensichtlich, obwohl es zugegebenermaßen nichts damit zu tun hat, wie die Bankoperationen tatsächlich angeordnet sind. <br><br><h2>  Update verloren </h2><br>  Beginnen wir mit dem <em>verlorenen Update</em> .  Diese Anomalie tritt auf, wenn zwei Transaktionen dieselbe Zeile in der Tabelle lesen, dann eine Transaktion diese Zeile aktualisiert und danach auch die zweite Transaktion dieselbe Zeile aktualisiert, ohne die durch die erste Transaktion vorgenommenen Änderungen zu berücksichtigen. <br><br>  Beispielsweise erhöhen zwei Transaktionen den Betrag auf demselben Konto um 100 ₽.  Die erste Transaktion liest den aktuellen Wert (1000 ₽), dann liest die zweite Transaktion den gleichen Wert.  Die erste Transaktion erhöht den Betrag (es stellt sich heraus, 1100 ₽) und schreibt diesen Wert.  Die zweite Transaktion macht das Gleiche - bekommt die gleichen 1.100 ₽ und schreibt sie.  Infolgedessen verlor der Kunde 100 ₽. <br><br>  Verlorene Updates sind vom Standard auf keiner Isolationsstufe zulässig. <br><br><h2>  Dirty Reading und Read Uncommitted </h2><br>  Mit <em>schmutzigem Lesen haben</em> wir uns oben schon getroffen.  Diese Anomalie tritt auf, wenn eine Transaktion ausstehende Änderungen liest, die von einer anderen Transaktion vorgenommen wurden. <br><br>  Bei der ersten Transaktion wird beispielsweise das gesamte Geld vom Konto des Kunden auf ein anderes Konto übertragen, die Änderung wird jedoch nicht erfasst.  Eine andere Transaktion liest den Kontostatus, erhält 0 ₽ und weigert sich, Bargeld an den Kunden auszugeben - trotz der Tatsache, dass die erste Transaktion unterbrochen wird und ihre Änderungen abbricht, sodass der Wert 0 nie in der Datenbank vorhanden war. <br><br>  Das fehlerhafte Lesen ist nach dem Standard auf der Ebene "Nicht festgeschrieben" zulässig. <br><br><h2>  Nicht wiederholtes Lesen und Lesen festgeschrieben </h2><br>  Die <em>nicht wiederholte</em> Leseanomalie tritt auf, wenn eine Transaktion dieselbe Zeile zweimal liest und in dem Intervall zwischen den Lesevorgängen die zweite Transaktion diese Zeile ändert (oder löscht) und die Änderungen festschreibt.  Dann erhält die erste Transaktion unterschiedliche Ergebnisse. <br><br>  Lassen Sie beispielsweise die Konsistenzregel <em>negative Beträge in Kundenkonten verbieten</em> .  Bei der ersten Transaktion wird der Betrag auf dem Konto um 100 reduce reduziert.  Sie überprüft den aktuellen Wert, erhält 1000 ₽ und entscheidet, dass eine Reduzierung möglich ist.  Zu diesem Zeitpunkt reduziert die zweite Transaktion den Betrag auf dem Konto auf Null und zeichnet die Änderungen auf.  Wenn nun die erste Transaktion den Betrag erneut prüfte, würde sie 0 ₽ erhalten (aber sie hatte bereits beschlossen, den Wert zu verringern, und das Konto geht auf Minus). <br><br>  Nicht wiederholtes Lesen ist nach dem Standard auf den Ebenen Read Uncommitted und Read Committed zulässig.  Aber schmutziges Lesen Read Committed erlaubt nicht. <br><br><h2>  Phantom Read und wiederholbares Lesen </h2><br>  <em>Das Phantomlesen</em> tritt auf, wenn eine Transaktion einen Satz von Zeilen unter derselben Bedingung zweimal liest, und in dem Intervall zwischen den Lesevorgängen fügt die zweite Transaktion Zeilen hinzu, die diese Bedingung erfüllen (und die Änderungen festschreiben).  Dann erhält die erste Transaktion verschiedene Zeilensätze. <br><br>  Angenommen, eine Konsistenzregel <em>verhindert, dass ein Kunde mehr als drei Konten hat</em> .  Die erste Transaktion eröffnet ein neues Konto, überprüft die aktuelle Nummer (z. B. 2) und entscheidet, dass eine Eröffnung möglich ist.  Zu diesem Zeitpunkt eröffnet die zweite Transaktion auch ein neues Konto für den Kunden und zeichnet die Änderungen auf.  Wenn nun die erste Transaktion die Menge doppelt prüft, erhält sie 3 (aber sie eröffnet bereits ein anderes Konto und der Kunde hat 4 davon). <br><br>  Das Lesen von Phantomen ist standardmäßig in den Stufen Read Uncommitted, Read Committed und Repeatable Read zulässig.  Auf der Ebene Wiederholbares Lesen ist nicht wiederholtes Lesen jedoch nicht zulässig. <br><br><h2>  Mangel an Anomalien und serialisierbar </h2><br>  Der Standard definiert eine andere Ebene - serialisierbar - auf der keine Anomalien zulässig sind.  Und dies ist keineswegs gleichbedeutend mit einem Verbot eines verlorenen Updates und einem schmutzigen, sich nicht wiederholenden und Phantom-Lesen. <br><br>  Tatsache ist, dass es deutlich mehr bekannte Anomalien als die im Standard aufgeführten gibt und eine unbekannte Anzahl noch unbekannt ist. <br><br>  Serialisierbar sollte <em>generell alle</em> Anomalien verhindern.  Dies bedeutet, dass der Anwendungsentwickler auf dieser Ebene nicht daran denken muss, gleichzeitig ausgeführt zu werden.  Wenn Transaktionen die richtigen Abfolgen von Anweisungen ausführen und alleine arbeiten, stimmen die Daten mit dem gleichzeitigen Betrieb dieser Transaktionen überein. <br><br><h2>  Zusammenfassungsschild </h2><br>  Jetzt können Sie jedem einen bekannten Tisch bringen.  Aus Gründen der Übersichtlichkeit wird hier jedoch die letzte Spalte hinzugefügt, die nicht im Standard enthalten ist. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  verlorene Änderungen </th><th>  schmutziges Lesen </th><th>  nicht wiederholtes Lesen </th><th>  Phantomlesung </th><th>  andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br><h2>  Warum genau diese Anomalien? </h2><br>  Warum sind nur einige der vielen möglichen Anomalien im Standard aufgeführt und warum sind dies? <br><br>  Anscheinend scheint das niemand mit Sicherheit zu wissen.  Aber die Praxis hier hat definitiv die Theorie überholt, so dass es möglich ist, dass wir dann nicht über andere Anomalien nachgedacht haben (Rede über den SQL-Standard: 92). <br><br>  Außerdem wurde angenommen, dass die Isolierung auf Verriegelungen aufgebaut sein sollte.  Die Idee des weit verbreiteten <em>Zwei-Phasen-Blockierungsprotokolls</em> (2PL) ist, dass die Transaktion während der Transaktion die Leitungen blockiert, mit denen sie arbeitet, und nach Abschluss die Sperren aufhebt.  Je mehr Sperren eine Transaktion erfasst, desto besser ist sie von anderen Transaktionen isoliert.  Die Leistung des Systems leidet jedoch noch mehr, da Transaktionen nicht mehr zusammenarbeiten, sondern für dieselben Zeilen ausgerichtet werden. <br><br>  Es scheint mir, dass der Unterschied zwischen den Isolationsstufen des Standards genau durch die Anzahl der erforderlichen Sperren erklärt wird. <br><br>  Wenn eine Transaktion das Ändern, aber nicht das Lesen geänderter Zeilen blockiert, erhalten wir die Stufe "Nicht festgeschrieben lesen": Verlorene Änderungen sind nicht zulässig, aber nicht festgeschriebene Daten können gelesen werden. <br><br>  Wenn die Transaktion das Lesen und Ändern von veränderlichen Zeilen blockiert, erhalten wir die Stufe Read Committed: Sie können keine nicht festgeschriebenen Daten lesen, aber wenn Sie erneut auf die Zeile zugreifen, können Sie einen anderen Wert erhalten (nicht wiederholtes Lesen). <br><br>  Wenn eine Transaktion sowohl lesbare als auch veränderbare Zeilen vom Lesen und Ändern blockiert, erhalten wir die Stufe Wiederholbares Lesen: Durch wiederholtes Lesen der Zeile wird der gleiche Wert erzeugt. <br><br>  Bei Serializable gibt es jedoch ein Problem: Es ist nicht möglich, eine noch nicht vorhandene Zeile zu sperren.  Aus diesem Grund bleibt die Möglichkeit des Phantomlesens bestehen: Eine andere Transaktion kann eine Zeile hinzufügen (aber nicht löschen), die unter die Bedingungen einer zuvor ausgeführten Abfrage fällt, und diese Zeile wird erneut abgerufen. <br><br>  Daher reichen gewöhnliche Sperren nicht aus, um die Ebene der Serialisierbarkeit zu implementieren. Sie müssen nicht die Zeilen, sondern die Bedingungen (Prädikate) blockieren.  Solche Sperren wurden <em>Prädikate genannt</em> .  Sie wurden bereits 1976 vorgeschlagen, aber ihre praktische Anwendbarkeit wird durch relativ einfache Bedingungen eingeschränkt, für die klar ist, wie zwei verschiedene Prädikate kombiniert werden können.  Soweit ich weiß, ist es in keinem System zur Implementierung solcher Sperren gekommen. <br><br><h1>  PostgreSQL-Isolationsstufen </h1><br>  Im Laufe der Zeit ersetzte Snapshot Isolation die blockierenden Transaktionsverwaltungsprotokolle.  Seine Idee ist, dass jede Transaktion zu einem bestimmten Zeitpunkt mit einem konsistenten Snapshot der Daten arbeitet, bei dem nur die Änderungen fallen, die vor der Erstellung des Snapshots aufgezeichnet wurden. <br><br>  Eine solche Isolierung ermöglicht nicht automatisch ein schmutziges Lesen.  Formal können Sie in PostgreSQL die Stufe Read Uncommitted angeben, dies funktioniert jedoch genauso wie Read Committed.  Daher werden wir nicht weiter über die Stufe "Nicht festgeschrieben lesen" sprechen. <br><br>  PostgreSQL implementiert eine <em>Mehrfachversion</em> dieses Protokolls.  Die Idee der Mehrfachversionierung besteht darin, dass mehrere Versionen derselben Zeichenfolge in einem DBMS gleichzeitig vorhanden sein können.  Auf diese Weise können Sie mit den verfügbaren Versionen einen Snapshot der Daten erstellen und mit einem Minimum an Sperren auskommen.  Tatsächlich werden nur wiederholte Änderungen an derselben Zeile blockiert.  Alle anderen Vorgänge werden gleichzeitig ausgeführt: Das Schreiben von Transaktionen blockiert niemals das Lesen von Transaktionen, und das Lesen von Transaktionen blockiert niemals jemanden. <br><br>  Bei Verwendung von Daten-Snapshots ist die Isolation in PostgreSQL strenger als es der Standard erfordert: Die Stufe "Wiederholbares Lesen" ermöglicht nicht nur nicht wiederholte, sondern auch Phantom-Lesevorgänge (obwohl sie keine vollständige Isolation bietet).  Und das ohne Wirkungsverlust. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  verlorene Änderungen </th><th>  schmutziges Lesen </th><th>  nicht wiederholtes Lesen </th><th>  Phantomlesung </th><th>  andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br>  Wie Multi-Versioning „unter der Haube“ implementiert wird, werden wir in den folgenden Artikeln besprechen und nun jede der drei Ebenen mit den Augen des Benutzers detailliert betrachten (wie Sie wissen, verbirgt sich das Interessanteste hinter „anderen Anomalien“).  Erstellen Sie dazu eine Kontenliste.  Alice und Bob haben jeweils 1.000 US-Dollar, aber Bob hat zwei offene Konten: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Lesen Sie verpflichtet </h2><br><h3>  Mangel an schmutzigem Lesen </h3><br>  Es ist leicht zu überprüfen, ob verschmutzte Daten nicht gelesen werden können.  Beginnen wir mit der Transaktion.  Standardmäßig wird die Isolationsstufe Read Committed verwendet: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Genauer gesagt wird der Standardpegel durch den Parameter festgelegt und kann bei Bedarf geändert werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Bei einer offenen Transaktion ziehen wir also Geld vom Konto ab, erfassen die Änderungen jedoch nicht.  Die Transaktion sieht ihre eigenen Änderungen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  In der zweiten Sitzung starten wir eine weitere Transaktion mit derselben Read Committed-Ebene.  Um zwischen verschiedenen Transaktionen zu unterscheiden, werden die Befehle der zweiten Transaktion eingerückt und durchgestrichen. <br><br>  Um die obigen Befehle zu wiederholen (was nützlich ist), müssen Sie zwei Terminals öffnen und jeweils psql ausführen.  Im ersten können Sie die Befehle einer Transaktion eingeben und im zweiten die Befehle einer anderen. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Wie erwartet werden bei einer anderen Transaktion keine nicht festgeschriebenen Änderungen angezeigt - Dirty Reading ist nicht zulässig. <br><br><h3>  Nicht wiederholtes Lesen </h3><br>  Lassen Sie nun die erste Transaktion die Änderungen festschreiben und die zweite dieselbe Anforderung erneut ausführen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die Anforderung empfängt bereits neue Daten - dies ist die Anomalie des <em>nicht wiederholten Lesens</em> , die auf der Ebene Read Committed zulässig ist. <br><br>  <em>Praktische Schlussfolgerung</em> : In einer Transaktion ist es unmöglich, Entscheidungen auf der Grundlage der von der vorherigen Anweisung gelesenen Daten zu treffen, da sich zwischen den Ausführungszeiten der Anweisungen alles ändern kann.  Hier ist ein Beispiel, dessen Variationen im Anwendungscode so häufig sind, dass es sich um ein klassisches Antimuster handelt: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Während der Zeit zwischen Überprüfung und Aktualisierung können andere Transaktionen den Status des Kontos wie gewünscht ändern, sodass bei einer solchen „Überprüfung“ nichts gespeichert wird.  Man kann sich leicht vorstellen, dass zwischen den Betreibern einer Transaktion alle anderen Betreiber anderer Transaktionen beispielsweise „keilen“ können: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Wenn Sie beim Neuanordnen der Operatoren alles ruinieren können, ist der Code falsch geschrieben.  Und täuschen Sie sich nicht, dass eine solche Kombination von Umständen nicht eintreten wird - es wird passieren. <br><br>  Wie schreibe ich den Code richtig?  Chancen beschränken sich in der Regel auf Folgendes: <br><br><ul><li>  Schreiben Sie keinen Code. <br>  Das ist kein Scherz.  In diesem Fall wird die Prüfung beispielsweise leicht zu einer Integritätsbeschränkung: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Jetzt sind keine Überprüfungen mehr erforderlich: Es reicht aus, die Aktion einfach auszuführen und gegebenenfalls die Ausnahme zu behandeln, die im Falle eines Versuchs, die Integrität zu verletzen, auftritt. <br></li><li>  Verwenden Sie eine einzelne SQL-Anweisung. <br>  Konsistenzprobleme entstehen aufgrund der Tatsache, dass im Intervall zwischen Operatoren eine andere Transaktion enden kann und sich die sichtbaren Daten ändern.  Und wenn es nur einen Operator gibt, gibt es keine Lücken. <br>  PostgreSQL verfügt über genügend Tools, um komplexe Probleme mit einer einzigen SQL-Anweisung zu lösen.  Wir beachten die allgemeinen Tabellenausdrücke (CTE), in denen Sie unter anderem die Anweisungen INSERT / UPDATE / DELETE sowie die Anweisung INSERT ON CONFLICT verwenden können, die die Logik "Einfügen und, wenn bereits eine Zeile vorhanden ist, aktualisieren" in einer Anweisung implementiert. <br></li><li>  Benutzersperren. <br>  Der letzte Ausweg besteht darin, manuell eine exklusive Sperre entweder für alle erforderlichen Zeilen (SELECT FOR UPDATE) oder für die gesamte Tabelle (LOCK TABLE) festzulegen.  Dies funktioniert immer, negiert jedoch die Vorteile der Mehrfachversionierung: Anstatt gleichzeitig ausgeführt zu werden, wird ein Teil der Vorgänge nacheinander ausgeführt. <br></li></ul><br><h3>  Inkonsistentes Lesen </h3><br>  Bevor man sich auf die nächste Stufe der Isolation begibt, muss man zugeben, dass nicht alles so einfach ist.  Die Implementierung von PostgreSQL ist so, dass andere, weniger bekannte Anomalien berücksichtigt werden, die nicht durch den Standard geregelt sind. <br><br>  Angenommen, mit der ersten Transaktion wurde Geld von einem Bob-Konto auf ein anderes übertragen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Zu diesem Zeitpunkt berechnet eine andere Transaktion den Saldo von Bob, wobei die Berechnung in einem Zyklus für alle Konten von Bob durchgeführt wird.  Tatsächlich beginnt die Transaktion mit dem ersten Konto (und sieht offensichtlich den vorherigen Status): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Zu diesem Zeitpunkt wird die erste Transaktion erfolgreich abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und der andere liest den Status des zweiten Kontos (und sieht bereits einen neuen Wert): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Somit erhielt die zweite Transaktion insgesamt 1100 ₽, dh falsche Daten.  Dies ist eine Anomalie des <em>inkonsistenten Lesens</em> . <br><br>  Wie kann man eine solche Anomalie vermeiden, indem man bei Read Committed bleibt?  Verwenden Sie natürlich einen Operator.  Zum Beispiel so: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Bisher habe ich argumentiert, dass sich die Sichtbarkeit von Daten nur zwischen Betreibern ändern kann, aber ist das so offensichtlich?  Und wenn die Anforderung für eine lange Zeit ausgeführt wird, kann sie einen Teil der Daten in einem Zustand und einen Teil in einem anderen sehen? <br><br>  Schau es dir an.  Eine bequeme Möglichkeit, dies zu tun, besteht darin, eine künstliche Verzögerung in den Operator einzufügen, indem die Funktion pg_sleep aufgerufen wird.  Sein Parameter legt die Verzögerungszeit in Sekunden fest. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Während dieser Bauarbeiten überweisen wir bei einer anderen Transaktion Geld zurück: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Das Ergebnis zeigt, dass der Bediener die Daten in dem Zustand sieht, in dem sie sich zum Zeitpunkt des Starts befanden.  Das ist sicherlich richtig. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Aber hier ist es nicht so einfach.  Mit PostgreSQL können Sie Funktionen definieren, während Funktionen das Konzept einer <em>Variabilitätskategorie haben</em> .  Wenn eine <em>flüchtige</em> Funktion (mit der Kategorie VOLATILE) in einer Anforderung aufgerufen wird und eine andere Anforderung in dieser Funktion ausgeführt wird, werden bei dieser Anforderung innerhalb der Funktion Daten angezeigt, die nicht mit den Daten der Hauptanforderung übereinstimmen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  In diesem Fall erhalten wir falsche Daten - 100 ₽ gehen verloren: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Ich betone, dass ein solcher Effekt nur auf der Isolationsstufe Read Committed und nur auf der Variabilitätskategorie VOLATILE möglich ist.  Das Problem ist, dass diese Isolationsstufe und diese Kategorie von Variabilität standardmäßig verwendet werden, also muss ich zugeben - der Rechen liegt sehr gut.  Nicht treten! <br><br><h3>  Inkonsistentes Lesen im Austausch für verlorene Änderungen </h3><br>  Ein inkonsistenter Messwert im Rahmen eines Operators kann - auf etwas unerwartete Weise - während eines Updates erhalten werden. <br><br>  Mal sehen, was passiert, wenn Sie versuchen, dieselbe Zeile mit zwei Transaktionen zu ändern.  Bob hat jetzt 1000 ₽ auf zwei Konten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Wir starten eine Transaktion, die Bobs Guthaben reduziert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Gleichzeitig fallen für eine andere Transaktion Zinsen auf alle Kundenkonten mit einem Gesamtguthaben von mindestens 1000 ₽ an: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  Das Ausführen einer UPDATE-Anweisung besteht aus zwei Teilen.  Zunächst wird tatsächlich ein SELECT ausgeführt, das die Zeilen auswählt, die der Bedingung für die Aktualisierung entsprechen.  Da die Änderung der ersten Transaktion nicht festgelegt ist, kann die zweite Transaktion sie nicht sehen und hat keinen Einfluss auf die Auswahl der Zeilen für die Zinsberechnung.  Bobs Konten fallen also unter die Bedingung und nach Abschluss des Updates sollte sich sein Kontostand um 10 increase erhöhen. <br><br>  Die zweite Ausführungsstufe - Die ausgewählten Zeilen werden nacheinander aktualisiert.  Hier wird die zweite Transaktion zum "Einfrieren" gezwungen, da die Zeilen-ID = 3 bereits von der ersten Transaktion gesperrt ist. <br><br>  In der Zwischenzeit werden bei der ersten Transaktion die Änderungen festgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Was wird das Ergebnis sein? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Ja, einerseits sollte der Befehl UPDATE keine Änderungen in der zweiten Transaktion sehen.  Andererseits sollten die in der zweiten Transaktion aufgezeichneten Änderungen nicht verloren gehen. <br><br>  Nachdem die Sperre aufgehoben wurde, liest UPDATE die Zeile, die aktualisiert werden soll, erneut (aber nur eine!).  Das Ergebnis ist, dass Bob 9 ₽ angesammelt hat, basierend auf dem Betrag von 900 ₽.  Aber wenn Bob 900 had hätte, hätten seine Konten überhaupt nicht in die Stichprobe aufgenommen werden dürfen. <br><br>  Die Transaktion empfängt also falsche Daten: Einige der Zeilen sind zu einem bestimmten Zeitpunkt sichtbar, andere zum anderen.  Anstelle eines verlorenen Updates erhalten wir erneut eine Anomalie beim <em>inkonsistenten Lesen</em> . <br><br><blockquote>  Aufmerksame Leser stellen fest, dass Sie mit Hilfe der Anwendung auf der Ebene "Read Committed" ein verlorenes Update erhalten können.  Zum Beispiel so: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Die Datenbank ist nicht schuld: Sie empfängt zwei SQL-Anweisungen und weiß nichts, dass der Wert von x + 100 in irgendeiner Weise mit accounts.amount zusammenhängt.  Schreiben Sie keinen Code auf diese Weise. <br></blockquote><br><h2>  Wiederholbares Lesen </h2><br><h3>  Mangel an nicht wiederholenden und Phantomablesungen </h3><br>  Der Name der Isolationsstufe selbst zeigt an, dass der Messwert wiederholbar ist.  Wir werden dies überprüfen und gleichzeitig davon überzeugt sein, dass keine Phantomwerte vorliegen.  Setzen Sie dazu in der ersten Transaktion die Konten von Bob auf den vorherigen Status zurück und erstellen Sie ein neues Konto für Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  In der zweiten Sitzung starten wir die Transaktion mit der Ebene Wiederholbares Lesen, die im Befehl BEGIN angegeben wird (die Ebene der ersten Transaktion ist nicht wichtig). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Jetzt schreibt die erste Transaktion die Änderungen fest und die zweite führt dieselbe Anforderung erneut aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Bei der zweiten Transaktion werden weiterhin genau dieselben Daten wie zu Beginn angezeigt: Es sind weder Änderungen an vorhandenen noch neue Zeilen sichtbar. <br><br>  Auf dieser Ebene müssen Sie sich keine Sorgen machen, dass sich zwischen den beiden Operatoren etwas ändert. <br><br><h3>  Serialisierungsfehler im Austausch für verlorene Änderungen </h3><br>  Wir haben oben gesagt, dass beim Aktualisieren derselben Zeile mit zwei Transaktionen auf der Ebene "Read Committed" eine Anomalie des inkonsistenten Lesens auftreten kann.  Dies liegt an der Tatsache, dass die ausstehende Transaktion die gesperrte Zeile erneut liest und sie daher nicht zum gleichen Zeitpunkt wie die übrigen Zeilen sieht. <br><br>  Auf der Ebene "Wiederholbares Lesen" ist eine solche Anomalie nicht zulässig. Wenn sie dennoch auftritt, kann nichts unternommen werden. Daher endet die Transaktion mit einem Serialisierungsfehler.  Wir überprüfen dies, indem wir dasselbe Szenario mit Prozentsätzen wiederholen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Daten blieben konsistent: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  Der gleiche Fehler tritt bei jeder anderen Änderung der Wettbewerbszeile auf, auch wenn sich die für uns interessanten Spalten nicht tatsächlich geändert haben. <br><br>  <em>Praktische Schlussfolgerung</em> : Wenn die Anwendung die Isolationsstufe Wiederholbares Lesen zum Schreiben von Transaktionen verwendet, sollte sie bereit sein, Transaktionen zu wiederholen, die mit einem Serialisierungsfehler endeten.  Bei schreibgeschützten Transaktionen ist ein solches Ergebnis nicht möglich. <br><br><h3>  Inkonsistenter Eintrag </h3><br>  In PostgreSQL werden auf der Isolationsstufe von Repeatable Read alle im Standard beschriebenen Anomalien verhindert.  Aber überhaupt nicht.  Es stellt sich heraus, dass <em>genau zwei</em> Anomalien möglich bleiben.  (Dies gilt nicht nur für PostgreSQL, sondern auch für andere Snapshot-basierte Isolationsimplementierungen.) <br><br>  Die erste dieser Anomalien ist eine <em>inkonsistente Aufzeichnung</em> . <br><br>  Lassen Sie diese Konsistenzregel gelten: <em>Negative Beträge sind auf den Konten des Kunden zulässig, wenn der Gesamtbetrag auf allen Konten dieses Kunden nicht negativ bleibt</em> . <br><br>  Die erste Transaktion erhält den Betrag auf Bobs Konten: 900 ₽. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  Die zweite Transaktion erhält den gleichen Betrag. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  Die erste Transaktion geht zu Recht davon aus, dass der Betrag eines der Konten um 600 reduced reduziert werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Und die zweite Transaktion kommt zu dem gleichen Ergebnis.  Reduziert aber eine andere Punktzahl: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Wir haben es geschafft, Bobs Saldo auf Minus zu bringen, obwohl jede der Transaktionen einzeln korrekt funktioniert. <br><br><h3>  Schreibgeschützte Anomalie </h3><br>  Dies ist die zweite und letzte der Anomalien, die auf der Ebene des wiederholbaren Lesens möglich sind.  Um dies zu demonstrieren, benötigen Sie drei Transaktionen, von denen zwei die Daten ändern und die dritte - nur lesbar. <br><br>  Stellen Sie jedoch zuerst den Kontostatus von Bob wieder her: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Bei der ersten Transaktion werden Bob Zinsen für den Geldbetrag auf allen Konten berechnet.  Die Zinsen werden einem seiner Konten gutgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Dann zieht eine andere Transaktion Geld von einem anderen Konto von Bob ab und erfasst seine Änderungen: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Wenn zu diesem Zeitpunkt die erste Transaktion festgeschrieben wird, liegt keine Anomalie vor: Wir können davon ausgehen, dass die erste Transaktion zuerst und dann die zweite abgeschlossen wurde (aber nicht umgekehrt, da bei der ersten Transaktion der Status der Konto-ID = 3 vor diesem Konto angezeigt wurde geändert durch die zweite Transaktion). <br><br>  Angenommen, in diesem Moment beginnt die dritte (schreibgeschützte) Transaktion, die den Status eines Kontos liest, das von den ersten beiden Transaktionen nicht betroffen ist: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Und erst danach ist die erste Transaktion abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Welchen Status sollte die dritte Transaktion jetzt sehen? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Nach dem Start konnte bei der dritten Transaktion Änderungen in der zweiten Transaktion (die bereits festgeschrieben wurde) angezeigt werden, nicht jedoch in der ersten Transaktion (die noch nicht festgeschrieben wurde).  Andererseits haben wir oben bereits festgestellt, dass die zweite Transaktion nach der ersten begonnen haben sollte.  Welchen Status die dritte Transaktion auch sieht, sie ist inkonsistent - dies ist die Anomalie nur der Lesetransaktion.  Auf der Ebene Wiederholbares Lesen ist jedoch Folgendes zulässig: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serialisierbar </h2><br>  Auf der Ebene Serializable werden alle möglichen Anomalien verhindert.  Tatsächlich wird Serializable als Add-In für die Isolation basierend auf Datenschnappschüssen implementiert.  Diejenigen Anomalien, die während des wiederholbaren Lesens nicht auftreten (z. B. schmutziges, nicht wiederholbares Phantom-Lesen), treten auf der Ebene von Serializable nicht auf.  Und die auftretenden Anomalien (inkonsistente Aufzeichnung und Anomalie nur der Lesetransaktion) werden erkannt und die Transaktion wird abgebrochen - der bereits bekannte Serialisierungsfehler konnte den Zugriff nicht serialisieren. <br><br><h3>  Inkonsistenter Eintrag </h3><br>  Zur Veranschaulichung wiederholen wir das Szenario mit einer Anomalie inkonsistenter Aufzeichnung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Neben der Ebene "Wiederholbares Lesen" muss eine Anwendung, die die Isolationsstufe "Serialisierbar" verwendet, Transaktionen wiederholen, die zu einem Serialisierungsfehler geführt haben, der uns auch durch den Hinweis in der Fehlermeldung gemeldet wird. <br><br>  Wir erhalten die Einfachheit der Programmierung, aber der Preis dafür ist die erzwungene Aufschlüsselung eines bestimmten Anteils von Transaktionen und die Notwendigkeit, diese zu wiederholen.  Die ganze Frage ist natürlich, wie groß dieser Anteil ist.  Wenn nur die Transaktionen beendet würden, die sich in Daten wirklich inkompatibel mit anderen Transaktionen überschneiden, wäre alles schön.  Eine solche Implementierung würde sich jedoch unweigerlich als ressourcenintensiv und ineffizient herausstellen, da sie den Betrieb mit jeder Zeile verfolgen müsste. <br><br>  Tatsächlich ist die Implementierung von PostgreSQL so, dass falsch negative Auslöser zugelassen werden: Einige völlig normale Transaktionen, die einfach „kein Glück haben“, werden abgebrochen.  Wie wir später sehen werden, hängt dies von vielen Gründen ab, beispielsweise von der Verfügbarkeit geeigneter Indizes oder der verfügbaren RAM-Menge.  Darüber hinaus gibt es einige andere (ziemlich schwerwiegende) Implementierungsbeschränkungen, z. B. funktionieren Anforderungen auf serialisierbarer Ebene nicht für Replikate, parallele Ausführungspläne werden für sie nicht verwendet.  Und obwohl die Arbeit zur Verbesserung der Umsetzung nicht aufhört, verringern die bestehenden Beschränkungen die Attraktivität dieser Isolationsstufe. <br><blockquote>  Parallele Pläne werden in PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> .  Und Anfragen zu Replikaten können in PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem weiteren Patch</a> ) verdient werden. <br></blockquote><br><h3>  Schreibgeschützte Anomalie </h3><br>  Damit nur eine Lesetransaktion nicht zu einer Anomalie führen und nicht darunter leiden kann, bietet PostgreSQL einen interessanten Mechanismus: Eine solche Transaktion kann blockiert werden, bis ihre Ausführung sicher ist.  Dies ist der einzige Fall, in dem eine SELECT-Anweisung durch Zeilenaktualisierungen blockiert werden kann.  So sieht es aus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Die dritte Transaktion wird ausdrücklich nur vom Leser deklariert (NUR LESEN) und zurückgestellt (DEFERRABLE): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Wenn Sie versuchen, eine Anforderung auszuführen, wird die Transaktion blockiert, da ihre Ausführung sonst zu einer Anomalie führt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und erst nachdem die erste Transaktion festgeschrieben wurde, wird die dritte weiter ausgeführt: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Ein weiterer wichtiger Hinweis: Wenn die serialisierbare Isolation verwendet wird, müssen alle Transaktionen in der Anwendung diese Ebene verwenden.  Sie können Read Committed (oder Repeatable Read) -Transaktionen nicht mit Serializable mischen.  Das heißt, Sie können etwas mischen, aber dann verhält sich Serializable wie ein wiederholbarer Lesevorgang ohne Vorwarnung.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum dies geschieht, werden wir später betrachten, wenn wir über die Implementierung sprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich also für Serializble entscheiden, ist es am besten, die Standardstufe global festzulegen (obwohl dies natürlich nicht die explizite Angabe der falschen Stufe verbietet):</font></font><br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine genauere Darstellung von Fragen im Zusammenhang mit Transaktionen, Konsistenz und Anomalien findet sich in </font><font style="vertical-align: inherit;">Boris Asenovich Novikovs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buch-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorlesungskurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Fundamentals of Database Technologies".</font></font><br></blockquote><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Welchen Isolationsgrad sollte ich verwenden? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Read Committed-Isolationsstufe wird in PostgreSQL standardmäßig verwendet, und es scheint, dass diese Stufe in der überwiegenden Mehrheit der Anwendungen verwendet wird. Es ist zweckmäßig, dass eine Transaktionsunterbrechung nur im Fehlerfall möglich ist, nicht aber um Inkonsistenzen zu vermeiden. Mit anderen Worten, ein Serialisierungsfehler kann nicht auftreten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kehrseite der Münze ist die große Anzahl möglicher Anomalien, die oben ausführlich erörtert wurden. Der Entwickler muss sie ständig im Auge behalten und Code so schreiben, dass ihr Auftreten verhindert wird. Wenn es nicht möglich ist, die erforderlichen Aktionen in einer einzelnen SQL-Anweisung zu formulieren, müssen Sie explizit Sperren setzen. Das Unangenehmste ist, dass der Code schwer auf Fehler beim Abrufen inkonsistenter Daten zu testen ist und die Fehler selbst auf unvorhersehbare und nicht reproduzierbare Weise auftreten können und daher schwer zu beheben sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Isolationsstufe von Repeatable Read beseitigt einige der Probleme der Inkonsistenz, aber leider nicht alle. Daher müssen Sie sich nicht nur die verbleibenden Anomalien merken, sondern auch die Anwendung so ändern, dass Serialisierungsfehler korrekt verarbeitet werden. Dies ist natürlich unpraktisch. Bei schreibgeschützten Transaktionen ergänzt diese Ebene jedoch perfekt Read Committed und ist beispielsweise sehr praktisch, um Berichte zu erstellen, die mehrere SQL-Abfragen verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich macht die serialisierbare Ebene die Notwendigkeit von Inkonsistenzen überflüssig und erleichtert das Schreiben von Code erheblich. </font><font style="vertical-align: inherit;">Die Anwendung muss lediglich alle Transaktionen wiederholen können, wenn ein Serialisierungsfehler auftritt. </font><font style="vertical-align: inherit;">Der Anteil unterbrochener Transaktionen, der zusätzliche Overhead und die Unfähigkeit, Anforderungen zu parallelisieren, können jedoch den Systemdurchsatz erheblich reduzieren. </font><font style="vertical-align: inherit;">Beachten Sie außerdem, dass die serialisierbare Ebene nicht auf Replikate anwendbar ist und nicht mit anderen Isolationsstufen gemischt werden kann. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung folgt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442804/">https://habr.com/ru/post/de442804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442790/index.html">Die Registrierung für das Allure Server Meetup in St. Petersburg ist offen</a></li>
<li><a href="../de442794/index.html">Wir laden Sie zur Konferenz „(IT) Architekt in IT-Projekten und -Organisationen“ ein.</a></li>
<li><a href="../de442796/index.html">Umfrage: Cloud-Technologien in GIS- und Geodatendiensten</a></li>
<li><a href="../de442798/index.html">Das Überwachen von Pings zwischen Kubernetes-Hosts ist unser Rezept</a></li>
<li><a href="../de442800/index.html">Einfacher Telegramm-Bot in Python in 30 Minuten</a></li>
<li><a href="../de442806/index.html">Das vorläufige DUMP-2019-Programm ist fertig. Sprecher von Evil Martians, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../de442808/index.html">Wir laden Sie zur Droid Party ein - einem Treffen, das sich praktischen Fragen der Entwicklung von Android-Anwendungen und -Geräten widmet</a></li>
<li><a href="../de442810/index.html">Mythen der Populärphysik, Fortsetzung: Schwerkraft</a></li>
<li><a href="../de442812/index.html">"Ich sehe keinen Grund, Python für die Arbeit mit Spark zu verwenden, außer Faulheit."</a></li>
<li><a href="../de442814/index.html">10 Jahre sind vergangen und niemand hat herausgefunden, wie man die Blockchain benutzt. Und wieder hier?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>