<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöà üåë üôãüèæ MVCC-1. Isolierung üë©üèª‚Äçü§ù‚Äçüë®üèΩ üïï üëª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Mit diesem Artikel beginne ich eine Reihe von Schleifen (oder eine Reihe von Schleifen? Im Allgemeinen eine gro√üartige Idee) √ºber die inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-1. Isolierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442804/">  Hallo Habr!  Mit diesem Artikel beginne ich eine Reihe von Schleifen (oder eine Reihe von Schleifen? Im Allgemeinen eine gro√üartige Idee) √ºber die interne Struktur von PostgreSQL. <br><br>  Das Material basiert auf Verwaltungsschulungen, die wir mit Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">pluzanov durchf√ºhren</a> .  Nicht jeder sieht sich gerne ein Video an (ich mag es definitiv nicht), aber das Lesen von Folien, auch mit Kommentaren, ist v√∂llig "falsch". <br><br>  Nat√ºrlich wiederholen die Artikel den Inhalt der Kurse nicht eins zu eins.  Ich werde nur dar√ºber sprechen, wie alles funktioniert, wobei die Verwaltung selbst weggelassen wird, aber ich werde versuchen, dies detaillierter und detaillierter zu tun.  Und ich glaube, dass dieses Wissen f√ºr den Anwendungsentwickler nicht weniger n√ºtzlich ist als f√ºr den Administrator. <br><br>  Ich werde mich auf diejenigen konzentrieren, die bereits Erfahrung mit PostgreSQL haben, und mir zumindest allgemein vorstellen, was passiert.  F√ºr Anf√§nger wird der Text etwas schwer sein.  Zum Beispiel werde ich kein Wort dar√ºber sagen, wie man PostgreSQL installiert und psql ausf√ºhrt. <br><br>  Dinge, die besprochen werden, √§ndern sich nicht viel von Version zu Version, aber ich werde das aktuelle 11. "Vanilla" PostgreSQL verwenden. <br><br>  Der erste Zyklus ist Fragen im Zusammenhang mit Isolation und Multiversion gewidmet und hat folgenden Plan: <br><br><ol><li>  Isolation im Sinne von Standard und PostgreSQL (dieser Artikel); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ebenen, Dateien, Seiten</a> - was passiert auf physischer Ebene? </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeilenversionen, virtuelle und verschachtelte Transaktionen</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenschnappsch√ºsse und Sichtbarkeit von Zeilenversionen, Ereignishorizont</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In-Page-Reinigung und HOT-Updates</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Reinigung</a> (Vakuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Automatische Reinigung</a> (Autovakuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberlauf und Einfrieren des Transaktionsz√§hlers</a> . </li></ol><br>  Nun, lass uns gehen. <br><a name="habracut"></a><br><h1>  Was ist Isolierung und warum ist sie wichtig? </h1><br>  Wahrscheinlich wei√ü zumindest jeder √ºber die Existenz von Transaktionen Bescheid, traf das Akronym ACID und h√∂rte von Isolationsstufen.  Man muss sich aber immer noch der Meinung stellen, dass dies eine Theorie ist, die in der Praxis nicht notwendig ist.  Daher werde ich einige Zeit damit verbringen, zu erkl√§ren, warum dies wirklich wichtig ist. <br><br>  Es ist unwahrscheinlich, dass Sie sich freuen werden, wenn die Anwendung falsche Daten aus der Datenbank empf√§ngt oder wenn die Anwendung falsche Daten in die Datenbank schreibt. <br><br>  Aber was sind "richtige" Daten?  Es ist bekannt, dass Sie auf Datenbankebene Integrit√§tsbeschr√§nkungen erstellen k√∂nnen (z. B. NOT NULL oder UNIQUE).  Wenn die Daten immer die Integrit√§tsbedingungen erf√ºllen (und dies liegt daran, dass das DBMS dies garantiert), sind sie ganzheitlich. <br><br>  <em>Sind richtig</em> und <em>ganzheitlich</em> - dasselbe?  Nicht wirklich.  Nicht alle Einschr√§nkungen k√∂nnen auf Datenbankebene formuliert werden.  Ein Teil der Einschr√§nkungen ist zu kompliziert, z. B. werden mehrere Tabellen gleichzeitig abgedeckt.  Und selbst wenn die Einschr√§nkung im Prinzip in der Datenbank definiert werden k√∂nnte, aber aus irgendeinem Grund nicht, bedeutet dies nicht, dass sie verletzt werden kann. <br><br>  <em>Korrektheit ist also</em> strenger als <em>Integrit√§t</em> , aber wir wissen nicht genau, was es ist.  Es bleibt abzuwarten, dass der Standard der Korrektheit eine Anwendung ist, die, wie wir glauben wollen, <em>korrekt</em> geschrieben ist und niemals falsch ist.  In jedem Fall wird das DBMS nichts davon wissen und seine Hand nicht fangen, wenn die Anwendung nicht die Integrit√§t, sondern die Richtigkeit verletzt. <br><br>  Von nun an nennen wir Korrektheit den Begriff Konsistenz. <br><br>  Nehmen wir jedoch an, dass die Anwendung nur die richtige Reihenfolge von Anweisungen ausf√ºhrt.  Welche Rolle spielt das DBMS dann, wenn die Anwendung korrekt ist? <br><br>  Erstens stellt sich heraus, dass eine korrekte Folge von Anweisungen die Datenkonsistenz vor√ºbergehend st√∂ren kann, und dies ist - seltsamerweise - normal.  Ein abgedroschenes, aber verst√§ndliches Beispiel ist die √úberweisung von Geldern von einem Konto auf ein anderes.  Die Konsistenzregel mag folgenderma√üen klingen: Eine <em>√úberweisung √§ndert niemals den Gesamtbetrag auf Konten</em> (eine solche Regel ist als Integrit√§tsbedingung in SQL nur schwer zu schreiben, daher existiert sie auf Anwendungsebene und ist f√ºr das DBMS unsichtbar).  Eine √úberweisung besteht aus zwei Vorg√§ngen: Der erste reduziert das Guthaben auf einem Konto, der zweite erh√∂ht sich auf einem anderen.  Die erste Operation verletzt die Datenkonsistenz, die zweite - stellt wieder her. <br><br><blockquote>  Eine gute √úbung besteht darin, die oben beschriebene Regel auf der Ebene der Integrit√§tsbeschr√§nkungen zu implementieren.  Bist du schwach  ¬© <br></blockquote><br>  Was ist, wenn die erste Operation abgeschlossen ist und die zweite nicht?  Immerhin ist es einfach: W√§hrend der zweiten Operation kann Strom verloren gehen, der Server kann herunterfallen, es kann eine Division durch Null auftreten - aber Sie wissen es nie.  Es ist klar, dass die Konsistenz verletzt wird, und dies sollte nicht erlaubt sein.  Grunds√§tzlich ist es m√∂glich, solche Situationen auf Anwendungsebene auf Kosten eines unglaublichen Aufwands zu l√∂sen, aber zum Gl√ºck ist dies nicht erforderlich: Das DBMS k√ºmmert sich darum.  Daf√ºr muss sie jedoch wissen, dass zwei Operationen ein unteilbares Ganzes bilden.  Das ist eine <em>Transaktion</em> . <br><br>  Es stellt sich als interessant heraus: Da das DBMS wei√ü, dass Operationen eine Transaktion darstellen, hilft es, die Konsistenz aufrechtzuerhalten, indem es die Atomizit√§t von Transaktionen garantiert, ohne etwas √ºber bestimmte Konsistenzregeln zu wissen. <br><br>  Aber es gibt noch einen zweiten, subtileren Punkt.  Sobald mehrere gleichzeitige Transaktionen im System erscheinen, die nacheinander absolut korrekt sind, k√∂nnen sie zusammen falsch funktionieren.  Dies liegt an der Tatsache, dass die Reihenfolge der Operationen gemischt ist: Es kann nicht davon ausgegangen werden, dass alle Operationen einer Transaktion zuerst ausgef√ºhrt werden und erst dann alle Operationen einer anderen. <br><br>  Ein Hinweis zur Gleichzeitigkeit.  Gleichzeitig k√∂nnen Transaktionen auf einem System mit einem Mehrkernprozessor, einem Festplattenarray usw. ausgef√ºhrt werden. F√ºr einen Server, der Befehle nacheinander im Time-Sharing-Modus ausf√ºhrt, gelten jedoch dieselben √úberlegungen: So viele Zyklen, eine Transaktion wird ausgef√ºhrt, so viele Zyklen sind unterschiedlich .  Manchmal wird der Begriff <em>Wettbewerbsausf√ºhrung</em> verwendet, um zusammenzufassen. <br><br>  Situationen, in denen korrekte Transaktionen nicht korrekt zusammenarbeiten, werden als gleichzeitige Ausf√ºhrungsanomalien bezeichnet. <br><br>  Ein einfaches Beispiel: Wenn eine Anwendung die richtigen Daten aus der Datenbank abrufen m√∂chte, sollte sie zumindest keine √Ñnderungen bei anderen nicht festgeschriebenen Transaktionen sehen.  Andernfalls k√∂nnen Sie nicht nur inkonsistente Daten abrufen, sondern auch etwas sehen, das noch nie in der Datenbank vorhanden war (wenn die Transaktion abgebrochen wird).  Diese Anomalie wird als <em>schmutziges Lesen bezeichnet</em> . <br><br>  Wenn es andere, komplexere Anomalien gibt, auf die wir etwas sp√§ter eingehen werden. <br><br>  Nat√ºrlich ist es unm√∂glich, die gleichzeitige Ausf√ºhrung abzulehnen. Welche Art von Auff√ºhrung kann sonst diskutiert werden?  Sie k√∂nnen jedoch nicht mit falschen Daten arbeiten. <br><br>  Und wieder kommt das DBMS zur Rettung.  Sie k√∂nnen Transaktionen <em>wie</em> nacheinander ausf√ºhren, <em>als ob sie</em> nacheinander ausgef√ºhrt w√ºrden.  Mit anderen Worten, <em>isoliert</em> voneinander.  In der Realit√§t kann das DBMS Operationen gemischt ausf√ºhren, gleichzeitig aber sicherstellen, dass das Ergebnis der gleichzeitigen Ausf√ºhrung mit dem Ergebnis einer der m√∂glichen sequentiellen Ausf√ºhrungen √ºbereinstimmt.  Und das beseitigt m√∂gliche Anomalien. <br><br>  Also kommen wir zur Definition: <br><br><blockquote>  Eine Transaktion ist der Satz von Operationen, die von einer Anwendung ausgef√ºhrt werden, die die Datenbank von einem korrekten Zustand in einen anderen korrekten Zustand √ºbertr√§gt (Konsistenz), vorausgesetzt, die Transaktion ist vollst√§ndig (Atomizit√§t) und ohne St√∂rung durch andere Transaktionen (Isolation). <br></blockquote><br>  Diese Definition kombiniert die ersten drei Buchstaben des Akronyms ACID.  Sie sind so eng miteinander verwandt, dass es einfach keinen Sinn macht, eins ohne das andere zu betrachten.  Tats√§chlich ist es schwierig, den Buchstaben D (Haltbarkeit) abzurei√üen.  Schlie√ülich bleiben im Falle eines Systemabsturzes √Ñnderungen an nicht festgeschriebenen Transaktionen darin, mit denen Sie etwas tun m√ºssen, um die Datenkonsistenz wiederherzustellen. <br><br>  Alles w√§re in Ordnung, aber die Implementierung einer vollst√§ndigen Isolierung ist eine technisch schwierige Aufgabe, verbunden mit einer Verringerung des Systemdurchsatzes.  Daher wird in der Praxis sehr oft (nicht immer, aber fast immer) eine geschw√§chte Isolierung angewendet, die einige, aber nicht alle Anomalien verhindert.  Dies bedeutet, dass ein Teil der Arbeit zur Sicherstellung der Richtigkeit der Daten auf die Anwendung f√§llt.  Aus diesem Grund ist es sehr wichtig zu verstehen, welche Isolationsstufe im System verwendet wird, welche Garantien es gibt und welche nicht und wie der richtige Code unter solchen Bedingungen geschrieben wird. <br><br><h1>  SQL-Isolationsstufen und Anomalien </h1><br>  Der SQL-Standard hat lange Zeit vier Isolationsstufen beschrieben.  Diese Ebenen werden durch Auflisten der Anomalien ermittelt, die bei der Ausf√ºhrung von Transaktionen auf dieser Ebene zul√§ssig oder nicht zul√§ssig sind.  Um √ºber diese Ebenen zu sprechen, m√ºssen Sie sich daher mit den Anomalien vertraut machen. <br><br>  Ich betone, dass wir in diesem Teil √ºber den Standard sprechen, dh √ºber eine bestimmte Theorie, auf die sich die Praxis stark st√ºtzt, die aber gleichzeitig im Widerspruch steht.  Daher sind alle Beispiele hier spekulativ.  Sie werden die gleichen Operationen auf Kundenkonten anwenden: Dies ist ziemlich offensichtlich, obwohl es zugegebenerma√üen nichts damit zu tun hat, wie die Bankoperationen tats√§chlich angeordnet sind. <br><br><h2>  Update verloren </h2><br>  Beginnen wir mit dem <em>verlorenen Update</em> .  Diese Anomalie tritt auf, wenn zwei Transaktionen dieselbe Zeile in der Tabelle lesen, dann eine Transaktion diese Zeile aktualisiert und danach auch die zweite Transaktion dieselbe Zeile aktualisiert, ohne die durch die erste Transaktion vorgenommenen √Ñnderungen zu ber√ºcksichtigen. <br><br>  Beispielsweise erh√∂hen zwei Transaktionen den Betrag auf demselben Konto um 100 ‚ÇΩ.  Die erste Transaktion liest den aktuellen Wert (1000 ‚ÇΩ), dann liest die zweite Transaktion den gleichen Wert.  Die erste Transaktion erh√∂ht den Betrag (es stellt sich heraus, 1100 ‚ÇΩ) und schreibt diesen Wert.  Die zweite Transaktion macht das Gleiche - bekommt die gleichen 1.100 ‚ÇΩ und schreibt sie.  Infolgedessen verlor der Kunde 100 ‚ÇΩ. <br><br>  Verlorene Updates sind vom Standard auf keiner Isolationsstufe zul√§ssig. <br><br><h2>  Dirty Reading und Read Uncommitted </h2><br>  Mit <em>schmutzigem Lesen haben</em> wir uns oben schon getroffen.  Diese Anomalie tritt auf, wenn eine Transaktion ausstehende √Ñnderungen liest, die von einer anderen Transaktion vorgenommen wurden. <br><br>  Bei der ersten Transaktion wird beispielsweise das gesamte Geld vom Konto des Kunden auf ein anderes Konto √ºbertragen, die √Ñnderung wird jedoch nicht erfasst.  Eine andere Transaktion liest den Kontostatus, erh√§lt 0 ‚ÇΩ und weigert sich, Bargeld an den Kunden auszugeben - trotz der Tatsache, dass die erste Transaktion unterbrochen wird und ihre √Ñnderungen abbricht, sodass der Wert 0 nie in der Datenbank vorhanden war. <br><br>  Das fehlerhafte Lesen ist nach dem Standard auf der Ebene "Nicht festgeschrieben" zul√§ssig. <br><br><h2>  Nicht wiederholtes Lesen und Lesen festgeschrieben </h2><br>  Die <em>nicht wiederholte</em> Leseanomalie tritt auf, wenn eine Transaktion dieselbe Zeile zweimal liest und in dem Intervall zwischen den Lesevorg√§ngen die zweite Transaktion diese Zeile √§ndert (oder l√∂scht) und die √Ñnderungen festschreibt.  Dann erh√§lt die erste Transaktion unterschiedliche Ergebnisse. <br><br>  Lassen Sie beispielsweise die Konsistenzregel <em>negative Betr√§ge in Kundenkonten verbieten</em> .  Bei der ersten Transaktion wird der Betrag auf dem Konto um 100 reduce reduziert.  Sie √ºberpr√ºft den aktuellen Wert, erh√§lt 1000 ‚ÇΩ und entscheidet, dass eine Reduzierung m√∂glich ist.  Zu diesem Zeitpunkt reduziert die zweite Transaktion den Betrag auf dem Konto auf Null und zeichnet die √Ñnderungen auf.  Wenn nun die erste Transaktion den Betrag erneut pr√ºfte, w√ºrde sie 0 ‚ÇΩ erhalten (aber sie hatte bereits beschlossen, den Wert zu verringern, und das Konto geht auf Minus). <br><br>  Nicht wiederholtes Lesen ist nach dem Standard auf den Ebenen Read Uncommitted und Read Committed zul√§ssig.  Aber schmutziges Lesen Read Committed erlaubt nicht. <br><br><h2>  Phantom Read und wiederholbares Lesen </h2><br>  <em>Das Phantomlesen</em> tritt auf, wenn eine Transaktion einen Satz von Zeilen unter derselben Bedingung zweimal liest, und in dem Intervall zwischen den Lesevorg√§ngen f√ºgt die zweite Transaktion Zeilen hinzu, die diese Bedingung erf√ºllen (und die √Ñnderungen festschreiben).  Dann erh√§lt die erste Transaktion verschiedene Zeilens√§tze. <br><br>  Angenommen, eine Konsistenzregel <em>verhindert, dass ein Kunde mehr als drei Konten hat</em> .  Die erste Transaktion er√∂ffnet ein neues Konto, √ºberpr√ºft die aktuelle Nummer (z. B. 2) und entscheidet, dass eine Er√∂ffnung m√∂glich ist.  Zu diesem Zeitpunkt er√∂ffnet die zweite Transaktion auch ein neues Konto f√ºr den Kunden und zeichnet die √Ñnderungen auf.  Wenn nun die erste Transaktion die Menge doppelt pr√ºft, erh√§lt sie 3 (aber sie er√∂ffnet bereits ein anderes Konto und der Kunde hat 4 davon). <br><br>  Das Lesen von Phantomen ist standardm√§√üig in den Stufen Read Uncommitted, Read Committed und Repeatable Read zul√§ssig.  Auf der Ebene Wiederholbares Lesen ist nicht wiederholtes Lesen jedoch nicht zul√§ssig. <br><br><h2>  Mangel an Anomalien und serialisierbar </h2><br>  Der Standard definiert eine andere Ebene - serialisierbar - auf der keine Anomalien zul√§ssig sind.  Und dies ist keineswegs gleichbedeutend mit einem Verbot eines verlorenen Updates und einem schmutzigen, sich nicht wiederholenden und Phantom-Lesen. <br><br>  Tatsache ist, dass es deutlich mehr bekannte Anomalien als die im Standard aufgef√ºhrten gibt und eine unbekannte Anzahl noch unbekannt ist. <br><br>  Serialisierbar sollte <em>generell alle</em> Anomalien verhindern.  Dies bedeutet, dass der Anwendungsentwickler auf dieser Ebene nicht daran denken muss, gleichzeitig ausgef√ºhrt zu werden.  Wenn Transaktionen die richtigen Abfolgen von Anweisungen ausf√ºhren und alleine arbeiten, stimmen die Daten mit dem gleichzeitigen Betrieb dieser Transaktionen √ºberein. <br><br><h2>  Zusammenfassungsschild </h2><br>  Jetzt k√∂nnen Sie jedem einen bekannten Tisch bringen.  Aus Gr√ºnden der √úbersichtlichkeit wird hier jedoch die letzte Spalte hinzugef√ºgt, die nicht im Standard enthalten ist. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  verlorene √Ñnderungen </th><th>  schmutziges Lesen </th><th>  nicht wiederholtes Lesen </th><th>  Phantomlesung </th><th>  andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br><h2>  Warum genau diese Anomalien? </h2><br>  Warum sind nur einige der vielen m√∂glichen Anomalien im Standard aufgef√ºhrt und warum sind dies? <br><br>  Anscheinend scheint das niemand mit Sicherheit zu wissen.  Aber die Praxis hier hat definitiv die Theorie √ºberholt, so dass es m√∂glich ist, dass wir dann nicht √ºber andere Anomalien nachgedacht haben (Rede √ºber den SQL-Standard: 92). <br><br>  Au√üerdem wurde angenommen, dass die Isolierung auf Verriegelungen aufgebaut sein sollte.  Die Idee des weit verbreiteten <em>Zwei-Phasen-Blockierungsprotokolls</em> (2PL) ist, dass die Transaktion w√§hrend der Transaktion die Leitungen blockiert, mit denen sie arbeitet, und nach Abschluss die Sperren aufhebt.  Je mehr Sperren eine Transaktion erfasst, desto besser ist sie von anderen Transaktionen isoliert.  Die Leistung des Systems leidet jedoch noch mehr, da Transaktionen nicht mehr zusammenarbeiten, sondern f√ºr dieselben Zeilen ausgerichtet werden. <br><br>  Es scheint mir, dass der Unterschied zwischen den Isolationsstufen des Standards genau durch die Anzahl der erforderlichen Sperren erkl√§rt wird. <br><br>  Wenn eine Transaktion das √Ñndern, aber nicht das Lesen ge√§nderter Zeilen blockiert, erhalten wir die Stufe "Nicht festgeschrieben lesen": Verlorene √Ñnderungen sind nicht zul√§ssig, aber nicht festgeschriebene Daten k√∂nnen gelesen werden. <br><br>  Wenn die Transaktion das Lesen und √Ñndern von ver√§nderlichen Zeilen blockiert, erhalten wir die Stufe Read Committed: Sie k√∂nnen keine nicht festgeschriebenen Daten lesen, aber wenn Sie erneut auf die Zeile zugreifen, k√∂nnen Sie einen anderen Wert erhalten (nicht wiederholtes Lesen). <br><br>  Wenn eine Transaktion sowohl lesbare als auch ver√§nderbare Zeilen vom Lesen und √Ñndern blockiert, erhalten wir die Stufe Wiederholbares Lesen: Durch wiederholtes Lesen der Zeile wird der gleiche Wert erzeugt. <br><br>  Bei Serializable gibt es jedoch ein Problem: Es ist nicht m√∂glich, eine noch nicht vorhandene Zeile zu sperren.  Aus diesem Grund bleibt die M√∂glichkeit des Phantomlesens bestehen: Eine andere Transaktion kann eine Zeile hinzuf√ºgen (aber nicht l√∂schen), die unter die Bedingungen einer zuvor ausgef√ºhrten Abfrage f√§llt, und diese Zeile wird erneut abgerufen. <br><br>  Daher reichen gew√∂hnliche Sperren nicht aus, um die Ebene der Serialisierbarkeit zu implementieren. Sie m√ºssen nicht die Zeilen, sondern die Bedingungen (Pr√§dikate) blockieren.  Solche Sperren wurden <em>Pr√§dikate genannt</em> .  Sie wurden bereits 1976 vorgeschlagen, aber ihre praktische Anwendbarkeit wird durch relativ einfache Bedingungen eingeschr√§nkt, f√ºr die klar ist, wie zwei verschiedene Pr√§dikate kombiniert werden k√∂nnen.  Soweit ich wei√ü, ist es in keinem System zur Implementierung solcher Sperren gekommen. <br><br><h1>  PostgreSQL-Isolationsstufen </h1><br>  Im Laufe der Zeit ersetzte Snapshot Isolation die blockierenden Transaktionsverwaltungsprotokolle.  Seine Idee ist, dass jede Transaktion zu einem bestimmten Zeitpunkt mit einem konsistenten Snapshot der Daten arbeitet, bei dem nur die √Ñnderungen fallen, die vor der Erstellung des Snapshots aufgezeichnet wurden. <br><br>  Eine solche Isolierung erm√∂glicht nicht automatisch ein schmutziges Lesen.  Formal k√∂nnen Sie in PostgreSQL die Stufe Read Uncommitted angeben, dies funktioniert jedoch genauso wie Read Committed.  Daher werden wir nicht weiter √ºber die Stufe "Nicht festgeschrieben lesen" sprechen. <br><br>  PostgreSQL implementiert eine <em>Mehrfachversion</em> dieses Protokolls.  Die Idee der Mehrfachversionierung besteht darin, dass mehrere Versionen derselben Zeichenfolge in einem DBMS gleichzeitig vorhanden sein k√∂nnen.  Auf diese Weise k√∂nnen Sie mit den verf√ºgbaren Versionen einen Snapshot der Daten erstellen und mit einem Minimum an Sperren auskommen.  Tats√§chlich werden nur wiederholte √Ñnderungen an derselben Zeile blockiert.  Alle anderen Vorg√§nge werden gleichzeitig ausgef√ºhrt: Das Schreiben von Transaktionen blockiert niemals das Lesen von Transaktionen, und das Lesen von Transaktionen blockiert niemals jemanden. <br><br>  Bei Verwendung von Daten-Snapshots ist die Isolation in PostgreSQL strenger als es der Standard erfordert: Die Stufe "Wiederholbares Lesen" erm√∂glicht nicht nur nicht wiederholte, sondern auch Phantom-Lesevorg√§nge (obwohl sie keine vollst√§ndige Isolation bietet).  Und das ohne Wirkungsverlust. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  verlorene √Ñnderungen </th><th>  schmutziges Lesen </th><th>  nicht wiederholtes Lesen </th><th>  Phantomlesung </th><th>  andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  ja </th><th>  ja </th><th>  ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br>  Wie Multi-Versioning ‚Äûunter der Haube‚Äú implementiert wird, werden wir in den folgenden Artikeln besprechen und nun jede der drei Ebenen mit den Augen des Benutzers detailliert betrachten (wie Sie wissen, verbirgt sich das Interessanteste hinter ‚Äûanderen Anomalien‚Äú).  Erstellen Sie dazu eine Kontenliste.  Alice und Bob haben jeweils 1.000 US-Dollar, aber Bob hat zwei offene Konten: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Lesen Sie verpflichtet </h2><br><h3>  Mangel an schmutzigem Lesen </h3><br>  Es ist leicht zu √ºberpr√ºfen, ob verschmutzte Daten nicht gelesen werden k√∂nnen.  Beginnen wir mit der Transaktion.  Standardm√§√üig wird die Isolationsstufe Read Committed verwendet: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Genauer gesagt wird der Standardpegel durch den Parameter festgelegt und kann bei Bedarf ge√§ndert werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Bei einer offenen Transaktion ziehen wir also Geld vom Konto ab, erfassen die √Ñnderungen jedoch nicht.  Die Transaktion sieht ihre eigenen √Ñnderungen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  In der zweiten Sitzung starten wir eine weitere Transaktion mit derselben Read Committed-Ebene.  Um zwischen verschiedenen Transaktionen zu unterscheiden, werden die Befehle der zweiten Transaktion einger√ºckt und durchgestrichen. <br><br>  Um die obigen Befehle zu wiederholen (was n√ºtzlich ist), m√ºssen Sie zwei Terminals √∂ffnen und jeweils psql ausf√ºhren.  Im ersten k√∂nnen Sie die Befehle einer Transaktion eingeben und im zweiten die Befehle einer anderen. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Wie erwartet werden bei einer anderen Transaktion keine nicht festgeschriebenen √Ñnderungen angezeigt - Dirty Reading ist nicht zul√§ssig. <br><br><h3>  Nicht wiederholtes Lesen </h3><br>  Lassen Sie nun die erste Transaktion die √Ñnderungen festschreiben und die zweite dieselbe Anforderung erneut ausf√ºhren. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die Anforderung empf√§ngt bereits neue Daten - dies ist die Anomalie des <em>nicht wiederholten Lesens</em> , die auf der Ebene Read Committed zul√§ssig ist. <br><br>  <em>Praktische Schlussfolgerung</em> : In einer Transaktion ist es unm√∂glich, Entscheidungen auf der Grundlage der von der vorherigen Anweisung gelesenen Daten zu treffen, da sich zwischen den Ausf√ºhrungszeiten der Anweisungen alles √§ndern kann.  Hier ist ein Beispiel, dessen Variationen im Anwendungscode so h√§ufig sind, dass es sich um ein klassisches Antimuster handelt: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  W√§hrend der Zeit zwischen √úberpr√ºfung und Aktualisierung k√∂nnen andere Transaktionen den Status des Kontos wie gew√ºnscht √§ndern, sodass bei einer solchen ‚Äû√úberpr√ºfung‚Äú nichts gespeichert wird.  Man kann sich leicht vorstellen, dass zwischen den Betreibern einer Transaktion alle anderen Betreiber anderer Transaktionen beispielsweise ‚Äûkeilen‚Äú k√∂nnen: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Wenn Sie beim Neuanordnen der Operatoren alles ruinieren k√∂nnen, ist der Code falsch geschrieben.  Und t√§uschen Sie sich nicht, dass eine solche Kombination von Umst√§nden nicht eintreten wird - es wird passieren. <br><br>  Wie schreibe ich den Code richtig?  Chancen beschr√§nken sich in der Regel auf Folgendes: <br><br><ul><li>  Schreiben Sie keinen Code. <br>  Das ist kein Scherz.  In diesem Fall wird die Pr√ºfung beispielsweise leicht zu einer Integrit√§tsbeschr√§nkung: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Jetzt sind keine √úberpr√ºfungen mehr erforderlich: Es reicht aus, die Aktion einfach auszuf√ºhren und gegebenenfalls die Ausnahme zu behandeln, die im Falle eines Versuchs, die Integrit√§t zu verletzen, auftritt. <br></li><li>  Verwenden Sie eine einzelne SQL-Anweisung. <br>  Konsistenzprobleme entstehen aufgrund der Tatsache, dass im Intervall zwischen Operatoren eine andere Transaktion enden kann und sich die sichtbaren Daten √§ndern.  Und wenn es nur einen Operator gibt, gibt es keine L√ºcken. <br>  PostgreSQL verf√ºgt √ºber gen√ºgend Tools, um komplexe Probleme mit einer einzigen SQL-Anweisung zu l√∂sen.  Wir beachten die allgemeinen Tabellenausdr√ºcke (CTE), in denen Sie unter anderem die Anweisungen INSERT / UPDATE / DELETE sowie die Anweisung INSERT ON CONFLICT verwenden k√∂nnen, die die Logik "Einf√ºgen und, wenn bereits eine Zeile vorhanden ist, aktualisieren" in einer Anweisung implementiert. <br></li><li>  Benutzersperren. <br>  Der letzte Ausweg besteht darin, manuell eine exklusive Sperre entweder f√ºr alle erforderlichen Zeilen (SELECT FOR UPDATE) oder f√ºr die gesamte Tabelle (LOCK TABLE) festzulegen.  Dies funktioniert immer, negiert jedoch die Vorteile der Mehrfachversionierung: Anstatt gleichzeitig ausgef√ºhrt zu werden, wird ein Teil der Vorg√§nge nacheinander ausgef√ºhrt. <br></li></ul><br><h3>  Inkonsistentes Lesen </h3><br>  Bevor man sich auf die n√§chste Stufe der Isolation begibt, muss man zugeben, dass nicht alles so einfach ist.  Die Implementierung von PostgreSQL ist so, dass andere, weniger bekannte Anomalien ber√ºcksichtigt werden, die nicht durch den Standard geregelt sind. <br><br>  Angenommen, mit der ersten Transaktion wurde Geld von einem Bob-Konto auf ein anderes √ºbertragen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Zu diesem Zeitpunkt berechnet eine andere Transaktion den Saldo von Bob, wobei die Berechnung in einem Zyklus f√ºr alle Konten von Bob durchgef√ºhrt wird.  Tats√§chlich beginnt die Transaktion mit dem ersten Konto (und sieht offensichtlich den vorherigen Status): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Zu diesem Zeitpunkt wird die erste Transaktion erfolgreich abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und der andere liest den Status des zweiten Kontos (und sieht bereits einen neuen Wert): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Somit erhielt die zweite Transaktion insgesamt 1100 ‚ÇΩ, dh falsche Daten.  Dies ist eine Anomalie des <em>inkonsistenten Lesens</em> . <br><br>  Wie kann man eine solche Anomalie vermeiden, indem man bei Read Committed bleibt?  Verwenden Sie nat√ºrlich einen Operator.  Zum Beispiel so: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Bisher habe ich argumentiert, dass sich die Sichtbarkeit von Daten nur zwischen Betreibern √§ndern kann, aber ist das so offensichtlich?  Und wenn die Anforderung f√ºr eine lange Zeit ausgef√ºhrt wird, kann sie einen Teil der Daten in einem Zustand und einen Teil in einem anderen sehen? <br><br>  Schau es dir an.  Eine bequeme M√∂glichkeit, dies zu tun, besteht darin, eine k√ºnstliche Verz√∂gerung in den Operator einzuf√ºgen, indem die Funktion pg_sleep aufgerufen wird.  Sein Parameter legt die Verz√∂gerungszeit in Sekunden fest. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  W√§hrend dieser Bauarbeiten √ºberweisen wir bei einer anderen Transaktion Geld zur√ºck: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Das Ergebnis zeigt, dass der Bediener die Daten in dem Zustand sieht, in dem sie sich zum Zeitpunkt des Starts befanden.  Das ist sicherlich richtig. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Aber hier ist es nicht so einfach.  Mit PostgreSQL k√∂nnen Sie Funktionen definieren, w√§hrend Funktionen das Konzept einer <em>Variabilit√§tskategorie haben</em> .  Wenn eine <em>fl√ºchtige</em> Funktion (mit der Kategorie VOLATILE) in einer Anforderung aufgerufen wird und eine andere Anforderung in dieser Funktion ausgef√ºhrt wird, werden bei dieser Anforderung innerhalb der Funktion Daten angezeigt, die nicht mit den Daten der Hauptanforderung √ºbereinstimmen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  In diesem Fall erhalten wir falsche Daten - 100 ‚ÇΩ gehen verloren: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Ich betone, dass ein solcher Effekt nur auf der Isolationsstufe Read Committed und nur auf der Variabilit√§tskategorie VOLATILE m√∂glich ist.  Das Problem ist, dass diese Isolationsstufe und diese Kategorie von Variabilit√§t standardm√§√üig verwendet werden, also muss ich zugeben - der Rechen liegt sehr gut.  Nicht treten! <br><br><h3>  Inkonsistentes Lesen im Austausch f√ºr verlorene √Ñnderungen </h3><br>  Ein inkonsistenter Messwert im Rahmen eines Operators kann - auf etwas unerwartete Weise - w√§hrend eines Updates erhalten werden. <br><br>  Mal sehen, was passiert, wenn Sie versuchen, dieselbe Zeile mit zwei Transaktionen zu √§ndern.  Bob hat jetzt 1000 ‚ÇΩ auf zwei Konten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Wir starten eine Transaktion, die Bobs Guthaben reduziert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Gleichzeitig fallen f√ºr eine andere Transaktion Zinsen auf alle Kundenkonten mit einem Gesamtguthaben von mindestens 1000 ‚ÇΩ an: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  Das Ausf√ºhren einer UPDATE-Anweisung besteht aus zwei Teilen.  Zun√§chst wird tats√§chlich ein SELECT ausgef√ºhrt, das die Zeilen ausw√§hlt, die der Bedingung f√ºr die Aktualisierung entsprechen.  Da die √Ñnderung der ersten Transaktion nicht festgelegt ist, kann die zweite Transaktion sie nicht sehen und hat keinen Einfluss auf die Auswahl der Zeilen f√ºr die Zinsberechnung.  Bobs Konten fallen also unter die Bedingung und nach Abschluss des Updates sollte sich sein Kontostand um 10 increase erh√∂hen. <br><br>  Die zweite Ausf√ºhrungsstufe - Die ausgew√§hlten Zeilen werden nacheinander aktualisiert.  Hier wird die zweite Transaktion zum "Einfrieren" gezwungen, da die Zeilen-ID = 3 bereits von der ersten Transaktion gesperrt ist. <br><br>  In der Zwischenzeit werden bei der ersten Transaktion die √Ñnderungen festgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Was wird das Ergebnis sein? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Ja, einerseits sollte der Befehl UPDATE keine √Ñnderungen in der zweiten Transaktion sehen.  Andererseits sollten die in der zweiten Transaktion aufgezeichneten √Ñnderungen nicht verloren gehen. <br><br>  Nachdem die Sperre aufgehoben wurde, liest UPDATE die Zeile, die aktualisiert werden soll, erneut (aber nur eine!).  Das Ergebnis ist, dass Bob 9 ‚ÇΩ angesammelt hat, basierend auf dem Betrag von 900 ‚ÇΩ.  Aber wenn Bob 900 had h√§tte, h√§tten seine Konten √ºberhaupt nicht in die Stichprobe aufgenommen werden d√ºrfen. <br><br>  Die Transaktion empf√§ngt also falsche Daten: Einige der Zeilen sind zu einem bestimmten Zeitpunkt sichtbar, andere zum anderen.  Anstelle eines verlorenen Updates erhalten wir erneut eine Anomalie beim <em>inkonsistenten Lesen</em> . <br><br><blockquote>  Aufmerksame Leser stellen fest, dass Sie mit Hilfe der Anwendung auf der Ebene "Read Committed" ein verlorenes Update erhalten k√∂nnen.  Zum Beispiel so: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Die Datenbank ist nicht schuld: Sie empf√§ngt zwei SQL-Anweisungen und wei√ü nichts, dass der Wert von x + 100 in irgendeiner Weise mit accounts.amount zusammenh√§ngt.  Schreiben Sie keinen Code auf diese Weise. <br></blockquote><br><h2>  Wiederholbares Lesen </h2><br><h3>  Mangel an nicht wiederholenden und Phantomablesungen </h3><br>  Der Name der Isolationsstufe selbst zeigt an, dass der Messwert wiederholbar ist.  Wir werden dies √ºberpr√ºfen und gleichzeitig davon √ºberzeugt sein, dass keine Phantomwerte vorliegen.  Setzen Sie dazu in der ersten Transaktion die Konten von Bob auf den vorherigen Status zur√ºck und erstellen Sie ein neues Konto f√ºr Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  In der zweiten Sitzung starten wir die Transaktion mit der Ebene Wiederholbares Lesen, die im Befehl BEGIN angegeben wird (die Ebene der ersten Transaktion ist nicht wichtig). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Jetzt schreibt die erste Transaktion die √Ñnderungen fest und die zweite f√ºhrt dieselbe Anforderung erneut aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Bei der zweiten Transaktion werden weiterhin genau dieselben Daten wie zu Beginn angezeigt: Es sind weder √Ñnderungen an vorhandenen noch neue Zeilen sichtbar. <br><br>  Auf dieser Ebene m√ºssen Sie sich keine Sorgen machen, dass sich zwischen den beiden Operatoren etwas √§ndert. <br><br><h3>  Serialisierungsfehler im Austausch f√ºr verlorene √Ñnderungen </h3><br>  Wir haben oben gesagt, dass beim Aktualisieren derselben Zeile mit zwei Transaktionen auf der Ebene "Read Committed" eine Anomalie des inkonsistenten Lesens auftreten kann.  Dies liegt an der Tatsache, dass die ausstehende Transaktion die gesperrte Zeile erneut liest und sie daher nicht zum gleichen Zeitpunkt wie die √ºbrigen Zeilen sieht. <br><br>  Auf der Ebene "Wiederholbares Lesen" ist eine solche Anomalie nicht zul√§ssig. Wenn sie dennoch auftritt, kann nichts unternommen werden. Daher endet die Transaktion mit einem Serialisierungsfehler.  Wir √ºberpr√ºfen dies, indem wir dasselbe Szenario mit Prozents√§tzen wiederholen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Daten blieben konsistent: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  Der gleiche Fehler tritt bei jeder anderen √Ñnderung der Wettbewerbszeile auf, auch wenn sich die f√ºr uns interessanten Spalten nicht tats√§chlich ge√§ndert haben. <br><br>  <em>Praktische Schlussfolgerung</em> : Wenn die Anwendung die Isolationsstufe Wiederholbares Lesen zum Schreiben von Transaktionen verwendet, sollte sie bereit sein, Transaktionen zu wiederholen, die mit einem Serialisierungsfehler endeten.  Bei schreibgesch√ºtzten Transaktionen ist ein solches Ergebnis nicht m√∂glich. <br><br><h3>  Inkonsistenter Eintrag </h3><br>  In PostgreSQL werden auf der Isolationsstufe von Repeatable Read alle im Standard beschriebenen Anomalien verhindert.  Aber √ºberhaupt nicht.  Es stellt sich heraus, dass <em>genau zwei</em> Anomalien m√∂glich bleiben.  (Dies gilt nicht nur f√ºr PostgreSQL, sondern auch f√ºr andere Snapshot-basierte Isolationsimplementierungen.) <br><br>  Die erste dieser Anomalien ist eine <em>inkonsistente Aufzeichnung</em> . <br><br>  Lassen Sie diese Konsistenzregel gelten: <em>Negative Betr√§ge sind auf den Konten des Kunden zul√§ssig, wenn der Gesamtbetrag auf allen Konten dieses Kunden nicht negativ bleibt</em> . <br><br>  Die erste Transaktion erh√§lt den Betrag auf Bobs Konten: 900 ‚ÇΩ. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  Die zweite Transaktion erh√§lt den gleichen Betrag. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  Die erste Transaktion geht zu Recht davon aus, dass der Betrag eines der Konten um 600 reduced reduziert werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Und die zweite Transaktion kommt zu dem gleichen Ergebnis.  Reduziert aber eine andere Punktzahl: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Wir haben es geschafft, Bobs Saldo auf Minus zu bringen, obwohl jede der Transaktionen einzeln korrekt funktioniert. <br><br><h3>  Schreibgesch√ºtzte Anomalie </h3><br>  Dies ist die zweite und letzte der Anomalien, die auf der Ebene des wiederholbaren Lesens m√∂glich sind.  Um dies zu demonstrieren, ben√∂tigen Sie drei Transaktionen, von denen zwei die Daten √§ndern und die dritte - nur lesbar. <br><br>  Stellen Sie jedoch zuerst den Kontostatus von Bob wieder her: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Bei der ersten Transaktion werden Bob Zinsen f√ºr den Geldbetrag auf allen Konten berechnet.  Die Zinsen werden einem seiner Konten gutgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Dann zieht eine andere Transaktion Geld von einem anderen Konto von Bob ab und erfasst seine √Ñnderungen: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Wenn zu diesem Zeitpunkt die erste Transaktion festgeschrieben wird, liegt keine Anomalie vor: Wir k√∂nnen davon ausgehen, dass die erste Transaktion zuerst und dann die zweite abgeschlossen wurde (aber nicht umgekehrt, da bei der ersten Transaktion der Status der Konto-ID = 3 vor diesem Konto angezeigt wurde ge√§ndert durch die zweite Transaktion). <br><br>  Angenommen, in diesem Moment beginnt die dritte (schreibgesch√ºtzte) Transaktion, die den Status eines Kontos liest, das von den ersten beiden Transaktionen nicht betroffen ist: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Und erst danach ist die erste Transaktion abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Welchen Status sollte die dritte Transaktion jetzt sehen? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Nach dem Start konnte bei der dritten Transaktion √Ñnderungen in der zweiten Transaktion (die bereits festgeschrieben wurde) angezeigt werden, nicht jedoch in der ersten Transaktion (die noch nicht festgeschrieben wurde).  Andererseits haben wir oben bereits festgestellt, dass die zweite Transaktion nach der ersten begonnen haben sollte.  Welchen Status die dritte Transaktion auch sieht, sie ist inkonsistent - dies ist die Anomalie nur der Lesetransaktion.  Auf der Ebene Wiederholbares Lesen ist jedoch Folgendes zul√§ssig: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serialisierbar </h2><br>  Auf der Ebene Serializable werden alle m√∂glichen Anomalien verhindert.  Tats√§chlich wird Serializable als Add-In f√ºr die Isolation basierend auf Datenschnappsch√ºssen implementiert.  Diejenigen Anomalien, die w√§hrend des wiederholbaren Lesens nicht auftreten (z. B. schmutziges, nicht wiederholbares Phantom-Lesen), treten auf der Ebene von Serializable nicht auf.  Und die auftretenden Anomalien (inkonsistente Aufzeichnung und Anomalie nur der Lesetransaktion) werden erkannt und die Transaktion wird abgebrochen - der bereits bekannte Serialisierungsfehler konnte den Zugriff nicht serialisieren. <br><br><h3>  Inkonsistenter Eintrag </h3><br>  Zur Veranschaulichung wiederholen wir das Szenario mit einer Anomalie inkonsistenter Aufzeichnung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Neben der Ebene "Wiederholbares Lesen" muss eine Anwendung, die die Isolationsstufe "Serialisierbar" verwendet, Transaktionen wiederholen, die zu einem Serialisierungsfehler gef√ºhrt haben, der uns auch durch den Hinweis in der Fehlermeldung gemeldet wird. <br><br>  Wir erhalten die Einfachheit der Programmierung, aber der Preis daf√ºr ist die erzwungene Aufschl√ºsselung eines bestimmten Anteils von Transaktionen und die Notwendigkeit, diese zu wiederholen.  Die ganze Frage ist nat√ºrlich, wie gro√ü dieser Anteil ist.  Wenn nur die Transaktionen beendet w√ºrden, die sich in Daten wirklich inkompatibel mit anderen Transaktionen √ºberschneiden, w√§re alles sch√∂n.  Eine solche Implementierung w√ºrde sich jedoch unweigerlich als ressourcenintensiv und ineffizient herausstellen, da sie den Betrieb mit jeder Zeile verfolgen m√ºsste. <br><br>  Tats√§chlich ist die Implementierung von PostgreSQL so, dass falsch negative Ausl√∂ser zugelassen werden: Einige v√∂llig normale Transaktionen, die einfach ‚Äûkein Gl√ºck haben‚Äú, werden abgebrochen.  Wie wir sp√§ter sehen werden, h√§ngt dies von vielen Gr√ºnden ab, beispielsweise von der Verf√ºgbarkeit geeigneter Indizes oder der verf√ºgbaren RAM-Menge.  Dar√ºber hinaus gibt es einige andere (ziemlich schwerwiegende) Implementierungsbeschr√§nkungen, z. B. funktionieren Anforderungen auf serialisierbarer Ebene nicht f√ºr Replikate, parallele Ausf√ºhrungspl√§ne werden f√ºr sie nicht verwendet.  Und obwohl die Arbeit zur Verbesserung der Umsetzung nicht aufh√∂rt, verringern die bestehenden Beschr√§nkungen die Attraktivit√§t dieser Isolationsstufe. <br><blockquote>  Parallele Pl√§ne werden in PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> .  Und Anfragen zu Replikaten k√∂nnen in PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem weiteren Patch</a> ) verdient werden. <br></blockquote><br><h3>  Schreibgesch√ºtzte Anomalie </h3><br>  Damit nur eine Lesetransaktion nicht zu einer Anomalie f√ºhren und nicht darunter leiden kann, bietet PostgreSQL einen interessanten Mechanismus: Eine solche Transaktion kann blockiert werden, bis ihre Ausf√ºhrung sicher ist.  Dies ist der einzige Fall, in dem eine SELECT-Anweisung durch Zeilenaktualisierungen blockiert werden kann.  So sieht es aus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Die dritte Transaktion wird ausdr√ºcklich nur vom Leser deklariert (NUR LESEN) und zur√ºckgestellt (DEFERRABLE): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Wenn Sie versuchen, eine Anforderung auszuf√ºhren, wird die Transaktion blockiert, da ihre Ausf√ºhrung sonst zu einer Anomalie f√ºhrt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und erst nachdem die erste Transaktion festgeschrieben wurde, wird die dritte weiter ausgef√ºhrt: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Ein weiterer wichtiger Hinweis: Wenn die serialisierbare Isolation verwendet wird, m√ºssen alle Transaktionen in der Anwendung diese Ebene verwenden.  Sie k√∂nnen Read Committed (oder Repeatable Read) -Transaktionen nicht mit Serializable mischen.  Das hei√üt, Sie k√∂nnen etwas mischen, aber dann verh√§lt sich Serializable wie ein wiederholbarer Lesevorgang ohne Vorwarnung.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum dies geschieht, werden wir sp√§ter betrachten, wenn wir √ºber die Implementierung sprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich also f√ºr Serializble entscheiden, ist es am besten, die Standardstufe global festzulegen (obwohl dies nat√ºrlich nicht die explizite Angabe der falschen Stufe verbietet):</font></font><br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine genauere Darstellung von Fragen im Zusammenhang mit Transaktionen, Konsistenz und Anomalien findet sich in </font><font style="vertical-align: inherit;">Boris Asenovich Novikovs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buch-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorlesungskurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Fundamentals of Database Technologies".</font></font><br></blockquote><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Welchen Isolationsgrad sollte ich verwenden? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Read Committed-Isolationsstufe wird in PostgreSQL standardm√§√üig verwendet, und es scheint, dass diese Stufe in der √ºberwiegenden Mehrheit der Anwendungen verwendet wird. Es ist zweckm√§√üig, dass eine Transaktionsunterbrechung nur im Fehlerfall m√∂glich ist, nicht aber um Inkonsistenzen zu vermeiden. Mit anderen Worten, ein Serialisierungsfehler kann nicht auftreten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kehrseite der M√ºnze ist die gro√üe Anzahl m√∂glicher Anomalien, die oben ausf√ºhrlich er√∂rtert wurden. Der Entwickler muss sie st√§ndig im Auge behalten und Code so schreiben, dass ihr Auftreten verhindert wird. Wenn es nicht m√∂glich ist, die erforderlichen Aktionen in einer einzelnen SQL-Anweisung zu formulieren, m√ºssen Sie explizit Sperren setzen. Das Unangenehmste ist, dass der Code schwer auf Fehler beim Abrufen inkonsistenter Daten zu testen ist und die Fehler selbst auf unvorhersehbare und nicht reproduzierbare Weise auftreten k√∂nnen und daher schwer zu beheben sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Isolationsstufe von Repeatable Read beseitigt einige der Probleme der Inkonsistenz, aber leider nicht alle. Daher m√ºssen Sie sich nicht nur die verbleibenden Anomalien merken, sondern auch die Anwendung so √§ndern, dass Serialisierungsfehler korrekt verarbeitet werden. Dies ist nat√ºrlich unpraktisch. Bei schreibgesch√ºtzten Transaktionen erg√§nzt diese Ebene jedoch perfekt Read Committed und ist beispielsweise sehr praktisch, um Berichte zu erstellen, die mehrere SQL-Abfragen verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich macht die serialisierbare Ebene die Notwendigkeit von Inkonsistenzen √ºberfl√ºssig und erleichtert das Schreiben von Code erheblich. </font><font style="vertical-align: inherit;">Die Anwendung muss lediglich alle Transaktionen wiederholen k√∂nnen, wenn ein Serialisierungsfehler auftritt. </font><font style="vertical-align: inherit;">Der Anteil unterbrochener Transaktionen, der zus√§tzliche Overhead und die Unf√§higkeit, Anforderungen zu parallelisieren, k√∂nnen jedoch den Systemdurchsatz erheblich reduzieren. </font><font style="vertical-align: inherit;">Beachten Sie au√üerdem, dass die serialisierbare Ebene nicht auf Replikate anwendbar ist und nicht mit anderen Isolationsstufen gemischt werden kann. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung folgt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442804/">https://habr.com/ru/post/de442804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442790/index.html">Die Registrierung f√ºr das Allure Server Meetup in St. Petersburg ist offen</a></li>
<li><a href="../de442794/index.html">Wir laden Sie zur Konferenz ‚Äû(IT) Architekt in IT-Projekten und -Organisationen‚Äú ein.</a></li>
<li><a href="../de442796/index.html">Umfrage: Cloud-Technologien in GIS- und Geodatendiensten</a></li>
<li><a href="../de442798/index.html">Das √úberwachen von Pings zwischen Kubernetes-Hosts ist unser Rezept</a></li>
<li><a href="../de442800/index.html">Einfacher Telegramm-Bot in Python in 30 Minuten</a></li>
<li><a href="../de442806/index.html">Das vorl√§ufige DUMP-2019-Programm ist fertig. Sprecher von Evil Martians, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../de442808/index.html">Wir laden Sie zur Droid Party ein - einem Treffen, das sich praktischen Fragen der Entwicklung von Android-Anwendungen und -Ger√§ten widmet</a></li>
<li><a href="../de442810/index.html">Mythen der Popul√§rphysik, Fortsetzung: Schwerkraft</a></li>
<li><a href="../de442812/index.html">"Ich sehe keinen Grund, Python f√ºr die Arbeit mit Spark zu verwenden, au√üer Faulheit."</a></li>
<li><a href="../de442814/index.html">10 Jahre sind vergangen und niemand hat herausgefunden, wie man die Blockchain benutzt. Und wieder hier?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>