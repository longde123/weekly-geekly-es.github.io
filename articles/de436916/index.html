<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏼 📷 👇🏼 VShard - horizontale Skalierung in Tarantool 👨🏿‍🏫 🦑 🔉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Vladislav, ich beteilige mich an der Entwicklung von Tarantool - DBMS und Anwendungsserver in einer Flasche. Und heute werde ich Ihnen e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VShard - horizontale Skalierung in Tarantool</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/436916/"><img src="https://habrastorage.org/webt/4p/e8/fo/4pe8foryc_t_l5joliydwpislhm.png"><br><br>  Mein Name ist Vladislav, ich beteilige mich an der Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool</a> - DBMS und Anwendungsserver in einer Flasche.  Und heute werde ich Ihnen erzählen, wie wir die horizontale Skalierung in Tarantool mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VShard-</a> Moduls <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementiert haben</a> . <br><a name="habracut"></a><br>  Zunächst eine kleine Theorie. <br><br>  Es gibt zwei Arten der Skalierung: horizontal und vertikal.  Horizontal wird in zwei Typen unterteilt: Replikation und Sharding.  Die Replikation wird zum Skalieren von Computern verwendet, das Sharding zum Skalieren von Daten. <br><br>  Sharding wird in zwei Typen unterteilt: Sharding nach Bereichen und Sharding nach Hashes. <br><br>  Beim Sharding mit Bereichen berechnen wir aus jedem Datensatz im Cluster einen Shard-Schlüssel.  Diese Shard-Schlüssel werden auf eine gerade Linie projiziert, die in Bereiche unterteilt ist, die wir verschiedenen physischen Knoten hinzufügen. <br><br>  Das Sharding mit Hashes ist einfacher: Von jedem Datensatz im Cluster, den wir als Hash-Funktion betrachten, fügen wir die Einträge mit demselben Wert der Hash-Funktion einem physischen Knoten hinzu. <br><br>  Ich werde über horizontale Skalierung mit Hash-Sharding sprechen. <br><br><h1>  Vorherige Implementierung </h1><br>  Das erste horizontale Skalierungsmodul, das wir hatten, war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Shard</a> .  Dies ist ein sehr einfaches Sharding durch Hashes, bei dem der Shard-Schlüssel aus dem Primärschlüssel aller Einträge im Cluster berücksichtigt wird. <br><br><pre><code class="plaintext hljs">function shard_function(primary_key) return guava(crc32(primary_key), shard_count) end</code> </pre> <br>  Aber dann entstand eine Aufgabe, die Tarantool Shard aus drei grundlegenden Gründen nicht bewältigen konnte. <br><br>  Erstens war die <b>Lokalität logisch verwandter Daten</b> erforderlich.  Wenn Daten logisch verbunden sind, möchten wir sie immer auf demselben physischen Knoten speichern, unabhängig davon, wie sich die Clustertopologie ändert oder der Ausgleich durchgeführt wird.  Und Tarantool Shard garantiert dies nicht.  Er betrachtet den Hash nur anhand von Primärschlüsseln, und beim Neuausgleich können sogar Datensätze mit demselben Hash für einige Zeit getrennt werden - die Übertragung ist nicht atomar. <br><br>  Das Problem der fehlenden Lokalität der Daten hat uns am meisten verhindert.  Ich werde ein Beispiel geben.  Es gibt eine Bank, bei der der Kunde ein Konto eröffnet hat.  Konto- und Kundendaten müssen immer physisch zusammen gespeichert werden, damit sie in einer Anfrage gelesen und in einer Transaktion ausgetauscht werden können, beispielsweise beim Überweisen von Geld von einem Konto.  Wenn Sie klassisches Sharding mit Tarantool Shard verwenden, unterscheiden sich die Werte der Shard-Funktionen für Konten und Kunden.  Daten können sich auf verschiedenen physischen Knoten befinden.  Dies erschwert sowohl das Lesen als auch die Transaktionsarbeit mit einem solchen Kunden erheblich. <br><br><pre> <code class="plaintext hljs">format = {{'id', 'unsigned'}, {'email', 'string'}} box.schema.create_space('customer', {format = format}) format = {{'id', 'unsigned'}, {'customer_id', 'unsigned'}, {'balance', 'number'}} box.schema.create_space('account', {format = format})</code> </pre><br>  Im obigen Beispiel können die <code>id</code> Felder leicht nicht mit Konten und Kunden übereinstimmen.  Sie sind über das Kontofeld <code>customer_id</code> und <code>customer_id</code> <code>id</code> .  Das gleiche <code>id</code> Feld würde die Eindeutigkeit des Konto-Primärschlüssels beeinträchtigen.  Und auf andere Weise kann Shard nicht scherben. <br><br>  Das nächste Problem ist das <b>langsame Resharding</b> .  Dies ist das klassische Problem aller Scherben auf Hashes.  Unter dem Strich ändern wir normalerweise die Shard-Funktion, wenn wir die Zusammensetzung eines Clusters ändern, da dies normalerweise von der Anzahl der Knoten abhängt.  Wenn sich die Funktion ändert, müssen Sie alle Einträge im Cluster durchgehen und die Shard-Funktion erneut neu berechnen.  Vielleicht ein paar Notizen übertragen.  Und während wir sie übertragen, wissen wir nicht, ob die Daten, die für die nächste eingehende Anforderung benötigt werden, bereits übertragen wurden. Vielleicht werden sie gerade übertragen.  Daher ist es während des Resharding erforderlich, dass bei jedem Lesen zwei Shard-Funktionen angefordert werden: die alte und die neue.  Anfragen werden doppelt so langsam und für uns war das inakzeptabel. <br><br>  Ein weiteres Merkmal von Tarantool Shard war, dass bei Ausfall einiger Knoten in den Replikatsätzen eine <b>schlechte Lesezugriffsfähigkeit</b> angezeigt wird. <br><br><h1>  Neue Lösung </h1><br>  Um die drei beschriebenen Probleme zu lösen, haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool VShard erstellt</a> .  Der Hauptunterschied besteht darin, dass die Datenspeicherebene virtualisiert wird: Virtuelle Speicher werden über physischen Speichern angezeigt, und Datensätze werden unter ihnen verteilt.  Diese Speicher werden Bucket'ami genannt.  Der Benutzer muss nicht darüber nachdenken, was und auf welchem ​​physischen Knoten liegt.  Bucket ist eine atomare unteilbare Dateneinheit, wie beim klassischen Sharding eines Tupels.  VShard speichert immer den gesamten Bucket auf einem physischen Knoten und überträgt beim Resharding alle Daten eines Buckets atomar.  Aus diesem Grund wird Lokalität zur Verfügung gestellt.  Wir müssen nur die Daten in einen Bucket packen und können immer sicher sein, dass diese Daten zusammen mit allen Änderungen im Cluster vorliegen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42e/a4f/87b/42ea4f87b5c0f0b05bdf0e0c75b356fe.png"><br><br>  Wie kann ich Daten in einen Eimer legen?  In dem Schema, das wir zuvor für den Bankkunden eingeführt haben, fügen wir die <code>bucket id</code> gemäß dem neuen Feld zu den Tabellen hinzu.  Wenn die verknüpften Daten identisch sind, befinden sich die Datensätze im selben Bucket.  Der Vorteil ist, dass wir diese Datensätze mit derselben <code>bucket id</code> in verschiedenen Räumen und sogar in verschiedenen Engines speichern können.  Die <code>bucket id</code> bereitgestellt, unabhängig davon, wie diese Datensätze gespeichert sind. <br><br><pre> <code class="plaintext hljs">format = {{'id', 'unsigned'}, {'email', 'string'}, {'bucket_id', 'unsigned'}} box.schema.create_space('customer', {format = format}) format = {{'id', 'unsigned'}, {'customer_id', 'unsigned'}, {'balance', 'number'}, {'bucket_id', 'unsigned'}} box.schema.create_space('account', {format = format})</code> </pre><br>  Warum sind wir so gespannt darauf?  Wenn wir klassisches Sharding haben, können sich die Daten über alle physischen Speicher erstrecken, die wir nur haben.  Wenn Sie im Beispiel mit der Bank alle Konten eines Kunden anfordern, müssen Sie sich an alle Knoten wenden.  Es stellt sich heraus, dass es schwierig ist, O (N) zu lesen, wobei N die Anzahl der physischen Speicher ist.  Schrecklich langsam. <br><br>  Dank Bucket'am und der Lokalität nach <code>bucket id</code> wir unabhängig von der Clustergröße immer Daten von einem Knoten in einer Anforderung lesen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2bb/524/8b7/2bb5248b7757ea6249f47a3dca46a681.png"><br><br>  Sie müssen die <code>bucket id</code> berechnen und dieselben Werte selbst zuweisen.  Für einige ist dies ein Vorteil, für jemanden ein Nachteil.  Ich halte es für einen Vorteil, dass Sie die Funktion zur Berechnung der <code>bucket id</code> selbst auswählen können. <br><br>  Was ist der Hauptunterschied zwischen klassischem Sharding und virtuellem Sharding mit Bucket? <br><br>  Im ersten Fall, wenn wir die Zusammensetzung des Clusters ändern, haben wir zwei Zustände: den aktuellen (alten) und den neuen, in den wir gehen müssen.  Während des Übergangsprozesses müssen Sie nicht nur die Daten übertragen, sondern auch die Hash-Funktionen für alle Datensätze neu berechnen.  Dies ist sehr unpraktisch, da wir zu einem bestimmten Zeitpunkt nicht wissen, welche Daten bereits übertragen wurden und welche nicht.  Darüber hinaus ist dies weder zuverlässig noch atomar, da für die atomare Übertragung eines Satzes von Datensätzen mit demselben Wert der Hash-Funktion der Übertragungsstatus dauerhaft gespeichert werden muss, falls eine Wiederherstellung erforderlich ist.  Es gibt Konflikte, Fehler, Sie müssen die Prozedur viele Male neu starten. <br><br>  Virtuelles Sharding ist viel einfacher.  Wir haben nicht zwei ausgewählte Zustände des Clusters, wir haben nur den Zustand des Buckets.  Der Cluster wird wendiger und bewegt sich allmählich von einem Zustand in einen anderen.  Und jetzt gibt es mehr als zwei Staaten.  Dank eines reibungslosen Übergangs können Sie das Guthaben im laufenden Betrieb ändern und den neu hinzugefügten Speicher löschen.  Das heißt, die Steuerbarkeit des Auswuchtens wird stark erhöht, es wird granular. <br><br><h1>  Verwenden Sie </h1><br>  Angenommen, wir haben eine Funktion für die <code>bucket id</code> und so viele Daten in den Cluster eingegeben, dass kein Speicherplatz mehr vorhanden war.  Jetzt möchten wir Knoten hinzufügen, damit die Daten selbst zu ihnen verschoben werden.  In VShard geschieht dies wie folgt.  Starten Sie zuerst neue Knoten und Tarantools und aktualisieren Sie dann die VShard-Konfiguration.  Es beschreibt alle Clustermitglieder, alle Replikate, Replikatsätze, Master, zugewiesenen URIs und vieles mehr.  Wir fügen der Konfiguration neue Knoten hinzu und verwenden sie mit der Funktion <code>VShard.storage.cfg</code> auf allen Knoten des Clusters. <br><br><pre> <code class="plaintext hljs">function create_user(email) local customer_id = next_id() local bucket_id = crc32(customer_id) box.space.customer:insert(customer_id, email, bucket_id) end function add_account(customer_id) local id = next_id() local bucket_id = crc32(customer_id) box.space.account:insert(id, customer_id, 0, bucket_id) end</code> </pre> <br>  Wie Sie sich erinnern, ändert sich beim klassischen Sharding mit einer Änderung der Anzahl der Knoten auch die Shard-Funktion.  In VShard passiert dies nicht, wir haben eine feste Anzahl von virtuellen Speichern - Bucket'ov.  Dies ist die Konstante, die Sie beim Starten des Clusters auswählen.  Aus diesem Grund scheint die Skalierbarkeit eingeschränkt zu sein, aber nicht wirklich.  Sie können eine große Anzahl von Bucket'ov, Zehntausenden und Hunderttausenden auswählen.  Die Hauptsache ist, dass mindestens zwei Größenordnungen mehr als die maximale Anzahl von Replikatsätzen vorhanden sein sollten, die Sie jemals im Cluster haben werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/422/499/979/422499979e5b8c5728c3df2b967cf599.gif"><br><br>  Da sich die Anzahl der virtuellen Speicher nicht ändert und die Shard-Funktion nur von diesem Wert abhängt, können wir so viele physische Speicher wie nötig hinzufügen, ohne die Shard-Funktion erneut anzugeben. <br><br>  Wie werden Bukets selbst auf physische Geschäfte verteilt?  Wenn VShard.storage.cfg auf einem der Knoten aufgerufen wird, wird der Neuausgleichsprozess aktiviert.  Dies ist ein Analyseprozess, der das perfekte Gleichgewicht in einem Cluster berechnet.  Er geht zu allen physischen Knoten, fragt, wer wie viele Bucket'ov hat, und erstellt Routen für ihre Bewegung, um die Verteilung zu mitteln.  Der Rebalancer sendet Routen zu überfüllten Lagern, und sie beginnen, Eimer zu senden.  Nach einiger Zeit wird der Cluster ausgeglichen. <br><br>  In realen Projekten kann das Konzept der perfekten Balance jedoch anders sein.  Ich möchte beispielsweise weniger Daten auf einem Replikatsatz als auf dem anderen speichern, da weniger Festplattenspeicher vorhanden ist.  VShard glaubt, dass alles gut ausbalanciert ist, und tatsächlich ist mein Speicher kurz vor dem Überlaufen.  Wir haben einen Mechanismus zum Anpassen der Ausgleichsregeln mithilfe von Gewichten bereitgestellt.  Jeder Replikatsatz und jedes Repository kann gewichtet werden.  Wenn der Balancer entscheidet, an wen er wie viele Eimer senden soll, berücksichtigt er die <b>Beziehung</b> aller Gewichtspaare. <br><br>  Zum Beispiel hat ein Geschäft ein Gewicht von 100 und das andere 200. Dann speichert das erste zweimal weniger Eimer als das zweite.  Bitte beachten Sie, dass ich speziell über das Gewichtsverhältnis spreche.  Absolute Bedeutungen haben keine Wirkung.  Sie können Gewichte basierend auf einer 100% -Clusterverteilung auswählen: Ein Geschäft hat 30%, ein anderes 70%.  Sie können die Speicherkapazität in Gigabyte als Basis verwenden oder die Gewichte in der Anzahl der Bucket'ov messen.  Die Hauptsache ist, die Einstellung zu beobachten, die Sie brauchen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4e/889/298/b4e889298991781b8c3ee01f4c066a6e.png"><br><br>  Ein solches System hat einen interessanten Nebeneffekt: Wenn Sie einem Geschäft ein Gewicht von Null zuweisen, befiehlt der Balancer dem Geschäft, alle seine Eimer zu verteilen.  Danach können Sie den gesamten Replikatsatz aus der Konfiguration entfernen. <br><br><h1>  Atomic Bucket Transfer </h1><br>  Wir haben einen Bucket, der Lese- und Schreibanforderungen akzeptiert, und dann fordert der Balancer auf, ihn in einen anderen Speicher zu übertragen.  Bucket akzeptiert keine Aufzeichnungsanforderungen mehr, andernfalls können sie diese während der Übertragung aktualisieren. Dann haben sie Zeit, das tragbare Update, dann das tragbare Update-Update usw. auf unendlich zu aktualisieren.  Daher ist der Datensatz blockiert und Sie können immer noch aus dem Bucket lesen.  Die Übertragung von Brocken an einen neuen Ort beginnt.  Nach Abschluss der Übertragung nimmt der Bucket erneut Anforderungen an.  An der alten Stelle liegt es auch noch, aber es wurde bereits als Müll markiert und anschließend wird es vom Müllsammler Stück für Stück gelöscht. <br><br>  Jeder Bucket ist Metadaten zugeordnet, die physisch auf der Festplatte gespeichert sind.  Alle oben genannten Schritte werden auf der Festplatte gespeichert. Unabhängig davon, was mit dem Repository geschieht, wird der Status des Buckets automatisch wiederhergestellt. <br><br>  Sie könnten Fragen haben: <br><br><ul><li>  <b>Was passiert mit den Anforderungen, die mit dem Bucket funktionierten, als sie mit dem Portieren begannen?</b> <br><br>  In den Metadaten jedes Buckets gibt es zwei Arten von Links: Lesen und Schreiben.  Wenn der Benutzer eine Anfrage an den Bucket stellt, gibt er an, wie er damit arbeiten, schreibgeschützt oder schreibgeschützt schreiben wird.  Für jede Anforderung wird der entsprechende Referenzzähler erhöht. <br><br>  Warum brauche ich einen Referenzzähler zum Lesen von Anfragen?  Angenommen, der Bucket wird leise übertragen, und hier kommt der Garbage Collector und möchte diesen Bucket löschen.  Er sieht, dass die Anzahl der Links größer als Null ist, sodass Sie sie nicht löschen können.  Und wenn die Anforderungen verarbeitet werden, kann der Garbage Collector seine Arbeit abschließen. <br><br>  Der Referenzzähler zum Schreiben von Anforderungen stellt sicher, dass der Bucket nicht einmal zu übertragen beginnt, während mindestens eine Schreibanforderung damit arbeitet.  Schreibanfragen können jedoch ständig eingehen, und dann wird der Eimer niemals übertragen.  Tatsache ist, dass, wenn der Balancer den Wunsch geäußert hat, ihn zu übertragen, neue Aufzeichnungsanforderungen blockiert werden und das aktuelle System auf den Abschluss einer Zeitüberschreitung wartet.  Wenn die Anforderungen nicht in der zugewiesenen Zeit abgeschlossen werden, akzeptiert das System erneut neue Schreibanforderungen und verschiebt die Übertragung des Buckets um einige Zeit.  Somit unternimmt der Balancer die Übertragungsversuche, bis einer erfolgreich ist. <br><br>  VShard verfügt über eine Bucket_Ref-API auf niedriger Ebene, falls Sie nur wenige Funktionen auf hoher Ebene haben.  Wenn Sie wirklich etwas selbst tun möchten, greifen Sie einfach über den Code auf diese API zu. </li><li>  <b>Ist es möglich, Datensätze überhaupt nicht zu blockieren?</b> <br><br>  Es ist unmöglich.  Wenn der Bucket wichtige Daten enthält, für die ein ständiger Schreibzugriff erforderlich ist, müssen Sie die Übertragung vollständig blockieren.  <code>bucket_pin</code> gibt es eine Funktion <code>bucket_pin</code> , die den Bucket fest mit dem aktuellen Replikatsatz verbindet und dessen Übertragung verhindert.  In diesem Fall kann sich der benachbarte Eimer ohne Einschränkungen bewegen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6a/848/fa7/b6a848fa775b0066ac6f69b73d97ed76.png"><br><br>  Es gibt ein Tool, das noch leistungsfähiger ist als <code>bucket_pin</code> - das Blockieren von Replikatsätzen.  Dies geschieht nicht mehr im Code, sondern durch Konfiguration.  Das Blockieren verbietet die Bewegung von Bucket'ov aus diesem Replikatset'a und den Empfang neuer.  Dementsprechend stehen alle Daten ständig zur Aufzeichnung zur Verfügung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/744/39c/65b74439c5b5743eda1168bdb320f8f4.png"></li></ul><br><h1>  VShard.router </h1><br>  VShard besteht aus zwei Submodulen: VShard.storage und VShard.router.  Sie können selbst in einer Instanz unabhängig erstellt und skaliert werden.  Beim Zugriff auf den Cluster wissen wir nicht, wo sich der Bucket befindet, und VShard.router sucht nach der <code>bucket id</code> für uns. <br><br>  Schauen wir uns ein Beispiel an, wie das aussieht.  Wir kehren zum Bankcluster und zu den Kundenkonten zurück.  Ich möchte in der Lage sein, alle Konten eines bestimmten Clients aus dem Cluster zu ziehen.  Dazu schreibe ich die übliche Funktion für die lokale Suche: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f78/e2b/df2/f78e2bdf2d977fcb9fb320b031592171.png"><br><br>  Sie sucht nach allen Kundenkonten anhand seiner ID.  Jetzt muss ich entscheiden, welches der Repositorys diese Funktion aufrufen soll.  Dazu berechne ich die <code>bucket id</code> aus der Client-ID in meiner Anfrage und fordere VShard.router auf, mir eine solche Funktion in dem Speicher aufzurufen, in dem der Bucket mit der resultierenden <code>bucket id</code> lebt.  Im Submodul befindet sich eine Routing-Tabelle, in der die Position des Buckets im Replikatsatz angegeben ist.  Und VShard.router vertritt meine Anfrage. <br><br>  Natürlich kann es vorkommen, dass zu diesem Zeitpunkt das Resharding begann und sich der Eimer in Bewegung setzte.  Der Router im Hintergrund aktualisiert die Tabelle schrittweise in großen Blöcken: Er fragt die Repositorys nach ihren aktuellen Bucket-Tabellen ab. <br><br>  Es kann sogar vorkommen, dass wir uns dem gerade verschobenen Bucket zuwenden und der Router seine Routing-Tabelle noch nicht aktualisiert hat.  Dann wendet er sich an das alte Repository und teilt dem Router entweder mit, wo er nach dem Bucket suchen soll, oder antwortet einfach, dass er nicht über die erforderlichen Daten verfügt.  Dann durchsucht der Router alle Speicher auf der Suche nach dem gewünschten Bucket.  Und das alles ist für uns transparent, wir werden nicht einmal einen Fehler in der Routing-Tabelle bemerken. <br><br><h1>  Instabilität lesen </h1><br>  Erinnern Sie sich daran, welche Probleme wir ursprünglich hatten: <br><br><ul><li>  Es gab keine Datenlokalität.  Wir haben uns entschieden, indem wir Bucket'ov hinzugefügt haben. </li><li>  Resharding verlangsamte alles und verlangsamte sich.  Implementierte Atomic Data Transfer Bucket'ami, wurde das Nacherzählen von Shard-Funktionen beseitigt. </li><li>  Instabiles Lesen. </li></ul><br>  Das letzte Problem wird von VShard.router mithilfe des automatischen Lesefailover-Subsystems gelöst. <br><br>  Der Router pingt regelmäßig den in der Konfiguration angegebenen Speicher an.  Und dann hörten einige von ihnen auf zu pingen.  Der Router verfügt über eine Hot-Backup-Verbindung zu jedem Replikat. Wenn das aktuelle Replikat nicht mehr reagiert, wird es zu einem anderen weitergeleitet.  Die Leseanforderung wird normal verarbeitet, da wir Replikate lesen (aber nicht schreiben) können.  Wir können die Priorität der Replikate festlegen, mit denen der Router das Failover für die Lesungen auswählen soll.  Wir machen das mit Zoning. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c3/5bf/dbd/5c35bfdbddd67fe8217f06730673bd43.png"><br><br>  Wir weisen jedem Replikat und jedem Router eine Zonennummer zu und legen eine Tabelle fest, in der wir den Abstand zwischen jedem Zonenpaar angeben.  Wenn der Router entscheidet, wohin eine Leseanforderung gesendet werden soll, wählt er ein Replikat in der Zone aus, die seiner eigenen am nächsten liegt. <br><br>  Wie es in der Konfiguration aussieht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/445/799/5ae/4457995ae5c7bc1761684cf7d4f3b2e4.png"><br><br>  Im allgemeinen Fall können Sie auf ein beliebiges Replikat verweisen. Wenn der Cluster jedoch groß und komplex und sehr verteilt ist, ist das Zoning sehr nützlich.  Verschiedene Server-Racks können Zonen sein, um das Netzwerk nicht mit Datenverkehr zu belasten.  Oder es können Punkte sein, die geografisch voneinander entfernt sind. <br><br>  Zoning hilft auch bei unterschiedlichen Replikationsleistungen.  Zum Beispiel haben wir in jedem Replikatsatz ein Sicherungsreplikat, das keine Anforderungen akzeptieren sollte, sondern nur eine Kopie der Daten speichert.  Dann schaffen wir es in der Zone, die sehr weit von allen Routern in der Tabelle entfernt ist, und sie werden sich im extremsten Fall daran wenden. <br><br><h1>  Instabilität der Aufnahme </h1><br>  Was ist mit dem Schreibfailover beim Ändern des Assistenten, da es sich um ein Lesefailover handelt?  Hier ist VShard nicht so rosig: Die Wahl eines neuen Meisters ist darin nicht umgesetzt, Sie müssen es selbst tun.  Wenn wir es irgendwie ausgewählt haben, ist es notwendig, dass diese Instanz jetzt die Autorität des Masters übernimmt.  Wir aktualisieren die Konfiguration, indem wir <code>master = false</code> für den alten Master und <code>master = true</code> für den neuen angeben. Wenden Sie sie über VShard.storage.cfg an und rollen Sie sie in den Speicher.  Dann passiert alles automatisch.  Der alte Master akzeptiert keine Schreibanforderungen mehr und beginnt mit der Synchronisierung mit dem neuen Master, da möglicherweise bereits Daten auf den alten Master angewendet wurden, der neue jedoch noch nicht eingetroffen ist.  Danach tritt der neue Master in die Rolle ein und beginnt, Anforderungen anzunehmen, und der alte Master wird zu einem Replikat.  So funktioniert Write Failover in VShard. <br><br><pre> <code class="plaintext hljs">replicas = new_cfg.sharding[uud].replicas replicas[old_master_uuid].master = false replicas[new_master_uuid].master = true vshard.storage.cfg(new_cfg)</code> </pre> <br><h1>  Wie kann man nun all diese verschiedenen Ereignisse verfolgen? </h1><br>  Im Allgemeinen reichen zwei Handles aus - <code>VShard.storage.info</code> und <code>VShard.router.info</code> . <br><br>  VShard.storage.info zeigt Informationen in mehreren Abschnitten an. <br><br><pre> <code class="plaintext hljs">vshard.storage.info() --- - replicasets: &lt;replicaset_2&gt;: uuid: &lt;replicaset_2&gt; master: uri: storage@127.0.0.1:3303 &lt;replicaset_1&gt;: uuid: &lt;replicaset_1&gt; master: missing bucket: receiving: 0 active: 0 total: 0 garbage: 0 pinned: 0 sending: 0 status: 2 replication: status: slave Alerts: - ['MISSING_MASTER', 'Master is not configured for ''replicaset &lt;replicaset_1&gt;']</code> </pre> <br>  Der erste ist der Replikationsabschnitt.  Der Status des Replikatsatzes, auf den Sie diese Funktion angewendet haben, wird angezeigt: Welche Replikationsverzögerung hat sie, mit wem hat sie Verbindungen und mit wem ist sie nicht verfügbar, wer ist verfügbar und nicht verfügbar, welcher Assistent ist für welche konfiguriert usw. <br><br>  Im Abschnitt Bucket können Sie in Echtzeit sehen, wie viele Bucket'ov derzeit auf das aktuelle Replikatset verschoben werden, wie viele es verlassen, wie viele derzeit daran arbeiten, wie viele als Müll markiert sind und wie viele angehängt sind. <br><br>  Der Alert-Bereich ist ein derartiges Durcheinander aller Probleme, die VShard unabhängig feststellen konnte: Der Master ist nicht konfiguriert, die Redundanzstufe ist unzureichend, der Master ist vorhanden und alle Replikate sind fehlgeschlagen usw. <br><br>  Und der letzte Abschnitt ist ein Licht, das rot leuchtet, wenn es wirklich schlimm wird.  Es ist eine Zahl von null bis drei, je mehr desto schlechter. <br><br>  VShard.router.info hat die gleichen Abschnitte, aber sie bedeuten etwas anders. <br><br><pre> <code class="plaintext hljs">vshard.router.info() --- - replicasets: &lt;replicaset_2&gt;: replica: &amp;0 status: available uri: storage@127.0.0.1:3303 uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7 bucket: available_rw: 500 uuid: &lt;replicaset_2&gt; master: *0 &lt;replicaset_1&gt;: replica: &amp;1 status: available uri: storage@127.0.0.1:3301 uuid: 8a274925-a26d-47fc-9e1b-af88ce939412 bucket: available_rw: 400 uuid: &lt;replicaset_1&gt; master: *1 bucket: unreachable: 0 available_ro: 800 unknown: 200 available_rw: 700 status: 1 alerts: - ['UNKNOWN_BUCKETS', '200 buckets are not discovered']</code> </pre> <br>  Der erste Abschnitt ist die Replikation.      ,    :    ,  replica set'  ,          ,   ,   replica set'  bucket'     ,     . <br><br>   Bucket    bucket',              ;    bucket'   ;  ,       replica set'. <br><br>   Alert,  ,   ,   failover,   bucket'. <br><br> ,         . <br><br><h1>     VShard? </h1><br>  —    bucket'.       <code>int32_max</code> ?     bucket'   —  30      16   .     bucket',     .           bucket',          bucket'.    ,          . <br><br>  —   -   <code>bucket id</code> .    ,    -   ,   bucket —           .      ,   bucket'   ,  VShard    bucket'.       -,      bucket'  bucket,  -.    . <br><br><h1>  Zusammenfassung </h1><br> Vshard : <br><br><ul><li>  ; </li><li>  ; </li><li>    ; </li><li>  read failover; </li><li>    bucket'. </li></ul><br> VShard   .  -    .  —  <b>   </b> .     ,       .           . <br><br>  — <b>lock-free  bucket'</b> .   ,       bucket'      .      ,     . <br><br>  — <b>  </b> .          : -    ,   ,    ?        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436916/">https://habr.com/ru/post/de436916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436904/index.html">32K-Schwellenwert für Daten im AVR-Mikrocontroller-ROM</a></li>
<li><a href="../de436908/index.html">6 Möglichkeiten, Daten in einer Android-Anwendung auszublenden</a></li>
<li><a href="../de436910/index.html">Tipps zum Erstellen benutzerdefinierter Workflows in GitLab CI</a></li>
<li><a href="../de436912/index.html">2019 CRM-Trends: Spaß beim Lesen, gefährlich zu glauben</a></li>
<li><a href="../de436914/index.html">Probleme mit dem Startwachstum - Überwachung</a></li>
<li><a href="../de436918/index.html">Erstellen eines Spiels für Game Boy, Teil 2</a></li>
<li><a href="../de436920/index.html">PAS2JS-Transpiler von Pascal nach JavaScript: Inkompatibel mit Delphi und Problemumgehungen</a></li>
<li><a href="../de436922/index.html">Optimieren der Startzeit von Prometheus 2.6.0 mit pprof</a></li>
<li><a href="../de436924/index.html">Ein paar Worte zur Organisation von Roboterwettbewerben</a></li>
<li><a href="../de436926/index.html">Helden der Zwei-Faktor-Authentifizierung oder wie man "in den Schuhen anderer läuft"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>