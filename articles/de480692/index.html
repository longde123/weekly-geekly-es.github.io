<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüåæ üë®üèª‚Äçüé§ üõ¥ MobX oder Redux: Was ist besser f√ºr das React State Management? üê§ üî™ üë∏üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In JavaScript ist die Zustandsverwaltung heutzutage ein hei√ües Thema. Wenn es um die Implementierung von State Management geht, ist es f√ºr Entwickler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MobX oder Redux: Was ist besser f√ºr das React State Management?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480692/"><img src="https://habrastorage.org/webt/ih/84/tp/ih84tp1bk6iwfgmeg5khccc2qrm.jpeg"><br><br>  In JavaScript ist die Zustandsverwaltung heutzutage ein hei√ües Thema.  Wenn es um die Implementierung von State Management geht, ist es f√ºr Entwickler h√§ufig eine Herausforderung, mit Code von Boilerplate in Redux umzugehen.  Daher hat sich MobX als eine gute Alternative zu Redux erwiesen, die dieselbe Funktionalit√§t mit weniger Code zum Schreiben bietet.  Beide Statusverwaltungstools funktionieren jedoch gut mit React. <br><br>  <b>Schauen wir uns zun√§chst die Gemeinsamkeiten an:</b> <br><br>  1) Beide unterst√ºtzen das Zeitreise-Debugging <br>  2) Beide enthalten Open-Source-Bibliotheken <br>  3) Beide bieten eine clientseitige Statusverwaltung <br>  4) Beide bieten enorme Unterst√ºtzung f√ºr native React-Frameworks <br><br>  In diesem Blog haben wir alle Vor- und Nachteile beider State-Management-L√∂sungen aufgelistet.  Es wird <a href="https://www.valuecoders.com/hire-developers/hire-web-app-developers" rel="nofollow">Webentwicklern</a> helfen, das beste f√ºr ihr n√§chstes Projekt auszuw√§hlen.  Bevor wir darauf eingehen, haben wir Redux und Mobx anhand der folgenden Parameter verglichen: <br><a name="habracut"></a><br>  -&gt; Wartung &amp; Skalierbar <br><br>  Aufgrund des Vorhandenseins reiner Funktionen und des funktionalen Programmierparadigmas ist Redux skalierbarer und wartbarer.  Mit Redux lassen sich die Dinge einfach steuern. <br><br>  -&gt; Debug-Prozess <br><br>  Das Debuggen in Redux ist im Vergleich zu MobX eine gute Erfahrung, da es hervorragende Entwicklertools bietet und weniger abstrahiert.  Mit dem Flussparadigma wird der Redux vorhersehbarer.  Auf der anderen Seite ist das Debuggen in MobX aufgrund von mehr Abstraktion und durchschnittlichen Entwicklertools sehr viel schwieriger. <br><br>  -&gt; Lernkurve <br><br>  Das Erlernen von MobX ist einfach, da es eine stetige Lernkurve aufweist.  Das Vorhandensein maximaler Abstraktion erleichtert das Lernen und JavaScript-Entwickler, die mit OOP-Konzepten vertraut sind, haben eine Hochburg in MobX.  Auf der anderen Seite verwendet Redux ein funktionales Programmierparadigma, das es schwierig macht, es auf Anhieb zu verstehen. <br><br>  -&gt; Gemeinschaft <br><br>  Redux hat im Vergleich zu MobX eine gro√üe Community-Basis.  Daher bietet Redux Entwicklern jederzeit und an jedem Ort gro√üartigen Community-Support. <br><br>  -&gt; Unrein vs rein <br><br>  MobX ist unrein, da die Zust√§nde √ºberschrieben werden k√∂nnen.  Hier k√∂nnen Sie einfach die Status mit den neuen Werten aktualisieren.  Redux ist jedoch rein, da es reine Funktionen verwendet.  Hier sind die Zust√§nde schreibgesch√ºtzt und k√∂nnen nicht direkt √ºberschrieben werden.  Der vorherige Status wird durch einen neuen Status ersetzt. <br><br>  -&gt; Observable vs plain data <br><br>  MobX verwendet eine Observable zum Speichern, w√§hrend Redux normale Javascript-Daten zum Speichern von Werten verwendet.  In Redux werden alle Updates manuell nachverfolgt. <br><br>  -&gt; Speichern <br><br>  In einem Gesch√§ft werden Daten abgelegt.  MobX hat mehr als ein Gesch√§ft, in dem diese Gesch√§fte logisch getrennt sind.  Auf der anderen Seite hat Redux ein gro√ües Gesch√§ft, in dem alle Zust√§nde gespeichert sind.  Die Daten werden normalerweise in Redux normalisiert und die Daten werden in MobX denormalisiert. <br><br>  <b>Redux vs MobX: Der Code-Vergleich</b> <br><br>  <b><u>Requisiten Injektion</u></b> <br><br>  Die connect () -Funktion von React-Redux wird verwendet, um Status und Aktionen an Requisiten in Redux zu √ºbergeben.  Es wird unten gezeigt: <br><br>  // auf Requisiten zugreifen <br><br><pre><code class="markdown hljs"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.contact}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">loading</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.loading}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onSubmit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.submit}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span></code> </pre> <br><br>  // Funktion zum Einspritzen des Zustands in Requisiten <br><br><pre> <code class="markdown hljs">function mapStateToProps(state) { return { contact: state.contactStore.contact, errors: state.contactStore.errors } }</code> </pre> <br><br>  // Injizieren von Status und Aktionen in Requisiten <br><br><pre> <code class="markdown hljs">export default connect(mapStateToProps, { newContact, saveContact, fetchContact, updateContact })(ContactFormPage);</code> </pre> <br><br>  In MobX wird inject verwendet, um die Auflistung der Stores zu injizieren.  Dadurch werden die L√§den in Requisiten verf√ºgbar.  Hier wird auf Status und Aktionen √ºber Eigenschaften im Gesch√§ftsobjekt zugegriffen, sodass sie nicht separat √ºbergeben werden m√ºssen. <br><br><pre> <code class="markdown hljs">@inject("stores") @observer // injecting store into props class ContactFormPage extends Component { ‚Ä¶ // accessing store via props const { contactStore:store } = this.props.stores; return ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">form</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.form}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store.entity}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> ) ‚Ä¶ }</code> </pre> <br><br>  Daher haben wir Redux-Connect-Dekoratoren verwendet, um den Redux-Code zu vereinfachen, und die MobX-Version ist immer leicht zu lesen.  Daher kein so klarer Gewinner. <br><br>  <b><u>Bootstrapping</u></b> <br><br>  In Redux definieren Sie zun√§chst den Store und die App wird √ºber den Provider √ºbergeben.  Um asynchrone Funktionen zu verarbeiten, m√ºssen Sie au√üerdem Redux-Thunk- und Redux-Promise-Middleware definieren.  Danach erm√∂glicht die Erweiterung redux-devtools das Debuggen des Speichers im Zeitreisemodus. <br><br><pre> <code class="markdown hljs">import { applyMiddleware, createStore } from "redux"; import thunk from "redux-thunk"; import promise from "redux-promise-middleware"; import { composeWithDevTools } from 'redux-devtools-extension'; import rootReducer from "./reducers"; const middleware = composeWithDevTools(applyMiddleware(promise(), thunk)); export default createStore(rootReducer, middleware);</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br>  In MobX werden mehrere Stores eingerichtet.  Es werden keine externen Bibliotheken f√ºr asynchrone Aktionen ben√∂tigt, sondern nur einige Codezeilen.  Sie ben√∂tigen mobx-remotedev, um das Debugging-Tool redux-devtools-extension anzuschlie√üen. <br><br><br><br><pre> <code class="markdown hljs">import remotedev from 'mobx-remotedev'; import Store from './store'; const contactConfig = { name:'Contact Store', global: true, onlyActions:true, filters: { whitelist: /fetch|update|create|Event|entity|entities|handleErrors/ } }; const contactStore = new Store('api/contacts'); const allStores = { contactStore: remotedev(contactStore, contactConfig) }; export default allStores;</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">stores</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{allStores}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br>  Die Menge des in beiden verwendeten Codes ist jedoch gleich.  MobX enth√§lt jedoch weniger Importanweisungen. <br><br>  <b><u>Definieren von Aktionen und Reduzierungen</u></b> <br><br>  Aktionen und Reduzierungen werden in Redux durch folgenden Code definiert: <br><br>  // Aktionen <br><br><pre> <code class="markdown hljs">export function fetchContacts(){ return dispatch =&gt; { dispatch({ type: 'FETCH_CONTACTS', payload: client.get(url) }) } }</code> </pre> <br><br>  // Reduzierungen <br><br><pre> <code class="markdown hljs">switch (action.type) { case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>FULFILLED': { return { ...state, contacts: action.payload.data.data || action.payload.data, loading: false, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>PENDING': { return { ...state, loading: true, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>REJECTED': { return { ...state, loading: false, errors: { global: action.payload.message } } } }</code> </pre> <br><br>  Die Logik f√ºr Action &amp; Reducer wird in einer Klasse in MobX erstellt.  Es wird OOP verwendet, aufgrund dessen die Store-Klasse √ºberarbeitet wird, um mithilfe des Klassenkonstruktors mehrere Stores zu erstellen.  Der entsprechende Code wird unten angezeigt: <br><br><pre> <code class="markdown hljs">@action fetchAll = async() =&gt; { this.loading = true; this.errors = {}; try { const response = await this.service.find({}) runInAction('entities fetched', () =&gt; { this.entities = response.data; this.loading = false; }); } catch(err) { this.handleErrors(err); } }</code> </pre> <br><br>  Wir haben also gesehen, dass die in beiden Zustandsverwaltungsl√∂sungen definierte Logik die gleiche Aufgabe erf√ºllt.  Der einzige Unterschied besteht darin, dass wir 33 Codezeilen in Redux und 14 Codezeilen in MobX verwendet haben, um das Ergebnis zu erzielen.  Daher k√∂nnen Sie mit MobX Apps schneller erstellen. <br><br>  <b>Warum MobX for React Apps verwenden?</b> <br><br>  MobX ist eine getestete Bibliothek, die das Statusmanagement einfach und skalierbar macht, indem funktionale reaktive Programmierung (TFRP) transparent angewendet wird.  React und MobX bilden eine leistungsstarke Kombination. <br><br><ul><li>  Weniger Code zum Schreiben </li><li>  Leicht zu erlernen </li><li>  Verschachtelte Daten sind einfach </li><li>  Unterst√ºtzung f√ºr objektorientierte Programmierung </li></ul><br><br>  <b>Warum nicht MobX benutzen?</b> <br><br><ul><li>  Schwer zu debuggen </li><li>  Bessere Alternativen vorhanden </li><li>  Gibt zu viel Freiheit </li></ul><br><br>  <b>Warum sollten Sie Redux f√ºr React-Apps verwenden?</b> <br><br>  Redux ist eine eigenst√§ndige Bibliothek, die mit UI-Frameworks wie Angular, Vue, Ember, React und Vanilla JS verwendet werden kann. <br><br><ul><li>  Erweiterbarkeit √ºber Middleware </li><li>  Popularit√§t &amp; Gemeinschaft </li><li>  Werkzeugunterst√ºtzung </li><li>  Vorhersehbarkeit und Einfachheit </li><li>  Unidirektionaler Datenfluss und Unver√§nderlichkeit </li><li>  Datentrennung &amp; Pr√§sentation </li></ul><br><br>  <b>Warum nicht Redux benutzen?</b> <br><br><ul><li>  Boilerplate (Reduzierungen, Selektoren, Ansichten, Aktionstypen, Aktionsersteller, ...) </li><li>  Aktionen werden von ihrer Wirkung getrennt (wie im Reduzierer definiert) </li><li>  Keine sofort einsatzbereite L√∂sung f√ºr den Umgang mit Nebenwirkungen (erh√§ltlich √ºber Middleware wie Redux-Thunk oder Redux-Saga) </li></ul><br><br>  <b>Schlussbemerkung:</b> <br><br>  Jetzt k√∂nnen Sie sehen, dass die MobX-Codebasis wesentlich agiler ist.  Mithilfe des OOP-Stils und guter Entwicklungspraktiken k√∂nnen Sie schnell React-Anwendungen erstellen.  Der Hauptnachteil ist, dass es sehr einfach ist, schlechten Code zu schreiben und nicht zu warten. <br><br>  Andererseits ist Redux sehr beliebt und eignet sich f√ºr den Bau gro√üer und komplexer Projekte.  Es ist ein strenger Rahmen mit Sicherheitsvorkehrungen, der sicherstellt, dass jeder Entwickler Code schreibt, der einfach zu testen und zu warten ist.  F√ºr kleine Projekte ist es jedoch nicht geeignet. <br><br>  Ich hoffe, ich habe gen√ºgend Informationen zur Verf√ºgung gestellt, um zu kl√§ren, ob ich auf MobX migrieren oder mit Redux fortfahren soll.  Letztendlich h√§ngt die Entscheidung von der Art des Projekts ab, an dem Sie arbeiten, und von den Ressourcen, die Ihnen zur Verf√ºgung stehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480692/">https://habr.com/ru/post/de480692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480680/index.html">NGINX Verteidigungsstrategie und Anfrage an Igor Sysoev</a></li>
<li><a href="../de480682/index.html">Intel RealSense LiDAR L515 - Ein weiteres neues RealSense</a></li>
<li><a href="../de480686/index.html">Warum ich plattform√ºbergreifende L√∂sungen in der mobilen Entwicklung abgelehnt habe</a></li>
<li><a href="../de480688/index.html">Woher kommen Mojibakes? Grundlagen der Kodierung</a></li>
<li><a href="../de480690/index.html">Zoll-Jalousien verwalten wir g√ºnstig</a></li>
<li><a href="../de480694/index.html">K√∂nnen wir aufh√∂ren, UX-Barrierefreiheit und -Bedienbarkeit anzurufen?</a></li>
<li><a href="../de480700/index.html">Wir verwenden console.log () in Chrome vollst√§ndig</a></li>
<li><a href="../de480702/index.html">HR und Talente, Experten und Kreative: Wie war das achte Habraseminar?</a></li>
<li><a href="../de480704/index.html">Reaktionsf√§higes Laden von Inhalten auf der Website</a></li>
<li><a href="../de480710/index.html">Refactoring von SFML-Spielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>