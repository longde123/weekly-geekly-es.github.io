<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🌾 👨🏻‍🎤 🛴 MobX oder Redux: Was ist besser für das React State Management? 🐤 🔪 👸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In JavaScript ist die Zustandsverwaltung heutzutage ein heißes Thema. Wenn es um die Implementierung von State Management geht, ist es für Entwickler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MobX oder Redux: Was ist besser für das React State Management?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480692/"><img src="https://habrastorage.org/webt/ih/84/tp/ih84tp1bk6iwfgmeg5khccc2qrm.jpeg"><br><br>  In JavaScript ist die Zustandsverwaltung heutzutage ein heißes Thema.  Wenn es um die Implementierung von State Management geht, ist es für Entwickler häufig eine Herausforderung, mit Code von Boilerplate in Redux umzugehen.  Daher hat sich MobX als eine gute Alternative zu Redux erwiesen, die dieselbe Funktionalität mit weniger Code zum Schreiben bietet.  Beide Statusverwaltungstools funktionieren jedoch gut mit React. <br><br>  <b>Schauen wir uns zunächst die Gemeinsamkeiten an:</b> <br><br>  1) Beide unterstützen das Zeitreise-Debugging <br>  2) Beide enthalten Open-Source-Bibliotheken <br>  3) Beide bieten eine clientseitige Statusverwaltung <br>  4) Beide bieten enorme Unterstützung für native React-Frameworks <br><br>  In diesem Blog haben wir alle Vor- und Nachteile beider State-Management-Lösungen aufgelistet.  Es wird <a href="https://www.valuecoders.com/hire-developers/hire-web-app-developers" rel="nofollow">Webentwicklern</a> helfen, das beste für ihr nächstes Projekt auszuwählen.  Bevor wir darauf eingehen, haben wir Redux und Mobx anhand der folgenden Parameter verglichen: <br><a name="habracut"></a><br>  -&gt; Wartung &amp; Skalierbar <br><br>  Aufgrund des Vorhandenseins reiner Funktionen und des funktionalen Programmierparadigmas ist Redux skalierbarer und wartbarer.  Mit Redux lassen sich die Dinge einfach steuern. <br><br>  -&gt; Debug-Prozess <br><br>  Das Debuggen in Redux ist im Vergleich zu MobX eine gute Erfahrung, da es hervorragende Entwicklertools bietet und weniger abstrahiert.  Mit dem Flussparadigma wird der Redux vorhersehbarer.  Auf der anderen Seite ist das Debuggen in MobX aufgrund von mehr Abstraktion und durchschnittlichen Entwicklertools sehr viel schwieriger. <br><br>  -&gt; Lernkurve <br><br>  Das Erlernen von MobX ist einfach, da es eine stetige Lernkurve aufweist.  Das Vorhandensein maximaler Abstraktion erleichtert das Lernen und JavaScript-Entwickler, die mit OOP-Konzepten vertraut sind, haben eine Hochburg in MobX.  Auf der anderen Seite verwendet Redux ein funktionales Programmierparadigma, das es schwierig macht, es auf Anhieb zu verstehen. <br><br>  -&gt; Gemeinschaft <br><br>  Redux hat im Vergleich zu MobX eine große Community-Basis.  Daher bietet Redux Entwicklern jederzeit und an jedem Ort großartigen Community-Support. <br><br>  -&gt; Unrein vs rein <br><br>  MobX ist unrein, da die Zustände überschrieben werden können.  Hier können Sie einfach die Status mit den neuen Werten aktualisieren.  Redux ist jedoch rein, da es reine Funktionen verwendet.  Hier sind die Zustände schreibgeschützt und können nicht direkt überschrieben werden.  Der vorherige Status wird durch einen neuen Status ersetzt. <br><br>  -&gt; Observable vs plain data <br><br>  MobX verwendet eine Observable zum Speichern, während Redux normale Javascript-Daten zum Speichern von Werten verwendet.  In Redux werden alle Updates manuell nachverfolgt. <br><br>  -&gt; Speichern <br><br>  In einem Geschäft werden Daten abgelegt.  MobX hat mehr als ein Geschäft, in dem diese Geschäfte logisch getrennt sind.  Auf der anderen Seite hat Redux ein großes Geschäft, in dem alle Zustände gespeichert sind.  Die Daten werden normalerweise in Redux normalisiert und die Daten werden in MobX denormalisiert. <br><br>  <b>Redux vs MobX: Der Code-Vergleich</b> <br><br>  <b><u>Requisiten Injektion</u></b> <br><br>  Die connect () -Funktion von React-Redux wird verwendet, um Status und Aktionen an Requisiten in Redux zu übergeben.  Es wird unten gezeigt: <br><br>  // auf Requisiten zugreifen <br><br><pre><code class="markdown hljs"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.contact}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">loading</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.loading}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onSubmit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.submit}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span></code> </pre> <br><br>  // Funktion zum Einspritzen des Zustands in Requisiten <br><br><pre> <code class="markdown hljs">function mapStateToProps(state) { return { contact: state.contactStore.contact, errors: state.contactStore.errors } }</code> </pre> <br><br>  // Injizieren von Status und Aktionen in Requisiten <br><br><pre> <code class="markdown hljs">export default connect(mapStateToProps, { newContact, saveContact, fetchContact, updateContact })(ContactFormPage);</code> </pre> <br><br>  In MobX wird inject verwendet, um die Auflistung der Stores zu injizieren.  Dadurch werden die Läden in Requisiten verfügbar.  Hier wird auf Status und Aktionen über Eigenschaften im Geschäftsobjekt zugegriffen, sodass sie nicht separat übergeben werden müssen. <br><br><pre> <code class="markdown hljs">@inject("stores") @observer // injecting store into props class ContactFormPage extends Component { … // accessing store via props const { contactStore:store } = this.props.stores; return ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">form</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.form}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store.entity}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> ) … }</code> </pre> <br><br>  Daher haben wir Redux-Connect-Dekoratoren verwendet, um den Redux-Code zu vereinfachen, und die MobX-Version ist immer leicht zu lesen.  Daher kein so klarer Gewinner. <br><br>  <b><u>Bootstrapping</u></b> <br><br>  In Redux definieren Sie zunächst den Store und die App wird über den Provider übergeben.  Um asynchrone Funktionen zu verarbeiten, müssen Sie außerdem Redux-Thunk- und Redux-Promise-Middleware definieren.  Danach ermöglicht die Erweiterung redux-devtools das Debuggen des Speichers im Zeitreisemodus. <br><br><pre> <code class="markdown hljs">import { applyMiddleware, createStore } from "redux"; import thunk from "redux-thunk"; import promise from "redux-promise-middleware"; import { composeWithDevTools } from 'redux-devtools-extension'; import rootReducer from "./reducers"; const middleware = composeWithDevTools(applyMiddleware(promise(), thunk)); export default createStore(rootReducer, middleware);</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br>  In MobX werden mehrere Stores eingerichtet.  Es werden keine externen Bibliotheken für asynchrone Aktionen benötigt, sondern nur einige Codezeilen.  Sie benötigen mobx-remotedev, um das Debugging-Tool redux-devtools-extension anzuschließen. <br><br><br><br><pre> <code class="markdown hljs">import remotedev from 'mobx-remotedev'; import Store from './store'; const contactConfig = { name:'Contact Store', global: true, onlyActions:true, filters: { whitelist: /fetch|update|create|Event|entity|entities|handleErrors/ } }; const contactStore = new Store('api/contacts'); const allStores = { contactStore: remotedev(contactStore, contactConfig) }; export default allStores;</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">stores</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{allStores}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br>  Die Menge des in beiden verwendeten Codes ist jedoch gleich.  MobX enthält jedoch weniger Importanweisungen. <br><br>  <b><u>Definieren von Aktionen und Reduzierungen</u></b> <br><br>  Aktionen und Reduzierungen werden in Redux durch folgenden Code definiert: <br><br>  // Aktionen <br><br><pre> <code class="markdown hljs">export function fetchContacts(){ return dispatch =&gt; { dispatch({ type: 'FETCH_CONTACTS', payload: client.get(url) }) } }</code> </pre> <br><br>  // Reduzierungen <br><br><pre> <code class="markdown hljs">switch (action.type) { case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>FULFILLED': { return { ...state, contacts: action.payload.data.data || action.payload.data, loading: false, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>PENDING': { return { ...state, loading: true, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>REJECTED': { return { ...state, loading: false, errors: { global: action.payload.message } } } }</code> </pre> <br><br>  Die Logik für Action &amp; Reducer wird in einer Klasse in MobX erstellt.  Es wird OOP verwendet, aufgrund dessen die Store-Klasse überarbeitet wird, um mithilfe des Klassenkonstruktors mehrere Stores zu erstellen.  Der entsprechende Code wird unten angezeigt: <br><br><pre> <code class="markdown hljs">@action fetchAll = async() =&gt; { this.loading = true; this.errors = {}; try { const response = await this.service.find({}) runInAction('entities fetched', () =&gt; { this.entities = response.data; this.loading = false; }); } catch(err) { this.handleErrors(err); } }</code> </pre> <br><br>  Wir haben also gesehen, dass die in beiden Zustandsverwaltungslösungen definierte Logik die gleiche Aufgabe erfüllt.  Der einzige Unterschied besteht darin, dass wir 33 Codezeilen in Redux und 14 Codezeilen in MobX verwendet haben, um das Ergebnis zu erzielen.  Daher können Sie mit MobX Apps schneller erstellen. <br><br>  <b>Warum MobX for React Apps verwenden?</b> <br><br>  MobX ist eine getestete Bibliothek, die das Statusmanagement einfach und skalierbar macht, indem funktionale reaktive Programmierung (TFRP) transparent angewendet wird.  React und MobX bilden eine leistungsstarke Kombination. <br><br><ul><li>  Weniger Code zum Schreiben </li><li>  Leicht zu erlernen </li><li>  Verschachtelte Daten sind einfach </li><li>  Unterstützung für objektorientierte Programmierung </li></ul><br><br>  <b>Warum nicht MobX benutzen?</b> <br><br><ul><li>  Schwer zu debuggen </li><li>  Bessere Alternativen vorhanden </li><li>  Gibt zu viel Freiheit </li></ul><br><br>  <b>Warum sollten Sie Redux für React-Apps verwenden?</b> <br><br>  Redux ist eine eigenständige Bibliothek, die mit UI-Frameworks wie Angular, Vue, Ember, React und Vanilla JS verwendet werden kann. <br><br><ul><li>  Erweiterbarkeit über Middleware </li><li>  Popularität &amp; Gemeinschaft </li><li>  Werkzeugunterstützung </li><li>  Vorhersehbarkeit und Einfachheit </li><li>  Unidirektionaler Datenfluss und Unveränderlichkeit </li><li>  Datentrennung &amp; Präsentation </li></ul><br><br>  <b>Warum nicht Redux benutzen?</b> <br><br><ul><li>  Boilerplate (Reduzierungen, Selektoren, Ansichten, Aktionstypen, Aktionsersteller, ...) </li><li>  Aktionen werden von ihrer Wirkung getrennt (wie im Reduzierer definiert) </li><li>  Keine sofort einsatzbereite Lösung für den Umgang mit Nebenwirkungen (erhältlich über Middleware wie Redux-Thunk oder Redux-Saga) </li></ul><br><br>  <b>Schlussbemerkung:</b> <br><br>  Jetzt können Sie sehen, dass die MobX-Codebasis wesentlich agiler ist.  Mithilfe des OOP-Stils und guter Entwicklungspraktiken können Sie schnell React-Anwendungen erstellen.  Der Hauptnachteil ist, dass es sehr einfach ist, schlechten Code zu schreiben und nicht zu warten. <br><br>  Andererseits ist Redux sehr beliebt und eignet sich für den Bau großer und komplexer Projekte.  Es ist ein strenger Rahmen mit Sicherheitsvorkehrungen, der sicherstellt, dass jeder Entwickler Code schreibt, der einfach zu testen und zu warten ist.  Für kleine Projekte ist es jedoch nicht geeignet. <br><br>  Ich hoffe, ich habe genügend Informationen zur Verfügung gestellt, um zu klären, ob ich auf MobX migrieren oder mit Redux fortfahren soll.  Letztendlich hängt die Entscheidung von der Art des Projekts ab, an dem Sie arbeiten, und von den Ressourcen, die Ihnen zur Verfügung stehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480692/">https://habr.com/ru/post/de480692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480680/index.html">NGINX Verteidigungsstrategie und Anfrage an Igor Sysoev</a></li>
<li><a href="../de480682/index.html">Intel RealSense LiDAR L515 - Ein weiteres neues RealSense</a></li>
<li><a href="../de480686/index.html">Warum ich plattformübergreifende Lösungen in der mobilen Entwicklung abgelehnt habe</a></li>
<li><a href="../de480688/index.html">Woher kommen Mojibakes? Grundlagen der Kodierung</a></li>
<li><a href="../de480690/index.html">Zoll-Jalousien verwalten wir günstig</a></li>
<li><a href="../de480694/index.html">Können wir aufhören, UX-Barrierefreiheit und -Bedienbarkeit anzurufen?</a></li>
<li><a href="../de480700/index.html">Wir verwenden console.log () in Chrome vollständig</a></li>
<li><a href="../de480702/index.html">HR und Talente, Experten und Kreative: Wie war das achte Habraseminar?</a></li>
<li><a href="../de480704/index.html">Reaktionsfähiges Laden von Inhalten auf der Website</a></li>
<li><a href="../de480710/index.html">Refactoring von SFML-Spielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>