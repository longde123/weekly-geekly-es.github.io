<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏻 🧀 👩🏽‍🎨 MVCC-3. Versions en ligne 🏖️ 👆🏿 🔆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons donc examiné les problèmes liés à l' isolement et fait une digression sur l' organisation des données à un faible niveau . Et enfin arrivé ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-3. Versions en ligne</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/445820/">  Nous avons donc examiné les problèmes liés à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> et fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des données à un faible niveau</a> .  Et enfin arrivé au plus intéressant - à la version des lignes. <br><br><h1>  Titre </h1><br>  Comme nous l'avons déjà dit, chaque ligne peut être simultanément présente dans la base de données en plusieurs versions.  Une version doit être distinguée de l'autre d'une manière ou d'une autre: à cet effet, chaque version a deux marques qui déterminent le "temps" de l'action de cette version (xmin et xmax).  Entre guillemets - car ce n'est pas le temps qui est utilisé comme tel, mais un compteur d'incrémentation spécial.  Et ce compteur est le numéro de transaction. <br><br>  (Comme d'habitude, c'est en fait plus compliqué: le numéro de transaction ne peut pas augmenter tout le temps en raison de la capacité en bits limitée du compteur. Mais nous examinerons ces détails en détail lorsque nous arriverons au gel.) <br><a name="habracut"></a><br>  Lorsque la ligne est créée, xmin est défini sur le numéro de la transaction qui a exécuté la commande INSERT et xmax n'est pas renseigné. <br><br>  Lorsqu'une ligne est supprimée, la valeur xmax de la version actuelle est marquée avec le numéro de transaction qui a effectué DELETE. <br><br>  Lorsqu'une ligne est modifiée avec la commande UPDATE, deux opérations sont réellement effectuées: DELETE et INSERT.  Dans la version actuelle de la ligne, xmax est défini comme égal au numéro de la transaction qui a effectué UPDATE.  Ensuite, une nouvelle version de la même ligne est créée;  sa valeur xmin correspond à la valeur xmax de la version précédente. <br><br>  Les champs xmin et xmax sont inclus dans l'en-tête de version de ligne.  En plus de ces champs, l'en-tête en contient d'autres, par exemple: <br><br><ul><li>  infomask - une série de bits définissant les propriétés de cette version.  Il y en a beaucoup;  les principaux que nous considérerons progressivement. </li><li>  ctid - un lien vers la prochaine version plus récente de la même ligne.  Dans la version la plus récente et la plus récente de la chaîne, ctid fait référence à cette version elle-même.  Le numéro a la forme (x, y), où x est le numéro de page, y est le numéro de série du pointeur dans le tableau. </li><li>  bitmap de valeurs non définies - marque les colonnes de cette version qui contiennent une valeur non définie (NULL).  NULL n'est pas l'une des valeurs habituelles des types de données, donc l'attribut doit être stocké séparément. </li></ul><br>  En conséquence, l'en-tête est assez volumineux - au moins 23 octets par version de la chaîne, et généralement plus en raison de la bitmap NULL.  Si le tableau est «étroit» (c'est-à-dire qu'il contient peu de colonnes), la surcharge peut prendre plus que des informations utiles. <br><br><h1>  Insérer </h1><br>  Examinons de plus près comment les opérations de chaîne sont effectuées à un niveau bas et commençons par l'insertion. <br><br>  Pour les expériences, créez une nouvelle table avec deux colonnes et un index sur l'une d'entre elles: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre> <br>  Insérez une ligne, après avoir démarré la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Voici le numéro de notre transaction en cours: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Jetez un œil au contenu de la page.  La fonction heap_page_items de l'extension pageinspect fournit des informations sur les pointeurs et les versions des lignes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Notez que le mot tas (tas) dans PostgreSQL fait référence aux tables.  C'est une autre utilisation étrange du terme - le tas est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structure de données</a> bien connue qui n'a rien à voir avec une table.  Ici, ce mot est utilisé dans le sens de «tout est empilé en tas», contrairement aux index ordonnés. <br><br>  La fonction affiche les données «telles quelles» dans un format difficile à lire.  Pour comprendre, nous ne laisserons qu'une partie des informations et les décrypterons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Voici ce que nous avons fait: <br><br><ul><li>  Nous avons ajouté un zéro au numéro d'index pour le mettre sous la même forme que t_ctid: (numéro de page, numéro d'index). </li><li>  Déchiffré l'état du pointeur lp_flags.  Ici, c'est «normal» - cela signifie que le pointeur fait vraiment référence à la version de la chaîne.  D'autres valeurs seront prises en compte ultérieurement. </li><li>  De tous les bits d'information, jusqu'à présent, seules deux paires ont été allouées.  Les bits xmin_committed et xmin_aborted indiquent si la transaction avec le numéro xmin est validée (annulée).  Deux bits similaires font référence au numéro de transaction xmax. </li></ul><br>  Que voyons-nous?  Lorsque vous insérez une ligne dans la page du tableau, un pointeur apparaît avec le numéro 1, faisant référence à la première et seule version de la ligne. <br><br>  Dans la version de la ligne, le champ xmin est rempli avec le numéro de la transaction en cours.  La transaction est toujours active, donc les bits xmin_committed et xmin_aborted ne sont pas définis. <br><br>  Le champ ctid de la version de ligne fait référence à la même ligne.  Cela signifie qu'une version plus récente n'existe pas. <br><br>  Le champ xmax est rempli d'un numéro fictif 0, car cette version de la ligne n'est pas supprimée et est pertinente.  Les transactions ne prêteront pas attention à ce nombre, car le bit xmax_aborted est défini. <br><br>  Faisons un pas de plus pour améliorer la lisibilité en ajoutant des bits d'information aux numéros de transaction.  Et nous allons créer une fonction, car nous aurons besoin de la demande plus d'une fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Dans ce formulaire, il est beaucoup plus clair ce qui se passe dans l'en-tête de la version de la chaîne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Des informations similaires, mais beaucoup moins détaillées, peuvent être obtenues à partir du tableau lui-même, en utilisant les pseudo-colonnes xmin et xmax: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Fixation </h1><br>  Une fois la transaction réussie, vous devez vous souvenir de son état - notez qu'elle est corrigée.  Pour ce faire, utilisez une structure appelée XACT (et avant la version 10, elle s'appelait CLOG (journal de validation) et ce nom peut toujours être trouvé à différents endroits). <br><br>  XACT n'est pas une table de catalogue système;  Ce sont les fichiers du répertoire PGDATA / pg_xact.  Dans ceux-ci, pour chaque transaction, deux bits sont alloués: validés et abandonnés - exactement les mêmes que dans l'en-tête de la version de la ligne.  Ces informations sont divisées en plusieurs fichiers uniquement pour des raisons de commodité, nous reviendrons sur ce problème lorsque nous envisagerons le gel.  Et le travail avec ces fichiers s'effectue page par page, comme avec tous les autres. <br><br>  Ainsi, lors de la validation d'une transaction dans XACT, le bit validé est défini pour cette transaction.  Et c'est tout ce qui se passe pendant le commit (bien que nous ne parlions pas encore du journal de pré-enregistrement). <br><br>  Lorsqu'une autre transaction accède à la page du tableau que nous venons de voir, elle devra répondre à quelques questions. <br><br><ol><li>  La transaction xmin est-elle terminée?  Sinon, la version générée de la chaîne ne doit pas être visible. <br>  Cette vérification est effectuée en examinant encore une autre structure, qui se trouve dans la mémoire partagée de l'instance et s'appelle ProcArray.  Il contient une liste de tous les processus actifs, et pour chacun le numéro de sa transaction actuelle (active) est indiqué. </li><li>  Une fois terminé, comment - par fixation ou annulation?  En cas d'annulation, la version de la chaîne ne devrait pas non plus être visible. <br>  C'est exactement à cela que sert XACT.  Mais, bien que les dernières pages XACT soient stockées dans des tampons en RAM, il n'est pas nécessaire de vérifier le XACT à chaque fois.  Par conséquent, le statut d'une transaction une fois clarifiée est enregistré dans les bits xmin_committed et xmin_aborted de la version de ligne.  Si l'un de ces bits est défini, l'état de la transaction xmin est considéré comme connu et la transaction suivante n'aura plus à accéder à XACT. </li></ol><br>  Pourquoi ces bits ne sont-ils pas définis par la transaction elle-même qui effectue l'insertion?  Lorsqu'une insertion se produit, la transaction ne sait pas encore si elle se terminera avec succès.  Et au moment de la correction, il n'est déjà pas clair quelles lignes dans quelles pages ont été modifiées.  Il peut y avoir de nombreuses pages de ce type, et les mémoriser est désavantageux.  De plus, une partie des pages peut être poussée hors du cache tampon vers le disque;  les relire pour changer les bits signifierait un ralentissement significatif de la validation. <br><br>  L'inconvénient des économies est qu'après les modifications, toute transaction (même en effectuant une simple lecture - SELECT) peut commencer à changer les pages de données dans le cache de tampon. <br><br>  Alors, corrigez le changement. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Rien n'a changé dans la page (mais nous savons que l'état de la transaction est déjà enregistré dans XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Maintenant, la transaction qui accède d'abord à la page devra déterminer l'état de la transaction xmin et l'écrire dans les bits d'information: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Effacer </h1><br>  Lorsqu'une ligne est supprimée, le numéro de la transaction de suppression en cours est enregistré dans le champ xmax de la version actuelle et le bit xmax_aborted est réinitialisé. <br><br>  Notez que la valeur xmax définie correspondant à la transaction active agit comme un verrou de ligne.  Si une autre transaction est sur le point de mettre à jour ou de supprimer cette ligne, elle sera obligée d'attendre la fin de la transaction xmax.  Nous parlerons plus en détail des verrous plus tard.  Pour l'instant, nous notons seulement que le nombre de verrous de ligne est illimité.  Ils n'occupent pas de place dans la RAM et les performances du système ne souffrent pas de leur quantité.  Certes, les transactions «longues» présentent d'autres inconvénients, mais nous en reparlerons plus tard. <br><br>  Supprimez la ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Nous voyons que le numéro de transaction est enregistré dans le champ xmax, mais les bits d'information ne sont pas définis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Annuler </h1><br>  L'inversion des modifications fonctionne de la même manière que la validation, uniquement dans XACT pour la transaction le bit abandonné est défini.  L'annulation est aussi rapide que la validation.  Bien que la commande soit appelée ROLLBACK, la modification n'est pas annulée: tout ce que la transaction a réussi à modifier dans les pages de données reste inchangé. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Lors de l'accès à la page, l'état sera vérifié et le bit de conseil xmax_aborted sera défini dans la version de la ligne.  Le nombre xmax lui-même reste dans la page, mais personne ne le regardera. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Mettre à jour </h1><br>  La mise à jour fonctionne comme si elle supprimait d'abord la version actuelle de la ligne, puis en insérait une nouvelle. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  La demande produit une ligne (nouvelle version): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Mais dans la page, nous voyons les deux versions: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  La version distante est marquée du numéro de transaction actuel dans le champ xmax.  De plus, cette valeur est écrite sur l'ancienne, puisque la transaction précédente a été annulée.  Et le bit xmax_aborted est réinitialisé, car le statut de la transaction en cours est encore inconnu. <br><br>  La première version de la ligne fait désormais référence à la seconde (champ t_ctid), en tant que plus récente. <br><br>  Un deuxième pointeur et une deuxième ligne apparaissent dans la page d'index, reliant à la deuxième version dans la page de table. <br><br>  Comme pour la suppression, la valeur xmax dans la première version de la chaîne est un signe que la chaîne est verrouillée. <br><br>  Eh bien, terminez la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Indices </h1><br>  Jusqu'à présent, nous n'avons parlé que des pages tabulaires.  Et que se passe-t-il à l'intérieur des indices? <br><br>  Les informations contenues dans les pages d'index dépendent fortement du type particulier d'index.  Et même un type d'index a différents types de pages.  Par exemple, l'arbre B a une page avec des métadonnées et des pages «normales». <br><br>  Cependant, une page a généralement un tableau de pointeurs vers les lignes et les lignes elles-mêmes (comme dans une page de tableau).  De plus, à la fin de la page, il y a une place pour les données spéciales. <br><br>  Les lignes dans les index peuvent également avoir une structure très différente selon le type d'index.  Par exemple, pour un arbre B, les lignes liées aux pages feuilles contiennent la valeur de la clé d'index et un lien (ctid) vers la ligne correspondante du tableau.  En général, un index peut être organisé de manière complètement différente. <br><br>  Le point le plus important est qu'il n'y a aucune version de ligne dans aucun type d'index.  Eh bien, ou nous pouvons supposer que chaque ligne est représentée par exactement une version.  En d'autres termes, il n'y a pas de champs xmin et xmax dans l'en-tête de la ligne d'index.  Nous pouvons supposer que les liens de l'index mènent à toutes les versions tabulaires des lignes - vous ne pouvez donc déterminer quelle version la transaction verra si vous regardez le tableau.  (Comme d'habitude, ce n'est pas toute la vérité. Dans certains cas, la carte de visibilité vous permet d'optimiser le processus, mais nous l'examinerons plus en détail plus tard.) <br><br>  Dans le même temps, dans la page d'index, nous trouvons des pointeurs vers les deux versions, à la fois actuelle et ancienne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transactions virtuelles </h1><br>  En pratique, PostgreSQL utilise des optimisations pour «enregistrer» les numéros de transaction. <br><br>  Si une transaction ne lit que des données, elle n'affecte pas la visibilité des versions de ligne.  Par conséquent, au début, le processus de desserte émet une transaction de numéro virtuel (xid virtuel).  Le numéro se compose d'un identifiant de processus et d'un numéro séquentiel. <br><br>  L'émission de ce numéro ne nécessite pas de synchronisation entre tous les processus et est donc très rapide.  Nous découvrirons une autre raison d'utiliser des numéros virtuels lorsque nous parlerons de gel. <br><br>  Les numéros virtuels ne sont pas pris en compte dans les instantanés de données. <br><br>  À différents moments, des transactions virtuelles avec des numéros déjà utilisés peuvent bien apparaître dans le système, ce qui est normal.  Mais un tel nombre ne peut pas être écrit sur les pages de données, car la prochaine fois que vous accédez à la page, il peut perdre tout son sens. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Si la transaction commence à modifier des données, un numéro de transaction réel et unique lui est attribué. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Transactions imbriquées </h1><br><h2>  Enregistrer des points </h2><br>  SQL définit des points de sauvegarde qui vous permettent d'annuler une partie d'une transaction sans l'interrompre complètement.  Mais cela ne rentre pas dans le schéma ci-dessus, car le statut d'une transaction est celui de toutes ses modifications, et physiquement aucune donnée n'est annulée. <br><br>  Pour implémenter une telle fonctionnalité, une transaction avec un point de sauvegarde est divisée en plusieurs <em>transactions imbriquées</em> distinctes (sous- <em>transaction</em> ), dont le statut peut être contrôlé séparément. <br><br>  Les transactions imbriquées ont leur propre numéro (supérieur au numéro de transaction principal).  Le statut des transactions imbriquées est enregistré de la manière habituelle dans XACT, cependant, le statut final dépend du statut de la transaction principale: si elle est annulée, toutes les transactions imbriquées sont également annulées. <br><br>  Les informations sur l'imbrication des transactions sont stockées dans des fichiers dans le répertoire PGDATA / pg_subtrans.  Les fichiers sont accessibles via des tampons dans la mémoire partagée de l'instance, organisés de la même manière que les tampons XACT. <br><br>  Ne confondez pas les transactions imbriquées et les transactions autonomes.  Les transactions autonomes ne dépendent en aucune manière les unes des autres, et les transactions imbriquées sont dépendantes.  Il n'y a pas de transactions autonomes dans PostgreSQL habituel, et peut-être pour le mieux: dans le cas où elles sont nécessaires très, très rarement, et leur présence dans d'autres SGBD provoque des abus, dont tout le monde souffre alors. <br><br>  Effacez la table, démarrez la transaction et insérez la ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Placez maintenant un point de sauvegarde et insérez une autre ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Notez que la fonction txid_current () renvoie le numéro de la transaction principale, non imbriquée. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Nous revenons au point de sauvegarde et insérons la troisième ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Dans la page, nous continuons de voir la ligne ajoutée par la transaction imbriquée annulée. <br><br>  Nous corrigeons les changements. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Vous pouvez maintenant voir clairement que chaque transaction imbriquée a son propre statut. <br><br>  Notez que les transactions imbriquées ne peuvent pas être utilisées explicitement dans SQL, c'est-à-dire que vous ne pouvez pas démarrer une nouvelle transaction sans terminer la transaction en cours.  Ce mécanisme est utilisé implicitement lors de l'utilisation de points de sauvegarde, ainsi que lors de la gestion des exceptions PL / pgSQL et dans un certain nombre d'autres cas plus exotiques. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Erreurs et atomicité des opérations </h2><br>  Que se passe-t-il si une erreur se produit pendant l'opération?  Par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Une erreur s'est produite.  Maintenant, la transaction est considérée comme abandonnée et aucune opération n'est autorisée: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Et même si vous essayez de valider les modifications, PostgreSQL signalera l'annulation: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Pourquoi ne puis-je pas continuer la transaction après un échec?  Le fait est qu'une erreur pourrait se produire afin que nous puissions accéder à une partie des changements - l'atomicité même pas de la transaction, mais l'opérateur serait violé.  Comme dans notre exemple, où l'opérateur a réussi à mettre à jour une ligne avant l'erreur: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Je dois dire que dans psql, il existe un mode qui vous permet toujours de continuer la transaction après un échec, comme si les actions de l'opérateur erroné étaient annulées. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Il est facile de deviner que dans ce mode, psql définit en fait un point de sauvegarde implicite devant chaque commande, et en cas d'échec, il lance une restauration.  Ce mode n'est pas utilisé par défaut, car la définition de points de sauvegarde (même sans y revenir) est associée à une surcharge importante. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À suivre.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445820/">https://habr.com/ru/post/fr445820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445804/index.html">Encapsulation pour de vrais samouraïs ou les nuances associées au mot-clé interne en C #</a></li>
<li><a href="../fr445806/index.html">Comment l'intelligence artificielle change la science</a></li>
<li><a href="../fr445808/index.html">Nous détestons et chassons: la vie dangereuse d'un pirate de virus qui se fait de puissants ennemis</a></li>
<li><a href="../fr445814/index.html">Comment un robot de livraison a changé les habitudes culinaires des étudiants américains</a></li>
<li><a href="../fr445816/index.html">Comment nous avons vu le rendu du serveur et ce qui en est ressorti</a></li>
<li><a href="../fr445822/index.html">Pourquoi Jaop? Pourquoi raquette?</a></li>
<li><a href="../fr445824/index.html">Génération de code dans Dart. Partie 1. Bases</a></li>
<li><a href="../fr445826/index.html">On marche sagement autour de la ville - 2: on fait le tour de la ville en rond en utilisant l'algorithme génétique</a></li>
<li><a href="../fr445828/index.html">Spectre solaire chinois</a></li>
<li><a href="../fr445832/index.html">Rayonnement: le tueur invisible et ses filles ou un peu sur le radon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>