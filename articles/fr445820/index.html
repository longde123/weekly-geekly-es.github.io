<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèª üßÄ üë©üèΩ‚Äçüé® MVCC-3. Versions en ligne üèñÔ∏è üëÜüèø üîÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons donc examin√© les probl√®mes li√©s √† l' isolement et fait une digression sur l' organisation des donn√©es √† un faible niveau . Et enfin arriv√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-3. Versions en ligne</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/445820/">  Nous avons donc examin√© les probl√®mes li√©s √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> et fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des donn√©es √† un faible niveau</a> .  Et enfin arriv√© au plus int√©ressant - √† la version des lignes. <br><br><h1>  Titre </h1><br>  Comme nous l'avons d√©j√† dit, chaque ligne peut √™tre simultan√©ment pr√©sente dans la base de donn√©es en plusieurs versions.  Une version doit √™tre distingu√©e de l'autre d'une mani√®re ou d'une autre: √† cet effet, chaque version a deux marques qui d√©terminent le "temps" de l'action de cette version (xmin et xmax).  Entre guillemets - car ce n'est pas le temps qui est utilis√© comme tel, mais un compteur d'incr√©mentation sp√©cial.  Et ce compteur est le num√©ro de transaction. <br><br>  (Comme d'habitude, c'est en fait plus compliqu√©: le num√©ro de transaction ne peut pas augmenter tout le temps en raison de la capacit√© en bits limit√©e du compteur. Mais nous examinerons ces d√©tails en d√©tail lorsque nous arriverons au gel.) <br><a name="habracut"></a><br>  Lorsque la ligne est cr√©√©e, xmin est d√©fini sur le num√©ro de la transaction qui a ex√©cut√© la commande INSERT et xmax n'est pas renseign√©. <br><br>  Lorsqu'une ligne est supprim√©e, la valeur xmax de la version actuelle est marqu√©e avec le num√©ro de transaction qui a effectu√© DELETE. <br><br>  Lorsqu'une ligne est modifi√©e avec la commande UPDATE, deux op√©rations sont r√©ellement effectu√©es: DELETE et INSERT.  Dans la version actuelle de la ligne, xmax est d√©fini comme √©gal au num√©ro de la transaction qui a effectu√© UPDATE.  Ensuite, une nouvelle version de la m√™me ligne est cr√©√©e;  sa valeur xmin correspond √† la valeur xmax de la version pr√©c√©dente. <br><br>  Les champs xmin et xmax sont inclus dans l'en-t√™te de version de ligne.  En plus de ces champs, l'en-t√™te en contient d'autres, par exemple: <br><br><ul><li>  infomask - une s√©rie de bits d√©finissant les propri√©t√©s de cette version.  Il y en a beaucoup;  les principaux que nous consid√©rerons progressivement. </li><li>  ctid - un lien vers la prochaine version plus r√©cente de la m√™me ligne.  Dans la version la plus r√©cente et la plus r√©cente de la cha√Æne, ctid fait r√©f√©rence √† cette version elle-m√™me.  Le num√©ro a la forme (x, y), o√π x est le num√©ro de page, y est le num√©ro de s√©rie du pointeur dans le tableau. </li><li>  bitmap de valeurs non d√©finies - marque les colonnes de cette version qui contiennent une valeur non d√©finie (NULL).  NULL n'est pas l'une des valeurs habituelles des types de donn√©es, donc l'attribut doit √™tre stock√© s√©par√©ment. </li></ul><br>  En cons√©quence, l'en-t√™te est assez volumineux - au moins 23 octets par version de la cha√Æne, et g√©n√©ralement plus en raison de la bitmap NULL.  Si le tableau est ¬´√©troit¬ª (c'est-√†-dire qu'il contient peu de colonnes), la surcharge peut prendre plus que des informations utiles. <br><br><h1>  Ins√©rer </h1><br>  Examinons de plus pr√®s comment les op√©rations de cha√Æne sont effectu√©es √† un niveau bas et commen√ßons par l'insertion. <br><br>  Pour les exp√©riences, cr√©ez une nouvelle table avec deux colonnes et un index sur l'une d'entre elles: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre> <br>  Ins√©rez une ligne, apr√®s avoir d√©marr√© la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Voici le num√©ro de notre transaction en cours: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Jetez un ≈ìil au contenu de la page.  La fonction heap_page_items de l'extension pageinspect fournit des informations sur les pointeurs et les versions des lignes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Notez que le mot tas (tas) dans PostgreSQL fait r√©f√©rence aux tables.  C'est une autre utilisation √©trange du terme - le tas est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structure de donn√©es</a> bien connue qui n'a rien √† voir avec une table.  Ici, ce mot est utilis√© dans le sens de ¬´tout est empil√© en tas¬ª, contrairement aux index ordonn√©s. <br><br>  La fonction affiche les donn√©es ¬´telles quelles¬ª dans un format difficile √† lire.  Pour comprendre, nous ne laisserons qu'une partie des informations et les d√©crypterons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Voici ce que nous avons fait: <br><br><ul><li>  Nous avons ajout√© un z√©ro au num√©ro d'index pour le mettre sous la m√™me forme que t_ctid: (num√©ro de page, num√©ro d'index). </li><li>  D√©chiffr√© l'√©tat du pointeur lp_flags.  Ici, c'est ¬´normal¬ª - cela signifie que le pointeur fait vraiment r√©f√©rence √† la version de la cha√Æne.  D'autres valeurs seront prises en compte ult√©rieurement. </li><li>  De tous les bits d'information, jusqu'√† pr√©sent, seules deux paires ont √©t√© allou√©es.  Les bits xmin_committed et xmin_aborted indiquent si la transaction avec le num√©ro xmin est valid√©e (annul√©e).  Deux bits similaires font r√©f√©rence au num√©ro de transaction xmax. </li></ul><br>  Que voyons-nous?  Lorsque vous ins√©rez une ligne dans la page du tableau, un pointeur appara√Æt avec le num√©ro 1, faisant r√©f√©rence √† la premi√®re et seule version de la ligne. <br><br>  Dans la version de la ligne, le champ xmin est rempli avec le num√©ro de la transaction en cours.  La transaction est toujours active, donc les bits xmin_committed et xmin_aborted ne sont pas d√©finis. <br><br>  Le champ ctid de la version de ligne fait r√©f√©rence √† la m√™me ligne.  Cela signifie qu'une version plus r√©cente n'existe pas. <br><br>  Le champ xmax est rempli d'un num√©ro fictif 0, car cette version de la ligne n'est pas supprim√©e et est pertinente.  Les transactions ne pr√™teront pas attention √† ce nombre, car le bit xmax_aborted est d√©fini. <br><br>  Faisons un pas de plus pour am√©liorer la lisibilit√© en ajoutant des bits d'information aux num√©ros de transaction.  Et nous allons cr√©er une fonction, car nous aurons besoin de la demande plus d'une fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Dans ce formulaire, il est beaucoup plus clair ce qui se passe dans l'en-t√™te de la version de la cha√Æne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Des informations similaires, mais beaucoup moins d√©taill√©es, peuvent √™tre obtenues √† partir du tableau lui-m√™me, en utilisant les pseudo-colonnes xmin et xmax: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Fixation </h1><br>  Une fois la transaction r√©ussie, vous devez vous souvenir de son √©tat - notez qu'elle est corrig√©e.  Pour ce faire, utilisez une structure appel√©e XACT (et avant la version 10, elle s'appelait CLOG (journal de validation) et ce nom peut toujours √™tre trouv√© √† diff√©rents endroits). <br><br>  XACT n'est pas une table de catalogue syst√®me;  Ce sont les fichiers du r√©pertoire PGDATA / pg_xact.  Dans ceux-ci, pour chaque transaction, deux bits sont allou√©s: valid√©s et abandonn√©s - exactement les m√™mes que dans l'en-t√™te de la version de la ligne.  Ces informations sont divis√©es en plusieurs fichiers uniquement pour des raisons de commodit√©, nous reviendrons sur ce probl√®me lorsque nous envisagerons le gel.  Et le travail avec ces fichiers s'effectue page par page, comme avec tous les autres. <br><br>  Ainsi, lors de la validation d'une transaction dans XACT, le bit valid√© est d√©fini pour cette transaction.  Et c'est tout ce qui se passe pendant le commit (bien que nous ne parlions pas encore du journal de pr√©-enregistrement). <br><br>  Lorsqu'une autre transaction acc√®de √† la page du tableau que nous venons de voir, elle devra r√©pondre √† quelques questions. <br><br><ol><li>  La transaction xmin est-elle termin√©e?  Sinon, la version g√©n√©r√©e de la cha√Æne ne doit pas √™tre visible. <br>  Cette v√©rification est effectu√©e en examinant encore une autre structure, qui se trouve dans la m√©moire partag√©e de l'instance et s'appelle ProcArray.  Il contient une liste de tous les processus actifs, et pour chacun le num√©ro de sa transaction actuelle (active) est indiqu√©. </li><li>  Une fois termin√©, comment - par fixation ou annulation?  En cas d'annulation, la version de la cha√Æne ne devrait pas non plus √™tre visible. <br>  C'est exactement √† cela que sert XACT.  Mais, bien que les derni√®res pages XACT soient stock√©es dans des tampons en RAM, il n'est pas n√©cessaire de v√©rifier le XACT √† chaque fois.  Par cons√©quent, le statut d'une transaction une fois clarifi√©e est enregistr√© dans les bits xmin_committed et xmin_aborted de la version de ligne.  Si l'un de ces bits est d√©fini, l'√©tat de la transaction xmin est consid√©r√© comme connu et la transaction suivante n'aura plus √† acc√©der √† XACT. </li></ol><br>  Pourquoi ces bits ne sont-ils pas d√©finis par la transaction elle-m√™me qui effectue l'insertion?  Lorsqu'une insertion se produit, la transaction ne sait pas encore si elle se terminera avec succ√®s.  Et au moment de la correction, il n'est d√©j√† pas clair quelles lignes dans quelles pages ont √©t√© modifi√©es.  Il peut y avoir de nombreuses pages de ce type, et les m√©moriser est d√©savantageux.  De plus, une partie des pages peut √™tre pouss√©e hors du cache tampon vers le disque;  les relire pour changer les bits signifierait un ralentissement significatif de la validation. <br><br>  L'inconv√©nient des √©conomies est qu'apr√®s les modifications, toute transaction (m√™me en effectuant une simple lecture - SELECT) peut commencer √† changer les pages de donn√©es dans le cache de tampon. <br><br>  Alors, corrigez le changement. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Rien n'a chang√© dans la page (mais nous savons que l'√©tat de la transaction est d√©j√† enregistr√© dans XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Maintenant, la transaction qui acc√®de d'abord √† la page devra d√©terminer l'√©tat de la transaction xmin et l'√©crire dans les bits d'information: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Effacer </h1><br>  Lorsqu'une ligne est supprim√©e, le num√©ro de la transaction de suppression en cours est enregistr√© dans le champ xmax de la version actuelle et le bit xmax_aborted est r√©initialis√©. <br><br>  Notez que la valeur xmax d√©finie correspondant √† la transaction active agit comme un verrou de ligne.  Si une autre transaction est sur le point de mettre √† jour ou de supprimer cette ligne, elle sera oblig√©e d'attendre la fin de la transaction xmax.  Nous parlerons plus en d√©tail des verrous plus tard.  Pour l'instant, nous notons seulement que le nombre de verrous de ligne est illimit√©.  Ils n'occupent pas de place dans la RAM et les performances du syst√®me ne souffrent pas de leur quantit√©.  Certes, les transactions ¬´longues¬ª pr√©sentent d'autres inconv√©nients, mais nous en reparlerons plus tard. <br><br>  Supprimez la ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Nous voyons que le num√©ro de transaction est enregistr√© dans le champ xmax, mais les bits d'information ne sont pas d√©finis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Annuler </h1><br>  L'inversion des modifications fonctionne de la m√™me mani√®re que la validation, uniquement dans XACT pour la transaction le bit abandonn√© est d√©fini.  L'annulation est aussi rapide que la validation.  Bien que la commande soit appel√©e ROLLBACK, la modification n'est pas annul√©e: tout ce que la transaction a r√©ussi √† modifier dans les pages de donn√©es reste inchang√©. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Lors de l'acc√®s √† la page, l'√©tat sera v√©rifi√© et le bit de conseil xmax_aborted sera d√©fini dans la version de la ligne.  Le nombre xmax lui-m√™me reste dans la page, mais personne ne le regardera. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Mettre √† jour </h1><br>  La mise √† jour fonctionne comme si elle supprimait d'abord la version actuelle de la ligne, puis en ins√©rait une nouvelle. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  La demande produit une ligne (nouvelle version): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Mais dans la page, nous voyons les deux versions: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  La version distante est marqu√©e du num√©ro de transaction actuel dans le champ xmax.  De plus, cette valeur est √©crite sur l'ancienne, puisque la transaction pr√©c√©dente a √©t√© annul√©e.  Et le bit xmax_aborted est r√©initialis√©, car le statut de la transaction en cours est encore inconnu. <br><br>  La premi√®re version de la ligne fait d√©sormais r√©f√©rence √† la seconde (champ t_ctid), en tant que plus r√©cente. <br><br>  Un deuxi√®me pointeur et une deuxi√®me ligne apparaissent dans la page d'index, reliant √† la deuxi√®me version dans la page de table. <br><br>  Comme pour la suppression, la valeur xmax dans la premi√®re version de la cha√Æne est un signe que la cha√Æne est verrouill√©e. <br><br>  Eh bien, terminez la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Indices </h1><br>  Jusqu'√† pr√©sent, nous n'avons parl√© que des pages tabulaires.  Et que se passe-t-il √† l'int√©rieur des indices? <br><br>  Les informations contenues dans les pages d'index d√©pendent fortement du type particulier d'index.  Et m√™me un type d'index a diff√©rents types de pages.  Par exemple, l'arbre B a une page avec des m√©tadonn√©es et des pages ¬´normales¬ª. <br><br>  Cependant, une page a g√©n√©ralement un tableau de pointeurs vers les lignes et les lignes elles-m√™mes (comme dans une page de tableau).  De plus, √† la fin de la page, il y a une place pour les donn√©es sp√©ciales. <br><br>  Les lignes dans les index peuvent √©galement avoir une structure tr√®s diff√©rente selon le type d'index.  Par exemple, pour un arbre B, les lignes li√©es aux pages feuilles contiennent la valeur de la cl√© d'index et un lien (ctid) vers la ligne correspondante du tableau.  En g√©n√©ral, un index peut √™tre organis√© de mani√®re compl√®tement diff√©rente. <br><br>  Le point le plus important est qu'il n'y a aucune version de ligne dans aucun type d'index.  Eh bien, ou nous pouvons supposer que chaque ligne est repr√©sent√©e par exactement une version.  En d'autres termes, il n'y a pas de champs xmin et xmax dans l'en-t√™te de la ligne d'index.  Nous pouvons supposer que les liens de l'index m√®nent √† toutes les versions tabulaires des lignes - vous ne pouvez donc d√©terminer quelle version la transaction verra si vous regardez le tableau.  (Comme d'habitude, ce n'est pas toute la v√©rit√©. Dans certains cas, la carte de visibilit√© vous permet d'optimiser le processus, mais nous l'examinerons plus en d√©tail plus tard.) <br><br>  Dans le m√™me temps, dans la page d'index, nous trouvons des pointeurs vers les deux versions, √† la fois actuelle et ancienne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transactions virtuelles </h1><br>  En pratique, PostgreSQL utilise des optimisations pour ¬´enregistrer¬ª les num√©ros de transaction. <br><br>  Si une transaction ne lit que des donn√©es, elle n'affecte pas la visibilit√© des versions de ligne.  Par cons√©quent, au d√©but, le processus de desserte √©met une transaction de num√©ro virtuel (xid virtuel).  Le num√©ro se compose d'un identifiant de processus et d'un num√©ro s√©quentiel. <br><br>  L'√©mission de ce num√©ro ne n√©cessite pas de synchronisation entre tous les processus et est donc tr√®s rapide.  Nous d√©couvrirons une autre raison d'utiliser des num√©ros virtuels lorsque nous parlerons de gel. <br><br>  Les num√©ros virtuels ne sont pas pris en compte dans les instantan√©s de donn√©es. <br><br>  √Ä diff√©rents moments, des transactions virtuelles avec des num√©ros d√©j√† utilis√©s peuvent bien appara√Ætre dans le syst√®me, ce qui est normal.  Mais un tel nombre ne peut pas √™tre √©crit sur les pages de donn√©es, car la prochaine fois que vous acc√©dez √† la page, il peut perdre tout son sens. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Si la transaction commence √† modifier des donn√©es, un num√©ro de transaction r√©el et unique lui est attribu√©. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Transactions imbriqu√©es </h1><br><h2>  Enregistrer des points </h2><br>  SQL d√©finit des points de sauvegarde qui vous permettent d'annuler une partie d'une transaction sans l'interrompre compl√®tement.  Mais cela ne rentre pas dans le sch√©ma ci-dessus, car le statut d'une transaction est celui de toutes ses modifications, et physiquement aucune donn√©e n'est annul√©e. <br><br>  Pour impl√©menter une telle fonctionnalit√©, une transaction avec un point de sauvegarde est divis√©e en plusieurs <em>transactions imbriqu√©es</em> distinctes (sous- <em>transaction</em> ), dont le statut peut √™tre contr√¥l√© s√©par√©ment. <br><br>  Les transactions imbriqu√©es ont leur propre num√©ro (sup√©rieur au num√©ro de transaction principal).  Le statut des transactions imbriqu√©es est enregistr√© de la mani√®re habituelle dans XACT, cependant, le statut final d√©pend du statut de la transaction principale: si elle est annul√©e, toutes les transactions imbriqu√©es sont √©galement annul√©es. <br><br>  Les informations sur l'imbrication des transactions sont stock√©es dans des fichiers dans le r√©pertoire PGDATA / pg_subtrans.  Les fichiers sont accessibles via des tampons dans la m√©moire partag√©e de l'instance, organis√©s de la m√™me mani√®re que les tampons XACT. <br><br>  Ne confondez pas les transactions imbriqu√©es et les transactions autonomes.  Les transactions autonomes ne d√©pendent en aucune mani√®re les unes des autres, et les transactions imbriqu√©es sont d√©pendantes.  Il n'y a pas de transactions autonomes dans PostgreSQL habituel, et peut-√™tre pour le mieux: dans le cas o√π elles sont n√©cessaires tr√®s, tr√®s rarement, et leur pr√©sence dans d'autres SGBD provoque des abus, dont tout le monde souffre alors. <br><br>  Effacez la table, d√©marrez la transaction et ins√©rez la ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Placez maintenant un point de sauvegarde et ins√©rez une autre ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Notez que la fonction txid_current () renvoie le num√©ro de la transaction principale, non imbriqu√©e. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Nous revenons au point de sauvegarde et ins√©rons la troisi√®me ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Dans la page, nous continuons de voir la ligne ajout√©e par la transaction imbriqu√©e annul√©e. <br><br>  Nous corrigeons les changements. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Vous pouvez maintenant voir clairement que chaque transaction imbriqu√©e a son propre statut. <br><br>  Notez que les transactions imbriqu√©es ne peuvent pas √™tre utilis√©es explicitement dans SQL, c'est-√†-dire que vous ne pouvez pas d√©marrer une nouvelle transaction sans terminer la transaction en cours.  Ce m√©canisme est utilis√© implicitement lors de l'utilisation de points de sauvegarde, ainsi que lors de la gestion des exceptions PL / pgSQL et dans un certain nombre d'autres cas plus exotiques. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Erreurs et atomicit√© des op√©rations </h2><br>  Que se passe-t-il si une erreur se produit pendant l'op√©ration?  Par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Une erreur s'est produite.  Maintenant, la transaction est consid√©r√©e comme abandonn√©e et aucune op√©ration n'est autoris√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Et m√™me si vous essayez de valider les modifications, PostgreSQL signalera l'annulation: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Pourquoi ne puis-je pas continuer la transaction apr√®s un √©chec?  Le fait est qu'une erreur pourrait se produire afin que nous puissions acc√©der √† une partie des changements - l'atomicit√© m√™me pas de la transaction, mais l'op√©rateur serait viol√©.  Comme dans notre exemple, o√π l'op√©rateur a r√©ussi √† mettre √† jour une ligne avant l'erreur: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Je dois dire que dans psql, il existe un mode qui vous permet toujours de continuer la transaction apr√®s un √©chec, comme si les actions de l'op√©rateur erron√© √©taient annul√©es. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Il est facile de deviner que dans ce mode, psql d√©finit en fait un point de sauvegarde implicite devant chaque commande, et en cas d'√©chec, il lance une restauration.  Ce mode n'est pas utilis√© par d√©faut, car la d√©finition de points de sauvegarde (m√™me sans y revenir) est associ√©e √† une surcharge importante. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445820/">https://habr.com/ru/post/fr445820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445804/index.html">Encapsulation pour de vrais samoura√Øs ou les nuances associ√©es au mot-cl√© interne en C #</a></li>
<li><a href="../fr445806/index.html">Comment l'intelligence artificielle change la science</a></li>
<li><a href="../fr445808/index.html">Nous d√©testons et chassons: la vie dangereuse d'un pirate de virus qui se fait de puissants ennemis</a></li>
<li><a href="../fr445814/index.html">Comment un robot de livraison a chang√© les habitudes culinaires des √©tudiants am√©ricains</a></li>
<li><a href="../fr445816/index.html">Comment nous avons vu le rendu du serveur et ce qui en est ressorti</a></li>
<li><a href="../fr445822/index.html">Pourquoi Jaop? Pourquoi raquette?</a></li>
<li><a href="../fr445824/index.html">G√©n√©ration de code dans Dart. Partie 1. Bases</a></li>
<li><a href="../fr445826/index.html">On marche sagement autour de la ville - 2: on fait le tour de la ville en rond en utilisant l'algorithme g√©n√©tique</a></li>
<li><a href="../fr445828/index.html">Spectre solaire chinois</a></li>
<li><a href="../fr445832/index.html">Rayonnement: le tueur invisible et ses filles ou un peu sur le radon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>