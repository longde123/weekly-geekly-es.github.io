<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö≤ üëÜüèø üßëüèæ‚Äçü§ù‚Äçüßëüèæ Los fundamentos de la programaci√≥n reactiva con RxJS. Parte 3. Observables de orden superior üçö ‚òùüèº üóΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo veremos c√≥mo es posible procesar otro en un hilo, por qu√© es necesario y c√≥mo los operadores de Observaci√≥n de orden superior (en lo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los fundamentos de la programaci√≥n reactiva con RxJS. Parte 3. Observables de orden superior</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450050/"><img src="https://habrastorage.org/webt/kk/rj/yw/kkrjywqpfptl1uta2ou9bltd-je.png"><br><br>  En este art√≠culo veremos c√≥mo es posible procesar otro en un hilo, por qu√© es necesario y c√≥mo los operadores de Observaci√≥n de orden superior (en lo sucesivo, HOO) nos ayudar√°n en esto. <br><br>  Serie de art√≠culos "Fundamentos de la programaci√≥n reactiva con RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1. Reactividad y flujos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Operadores y tuber√≠as.</a> </li></ul><br><br>  Cuando se trabaja con hilos, a menudo surge una situaci√≥n en la que es necesario transferir los resultados de otro a un hilo como valor.  Por ejemplo, queremos ejecutar una solicitud ajax y procesar su respuesta en el hilo actual, o ejecutar varias solicitudes paralelas, implementar la agrupaci√≥n.  Creo que muchas personas est√°n acostumbradas a resolver estos problemas utilizando un mecanismo como la promesa.  ¬øPero es posible resolverlos usando RxJS?  ¬°Por supuesto, y todo es mucho m√°s f√°cil de lo que piensas! <br><a name="habracut"></a><br>  <b>Nota</b> : para comprender la parte te√≥rica del art√≠culo, no es necesario que lea los art√≠culos anteriores, solo necesita saber qu√© son observables, operadores y tuber√≠as.  En la parte pr√°ctica, refinaremos el ejemplo del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo art√≠culo</a> , que puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aqu√≠</a> . <br><br><h4>  El problema </h4><br>  Imaginemos la siguiente tarea: necesitamos averiguar cada segundo si el servidor es accesible.  ¬øC√≥mo podemos resolverlo? <br><br>  Primero, cree una secuencia utilizando el m√©todo del temporizador: <br><br><pre><code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre> <br>  El m√©todo del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">temporizador</a> es muy similar en principio al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">intervalo</a> .  Pero a diferencia de esto, le permite establecer el tiempo de espera de inicio del subproceso, que se transmite por el primer par√°metro.  El segundo par√°metro indica el intervalo a trav√©s del cual se generar√° un nuevo valor.  Si no se especifica el segundo par√°metro, el temporizador generar√° solo un valor y terminar√° la transmisi√≥n. <br><br>  Como usted y yo no tenemos un servidor, sugiero escribir una funci√≥n que emule una solicitud al servidor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> makeRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mapTo(<span class="hljs-string"><span class="hljs-string">'success'</span></span>) ) }</code> </pre><br>  ¬øQu√© hace este m√©todo?  Devuelve una secuencia creada utilizando el m√©todo del temporizador, que emite un valor despu√©s de que un segundo ha pasado y termina.  Dado que el m√©todo del temporizador solo genera un n√∫mero, utilizamos el operador mapTo para reemplazarlo con la cadena "√©xito". <br><br>  As√≠ es como se ve la secuencia creada por el m√©todo makeRequest: <br><br><img src="https://habrastorage.org/webt/5t/0a/pf/5t0apfljjo-5lc9buhsd9455mrk.png"><br><br>  Ahora tenemos una opci√≥n: ¬øllamar al m√©todo makeRequest dentro de la secuencia o asignar esta responsabilidad al observador? <br><br>  El primer enfoque es preferible, ya que en este caso podremos utilizar todo el potencial de RxJS con sus operadores y liberar a nuestro observador de tareas innecesarias.  Usamos el m√©todo del temporizador para ejecutar solicitudes por intervalo: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Cuando ejecutamos dicho c√≥digo, veremos que en console.log no recibimos un mensaje con el texto "√©xito", sino un objeto de tipo Observable: <br><br><img src="https://habrastorage.org/webt/ld/bd/ue/ldbduelhulehfiqmbm80sm3zgu8.png"><br><br>  La respuesta es bastante esperada, porque en el mapa devolvemos la secuencia.  Para que una secuencia funcione, debe suscribirse a ella.  Bueno, veamos c√≥mo <b>no hacerlo</b> : <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observable</span></span></span><span class="hljs-function"> =&gt;</span></span> observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); });</code> </pre><br>  El problema con el ejemplo anterior es que obtenemos una suscripci√≥n en una suscripci√≥n.  Pero, ¬øqu√© pasa si queremos hacer m√°s de una solicitud en una cadena?  ¬øO qu√© pasa si en alg√∫n momento necesitamos cancelar la suscripci√≥n del flujo interno?  En este caso, nuestro c√≥digo se parecer√° cada vez m√°s a "fideos".  Para resolver este problema, RxJS tiene operadores especiales llamados HOO. <br><br><h4>  Hoo </h4><br>  HOO es un tipo especial de declaraciones que aceptan flujos como valores.  Uno de estos operadores es el m√©todo mergeAll. <br><br>  Cuando una secuencia llega a mergeAll, se suscribe a ella.  La secuencia a la que se suscribi√≥ el operador se llama interna.  El flujo desde el cual el operador recibe otros flujos como valores se llama externo. <br><br>  Cuando un hilo interno genera un valor, mergeAll empuja ese valor al hilo externo.  Por lo tanto, nos deshacemos de la necesidad de suscribirse manualmente.  Si nos damos de baja del flujo externo, mergeAll autom√°ticamente se dar√° de baja del flujo interno. <br><br>  Veamos c√≥mo podemos reescribir nuestro ejemplo con mergeAll: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  En el ejemplo anterior, la secuencia externa fue creada por la declaraci√≥n del temporizador.  Y los flujos que se crean en el operador del mapa son internos.  Cada hilo creado cae en la instrucci√≥n mergeAll. <br><br><img src="https://habrastorage.org/webt/la/va/m1/lavam1n0lygvuyfolgwfd6yfyd0.png"><br><br>  La combinaci√≥n map + mergeAll se usa muy a menudo, por lo tanto, en RxJS hay un m√©todo mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Cuando un hilo externo genera un valor, el operador mergeMap llama a la funci√≥n de devoluci√≥n de llamada que se le pasa, lo que genera un nuevo hilo.  Luego mergeMap se suscribe a la secuencia generada. <br><br><img src="https://habrastorage.org/webt/n1/rh/ks/n1rhksa9atkguhglj7by5p45bew.png"><br><br>  La peculiaridad del operador mergeAll / mergeMap es que si se trata de otra secuencia, tambi√©n se suscribe.  Por lo tanto, en un flujo externo, podemos obtener valores de varios internos a la vez.  Veamos el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"> timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  As√≠ es como se ver√° la transmisi√≥n externa sin el operador mergeMap: <br><br><img src="https://habrastorage.org/webt/ie/ww/8j/ieww8j7-t1lnixucckiwzzqrmxc.png"><br><br>  Y as√≠ con mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) )</code> </pre><br><img src="https://habrastorage.org/webt/lw/0p/_o/lw0p_ownbroitrzyxksva1lhexe.png"><br><br>  Cada segundo, creamos un nuevo hilo interno y mergeMap se suscribe a √©l.  Por lo tanto, tenemos muchos hilos internos trabajando simult√°neamente, cuyos valores caen en el externo: <br><br><img src="https://habrastorage.org/webt/ar/il/_v/aril_vrkhr-jrn1jkllqj6io-ec.png"><br><br><img src="https://habrastorage.org/webt/jv/wh/um/jvwhumoobhmtyejohzsxkc26oae.png"><br><br>  <b>Nota</b> : tenga cuidado al usar mergeMap, cada nuevo hilo interno funcionar√° hasta que se d√© de baja del externo.  En el ejemplo anterior, el n√∫mero de subprocesos internos crece cada segundo, al final puede haber tantos subprocesos que la computadora no puede hacer frente a la carga. <br><br><h4>  concatAll / concatMap </h4><br>  El m√©todo mergeMap es excelente cuando no te importa el orden de ejecuci√≥n de los hilos internos, pero ¬øqu√© pasa si lo necesitas?  ¬øSupongamos que queremos que la pr√≥xima solicitud del servidor se ejecute solo despu√©s de recibir una respuesta de la anterior? <br><br>  Para tales fines, el operador HOO concatAll / concatMap es adecuado.  Este operador, habi√©ndose suscrito al hilo interno, espera hasta que termine, y solo entonces se suscribe al siguiente. <br><br>  Si durante la ejecuci√≥n de un hilo desciende uno nuevo, entonces se coloca en la cola hasta que se complete el anterior. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  1     const firstInnerObservable = timer(1000).pipe( mapTo(1) ); // ,  2     const secondInnerObservable = timer(500).pipe( mapTo(2) ); of( firstInnerObservable, secondInnerObservable ).pipe( concatAll() ).subscribe({ next: console.log });</span></span></code> </pre><br>  En el ejemplo anterior, creamos dos hilos usando el m√©todo del temporizador.  Para mayor claridad, utilic√© el operador mapTo para mostrar diferentes valores.  El primer subproceso generar√° 1, el segundo - 2. Se crea un subproceso externo utilizando el m√©todo of, que toma dos de los anteriores observables como entrada. <br><br>  La instrucci√≥n concatAll primero recibe firstInnerObservable, se suscribe a ella y espera a que se complete, y solo despu√©s de completar las primeras suscripciones a secondInnerObservable.  As√≠ es como se ver√° la transmisi√≥n externa: <br><br><img src="https://habrastorage.org/webt/dz/cd/mi/dzcdmibwf773qa025bqlqfd9oe4.png"><br><br>  Si reemplazamos concatAll con mergeAll, la secuencia se ver√° as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ax/o3/tw/axo3tw1onffl5zq956-ewdjdf8q.png"><br><br><h4>  switchAll / switchMap </h4><br>  Este operador difiere de los anteriores en que cuando recibe una nueva secuencia, inmediatamente se da de baja de la anterior y se suscribe a la nueva. <br><br>  Tome el ejemplo anterior y reemplace concatAll por switchAll, y vea c√≥mo se comporta el flujo externo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( switchAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ec/ra/sm/ecrasmknkfvubsngt7c_dcrtu1w.png"><br><br>  Solo el valor de la segunda secuencia interna se introdujo en la secuencia externa.  Esto se debe a que switchMap cancel√≥ la suscripci√≥n del primero cuando recibi√≥ el segundo subproceso. <br><br>  ¬øCu√°ndo se necesita esto?  Por ejemplo, al implementar una b√∫squeda de datos.  Si la respuesta del servidor a√∫n no ha llegado y ya hemos enviado una nueva solicitud, entonces no tenemos que esperar a la anterior. <br><br><h4>  escape / escapeMapa </h4><br>  exhaust es exactamente lo contrario de la instrucci√≥n switchAll, y su comportamiento es similar al de concatAll.  Este m√©todo, al suscribirse a la transmisi√≥n, espera a que se complete.  Si se trata de una nueva secuencia, simplemente se descarta. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( exhaust() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/2m/x7/ur/2mx7urryxakugfc8srx3lffn92c.png"><br><br>  En el ejemplo anterior, no obtuvimos un deuce, porque en ese momento el operador estaba esperando la finalizaci√≥n del primer hilo, y simplemente dej√≥ caer el segundo. <br><br>  Creo que muchos tienen una pregunta, ¬øcu√°ndo puede ser necesario ese comportamiento?  Un buen ejemplo es el formulario de inicio de sesi√≥n.  No tiene sentido enviar varias solicitudes al servidor hasta que se complete la actual. <br><br><h4>  Estamos finalizando la solicitud. </h4><br>  Recordamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">ejemplo</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo art√≠culo</a> .  En √©l, implementamos una b√∫squeda en GitHub y utilizamos el operador mergeMap para enviar solicitudes al servidor.  Ahora que conocemos las caracter√≠sticas de este operador, ¬øes realmente adecuado en nuestro caso? <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Supongamos que el servidor GitHub se sobrecargar√° en gran medida, y procesar nuestra respuesta llevar√° mucho tiempo.  ¬øQu√© podr√≠a salir mal en este caso? <br><br>  Supongamos que un usuario ingres√≥ algunos datos, no esper√≥ una respuesta e ingres√≥ otros nuevos.  En este caso, enviaremos la segunda solicitud al servidor.  Sin embargo, nadie garantiza que la respuesta a la primera solicitud llegue antes. <br><br>  Como al operador mergeMap no le importa en qu√© orden procesar los flujos internos, en el caso de que la primera solicitud se ejecute m√°s tarde que la segunda, borraremos los datos reales.  Por lo tanto, propongo reemplazar el m√©todo mergeMap con switchMap: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Ahora, si el usuario ingresa datos nuevos, switchMap se dar√° de baja de la secuencia anterior y se suscribir√° a la nueva. <br><br>  Vale la pena se√±alar que nuestra solicitud http continuar√° colgando hasta que el servidor responda.  Pero, dado que nos hemos dado de baja de la secuencia interna, la respuesta no caer√° en la secuencia externa. <br><br>  <b>Nota</b> : si trabaja con Angular y usa HttpClient para trabajar con http, entonces no puede preocuparse por cancelar la solicitud en s√≠.  HttpClient puede hacer esto por usted al darse de baja. <br><br><h4>  Cancelar http </h4><br>  La API de recuperaci√≥n tiene la capacidad de cancelar la solicitud http utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">AbortController</a> .  Cuando se combina con el operador switchMap, esta funcionalidad ahorrar√° tr√°fico de usuarios. <br><br>  Reescribamos un poco nuestro ejemplo.  Y cree un m√©todo que ajuste la llamada de b√∫squeda en observable: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createCancellableRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      const controller = new AbortController(); const signal = controller.signal; return new Observable(observer =&gt; { fetch(url, { signal }) .then(response =&gt; { if (response.ok) { return response.json(); } throw new Error(''); }) //     .then(result =&gt; observer.next(result)) //   .then(() =&gt; observer.complete()) //   ,     .catch(error =&gt; observer.error(error)); // ,    return () =&gt; { //   controller.abort(); }; }); };</span></span></code> </pre><br>  Tambi√©n cambie el m√©todo getUsersRepsFromApi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createCancellableRequest(url); }</code> </pre><br>  Ahora el m√©todo devuelve no prometedor, sino observable.  Por lo tanto, eliminamos el contenedor del switchMap: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUsersRepsFromAPI(value).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([]) ) )</code> </pre><br>  <b>Nota</b> : en RxJS versi√≥n 6.5, agregaron la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">declaraci√≥n fromFetch</a> , que a su vez llama al m√©todo abortar debajo del cap√≥, por lo que ya no necesita escribir su "bicicleta". <br><br>  Eso es todo!  Todo el c√≥digo de muestra se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aqu√≠</a> . <br><br><h4>  Conclusi√≥n </h4><br>  Hoy vimos qu√© es HOO y algunos operadores muy √∫tiles de esta categor√≠a.  Por supuesto, estos estaban lejos de todos ellos.  Para obtener informaci√≥n m√°s detallada y detallada, recomiendo visitar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">documentaci√≥n de</a> RxJS. <br><br>  En el pr√≥ximo art√≠culo planeo considerar cu√°l es la diferencia entre los observables en fr√≠o y en caliente. <br><br>  Finalmente: ¬°no use la suscripci√≥n en la suscripci√≥n, porque hay HOO! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450050/">https://habr.com/ru/post/450050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450036/index.html">Summ3r 0f h4ck: pr√°cticas Digital Security 2019</a></li>
<li><a href="../450040/index.html">Nueva compa√±√≠a apoyar√° OpenJDK 8 y 11 - entendemos la situaci√≥n</a></li>
<li><a href="../450042/index.html">Dise√±o de teclado extendido ruso</a></li>
<li><a href="../450044/index.html">Buscando un problema en el lugar equivocado</a></li>
<li><a href="../450048/index.html">Comentarios sobre los cambios a la Ley Federal N¬∫ 149-–§–ó ‚ÄúSobre informaci√≥n, tecnolog√≠as de la informaci√≥n y protecci√≥n de la informaci√≥n‚Äù</a></li>
<li><a href="../450054/index.html">Hackear el token jwt</a></li>
<li><a href="../450056/index.html">Preste atenci√≥n # 2: resumen de art√≠culos sobre pensamiento de productos, psicolog√≠a conductual y productividad personal</a></li>
<li><a href="../450058/index.html">El curr√≠culum de ese tipo</a></li>
<li><a href="../450060/index.html">C√≥mo descubr√≠ que mi visa no est√° lista, un mensaje en Slack</a></li>
<li><a href="../450062/index.html">Restaurar la circulaci√≥n en el cerebro unas horas despu√©s de la muerte.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>