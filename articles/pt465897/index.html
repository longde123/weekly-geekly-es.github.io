<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👦 ⁉️ 👉🏾 Os 10 erros mais comuns do Spring Framework 👏🏼 🖐🏼 🕴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Apresento a você a tradução do artigo “Os 10 erros mais comuns do framework Spring”, de Toni Kukurin. 

 A primavera é provavelmente um dos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Os 10 erros mais comuns do Spring Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465897/"> Olá Habr!  Apresento a você a tradução do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Os 10 erros mais comuns do framework Spring”,</a> de Toni Kukurin. <br><br>  A primavera é provavelmente um dos frameworks Java mais populares, além de ser uma fera poderosa para domesticar.  Embora seus conceitos básicos sejam bastante fáceis de entender, é preciso tempo e esforço para se tornar um desenvolvedor forte do Spring. <br><br>  Neste artigo, examinaremos alguns dos erros mais comuns no Spring, especialmente aqueles relacionados a aplicativos Web e Spring Boot.  Conforme declarado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do Spring Boot</a> , ele impõe uma idéia de como os aplicativos industriais devem ser construídos; portanto, neste artigo, tentaremos demonstrar essa idéia e fornecer uma visão geral de algumas dicas que se encaixam bem no processo padrão de desenvolvimento de aplicativos da Web do Spring Boot. <br>  Se você não conhece muito o Spring Boot, mas ainda deseja experimentar algumas das coisas mencionadas, criei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o repositório GitHub que acompanha este artigo</a> .  Se você sentir que está perdido em algum lugar do artigo, recomendo clonar o repositório no computador local e brincar com o código. <br><a name="habracut"></a><br><h2>  Erro comum nº 1: desça muito baixo </h2><br>  Encontramos esse erro comum porque a síndrome <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"não inventada aqui"</a> é bastante comum no mundo do desenvolvimento de software.Os sintomas incluem a reescrita regular de fragmentos de código usado com freqüência, e muitos desenvolvedores parecem sofrer com isso. <br><br>  Embora seja bom e necessário compreender o interior de uma determinada biblioteca e sua implementação em grande parte (e possa ser um excelente processo de aprendizado), resolver constantemente os mesmos detalhes de implementação de baixo nível é prejudicial ao seu desenvolvimento como engenheiro de software.  Há uma razão para abstrações e estruturas como o Spring que o separam estritamente do trabalho manual repetitivo e permitem que você se concentre em detalhes de nível superior - seus objetos de domínio e lógica de negócios. <br><br>  Portanto, use abstrações - na próxima vez em que encontrar um problema específico, faça uma pesquisa rápida e determine se a biblioteca que resolve esse problema está integrada ao Spring.  Atualmente, é mais provável que você encontre uma solução adequada existente.  Como exemplo de uma biblioteca útil, nos exemplos do restante deste artigo, usarei as anotações <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do projeto Lombok</a> .  O Lombok é usado como um gerador de código de modelo e o desenvolvedor preguiçoso dentro de você, espero que não deva ter problemas com a idéia desta biblioteca.  Como exemplo, veja como é um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"bean Java padrão"</a> com o Lombok: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstBeanProperty; String secondBeanProperty; }</code> </pre> <br>  Como você pode imaginar, o código acima é compilado em: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstBeanProperty; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String secondBeanProperty; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSecondBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setFirstBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstBeanProperty)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstBeanProperty = firstBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSecondBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String secondBeanProperty)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondBeanProperty = secondBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br>  No entanto, observe que você provavelmente precisará instalar o plug-in se pretender usar o Lombok com seu IDE.  A versão do plugin para o IntelliJ IDEA pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  Erro comum nº 2: vazando conteúdo interno </h2><br>  Revelar sua estrutura interna é sempre uma péssima idéia, pois cria inflexibilidade no design do serviço e, portanto, contribui para práticas inadequadas de codificação.  Um "vazamento" de conteúdo interno se manifesta no fato de que a estrutura do banco de dados é acessível a partir de determinados pontos de extremidade da API.  Como exemplo, suponha que o seguinte POJO ("Objeto Java Antigo Simples") represente uma tabela no seu banco de dados: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopTalentEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre> <br>  Suponha que exista um terminal que precise acessar os dados de TopTalentEntity.  Não importa o quão tentador seja retornar instâncias TopTalentEntity, uma solução mais flexível seria criar uma nova classe para exibir os dados TopTalentEntity no terminal da API: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; }</code> </pre> <br>  Portanto, fazer alterações no back-end do banco de dados não exigirá alterações adicionais na camada de serviço.  Pense no que acontece se você adicionar o campo de senha ao TopTalentEntity para armazenar hashes de senha de usuário no banco de dados - sem um conector como o TopTalentData, se você esquecer de alterar o serviço, o front-end exibirá acidentalmente algumas informações secretas indesejáveis! <br><br><h2>  Erro comum nº 3: falta de separação de deveres </h2><br>  À medida que o aplicativo cresce, a organização do código se torna um problema cada vez mais importante.  Ironicamente, a maioria dos bons princípios de desenvolvimento de software está começando a ser violada em todos os lugares - especialmente nos casos em que pouca atenção é dada ao design da arquitetura do aplicativo.  Um dos erros mais comuns enfrentados pelos desenvolvedores é a mistura de responsabilidades de código, e é muito fácil de fazer! <br><br>  O que geralmente viola o princípio da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">separação de tarefas</a> é simplesmente "adicionar" novas funcionalidades às classes existentes.  Essa, é claro, é uma excelente solução de curto prazo (para iniciantes, requer menos digitação), mas inevitavelmente se tornará um problema no futuro, seja durante testes, manutenção ou em algum lugar intermediário.  Considere o seguinte controlador, que retorna TopTalentData de seu repositório: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentRepository topTalentRepository; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/toptal/get"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentRepository.findAll() .stream() .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::entityToData) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TopTalentData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityToData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentEntity topTalentEntity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentData(topTalentEntity.getName()); } }</code> </pre> <br>  A princípio, não é perceptível que algo esteja errado com esse trecho de código.  Ele fornece uma lista TopTalentData que é recuperada das instâncias TopTalentEntity.  No entanto, se você observar de perto, veremos que, de fato, o TopTalentController faz algumas coisas aqui.  A saber: ele mapeia solicitações para um terminal específico, extrai dados do repositório e converte entidades obtidas do TopTalentRepository em outro formato.  Uma solução "mais limpa" seria dividir essas responsabilidades em suas próprias classes.  Pode ser algo como isto: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/toptal"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentService topTalentService; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/get"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentService.getTopTalent(); } } <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentRepository topTalentRepository; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentEntityConverter topTalentEntityConverter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentRepository.findAll() .stream() .map(topTalentEntityConverter::toResponse) .collect(Collectors.toList()); } } <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentEntityConverter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TopTalentData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentEntity topTalentEntity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentData(topTalentEntity.getName()); } }</code> </pre> <br>  Um benefício adicional dessa hierarquia é que ela nos permite determinar onde a funcionalidade está localizada, basta verificar o nome da classe.  Além disso, durante o teste, podemos substituir facilmente qualquer uma das classes por uma implementação simulada, se necessário. <br><br><h2>  Erro comum nº 4: inconsistência e tratamento inadequado de erros </h2><br>  O tópico consistência não é necessariamente exclusivo do Spring (ou Java, por sinal), mas ainda é um aspecto importante a ser considerado ao trabalhar em projetos do Spring.  Embora o estilo de escrever código possa ser objeto de discussão (e geralmente é uma questão de acordo entre a equipe ou a empresa), a presença de um padrão comum é de grande ajuda no desempenho.  Isto é especialmente verdade para equipes de várias pessoas.  A consistência permite que o código seja transmitido sem o gasto de recursos para manutenção ou o fornecimento de explicações detalhadas sobre as responsabilidades de várias classes. <br><br>  Considere um projeto Spring com vários arquivos de configuração, serviços e controladores.  Sendo semanticamente consistente em nomeá-los, é criada uma estrutura facilmente pesquisável na qual qualquer novo desenvolvedor pode controlar como trabalhar com o código: por exemplo, o sufixo Config é adicionado às classes de configuração, Service sufixo aos serviços e Controller sufixo aos controladores. <br><br>  Intimamente relacionado ao tópico consistência, o tratamento de erros do lado do servidor merece atenção especial.  Se você já teve que lidar com respostas de exceção de uma API mal escrita, provavelmente sabe por que pode ser doloroso analisar exceções e é ainda mais difícil determinar o motivo pelo qual essas exceções ocorreram originalmente. <br><br>  Como desenvolvedor de API, você idealmente deseja cobrir todos os pontos de extremidade do usuário e convertê-los em um formato de erro comum.  Isso geralmente significa que você tem um código de erro e uma descrição comuns, e não apenas uma desculpa na forma de: a) retornar a mensagem “500 Internal Server Error” ou b) apenas redefinir o rastreamento da pilha para o usuário (o que deve ser evitado a todo custo, pois mostra suas informações internas) além da complexidade do processamento no lado do cliente). <br>  Um exemplo de um formato de resposta de erro comum pode ser: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorResponse</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer errorCode; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String errorMessage; }</code> </pre> <br>  Algo semelhante é geralmente encontrado nas APIs mais populares e geralmente funciona bem, pois pode ser fácil e sistematicamente documentado.  Você pode converter exceções nesse formato fornecendo ao método a anotação @ExceptionHandler (um exemplo da anotação é fornecido no Erro comum nº 6). <br><br><h2>  Erro comum nº 5: multithreading incorreto </h2><br>  Independentemente de ser encontrado em aplicativos de desktop ou da Web, no Spring ou não no Spring, o multithreading pode ser uma tarefa assustadora.  Os problemas causados ​​pela execução de programas paralelos são esquivos e muitas vezes extremamente difíceis de depurar - de fato, devido à natureza do problema, depois que você entende que está lidando com o problema de execução paralela, provavelmente deve abandonar completamente o depurador e iniciar verifique seu código manualmente até encontrar a causa do erro.  Infelizmente, para resolver esses problemas, não há solução de modelo.  Dependendo do caso específico, você terá que avaliar a situação e atacar o problema de um ângulo que você considera o melhor. <br><br>  Idealmente, é claro, você gostaria de evitar completamente os erros de multithreading.  Novamente, não há uma abordagem única para isso, mas aqui estão algumas considerações práticas para depuração e prevenção de erros de multithreading: <br><br><h3>  Evitar status global </h3><br>  Primeiro, lembre-se sempre do problema do "estado global".  Se você estiver criando um aplicativo multithread, absolutamente tudo o que pode ser alterado globalmente deve ser cuidadosamente monitorado e, se possível, completamente removido.  Se houver um motivo para a variável global permanecer mutável, use com cuidado a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sincronização</a> e monitore o desempenho do seu aplicativo para confirmar que não está diminuindo a velocidade devido a novos períodos de espera. <br><br><h3>  Evitar Mutabilidade </h3><br>  Isso segue diretamente da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programação funcional</a> e, de acordo com a OOP, afirma que a volatilidade de classe e a mudança de estado devem ser evitadas.  Em resumo, o que precede significa a presença de levantadores e campos finais privados em todas as classes do modelo.  Seus valores mudam apenas durante a construção.  Assim, você pode ter certeza de que não haverá problemas na corrida por recursos e que o acesso às propriedades do objeto sempre fornecerá os valores corretos. <br><br><h3>  Registrar dados críticos </h3><br>  Avalie onde seu aplicativo pode causar problemas e pré-registre todos os dados importantes.  Se ocorrer um erro, você será grato por informações sobre quais solicitações foram recebidas e poderá entender melhor por que seu aplicativo está se comportando mal.  Novamente, observe que o registro aumenta a E / S do arquivo, portanto você não deve abusar dele, pois isso pode afetar seriamente o desempenho do seu aplicativo. <br><br><h3>  Reutilizar implementações existentes </h3><br>  Sempre que você precisar criar seus próprios encadeamentos (por exemplo, para fazer solicitações assíncronas para vários serviços), reutilize implementações seguras existentes, em vez de criar suas próprias soluções.  Na maioria das vezes, isso significaria usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ExecutorServices</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CompletableFutures</a> no elegante estilo funcional do Java 8 para criar encadeamentos.  O Spring também permite o processamento de solicitações assíncronas através da classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DeferredResult</a> . <br><br><h2>  Erro comum nº 6: não usar validação baseada em anotação </h2><br>  Vamos imaginar que nosso serviço TopTalent, mencionado acima, precise de um endpoint para adicionar novos super talentos.  Além disso, suponha que, por algum motivo realmente bom, cada novo nome tenha exatamente 10 caracteres.  Uma maneira de fazer isso pode ser a seguinte: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/put"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody TopTalentData topTalentData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> nameNonExistentOrHasInvalidLength = Optional.ofNullable(topTalentData) .map(TopTalentData::getName) .map(name -&gt; name.length() == <span class="hljs-number"><span class="hljs-number">10</span></span>) .orElse(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nameNonExistentOrInvalidLength) { <span class="hljs-comment"><span class="hljs-comment">// throw some exception } topTalentService.addTopTalent(topTalentData); }</span></span></code> </pre> <br>  No entanto, o acima exposto (além de ser mal projetado) não é realmente uma solução "limpa".  Verificamos mais de um tipo de validade (ou seja, que TopTalentData não é nulo e que TopTalentData.name não é nulo e que TopTalentData.name possui 10 caracteres) e também gera uma exceção se os dados forem inválidos. <br><br>  Isso pode ser feito de maneira muito mais limpa usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">validador Hibernate</a> com Spring.  Primeiro, reescrevemos o método addTopTalent para dar suporte à validação: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/put"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Valid @NotNull @RequestBody TopTalentData topTalentData)</span></span></span><span class="hljs-function"> </span></span>{ topTalentService.addTopTalent(topTalentData); } <span class="hljs-meta"><span class="hljs-meta">@ExceptionHandler</span></span> <span class="hljs-meta"><span class="hljs-meta">@ResponseStatus</span></span>(HttpStatus.BAD_REQUEST) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ErrorResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleInvalidTopTalentDataException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodArgumentNotValidException methodArgumentNotValidException)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// handle validation exception }</span></span></code> </pre> <br>  Além disso, devemos indicar qual propriedade queremos verificar na classe TopTalentData: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Length</span></span>(min = <span class="hljs-number"><span class="hljs-number">10</span></span>, max = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; }</code> </pre> <br>  O Spring agora interceptará a solicitação e a verificará antes de chamar o método - não há necessidade de usar testes manuais adicionais. <br><br>  Outra maneira de conseguirmos o mesmo é criar nossas próprias anotações.  Embora as anotações personalizadas geralmente sejam usadas apenas quando suas necessidades excederem o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto de constantes internas</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hibernate</a> , neste exemplo, vamos imaginar que as anotações <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Comprimento</a> não existam.  Você deve criar um validador que verifique o comprimento de uma sequência criando duas classes adicionais, uma para verificação e outra para propriedades de anotação: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Documented</span></span> <span class="hljs-meta"><span class="hljs-meta">@Constraint</span></span>(validatedBy = { MyAnnotationValidator.class }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> MyAnnotation { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> "String length does not match expected"</span></span>; Class&lt;?&gt;[] groups() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; Class&lt;? extends Payload&gt;[] payload() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAnnotationValidator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstraintValidator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAnnotation</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expectedLength; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyAnnotation myAnnotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expectedLength = myAnnotation.value(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s, ConstraintValidatorContext constraintValidatorContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || s.length() == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expectedLength; } }</code> </pre> <br>  Observe que, nesses casos, as práticas recomendadas para separação de tarefas exigem que você marque uma propriedade como válida se for nula (s == null no método isValid) e, em seguida, use a anotação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">NotNull</a> se esse for um requisito adicional para a propriedade: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@MyAnnotation</span></span>(value = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; }</code> </pre> <br><h2>  Erro comum nº 7: usando a configuração XML (estática) </h2><br>  Embora o XML fosse necessário para versões anteriores do Spring, atualmente a maior parte da configuração pode ser feita exclusivamente com código / anotações Java.  As configurações XML simplesmente representam um clichê adicional e desnecessário. <br>  Este artigo (e o repositório do GitHub que o acompanha) usa anotações para configurar o Spring e o Spring sabe quais beans ele deve se conectar porque o pacote raiz foi anotado usando a anotação composta @SpringBootApplication, por exemplo: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(Application.class, args); } }</code> </pre> <br>  Essa anotação composta (você pode aprender mais sobre isso na documentação do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spring</a> ) apenas fornece ao Spring uma dica sobre quais pacotes devem ser verificados para extrair os beans.  No nosso caso específico, isso significa que as seguintes classes serão usadas para conectar os beans, começando com o pacote de nível superior (co.kukurin): <br><br><ul><li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> <li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> <li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> <li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> </ul><br>  Se tivéssemos quaisquer classes adicionais anotadas com @Configuration, elas também seriam verificadas quanto à configuração do Java. <br><br><h2>  Erro comum número 8: esquecer perfis </h2><br>  O problema geralmente encontrado ao desenvolver servidores é a diferença entre diferentes tipos de configurações, geralmente configurações industriais e de desenvolvimento.  Em vez de alterar manualmente os vários parâmetros de configuração cada vez que você alterna do teste para a implantação de aplicativos, uma maneira mais eficiente seria usar perfis. <br><br>  Considere o caso ao usar o banco de dados na memória para desenvolvimento local e o banco de dados MySQL no PROM.  Em essência, isso significa que você usará URLs diferentes e (espero) credenciais diferentes para acessar cada um deles.  Vamos ver como isso pode ser feito com dois arquivos de configuração diferentes: <br><br><h4>  FILE APPLICATION.YAML </h4><br><pre> <code class="plaintext hljs"># set default profile to 'dev' spring.profiles.active: dev # production database details spring.datasource.url: 'jdbc:mysql://localhost:3306/toptal' spring.datasource.username: root spring.datasource.password:</code> </pre> <br><h4>  FILE APPLICATION-DEV.YAML </h4><br><pre> <code class="plaintext hljs">spring.datasource.url: 'jdbc:h2:mem:' spring.datasource.platform: h2</code> </pre> <br>  Aparentemente, você não deseja executar acidentalmente nenhuma ação no seu banco de dados industrial enquanto mexe no código; portanto, faz sentido definir o perfil padrão em dev.  Em seguida, no servidor, você pode substituir manualmente o perfil de configuração especificando o parâmetro -Dspring.profiles.active = prod para a JVM.  Além disso, você também pode definir a variável de ambiente do SO para o perfil padrão desejado. <br><br><h2>  Erro comum nº 9: incapacidade de aceitar injeção de dependência </h2><br>  O uso adequado da injeção de dependência no Spring significa que ele permite vincular todos os seus objetos, varrendo todas as classes de configuração necessárias;  isso é útil para dissociar relacionamentos e também facilita muito os testes.  Em vez de vincular classes, fazendo algo como isto: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentService topTalentService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.topTalentService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentService(); } }</code> </pre> <br><br>  Deixamos a Spring fazer a ligação para nós: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentService topTalentService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentService topTalentService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.topTalentService = topTalentService; } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Misko Hevery, do Google talk, explica</a> detalhadamente os "motivos" da injeção de dependência, então vamos ver como isso é usado na prática.  Na divisão de responsabilidades (Common Mistakes # 3), criamos classes de serviço e controlador.  Suponha que desejamos testar um controlador sob a suposição de que TopTalentService está se comportando corretamente.  Podemos inserir um objeto simulado em vez da implementação real do serviço, fornecendo uma classe de configuração separada: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleUnitTestConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TopTalentService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topTalentService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TopTalentService topTalentService = Mockito.mock(TopTalentService.class); Mockito.when(topTalentService.getTopTalent()).thenReturn( Stream.of(<span class="hljs-string"><span class="hljs-string">"Mary"</span></span>, <span class="hljs-string"><span class="hljs-string">"Joel"</span></span>) .map(TopTalentData::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>).collect(Collectors.toList())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentService; } }</code> </pre> <br>  Em seguida, podemos incorporar o objeto simulado dizendo ao Spring para usar o SampleUnitTestConfig como o provedor de configuração: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(classes = { SampleUnitTestConfig.class })</code> </pre> <br>  Isso nos permitirá usar a configuração de contexto para incorporar o bean personalizado no teste de unidade. <br><br><h2>  Erro comum nº 10: falta de teste ou teste incorreto </h2><br>  Apesar do fato de que a idéia de teste de unidade está conosco há muito tempo, muitos desenvolvedores parecem "esquecer" de fazer isso (especialmente se isso não for necessário), ou simplesmente deixá-lo para mais tarde.  Obviamente, isso é indesejável, pois os testes não devem apenas verificar a correção do seu código, mas também servir como documentação sobre como o aplicativo deve se comportar em diferentes situações. <br><br>  Ao testar serviços da Web, você raramente realiza testes de unidade excepcionalmente "limpos", já que a interação por HTTP geralmente exige chamar DispatcherServlet Spring e verificar o que acontece quando o HttpServletRequest real é recebido (o que o torna um teste de integração, com usando validação, serialização etc.).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">REST Assured</a> - Java DSL para testar facilmente os serviços REST sobre o MockMVC provou ser uma solução muito elegante.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere o seguinte fragmento de código com injeção de dependência: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringJUnit4ClassRunner.class) <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(classes = { Application.class, SampleUnitTestConfig.class }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RestAssuredTestDemonstration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TopTalentController topTalentController; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldGetMaryAndJoel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// given MockMvcRequestSpecification givenRestAssuredSpecification = RestAssuredMockMvc.given() .standaloneSetup(topTalentController); // when MockMvcResponse response = givenRestAssuredSpecification.when().get("/toptal/get"); // then response.then().statusCode(200); response.then().body("name", hasItems("Mary", "Joel")); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O SampleUnitTestConfig habilita a implementação simulada TopTalentService no TopTalentController, enquanto todas as outras classes são conectadas usando a configuração padrão obtida pela verificação de pacotes com raízes no pacote da classe Application. </font><font style="vertical-align: inherit;">RestAssuredMockMvc é simplesmente usado para criar um ambiente leve e enviar uma solicitação GET para o terminal / toptal / get.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Torne-se um mestre da primavera </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primavera é uma estrutura poderosa e fácil de começar, mas que exige dedicação e tempo para alcançar o domínio total. Se você gastar tempo conhecendo a estrutura, certamente aumentará sua produtividade a longo prazo e, finalmente, ajudará você a escrever um código mais limpo e se tornar um desenvolvedor melhor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você estiver procurando por recursos adicionais, o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring In Action</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um livro de boas práticas que abrange muitos dos principais tópicos do Spring. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAGS</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Java SpringFramework</font></font><br><br><h2>  Comentários </h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timothy Schimandle</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em # 2, acho que é preferível retornar um objeto de domínio na maioria dos casos. Seu exemplo de objeto personalizado é uma das várias classes que possuem campos que queremos ocultar. Mas a grande maioria dos objetos com os quais trabalhei não possui essa restrição, e adicionar a classe dto é apenas um código desnecessário. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em suma, um bom artigo. Bom trabalho </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apaixonado por Timothy Schimandle,</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eu concordo totalmente. Parece que uma camada extra desnecessária de código foi adicionada, acho que o @JsonIgnore ajudará a ignorar os campos (embora com falhas nas estratégias de detecção de repositório padrão), mas no geral, este é um ótimo post no blog. Orgulhoso de tropeçar ... </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arokiadoss Asirvatham</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara, outro erro comum dos iniciantes é: 1) Dependência cíclica e 2) não conformidade com doutrinas básicas de declaração da classe Singleton, como o uso de uma variável de instância em beans com escopo singleton. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hlodowig</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em relação ao número 8, acredito que as abordagens aos perfis são muito insatisfatórias. </font><font style="vertical-align: inherit;">Vamos ver:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segurança: algumas pessoas dizem: se o seu repositório fosse público, haveria chaves / senhas secretas? </font><font style="vertical-align: inherit;">Muito provavelmente, será assim, seguindo esta abordagem. </font><font style="vertical-align: inherit;">A menos, é claro, que você adicione arquivos de configuração ao .gitignore, mas essa não é uma opção séria.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duplicação: toda vez que tenho configurações diferentes, preciso criar um novo arquivo de propriedades, o que é bastante irritante. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portabilidade: Eu sei que esse é apenas um argumento da JVM, mas zero é melhor que um. </font><font style="vertical-align: inherit;">Infinitamente menos propenso a erros.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentei encontrar uma maneira de usar variáveis ​​de ambiente nos meus arquivos de configuração, em vez de "codificar" os valores, mas até agora não consegui, acho que preciso fazer mais pesquisas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ótimo artigo Tony, mantenha o bom trabalho! </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tradução concluída: tele.gg/middle_java</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465897/">https://habr.com/ru/post/pt465897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465885/index.html">Como se tornar um líder em Scrum Master e agitar a equipe?</a></li>
<li><a href="../pt465889/index.html">Como abordamos a eficiência energética</a></li>
<li><a href="../pt465891/index.html">Como criar um nome de produto ou empresa usando o Vepp como exemplo</a></li>
<li><a href="../pt465893/index.html">Summ3r do h4ck 2019. Departamento de Análise de Segurança</a></li>
<li><a href="../pt465895/index.html">Visão geral do programa C ++ Russia 2019 Piter: assincronia, módulos, bibliotecas ... e táxi</a></li>
<li><a href="../pt465899/index.html">O livro "Prompt de Comando do Linux. O guia completo. 2nd int. ed. "</a></li>
<li><a href="../pt465901/index.html">O que um aplicativo de fitness deve ter?</a></li>
<li><a href="../pt465903/index.html">Bem-vindo ao Fujitsu World Tour 2019</a></li>
<li><a href="../pt465905/index.html">Conferência ZeroNights 2019</a></li>
<li><a href="../pt465911/index.html">Meetup de aceleração 17/09 Vídeos e apresentações da UPD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>