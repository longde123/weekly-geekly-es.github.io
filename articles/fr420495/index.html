<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèæ üçÖ üßôüèª Rendu de l'eau √† l'√©cran üî¥ üë®üèº‚Äçüè´ üê°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ma derni√®re t√¢che en graphisme / rendu technique a √©t√© de trouver une bonne solution pour le rendu de l'eau. En particulier, le rendu de jets d'eau mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendu de l'eau √† l'√©cran</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420495/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/216/ca8/1f5/216ca81f5eb506eab2dbcfc730a904b4.png" alt="image"></div><br>  Ma derni√®re t√¢che en graphisme / rendu technique a √©t√© de trouver une bonne solution pour le rendu de l'eau.  En particulier, le rendu de jets d'eau minces et rapides √† base de particules.  Au cours de la semaine derni√®re, j'ai pens√© √† de bons r√©sultats, je vais donc √©crire un article √† ce sujet. <br><br>  Je n'aime pas vraiment l'approche des cubes vox√©lis√©s / marchants lors du rendu de l'eau (voir, par exemple, le rendu d'une simulation fluide dans Blender).  Lorsque le volume d'eau est √† la m√™me √©chelle que la grille utilis√©e pour le rendu, le mouvement est sensiblement discret.  Ce probl√®me peut √™tre r√©solu en augmentant la r√©solution de la grille, mais pour les jets minces sur des distances relativement longues en temps r√©el, il est tout simplement peu pratique car il affecte consid√©rablement le temps d'ex√©cution et la m√©moire occup√©e.  (Il existe un pr√©c√©dent pour l'utilisation de structures de voxels clairsem√©es pour am√©liorer la situation. Mais je ne sais pas dans quelle mesure cela fonctionne pour les syst√®mes dynamiques. De plus, ce n'est pas le niveau de complexit√© avec lequel je voudrais travailler.) <br><br>  La premi√®re alternative que j'ai explor√©e √©tait les Screen Space Meshes de M√ºller.  Ils utilisent le rendu des particules d'eau dans un tampon de profondeur, le lissant, reconnaissant les fragments connect√©s de profondeur similaire et construisant un maillage √† partir du r√©sultat √† l'aide de carr√©s de marche.  Aujourd'hui, cette m√©thode est probablement devenue <i>plus</i> applicable qu'en 2007 (puisque maintenant nous pouvons cr√©er un maillage dans le shader de calcul), mais elle est toujours associ√©e √† un niveau de complexit√© et de co√ªt plus √©lev√© que je ne le souhaiterais. <br><br>  Au final, j'ai trouv√© la pr√©sentation de Simon Green avec GDC 2010, Screen Space Fluid Rendering For Games.  Il commence exactement de la m√™me mani√®re que les maillages d'espace d'√©cran: avec le rendu des particules dans le tampon de profondeur et le lissage.  Mais au lieu de construire le maillage, le tampon r√©sultant est utilis√© pour ombrer et composer le liquide dans la sc√®ne principale (en enregistrant explicitement la profondeur.) J'ai d√©cid√© de mettre en ≈ìuvre un tel syst√®me. <br><a name="habracut"></a><br><h3>  La pr√©paration </h3><br>  Plusieurs projets Unity pr√©c√©dents m'ont appris √† ne pas g√©rer les limites du rendu du moteur.  Par cons√©quent, les tampons fluides sont rendus par une deuxi√®me cam√©ra avec une profondeur de champ plus faible de sorte qu'elle effectue un rendu devant la sc√®ne principale.  Chaque syst√®me fluide existe sur une couche de rendu distincte;  la chambre principale exclut une couche d'eau, et la deuxi√®me chambre ne rend que de l'eau.  Les deux cam√©ras sont les enfants d'un objet vide pour assurer leur orientation relative. <br><br>  Un tel sch√©ma signifie que je peux rendre presque n'importe quoi dans la couche liquide, et il ressemblera √† ce que j'attends.  Dans le contexte de ma sc√®ne de d√©monstration, cela signifie que quelques jets et √©claboussures de sous-√©metteurs peuvent fusionner.  De plus, cela permettra le m√©lange d'autres syst√®mes d'eau, par exemple, des volumes bas√©s sur des champs d'altitude, qui peuvent ensuite √™tre rendus les m√™mes.  (Je n'ai pas encore test√© cela.) <br><br>  La source d'eau dans ma sc√®ne est un syst√®me de particules standard.  En fait, aucune simulation de fluide n'est effectu√©e.  Ceci, √† son tour, signifie que les particules ne se chevauchent pas de mani√®re compl√®tement physique, mais le r√©sultat final semble acceptable dans la pratique. <br><br><h3>  Rendu de tampon fluide </h3><br>  La premi√®re √©tape de cette technique consiste √† rendre le tampon fluide de base.  Il s'agit d'un tampon hors √©cran qui contient (au stade actuel de mon impl√©mentation) les √©l√©ments suivants: largeur de fluide, vecteur de mouvement dans l'espace d'√©cran et valeur de bruit.  De plus, nous rendons le tampon de profondeur en enregistrant explicitement la profondeur du fragment shader afin de transformer chaque quadrilat√®re d'une particule en une "boule" sph√©rique (enfin elliptique). <br><br>  Les calculs de profondeur et de largeur sont assez simples: <br><br><pre><code class="cpp hljs">frag_out o; float3 N; N.xy = i.uv*<span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r2 = dot(N.xy, N.xy); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r2 &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>) discard; Nz = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - r2); float4 pixel_pos = float4(i.view_pos + N * i.size, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); float4 clip_pos = mul(UNITY_MATRIX_P, pixel_pos); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth = clip_pos.z / clip_pos.w; o.depth = depth; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thick = Nz * i.size * <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  (Bien s√ªr, les calculs de profondeur peuvent √™tre simplifi√©s; √† partir de la position du clip, nous n'avons besoin que de z et w.) <br><br>  Un peu plus tard, nous reviendrons sur le fragment shader pour les vecteurs mouvement et bruit. <br><br>  Le plaisir commence dans le vertex shader, et c'est ici que je m'√©loigne de la technique Green.  Le but de ce projet est de rendre des jets d'eau √† grande vitesse;  il peut √™tre r√©alis√© √† l'aide de particules sph√©riques, mais une √©norme quantit√© d'entre elles sera n√©cessaire pour cr√©er un jet continu.  Au lieu de cela, j'√©tirerai les quadrangles des particules en fonction de leur vitesse, qui √† son tour √©tire les boules de profondeur, les rendant non sph√©riques, mais elliptiques.  (√âtant donn√© que les calculs de profondeur sont bas√©s sur les UV, qui ne changent pas, tout fonctionne simplement.) <br><br>  Les utilisateurs exp√©riment√©s d'Unity peuvent se demander pourquoi je n'utilise tout simplement pas le mode de panneau d'affichage √©tendu int√©gr√© disponible dans le syst√®me de particules Unity.  Le panneau d'affichage √©tir√© effectue un √©tirement inconditionnel le long du vecteur vitesse dans l'espace du monde.  Dans le cas g√©n√©ral, cela convient parfaitement, mais cela conduit √† un probl√®me tr√®s notable lorsque le vecteur vitesse est codirig√© avec le vecteur cam√©ra orient√© vers l'avant (ou tr√®s proche de celui-ci).  Le panneau d'affichage s'√©tire sur l'√©cran, ce qui rend sa nature bidimensionnelle tr√®s visible. <br><br>  Au lieu de cela, j'utilise un panneau d'affichage visant la cam√©ra et projette le vecteur vitesse sur le plan de la particule, en l'utilisant pour √©tirer le quadrilat√®re.  Si le vecteur vitesse est perpendiculaire au plan (dirig√© vers l'√©cran ou √©loign√© de lui), alors la particule reste non √©tir√©e et sph√©rique, comme il se doit, et lorsqu'elle est inclin√©e, la particule est √©tir√©e dans cette direction, ce dont nous avons besoin. <br><br>  Laissons une longue explication, voici une fonction assez simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeStretchedVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 p_world, float3 c_world, float3 vdir_world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stretch_amount)</span></span></span><span class="hljs-function"> </span></span>{ float3 center_offset = p_world - c_world; float3 stretch_offset = dot(center_offset, vdir_world) * vdir_world; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p_world + stretch_offset * lerp(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>, stretch_amount); }</code> </pre> <br>  Pour calculer le vecteur de mouvement de l'espace d'√©cran, nous calculons deux ensembles de positions de vecteurs: <br><br><pre> <code class="cpp hljs">float3 vp1 = ComputeStretchedVertex( vertex_wp, center_wp, velocity_dir_w, rand); float3 vp0 = ComputeStretchedVertex( vertex_wp - velocity_w * unity_DeltaTime.x, center_wp - velocity_w * unity_DeltaTime.x, velocity_dir_w, rand); o.motion_0 = mul(_LastVP, float4(vp0, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); o.motion_1 = mul(_CurrVP, float4(vp1, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre> <br>  Notez que puisque nous calculons des vecteurs de mouvement dans le passage principal et non dans le passage de vecteurs de vitesse, Unity ne nous fournit pas une projection de courant pr√©c√©dente ou non d√©form√©e √† partir de la vue.  Pour r√©soudre ce probl√®me, j'ai ajout√© un script simple aux syst√®mes de particules correspondants: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ScreenspaceLiquidRenderer</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera LiquidCamera; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ParticleSystemRenderer m_ParticleRenderer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_First; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Matrix4x4 m_PreviousVP; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_ParticleRenderer = GetComponent(); m_First = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWillRenderObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Matrix4x4 current_vp = LiquidCamera.nonJitteredProjectionMatrix * LiquidCamera.worldToCameraMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_First) { m_PreviousVP = current_vp; m_First = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } m_ParticleRenderer.material.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_LastVP"</span></span>, GL.GetGPUProjectionMatrix(m_PreviousVP, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)); m_ParticleRenderer.material.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_CurrVP"</span></span>, GL.GetGPUProjectionMatrix(current_vp, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)); m_PreviousVP = current_vp; } }</code> </pre> <br>  Je mets en cache la matrice pr√©c√©dente manuellement car Camera.previousViewProjectionMatrix donne des r√©sultats incorrects. <br><br>  ¬Ø \ _ („ÉÑ) _ / ¬Ø <br><br>  (De plus, cette m√©thode viole le rendu; il peut √™tre prudent de d√©finir des constantes matricielles globales dans la pratique plut√¥t que de les utiliser pour chaque mat√©riau.) <br><br>  Revenons au shader de fragment: nous utilisons les positions projet√©es pour calculer les vecteurs de mouvement de l'espace √©cran: <br><br><pre> <code class="cpp hljs">float3 hp0 = i.motion_0.xyz / i.motion_0.w; float3 hp1 = i.motion_1.xyz / i.motion_1.w; float2 vp0 = (hp0.xy + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; float2 vp1 = (hp1.xy + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_UV_STARTS_AT_TOP vp0.y = 1.0 - vp0.y; vp1.y = 1.0 - vp1.y; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> float2 vel = vp1 - vp0;</span></span></code> </pre> <br>  (Le calcul des vecteurs de mouvement est pratiquement inchang√©, extrait de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://github.com/keijiro/ParticleMotionVector/blob/master/Assets/ParticleMotionVector/Shaders/Motion.cginc</a> ) <br><br>  Enfin, la derni√®re valeur dans le tampon fluide est le bruit.  J'utilise un nombre al√©atoire stable pour chaque particule pour s√©lectionner l'un des quatre bruits (regroup√©s dans une seule texture).  Ensuite, il est mis √† l'√©chelle par la vitesse et l'unit√© moins la taille des particules (par cons√©quent, les particules rapides et petites sont plus bruyantes).  Cette valeur de bruit est utilis√©e dans la passe d'ombrage pour d√©former les normales et ajouter une couche de mousse.  Le travail de Green utilise un bruit blanc √† trois canaux, mais un travail plus r√©cent (Rendu fluide de l'espace spatial avec flux de courbure) propose d'utiliser le bruit Perlin.  J'utilise le bruit Voronoi / bruit cellulaire avec diff√©rentes √©chelles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/743/9f4/c0b/7439f4c0beebbc16cbfa536c516b2fcf.png"></div><br><h3>  Probl√®mes de mixage (et solutions) </h3><br>  Et voici les premiers probl√®mes de ma mise en ≈ìuvre apparaissent.  Pour le calcul correct de l'√©paisseur des particules sont m√©lang√©es additivement.  √âtant donn√© que le mixage affecte toutes les sorties, cela signifie que les vecteurs de bruit et de mouvement sont √©galement m√©lang√©s de mani√®re additive.  Le bruit additif nous convient tout √† fait, mais pas les vecteurs additifs, et si vous les laissez tels quels, vous obtenez un anti-aliasing de temps d√©go√ªtant (TAA) et un flou de mouvement.  Pour r√©soudre ce probl√®me, lors du rendu d'un tampon fluide, je multiplie simplement les vecteurs de mouvement par l'√©paisseur et divise par l'√©paisseur totale dans la passe d'ombrage.  Cela nous donne un vecteur de mouvement moyen pond√©r√© pour toutes les particules qui se chevauchent;  pas tout √† fait ce dont nous avons besoin (des artefacts √©tranges sont cr√©√©s lorsque plusieurs jets se croisent), mais tout √† fait acceptable. <br><br>  Un probl√®me plus complexe est la profondeur;  Pour un rendu correct du tampon de profondeur, nous devons avoir √† la fois l'enregistrement et la v√©rification de la profondeur actifs.  Cela peut entra√Æner des probl√®mes si les particules ne sont pas tri√©es (car la diff√©rence dans l'ordre de rendu peut entra√Æner l'√©cr√™tage de la sortie des particules superpos√©es par d'autres).  Par cons√©quent, nous ordonnons au syst√®me de particules Unity de trier les particules par profondeur, puis nous croisons les doigts et esp√©rons.  que les syst√®mes rendront √©galement en profondeur.  Nous aurons * des * cas de syst√®mes qui se chevauchent (par exemple, l'intersection de deux jets de particules) qui ne sont pas trait√©s correctement, ce qui conduira √† une √©paisseur plus petite.  Mais cela ne se produit pas tr√®s souvent et n'affecte pas beaucoup l'apparence. <br><br>  Tr√®s probablement, la bonne approche serait de s√©parer compl√®tement les tampons de profondeur et de couleur;  le retour sur investissement sera un rendu en deux passes.  Il convient d'explorer ce probl√®me lors de la configuration du syst√®me. <br><br><h3>  Lissage en profondeur </h3><br>  Enfin, la chose la plus importante dans la technique verte.  Nous avons rendu un tas de boules sph√©riques dans le tampon de profondeur, mais en r√©alit√©, l'eau n'est pas constitu√©e de ¬´boules¬ª.  Alors maintenant, nous prenons cette approximation et la rendons floue pour qu'elle ressemble davantage √† la surface d'un liquide. <br><br>  L'approche na√Øve consiste simplement √† appliquer des profondeurs de bruit gaussiennes √† l'ensemble du tampon.  Cela cr√©e des r√©sultats √©tranges - il lisse les points √©loign√©s plus que les points proches et brouille les bords des silhouettes.  Au lieu de cela, nous pouvons modifier le rayon de flou en profondeur et utiliser un flou bilat√©ral pour enregistrer les bords. <br><br>  Un seul probl√®me se pose ici: de tels changements rendent le flou indivisible.  Le flou partag√© peut √™tre effectu√© en deux passes: flou horizontalement, puis verticalement.  Le flou indiscernable se fait en un seul passage.  Cette diff√©rence est importante car le flou partag√© est mis √† l'√©chelle de fa√ßon lin√©aire (O (w) + O (h)) et le flou non partag√© est mis √† l'√©chelle de fa√ßon nette (O (w * h)).  Le flou √† grande √©chelle et non partag√© devient rapidement inapplicable dans la pratique. <br><br>  En tant qu'adultes, d√©veloppeurs responsables, nous pouvons faire le pas √©vident: fermer les yeux, pr√©tendre que le bruit bidirectionnel * est * partag√©, et toujours l'impl√©menter avec des all√©es horizontales et verticales s√©par√©es. <br><br>  Green dans sa pr√©sentation a d√©montr√© que bien que cette approche <i>cr√©e des</i> artefacts dans le r√©sultat r√©sultant (en particulier lors de la reconstruction de normales), la phase d'ombrage les masque bien.  Lorsque vous travaillez avec les jets d'eau plus √©troits que je cr√©e, ces artefacts sont encore moins visibles et n'affectent pas particuli√®rement le r√©sultat. <br><br><h3>  Ombrage </h3><br>  Nous avons finalement fini de travailler avec le tampon fluide.  Passons maintenant √† la deuxi√®me partie de l'effet: l'ombrage et la composition de l'image principale. <br><br>  Nous rencontrons ici de nombreuses restrictions de rendu Unity.  J'ai d√©cid√© d'√©clairer l'eau uniquement avec la lumi√®re du soleil et de la skybox;  La prise en charge de sources d'√©clairage suppl√©mentaires n√©cessite soit plusieurs passes (c'est du gaspillage!) Soit la construction d'une structure de recherche d'√©clairage c√¥t√© GPU (co√ªteuse et plut√¥t compliqu√©e).  De plus, comme Unity ne donne pas acc√®s aux plans d'ombres et que les lumi√®res directionnelles utilisent des ombres d'espace d'√©cran (bas√©es sur un tampon de profondeur rendu par une g√©om√©trie opaque), nous n'avons pas acc√®s aux informations sur les ombres provenant d'une source de lumi√®re solaire.  Vous pouvez attacher un tampon de commande √† une source de lumi√®re du soleil pour cr√©er une carte d'ombre de l'espace d'√©cran sp√©cifiquement pour l'eau, mais jusqu'√† pr√©sent je ne l'ai pas fait. <br><br>  La derni√®re √©tape de l'ombrage est contr√¥l√©e par un script et utilise le tampon de commande pour envoyer des appels de tirage.  Cela est <i>n√©cessaire</i> car la texture du vecteur de mouvement (utilis√©e pour l'anti-aliasing temporaire (TAA) et le flou de mouvement) ne peut pas √™tre utilis√©e pour le rendu direct √† l'aide de Graphics.SetRenderTarget ().  Dans le script joint √† la cam√©ra principale, nous √©crivons ce qui suit: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... m_QuadMesh = new Mesh(); m_QuadMesh.subMeshCount = 1; m_QuadMesh.vertices = new Vector3[] { new Vector3(0, 0, 0.1f), new Vector3(1, 0, 0.1f), new Vector3(1, 1, 0.1f), new Vector3(0, 1, 0.1f), }; m_QuadMesh.uv = new Vector2[] { new Vector2(0, 0), new Vector2(1, 0), new Vector2(1, 1), new Vector2(0, 1), }; m_QuadMesh.triangles = new int[] { 0, 1, 2, 0, 2, 3, }; m_QuadMesh.UploadMeshData(false); m_CommandBuffer = new CommandBuffer(); m_CommandBuffer.Clear(); m_CommandBuffer.SetProjectionMatrix( GL.GetGPUProjectionMatrix( Matrix4x4.Ortho(0, 1, 0, 1, -1, 100), false)); m_CommandBuffer.SetRenderTarget( BuiltinRenderTextureType.CameraTarget, BuiltinRenderTextureType.CameraTarget); m_CommandBuffer.DrawMesh( m_QuadMesh, Matrix4x4.identity, m_Mat, 0, m_Mat.FindPass("LIQUIDCOMPOSITE")); m_CommandBuffer.SetRenderTarget( BuiltinRenderTextureType.MotionVectors, BuiltinRenderTextureType.Depth); m_CommandBuffer.DrawMesh( m_QuadMesh, Matrix4x4.identity, m_Mat, 0, m_Mat.FindPass("MOTION")); }</span></span></code> </pre> <br>  Les tampons de couleur et les vecteurs de mouvement ne peuvent pas √™tre rendus simultan√©ment avec MRT (cibles de rendu multiples).  Je n'ai pas pu trouver la raison.  De plus, ils n√©cessitent une liaison √† des tampons de profondeur diff√©rents.  Heureusement, nous √©crivons la profondeur dans <i>ces deux</i> tampons de profondeur, donc la re-projection de l'anti-aliasing temporaire fonctionne tr√®s bien (oh, c'est un plaisir de travailler avec le moteur de bo√Æte noire). <br><br>  Dans chaque image, nous lan√ßons un rendu composite de OnPostRender (): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">RenderTexture </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateRefractionTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RenderTexture result = RenderTexture.GetTemporary(m_MainCamera.activeTexture.descriptor); Graphics.Blit(m_MainCamera.activeTexture, result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPostRender</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ScreenspaceLiquidCamera &amp;&amp; ScreenspaceLiquidCamera.IsReady()) { RenderTexture refraction_texture = GenerateRefractionTexture(); m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, ScreenspaceLiquidCamera.GetColorBuffer()); m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_MainTex_TexelSize"</span></span>, ScreenspaceLiquidCamera.GetTexelSize()); m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_LiquidRefractTexture"</span></span>, refraction_texture); m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_MainDepth"</span></span>, ScreenspaceLiquidCamera.GetDepthBuffer()); m_Mat.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_DepthViewFromClip"</span></span>, ScreenspaceLiquidCamera.GetProjection().inverse); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SunLight) { m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_SunDir"</span></span>, transform.InverseTransformVector(-SunLight.transform.forward)); m_Mat.SetColor(<span class="hljs-string"><span class="hljs-string">"_SunColor"</span></span>, SunLight.color * SunLight.intensity); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_SunDir"</span></span>, transform.InverseTransformVector(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); m_Mat.SetColor(<span class="hljs-string"><span class="hljs-string">"_SunColor"</span></span>, Color.white); } m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_ReflectionProbe"</span></span>, ReflectionProbe.defaultTexture); m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_ReflectionProbe_HDR"</span></span>, ReflectionProbe.defaultTextureHDRDecodeValues); Graphics.ExecuteCommandBuffer(m_CommandBuffer); RenderTexture.ReleaseTemporary(refraction_texture); } }</code> </pre> <br>  Et c'est l√† que la participation du processeur se termine, plus tard seuls les shaders vont. <br><br>  Commen√ßons par le passage des vecteurs de mouvement.  Voici √† quoi ressemble le shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span><span class="hljs-meta"> sampler2D _MainDepth; sampler2D _MainTex; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert(appdata v) { v2f o; o.vertex = mul(UNITY_MATRIX_P, v.vertex); o.uv = v.uv; return o; } struct frag_out { float4 color : SV_Target; float depth : SV_Depth; }; frag_out frag(v2f i) { frag_out o; float4 fluid = tex2D(_MainTex, i.uv); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (fluid.a == 0) discard; o.depth = tex2D(_MainDepth, i.uv).r; float2 vel = fluid.gb / fluid.a; o.color = float4(vel, 0, 1); return o; }</span></span></code> </pre> <br>  La vitesse dans l'espace de l'√©cran est stock√©e dans les canaux vert et bleu du tampon fluide.  Puisque nous avons mis la vitesse √† l'√©chelle en fonction de l'√©paisseur lors du rendu du tampon, nous divisons √† nouveau l'√©paisseur totale (situ√©e dans le canal alpha) pour obtenir une vitesse moyenne pond√©r√©e. <br><br>  Il convient de noter que lorsque vous travaillez avec de grands volumes d'eau, une autre m√©thode de traitement du tampon de vitesse peut √™tre n√©cessaire.  Puisque nous effectuons un rendu sans m√©lange, les vecteurs de mouvement pour tout ce qui se trouve <i>derri√®re l'</i> eau sont perdus, d√©truisant le TAA et le flou de mouvement de ces objets.  Lorsque vous travaillez avec de minces jets d'eau, ce n'est pas un probl√®me, mais cela peut interf√©rer lorsque vous travaillez avec une piscine ou un lac lorsque nous avons besoin de TAA ou d'objets flou de mouvement pour √™tre clairement visibles √† travers la surface. <br><br>  Le passage d'ombrage principal est plus int√©ressant.  Notre premi√®re priorit√© apr√®s masquage avec l'√©paisseur du liquide est de reconstruire la position et la normale de l'espace de visualisation (espace de visualisation). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clip_z = tex2D(_MainDepth, uv).r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clip_x = uv.x * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clip_y = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - uv.y * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; float4 clip_p = float4(clip_x, clip_y, clip_z, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); float4 view_p = mul(_DepthViewFromClip, clip_p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (view_p.xyz / view_p.w); } <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReconstructNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 vp11)</span></span></span><span class="hljs-function"> </span></span>{ float3 vp12 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); float3 vp10 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)); float3 vp21 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); float3 vp01 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); float3 dvpdx0 = vp11 - vp12; float3 dvpdx1 = vp10 - vp11; float3 dvpdy0 = vp11 - vp21; float3 dvpdy1 = vp01 - vp11; <span class="hljs-comment"><span class="hljs-comment">// Pick the closest float3 dvpdx = dot(dvpdx0, dvpdx0) &gt; dot(dvpdx1, dvpdx1) ? dvpdx1 : dvpdx0; float3 dvpdy = dot(dvpdy0, dvpdy0) &gt; dot(dvpdy1, dvpdy1) ? dvpdy1 : dvpdy0; return normalize(cross(dvpdy, dvpdx)); }</span></span></code> </pre> <br>  C'est une fa√ßon co√ªteuse de reconstruire la position de l'espace de visualisation: on prend la position dans l'espace clip et on effectue l'op√©ration inverse de projection. <br><br>  Apr√®s avoir trouv√© un moyen de reconstruire les positions, les normales sont plus simples: nous calculons la position des points voisins dans le tampon de profondeur et construisons une base tangente √† partir d'eux.  Pour travailler avec les bords des silhouettes, nous √©chantillonnons dans les deux directions et s√©lectionnons le point le plus proche de l'espace de vue pour reconstruire la normale.  Cette m√©thode fonctionne √©tonnamment bien et ne pose de probl√®mes que dans le cas d'objets tr√®s minces. <br><br>  Cela signifie que nous effectuons cinq op√©rations de projection inverse distinctes par pixel (pour le point actuel et quatre voisines).  Il existe un moyen moins cher, mais ce post est d√©j√† trop long, donc je le laisse pour plus tard. <br><br>  Les normales r√©sultantes sont: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2c/0ed/7f6/b2c0ed7f6cfcc66473ff4e5380c46894.png"></div><br>  Je d√©forme cette normale calcul√©e en utilisant les d√©riv√©es de la valeur de bruit du tampon fluide, mise √† l'√©chelle par le param√®tre de force et normalis√©e en divisant par l'√©paisseur du jet (pour la m√™me raison que pour la vitesse): <br><br><pre> <code class="cpp hljs">N.xy += NoiseDerivatives(i.uv, fluid.r) * (_NoiseStrength / fluid.a); N = normalize(N);</code> </pre> <br>  Nous pouvons enfin proc√©der √† l'ombrage lui-m√™me.  L'ombrage de l'eau se compose de trois parties principales: la r√©flexion sp√©culaire, la r√©fraction sp√©culaire et la mousse. <br><br>  La r√©flexion est un GGX standard enti√®rement repris du shader Unity standard.  (Avec une correction, le F0 correct de 2% est utilis√© pour l'eau.) <br><br>  Avec la r√©fraction, tout est plus int√©ressant.  Une r√©fraction correcte n√©cessite un lancer de rayons (ou un raymarching pour un r√©sultat approximatif).  Heureusement, la r√©fraction est moins intuitive √† l'≈ìil que la r√©flexion, et donc des r√©sultats incorrects ne sont pas si visibles.  Par cons√©quent, nous d√©calons l'√©chantillon UV pour la texture r√©fractive par les normales x et y, mises √† l'√©chelle par le param√®tre d'√©paisseur et de force: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> aspect = _MainTex_TexelSize.y * _MainTex_TexelSize.z; float2 refract_uv = (i.grab_pos.xy + N.xy * float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, -aspect) * fluid.a * _RefractionMultiplier) / i.grab_pos.w; float4 refract_color = tex2D(_LiquidRefractTexture, refract_uv);</code> </pre> <br>  (Notez que la correction de corr√©lation est utilis√©e; elle est <i>facultative</i> - apr√®s tout, ce n'est qu'une approximation, mais l'ajouter est assez simple.) <br><br>  Cette lumi√®re r√©fract√©e passe √† travers le liquide, donc une partie est absorb√©e: <br><br><pre> <code class="cpp hljs">float3 water_color = _AbsorptionColor.rgb * _AbsorptionIntensity; refract_color.rgb *= <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-water_color * fluid.a);</code> </pre> <br>  Notez que _AbsorptionColor est d√©termin√© exactement √† l'oppos√© de la mani√®re attendue: les valeurs de chaque canal indiquent la quantit√© de lumi√®re <i>absorb√©e</i> plut√¥t que transmise.  Par cons√©quent, _AbsorptionColor avec une valeur de (1, 0, 0) ne donne pas le rouge, mais une couleur turquoise (turquoise). <br><br>  La r√©flexion et la r√©fraction sont m√©lang√©es √† l'aide de coefficients de Fresnel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spec_blend = lerp(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - ldoth, <span class="hljs-number"><span class="hljs-number">5</span></span>)); float4 clear_color = lerp(refract_color, spec, spec_blend);</code> </pre> <br>  Jusqu'√† ce moment, nous avons respect√© les r√®gles (principalement) et utilis√© un ombrage physique. <br><br>  Il est assez bon, mais il a un probl√®me avec l'eau.  C'est un peu difficile √† voir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff2/4f2/ba2/ff24f2ba2dad5dc6fe7714ad3fd55124.png"></div><br>  Pour le r√©parer, ajoutons un peu de mousse. <br><br>  La mousse appara√Æt lorsque l'eau est turbulente et l'air se m√©lange √† l'eau pour former des bulles.  Ces bulles cr√©ent toutes sortes de variations de r√©flexion et de r√©fraction, ce qui donne √† toute l'eau une sensation d'√©clairage diffus.  Je mod√©liserai ce comportement avec de la lumi√®re ambiante envelopp√©e: <br><br><pre> <code class="cpp hljs">float3 foam_color = _SunColor * saturate((dot(N, L)*<span class="hljs-number"><span class="hljs-number">0.25f</span></span> + <span class="hljs-number"><span class="hljs-number">0.25f</span></span>));</code> </pre> <br>  Il est ajout√© √† la couleur finale √† l'aide d'un facteur sp√©cial, en fonction du bruit du fluide et du coefficient de Fresnel ramolli: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam_blend = saturate(fluid.r * _NoiseStrength) * lerp(<span class="hljs-number"><span class="hljs-number">0.05f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - ndotv, <span class="hljs-number"><span class="hljs-number">3</span></span>)); clear_color.rgb += foam_color * saturate(foam_blend);</code> </pre> <br>  L'√©clairage ambiant envelopp√© est normalis√© pour conserver l'√©nergie afin qu'il puisse √™tre utilis√© comme approximation de la diffusion.  Le m√©lange de la couleur de la mousse est plus visible.  Il s'agit d'une violation assez claire de la loi de conservation de l'√©nergie. <br><br>  Mais en g√©n√©ral, tout semble bon et rend le flux plus visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/216/ca8/1f5/216ca81f5eb506eab2dbcfc730a904b4.png"></div><br><h3>  Poursuite des travaux et am√©liorations </h3><br>  Dans le syst√®me cr√©√©, beaucoup peut √™tre am√©lior√©. <br><br><ul><li>  Utilisation de plusieurs couleurs.  √Ä l'heure actuelle, l'absorption est calcul√©e uniquement au dernier stade de l'ombrage et utilise une couleur et une luminosit√© constantes pour tout le liquide sur l'√©cran.  La prise en charge de diff√©rentes couleurs est possible, mais n√©cessite un deuxi√®me tampon de couleur et la solution de l'int√©grale d'absorption pour chaque particule dans le processus de rendu du tampon fluide de base.  Cela pourrait potentiellement √™tre une op√©ration co√ªteuse. </li><li>  Couverture compl√®te.  Ayant acc√®s √† la structure de recherche d'√©clairage c√¥t√© GPU (soit √† la main, soit gr√¢ce √† la liaison avec le nouveau pipeline de rendu Unity HD), nous pouvons √©clairer correctement l'eau avec un nombre illimit√© de sources de lumi√®re et cr√©er le bon √©clairage ambiant. </li><li>  Am√©lioration de la r√©fraction.  Avec les textures floues de la texture d'arri√®re-plan, nous pouvons mieux simuler la r√©fraction pour les surfaces rugueuses.  En pratique, cela n'est pas tr√®s utile pour de petites pulv√©risations de liquide, mais peut √™tre utile pour des volumes plus importants. </li></ul><br>  Si j'en avais l'occasion, j'am√©liorerais ce syst√®me √† la perte d'une impulsion, mais pour le moment on peut la qualifier de compl√®te. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420495/">https://habr.com/ru/post/fr420495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420479/index.html">Injection de d√©pendances dans le service Apache Ignite.NET</a></li>
<li><a href="../fr420487/index.html">Les entreprises demandent le droit aux donn√©es personnelles des utilisateurs</a></li>
<li><a href="../fr420489/index.html">Les nouveaux processeurs ARM peuvent rivaliser avec le Core i5</a></li>
<li><a href="../fr420491/index.html">Ma mani√®re de guerrier, ou comment j'ai pr√©par√© une demande de vie √† Sailfish</a></li>
<li><a href="../fr420493/index.html">Le service am√©ricain de commande de produits alimentaires peut-il devenir Amazon dans le monde des restaurants</a></li>
<li><a href="../fr420497/index.html">Singularit√© des l√©gumes: Kroger lance des robots pour les clients des fruits et l√©gumes en Arizona</a></li>
<li><a href="../fr420499/index.html">Anatomie des syst√®mes de recommandation. Premi√®re partie</a></li>
<li><a href="../fr420501/index.html">Linux en RAM: debirf way 2018</a></li>
<li><a href="../fr420503/index.html">JS Developer Day, diff√©rentes villes et communaut√©s - un jour f√©ri√©</a></li>
<li><a href="../fr420505/index.html">OpenAI Five remportera-t-il l'√©quipe professionnelle de l'International</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>