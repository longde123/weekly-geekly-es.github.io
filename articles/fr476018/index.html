<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèΩ üòû üßñüèª Comment fonctionne Flutter üò≥ üç† üë∂üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment Flutter fonctionne-t-il r√©ellement? 


 Que sont les widgets, les √©l√©ments, BuildContext, RenderOject, Bindings? .. 


 Difficult√©: d√©butant 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment fonctionne Flutter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  Comment Flutter fonctionne-t-il r√©ellement? </p><br><p>  Que sont les widgets, les √©l√©ments, BuildContext, RenderOject, Bindings? .. </p><br><p>  Difficult√©: <em>d√©butant</em> </p><br><h1 id="vstuplenie">  Entr√©e </h1><br><p>  L'ann√©e derni√®re ( <em>note: en 2018</em> ), lorsque j'ai commenc√© mon voyage dans le monde fabuleux de Flutter, il y avait tr√®s peu d'informations sur Internet par rapport √† ce qu'elles sont aujourd'hui.  Maintenant, malgr√© le fait que beaucoup de documents ont d√©j√† √©t√© √©crits, seule une petite partie d'entre eux parle du fonctionnement r√©el de Flutter. </p><br><p>  Que sont les widgets ( <em>widgets</em> ), les √©l√©ments ( <em>√©l√©ments</em> ), BuildContext?  Pourquoi Flutter est-il rapide?  Pourquoi parfois cela ne fonctionne pas comme pr√©vu?  Quels sont les arbres et pourquoi sont-ils n√©cessaires? </p><br><p>  Dans 95% des cas, lors de l'√©criture d'une application, vous ne traiterez que des widgets afin d'afficher quelque chose ou d'interagir avec.  Mais ne vous √™tes-vous jamais vraiment demand√© comment fonctionne toute cette magie √† l'int√©rieur?  Comment le syst√®me sait-il quand actualiser l'√©cran et quelles parties doivent √™tre mises √† jour? </p><br><p>  <strong>Contenu:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Entr√©e</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: Contexte</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un peu sur l'appareil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interface entre le code et l'appareil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©rer le rendu Flutter Engine Flutter Engine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RenderView et RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liaisons d'initialisation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SchedulerBinding</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reliure par geste</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reliure de rendu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liaison des widgets</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Des widgets aux pixels</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Configuration immuable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La structure hi√©rarchique des widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">For√™t derri√®re les arbres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre l'√©l√©ment dans un arbre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3 cat√©gories de widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types d'articles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment les widgets et les √©l√©ments fonctionnent ensemble</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: G√©rer les gestes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: Animations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Image compl√®te</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quelle est l'utilit√© d'un BuildContext?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pour le plaisir</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><h1 id="chast-1-predystoriya">  Partie 1: Contexte </h1><br><p>  La premi√®re partie de l'article pr√©sente quelques concepts cl√©s qui seront utilis√©s dans la deuxi√®me partie du mat√©riel et aideront √† mieux comprendre Flutter. </p><br><h2 id="nemnogo-ob-ustroystve">  Un peu sur l'appareil </h2><br><p>  Commen√ßons par la fin et revenons aux bases. </p><br><p>  Lorsque vous regardez votre appareil ou, plus pr√©cis√©ment, l'application qui s'ex√©cute sur votre appareil, vous ne voyez que l'√©cran. </p><br><p>  En fait, tout ce que vous voyez, ce sont les pixels, qui forment ensemble une image bidimensionnelle, et lorsque vous touchez l'√©cran avec votre doigt, l'appareil ne reconna√Æt que la position de votre doigt sur la vitre. </p><br><p>  Toute la magie de l'application (d'un point de vue visuel) est dans la plupart des cas de mettre √† jour cette image en fonction des interactions suivantes: </p><br><ul><li>  avec l'√©cran de l'appareil ( <em>par exemple, un doigt sur la vitre</em> ) </li><li>  avec le r√©seau ( <em>par exemple, communication avec le serveur</em> ) </li><li>  au fil du temps ( <em>par exemple animation</em> ) </li><li>  avec d'autres capteurs externes </li></ul><br><p>  La visualisation de l'image sur l'√©cran est assur√©e par du mat√©riel (affichage), qui met r√©guli√®rement (g√©n√©ralement 60 fois par seconde) √† jour l'affichage.  C'est ce qu'on appelle le "taux de rafra√Æchissement" et est exprim√© en Hz (Hertz). </p><br><p>  L'√©cran re√ßoit des informations √† afficher du GPU (Graphics Processing Unit), qui est un circuit √©lectronique sp√©cialis√© optimis√© et con√ßu pour former rapidement des images √† partir de certaines donn√©es (polygones et textures).  Le nombre de fois par seconde que le processeur graphique peut g√©n√©rer une ¬´image¬ª (= tampon d'image) pour l'afficher et l'envoyer au mat√©riel s'appelle la fr√©quence d'images ( <em>note: fr√©quence d'images</em> ).  Ceci est mesur√© en utilisant un bloc d'images par seconde ( <em>par exemple 60 images par seconde ou 60 images par seconde</em> ). </p><br><p>  Vous pouvez me demander pourquoi j'ai commenc√© cet article avec les concepts d'une image bidimensionnelle affich√©e par un GPU / mat√©riel et un capteur de verre physique, et quel est le lien avec les widgets Flutter r√©guliers? </p><br><p>  Je pense qu'il sera plus facile de comprendre comment Flutter fonctionne r√©ellement si nous le regardons de ce point de vue, car l'un des principaux objectifs de l'application Flutter est de cr√©er cette image bidimensionnelle et de lui permettre d'interagir avec elle.  Aussi parce que dans Flutter, croyez-le ou non, presque tout est d√ª √† la n√©cessit√© de mettre √† jour l'√©cran rapidement et au bon moment! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Interface entre le code et l'appareil </h2><br><p>  Quoi qu'il en soit, tous ceux qui s'int√©ressent √† Flutter ont d√©j√† vu l'image suivante qui d√©crit l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">architecture</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">haut niveau</a> de Flutter. </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Lorsque nous √©crivons une application Flutter √† l'aide de Dart, nous restons au niveau <em>Flutter Framework</em> (surlign√© en vert). </p><br><p>  <em>Le cadre Flutter</em> interagit avec le <em>moteur Flutter</em> (en bleu) via une couche d'abstraction appel√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Window</a> .  Ce niveau d'abstraction fournit un certain nombre d'API pour l'interaction indirecte avec l'appareil. </p><br><p>  √âgalement √† travers ce niveau d'abstraction, le <em>moteur Flutter</em> avertit le <em>cadre Flutter</em> lorsque: </p><br><ul><li>  un √©v√©nement d'int√©r√™t se produit au niveau de l'appareil (changement d'orientation, changement de param√®tres, probl√®me de m√©moire, √©tat de fonctionnement de l'application ...) </li><li>  un √©v√©nement se produit au niveau du verre (= geste) </li><li>  canal de plate-forme envoie des donn√©es </li><li>  mais aussi principalement lorsque le <strong>moteur Flutter est pr√™t √† rendre un nouveau cadre</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  G√©rer le rendu Flutter Engine Flutter Engine </h2><br><p>  C'est difficile √† croire, mais c'est vrai.  Sauf dans certains cas ( <em>voir ci-dessous</em> ), aucun code <em>Flutter Framework</em> n'est ex√©cut√© sans d√©marrer le rendu <em>Flutter Engine</em> . </p><br><p>  Exceptions: </p><br><ul><li>  Geste / Geste (= √©v√©nement sur verre) </li><li>  Messages de la plateforme (= messages g√©n√©r√©s par un appareil, comme le GPS) </li><li>  Messages de l'appareil (= messages li√©s √† un changement d'√©tat de l'appareil, par exemple, orientation, application envoy√©e en arri√®re-plan, alertes de m√©moire, param√®tres de l'appareil ...) </li><li>  R√©ponses futures ou http </li></ul><br><p>  <em>(Entre nous, vous pouvez r√©ellement appliquer un changement visuel sans appeler du moteur Flutter, mais ce n'est <strong>pas recommand√©</strong> )</em> </p><br><p>  Vous me demandez: "Si une sorte de code li√© au <em>geste</em> est ex√©cut√© et provoque un changement visuel, ou si j'utilise une <em>minuterie</em> pour d√©finir la fr√©quence de la t√¢che qui conduit √† des changements visuels (par exemple, une animation), alors comment √ßa marche?" </p><br><p>  Si vous souhaitez qu'un changement visuel se produise ou qu'un code soit ex√©cut√© sur la base d'une minuterie, vous devez indiquer au <em>moteur Flutter</em> que quelque chose doit √™tre dessin√©. </p><br><p>  Habituellement, la prochaine fois que le <em>moteur Flutter est mis √†</em> jour, il fait appel √† <em>Flutter Framework</em> pour ex√©cuter du code et fournit finalement une nouvelle sc√®ne pour le rendu. </p><br><p>  Par cons√©quent, une question importante est de savoir comment le moteur Flutter organise tous les comportements des applications en fonction du rendu. </p><br><p>  Pour avoir une id√©e des m√©canismes internes, regardez l'animation suivante: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Une br√®ve explication (plus de d√©tails viendront plus tard): </p><br><ul><li>  Certains √©v√©nements externes (geste, r√©ponses http, etc.) ou m√™me futurs peuvent d√©clencher des t√¢ches qui n√©cessitent de mettre √† jour l'affichage.  Le message correspondant est envoy√© au <em>moteur Flutter</em> (= <em>Schedule Frame</em> ) </li><li>  Lorsque le <em>moteur Flutter est</em> pr√™t √† commencer la mise √† jour du rendu, il cr√©e une demande <em>Begin Frame</em> </li><li>  Cette requ√™te <em>Begin Frame</em> est intercept√©e par <em>Flutter Framework</em> , qui effectue des t√¢ches principalement li√©es aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">tickers</a> (par exemple, l'animation) </li><li>  Ces t√¢ches peuvent recr√©er la demande pour un rendu ult√©rieur (exemple: l'animation n'a pas termin√© son ex√©cution, et pour la terminer, elle devra obtenir une autre image de <em>d√©but</em> √† un stade ult√©rieur) </li><li>  Ensuite, le <em>moteur Flutter</em> envoie un <em>cadre de dessin</em> , qui est intercept√© par le <em>cadre Flutter</em> , qui recherchera toutes les t√¢ches li√©es √† la mise √† jour de la mise en page en termes de structure et de taille </li><li>  Une fois toutes ces t√¢ches termin√©es, il passe aux t√¢ches associ√©es √† la mise √† jour de la mise en page en termes de rendu </li><li>  S'il y a quelque chose sur l'√©cran qui doit √™tre dessin√©, alors une nouvelle sc√®ne ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">sc√®ne</a> ) pour la visualisation est envoy√©e au <em>moteur Flutter</em> , qui mettra √† jour l'√©cran </li><li>  <em>Flutter Framework</em> effectue <em>ensuite</em> toutes les t√¢ches qui seront effectu√©es apr√®s le rendu (= rappels PostFrame), et toutes les autres t√¢ches ult√©rieures qui ne sont pas li√©es au rendu </li><li>  ... et ce processus recommence </li></ul><br><h2 id="renderview-i-renderobject">  RenderView et RenderObject </h2><br><p>  Avant de plonger dans les d√©tails du workflow, il est temps d'introduire le concept de l' <em>arbre de rendu</em> . </p><br><p>  Comme mentionn√© pr√©c√©demment, tout sera finalement converti en pixels qui seront affich√©s √† l'√©cran, et <em>Flutter Framework</em> convertira les <em>widgets</em> que nous utilisons pour d√©velopper l'application en blocs visuels qui seront affich√©s √† l'√©cran. </p><br><p>  Ces parties visuelles correspondent √† des objets appel√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RenderObject</a> , qui sont utilis√©s pour: </p><br><ul><li>  d√©finir une certaine zone de l'√©cran en termes de taille, position, g√©om√©trie, ainsi qu'en termes de <em>"contenu rendu"</em> </li><li>  identifier les zones de l'√©cran qui peuvent √™tre affect√©es par les gestes (= toucher du doigt) </li></ul><br><p>  Un ensemble de tous les <em>objets de rendu</em> forme un arbre appel√© arbre de <em>rendu</em> .  En haut de cet arbre (= <em>racine</em> ), nous trouvons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> fournit une surface commune pour les objets d' <em>arbre de rendu</em> et est une version sp√©ciale de <em>RenderObject</em> . </p><br><p>  Visuellement, nous pourrions repr√©senter tout cela comme suit: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  La relation entre <em>Widget</em> et <em>RenderObject</em> sera discut√©e plus loin.  En attendant, il est temps d'aller un peu plus loin ... </p><br><h2 id="inicializaciya-bindings">  Liaisons d'initialisation </h2><br><p> Lorsque l'application Flutter d√©marre, la fonction <code>main()</code> est appel√©e en premier, ce qui appelle finalement la <code>runApp(Widget app)</code> . </p><br><p>  Lorsque la m√©thode <code>runApp()</code> est <code>runApp()</code> <em>Flutter Framework</em> initialise les interfaces entre lui-m√™me et le <em>moteur Flutter</em> .  Ces interfaces sont appel√©es <strong>liaisons</strong> ( <em>remarque: liaisons</em> ). </p><br><p>  <strong>Introduction aux liaisons</strong> </p><br><p>  Les liaisons sont con√ßues pour √™tre le lien entre le cadre et le moteur Flutter.  Ce n'est que par le biais de liaisons que les donn√©es peuvent √™tre √©chang√©es entre <em>Flutter Framework</em> et <em>Flutter Engine</em> . <br>  <em>(Il n'y a qu'une seule exception √† cette r√®gle -</em> RenderView <em>, mais nous en discuterons plus tard).</em> </p><br><p>  Chaque liaison est responsable du traitement d'un ensemble de t√¢ches, actions, √©v√©nements sp√©cifiques, regroup√©s par domaine d'activit√©. </p><br><p>  Au moment d'√©crire ces <em>lignes</em> , le <em>cadre Flutter</em> a 8 liaisons. </p><br><p>  Voici 4 d'entre eux qui seront consid√©r√©s dans cet article: </p><br><ul><li>  <em>SchedulerBinding</em> </li><li>  <em>Reliure par geste</em> </li><li>  <em>Reliure de rendu</em> </li><li>  <em>Liaison des widgets</em> </li></ul><br><p>  Pour √™tre complet, je mentionnerai les 4 autres: </p><br><ul><li>  <em>ServicesBinding</em> : responsable du traitement des messages envoy√©s par le <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">canal</a></em> de la <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">plateforme</a></em> </li><li>  <em>PaintingBinding</em> : responsable du traitement du cache d'image </li><li>  <em>SemanticsBinding</em> : r√©serv√© √† l'impl√©mentation ult√©rieure de tout ce qui touche √† la s√©mantique </li><li>  <em>TestWidgetsFlutterBinding</em> : utilis√© par la biblioth√®que de tests de widgets </li></ul><br><p>  Vous pouvez √©galement mentionner <em>WidgetsFlutterBinding</em> , mais ce n'est pas vraiment une liaison, mais plut√¥t une sorte d ' <em>"initialiseur de liaison"</em> . </p><br><p>  Le diagramme suivant montre l'interaction entre les liaisons, que je vais examiner ensuite, et le <em>moteur Flutter</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Examinons chacune de ces liaisons ¬´principales¬ª. </p><br><h3 id="schedulerbinding">  SchedulerBinding </h3><br><p>  Cette liaison a deux responsabilit√©s principales: </p><br><ul><li>  Dites <em>Flutter Engine</em> : <em>"H√©! La prochaine fois que vous n'√™tes pas occup√©, r√©veillez-moi pour que je puisse travailler un peu et vous dire quoi rendre, ou si j'ai besoin que vous m'appeliez plus tard ..."</em> </li><li>  √âcoutez et r√©agissez √† ces <em>¬´r√©veils troublants¬ª</em> (voir ci-dessous) </li></ul><br><p>  Quand <em>SchedulerBinding</em> demande un <em>r√©veil</em> ? </p><br><ul><li><p>  Quand <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ticker</a></em> doit <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">√©laborer</a></em> <em>une</em> nouvelle <em>tick</em> </p><br><p>  Par exemple, vous avez une animation, vous la d√©marrez.  L'animation est recadr√©e √† l'aide du <em>Ticker</em> , qui est appel√© √† intervalles r√©guliers (= <em>tick</em> ) pour effectuer un <em>rappel</em> .  Afin de lancer un tel <em>rappel</em> , nous devons informer le <em>moteur Flutter</em> afin qu'il nous r√©veille lors de la prochaine mise √† jour (= <em>Begin Frame</em> ).  Cela lancera le rappel du <em>ticker</em> pour terminer sa t√¢che.  Si le <em>ticker</em> doit encore continuer son ex√©cution, √† la fin de sa t√¢che, il appellera <em>SchedulerBinding</em> pour planifier une autre trame. </p><br></li><li><p>  Quand mettre √† jour l'affichage </p><br><p>  Par exemple, nous devons √©laborer un √©v√©nement qui entra√Æne un changement visuel (exemple: mise √† jour de la couleur d'une partie de l'√©cran, d√©filement, ajout / suppression de quelque chose √† l'√©cran), pour cela, nous devons prendre les mesures n√©cessaires pour finalement afficher l'image mise √† jour sur l'√©cran.  Dans ce cas, lorsqu'une telle modification se produit, <em>Flutter Framework</em> appelle <em>SchedulerBinding</em> pour planifier une autre image √† l'aide du <em>moteur Flutter</em> .  <em>(Plus tard, nous verrons comment cela fonctionne r√©ellement)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Reliure par geste </h3><br><p>  Cette liaison √©coute l'interaction avec le moteur en termes de <em>¬´doigt¬ª</em> (= <em>geste</em> ). </p><br><p>  Il est notamment charg√© de recevoir les donn√©es relatives aux <em>doigts</em> et de d√©terminer avec quelle (s) partie (s) de l'√©cran les gestes fonctionnent.  Il informe ensuite en cons√©quence / de ces pi√®ces. </p><br><h3 id="rendererbinding">  Reliure de rendu </h3><br><p>  Cette liaison est le lien entre le <em>moteur Flutter</em> et l' <em>arbre de rendu</em> .  Elle est responsable de: </p><br><ul><li>  √©couter les √©v√©nements g√©n√©r√©s par le moteur pour informer des changements appliqu√©s par l'utilisateur via les param√®tres de l'appareil qui affectent les effets visuels et / ou la s√©mantique </li><li>  message au moteur sur les changements qui seront appliqu√©s √† l'affichage </li></ul><br><p>  Pour fournir les modifications qui seront affich√©es √† l'√©cran, <em>RendererBinding</em> est responsable de la gestion de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">PipelineOwner</a> et de l'initialisation de <strong>RenderView</strong> . </p><br><p>  <em>PipelineOwner</em> est une sorte d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">orchestre</a> qui sait ce qui doit √™tre fait avec <em>RenderObject</em> conform√©ment au <em>composant</em> et coordonne ces actions. </p><br><h3 id="widgetsbinding">  Liaison des widgets </h3><br><p>  Cette liaison √©coute les modifications appliqu√©es par l'utilisateur via les param√®tres du p√©riph√©rique qui affectent la langue (= <em>locale</em> ) et la <em>s√©mantique</em> . </p><br><blockquote>  <em>Petite note</em> <br><br>  <em>Je suppose qu'√† un stade ult√©rieur du d√©veloppement de</em> Flutter, <em>tous les √©v√©nements li√©s √† la</em> s√©mantique <em>seront transf√©r√©s √†</em> SemanticsBinding <em>, mais au moment de la r√©daction de ce document, ce n'est pas le cas.</em> </blockquote><p>  De plus, <em>WidgetsBinding</em> est le lien entre les widgets et le <em>moteur Flutter</em> .  Elle est responsable de: </p><br><ul><li>  gestion du processus de traitement des modifications de la structure des widgets </li><li>  rendre l'appel </li></ul><br><p>  Le traitement des modifications apport√©es √† la structure des widgets est effectu√© √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>BuildOwner</em> garde la trace des widgets √† reconstruire et g√®re les autres t√¢ches qui s'appliquent √† la structure du widget dans son ensemble. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Partie 2. Des widgets aux pixels </h1><br><p>  Maintenant que nous avons appris les bases du travail interne de <em>Flutter</em> , il est temps de parler des widgets. </p><br><p>  Dans toute la documentation Flutter, vous lirez tous les <em>widgets</em> (widgets). </p><br><p>  C'est presque correct.  Mais pour √™tre un peu plus pr√©cis, je dirais plut√¥t: </p><br><blockquote>  Du c√¥t√© du d√©veloppeur, tout ce qui concerne l'interface utilisateur en termes de mise en page et d'interaction se fait √† l'aide de widgets. </blockquote><p>  Pourquoi tant de pr√©cision?  En plus du fait que <em>Widget</em> permet au d√©veloppeur de d√©terminer une partie de l'√©cran en termes de taille, de contenu, de mise en page et d'interaction, <strong>MAIS</strong> il y a beaucoup plus.  Alors qu'est-ce que <em>Widget</em> vraiment? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Configuration immuable </h2><br><p>  Si vous regardez le code source de <em>Flutter</em> , vous remarquerez la d√©finition suivante de la classe <em>Widget</em> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  Qu'est-ce que cela signifie? </p><br><p>  L'annotation <strong>"@immutable" est</strong> tr√®s importante et nous indique que <strong>toute variable de la classe Widget doit √™tre FINALE</strong> , en d'autres termes: "d√©finie et affect√©e <strong>UNE FOIS POUR TOUS</strong> ."  Ainsi, apr√®s avoir cr√©√© une instance, Widget ne pourra plus modifier ses variables internes. </p><br><blockquote>  <em>√âtant donn√© que Widget est immuable, il peut √™tre consid√©r√© comme une configuration statique.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  La structure hi√©rarchique des widgets </h2><br><p>  Lorsque vous concevez avec Flutter, vous d√©finissez la structure de vos √©crans √† l'aide de widgets quelque chose comme ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  Cet exemple utilise 7 widgets qui forment ensemble une structure hi√©rarchique.  Un sch√©ma tr√®s simplifi√© bas√© sur ce code est le suivant: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Comme vous pouvez le voir, le diagramme pr√©sent√© ressemble √† un arbre, o√π <em>SafeArea</em> est sa racine. </p><br><h2 id="les-za-derevyami">  For√™t derri√®re les arbres </h2><br><p>  Comme vous le savez d√©j√†, un widget lui-m√™me peut √™tre une agr√©gation d'autres widgets.  Par exemple, vous pouvez modifier le code pr√©c√©dent comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Cette option suppose que le widget <em>"MyOwnWidget"</em> lui-m√™me affichera <em>SafeArea</em> , <em>Scaffold</em> .  Mais la chose la plus importante dans cet exemple est que </p><br><blockquote>  <em>Un widget</em> peut repr√©senter une feuille, un n≈ìud dans un arbre, voire l'arbre lui-m√™me ou, pourquoi pas, une for√™t d'arbres ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  Comprendre l' <em>√©l√©ment</em> dans un arbre </h2><br><p>  Qu'est-ce que cela a √† voir avec √ßa? </p><br><p>  Comme nous le verrons plus loin, afin de pouvoir g√©n√©rer les pixels qui composent l'image affich√©e sur l'appareil, <em>Flutter</em> doit conna√Ætre en d√©tail toutes les petites parties qui composent l'√©cran, et afin de d√©terminer toutes les parties, il doit conna√Ætre l' <strong>expansion de</strong> tous les widgets. </p><br><p>  Pour illustrer ce point, consid√©rons le principe d'une poup√©e imbriqu√©e: lorsqu'elle est ferm√©e, vous ne voyez qu'une seule poup√©e, mais elle en contient une autre, qui en contient une autre et ainsi de suite ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Lorsque <em>Flutter</em> √©tend tous les widgets <em>(une partie de l'√©cran)</em> , ce sera comme obtenir toutes les poup√©es <em>(une partie de l'ensemble)</em> . </p><br><p>  L'image ci-dessous montre une partie de la structure hi√©rarchique finale des widgets correspondant au code pr√©c√©dent.  En jaune, j'ai mis en √©vidence les widgets mentionn√©s dans le code plus t√¥t, afin que vous puissiez les d√©finir dans l'arborescence finale. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Pr√©cision importante</em></strong> <br><br>  <em>Le langage "Widget tree" n'existe que pour faciliter la compr√©hension, car les programmeurs utilisent des widgets, mais il n'y a AUCUNE arborescence de widgets dans Flutter!</em> <br><br>  <em>En fait, il serait plus correct de dire "arbre des √©l√©ments"</em> </blockquote><p>  Il est temps d'introduire le concept d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">√©l√©ment</a> . </p><br><blockquote>  <em><strong>Chaque</strong> widget a <strong>un</strong> √©l√©ment.</em>  <em>Les √©l√©ments sont connect√©s les uns aux autres et forment un arbre.</em>  <em>Par cons√©quent, <strong>un √©l√©ment</strong> est une r√©f√©rence √† quelque chose dans l'arbre.</em> </blockquote><p>  Pour commencer, consid√©rez un √©l√©ment comme un n≈ìud qui a un parent et √©ventuellement un enfant.  En les reliant par le biais d'une relation <em>parent-enfant</em> , nous obtenons une structure arborescente. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Comme vous pouvez le voir, l'√©l√©ment pointe vers un widget, et <strong>peut</strong> √©galement pointer vers un objet de <em>rendu</em> . </p><br><blockquote>  <em>Encore mieux ... Element pointe vers Widget qui a <strong>cr√©√©</strong> cet √©l√©ment!</em> </blockquote><p>  R√©sumons: </p><br><ul><li>  Il n'y a pas d'arborescence de widgets, mais il y a une arborescence d'√©l√©ments </li><li>  Les √©l√©ments sont cr√©√©s par des widgets. </li><li>  L'√©l√©ment fait r√©f√©rence au widget qui l'a cr√©√©. </li><li>  √âl√©ments li√©s aux relations avec les parents </li><li>  Un article peut avoir un ¬´b√©b√©¬ª. </li><li>  Les √©l√©ments peuvent √©galement pointer vers un objet de <em>rendu.</em> </li></ul><br><blockquote>  <em><strong>Les √©l√©ments</strong> d√©terminent comment les parties des blocs affich√©s sont li√©es les unes aux autres.</em> </blockquote><p>  Afin de mieux imaginer o√π se situe le concept d' <em>un √©l√©ment</em> , regardons la repr√©sentation visuelle suivante: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Comme vous pouvez le voir, l'arborescence des √©l√©ments est la relation r√©elle entre les widgets et les <em>objets de rendu</em> . </p><br><p>  Mais pourquoi <em>Widget</em> cr√©e-t-il un <em>√©l√©ment</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 cat√©gories de widgets </h2><br><p>  Dans Flutter, les widgets sont divis√©s en 3 cat√©gories, je les appelle personnellement comme suit <em>(mais ce n'est que ma fa√ßon de les classer)</em> : </p><br><ul><li><p>  Proxy </p><br><p>  L'objectif principal de ces widgets est de stocker certaines informations (qui devraient √™tre accessibles aux widgets), faisant partie de l'arborescence bas√©e sur Proxy.  Un exemple de tels widgets est <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">InheritedWidget</a></strong> ou <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Ces widgets ne participent pas directement √† la formation de l'interface utilisateur, mais sont utilis√©s pour obtenir les informations qu'ils peuvent fournir. </p><br></li><li><p>  Renderer </p><br><p>  Ces widgets sont directement li√©s √† la disposition de l'√©cran, car ils d√©terminent (ou sont utilis√©s pour d√©terminer) la <em>taille</em> , la <em>position</em> , le <em>rendu</em> .  Des exemples typiques sont: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Row</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Column</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Stack</a></strong> , ainsi que <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Padding</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Align</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Opacity</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Composant </p><br><p>  Ce sont d'autres widgets qui fournissent directement non pas les informations finales li√©es aux tailles, positions, apparences, mais plut√¥t les donn√©es (ou astuces) qui seront utilis√©es pour obtenir les informations tr√®s finales.  Ces widgets sont commun√©ment appel√©s composants. </p><br><p>  Exemples: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Scaffold</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Text</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ce fichier PDF</a> r√©pertorie la plupart des widgets regroup√©s par cat√©gorie. </p><br><p>  Pourquoi cette s√©paration est-elle importante?  Parce que selon la cat√©gorie du widget, le type d'√©l√©ment correspondant est associ√© √† ... </p><br><h2 id="tipy-elementov">  Types d'articles </h2><br><p>  Il existe plusieurs types d'√©l√©ments: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Comme vous pouvez le voir dans l'image ci-dessus, les √©l√©ments sont divis√©s en 2 types principaux: </p><br><ul><li><p>  Componententlement </p><br><p>  Ces √©l√©ments ne <strong>sont</strong> pas <strong>directement</strong> responsables du rendu d'une partie de l'affichage. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Ces √©l√©ments sont responsables de parties de l'image affich√©e √† l'√©cran. </p><br></li></ul><br><p>  Super!  Tant d'informations, mais comment tout cela est-il li√© les uns aux autres et pourquoi est-il int√©ressant d'en parler? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  Comment les widgets et les √©l√©ments fonctionnent ensemble </h2><br><blockquote>  <em>Dans Flutter, toutes les m√©caniques sont bas√©es sur l'invalidation d'un √©l√©ment ou d'un renderObject.</em> </blockquote><p>  L'invalidation d'√©l√©ment peut √™tre effectu√©e des mani√®res suivantes: </p><br><ul><li>  en utilisant <code>setState</code> , qui invalide l'int√©gralit√© de <strong>StatefulElement</strong> (notez que je ne dis pas intentionnellement <em>StatefulWidget</em> ) </li><li>  via des notifications trait√©es par <strong>proxyElement</strong> (par exemple, InheritedWidget), qui invalide tout <em>√©l√©ment</em> qui d√©pend de ce <em>proxyElement</em> </li></ul><br><p>  Le r√©sultat de l' <em>invalidation</em> est qu'un lien vers l' <em>√©l√©ment</em> correspondant appara√Æt dans la liste des √©l√©ments <strong>sales</strong> . </p><br><p>  L' <em>invalidation de renderObject</em> signifie que la structure des √©l√©ments ne change pas du tout, mais il y a un changement au niveau de <em>renderObject</em> , par exemple: </p><br><ul><li>  changer sa taille, sa position, sa g√©om√©trie ... </li><li>  quelque chose doit √™tre repeint, par exemple, lorsque vous changez simplement la couleur d'arri√®re-plan, le style de police ... </li></ul><br><p>  Le r√©sultat d'une telle <em>invalidation</em> est un lien vers le <em>renderObject</em> correspondant dans la liste des objets de rendu <em>(renderObjects)</em> qui doivent √™tre reconstruits ou repeints. </p><br><p>  Quel que soit le type d'invalidation, <strong>SchedulerBinding</strong> est appel√© (vous vous en souvenez?) Pour demander au <strong>moteur Flutter</strong> de planifier une nouvelle trame. </p><br><p>  C'est exactement le moment o√π le <em>moteur Flutter</em> "r√©veille" le <em>SchedulerBinding</em> et toute la magie op√®re ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  Plus t√¥t dans cet article, nous avons not√© que <em>SchedulerBinding a</em> deux responsabilit√©s principales, dont l'une est sa disponibilit√© √† g√©rer les demandes faites par <em>Flutter Engine</em> li√©es √† la reconstruction de trames.  C'est le moment id√©al pour se concentrer sur cela. </p><br><p>  Le diagramme de s√©quence partielle ci-dessous montre ce qui se passe lorsque <em>SchedulerBinding</em> re√ßoit une demande <em>onDrawFrame ()</em> du <em>moteur Flutter</em> . </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>√âtape 1. √âl√©ments</strong> </p><br><p>  <em>WidgetsBinding</em> est <em>appel√©</em> et cette liaison prend d'abord en compte les modifications associ√©es aux √©l√©ments.  <em>WidgetsBinding</em> appelle la m√©thode <em>buildScope</em> de l'objet <em>buildOwner</em> , car <strong>BuildOwner</strong> est responsable du traitement de l'arborescence d'√©l√©ments.  Cette m√©thode parcourt la liste des √©l√©ments <em>sales</em> et demande leur <strong>reconstruction</strong> . </p><br><p>  Les principaux principes de cette m√©thode de <code>rebuild()</code> ) sont: </p><br><ol><li>  Il y a une demande pour reconstruire l'√©l√©ment (cela prendra la plupart du temps), appelant la m√©thode <code>build()</code> du widget auquel cet √©l√©ment fait r√©f√©rence (= <code>Widget build (BuildContext context) {...}</code> m√©thode).  Cette m√©thode <code>build()</code> retournera un nouveau widget </li><li>  Si l'√©l√©ment n'a pas ¬´d'enfant¬ª, alors un √©l√©ment est cr√©√© pour le nouveau widget (voir ci-dessous) ( <em>note: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">inflateWidget</a></em> ), sinon </li><li>  le nouveau widget est compar√© √† celui r√©f√©renc√© par l'enfant de l'√©l√©ment <br><ul><li>  S'ils sont interchangeables (= <em>le m√™me type de widget et la m√™me cl√©</em> ), la mise √† jour se produit et l'enfant est enregistr√©. </li><li>  S'ils ne sont pas interchangeables, l'enfant est supprim√© ( <em>~ supprim√©</em> ) et un √©l√©ment est cr√©√© pour le nouveau widget </li></ul></li><li>  Ce nouvel √©l√©ment est mont√© en tant qu'enfant de l'√©l√©ment.  ( <em>mont√©)</em> = ins√©r√© dans l'arborescence des √©l√©ments) </li></ol><br><p>  L'animation suivante va essayer de rendre cette explication un peu plus claire. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Remarque sur les widgets et les √©l√©ments</strong> </p><br><p>  Pour un nouveau widget, un √©l√©ment d'un <em>type sp√©cifique</em> est cr√©√© qui correspond √† <em>la cat√©gorie du</em> widget, √† savoir: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Chacun de ces types d'√©l√©ments a son propre comportement.  Par exemple: </p><br><ul><li>  <em>StatefulElement</em> appellera la m√©thode <code>widget.createState()</code> √† l'initialisation, qui cr√©era un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">√©tat</a> et l'associera √† l'√©l√©ment </li><li>  Lorsqu'un √©l√©ment de type <em>RenderObjectElement est</em> mont√©, il cr√©e un <em>RenderObject</em> .  Ce <em>renderObject</em> sera ajout√© √† l' <em>arbre de rendu</em> et associ√© √† l'√©l√©ment. </li></ul><br><p>  <strong>√âtape 2. renderObjects</strong> </p><br><p>  Maintenant, apr√®s avoir termin√© toutes les actions associ√©es aux √©l√©ments <em>sales</em> , l' <em>arbre des √©l√©ments</em> est stable.  Il est donc temps de consid√©rer le processus de visualisation. </p><br><p>  √âtant donn√© que <em>RendererBinding</em> est responsable du rendu de l' <em>arbre de rendu</em> , <em>WidgetsBinding</em> appelle la m√©thode <code>drawFrame</code> <em>RendererBinding</em> . </p><br><p>  Le diagramme partiel ci-dessous montre la s√©quence d'actions effectu√©es lors de la demande <em>drawFrame ()</em> . </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  √Ä cette √©tape, les actions suivantes sont effectu√©es: </p><br><ul><li>  Chaque <em>renderObject</em> marqu√© comme <em>sale</em> est demand√© de le composer (c'est-√†-dire de calculer sa taille et sa g√©om√©trie) </li><li>  Chaque <em>renderObject</em> marqu√© comme "ayant besoin d'√™tre redessin√©" est redessin√© en utilisant sa propre m√©thode de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">calque</a> </li><li>  La sc√®ne r√©sultante est form√©e et envoy√©e au <em>moteur Flutter</em> , afin que ce dernier la transf√®re √† l'√©cran de l'appareil </li><li>  Enfin, la s√©mantique est √©galement mise √† jour et envoy√©e au <em>moteur Flutter</em> </li></ul><br><p>  √Ä la fin de ce flux de travail, l'√©cran de l'appareil est actualis√©. </p><br><h1 id="chast-3-obrabotka-zhestov">  Partie 3: G√©rer les gestes </h1><br><p>  Les gestes (= <em>√©v√©nements li√©s aux actions des doigts sur la vitre</em> ) sont trait√©s √† l'aide de <em>GestureBinding</em> . </p><br><p>  Lorsque le <em>moteur Flutter</em> envoie des informations sur un √©v√©nement de mouvement via l'API <em>window.onPointerDataPacket</em> , <strong>GestureBinding l'</strong> intercepte, effectue une mise en m√©moire tampon et: </p><br><ol><li>  convertit les coordonn√©es fournies par le <em>moteur Flutter</em> pour correspondre au <strong>rapport de pixels de</strong> l' <strong>appareil</strong> , puis </li><li>  r√©cup√®re de <em>renderView une</em> liste de tous les <em>RenderObjects</em> qui se trouvent dans la partie de l'√©cran li√©e aux coordonn√©es de l'√©v√©nement </li><li>  puis parcourt la liste r√©sultante de <em>renderObjects</em> et envoie un √©v√©nement associ√© √† chacun d'eux </li><li>  si <em>renderObject</em> "√©coute" les √©v√©nements de ce type, il le traite </li></ol><br><p>  J'esp√®re maintenant que je comprends l'importance des <em>renderObjects</em> . </p><br><h1 id="chast-4-animacii">  Partie 4: Animations </h1><br><p>  Cette partie de l'article traite du concept d' <strong>animation</strong> et d'une compr√©hension approfondie de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ticker</a></strong> . </p><br><p>  Lorsque vous travaillez avec des animations, vous utilisez g√©n√©ralement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">AnimationController</a> ou n'importe quel widget pour les animations ( <em>remarque: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  Dans <em>Flutter,</em> tout ce qui concerne les animations fait r√©f√©rence √† <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ticker</a></em> .  <em>Ticker</em> , lorsqu'il est actif, n'a qu'une seule t√¢che: "il demande √† <em>SchedulerBinding d'</em> enregistrer un rappel et de dire au <em>moteur Flutter</em> de le r√©veiller lorsqu'un nouveau rappel appara√Æt."  Lorsque le <em>moteur Flutter est</em> pr√™t, il appelle <em>SchedulerBinding</em> via une requ√™te: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> acc√®de √† la liste de rappel du <em>ticker</em> et ex√©cute chacune. </p><br><p>  Chaque <em>tick est</em> intercept√© par un contr√¥leur "int√©ress√©" pour le traiter.  Si l'animation est termin√©e, le <em>ticker est</em> ¬´d√©sactiv√©¬ª, sinon le <em>ticker</em> demande un <em>SchedulerBinding</em> pour planifier un nouveau rappel.  Et ainsi de suite ... </p><br><h1 id="polnaya-kartina">  Image compl√®te </h1><br><p>  Nous avons maintenant appris comment fonctionne <em>Flutter</em> : </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Enfin, revenons au diagramme qui montre les diff√©rents types d'√©l√©ments, et consid√©rons la signature de l' <em>√©l√©ment</em> racine: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  Nous voyons le tr√®s c√©l√®bre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">BuildContext</a> !  Mais c'est quoi? </p><br><p>  <strong>BuildContext</strong> est une interface qui d√©finit un certain nombre de getters et de m√©thodes qui peuvent √™tre impl√©ment√©es par un √©l√©ment.  La plupart du temps, <em>BuildContext est</em> utilis√© dans la m√©thode <code>build()</code> de <em>StatelessWidget</em> ou <em>State</em> pour <em>StatefulWidget</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> n'est rien d'autre que l' <strong>√©l√©ment</strong> lui-m√™me, qui correspond √†</em> <br><ul><li>  <em>widget en cours de mise √† jour (√† l'int√©rieur des m√©thodes de <code>build</code> ou de <code>build</code> )</em> </li><li>  <em>StatefulWidget associ√© √† <strong>State</strong> dans lequel vous r√©f√©rencez la variable de contexte.</em> </li></ul><br></blockquote><p>  Cela signifie que la plupart des d√©veloppeurs travaillent constamment avec des √©l√©ments sans m√™me le savoir. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  Quelle est l'utilit√© d'un BuildContext? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> ‚Ä¶) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> ‚Äì  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    ‚Äì ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476018/">https://habr.com/ru/post/fr476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476000/index.html">Mises √† jour du g√©n√©rateur de mod√®les ML.NET</a></li>
<li><a href="../fr476002/index.html">Exp√©rience dans la recherche d'un poste de doctorant en Allemagne</a></li>
<li><a href="../fr476004/index.html">Chef de projet - mythe ou r√©alit√©? Ou pourquoi est-il n√©cessaire dans le domaine des effets visuels?</a></li>
<li><a href="../fr476006/index.html">Mythes et l√©gendes des constructeurs de SOC, ou 3 id√©es fausses sur les centres de surveillance et de r√©ponse aux cyberattaques</a></li>
<li><a href="../fr476008/index.html">Meetup MOSDROID: Connectez-vous √† la diffusion</a></li>
<li><a href="../fr476022/index.html">Vue Storefront: Relever le backend</a></li>
<li><a href="../fr476024/index.html">Meilleure architecture pour MVP: monolith, SOA, microservices ou sans serveur? .. Partie 1</a></li>
<li><a href="../fr476026/index.html">Cool Life Hacks pour travailler avec WSL (sous-syst√®me Windows pour Linux)</a></li>
<li><a href="../fr476032/index.html">Brunner Elektronik - Du syst√®me de CAO au cockpit</a></li>
<li><a href="../fr476034/index.html">Le plus sans d√©fense est le Faucon p√®lerin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>