<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏽 😞 🧖🏻 Comment fonctionne Flutter 😳 🍠 👶🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment Flutter fonctionne-t-il réellement? 


 Que sont les widgets, les éléments, BuildContext, RenderOject, Bindings? .. 


 Difficulté: débutant 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment fonctionne Flutter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/"><p><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p>  Comment Flutter fonctionne-t-il réellement? </p><br><p>  Que sont les widgets, les éléments, BuildContext, RenderOject, Bindings? .. </p><br><p>  Difficulté: <em>débutant</em> </p><br><h1 id="vstuplenie">  Entrée </h1><br><p>  L'année dernière ( <em>note: en 2018</em> ), lorsque j'ai commencé mon voyage dans le monde fabuleux de Flutter, il y avait très peu d'informations sur Internet par rapport à ce qu'elles sont aujourd'hui.  Maintenant, malgré le fait que beaucoup de documents ont déjà été écrits, seule une petite partie d'entre eux parle du fonctionnement réel de Flutter. </p><br><p>  Que sont les widgets ( <em>widgets</em> ), les éléments ( <em>éléments</em> ), BuildContext?  Pourquoi Flutter est-il rapide?  Pourquoi parfois cela ne fonctionne pas comme prévu?  Quels sont les arbres et pourquoi sont-ils nécessaires? </p><br><p>  Dans 95% des cas, lors de l'écriture d'une application, vous ne traiterez que des widgets afin d'afficher quelque chose ou d'interagir avec.  Mais ne vous êtes-vous jamais vraiment demandé comment fonctionne toute cette magie à l'intérieur?  Comment le système sait-il quand actualiser l'écran et quelles parties doivent être mises à jour? </p><br><p>  <strong>Contenu:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Entrée</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: Contexte</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un peu sur l'appareil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interface entre le code et l'appareil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gérer le rendu Flutter Engine Flutter Engine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RenderView et RenderObject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liaisons d'initialisation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SchedulerBinding</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reliure par geste</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reliure de rendu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liaison des widgets</a> <a name="habracut"></a></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Des widgets aux pixels</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Configuration immuable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La structure hiérarchique des widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forêt derrière les arbres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre l'élément dans un arbre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3 catégories de widgets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types d'articles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment les widgets et les éléments fonctionnent ensemble</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">onDrawFrame ()</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: Gérer les gestes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: Animations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Image complète</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Buildcontext</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quelle est l'utilité d'un BuildContext?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pour le plaisir</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><h1 id="chast-1-predystoriya">  Partie 1: Contexte </h1><br><p>  La première partie de l'article présente quelques concepts clés qui seront utilisés dans la deuxième partie du matériel et aideront à mieux comprendre Flutter. </p><br><h2 id="nemnogo-ob-ustroystve">  Un peu sur l'appareil </h2><br><p>  Commençons par la fin et revenons aux bases. </p><br><p>  Lorsque vous regardez votre appareil ou, plus précisément, l'application qui s'exécute sur votre appareil, vous ne voyez que l'écran. </p><br><p>  En fait, tout ce que vous voyez, ce sont les pixels, qui forment ensemble une image bidimensionnelle, et lorsque vous touchez l'écran avec votre doigt, l'appareil ne reconnaît que la position de votre doigt sur la vitre. </p><br><p>  Toute la magie de l'application (d'un point de vue visuel) est dans la plupart des cas de mettre à jour cette image en fonction des interactions suivantes: </p><br><ul><li>  avec l'écran de l'appareil ( <em>par exemple, un doigt sur la vitre</em> ) </li><li>  avec le réseau ( <em>par exemple, communication avec le serveur</em> ) </li><li>  au fil du temps ( <em>par exemple animation</em> ) </li><li>  avec d'autres capteurs externes </li></ul><br><p>  La visualisation de l'image sur l'écran est assurée par du matériel (affichage), qui met régulièrement (généralement 60 fois par seconde) à jour l'affichage.  C'est ce qu'on appelle le "taux de rafraîchissement" et est exprimé en Hz (Hertz). </p><br><p>  L'écran reçoit des informations à afficher du GPU (Graphics Processing Unit), qui est un circuit électronique spécialisé optimisé et conçu pour former rapidement des images à partir de certaines données (polygones et textures).  Le nombre de fois par seconde que le processeur graphique peut générer une «image» (= tampon d'image) pour l'afficher et l'envoyer au matériel s'appelle la fréquence d'images ( <em>note: fréquence d'images</em> ).  Ceci est mesuré en utilisant un bloc d'images par seconde ( <em>par exemple 60 images par seconde ou 60 images par seconde</em> ). </p><br><p>  Vous pouvez me demander pourquoi j'ai commencé cet article avec les concepts d'une image bidimensionnelle affichée par un GPU / matériel et un capteur de verre physique, et quel est le lien avec les widgets Flutter réguliers? </p><br><p>  Je pense qu'il sera plus facile de comprendre comment Flutter fonctionne réellement si nous le regardons de ce point de vue, car l'un des principaux objectifs de l'application Flutter est de créer cette image bidimensionnelle et de lui permettre d'interagir avec elle.  Aussi parce que dans Flutter, croyez-le ou non, presque tout est dû à la nécessité de mettre à jour l'écran rapidement et au bon moment! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom">  Interface entre le code et l'appareil </h2><br><p>  Quoi qu'il en soit, tous ceux qui s'intéressent à Flutter ont déjà vu l'image suivante qui décrit l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">architecture</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">haut niveau</a> de Flutter. </p><br><p><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p>  Lorsque nous écrivons une application Flutter à l'aide de Dart, nous restons au niveau <em>Flutter Framework</em> (surligné en vert). </p><br><p>  <em>Le cadre Flutter</em> interagit avec le <em>moteur Flutter</em> (en bleu) via une couche d'abstraction appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Window</a> .  Ce niveau d'abstraction fournit un certain nombre d'API pour l'interaction indirecte avec l'appareil. </p><br><p>  Également à travers ce niveau d'abstraction, le <em>moteur Flutter</em> avertit le <em>cadre Flutter</em> lorsque: </p><br><ul><li>  un événement d'intérêt se produit au niveau de l'appareil (changement d'orientation, changement de paramètres, problème de mémoire, état de fonctionnement de l'application ...) </li><li>  un événement se produit au niveau du verre (= geste) </li><li>  canal de plate-forme envoie des données </li><li>  mais aussi principalement lorsque le <strong>moteur Flutter est prêt à rendre un nouveau cadre</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine">  Gérer le rendu Flutter Engine Flutter Engine </h2><br><p>  C'est difficile à croire, mais c'est vrai.  Sauf dans certains cas ( <em>voir ci-dessous</em> ), aucun code <em>Flutter Framework</em> n'est exécuté sans démarrer le rendu <em>Flutter Engine</em> . </p><br><p>  Exceptions: </p><br><ul><li>  Geste / Geste (= événement sur verre) </li><li>  Messages de la plateforme (= messages générés par un appareil, comme le GPS) </li><li>  Messages de l'appareil (= messages liés à un changement d'état de l'appareil, par exemple, orientation, application envoyée en arrière-plan, alertes de mémoire, paramètres de l'appareil ...) </li><li>  Réponses futures ou http </li></ul><br><p>  <em>(Entre nous, vous pouvez réellement appliquer un changement visuel sans appeler du moteur Flutter, mais ce n'est <strong>pas recommandé</strong> )</em> </p><br><p>  Vous me demandez: "Si une sorte de code lié au <em>geste</em> est exécuté et provoque un changement visuel, ou si j'utilise une <em>minuterie</em> pour définir la fréquence de la tâche qui conduit à des changements visuels (par exemple, une animation), alors comment ça marche?" </p><br><p>  Si vous souhaitez qu'un changement visuel se produise ou qu'un code soit exécuté sur la base d'une minuterie, vous devez indiquer au <em>moteur Flutter</em> que quelque chose doit être dessiné. </p><br><p>  Habituellement, la prochaine fois que le <em>moteur Flutter est mis à</em> jour, il fait appel à <em>Flutter Framework</em> pour exécuter du code et fournit finalement une nouvelle scène pour le rendu. </p><br><p>  Par conséquent, une question importante est de savoir comment le moteur Flutter organise tous les comportements des applications en fonction du rendu. </p><br><p>  Pour avoir une idée des mécanismes internes, regardez l'animation suivante: </p><br><p><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p>  Une brève explication (plus de détails viendront plus tard): </p><br><ul><li>  Certains événements externes (geste, réponses http, etc.) ou même futurs peuvent déclencher des tâches qui nécessitent de mettre à jour l'affichage.  Le message correspondant est envoyé au <em>moteur Flutter</em> (= <em>Schedule Frame</em> ) </li><li>  Lorsque le <em>moteur Flutter est</em> prêt à commencer la mise à jour du rendu, il crée une demande <em>Begin Frame</em> </li><li>  Cette requête <em>Begin Frame</em> est interceptée par <em>Flutter Framework</em> , qui effectue des tâches principalement liées aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">tickers</a> (par exemple, l'animation) </li><li>  Ces tâches peuvent recréer la demande pour un rendu ultérieur (exemple: l'animation n'a pas terminé son exécution, et pour la terminer, elle devra obtenir une autre image de <em>début</em> à un stade ultérieur) </li><li>  Ensuite, le <em>moteur Flutter</em> envoie un <em>cadre de dessin</em> , qui est intercepté par le <em>cadre Flutter</em> , qui recherchera toutes les tâches liées à la mise à jour de la mise en page en termes de structure et de taille </li><li>  Une fois toutes ces tâches terminées, il passe aux tâches associées à la mise à jour de la mise en page en termes de rendu </li><li>  S'il y a quelque chose sur l'écran qui doit être dessiné, alors une nouvelle scène ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">scène</a> ) pour la visualisation est envoyée au <em>moteur Flutter</em> , qui mettra à jour l'écran </li><li>  <em>Flutter Framework</em> effectue <em>ensuite</em> toutes les tâches qui seront effectuées après le rendu (= rappels PostFrame), et toutes les autres tâches ultérieures qui ne sont pas liées au rendu </li><li>  ... et ce processus recommence </li></ul><br><h2 id="renderview-i-renderobject">  RenderView et RenderObject </h2><br><p>  Avant de plonger dans les détails du workflow, il est temps d'introduire le concept de l' <em>arbre de rendu</em> . </p><br><p>  Comme mentionné précédemment, tout sera finalement converti en pixels qui seront affichés à l'écran, et <em>Flutter Framework</em> convertira les <em>widgets</em> que nous utilisons pour développer l'application en blocs visuels qui seront affichés à l'écran. </p><br><p>  Ces parties visuelles correspondent à des objets appelés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RenderObject</a> , qui sont utilisés pour: </p><br><ul><li>  définir une certaine zone de l'écran en termes de taille, position, géométrie, ainsi qu'en termes de <em>"contenu rendu"</em> </li><li>  identifier les zones de l'écran qui peuvent être affectées par les gestes (= toucher du doigt) </li></ul><br><p>  Un ensemble de tous les <em>objets de rendu</em> forme un arbre appelé arbre de <em>rendu</em> .  En haut de cet arbre (= <em>racine</em> ), nous trouvons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RenderView</a> . </p><br><p>  <em>RenderView</em> fournit une surface commune pour les objets d' <em>arbre de rendu</em> et est une version spéciale de <em>RenderObject</em> . </p><br><p>  Visuellement, nous pourrions représenter tout cela comme suit: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p>  La relation entre <em>Widget</em> et <em>RenderObject</em> sera discutée plus loin.  En attendant, il est temps d'aller un peu plus loin ... </p><br><h2 id="inicializaciya-bindings">  Liaisons d'initialisation </h2><br><p> Lorsque l'application Flutter démarre, la fonction <code>main()</code> est appelée en premier, ce qui appelle finalement la <code>runApp(Widget app)</code> . </p><br><p>  Lorsque la méthode <code>runApp()</code> est <code>runApp()</code> <em>Flutter Framework</em> initialise les interfaces entre lui-même et le <em>moteur Flutter</em> .  Ces interfaces sont appelées <strong>liaisons</strong> ( <em>remarque: liaisons</em> ). </p><br><p>  <strong>Introduction aux liaisons</strong> </p><br><p>  Les liaisons sont conçues pour être le lien entre le cadre et le moteur Flutter.  Ce n'est que par le biais de liaisons que les données peuvent être échangées entre <em>Flutter Framework</em> et <em>Flutter Engine</em> . <br>  <em>(Il n'y a qu'une seule exception à cette règle -</em> RenderView <em>, mais nous en discuterons plus tard).</em> </p><br><p>  Chaque liaison est responsable du traitement d'un ensemble de tâches, actions, événements spécifiques, regroupés par domaine d'activité. </p><br><p>  Au moment d'écrire ces <em>lignes</em> , le <em>cadre Flutter</em> a 8 liaisons. </p><br><p>  Voici 4 d'entre eux qui seront considérés dans cet article: </p><br><ul><li>  <em>SchedulerBinding</em> </li><li>  <em>Reliure par geste</em> </li><li>  <em>Reliure de rendu</em> </li><li>  <em>Liaison des widgets</em> </li></ul><br><p>  Pour être complet, je mentionnerai les 4 autres: </p><br><ul><li>  <em>ServicesBinding</em> : responsable du traitement des messages envoyés par le <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">canal</a></em> de la <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">plateforme</a></em> </li><li>  <em>PaintingBinding</em> : responsable du traitement du cache d'image </li><li>  <em>SemanticsBinding</em> : réservé à l'implémentation ultérieure de tout ce qui touche à la sémantique </li><li>  <em>TestWidgetsFlutterBinding</em> : utilisé par la bibliothèque de tests de widgets </li></ul><br><p>  Vous pouvez également mentionner <em>WidgetsFlutterBinding</em> , mais ce n'est pas vraiment une liaison, mais plutôt une sorte d ' <em>"initialiseur de liaison"</em> . </p><br><p>  Le diagramme suivant montre l'interaction entre les liaisons, que je vais examiner ensuite, et le <em>moteur Flutter</em> . </p><br><p><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p>  Examinons chacune de ces liaisons «principales». </p><br><h3 id="schedulerbinding">  SchedulerBinding </h3><br><p>  Cette liaison a deux responsabilités principales: </p><br><ul><li>  Dites <em>Flutter Engine</em> : <em>"Hé! La prochaine fois que vous n'êtes pas occupé, réveillez-moi pour que je puisse travailler un peu et vous dire quoi rendre, ou si j'ai besoin que vous m'appeliez plus tard ..."</em> </li><li>  Écoutez et réagissez à ces <em>«réveils troublants»</em> (voir ci-dessous) </li></ul><br><p>  Quand <em>SchedulerBinding</em> demande un <em>réveil</em> ? </p><br><ul><li><p>  Quand <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ticker</a></em> doit <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">élaborer</a></em> <em>une</em> nouvelle <em>tick</em> </p><br><p>  Par exemple, vous avez une animation, vous la démarrez.  L'animation est recadrée à l'aide du <em>Ticker</em> , qui est appelé à intervalles réguliers (= <em>tick</em> ) pour effectuer un <em>rappel</em> .  Afin de lancer un tel <em>rappel</em> , nous devons informer le <em>moteur Flutter</em> afin qu'il nous réveille lors de la prochaine mise à jour (= <em>Begin Frame</em> ).  Cela lancera le rappel du <em>ticker</em> pour terminer sa tâche.  Si le <em>ticker</em> doit encore continuer son exécution, à la fin de sa tâche, il appellera <em>SchedulerBinding</em> pour planifier une autre trame. </p><br></li><li><p>  Quand mettre à jour l'affichage </p><br><p>  Par exemple, nous devons élaborer un événement qui entraîne un changement visuel (exemple: mise à jour de la couleur d'une partie de l'écran, défilement, ajout / suppression de quelque chose à l'écran), pour cela, nous devons prendre les mesures nécessaires pour finalement afficher l'image mise à jour sur l'écran.  Dans ce cas, lorsqu'une telle modification se produit, <em>Flutter Framework</em> appelle <em>SchedulerBinding</em> pour planifier une autre image à l'aide du <em>moteur Flutter</em> .  <em>(Plus tard, nous verrons comment cela fonctionne réellement)</em> </p><br></li></ul><br><h3 id="gesturebinding">  Reliure par geste </h3><br><p>  Cette liaison écoute l'interaction avec le moteur en termes de <em>«doigt»</em> (= <em>geste</em> ). </p><br><p>  Il est notamment chargé de recevoir les données relatives aux <em>doigts</em> et de déterminer avec quelle (s) partie (s) de l'écran les gestes fonctionnent.  Il informe ensuite en conséquence / de ces pièces. </p><br><h3 id="rendererbinding">  Reliure de rendu </h3><br><p>  Cette liaison est le lien entre le <em>moteur Flutter</em> et l' <em>arbre de rendu</em> .  Elle est responsable de: </p><br><ul><li>  écouter les événements générés par le moteur pour informer des changements appliqués par l'utilisateur via les paramètres de l'appareil qui affectent les effets visuels et / ou la sémantique </li><li>  message au moteur sur les changements qui seront appliqués à l'affichage </li></ul><br><p>  Pour fournir les modifications qui seront affichées à l'écran, <em>RendererBinding</em> est responsable de la gestion de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">PipelineOwner</a> et de l'initialisation de <strong>RenderView</strong> . </p><br><p>  <em>PipelineOwner</em> est une sorte d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">orchestre</a> qui sait ce qui doit être fait avec <em>RenderObject</em> conformément au <em>composant</em> et coordonne ces actions. </p><br><h3 id="widgetsbinding">  Liaison des widgets </h3><br><p>  Cette liaison écoute les modifications appliquées par l'utilisateur via les paramètres du périphérique qui affectent la langue (= <em>locale</em> ) et la <em>sémantique</em> . </p><br><blockquote>  <em>Petite note</em> <br><br>  <em>Je suppose qu'à un stade ultérieur du développement de</em> Flutter, <em>tous les événements liés à la</em> sémantique <em>seront transférés à</em> SemanticsBinding <em>, mais au moment de la rédaction de ce document, ce n'est pas le cas.</em> </blockquote><p>  De plus, <em>WidgetsBinding</em> est le lien entre les widgets et le <em>moteur Flutter</em> .  Elle est responsable de: </p><br><ul><li>  gestion du processus de traitement des modifications de la structure des widgets </li><li>  rendre l'appel </li></ul><br><p>  Le traitement des modifications apportées à la structure des widgets est effectué à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p>  <em>BuildOwner</em> garde la trace des widgets à reconstruire et gère les autres tâches qui s'appliquent à la structure du widget dans son ensemble. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam">  Partie 2. Des widgets aux pixels </h1><br><p>  Maintenant que nous avons appris les bases du travail interne de <em>Flutter</em> , il est temps de parler des widgets. </p><br><p>  Dans toute la documentation Flutter, vous lirez tous les <em>widgets</em> (widgets). </p><br><p>  C'est presque correct.  Mais pour être un peu plus précis, je dirais plutôt: </p><br><blockquote>  Du côté du développeur, tout ce qui concerne l'interface utilisateur en termes de mise en page et d'interaction se fait à l'aide de widgets. </blockquote><p>  Pourquoi tant de précision?  En plus du fait que <em>Widget</em> permet au développeur de déterminer une partie de l'écran en termes de taille, de contenu, de mise en page et d'interaction, <strong>MAIS</strong> il y a beaucoup plus.  Alors qu'est-ce que <em>Widget</em> vraiment? </p><br><h2 id="neizmenyaemaya-konfiguraciya">  Configuration immuable </h2><br><p>  Si vous regardez le code source de <em>Flutter</em> , vous remarquerez la définition suivante de la classe <em>Widget</em> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p>  Qu'est-ce que cela signifie? </p><br><p>  L'annotation <strong>"@immutable" est</strong> très importante et nous indique que <strong>toute variable de la classe Widget doit être FINALE</strong> , en d'autres termes: "définie et affectée <strong>UNE FOIS POUR TOUS</strong> ."  Ainsi, après avoir créé une instance, Widget ne pourra plus modifier ses variables internes. </p><br><blockquote>  <em>Étant donné que Widget est immuable, il peut être considéré comme une configuration statique.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov">  La structure hiérarchique des widgets </h2><br><p>  Lorsque vous concevez avec Flutter, vous définissez la structure de vos écrans à l'aide de widgets quelque chose comme ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p>  Cet exemple utilise 7 widgets qui forment ensemble une structure hiérarchique.  Un schéma très simplifié basé sur ce code est le suivant: </p><br><p><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p>  Comme vous pouvez le voir, le diagramme présenté ressemble à un arbre, où <em>SafeArea</em> est sa racine. </p><br><h2 id="les-za-derevyami">  Forêt derrière les arbres </h2><br><p>  Comme vous le savez déjà, un widget lui-même peut être une agrégation d'autres widgets.  Par exemple, vous pouvez modifier le code précédent comme suit: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p>  Cette option suppose que le widget <em>"MyOwnWidget"</em> lui-même affichera <em>SafeArea</em> , <em>Scaffold</em> .  Mais la chose la plus importante dans cet exemple est que </p><br><blockquote>  <em>Un widget</em> peut représenter une feuille, un nœud dans un arbre, voire l'arbre lui-même ou, pourquoi pas, une forêt d'arbres ... </blockquote><br><h2 id="ponimanie-element-v-dereve">  Comprendre l' <em>élément</em> dans un arbre </h2><br><p>  Qu'est-ce que cela a à voir avec ça? </p><br><p>  Comme nous le verrons plus loin, afin de pouvoir générer les pixels qui composent l'image affichée sur l'appareil, <em>Flutter</em> doit connaître en détail toutes les petites parties qui composent l'écran, et afin de déterminer toutes les parties, il doit connaître l' <strong>expansion de</strong> tous les widgets. </p><br><p>  Pour illustrer ce point, considérons le principe d'une poupée imbriquée: lorsqu'elle est fermée, vous ne voyez qu'une seule poupée, mais elle en contient une autre, qui en contient une autre et ainsi de suite ... </p><br><p><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p>  Lorsque <em>Flutter</em> étend tous les widgets <em>(une partie de l'écran)</em> , ce sera comme obtenir toutes les poupées <em>(une partie de l'ensemble)</em> . </p><br><p>  L'image ci-dessous montre une partie de la structure hiérarchique finale des widgets correspondant au code précédent.  En jaune, j'ai mis en évidence les widgets mentionnés dans le code plus tôt, afin que vous puissiez les définir dans l'arborescence finale. </p><br><p><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote>  <strong><em>Précision importante</em></strong> <br><br>  <em>Le langage "Widget tree" n'existe que pour faciliter la compréhension, car les programmeurs utilisent des widgets, mais il n'y a AUCUNE arborescence de widgets dans Flutter!</em> <br><br>  <em>En fait, il serait plus correct de dire "arbre des éléments"</em> </blockquote><p>  Il est temps d'introduire le concept d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">élément</a> . </p><br><blockquote>  <em><strong>Chaque</strong> widget a <strong>un</strong> élément.</em>  <em>Les éléments sont connectés les uns aux autres et forment un arbre.</em>  <em>Par conséquent, <strong>un élément</strong> est une référence à quelque chose dans l'arbre.</em> </blockquote><p>  Pour commencer, considérez un élément comme un nœud qui a un parent et éventuellement un enfant.  En les reliant par le biais d'une relation <em>parent-enfant</em> , nous obtenons une structure arborescente. </p><br><p><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p>  Comme vous pouvez le voir, l'élément pointe vers un widget, et <strong>peut</strong> également pointer vers un objet de <em>rendu</em> . </p><br><blockquote>  <em>Encore mieux ... Element pointe vers Widget qui a <strong>créé</strong> cet élément!</em> </blockquote><p>  Résumons: </p><br><ul><li>  Il n'y a pas d'arborescence de widgets, mais il y a une arborescence d'éléments </li><li>  Les éléments sont créés par des widgets. </li><li>  L'élément fait référence au widget qui l'a créé. </li><li>  Éléments liés aux relations avec les parents </li><li>  Un article peut avoir un «bébé». </li><li>  Les éléments peuvent également pointer vers un objet de <em>rendu.</em> </li></ul><br><blockquote>  <em><strong>Les éléments</strong> déterminent comment les parties des blocs affichés sont liées les unes aux autres.</em> </blockquote><p>  Afin de mieux imaginer où se situe le concept d' <em>un élément</em> , regardons la représentation visuelle suivante: </p><br><p><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p>  Comme vous pouvez le voir, l'arborescence des éléments est la relation réelle entre les widgets et les <em>objets de rendu</em> . </p><br><p>  Mais pourquoi <em>Widget</em> crée-t-il un <em>élément</em> ? </p><br><h2 id="3-kategorii-vidzhetov">  3 catégories de widgets </h2><br><p>  Dans Flutter, les widgets sont divisés en 3 catégories, je les appelle personnellement comme suit <em>(mais ce n'est que ma façon de les classer)</em> : </p><br><ul><li><p>  Proxy </p><br><p>  L'objectif principal de ces widgets est de stocker certaines informations (qui devraient être accessibles aux widgets), faisant partie de l'arborescence basée sur Proxy.  Un exemple de tels widgets est <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">InheritedWidget</a></strong> ou <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p>  Ces widgets ne participent pas directement à la formation de l'interface utilisateur, mais sont utilisés pour obtenir les informations qu'ils peuvent fournir. </p><br></li><li><p>  Renderer </p><br><p>  Ces widgets sont directement liés à la disposition de l'écran, car ils déterminent (ou sont utilisés pour déterminer) la <em>taille</em> , la <em>position</em> , le <em>rendu</em> .  Des exemples typiques sont: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Row</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Column</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Stack</a></strong> , ainsi que <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Padding</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Align</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Opacity</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li><p>  Composant </p><br><p>  Ce sont d'autres widgets qui fournissent directement non pas les informations finales liées aux tailles, positions, apparences, mais plutôt les données (ou astuces) qui seront utilisées pour obtenir les informations très finales.  Ces widgets sont communément appelés composants. </p><br><p>  Exemples: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">RaisedButton</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Scaffold</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Text</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GestureDetector</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Container</a></strong> ... </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ce fichier PDF</a> répertorie la plupart des widgets regroupés par catégorie. </p><br><p>  Pourquoi cette séparation est-elle importante?  Parce que selon la catégorie du widget, le type d'élément correspondant est associé à ... </p><br><h2 id="tipy-elementov">  Types d'articles </h2><br><p>  Il existe plusieurs types d'éléments: </p><br><p><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p>  Comme vous pouvez le voir dans l'image ci-dessus, les éléments sont divisés en 2 types principaux: </p><br><ul><li><p>  Componententlement </p><br><p>  Ces éléments ne <strong>sont</strong> pas <strong>directement</strong> responsables du rendu d'une partie de l'affichage. </p><br></li><li><p>  RenderObjectElement </p><br><p>  Ces éléments sont responsables de parties de l'image affichée à l'écran. </p><br></li></ul><br><p>  Super!  Tant d'informations, mais comment tout cela est-il lié les uns aux autres et pourquoi est-il intéressant d'en parler? </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste">  Comment les widgets et les éléments fonctionnent ensemble </h2><br><blockquote>  <em>Dans Flutter, toutes les mécaniques sont basées sur l'invalidation d'un élément ou d'un renderObject.</em> </blockquote><p>  L'invalidation d'élément peut être effectuée des manières suivantes: </p><br><ul><li>  en utilisant <code>setState</code> , qui invalide l'intégralité de <strong>StatefulElement</strong> (notez que je ne dis pas intentionnellement <em>StatefulWidget</em> ) </li><li>  via des notifications traitées par <strong>proxyElement</strong> (par exemple, InheritedWidget), qui invalide tout <em>élément</em> qui dépend de ce <em>proxyElement</em> </li></ul><br><p>  Le résultat de l' <em>invalidation</em> est qu'un lien vers l' <em>élément</em> correspondant apparaît dans la liste des éléments <strong>sales</strong> . </p><br><p>  L' <em>invalidation de renderObject</em> signifie que la structure des éléments ne change pas du tout, mais il y a un changement au niveau de <em>renderObject</em> , par exemple: </p><br><ul><li>  changer sa taille, sa position, sa géométrie ... </li><li>  quelque chose doit être repeint, par exemple, lorsque vous changez simplement la couleur d'arrière-plan, le style de police ... </li></ul><br><p>  Le résultat d'une telle <em>invalidation</em> est un lien vers le <em>renderObject</em> correspondant dans la liste des objets de rendu <em>(renderObjects)</em> qui doivent être reconstruits ou repeints. </p><br><p>  Quel que soit le type d'invalidation, <strong>SchedulerBinding</strong> est appelé (vous vous en souvenez?) Pour demander au <strong>moteur Flutter</strong> de planifier une nouvelle trame. </p><br><p>  C'est exactement le moment où le <em>moteur Flutter</em> "réveille" le <em>SchedulerBinding</em> et toute la magie opère ... </p><br><h2 id="ondrawframe">  onDrawFrame () </h2><br><p>  Plus tôt dans cet article, nous avons noté que <em>SchedulerBinding a</em> deux responsabilités principales, dont l'une est sa disponibilité à gérer les demandes faites par <em>Flutter Engine</em> liées à la reconstruction de trames.  C'est le moment idéal pour se concentrer sur cela. </p><br><p>  Le diagramme de séquence partielle ci-dessous montre ce qui se passe lorsque <em>SchedulerBinding</em> reçoit une demande <em>onDrawFrame ()</em> du <em>moteur Flutter</em> . </p><br><p><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p>  <strong>Étape 1. Éléments</strong> </p><br><p>  <em>WidgetsBinding</em> est <em>appelé</em> et cette liaison prend d'abord en compte les modifications associées aux éléments.  <em>WidgetsBinding</em> appelle la méthode <em>buildScope</em> de l'objet <em>buildOwner</em> , car <strong>BuildOwner</strong> est responsable du traitement de l'arborescence d'éléments.  Cette méthode parcourt la liste des éléments <em>sales</em> et demande leur <strong>reconstruction</strong> . </p><br><p>  Les principaux principes de cette méthode de <code>rebuild()</code> ) sont: </p><br><ol><li>  Il y a une demande pour reconstruire l'élément (cela prendra la plupart du temps), appelant la méthode <code>build()</code> du widget auquel cet élément fait référence (= <code>Widget build (BuildContext context) {...}</code> méthode).  Cette méthode <code>build()</code> retournera un nouveau widget </li><li>  Si l'élément n'a pas «d'enfant», alors un élément est créé pour le nouveau widget (voir ci-dessous) ( <em>note: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">inflateWidget</a></em> ), sinon </li><li>  le nouveau widget est comparé à celui référencé par l'enfant de l'élément <br><ul><li>  S'ils sont interchangeables (= <em>le même type de widget et la même clé</em> ), la mise à jour se produit et l'enfant est enregistré. </li><li>  S'ils ne sont pas interchangeables, l'enfant est supprimé ( <em>~ supprimé</em> ) et un élément est créé pour le nouveau widget </li></ul></li><li>  Ce nouvel élément est monté en tant qu'enfant de l'élément.  ( <em>monté)</em> = inséré dans l'arborescence des éléments) </li></ol><br><p>  L'animation suivante va essayer de rendre cette explication un peu plus claire. </p><br><p><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p>  <strong>Remarque sur les widgets et les éléments</strong> </p><br><p>  Pour un nouveau widget, un élément d'un <em>type spécifique</em> est créé qui correspond à <em>la catégorie du</em> widget, à savoir: </p><br><ul><li>  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li>  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li>  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li>  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li>  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li>  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li>  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li>  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li>  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p>  Chacun de ces types d'éléments a son propre comportement.  Par exemple: </p><br><ul><li>  <em>StatefulElement</em> appellera la méthode <code>widget.createState()</code> à l'initialisation, qui créera un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">état</a> et l'associera à l'élément </li><li>  Lorsqu'un élément de type <em>RenderObjectElement est</em> monté, il crée un <em>RenderObject</em> .  Ce <em>renderObject</em> sera ajouté à l' <em>arbre de rendu</em> et associé à l'élément. </li></ul><br><p>  <strong>Étape 2. renderObjects</strong> </p><br><p>  Maintenant, après avoir terminé toutes les actions associées aux éléments <em>sales</em> , l' <em>arbre des éléments</em> est stable.  Il est donc temps de considérer le processus de visualisation. </p><br><p>  Étant donné que <em>RendererBinding</em> est responsable du rendu de l' <em>arbre de rendu</em> , <em>WidgetsBinding</em> appelle la méthode <code>drawFrame</code> <em>RendererBinding</em> . </p><br><p>  Le diagramme partiel ci-dessous montre la séquence d'actions effectuées lors de la demande <em>drawFrame ()</em> . </p><br><p><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p>  À cette étape, les actions suivantes sont effectuées: </p><br><ul><li>  Chaque <em>renderObject</em> marqué comme <em>sale</em> est demandé de le composer (c'est-à-dire de calculer sa taille et sa géométrie) </li><li>  Chaque <em>renderObject</em> marqué comme "ayant besoin d'être redessiné" est redessiné en utilisant sa propre méthode de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">calque</a> </li><li>  La scène résultante est formée et envoyée au <em>moteur Flutter</em> , afin que ce dernier la transfère à l'écran de l'appareil </li><li>  Enfin, la sémantique est également mise à jour et envoyée au <em>moteur Flutter</em> </li></ul><br><p>  À la fin de ce flux de travail, l'écran de l'appareil est actualisé. </p><br><h1 id="chast-3-obrabotka-zhestov">  Partie 3: Gérer les gestes </h1><br><p>  Les gestes (= <em>événements liés aux actions des doigts sur la vitre</em> ) sont traités à l'aide de <em>GestureBinding</em> . </p><br><p>  Lorsque le <em>moteur Flutter</em> envoie des informations sur un événement de mouvement via l'API <em>window.onPointerDataPacket</em> , <strong>GestureBinding l'</strong> intercepte, effectue une mise en mémoire tampon et: </p><br><ol><li>  convertit les coordonnées fournies par le <em>moteur Flutter</em> pour correspondre au <strong>rapport de pixels de</strong> l' <strong>appareil</strong> , puis </li><li>  récupère de <em>renderView une</em> liste de tous les <em>RenderObjects</em> qui se trouvent dans la partie de l'écran liée aux coordonnées de l'événement </li><li>  puis parcourt la liste résultante de <em>renderObjects</em> et envoie un événement associé à chacun d'eux </li><li>  si <em>renderObject</em> "écoute" les événements de ce type, il le traite </li></ol><br><p>  J'espère maintenant que je comprends l'importance des <em>renderObjects</em> . </p><br><h1 id="chast-4-animacii">  Partie 4: Animations </h1><br><p>  Cette partie de l'article traite du concept d' <strong>animation</strong> et d'une compréhension approfondie de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ticker</a></strong> . </p><br><p>  Lorsque vous travaillez avec des animations, vous utilisez généralement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">AnimationController</a> ou n'importe quel widget pour les animations ( <em>remarque: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p>  Dans <em>Flutter,</em> tout ce qui concerne les animations fait référence à <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ticker</a></em> .  <em>Ticker</em> , lorsqu'il est actif, n'a qu'une seule tâche: "il demande à <em>SchedulerBinding d'</em> enregistrer un rappel et de dire au <em>moteur Flutter</em> de le réveiller lorsqu'un nouveau rappel apparaît."  Lorsque le <em>moteur Flutter est</em> prêt, il appelle <em>SchedulerBinding</em> via une requête: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> accède à la liste de rappel du <em>ticker</em> et exécute chacune. </p><br><p>  Chaque <em>tick est</em> intercepté par un contrôleur "intéressé" pour le traiter.  Si l'animation est terminée, le <em>ticker est</em> «désactivé», sinon le <em>ticker</em> demande un <em>SchedulerBinding</em> pour planifier un nouveau rappel.  Et ainsi de suite ... </p><br><h1 id="polnaya-kartina">  Image complète </h1><br><p>  Nous avons maintenant appris comment fonctionne <em>Flutter</em> : </p><br><p><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext">  Buildcontext </h1><br><p>  Enfin, revenons au diagramme qui montre les différents types d'éléments, et considérons la signature de l' <em>élément</em> racine: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  Nous voyons le très célèbre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">BuildContext</a> !  Mais c'est quoi? </p><br><p>  <strong>BuildContext</strong> est une interface qui définit un certain nombre de getters et de méthodes qui peuvent être implémentées par un élément.  La plupart du temps, <em>BuildContext est</em> utilisé dans la méthode <code>build()</code> de <em>StatelessWidget</em> ou <em>State</em> pour <em>StatefulWidget</em> . </p><br><blockquote>  <em><strong>BuildContext</strong> n'est rien d'autre que l' <strong>élément</strong> lui-même, qui correspond à</em> <br><ul><li>  <em>widget en cours de mise à jour (à l'intérieur des méthodes de <code>build</code> ou de <code>build</code> )</em> </li><li>  <em>StatefulWidget associé à <strong>State</strong> dans lequel vous référencez la variable de contexte.</em> </li></ul><br></blockquote><p>  Cela signifie que la plupart des développeurs travaillent constamment avec des éléments sans même le savoir. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext">  Quelle est l'utilité d'un BuildContext? </h2><br><p>  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul><li>     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li>   <em>RenderObject</em> </li><li>   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> …) </li></ul><br><h2 id="zabavy-radi">   </h2><br><p> ,   ,  <em>BuildContext</em> –  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote> <strong></strong> <br> <strong>,    !</strong> <br><br>    – ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p>     .       . </p><br><p> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476018/">https://habr.com/ru/post/fr476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476000/index.html">Mises à jour du générateur de modèles ML.NET</a></li>
<li><a href="../fr476002/index.html">Expérience dans la recherche d'un poste de doctorant en Allemagne</a></li>
<li><a href="../fr476004/index.html">Chef de projet - mythe ou réalité? Ou pourquoi est-il nécessaire dans le domaine des effets visuels?</a></li>
<li><a href="../fr476006/index.html">Mythes et légendes des constructeurs de SOC, ou 3 idées fausses sur les centres de surveillance et de réponse aux cyberattaques</a></li>
<li><a href="../fr476008/index.html">Meetup MOSDROID: Connectez-vous à la diffusion</a></li>
<li><a href="../fr476022/index.html">Vue Storefront: Relever le backend</a></li>
<li><a href="../fr476024/index.html">Meilleure architecture pour MVP: monolith, SOA, microservices ou sans serveur? .. Partie 1</a></li>
<li><a href="../fr476026/index.html">Cool Life Hacks pour travailler avec WSL (sous-système Windows pour Linux)</a></li>
<li><a href="../fr476032/index.html">Brunner Elektronik - Du système de CAO au cockpit</a></li>
<li><a href="../fr476034/index.html">Le plus sans défense est le Faucon pèlerin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>