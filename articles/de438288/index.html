<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòπ ü§© ü¶é Furchtloser Schutz. Speichersicherheit in Rust üëèüèª ü¶Ç üë©üèø‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mozilla hat im vergangenen Jahr Quantum CSS f√ºr Firefox ver√∂ffentlicht und damit acht Jahre lang Rust entwickelt, eine speicherfreundliche Systemprogr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Furchtloser Schutz. Speichersicherheit in Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438288/"> Mozilla hat im vergangenen Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quantum CSS</a> f√ºr Firefox ver√∂ffentlicht und damit acht Jahre lang Rust entwickelt, eine speicherfreundliche Systemprogrammiersprache.  Es dauerte mehr als ein Jahr, um die Hauptbrowserkomponente in Rust neu zu schreiben. <br><br>  Bisher sind alle wichtigen Browser-Engines haupts√§chlich aus Effizienzgr√ºnden in C ++ geschrieben.  Mit einer hohen Leistung geht jedoch eine gro√üe Verantwortung einher: C ++ - Programmierer m√ºssen den Speicher manuell verwalten, wodurch die Schwachstellenbox der Pandora ge√∂ffnet wird.  Rust behebt nicht nur solche Fehler, sondern verhindert mit seinen Methoden auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenrennen</a> , sodass Programmierer parallelen Code effizienter implementieren k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/3c1/378/8bb3c13783ff1502b161e92f5818c2aa.jpg"></div><a name="habracut"></a><br><h1>  Was ist Speichersicherheit? </h1><br>  Wenn wir √ºber das Erstellen sicherer Anwendungen sprechen, erw√§hnen wir h√§ufig die Speichersicherheit.  Inoffiziell meinen wir, dass das Programm in keinem Zustand auf ung√ºltigen Speicher zugreifen kann.  Ursachen f√ºr Sicherheitsverletzungen: <br><br><ul><li>  Speichern des Zeigers nach dem Freigeben des Speichers (Use-After-Free); <br></li><li>  Dereferenzieren eines Nullzeigers; <br></li><li>  Verwendung von nicht initialisiertem Speicher; <br></li><li>  Programmversuch, dieselbe Zelle zweimal freizugeben (doppelt frei); <br></li><li>  Puffer√ºberlauf. </li></ul><br>  Eine formellere Definition finden Sie in Michael Hicks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">'What is Memory Security'</a> sowie in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wissenschaftlichen Artikel</a> zu diesem Thema. <br><br>  Solche Verst√∂√üe k√∂nnen zu einem unerwarteten Absturz oder einer √Ñnderung des erwarteten Verhaltens des Programms f√ºhren.  M√∂gliche Folgen: Informationsverlust, Ausf√ºhrung von willk√ºrlichem Code und Ausf√ºhrung von Remotecode. <br><br><h1>  Speicherverwaltung </h1><br>  Die Speicherverwaltung ist f√ºr die Anwendungsleistung und -sicherheit von entscheidender Bedeutung.  In diesem Abschnitt betrachten wir das grundlegende Speichermodell.  Eines der Schl√ºsselkonzepte sind <i>Zeiger</i> .  Dies sind Variablen, in denen Speicheradressen gespeichert sind.  Wenn wir zu dieser Adresse gehen, werden wir dort einige Daten sehen.  Daher sagen wir, dass der Zeiger eine Referenz auf diese Daten ist (oder auf diese zeigt).  So wie die Privatadresse den Leuten sagt, wo Sie zu finden sind, zeigt die Speicheradresse dem Programm, wo die Daten zu finden sind. <br><br>  Alles im Programm befindet sich an bestimmten Speicheradressen, einschlie√ülich Code-Anweisungen.  Die falsche Verwendung von Zeigern kann zu schwerwiegenden Sicherheitsl√ºcken f√ºhren, einschlie√ülich Informationsverlust und willk√ºrlicher Codeausf√ºhrung. <br><br><h3>  Zuordnung / Freigabe </h3><br>  Wenn wir eine Variable erstellen, sollte das Programm gen√ºgend Speicherplatz im Speicher zuweisen, um die Daten dieser Variablen zu speichern.  Da jeder Prozess nur √ºber eine begrenzte Menge an Speicher verf√ºgt, ben√∂tigen Sie nat√ºrlich eine M√∂glichkeit, Ressourcen freizugeben.  Wenn der Speicher freigegeben wird, wird er zum Speichern neuer Daten verf√ºgbar, aber die alten Daten bleiben dort, bis die Zelle √ºberschrieben wird. <br><br><h3>  Puffer </h3><br>  <i>Ein Puffer</i> ist ein zusammenh√§ngender Speicherbereich, in dem mehrere Instanzen desselben Datentyps gespeichert sind.  Beispielsweise wird der Ausdruck "Meine Katze ist Batman" in einem 16-Byte-Puffer gespeichert.  Puffer werden durch die Startadresse und L√§nge bestimmt.  Um die Daten im benachbarten Speicher nicht zu besch√§digen, ist darauf zu achten, dass wir nicht au√üerhalb des Puffers lesen oder schreiben. <br><br><h3>  Kontrollfluss </h3><br>  Programme bestehen aus Routinen, die in einer bestimmten Reihenfolge ausgef√ºhrt werden.  Am Ende des Unterprogramms geht der Computer zum gespeicherten Zeiger auf den n√§chsten Teil des Codes (als <i>R√ºcksprungadresse bezeichnet</i> ).  Wenn Sie zur Absenderadresse gehen, geschieht eines von drei Dingen: <br><br><ol><li>  Der Vorgang wird normal fortgesetzt (Absenderadresse wird nicht ge√§ndert). <br></li><li>  Der Prozess st√ºrzt ab (die Adresse wurde ge√§ndert und zeigt auf nicht ausf√ºhrbaren Speicher). <br></li><li>  Der Prozess wird fortgesetzt, jedoch nicht wie erwartet (die R√ºcksprungadresse hat sich ge√§ndert und der Kontrollfluss hat sich ge√§ndert). </li></ol><br><h1>  Wie Sprachen Speichersicherheit bieten </h1><br>  Alle Programmiersprachen geh√∂ren zu verschiedenen Teilen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spektrums</a> .  Auf der einen Seite des Spektrums stehen Sprachen wie C / C ++.  Sie sind effektiv, erfordern jedoch eine manuelle Speicherverwaltung.  Interpretierte Sprachen hingegen mit automatischer Speicherverwaltung (z. B. Referenzz√§hlung und Garbage Collection (GC)) zahlen sich jedoch mit der Leistung aus.  Selbst Sprachen mit einer gut optimierten Speicherbereinigung k√∂nnen nicht mit Sprachen ohne GC verglichen werden. <br><br><h3>  Manuelle Speicherverwaltung </h3><br>  In einigen Sprachen (z. B. C) m√ºssen Programmierer den Speicher manuell verwalten: Wann und wie viel Speicher muss zugewiesen werden, wann muss er freigegeben werden?  Dies gibt dem Programmierer die vollst√§ndige Kontrolle dar√ºber, wie das Programm Ressourcen verwendet, und bietet schnellen und effizienten Code.  Dieser Ansatz ist jedoch fehleranf√§llig, insbesondere bei komplexen Codebasen. <br><br>  Fehler, die leicht zu machen sind: <br><br><ul><li>  Vergessen Sie, dass die Ressourcen kostenlos sind, und versuchen Sie, sie zu verwenden. <br></li><li>  Weisen Sie nicht gen√ºgend Speicherplatz f√ºr die Datenspeicherung zu. <br></li><li>  Speicher au√üerhalb des Puffers lesen. </li></ul><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/657/0a0/242/6570a02427a2d03632cb41c73aa5a48d.jpg"></a> </div><br>  <i><font color="gray">Geeignete Sicherheitshinweise f√ºr diejenigen, die den Speicher manuell verwalten</font></i> <br><br><h3>  Intelligente Zeiger </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intelligente Zeiger</a> bieten zus√§tzliche Informationen, um eine fehlerhafte Speicherverwaltung zu verhindern.  Sie werden zur automatischen Speicherverwaltung und Grenz√ºberpr√ºfung verwendet.  Im Gegensatz zu einem normalen Zeiger kann sich ein intelligenter Zeiger selbst zerst√∂ren und wartet nicht darauf, dass der Programmierer ihn manuell l√∂scht. <br><br>  F√ºr eine solche Konstruktion gibt es verschiedene Optionen, bei denen der urspr√ºngliche Zeiger in mehrere n√ºtzliche Abstraktionen eingeschlossen wird.  Einige intelligente Zeiger <i>z√§hlen Verweise</i> auf jedes Objekt, w√§hrend andere eine G√ºltigkeitsbereichsrichtlinie implementieren, um die Lebensdauer des Zeigers auf bestimmte Bedingungen zu beschr√§nken. <br><br>  Beim Z√§hlen von Links werden Ressourcen freigegeben, wenn der letzte Verweis auf das Objekt gel√∂scht wird.  Grundlegende Implementierungen f√ºr die Referenzz√§hlung leiden unter schlechter Leistung, erh√∂htem Speicherverbrauch und sind in Multithread-Umgebungen schwierig zu verwenden.  Wenn sich die Objekte aufeinander beziehen (kreisf√∂rmige Links), erreicht der Referenzz√§hler f√ºr jedes Objekt niemals Null, sodass komplexere Methoden erforderlich sind. <br><br><h1>  M√ºllabfuhr </h1><br>  Einige Sprachen (z. B. Java, Go, Python) implementieren die <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereinigung</a></i> .  Ein Teil der Laufzeitumgebung, der als Garbage Collector (GC) bezeichnet wird, verfolgt Variablen und identifiziert unzug√§ngliche Ressourcen im Verkn√ºpfungsdiagramm zwischen Objekten.  Sobald das Objekt nicht mehr verf√ºgbar ist, gibt der GC den Basisspeicher f√ºr die zuk√ºnftige Wiederverwendung frei.  Die Zuweisung und Freigabe von Speicher erfolgt ohne expliziten Programmierbefehl. <br><br>  Obwohl der GC sicherstellt, dass der Speicher immer korrekt verwendet wird, gibt er den Speicher nicht auf die effizienteste Weise frei - manchmal erfolgt die letzte Verwendung eines Objekts viel fr√ºher, als der Garbage Collector Speicher freigibt.  Leistungskosten sind f√ºr gesch√§ftskritische Anwendungen unerschwinglich: Manchmal m√ºssen Sie f√ºnfmal mehr Speicher verwenden, um Leistungseinbu√üen zu vermeiden. <br><br><h3>  Besitz </h3><br>  Rust nutzt das Eigentum, um hohe Leistung und Speichersicherheit zu gew√§hrleisten.  Formal ist dies ein Beispiel f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Affinit√§tstypisierung</a> .  Der gesamte Rust-Code folgt bestimmten Regeln, nach denen der Compiler den Speicher verwalten kann, ohne die Ausf√ºhrungszeit zu verlieren: <br><br><ol><li>  Jeder Wert hat eine Variable namens Eigent√ºmer. <br></li><li>  Es kann immer nur ein Eigent√ºmer gleichzeitig sein. <br></li><li>  Wenn der Eigent√ºmer den G√ºltigkeitsbereich verl√§sst, wird der Wert gel√∂scht. </li></ol><br>  Werte k√∂nnen von einer Variablen in eine andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbertragen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgeliehen werden</a> .  Diese Regeln gelten f√ºr einen Teil des Compilers namens Borrow Checker. <br><br>  Wenn eine Variable den G√ºltigkeitsbereich verl√§sst, gibt Rust diesen Speicher frei.  Im folgenden Beispiel gehen die Variablen <code>s1</code> und <code>s2</code> √ºber den G√ºltigkeitsbereich hinaus. Beide versuchen, denselben Speicher freizugeben, was zu einem doppelten Fehler f√ºhrt.  Um dies zu verhindern, wird der Vorbesitzer beim √úbertragen eines Werts von einer Variablen ung√ºltig.  Wenn der Programmierer dann versucht, eine ung√ºltige Variable zu verwenden, lehnt der Compiler den Code ab.  Dies kann vermieden werden, indem eine tiefe Kopie der Daten erstellt oder Links verwendet werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel 1</a> : Eigentums√ºbertragung <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s2 = s1; <span class="hljs-comment"><span class="hljs-comment">//won't compile because s1 is now invalid println!("{}, world!", s1);</span></span></code> </pre> <br>  Ein weiterer Satz von Regeln f√ºr die Kreditpr√ºfung bezieht sich auf die Lebensdauer von Variablen.  Rust verbietet die Verwendung nicht initialisierter Variablen und baumelnder Zeiger auf nicht vorhandene Objekte.  Wenn Sie den Code aus dem folgenden Beispiel kompilieren, bezieht sich <code>r</code> auf einen Speicher, der freigegeben wird, wenn <code>x</code> G√ºltigkeitsbereich verl√§sst: Ein baumelnder Zeiger tritt auf.  Der Compiler √ºberwacht alle Bereiche und √ºberpr√ºft die G√ºltigkeit aller √úbertragungen. Manchmal muss der Programmierer die Lebensdauer der Variablen explizit angeben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel 2</a> : H√§ngender Zeiger <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; r = &amp;x; } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"r: {}"</span></span>, r);</code> </pre> <br>  Das Eigentumsmodell bietet eine solide Grundlage f√ºr den korrekten Zugriff auf den Speicher und verhindert undefiniertes Verhalten. <br><br><h1>  Speicherschwachstellen </h1><br>  Die Hauptfolgen des anf√§lligen Ged√§chtnisses: <br><br><ol><li>  <b>Absturz</b> : Der Zugriff auf ung√ºltigen Speicher kann zu einer unerwarteten Beendigung der Anwendung f√ºhren. <br></li><li>  <b>Informationsverlust</b> : unbeabsichtigte Bereitstellung privater Daten, einschlie√ülich vertraulicher Informationen wie Kennw√∂rter. <br></li><li>  <b>Arbitrary Code Execution (ACE)</b> : Erm√∂glicht einem Angreifer, beliebige Befehle auf dem Zielcomputer auszuf√ºhren.  Wenn dies √ºber das Netzwerk geschieht, nennen wir es Remote Code Execution (RCE). </li></ol><br>  Ein weiteres Problem ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Speicherverlust,</a> wenn der zugewiesene Speicher nach Beendigung des Programms nicht freigegeben wird.  Sie k√∂nnen also den gesamten verf√ºgbaren Speicher belegen: Anschlie√üend werden Ressourcenanforderungen blockiert, was zu einem Denial-of-Service f√ºhrt.  Dies ist ein Speicherproblem, das auf PL-Ebene nicht gel√∂st werden kann. <br><br>  Im besten Fall st√ºrzt die Anwendung bei einem Speicherfehler ab.  Im schlimmsten Fall erlangt ein Angreifer durch eine Sicherheitsanf√§lligkeit die Kontrolle √ºber ein Programm (was zu weiteren Angriffen f√ºhren kann). <br><br><h3>  Missbrauch von freigegebenem Speicher (Use-After-Free, Double Free) </h3><br>  Diese Unterklasse von Sicherheitsanf√§lligkeiten tritt auf, wenn eine Ressource freigegeben wird, ein Link zu ihrer Adresse jedoch weiterhin erhalten bleibt.  Dies ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leistungsstarke Hacker-Methode</a> , die zu Zugriff au√üerhalb des Bereichs, Informationsverlust, Codeausf√ºhrung und vielem mehr f√ºhren kann. <br><br>  Sprachen mit Garbage Collection und Referenzz√§hlung verhindern die Verwendung ung√ºltiger Zeiger, wodurch nur unzug√§ngliche Objekte zerst√∂rt werden (was zu Leistungseinbu√üen f√ºhren kann), und manuell gesteuerte Sprachen sind von dieser Sicherheitsanf√§lligkeit betroffen (insbesondere in komplexen Codebasen).  Mit dem Tool zum Ausleihen von Pr√ºfern in Rust k√∂nnen Objekte nicht zerst√∂rt werden, w√§hrend auf sie verwiesen wird. Daher werden diese Fehler beim Kompilieren entfernt. <br><br><h3>  Nicht initialisierte Variablen </h3><br>  Wenn die Variable vor der Initialisierung verwendet wird, k√∂nnen diese Daten beliebige Daten enthalten, einschlie√ülich zuf√§lligen M√ºlls oder zuvor verworfener Daten, was zu Informationslecks f√ºhrt (sie werden manchmal als <i>ung√ºltige Zeiger bezeichnet</i> ).  Um diese Probleme zu vermeiden, verwenden Speicherverwaltungssprachen h√§ufig das automatische Initialisierungsverfahren nach dem Zuweisen von Speicher. <br><br>  Wie in C werden die meisten Variablen in Rust zun√§chst nicht initialisiert.  Im Gegensatz zu C k√∂nnen Sie sie jedoch nicht vor der Initialisierung lesen.  Der folgende Code wird nicht kompiliert: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel 3</a> : Verwenden einer nicht initialisierten Variablen <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); }</code> </pre> <br><h3>  Nullzeiger </h3><br>  Wenn eine Anwendung einen Zeiger dereferenziert, der sich als null herausstellt, greift sie normalerweise nur auf den M√ºll zu und verursacht einen Absturz.  In einigen F√§llen k√∂nnen diese Sicherheitsanf√§lligkeiten zur Ausf√ºhrung von beliebigem Code f√ºhren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ).  Rust hat zwei Arten von Zeigern: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Links</a> und Rohzeiger.  Links sind sicher, aber rohe Zeiger k√∂nnen ein Problem sein. <br><br>  Rust verhindert die Dereferenzierung eines Nullzeigers auf zwei Arten: <br><br><ol><li>  Vermeiden Sie nullbare Zeiger. <br></li><li>  Vermeiden Sie die Dereferenzierung von Rohzeigern. </li></ol><br>  Rust vermeidet Nullzeiger, indem es sie durch den speziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> Option</code></a> .  Um den m√∂glichen Nullwert im <code>Option</code> zu √§ndern, muss der Programmierer den Fall explizit mit einem Nullwert behandeln, da das Programm sonst nicht kompiliert wird. <br><br>  Was tun, wenn Zeiger, die einen Nullwert zulassen, nicht vermieden werden k√∂nnen (z. B. bei der Interaktion mit Code in einer anderen Sprache)?  Versuchen Sie, den Schaden zu isolieren.  Die Dereferenzierung von Rohzeigern muss in einem isolierten unsicheren Block erfolgen.  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">l√∂st die Rust-Regeln</a> und l√∂st einige Vorg√§nge auf, die undefiniertes Verhalten verursachen k√∂nnen (z. B. Dereferenzieren eines Rohzeigers). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e58/bd7/b69/e58bd7b69e8f2f399e431bdb4f6d151f.jpg"></div><br>  <i><font color="gray">"Alles √ºber den Leihscheck ... was ist mit diesem dunklen Ort?"</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray">- Dies ist ein unsicherer Block.</font></i>  <i><font color="gray">Geh niemals dorthin, Simba</font></i> <br><br><h3>  Puffer√ºberlauf </h3><br>  Wir haben Schwachstellen besprochen, die vermieden werden k√∂nnen, indem der Zugriff auf undefinierten Speicher eingeschr√§nkt wird.  Das Problem ist jedoch, dass der Puffer√ºberlauf nicht korrekt auf undefinierten, sondern legal zugewiesenen Speicher zugreift.  Wie der Use-After-Free-Fehler kann ein solcher Zugriff ein Problem sein, da er auf den freigegebenen Speicher zugreift, der noch vertrauliche Informationen enth√§lt, die nicht mehr vorhanden sein sollten. <br><br>  Puffer√ºberl√§ufe bedeuten einfach Zugriff au√üerhalb der Grenzen.  Aufgrund der Art und Weise, wie Puffer im Speicher gespeichert werden, verlieren sie h√§ufig Informationen, die vertrauliche Daten enthalten k√∂nnen, einschlie√ülich Kennw√∂rter.  In schwerwiegenderen F√§llen sind ACE / RCE-Schwachstellen durch √úberschreiben des Anweisungszeigers m√∂glich. <br><br>  Beispiel 4: Puffer√ºberlauf (C-Code) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// print out of bounds printf("Out of bounds: %d\n", buf[10]); // write out of bounds buf[10] = 10; printf("Out of bounds: %d\n", buf[10]); return 0; }</span></span></code> </pre> <br>  Der einfachste Schutz gegen Puffer√ºberl√§ufe besteht darin, beim Zugriff auf Elemente immer Grenzpr√ºfungen zu erfordern. Dies f√ºhrt jedoch zu einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schlechten Leistung</a> . <br><br>  Was macht Rost?  Die in der Standardbibliothek integrierten Puffertypen erfordern Grenzpr√ºfungen f√ºr jeden wahlfreien Zugriff, bieten jedoch auch Iterator-APIs, um sequentielle Aufrufe zu beschleunigen.  Dies stellt sicher, dass das Lesen und Schreiben au√üerhalb der Grenzen f√ºr diese Typen nicht m√∂glich ist.  Rust f√∂rdert Muster, die Randpr√ºfungen nur an Stellen erfordern, an denen Sie sie mit ziemlicher Sicherheit manuell in C / C ++ platzieren m√ºssen. <br><br><h1>  Speichersicherheit ist nur die halbe Miete </h1><br>  Sicherheitsverletzungen f√ºhren zu Sicherheitsl√ºcken wie Datenverlust und Remotecodeausf√ºhrung.  Es gibt verschiedene M√∂glichkeiten, den Speicher zu sch√ºtzen, einschlie√ülich intelligenter Zeiger und Speicherbereinigung.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Speichersicherheit</a> sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">formal nachweisen</a> .  W√§hrend einige Sprachen aus Gr√ºnden der Speichersicherheit mit Leistungseinbu√üen fertig geworden sind, bietet das Besitzkonzept von Rust Sicherheit und minimiert den Overhead. <br><br>  Leider sind Speicherfehler nur ein Teil der Geschichte, wenn wir √ºber das Schreiben von sicherem Code sprechen.  Im n√§chsten Artikel werden wir uns mit Thread-Sicherheit und Angriffen auf parallelen Code befassen. <br><br><h1>  Ausnutzen von Sicherheitsl√ºcken im Speicher: Zus√§tzliche Ressourcen </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haufen Speicher und Ausbeutung</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zerst√∂rung eines Stapels aus der Position eines Hackers</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analogien zur Informationssicherheit</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in Use-After-Free-Schwachstellen</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438288/">https://habr.com/ru/post/de438288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438272/index.html">Wie wir SMS aus der H√∂hle geschickt haben</a></li>
<li><a href="../de438274/index.html">Definition von ‚Äûtoxischer Pers√∂nlichkeit‚Äú in der IT</a></li>
<li><a href="../de438278/index.html">Kindern das Programmieren beibringen</a></li>
<li><a href="../de438280/index.html">Objekte in Django "l√∂schen"</a></li>
<li><a href="../de438286/index.html">Arbeiten mit Zeitzonen in JavaScript</a></li>
<li><a href="../de438290/index.html">Post-mortem mit GGJ-2019: wie man Unebenheiten bekommt, aber trotzdem das Spiel macht</a></li>
<li><a href="../de438292/index.html">Apartment Automation mit HomePod, Raspberry Pi und Node.js.</a></li>
<li><a href="../de438294/index.html">Zuckende Streamer in einem PUBG-Match finden</a></li>
<li><a href="../de438296/index.html">OpenSceneGraph: Plugin-System</a></li>
<li><a href="../de438298/index.html">Warum unterrichten, wenn das Entwickeln rentabler ist? Gespr√§ch mit GeekBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>