<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¿ âš°ï¸ ğŸ· Sejarah satu permintaan ğŸ‘¨ğŸ»â€ğŸ³ â„¢ï¸ ğŸ’–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bayangkan hari pertama Anda di pekerjaan baru. Kantor ini terletak di area stasiun metro Kurskaya yang sama sekali tidak dikenal. Makan siang mendekat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sejarah satu permintaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/433696/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9q/ks/jt/9qksjtj-bhuaxl7okhilaidgqsa.png" alt="gambar"></div><br>  Bayangkan hari pertama Anda di pekerjaan baru.  Kantor ini terletak di area stasiun metro Kurskaya yang sama sekali tidak dikenal.  Makan siang mendekat.  Anda membuka aplikasi pencarian, menulis <b>"makan di Kursk"</b> dan mendapatkan pilihan opsi di mana Anda dapat makan. <br><br>  Apa yang ada di balik permintaan <b>"makan di Kursk"</b> dan bagaimana diproses untuk menemukan apa yang Anda butuhkan?  Dalam artikel ini saya akan memberi tahu Anda bagaimana tim Pencarian 2GIS melakukan segala yang mungkin untuk membuat kehidupan di kota lebih nyaman dan nyaman bagi pengguna. <br><a name="habracut"></a><br>  Penting untuk dipahami bahwa teks permintaan pencarian hanyalah puncak gunung es, sebagian kecil dari apa yang berinteraksi langsung dengan pengguna.  Permintaan pencarian itu sendiri, selain teks, berisi banyak data lainnya.  Mereka termasuk informasi yang dipersonalisasi tentang lokasi pengguna, area peta yang dilihatnya, serangkaian catatan dari favoritnya, dan informasi tentang mode pencarian.  Misalnya, pencarian di peta atau di gedung, atau mungkin pencarian untuk arah.  Data adalah kunci keberhasilan fungsionalitas pencarian yang baik. <br><br>  Kami sangat memperhatikan data dan strukturnya.  Selain itu, kami menyebut algoritma pencarian dalam pencarian struktural 2GIS, karena dipertajam oleh pencarian yang efektif dan cepat dalam data terstruktur kami.  Kami secara khusus menyiapkan indeks pencarian dan data dari mana ia dibangun.  Saya tidak akan merinci, saya hanya bisa mengatakan bahwa data diatur sedemikian rupa agar cukup sederhana untuk diproses, terkompresi dengan baik, dan yang paling penting, ini memungkinkan kita untuk memprosesnya dengan cepat bahkan pada perangkat seluler. <br><br>  Selain itu, pencarian dapat bekerja offline, dan karenanya membuat tuntutan khusus pada kecepatan dan volume indeks pencarian.  Kami sangat memperhatikan fitur ini - kami terus-menerus mengompres indeks pencarian, mengevaluasi kinerja pada semua jenis platform dan mempercepat fungsionalitas di mana kasus pencarian spesifik melebihi batas waktu yang ditentukan.  Ngomong-ngomong, kita dapat menyombongkan bahwa permintaan pencarian biasa di 2GIS pada perangkat seluler lebih cepat daripada aplikasi menggambar daftar drop-down berdasarkan hasil. <br><br>  Di bawah ini saya akan mengungkap tabir kerahasiaan yang menutupi keajaiban pencarian kami.  Sebagai contoh, kami menerima permintaan yang disebutkan <b>"makan di Kursk"</b> .  Pertimbangkan tahapan prosesnya dan apa yang terjadi pada masing-masingnya.  Jadi ayo pergi! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/bo/ik/cmboik3cpygx88wzp2apwq7gvjq.jpeg" width="375" height="667"></div><br><br><h3>  Tahap 1. Parsing </h3><br>  Parameter input: permintaan <b>"eat on Kursk"</b> <br><br>  Pertama-tama, kita perlu mem-parsing teks permintaan.  Ini penting, karena setelah parsing kita dapat bekerja bukan dengan teks permintaan, tetapi dengan set token yang berisinya.  Token adalah kata permintaan tunggal.  Dalam kasus kami, kami akan menerima satu set tiga token: <b>"eat"</b> , <b>"on"</b> , <b>"Kursk"</b> .  Tampaknya semuanya sederhana, tetapi iblis ada dalam perinciannya.  Dan kadang-kadang tidak begitu jelas: misalnya, dalam kueri "wi-fi" atau "ke-2", kita harus memahami bahwa kita harus menangani kombinasi tersebut secara keseluruhan. <br><br>  Token itu sendiri berisi informasi tentang teks kata, tentang posisi dalam permintaan, tentang keberadaan pemisah yang mengikuti kata dan beberapa karakteristik kata - register karakternya, apakah kata itu angka, nomor urut, nomor telepon, alamat atau data lainnya. <br><br><h3>  Tahap 2. Pencarian Kamus </h3><br>  Parameter input: token <b>â€œeatâ€</b> , <b>â€œonâ€</b> , <b>â€œKurskâ€</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/nx/gs/bmnxgsmvl1wuogtxci70yebty3i.jpeg" alt="gambar"></div><br>  Dengan daftar token permintaan yang siap, kami melanjutkan ke tahap pencarian kamus, yaitu, ke tahap di mana untuk setiap token kami menemukan daftar bentuk kata dari data kami.  Bentuk kata adalah informasi yang dikodekan tentang akar kata dan akhirnya. <br><br>  Kami menyajikan pencarian kamus sebagai algoritme untuk menganalisis kamus, disajikan dalam bentuk grafik.  Node di dalamnya adalah huruf, atau lebih tepatnya, simbol.  Grafik terdiri dari simbol node dan transisi antara node ini.  Hasil dari berkeliling grafik kamus kami adalah banyak bentuk kata yang bisa kita dapatkan berdasarkan token yang ditransfer dari tahap sebelumnya.  Jadi kami mencoba menemukan di dalam kamus kami urutan karakter yang cocok dengan token berikutnya dari permintaan.  Pada saat yang sama, seperti yang kita semua tahu, pengguna membuat kesalahan ketik, kehilangan huruf atau bahkan membuat kesalahan dalam tata letak keyboard.  Karena itu, ketika berkeliling kamus, kami menerapkan beberapa manipulasi untuk memperhitungkan faktor manusia yang mungkin atau mencoba menebak apa yang diperoleh seseorang saat ini.  Berbagai transformasi rantai karakter digunakan: menyisipkan, penggantian, menambahkan karakter, dan sejenisnya. <br><br>  Akibatnya, untuk setiap token permintaan dari grafik, kami mengekstrak sekumpulan bentuk kata dengan informasi tentang akar dan akhir kata, informasi tentang jumlah karakter dalam bentuk kata, dan perkiraan yang ditemukan.  Estimasi temuan - penilaian yang mengkarakterisasi jarak kosa kata dari urutan karakter yang ditemukan ke urutan yang diinginkan.  Evaluasi mencirikan seberapa banyak string karakter yang ditemukan berbeda dari token permintaan. <br><br>  Jadi untuk token kita menemukan bentuk kata: <br><br><ul><li>  13 formulir untuk <b>"makan"</b> : "makan", "makan", "paese", "payot", ... </li><li>  3 formulir untuk <b>"on"</b> : "na", "nu", "on" </li><li>  48 formulir untuk <b>"Kursk"</b> : "Kursk", "Kursk", "Kursk", "Kursk", "Kurako", ... </li></ul><br>  Selanjutnya, bentuk kata yang ditemukan disaring tergantung pada penilaian mereka.  Yang terbaik dari mereka, yaitu, sedekat mungkin dengan kata-kata dari permintaan, termasuk dalam daftar istilah.  Yang kami maksud adalah bentuk kata dan estimasi temuan.  Plus, selain bentuk kata yang ditemukan, istilah yang ditambahkan menggunakan aturan morfologi ditambahkan ke daftar.  Langkah penting dalam pemrosesan morfologis adalah penambahan penilaian morfologis.  Faktanya adalah bahwa pencarian kami menggunakan mekanisme pemrosesan morfologis yang kuat yang memungkinkan kami tidak hanya untuk menemukan kata-kata yang mirip dari kamus, tetapi menurut aturan bahasa alami, lebih akurat untuk menemukan apa yang sebenarnya menarik minat pengguna dengan makna, dan bukan hanya dengan kesamaan kata. <br><br>  Jadi untuk token, ketentuan akan dibuat: <br><br><ul><li>  <b>"Makan"</b> : "makan", "makan", "makan", "makan", "makan" </li><li>  <b>"Aktif"</b> : "hidup", "na", "nu" </li><li>  <b>"Kursk"</b> : "Kursk", "Kursk", "Kursk", "Kursk", "Kursk" </li></ul><br>  Pada tahap ini, pencarian kamus berakhir.  Kami telah memproses permintaan dan meminta setiap token daftar istilah yang akan diproses lebih lanjut.  Istilah-istilah ini mengandung semua informasi tentang kata yang diwakilinya, dan memiliki penilaian tentang bagaimana masing-masing ditemukan. <br><br><h3>  Langkah 3. Menemukan Entri Data </h3><br>  Input: serangkaian istilah untuk setiap bagian dari permintaan <br><br><ul><li>  <b>"Makan"</b> : "makan", "makan", "makan", "makan", "makan" </li><li>  <b>"Aktif"</b> : "hidup", "na", "nu" </li><li>  <b>"Kursk"</b> : "Kursk", "Kursk", "Kursk", "Kursk", "Kursk" </li></ul><br>  Setelah menerima serangkaian istilah untuk setiap bagian dari permintaan dari tahap sebelumnya, kami melanjutkan untuk mencarinya dengan indeks kami.  Setiap dokumen dalam data memiliki banyak judul dan ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks terbalik</a> sehingga kita dapat dengan mudah menemukan semua referensi ke istilah yang diinginkan dalam dokumen spesifik yang mewakili organisasi, alamat atau yang lainnya. <br><br>  Untuk setiap bagian dari permintaan dan untuk setiap persyaratan dari bagian-bagian ini, kami sedang mencari dokumen yang mengandung kata-kata yang dikodekan dalam istilah.  Jadi, untuk sebagian permintaan, entri akan ditemukan dalam semua ketentuan: <br><br><ul><li>  <b>"Makan"</b> : 18 entri </li><li>  <b>Pada</b> : 4.304 entri </li><li>  <b>Kursk</b> : 79 entri </li></ul><br>  Jelas, preposisi <b>"on"</b> terjadi berkali-kali dan karenanya jatuh ke dalam banyak judul dokumen - "take-out coffee", "play <b>on the</b> console", "registrasi the machine".  <b>"Makan"</b> dan <b>"Kursk"</b> juga digunakan berulang kali.  Kata kedua dengan istilahnya ditemukan dalam data kami jauh lebih sering daripada yang pertama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3j/4m/da/3j4mdasko01hxwfdvyk3n_bih5a.jpeg" width="300" height="300"></div><br>  Dengan klik, kami menganggap kecocokan kata dari permintaan pencarian dengan kata dari dokumen tertentu.  Hit ini disimpan dalam daftar, yang akan dianalisis pada langkah selanjutnya.  Saat menambahkan klik, kami tidak hanya menyalin data tentang kata dalam dokumen dari istilah tersebut, tetapi juga menghitung estimasi terbaik tentang bagaimana kata itu dapat ditemukan.  Dengan kata lain, kami memilih penilaian morfologis dari istilah tersebut, atau penilaian tentang bagaimana istilah itu ditemukan dalam kamus, tergantung pada peringkat mana yang lebih dekat dengan token permintaan. <br><br>  Tahap ini merupakan awal dari awal pencarian itu sendiri.  Kami telah menyiapkan serangkaian klik dalam dokumen tertentu, berdasarkan algoritma mana yang akan memilih dan mengevaluasi apa yang perlu diberikan kepada pengguna sebagai hasilnya. <br><br><h3>  Tahap 4. Jantung pencarian </h3><br>  Pintu masuk: daftar sasaran <br><br><ul><li>  <b>"Makan"</b> : 18 entri </li><li>  <b>Pada</b> : 4.304 entri </li><li>  <b>Kursk</b> : 79 entri </li></ul><br>  Bahkan, daftar sasaran dalam implementasi kami adalah wadah yang cukup rumit.  Penting untuk dipahami bahwa ketika menambahkan klik ke sana, node khusus dibuat di mana hit itu direkam, dan tautan ke dokumen tempat hit tersebut jatuh. <br><br>  Oleh karena itu, akan lebih tepat untuk menampilkan data input sebagai berikut: <br>  Pintu masuk: wadah simpul dokumen <br><br><ul><li>  <b>document1: {hits, ...}</b> </li><li>  <b>document2: {hits, ...}</b> </li><li>  <b>document3: {hits, ...}</b> </li><li>  <b>document4: {hits, ...}</b> </li><li>  ... </li></ul><br>  Pertama-tama, pencarian mulai melewati pohon dokumen dan setiap node mengirimkannya ke penganalisa, yang mengevaluasi apakah dokumen dari simpul ini cocok untuk menjadi hasil untuk masuk ke output.  Untuk memahami volume yang harus dianalisa oleh penganalisa, saya akan mengatakan bahwa pada awalnya wadah tersebut berisi lebih dari 3000 node!  Tetapi node dapat ditambahkan selama proses crawl, oleh karena itu, sebenarnya diproses lebih lanjut.  Tidak berlebihan untuk mengatakan bahwa analisis adalah bagian yang paling mahal dari pencarian dan pada saat yang sama salah satu fungsi proyek yang paling kompleks dan besar.  Namun demikian, ini berjalan sangat cepat bahkan pada perangkat seluler. <br><br><h3>  Tahap 5. Analisis </h3><br>  Input: Node <b>dokumen: {hits, ...}</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ak/jj/my/akjjmypuvajc-jymk3_x4o0r9vo.png"></div><br>  Analisis dimulai dengan mendapatkan daftar judul dari node.  Judul adalah judul dan daftar klik yang termasuk dalam judul dokumen ini.  Judul-judul ini akan dievaluasi pada tahap pertama.  Penting bagi kita untuk mengetahui manfaat dari setiap judul.  Kegunaan bisa baik, lemah dan sampah. <br><br>  Untuk setiap judul, yang terbaik dari rantai hit dipilih - yang terbaik dalam panjang dan skor kosa kata, terdiri dari kesamaan dari hit.  Berdasarkan rantai terbaik, judul akan dievaluasi utilitasnya.  Untuk menentukan kegunaan rantai, kami juga menggunakan mekanisme berdasarkan frekuensi kata dalam dokumen.  Secara kasar, semakin sering sebuah kata muncul di dokumen, semakin penting artinya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TF-IDF</a> ).  Jadi, jika rantai berisi kata penting dari judul dokumen tanpa perbedaan morfologis yang kuat, misalnya, jumlah yang sangat baik atau jenis kelamin, kami menganggap judul tersebut berguna.  Judul juga dapat bermanfaat jika hitnya sepenuhnya mencakup kata-kata dari judul dokumen. <br><br>  Menggunakan utilitas, semua judul membentuk topeng utilitas untuk node.  Topeng ini memberi kita gambaran tentang token permintaan yang dicakup oleh simpul yang dianalisis.  Dan dengan bantuannya, kami sangat menentukan apakah akan menganalisis node lebih lanjut. <br><br>  Sebagai hasilnya, kami tidak hanya memiliki satu dokumen dari indeks, tetapi satu set data struktural yang mewakili hasil potensial dengan informasi tentang bagaimana ia dapat ditemukan. <br><br><h3>  Langkah 6. Evaluasi </h3><br>  Input: Node <b>dokumen: {hits, ...}</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/ek/rs/vsekrs0bs3knmkccjj160wxpdzw.jpeg"></div><br>  Bergantung pada topeng utilitas, kami akan memproses node, atau segera melanjutkan ke yang berikutnya.  Dari sekian banyak node yang diproses, kami mengumpulkan berbagai informasi tentang totalitasnya.  Misalnya, banyak judul node, hubungan antara node dan beberapa data lainnya. <br><br>  Selanjutnya dimulai analisis judul-judul node yang saling berhubungan satu sama lain.  Faktanya, banyak node digabungkan ke dalam grafik node, yang kami evaluasi. <br><br>  Dari simpul-simpul dari simpul-simpul grafik, kita mendapatkan daftar judul-judul peringkat.  Sederhananya, dari berbagai node kami menyusun satu daftar judul, di mana untuk setiap elemen kami juga menambahkan perkiraan dan kombinasi faktor dari hits judul semua node yang berpartisipasi. <br><br>  Evaluasi - suatu struktur dengan informasi tentang jumlah kata yang terlibat dalam suatu judul dari suatu permintaan dan banyak faktor lain tentang bagaimana kata itu ditemukan dan diproses - mulai dari tahap pencarian kamus.  Adalah penting bahwa nilai-nilai ini dari judul peringkat akan berpartisipasi dalam pemilihan nilai terbaik.  Beberapa dari mereka akan ditandai sebagai dipilih dan akan berkontribusi pada penilaian akhir dari hasil yang dilihat pengguna. <br><br>  Penilaian keseluruhan memberikan informasi hasil yang akan sangat penting dalam menyortir seluruh output.  Ini berisi faktor-faktor seperti, misalnya, kata-kata yang hilang dari kueri.  Ukuran ini mencirikan jumlah kata yang tidak tercakup oleh simpul dengan informasi strukturalnya. <br><br>  Berdasarkan informasi tentang kegunaan judul, kejelasan hasilnya ditentukan.  Kejelasan bisa baik, lemah dan buruk.  Dan itu dihitung dengan partisipasi semua judul yang dipilih untuk simpul yang diproses.  Semua data ini memiliki efek dramatis pada nasib hasil dan urutan penerbitannya. <br><br>  Secara bertahap, kami mendekati akhir analisis node.  Sebelum node akhirnya meninggalkan analisa dan menjadi hasil yang potensial, kami melakukan beberapa manipulasi yang lebih spesifik.  Misalnya, kompatibilitas judul dokumen yang dipilih. <br><br>  Node yang telah melewati semua lingkaran alat analisa membentuk hasil yang berisi informasi tentang header dan dokumen yang dipilih.  Hasilnya, yang memberikan cakupan yang baik dari permintaan pencarian, dikirim ke post-processing. <br><br><h3>  Langkah 7. Post Processing </h3><br>  Input: hasil dibangun dari simpul <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ve/ue/9b/veue9bh6pkqqx7hd1pynhtyanms.jpeg"></div><br>  Analisator menyaring banyak catatan dari indeks sebelum hasilnya.  Namun, selama analisis, banyak hasil potensial dapat dievaluasi dan dikirim untuk diproses.  Untuk menunjukkan kepada pengguna satu-satunya yang paling berguna dalam urutan relevansi, kita perlu memotong opsi terburuk yang ditemukan oleh penganalisa. <br><br>  Pada langkah sebelumnya, penilaian umum dari hasil disebutkan.  Penilaian umum memungkinkan kita untuk memotong hasil terburuk pada tahap pasca-pemrosesan.  Gradasinya adalah sebagai berikut.  Hasil yang tidak mencakup token permintaan apa pun jelas lebih buruk daripada token yang sepenuhnya mencakup permintaan pengguna.  Hasil dengan kejelasan yang lebih buruk jelas kurang diinginkan daripada hasil dengan kejelasan yang baik.  Post-prosesor mengumpulkan informasi tentang hasil yang masuk dan menghilangkan yang jelas lebih buruk.  Sisanya menambah daftar. <br><br>  Sebelum kami memberikan informasi pengguna yang lapar tentang kafe, kami melakukan pemrosesan akhir - urutkan berdasarkan relevansi.  Penyortiran melibatkan banyak faktor, dihitung dan dikumpulkan pada berbagai tahap pencarian.  Dan pada akhirnya, hasil pencarian untuk <b>"makan di Kursk"</b> adalah lebih dari 500 hasil.  Banyak dari mereka ditemukan dengan cara yang sama, dan karenanya memiliki peringkat yang sama.  Mereka akan diurutkan berdasarkan popularitas pengguna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ya/ml/jo/yamljowh757kha0ft1akjtwccae.jpeg" width="375" height="667"></div><br><br><h3>  Kesimpulan </h3><br>  Kami menerima ekstradisi dengan banyak kafe dan restoran dan, senangnya, kami pergi makan malam.  Kami mendapatkan semua hasil dalam sepersekian detik.  Kami bahkan tidak memerlukan koneksi internet. <br><br>  Aplikasi menyimpan indeks pencarian di perangkat.  Skema semacam itu memberi kita tugas-tugas non-sepele mengoptimalkan kompresi data dan kecepatan pemrosesan - lagipula, pencarian harus bekerja dengan cepat pada berbagai macam perangkat seluler!  Namun, ini adalah kisah yang sangat berbeda. <br><br>  Hari ini saya mencoba membuka kap mesin pencari kami dan menunjukkan bagaimana kami membantu pengguna menemukan apa yang mereka butuhkan di kota, dan melakukannya dengan cepat dan mudah.  Saya harap ini informatif. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433696/">https://habr.com/ru/post/id433696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433680/index.html">Acara musim dingin untuk industri game di HSE dan simulator gamedev desktop</a></li>
<li><a href="../id433682/index.html">Cara menggabungkan konten file di PowerShell. Dan jangan menderita</a></li>
<li><a href="../id433686/index.html">Amazon mulai menjual produk Apple langsung di situs webnya</a></li>
<li><a href="../id433688/index.html">Bagaimana ulasan acara YouTube tahunan meluncurkan Perang Sipil</a></li>
<li><a href="../id433692/index.html">Untuk menyelesaikan tugas optimasi yang paling sulit, cukup tambahkan laser</a></li>
<li><a href="../id433698/index.html">Filsafat CSS</a></li>
<li><a href="../id433700/index.html">Filter Bloom di Jawa dengan Jambu</a></li>
<li><a href="../id433704/index.html">Kutipan dari novel Endless Joke tentang video palsu dan topeng untuk foto dan video - bertahun-tahun sebelum penampilan aslinya</a></li>
<li><a href="../id433706/index.html">Sandbox di Windows</a></li>
<li><a href="../id433708/index.html">Selamat datang di Pertemuan Kelima Cybersecurity Industri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>