<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìñ üí¥ ‚õÖÔ∏è Wie man polymorphe Programme mit Arrow schreibt ü§¶üèø üë©üèø‚Äçüé® üë®üèΩ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Mein Name ist Artyom Dobrovinsky, ich arbeite f√ºr Finch . Ich schlage vor, einen Artikel eines der V√§ter der Arrow Bibliothek f√ºr funkt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man polymorphe Programme mit Arrow schreibt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447234/"><img src="https://habrastorage.org/webt/va/-y/jh/va-yjhqxdrghleli7gqzgt553r0.png"><br><br>  Hallo Habr! <br><br>  Mein Name ist Artyom Dobrovinsky, ich arbeite f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Finch</a> .  Ich schlage vor, einen Artikel eines der V√§ter der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Arrow</code></a> Bibliothek f√ºr funktionale Programmierung √ºber das Schreiben polymorpher Programme zu lesen.  Oft haben Menschen, die gerade erst anfangen, in einem funktionalen Stil zu schreiben, es nicht eilig, sich von alten Gewohnheiten zu trennen, und schreiben tats√§chlich einen etwas eleganteren Imperativ mit DI-Containern und Vererbung.  Die Idee, Funktionen unabh√§ngig von den verwendeten Typen wiederzuverwenden, kann viele dazu veranlassen, in die richtige Richtung zu denken. <br><p>  Viel Spa√ü! </p><a name="habracut"></a><br><h3>  ***. </h3><br><p>  Was w√§re, wenn wir Anwendungen schreiben k√∂nnten, ohne √ºber die Datentypen nachzudenken, die zur Laufzeit verwendet werden, aber einfach beschreiben, wie diese Daten verarbeitet werden? </p><br><p>  Stellen Sie sich vor, wir haben eine Anwendung, die mit dem <code>Observable</code> Typ aus der RxJava-Bibliothek funktioniert.  Dieser Typ erm√∂glicht es uns, Ketten von Aufrufen und Manipulationen mit Daten zu schreiben. Wird dieses <code>Observable</code> am Ende nicht nur ein Container mit zus√§tzlichen Eigenschaften sein? </p><br><p>  Die gleiche Geschichte mit Typen wie <code>Flowable</code> , <code>Deferred</code> (Coroutines), <code>Future</code> , <code>IO</code> und vielen anderen. </p><br><p>  Konzeptionell stellen alle diese Typen eine Operation dar (die bereits ausgef√ºhrt wurde oder in Zukunft implementiert werden soll), die Manipulationen wie das <code>flatMap</code> eines internen Werts in einen anderen Typ ( <code>map</code> ) unterst√ºtzt. Mit <code>flatMap</code> eine Kette von Operationen eines √§hnlichen Typs erstellt und mit anderen Instanzen desselben Typs ( <code>zip</code> kombiniert ), usw. </p><br><p>  Um Programme zu schreiben, die auf diesen Verhaltensweisen basieren, w√§hrend eine deklarative Beschreibung beibehalten wird, und um Ihre Programme unabh√§ngig von bestimmten Datentypen wie <code>Observable</code> aus, dass die verwendeten Datentypen bestimmten Vertr√§gen wie <code>map</code> , <code>flatMap</code> und anderen entsprechen . </p><br><p>  Ein solcher Ansatz mag seltsam oder zu kompliziert erscheinen, hat aber interessante Vorteile.  Betrachten Sie zun√§chst ein einfaches Beispiel und sprechen Sie dann dar√ºber. </p><cut></cut><br><h3 id="kanonicheskaya-problema">  Kanonisches Problem </h3><br><p>  Angenommen, wir haben eine Anwendung mit einer <code>Task</code> und m√∂chten eine Liste von Objekten vom Typ <code>Task</code> aus dem lokalen Cache extrahieren.  Wenn sie nicht im lokalen Speicher gefunden werden, werden wir versuchen, sie √ºber das Netzwerk abzufragen.  Wir ben√∂tigen einen einzigen Vertrag f√ºr beide Datenquellen, damit beide eine Liste von Objekten vom Typ <code>Task</code> f√ºr ein geeignetes <code>User</code> , unabh√§ngig von der Quelle: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Der Einfachheit halber geben wir hier <code>Observable</code> , aber es kann <code>Single</code> , <code>Maybe</code> , <code>Flowable</code> , <code>Deferred</code> - alles, was zur Erreichung des Ziels geeignet ist. </p><br><p>  F√ºgen Sie einige Mokka-Implementierungen von Datenquellen hinzu, eine f√ºr <code></code> und eine f√ºr <code></code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val localCache: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cachedUser = localCache[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cachedUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(cachedUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInLocalStorage(user)) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val internetStorage: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> networkUser = internetStorage[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (networkUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(networkUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInRemoteStorage(user)) } } }</code> </pre> <br><p>  Die Implementierungen beider Datenquellen sind nahezu identisch.  Dies sind einfach Scheinversionen dieser Quellen, die idealerweise Daten aus dem lokalen Speicher oder der Netzwerk-API abrufen.  In beiden F√§llen wird <code>Map&lt;User, List&lt;Task&gt;&gt;</code> zum Speichern von Daten verwendet. </p><br><p>  Weil  Wir haben zwei Datenquellen, wir m√ºssen sie irgendwie koordinieren.  Erstellen Sie ein Repository: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = localDS.allTasksByUser(user) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.computation()) .onErrorResumeNext { _: Throwable -&gt; remoteDS.allTasksByUser(user) } }</code> </pre> <br><p>  Es wird lediglich versucht, die <code>List&lt;Task&gt;</code> von <code>LocalDataSource</code> zu laden. Wenn sie nicht gefunden wird, wird versucht, sie mithilfe von <code>RemoteDataSource</code> vom Netzwerk <code>RemoteDataSource</code> . </p><br><p>  Erstellen wir ein einfaches Modul zum Bereitstellen von Abh√§ngigkeiten, ohne ein Framework f√ºr die Abh√§ngigkeitsinjektion (DI) zu verwenden: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource = LocalDataSource() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource = RemoteDataSource() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository = TaskRepository(localDataSource, remoteDataSource) }</code> </pre> <br><p>  Und schlie√ülich brauchen wir einen einfachen Test, der den gesamten Stapel von Operationen ausf√ºhrt: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dependenciesModule = Module() dependenciesModule.run { repository.allTasksByUser(user1).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user2).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user3).subscribe({ println(it) }, { println(it) }) } } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der gesamte obige Code befindet sich auf dem Github</a> . </p><br><p>  Dieses Programm erstellt die Ausf√ºhrungskette f√ºr drei Benutzer und abonniert dann das resultierende <code>Observable</code> . </p><br><p>  Die ersten beiden Objekte vom Typ <code>User</code> sind verf√ºgbar, damit hatten wir Gl√ºck.  <code>User1</code> ist in der lokalen <code>DataSource</code> verf√ºgbar, und <code>User2</code> ist in der Fernbedienung verf√ºgbar. </p><br><p>  Es gibt jedoch ein Problem mit <code>User3</code> , da es nicht im lokalen Speicher verf√ºgbar ist.  Das Programm wird versuchen, es von einem Remote-Dienst herunterzuladen - aber es ist auch nicht da.  Die Suche schl√§gt fehl und es wird eine Fehlermeldung in der Konsole angezeigt. </p><br><p>  In allen drei F√§llen wird Folgendes in der Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">&gt; [Task(value=LocalTask assigned to user1)] &gt; [Task(value=Remote Task assigned to user2)] &gt; UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Wir sind mit einem Beispiel fertig.  Versuchen wir nun, diese Logik im Stil des <code> </code> zu programmieren. </p><br><h3 id="abstragirovanie-tipov-dannyh">  Datentypabstraktion </h3><br><p>  Der Vertrag f√ºr die <code>DataSource</code> Schnittstelle sieht nun folgenderma√üen aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Alles scheint √§hnlich zu sein, aber es gibt zwei wichtige Unterschiede: </p><br><ul><li>  Es besteht eine Abh√§ngigkeit vom generalisierten Typ (generisch) <code>F</code> </li><li>  Der von der Funktion zur√ºckgegebene Typ ist jetzt <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </li></ul><br><p>  <code>Kind</code> ist, wie Arrow das codiert, was √ºblicherweise als <code>  (higher kind)</code> . <br>  Ich werde dieses Konzept anhand eines einfachen Beispiels erl√§utern. </p><br><p>  <code>Observable&lt;A&gt;</code> besteht aus 2 Teilen: </p><br><ul><li>  <code>Observable</code> : Beh√§lter, fester Typ. </li><li>  <code>A</code> : Argument eines generischen Typs.  Eine Abstraktion, an die andere Typen √ºbergeben werden k√∂nnen. </li></ul><br><p>  Wir sind es gewohnt, generische Typen wie <code>A</code> als Abstraktionen zu verwenden.  Aber nicht viele Leute wissen, dass wir auch Containertypen wie <code>Observable</code> abstrahieren k√∂nnen.  Daf√ºr gibt es hohe Typen. </p><br><p>  Die Idee ist, dass wir einen Konstruktor wie <code>F&lt;A&gt;</code> in dem sowohl <code>F</code> als auch <code>A</code> ein generischer Typ sein k√∂nnen.  Diese Syntax wird vom Kotlin-Compiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">noch</a> nicht unterst√ºtzt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">noch?</a> ), Daher werden wir sie mit einem √§hnlichen Ansatz nachahmen. </p><br><p>  Arrow unterst√ºtzt dies durch die Verwendung einer Zwischen-Meta-Schnittstelle <code>Kind&lt;F, A&gt;</code> , die Links zu beiden Typen enth√§lt und w√§hrend der Kompilierung Konverter in beide Richtungen generiert, sodass Sie dem Pfad von <code>Kind&lt;Observable, List&lt;Task&gt;&gt;</code> folgen k√∂nnen <code>Kind&lt;Observable, List&lt;Task&gt;&gt;</code> zu <code>Observable&lt;List&lt;Task&gt;&gt;</code> und umgekehrt.  Keine ideale L√∂sung, aber eine funktionierende. </p><br><p>  Schauen Sie sich also noch einmal die Oberfl√§che unseres Repositorys an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Die <code>DataSource</code> Funktion gibt einen hohen Typ zur√ºck: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  Es wird in <code>F&lt;List&lt;Task&gt;&gt;</code> , wobei <code>F</code> verallgemeinert bleibt. </p><br><p>  Wir erfassen nur die <code>List&lt;Task&gt;</code> in der Signatur.  Mit anderen Worten, es ist uns egal, welcher Container vom Typ <code>F</code> verwendet wird, solange er eine <code>List&lt;Task&gt;</code> .  Wir k√∂nnen verschiedene Datencontainer an die Funktion √ºbergeben.  Schon klar?  Mach weiter. </p><br><p>  <code>DataSource</code> wir einen Blick auf die auf diese Weise implementierte <code>DataSource</code> , diesmal jedoch f√ºr jede einzelne.  Zuerst zu lokal: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  Es wurden viele neue Dinge hinzugef√ºgt, wir werden alles Schritt f√ºr Schritt analysieren. </p><br><p>  Diese <code>DataSource</code> beh√§lt den generischen Typ <code>F</code> da sie eine <code>DataSource&lt;F&gt;</code> implementiert.  Wir wollen die M√∂glichkeit behalten, diesen Typ von au√üen zu √ºbertragen. </p><br><p>  Vergessen Sie nun den m√∂glicherweise unbekannten <code>ApplicativeError</code> im Konstruktor und konzentrieren Sie sich auf die Funktion <code>allTasksByUser()</code> .  Und wir werden zu <code>ApplicativeError</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } )</code> </pre> <br><p>  Es ist ersichtlich, dass <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  Es ist uns immer noch egal, was der Container <code>F</code> , solange er eine <code>List&lt;Task&gt;</code> . </p><br><p>  Aber es gibt ein Problem.  Abh√§ngig davon, ob wir die Liste der <code>Task</code> f√ºr den gew√ºnschten Benutzer im lokalen Speicher finden k√∂nnen oder nicht, m√∂chten wir einen Fehler melden (keine <code>Task</code> gefunden) oder die bereits in <code>F</code> <code>Task</code> ( <code>Task</code> gefunden). </p><br><p>  In beiden F√§llen m√ºssen wir Folgendes zur√ºckgeben: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </p><br><p>  Mit anderen Worten: Es gibt einen Typ, von dem wir nichts wissen ( <code>F</code> ), und wir brauchen eine M√∂glichkeit, einen in diesen Typ eingeschlossenen Fehler zur√ºckzugeben.  Au√üerdem ben√∂tigen wir eine M√∂glichkeit, eine Instanz dieses Typs zu erstellen, in die der nach erfolgreichem Abschluss der Funktion erhaltene Wert eingeschlossen wird.  Klingt nach etwas Unm√∂glichem? </p><br><p>  Kehren wir zur Klassendeklaration zur√ºck und stellen fest, dass <code>ApplicativeError</code> an den Konstruktor √ºbergeben und dann als Delegat f√ºr die Klasse ( <code>by A</code> ) verwendet wird. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>ApplicativeError</code></a> von <code>Applicative</code> geerbt, beide sind Typklassen. </p><br><p>  Typklassen definieren Verhaltensweisen (Vertr√§ge).  Sie sind als Schnittstellen codiert, die mit Argumenten in Form generischer Typen arbeiten, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Monad&lt;F&gt;</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Functor&lt;F&gt;</code></a> und vielen anderen.  Dieses <code>F</code> ist ein Datentyp.  Auf diese Weise k√∂nnen wir Typen wie <code>Either</code> , <code>Option</code> , <code>Flowable</code> , <code>Observable</code> , <code>Flowable</code> und viele mehr √ºbergeben. </p><br><p>  Zur√ºck zu unseren beiden Problemen: </p><br><ul><li>  Wickeln Sie den Wert, der nach erfolgreichem Abschluss der Funktion erhalten wurde, in <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  Hierf√ºr k√∂nnen wir eine Klasse vom Typ <code>Applicative</code> .  Da <code>ApplicativeError</code> von ihm geerbt wird, k√∂nnen wir seine Eigenschaften delegieren. </p><br><p>  <code>Applicative</code> bietet <code>just(a)</code> Funktion <code>just(a)</code> .  <code>just(a)</code> umschlie√üt den Wert im Kontext eines beliebigen High-Typs.  Wenn wir also <code>Applicative&lt;F&gt;</code> , kann es <code>just(a)</code> aufrufen, um den Wert in Container <code>F</code> zu verpacken, unabh√§ngig davon, um welchen Wert es sich handelt.  Nehmen wir an, wir verwenden <code>Observable</code> . Wir haben ein <code>Applicative&lt;Observable&gt;</code> , das wei√ü, wie man ein <code>Observable</code> , damit wir <code>Observable.just(a)</code> . </p><br><ul><li>  Schlie√üen Sie den Fehler in die Instanz <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  Hierf√ºr k√∂nnen wir <code>ApplicativeError</code> .  Es bietet eine Funktion <code>raiseError(e)</code> , die den Fehler in einen Container vom Typ <code>F</code> <code>raiseError(e)</code>  F√ºr das <code>Observable</code> Beispiel erzeugt ein Fehler so etwas wie <code>Observable.error&lt;A&gt;(t)</code> , wobei <code>t</code> <code>Throwable</code> , da wir unseren Fehlertyp als Klasse vom Typ <code>ApplicativeError&lt;F, Throwable&gt;</code> . </p><br><p>  Schauen Sie sich unsere abstrakte Implementierung von <code>LocalDataSource&lt;F&gt;</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  Die im Speicher gespeicherte <code>Map&lt;User, List&lt;Task&gt;&gt;</code> bleibt unver√§ndert, aber jetzt f√ºhrt die Funktion einige Dinge aus, die f√ºr Sie m√∂glicherweise neu sind: </p><br><ul><li><p>  Sie versucht, die <code>Task</code> aus dem lokalen Cache zu laden. Da der R√ºckgabewert m√∂glicherweise <code>null</code> ( <code>Task</code> m√∂glicherweise nicht gefunden), modellieren wir dies mithilfe der <code>Option</code> .  Wenn nicht klar ist, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Option</code></a> funktioniert, wird das Vorhandensein oder Fehlen des darin eingeschlossenen Werts modelliert. </p><br></li><li><p>  Nachdem wir den optionalen Wert erhalten haben, rufen wir <code>fold</code> auf.  Dies entspricht der Verwendung der <code>when</code> f√ºr einen optionalen Wert.  Wenn der Wert fehlt, <code>Option</code> den Fehler mit dem Datentyp <code>F</code> (erstes Lambda √ºbergeben).  Wenn der Wert vorhanden ist, erstellt <code>Option</code> eine Wrapper-Instanz f√ºr den Datentyp <code>F</code> (zweites Lambda).  In beiden F√§llen werden die zuvor genannten <code>ApplicativeError</code> Eigenschaften verwendet: <code>raiseError()</code> und <code>just()</code> . </p><br></li></ul><br><p>  Daher haben wir die Implementierung von Datenquellen mithilfe von Klassen abstrahiert, damit diese nicht wissen, welcher Container f√ºr den verwendeten Typ <code>F</code> . </p><br><p>  Implementieren einer Netzwerk- <code>DataSource</code> sieht folgenderma√üen aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) : DataSource&lt;F&gt;, Async&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> internetStorage: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) } }</code> </pre> <br><p>  Es gibt jedoch einen kleinen Unterschied: Anstatt an die <code>ApplicativeError</code> Instanz zu delegieren, verwenden wir eine andere Klasse wie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Async</code></a> . </p><br><p>  Dies liegt daran, dass Netzwerkanrufe asynchroner Natur sind.  Wir m√∂chten Code schreiben, der asynchron ausgef√ºhrt wird. Es ist logisch, eine daf√ºr vorgesehene Typklasse zu verwenden. </p><br><p>  <code>Async</code> verwendet, um asynchrone Operationen zu simulieren.  Es kann jeden R√ºckrufvorgang simulieren.  Beachten Sie, dass wir die spezifischen Datentypen immer noch nicht kennen. Wir beschreiben lediglich eine asynchrone Operation. </p><br><p>  Betrachten Sie die folgende Funktion: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) }</code> </pre> <br><p>  Wir k√∂nnen die Funktion <code>async {}</code> , f√ºr die wir eine Klasse vom Typ <code>Async</code> , um die Operation zu simulieren und eine Instanz vom Typ <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> erstellen, die asynchron erstellt wird. </p><br><p>  Wenn wir einen festen Datentyp wie <code>Observable</code> , w√§re <code>Async.async {}</code> √§quivalent zu <code>Observable.create()</code> , d. H.  Erstellen einer Operation, die aus synchronem oder asynchronem Code wie <code>Thread</code> oder <code>AsyncTask</code> . </p><br><p>  Der <code>callback</code> wird verwendet, um die resultierenden R√ºckrufe mit dem Containerkontext <code>F</code> zu verkn√ºpfen, der ein hoher Typ ist. </p><br><p>  Somit ist unsere <code>RemoteDataSource</code> abstrahiert und h√§ngt vom noch unbekannten Container vom Typ <code>F</code> </p><br><p>  Gehen wir zur Abstraktionsebene und werfen einen weiteren Blick auf unser Repository.  Wenn Sie sich erinnern, m√ºssen wir zuerst in <code>LocalDataSource</code> nach <code>Task</code> Objekten <code>LocalDataSource</code> und erst dann (wenn sie nicht lokal gefunden wurden), um sie von <code>RemoteLocalDataSource</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource&lt;F&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource&lt;F&gt;, AE: ApplicativeError&lt;F, Throwable&gt;) : ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> AE { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } } }</code> </pre> <br><p>  <code>ApplicativeError&lt;F, Throwable&gt;</code> ist wieder bei uns!  Es bietet auch eine <code>handleErrorWith()</code> -Funktion, die auf jedem High-End-Empf√§nger funktioniert. </p><br><p>  Es sieht so aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> Kind</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;F, A&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">E</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; Kind&lt;F, A&gt;): Kind&lt;F, A&gt;</code> </pre> <br><p>  Weil  <code>localDS.allTasksByUser(user)</code> gibt <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> , was als <code>F&lt;List&lt;Task&gt;&gt;</code> , wobei <code>F</code> ein generischer Typ bleibt. <code>handleErrorWith()</code> k√∂nnen wir <code>handleErrorWith()</code> aufrufen. </p><br><p>  <code>handleErrorWith()</code> k√∂nnen Sie mit dem √ºbergebenen Lambda auf Fehler reagieren.  Schauen wir uns die Funktion genauer an: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } }</code> </pre> <br><p>  Somit erhalten wir das Ergebnis der ersten Operation, au√üer wenn eine Ausnahme ausgel√∂st wurde.  Die Ausnahme wird vom Lambda behandelt.  Wenn der Fehler zum <code>UserNotInLocalStorage</code> Typ geh√∂rt, werden wir versuchen, Objekte vom Typ <code>Tasks</code> in der Remote- <code>DataSource</code> .  In allen anderen F√§llen verpacken wir den unbekannten Fehler in einen Container vom Typ <code>F</code> </p><br><p>  Das Abh√§ngigkeitsmodul bleibt der vorherigen Version sehr √§hnlich: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource&lt;F&gt; = LocalDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource&lt;F&gt; = RemoteDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository&lt;F&gt; = TaskRepository(localDataSource, remoteDataSource, A) }</code> </pre> <br><p>  Der einzige Unterschied besteht darin, dass es jetzt abstrakt ist und von <code>F</code> abh√§ngt, das polymorph bleibt.  Ich habe dies bewusst nicht beachtet, um den Rauschpegel zu reduzieren, aber <code>Async</code> von <code>ApplicativeError</code> geerbt, daher kann es auf allen Ebenen der Programmausf√ºhrung als Instanz verwendet werden. </p><br><h3 id="testiruya-polimorfizm">  Polymorphismus testen </h3><br><p>  Schlie√ülich ist unsere Anwendung vollst√§ndig von der Verwendung bestimmter Datentypen f√ºr Container ( <code>F</code> ) abstrahiert, und wir k√∂nnen uns darauf konzentrieren, den Polyformismus zur Laufzeit zu testen.  Wir werden denselben Code testen, der verschiedene Datentypen f√ºr Typ <code>F</code> an ihn <code>F</code>  Das Szenario ist das gleiche wie bei der Verwendung von <code>Observable</code> . </p><br><p>  Das Programm ist so geschrieben, dass wir die Grenzen von Abstraktionen vollst√§ndig beseitigen und Implementierungsdetails nach Wunsch √ºbermitteln k√∂nnen. </p><br><p>  Versuchen wir zun√§chst, <code>F</code> <code>Single</code> aus RxJava als Container zu verwenden. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> singleModule = Module(SingleK.async()) singleModule.run { repository.allTasksByUser(user1).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().single.subscribe(::println, ::println) } } }</code> </pre> <br><p>  Aus Kompatibilit√§tsgr√ºnden bietet Arrow Wrapper f√ºr bekannte Bibliotheksdatentypen.  Zum Beispiel gibt es einen praktischen <code>SingleK</code> Wrapper.  Mit diesen Wrappern k√∂nnen Sie Typklassen in Verbindung mit Datentypen als hohe Typen verwenden. </p><br><p>  Folgendes wird auf der Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Das gleiche Ergebnis wird <code>Observable</code> , wenn <code>Observable</code> . </p><br><p>  Lassen Sie uns nun mit <code>Maybe</code> , f√ºr das der <code>MaybeK</code> Wrapper <code>MaybeK</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> maybeModule = Module(MaybeK.async()) maybeModule.run { repository.allTasksByUser(user1).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().maybe.subscribe(::println, ::println) } }</code> </pre> <br><p>  Das gleiche Ergebnis wird auf der Konsole angezeigt, verwendet jedoch jetzt einen anderen Datentyp: </p><br><pre> <code class="kotlin hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Was ist mit <code>ObservableK</code> / <code>FlowableK</code> ? <br>  Probieren wir es aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> observableModule = Module(ObservableK.async()) observableModule.run { repository.allTasksByUser(user1).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().observable.subscribe(::println, ::println) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> flowableModule = Module(FlowableK.async()) flowableModule.run { repository.allTasksByUser(user1).fix().flowable.subscribe(::println) repository.allTasksByUser(user2).fix().flowable.subscribe(::println) repository.allTasksByUser(user3).fix().flowable.subscribe(::println, ::println) } } }</code> </pre> <br><p>  Wir werden in der Konsole sehen: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))) [Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Alles funktioniert wie erwartet. </p><br><p>  Versuchen wir es mit <code>DeferredK</code> , einem Wrapper f√ºr den Typ <code>kotlinx.coroutines.Deferred</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModule = Module(DeferredK.async()) deferredModule.run { runBlocking { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { println(repository.allTasksByUser(user1).fix().deferred.await()) println(repository.allTasksByUser(user2).fix().deferred.await()) println(repository.allTasksByUser(user3).fix().deferred.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: UserNotInRemoteStorage) { println(e) } } } } }</code> </pre> <br><p>  Wie Sie wissen, muss die Ausnahmebehandlung bei Verwendung von Corutin ausdr√ºcklich vorgeschrieben werden.   ,        ,        . </p><br><p>   ‚Äî   : </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Arrow   API     <code>DeferredK</code> .     <code>runBlocking</code>     : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModuleAlt = Module(DeferredK.async()) deferredModuleAlt.run { println(repository.allTasksByUser(user1).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user2).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user3).fix().unsafeAttemptSync()) } } }</code> </pre> <br><p>      [ <code>Try</code> ]({{ '/docs/arrow/core/try/ru' | relative_url }}) (..,   <code>Success</code>  <code>Failure</code> ). </p><br><pre> <code class="plaintext hljs">Success(value=[Task(value=LocalTask assigned to user1)]) Success(value=[Task(value=Remote Task assigned to user2)]) Failure(exception=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> ,          ,  <code>IO</code> . <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>IO</code></a> ,   in/out ,      ,       . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ioModule = Module(IO.async()) ioModule.run { println(repository.allTasksByUser(user1).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user2).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user3).fix().attempt().unsafeRunSync()) } } }</code> </pre> <br><pre> <code class="plaintext hljs">Right(b=[Task(value=LocalTask assigned to user1)]) Right(b=[Task(value=Remote Task assigned to user2)]) Left(a=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> <code>IO</code> ‚Äî  .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Either&lt;L,R&gt;</code></a> (   ).  , ""  <code>Either</code>    ,  ""    ,    .          <code>Right(...)</code> ,  ,  <code>Left(...)</code> . </p><br><p>      . </p><br><p> ,   .   ,         ,      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">       </a> . </p><br><h3 id="vsyo-eto-otlichno-zvuchitno-stoit-li-ono-togo">    ‚Ä¶     ? </h3><br><p>    ,    ,      .     . </p><br><ul><li><p>       : ,      (,  ),   ‚Äî .  ,     . </p><br></li><li><p>         ,    .         .        ()   (   )  ,   . </p><br></li><li><p>      (),   ,          ().         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> . </p><br></li><li><p>   ,         . ,            (      ). </p><br></li><li><p>       ,      API     .       (        <code>map</code> , <code>flatMap</code> , <code>fold</code> ,        ). ,     ,       Kotlin,  Arrow ‚Äî   . </p><br></li><li><p>          DI ( ), ..,    DI " ".         ,         ,              .        DI, ..,     ,        . </p><br></li><li><p>   ,     ,     .      , ..,    ,         . </p><br></li></ul><br><h3 id="dopolnitelno">  Optional </h3><br><p>       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> . <br>   ,         ,   ,      ,   . </p><br><p>   ,    .     ‚Äî   Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@JorgeCastilloPR</a> . </p><br><p>     (,  )    : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin Functional Programming: Does it make sense?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jorge Castillo</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin purity and Function Memoization</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jorge Castillo</a> </li></ul><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FP to the max</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">John De Goes</a>     <code>FpToTheMax.kt</code> ,    <code>arrow-examples</code> .          ,   ,          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447234/">https://habr.com/ru/post/de447234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447218/index.html">JPoint 2019 Parsing</a></li>
<li><a href="../de447220/index.html">Grundlagen der JavaScript-Engine: Allgemeine Formulare und Inline-Caching. Teil 2</a></li>
<li><a href="../de447222/index.html">Linux Quest. Herzlichen Gl√ºckwunsch an die Gewinner und sprechen Sie √ºber die L√∂sung von Problemen</a></li>
<li><a href="../de447226/index.html">Interview mit dem Popularisator der Wissenschaft, dem Leiter der einzigen privaten Schule f√ºr Astronomie in Russland, Pavel Skripnichenko</a></li>
<li><a href="../de447232/index.html">Pers√∂nliche Erfahrung. Wie wir internationale Telefonie verbunden haben: Vergleich von 6 virtuellen Vermittlungsstellen</a></li>
<li><a href="../de447236/index.html">Erstellen einer Android-Ger√§tefarm mit Open STF</a></li>
<li><a href="../de447240/index.html">Lernen Sie kontroverse Taktiken, Techniken und allgemeines Wissen (ATT @ CK). Unternehmenstaktik. Teil 10</a></li>
<li><a href="../de447242/index.html">Jenkins SQL Server-Automatisierung: Das Ergebnis wird wundersch√∂n zur√ºckgegeben</a></li>
<li><a href="../de447244/index.html">C301 und miniOTP-3, neue programmierbare Token von Token2</a></li>
<li><a href="../de447246/index.html">Prototyp in 1 Tag statt 2-3 Wochen: 3D-Druck im Okeanpribor-Konzern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>