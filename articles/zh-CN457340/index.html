<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏾 👨‍🎓 👼🏻 10个PostCSS插件，可节省您的布局时间 👏🏽 🚮 🚹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们（前端）拥有一类工具，它们不能解决我们面临的问题，而是会影响解决问题的过程。 改变它。 此类工具的态度大相径庭-从“让我们随处推这东西，这太酷了”的精神开始疯狂，以“如果不能解决业务问题，那么我们就不需要它”这样的借口结束。 但是，无论如何，今天我们将讨论PostCSS-其中一种工具。 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10个PostCSS插件，可节省您的布局时间</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457340/"><p><img src="https://habrastorage.org/webt/1b/7_/el/1b7_elrk3cworvip4qutltld9to.jpeg"></p><br><p> 我们（前端）拥有一类工具，它们不能解决我们面临的问题，而是会影响解决问题的过程。 改变它。 此类工具的态度大相径庭-从“让我们随处推这东西，这太酷了”的精神开始疯狂，以“如果不能解决业务问题，那么我们就不需要它”这样的借口结束。 但是，无论如何，今天我们将讨论PostCSS-其中一种工具。 </p><br><p> 炒作浪潮早已过去；近年来，关于PostCSS的评论很少。 许多初学者甚至都不知道它是什么。 我认为是时候从最普通的项目中实际使用的角度来看这个工具了，在这个项目中人们解决问题，而不是玩时髦的技术。 </p><a name="habracut"></a><br><h2 id="postcss-vs-sass">  PostCSS与SASS </h2><br><p>哦。。。关于这个显然。 我认为现在很少有排字工人没有遇到预处理器。  SASS或我最喜欢的LESS（不太常用的Stylus）用于大型项目和小型项目。 有人试图从中榨取最多的钱，有人使用了简约集-嵌套，变量，导入。 但是，无论哪种方式，这些工具都可以解决语法问题。 它们使我们更轻松地编写代码。 </p><br><p> 大约两三年前，PostCSS就一直与预处理器进行比较。 这是可以理解的。 正式地，使用它您可以做同样的事情，做出某种比纯CSS更方便的语法。 但是所有这些都引起了沸腾的群众，主要是因为每个人在PostCSS的帮助下都做了不同的事情。 无数未知的插件，数百万个组合，除了这个或那个配置的作者之外，没有人了解它的工作原理和作用。 就像Vim或Emacs一样-您可以用它们制成一艘太空飞船，但是要教其他开发人员如何使用它将非常困难。 </p><br><p> 但是，如果我们放弃这些比较，那么PostCSS是一个工具，它使我们能够获取CSS并对其进行处理。 没有人会为了语法而使用SASS，并且在汇编之后，粘贴PostCSS并对结果做些事情。 他们彼此不矛盾。 </p><br><h2 id="staroe--ne-znachit-nerabotayuschee"> 老不代表闲着 </h2><br><p> 最近，对于我们来说，创建可以完成仅想到的所有事情的联合收割机已经成为时尚，并且它们的发展永无止境。 而且，如果存储库在几个月内没有新的提交，那么所有内容-我们可以假定它已经过时并现在使用它-不必担心。 当然，我会夸大其词，但我想您自己已经注意到有时这种荒谬的想法。 </p><br><p> 在PostCSS世界中，通常一个插件可以解决一个问题。 您可以在这里看到Unix哲学的元素。 由此可以得出一个合理的结论-如果插件已经在解决其任务，则无需再执行任何操作。 您可以找到多年未更新的插件，但这并不意味着它们突然停止解决为其创建的任务。 </p><br><p> 但是，让我们开始吧……我整理了十二个插件，这些插件在实践中显示了它们能够简化版图设计师的工作并节省开发时间的能力。 但是您始终可以在评论中添加一些内容。 </p><br><h2 id="1-doiuse">  1号 杜伊斯 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/anandthakker/doiuse</a> </p><br><p> 我认为我们所有人都面临这个问题：您编写代码，签入chrome-一切正常。 您签入FF-大约。 然后在移动Safari中一切都崩溃了。 或在Edge中。 而你坐着，不明白什么是错的。 然后您凝视了很长时间的代码，喝了茶，突然间发现一种洞察力：某些浏览器不支持某些属性。 您继续<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前进</a> ，看到明显的确认。 </p><br><p><img src="https://habrastorage.org/webt/pm/dy/lw/pmdylwl6g5ahftjlsoikrqyckec.png"></p><br><p> 当然，凭经验，指针本身会记住应避免的属性，但是会发生任何事情。 您无法获得充足的睡眠，可能会有紧迫的期限和紧张的情绪，需要更改的浏览器列表可能会发生变化。 然后经验将开始失败。 在这种情况下，Doiuse可以提供很大帮助。 </p><br><p> 操作原理很简单-我们向他提供了一系列浏览器和CSS。 该插件会进入caniuse数据库，并实时为我们提供不受支持的答案。 </p><br><p> 我们可以直接在package.json中设置浏览器列表。 简单方便。  PostCSS使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器列表</a> ，如果您以前从未看过它，则它看起来像这样： </p><br><pre><code class="plaintext hljs">"browserslist": [ "&gt; .5% and last 2 versions", "not dead", "not OperaMini all", "ie &gt;= 11", "Edge &gt;= 12" ]</code> </pre> <br><p> 还有一个doiuse本身的配置，如果您确定它不会影响任何属性，则可以强制其中忽略某些属性组。 例如，如果您使用多文件或由于失去某些属性的支持，则什么都不会改变： </p><br><pre> <code class="plaintext hljs">ignore: [ 'will-change', 'object-fit' ]</code> </pre> <br><p> 插件提供的标准日志不是很可读。 它包含很多信息，并且感知起来不是很方便。 但这是可以解决的。 在相同的配置中，我们可以执行创建日志的功能。 </p><br><blockquote> 使用console.log找出将PostCSS传递给此函数的对象如何工作。 有很多有趣的事情。 </blockquote><p> 我的实践表明，最方便的选项是显示不支持的选择器和特定属性，而不指定浏览器和代码行。 如果项目使用BEM或某些类似物，并且组件代码分布在单独的文件中，则此方法可让您快速找到问题所在而无需费力。 </p><br><pre> <code class="javascript hljs">onFeatureUsage(info) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = info.usage.parent.selector; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.prop}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.value}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status = info.featureData.caniuseData.status.toUpperCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.missing) { status = <span class="hljs-string"><span class="hljs-string">'NOT SUPPORTED'</span></span>.red; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.partial) { status = <span class="hljs-string"><span class="hljs-string">'PARTIAL SUPPORT'</span></span>.yellow; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${status}</span></span></span><span class="hljs-string">:\n\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selector}</span></span></span><span class="hljs-string"> {\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property}</span></span></span><span class="hljs-string">;\n }\n`</span></span>); }</code> </pre> <br><p> 为了不在控制台中为颜色写特殊的字符序列，可以连接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">颜色</a>包，这样会更加方便。 </p><br><p> 构建时，控制台中将出现以下内容： </p><br><pre> <code class="plaintext hljs">NOT SUPPORTED: html { -ms-text-size-adjust: 100%; } NOT SUPPORTED: html { -webkit-text-size-adjust: 100%; } PARTIAL SUPPORT: body { display: flex; }</code> </pre> <br><h2 id="2-autoprefixer">  2号 自动前缀 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/postcss/autoprefixer</a> </p><br><p> 谈论他甚至令人尴尬，但我经常看到有人在2019年用双手写前缀，并向其他人保证他们确切知道哪些是不需要的。 这样的行为导致这样的事实，即代码中堆满了一堆不必要的前缀，变得完全不可读。 这影响劳动生产率。 另一方面，如果您需要恐龙的支持，则总是可以忘记某些事情。 因此，解决此问题时值得摆脱体力劳动。 </p><br><p> 自动前缀与相同的caniuse数据库一起使用，使用相同的浏览器列表，并且可以将我们指定的浏览器中真正需要的前缀添加到CSS中。 同时，代码本身变得更整洁，工作速度更快。 </p><br><h2 id="3-stylelint">  3号  Stylelint </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/stylelint/stylelint</a> </p><br><p> 当您进行大量且快速的打印时，迟早会开始犯下很多错误而没有完全注意到它们。 眼睛模糊。 在CSS的情况下，当您在浏览器中查看时，这可能会产生有趣的（实际上不是）效果-您会看到布局问题。 您看一下代码-它不存在。 您在浏览器中查看-是的。 但是在代码中-不。 结果，您可以长时间搜索一个难题，而完全不会注意到您只是想办法。 为了防止这种情况，发明了短绒。 </p><br><p>  Stylelint是一个受欢迎的选择。 他知道如何使用主要预处理器的语法，了解CSS的最新趋势，可以根据自己的喜好对其进行自定义-配置类似于eslint。 从形式上讲，无需PostCSS即可单独使用此工具，但在此不提它是错误的。 </p><br><h2 id="4-postcss-flexbugs-fixes">  4号  Postcss-Flexbugs-修复 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/luisrudge/postcss-flexbugs-fixes</a> </p><br><p> 从广义上讲， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">postcss-fixes</a>包括此插件。 但可以肯定的是，挠曲慢慢地取代了过去的浮法布局方法。 很好，但是我们都知道与它们相关的错误很多。 它们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">flexbugs</a>存储库中进行了描述。 其中一些需要特别注意，但也有一些非常简单，以至于它们不断从你的脑袋飞出。 例如，IE忽略了flex属性的简写形式的calc函数。 这不是经常需要的，但是如果需要的话，您的双手可以写一个简短的版本，然后您必须长时间考虑问题是什么。 幸运的是，这可以自动修复。  postcss-flexbugs-fixes插件可以解决。 </p><br><p> 在calc示例中，它将在代码中找到如下片段： </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw – 1px); }</code> </pre> <br><p> 并部署它们： </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw - 1px); }</code> </pre> <br><p> 简单方便。 </p><br><h2 id="5-postcss-preset-env">  5号  Postcss预设环境 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/csstools/postcss-preset-env</a> </p><br><p> 既然我们在谈论浏览器支持，那么谈论postcss-preset-env并不会显得不合适。 以前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cssnext</a>扮演相同的角色。 如果您对CSS的新趋势感兴趣，那么此插件将非常有用。 </p><br><p><img src="https://habrastorage.org/webt/bu/kp/4h/bukp4htn6ewwkk4qznb8phjxzoa.jpeg"></p><br><p> 从技术上讲，许多创新都可以使用旧方法来实施，但时间长，冗长且丑陋。  Preset-env帮助您以新的方式编写代码，节省时间，然后将其转换为可靠的旧版本。 当然，某些属性（如自定义属性）在旧版浏览器中根本无法实现，因此将在此处使用后备功能。 </p><br><p> 您可以从乐器的名称中猜出它类似于Babel预设的名称。 在这里，一切都是一样的-许多转换器组装成一个稳定的集合。 某些转换需要在客户端上随后连接多语言脚本，但是大多数转换完全由CSS实现。 据我了解，对于Stage2 +脚本是不需要的。 无论如何，我没有遇到他们的需要。 如果我错过了那里的东西，请纠正我。 </p><br><h2 id="6-postcss-animation">  6号 后动画 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/zhouwenbin/postcss-animation</a> </p><br><p> 我经常听到不同的人（大多数是CSS不太强的后端）听到他们想使用与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">animate.css</a>不同的动画，但是认为连接整个库是一个坏主意。 这是很合逻辑的。 但是结果，他们花了很多时间试图自己重复这些动画。 </p><br><p><img src="https://habrastorage.org/webt/hy/tw/wp/hytwwpkrfzjzsktmomybo51bea0.jpeg"></p><br><p>  postcss-animation插件大大加快了此过程。 我们只写动画的名称，例如： </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; }</code> </pre> <br><p> 然后他从animate.css中提取实现，并将其插入代码中。 </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> bounce { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span>, 20%, 53%, 80%, <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.215, 0.610, 0.355, 1.000); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,0,0); } 40%, 43% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -30px, 0); } 70% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -15px, 0); } 90% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,-4px,0); } }</code> </pre> <br><h2 id="7-list-selectors">  7号 列表选择器 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/davidtheclark/list-selectors</a> </p><br><p> 当您有多个排字机和多种样式时，就会出现代码审查的问题，有时您会目睹拥有我们所有选择器的全景图，这将是很好的选择。 知道使用了哪些ID，是否有标签选择器，或者遵循接受的方法的程度如何。 当您检查初学者的代码时，这一点尤其重要，该代码可以编写一些可以正常使用的奇怪内容，但实际上违反了公认的协议（这些协议在各个地方都固定得很好，并且有机会使这些事情自动化）。 自己滚动浏览多个样式表，以长时间检查选择器是否足够。 我们需要一种隔离它们并分别显示它们的方法。 列表选择器只是解决了这个问题。 </p><br><p> 就像doiuse一样，此插件可让您使用其功能来准备显示信息。 您可以只显示自己感兴趣的内容，也可以用不同的颜色绘制所有内容。 例如： </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'list-selectors'</span></span>).plugin(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inspect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>).inspect; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'SELECTORS:'</span></span>.blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.selectors, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'IDS:'</span></span>.red); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.simpleSelectors.ids, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).red); })</code> </pre> <br><p> 这个例子产生了很长的选择器列表： </p><br><pre> <code class="plaintext hljs">SELECTORS: [ '.mui-progress-bar', '.mui-progress-bar &gt; .indicator', '.mui-progress-bar &gt; .value', '.mui-progress-bar.-radial', '.mui-progress-bar.-radial &gt; .indicator', '.mui-progress-bar.-radial &gt; .indicator &gt; .background', '.mui-progress-bar.-radial &gt; .indicator &gt; .progress', '.mui-progress-bar.-radial &gt; .value', . . .</code> </pre> <br><h2 id="8-immutable-css">  8号 不可变的CSS </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/johno/immutable-css</a> </p><br><p> 要注意的另一件事是中断第三方库的样式。 如果我们连接了某种类型的库，然后开始从中为选择器编写我们自己的样式，那么最后，我们将得到令人困惑的代码，其中我们无法确定其来源。 这可能会导致随机的错误，这些错误然后会花费过多的时间。 尽管需要解决的问题本身可能非常简单，但我们重新定义某些事物的次数越多，最终了解所发生的事情就越困难。 在这种情况下，称为immutable-css的工具可能会派上用场。 </p><br><p> 通常，其工作原理很简单：它接收具有样式的文件，如果在选择器中找到匹配项，则会开始重新发送： </p><br><pre> <code class="plaintext hljs">! .button was mutated 2 times [line 93, col 1]: /css/basscss.css [line 3, col 1]: /css/custom.css [immutable-css] ! .left was mutated 2 times [line 291, col 1]: /css/basscss.css [line 4, col 1]: /css/custom.css [immutable-css]</code> </pre> <br><p> 该工具的唯一问题是它不支持非CSS语法。 因此，如果在项目中使用了预处理器，则必须比较已经汇编的文件。 但是总的来说，如果任务只是确保没有人意外地从第三方库重写样式，那么这并不是那么重要。 </p><br><h2 id="9-bye-bye">  9号 再见！ </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/AoDev/css-byebye</a> </p><br><p> 当我们逐步向工作站点中添加一些组件时，我认为每个人都熟悉这种情况。 他们中的一些人立即投入生产，其中一些人坐了很长时间，等待轮到他们（例如，我们组成了，我们还没有完成后端工作）。 可能是假期的实验或临时解决方案。 可能有很多情况，但由于我们拥有许多组件，因此只有一个很小的部分用于战斗现场，这使它们结合在一起。 最好从当前程序集中删除所有未使用的东西。 例如，当有必要进行重新设计时，这可以显着减小其大小，并减轻将来的麻烦，而问题是，现在真正需要重写的全部内容是什么，什么不需要重写。 </p><br><p><img src="https://habrastorage.org/webt/l5/rl/e5/l5rle5k5yldudgr5rvtz7hotjom.gif"></p><br><p> 有不同的方法来解决此问题。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Uncss</a>立即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浮现</a>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">脑海中</a> 。 该工具自动检测页面上使用了哪些样式，并删除了不必要的样式。 但是实际上，这几乎总是导致这样的事实，即没人知道实际使用的是什么，而不是实际使用的。 我也一直怀疑这个工具是否删除了多余的东西。 但这可能是我的偏执狂。 虽然... </p><br><p> 再见是一个更简单的工具，我们自己输入要从CSS中删除的选择器列表。 您可以使用正则表达式。 如果您使用BEM或类似的方法，则可以使用一个简单的常规删除包含与其相关的所有内容的块。 再见！ </p><br><p> 事实证明这种方法很方便。 可以立即清除哪些样式尚未使用或已被不必要地删除，在所有源均已就绪，所有设置在一个文件中，没有任何损失的情况下，它不会造成制作多个不同装配的麻烦，而且最重要的是，解决方案简单且可预测。 </p><br><h2 id="10-postcss-trolling">  10号 事后追踪 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/juanfran/postcss-trolling</a> </p><br><p> 以前的所有工具都可以稍微提高版图设计人员的工作效率，但是该工具仅给出了惊人的结果。 我强烈推荐它。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>  PostCSS对版面设计人员是一个很好的帮助。 当然，如果不滥用它们。 对于许多耗时的问题，有以插件形式存在的现成的解决方案，尽管它们通常不会开发并且似乎已被放弃，但这不会影响其使用。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457340/">https://habr.com/ru/post/zh-CN457340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457330/index.html">如何快速检查PVS-Studio分析仪针对C和C ++代码给出的有趣警告？</a></li>
<li><a href="../zh-CN457332/index.html">如何快速查看PVS-Studio分析器针对C和C ++代码生成的有趣警告？</a></li>
<li><a href="../zh-CN457334/index.html">TacacsGUI，配置管理器</a></li>
<li><a href="../zh-CN457336/index.html">不及时拔除智齿的后果</a></li>
<li><a href="../zh-CN457338/index.html">与伊利亚·克拉辛斯基（Ilya Krasinsky）的闪电战：如何提出错误的假设，为什么要撤消产品，以及如何以最少的行动实现增长？</a></li>
<li><a href="../zh-CN457342/index.html">上面的迹象：我们如何使制图师免于不必要的工作和红眼</a></li>
<li><a href="../zh-CN457348/index.html">从GitHub部署在PythonAnywhere上</a></li>
<li><a href="../zh-CN457350/index.html">为什么示波器需要加密支持？</a></li>
<li><a href="../zh-CN457352/index.html">买方展示信息的结论</a></li>
<li><a href="../zh-CN457354/index.html">性能测试的数据混淆</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>