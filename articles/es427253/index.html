<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏼 🙀 🚖 tipo de todo y malentendidos de pato 👩🏽‍🤝‍👩🏻 👩🏼‍🍳 🤷🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos los que usan JavaScript maravilloso para cualquier propósito se preguntaron: ¿por qué typeof es un "objeto" nulo ? typeof de una función devuelv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>tipo de todo y malentendidos de pato</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427253/"><p><img src="https://habrastorage.org/webt/w2/mj/_p/w2mj_pc_kr_unyrw31d2f27xdra.jpeg" alt="imagen"></p><br><p>  Todos los que usan <strong>JavaScript</strong> maravilloso para cualquier propósito se preguntaron: ¿por qué <em>typeof</em> es un <em>"objeto"</em> <em>nulo</em> ?  <em>typeof</em> de una función devuelve <em>"function"</em> , pero de <em>Array</em> - <em>"object"</em> ?  y donde <em>getClass</em> en tus clases alardeadas?  Y aunque en su mayor parte las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaciones</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los hechos históricos</a> responden de manera fácil y natural, me gustaría trazar un poco ... más para mí. </p><br><p> Si, lector, su tipo y su <em>instancia</em> no son suficientes para usted en sus tareas, y desea algunos detalles, en lugar de <em>"objetos"</em> , entonces puede ser útil más adelante.  Ah, sí, sobre los patos: ellos también lo estarán, solo un poco equivocados. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-voprosa">  Breve antecedentes </h2><br><p>  Obtener el tipo de variable de manera confiable en JavaScript siempre ha sido una tarea no trivial, ciertamente no para un principiante.  En la mayoría de los casos, por supuesto, no es obligatorio, solo: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; value !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// awesome code around the object }</span></span></code> </pre> <br><p>  y ahora no <code>Cannot read property of null</code> captar <code>Cannot read property of null</code> , un análogo local de NPE.  ¿Eso es familiar? </p><br><p>  Y luego comenzamos a usar funciones como constructores cada vez más a menudo, y a veces es útil inspeccionar el tipo de objeto creado de esta manera.  Pero simplemente usar <em>typeof</em> de la instancia no funcionará, ya que obtenemos el <em>"objeto"</em> correctamente. </p><br><p>  Entonces todavía era normal usar un prototipo de modelo OOP en JavaScript, ¿recuerdas?  Tenemos algún objeto, y a través del enlace a su prototipo podemos encontrar la propiedad del <em>constructor</em> que apunta a la función con la que se creó el objeto.  Y luego un poco de magia con <em>toString</em> de la función y las expresiones regulares, y aquí está el resultado: </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  A veces hacían esas preguntas en las entrevistas, pero ¿por qué? </p><br><p>  Sí, podríamos guardar una representación de cadena del tipo como una propiedad especial y obtenerla del objeto a través de la cadena de prototipo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; Type.prototype.typeName = <span class="hljs-string"><span class="hljs-string">'Type'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type; o.typeName; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Type</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Solo dos veces tiene que escribir <em>"Tipo"</em> : en la declaración de función y en la propiedad. </p><br><p>  Para los objetos integrados (como <em>Array</em> o <em>Date</em> ) teníamos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedad secreta</a> <em>[[Class]]</em> , que se podía conectar a <em>toString</em> desde el <em>objeto</em> estándar: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">object</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Array</span></span></span></span><span class="xml"><span class="hljs-tag">]"</span></span></span></span></code> </pre> <br><p>  Ahora tenemos clases, y los tipos personalizados finalmente se arreglan en el lenguaje: este no es un LiveScript para usted;  ¡Escribimos código compatible en grandes cantidades! </p><br><p>  Casi al mismo tiempo, <em>aparecieron Symbol.toStringTag</em> y <em>Function.name</em> , con lo que podemos tomar nuestro <em>typeof</em> de una nueva manera. </p><br><p>  En general, antes de continuar, quiero señalar que el problema en consideración evoluciona en StackOverflow junto con el lenguaje y sube de editor a editor: hace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9 años</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hace</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7 años</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no hace tanto tiempo,</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es esto</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquello</a> . </p><br><h2 id="tekuschee-polozhenie-del">  Estado actual de las cosas </h2><br><p>  Anteriormente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya examinamos con</a> suficiente detalle <em>Symbol.toStringTag</em> y <em>Function.name</em> .  En resumen, el carácter interno de <em>toStringTag</em> es moderno <em>[[Clase]]</em> , solo que podemos redefinirlo para nuestros objetos.  Y la propiedad <em>Function.name</em> está legalizada en casi todos los navegadores con el mismo <em>typeName</em> del ejemplo: devuelve el nombre de la función. </p><br><p>  Sin dudarlo, puede definir dicha función: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; any !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> any[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any.constructor === <span class="hljs-string"><span class="hljs-string">'function'</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any.constructor.name === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> any.constructor.name; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(any).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><ol><li>  SI la variable es un objeto, entonces: <br>  1.1.  SI el objeto se reemplaza por <em>StringTag</em> , devuélvalo; <br>  1.2.  SI la función <em>constructora</em> es conocida para el objeto y la función tiene una propiedad de <em>nombre</em> , devuélvala; </li><li>  FINALMENTE DE OTRA MANERA use el método <em>toString</em> del <em>objeto Object</em> , que hará <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">todo el trabajo polimórfico</a> por nosotros para absolutamente cualquier otra variable. </li></ol><br><p>  Objeto con <em>toStringTag</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> kitten = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]: <span class="hljs-string"><span class="hljs-string">'Kitten'</span></span> }; getTag(kitten); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Kitten</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Clase con <em>toStringTag</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Kitten'</span></span>; } } getTag(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Kitten</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Usando <em>constructor.name</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{} getTag(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Dog</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  → Se pueden encontrar más ejemplos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este repositorio.</a> </p><br><p>  Por lo tanto, ahora es bastante fácil determinar el tipo de cualquier variable en JavaScript.  Esta función le permite verificar uniformemente las variables para el tipo y usar una <em>expresión de</em> cambio simple en lugar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">verificaciones</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pato</a> en funciones polimórficas.  En general, nunca me gustó el enfoque basado en la escritura de patos, dicen que si algo tiene la propiedad de <em>empalme</em> , ¿es una matriz o algo así? </p><br><h2 id="kakie-to-nepravilnye-utki">  Algunos patos equivocados </h2><br><p>  Entender el tipo de una variable por la presencia de ciertos métodos o propiedades es, por supuesto, asunto de todos y depende de la situación.  Pero tomaré este <em>getTag</em> e inspeccionaré algunas cosas del lenguaje. </p><br><h3 id="klassy">  Clases? </h3><br><p>  Mi "pato" favorito en JavaScript son las clases.  Los chicos que comenzaron a escribir JavaScript con ES-2015, a veces no sospechan cuáles son estas clases.  Y la verdad es: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } hello() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">'John'</span></span>); user.hello(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">John</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Tenemos una palabra clave de <em>clase</em> , un constructor, algunos métodos, incluso se <em>extiende</em> .  También creamos una instancia de esta clase a través de <em>new</em> .  Parece una clase en su sentido habitual, ¡significa una clase! </p><br><p>  Sin embargo, cuando comienza a agregar nuevos métodos en <em>tiempo real</em> a la "clase", y al mismo tiempo están disponibles de inmediato para las instancias ya creadas, algunas se pierden: </p><br><pre> <code class="javascript hljs">Person.prototype.hello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Is not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span>; } user.hello(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">not</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">John</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  <strong>¡No hagas esto!</strong> </p><br><p>  Y no algunos saben de manera confiable que esto es solo azúcar sintáctico sobre el modelo prototipo, porque conceptualmente nada ha cambiado en el lenguaje.  Si llamamos a <em>getTag</em> desde <em>Persona</em> , obtenemos <em>"Función"</em> , no la <em>"Clase"</em> inventada, y vale la pena recordarlo. </p><br><h3 id="drugie-funkcii">  Otras funciones </h3><br><p>  Hay varias formas de declarar una función en JavaScript: <em>FunctionDeclaration</em> , <em>FunctionExpression</em> y recientemente <em>ArrowFunction</em> .  Todos sabemos cuándo y qué usar: las cosas son bastante diferentes.  Además, si llamamos a <em>getTag</em> desde la función declarada por cualquiera de las opciones propuestas, obtenemos <em>"Función"</em> . </p><br><p>  De hecho, el lenguaje tiene muchas más formas de definir una función.  <em>Agregamos</em> a la lista al menos la <em>ClassDeclaration</em> considerada, luego las funciones y generadores asíncronos, etc.: <em>AsyncFunctionDeclaration</em> , <em>AsyncFunctionExpression</em> , <em>AsyncArrowFunction</em> , <em>GeneratorDeclaration</em> , <em>GeneratorExpression</em> , <em>ClassExpression</em> , <em>MethodDefinition</em> (la lista no está completa).  Y parece que dicen ¿y qué?  todo lo anterior se comporta como una función, lo que significa que <em>getTag</em> también devolverá <em>"Función"</em> .  Pero hay una característica: todas las opciones son ciertamente funciones, pero no todas directamente: <em>Función</em> . </p><br><p>  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subtipos de</a> <em>función</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">incorporados</a> : </p><br><blockquote>  El constructor de funciones está diseñado para ser subclase. <br>  No hay medios sintácticos para crear instancias de subclases de funciones, excepto las subclases GeneratorFunction y AsyncFunction incorporadas. </blockquote><p>  Tenemos <em>Function</em> y dentro de <em>GeneratorFunction</em> y <em>AsyncFunction</em> con sus constructores "heredados" de él.  Esto enfatiza que los enlaces y los generadores tienen su propia naturaleza única.  Y como resultado: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(resolve, ms)); } getTag(sleep); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">AsyncFunction</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Al mismo tiempo, no podemos crear una instancia de dicha función a través del <em>nuevo</em> operador, y su llamada nos devuelve la <em>promesa</em> : </p><br><pre> <code class="javascript hljs">getTag(sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Promise</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Un ejemplo con una función generadora: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i += <span class="hljs-number"><span class="hljs-number">1</span></span>; } getTag(incg); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">GeneratorFunction</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Llamar a tal función devuelve una instancia: el objeto <em>Generador</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inc = incg(<span class="hljs-number"><span class="hljs-number">0</span></span>); getTag(inc); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Generator</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  El símbolo <em>toStringTag</em> está bastante redefinido para enlaces y generadores.  Pero <em>typeof</em> para cualquier función mostrará <em>"function"</em> . </p><br><h3 id="vstroennye-obekty">  Objetos en línea </h3><br><p>  Tenemos cosas como <em>Establecer</em> , <em>Mapa</em> , <em>Fecha</em> o <em>Error</em> .  La aplicación de <em>getTag</em> a ellos devolverá <em>"Función"</em> , porque estas son las funciones: constructores de colecciones iterables, fechas y errores.  De las instancias que obtenemos respectivamente: <em>"Establecer"</em> , <em>"Mapa"</em> , <em>"Fecha"</em> y " <em>Error</em> ". </p><br><p>  Pero ten cuidado!  Todavía hay objetos como <em>JSON</em> o <em>Math</em> .  Si te das prisa, puedes asumir una situación similar.  Pero no!  Esto es completamente diferente: objetos individuales integrados.  No son instanciables ( <code>is not a constructor</code> ).  Una llamada <em>typeof</em> devolverá <em>"objeto"</em> (quién lo dudaría).  Pero <em>getTag</em> recurrirá a <em>toStringTag</em> y obtendrá <em>"JSON"</em> y <em>"Math"</em> .  Esta es la última observación que quiero compartir. </p><br><h2 id="davayte-bez-fanatizma">  Vamos sin fanatismo </h2><br><p>  Recientemente pregunté un poco más de lo habitual sobre el tipo de variable en JavaScript cuando decidí escribir mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">simple inspector de objetos</a> para el análisis de código dinámico (jugar).  El material no solo se publica en la <em>programación Anormal</em> , ya que no lo necesita en producción: hay <em>typeof</em> , <em>instanceof</em> , <em>Array.isArray</em> , <em>isNaN</em> y todo lo demás que vale la pena recordar al realizar la verificación necesaria.  La mayoría de los proyectos tienen TypeScript, Dart o Flow.  ¡Me encanta <strong>JavaScript</strong> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427253/">https://habr.com/ru/post/es427253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427243/index.html">Vea la luz: nuestro llamado a un protocolo estandarizado para la mensajería entre robomobiles</a></li>
<li><a href="../es427245/index.html">Gestión de correo de voz grupal y grabación de llamadas en PBX 3CX</a></li>
<li><a href="../es427247/index.html">Aplicación web con IoC Starter. Asignación básica de consultas con el contexto ioc, ioc web y ioc orm</a></li>
<li><a href="../es427249/index.html">Según la estructura del material del artículo impreso, puede determinar el modelo de una impresora 3D y un dispositivo específico</a></li>
<li><a href="../es427251/index.html">El Departamento de Seguridad Nacional de los EE. UU. Confisca las baterías restauradas para las computadoras portátiles Apple y las califica</a></li>
<li><a href="../es427255/index.html">Cowon D2: Musical Long-Liver</a></li>
<li><a href="../es427257/index.html">Cameron Craig: Siete lecciones aprendidas de 10 años de gestión de relaciones públicas de Apple</a></li>
<li><a href="../es427259/index.html">Lo que realmente comprueba la prueba de Turing</a></li>
<li><a href="../es427263/index.html">Sé un ninja de seguridad: grabación de seminarios web y nivel de bonificación</a></li>
<li><a href="../es427265/index.html">Protobuffers están equivocados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>