<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶 🕧 👨‍👨‍👦‍👦 Microservices on Go مع مجموعة Go: مقدمة 👩🏿‍🌾 🏠 🛌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في هذه المقالة سأصف استخدام مجموعة أدوات Go ، وهي مجموعة من الأدوات والمكتبات لإنشاء خدمات صغيرة على Go. هذه المقالة مقدمة لمجموعة أدوات Go. الجزء الأ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microservices on Go مع مجموعة Go: مقدمة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430300/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  في هذه المقالة سأصف استخدام مجموعة أدوات Go ، وهي مجموعة من الأدوات والمكتبات لإنشاء خدمات صغيرة على Go.  هذه المقالة مقدمة لمجموعة أدوات Go.  الجزء الأول في مدونتي ، كود المصدر للأمثلة متاح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> . </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl"> يتم اختيار Go بشكل متزايد لتطوير الأنظمة الموزعة الحديثة.  عندما تقوم بتطوير نظام موزع على السحابة ، قد تحتاج إلى دعم وظائف محددة متنوعة في خدماتك ، مثل: بروتوكولات النقل المختلفة ( <em>إلخ ، HTTP ، gRPC ، إلخ</em> ) وتنسيقات ترميز الرسائل لها ، وموثوقية RPC ، وتسجيل ، التتبع ، المقاييس والتنميط ، مقاطعة الطلبات ، تحديد عدد الطلبات ، الاندماج في البنية التحتية ، وحتى وصف البنية.  Go هي لغة شائعة بسبب بساطتها ونهجها "لا سحر" ، وبالتالي فإن حزم Go ، على سبيل المثال ، مكتبة قياسية ، هي بالفعل أكثر ملاءمة لتطوير أنظمة موزعة من استخدام إطار كامل مع الكثير من "السحر تحت غطاء المحرك".  أنا شخصياً [ <em>تقريبًا.</em>  <em>عبر.</em>  <em>Shiju Varghese</em> ] أنا لا أؤيد استخدام أطر العمل الكاملة ، أفضل استخدام المكتبات التي تمنح المزيد من الحرية للمطور.  ملأت مجموعة Go الفجوة في النظام البيئي Go ، مما يجعل من الممكن استخدام مجموعة من المكتبات والحزم عند إنشاء الخدمات الدقيقة ، والتي بدورها تسمح باستخدام المبادئ الجيدة لتصميم الخدمات الفردية في الأنظمة الموزعة. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="الصورة"></p><br><h3 id="vvedenie-v-go-kit" style=";text-align:right;direction:rtl">  مقدمة لمجموعة أدوات Go </h3><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Go kit</a> عبارة عن مجموعة من حزم Go التي تجعل من السهل إنشاء خدمات دقيقة موثوقة ومدعومة.  توفر Go kit مكتبات لتنفيذ مكونات متنوعة من بنية تطبيق شفافة وموثوقة ، باستخدام طبقات مثل: تسجيل الدخول ، والمقاييس ، والتتبع ، والحد من طلبات المقاطعة الضرورية لتشغيل الخدمات الصغيرة على المنتج.  مجموعة أدوات Go جيدة لأنها تحتوي على أدوات جيدة التنفيذ للتفاعل مع مختلف البنى التحتية وتنسيقات ترميز الرسائل وطبقات النقل المختلفة. </p><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى مجموعة المكتبات لخدمات العالم النامي ، فإنه يوفر ويشجع على استخدام المبادئ الجيدة لتصميم بنية خدماتك.  تساعدك مجموعة أدوات Go على الالتزام بمبادئ SOLID ، والنهج الموجه نحو الموضوع (DDD) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">والعمارة السداسية</a> التي اقترحها <em>أليستير كوكبيرن</em> أو أي نهج آخر من المبادئ المعمارية المعروفة باسم " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هندسة البصل</a> " من قبل <em>جيفري باليرمو</em> و " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">العمارة النظيفة</a> " من قبل <em>روبرت سي مارتن</em> .  على الرغم من أن مجموعة Go تم تصميمها كمجموعة من الحزم لتطوير الخدمات الدقيقة ، إلا أنها مناسبة أيضًا لتطوير متجانسة أنيقة. </p><br><h3 id="arhitektura-go-kit" style=";text-align:right;direction:rtl">  مجموعة Go Architecture </h3><br><p style=";text-align:right;direction:rtl">  المستويات الرئيسية الثلاثة في بنية التطبيقات التي تم تطويرها باستخدام مجموعة أدوات Go هي: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  مستوى النقل </li><li style=";text-align:right;direction:rtl">  مستوى نقطة النهاية </li><li style=";text-align:right;direction:rtl">  مستوى الخدمة </li></ul><br><h4 id="transportnyy-uroven" style=";text-align:right;direction:rtl">  مستوى النقل </h4><br><p style=";text-align:right;direction:rtl">  عندما تكتب خدمات صغيرة للأنظمة الموزعة ، غالبًا ما يتعين على الخدمات فيها التواصل مع بعضها البعض باستخدام بروتوكولات النقل المختلفة ، مثل: HTTP أو gRPC ، أو استخدام أنظمة النشر / الفرعية ، مثل NATS.  ترتبط طبقة النقل في مجموعة Go ببروتوكول نقل محدد (يشار إليه فيما بعد بالنقل).  تدعم مجموعة أدوات النقل وسائل النقل المختلفة لخدمتك ، مثل: HTTP و gRPC و NATS و AMQP و Thirft ( <em>تقريبًا. يمكنك أيضًا تطوير وسيلة النقل الخاصة بك لبروتوكولك</em> ).  لذلك ، غالبًا ما تركز الخدمات المكتوبة باستخدام مجموعة Go على تنفيذ منطق عمل محدد لا يعرف أي شيء عن النقل المستخدم ، ولديك مطلق الحرية في استخدام وسائل نقل مختلفة لنفس الخدمة.  كمثال ، يمكن لخدمة واحدة مكتوبة في مجموعة Go توفير الوصول إليها في وقت واحد عبر HTTP و gRPC. </p><br><h4 id="endpointy" style=";text-align:right;direction:rtl">  نقاط النهاية </h4><br><p style=";text-align:right;direction:rtl">  نقطة النهاية أو نقطة النهاية هي لبنة البناء الأساسية للخدمات والعملاء.  في مجموعة أدوات Go ، يكون نمط الاتصال الرئيسي هو RPC.  يتم تقديم نقطة النهاية كطريقة RPC منفصلة.  يتم تحويل كل طريقة خدمة في مجموعة Go إلى نقطة نهاية ، مما يتيح لك التواصل بين الخادم والعميل بأسلوب RCP.  تكشف كل نقطة نهاية طريقة خدمة باستخدام طبقة النقل ، والتي بدورها تستخدم بروتوكولات نقل مختلفة ، مثل HTTP أو gRPC.  يمكن كشف نقطة نهاية منفصلة خارج الخدمة في وقت واحد باستخدام العديد من وسائل النقل ( <em>تقريبًا لكل HTTP و gRPC على منافذ مختلفة</em> ). </p><br><h4 id="servisy" style=";text-align:right;direction:rtl">  الخدمات </h4><br><p style=";text-align:right;direction:rtl">  يتم تنفيذ منطق الأعمال في طبقة الخدمة.  تم تصميم الخدمات المكتوبة باستخدام مجموعة Go كواجهات.  يحتوي منطق الأعمال في طبقة الخدمة على جوهر منطق الأعمال الأساسي ، والذي لا يحتاج إلى معرفة أي شيء عن نقاط النهاية المستخدمة أو بروتوكول نقل محدد ، مثل HTTP أو gRPC ، أو حول طلبات الترميز أو فك الترميز والردود على أنواع مختلفة من الرسائل.  سيسمح لك ذلك بالالتزام بهندسة نظيفة في الخدمات المكتوبة باستخدام مجموعة Go.  يتم تحويل كل طريقة خدمة إلى نقطة نهاية باستخدام محول وتعريضها للخارج باستخدام وسيلة نقل معينة.  من خلال استخدام العمارة النظيفة ، يمكن تعيين طريقة واحدة باستخدام وسائل نقل متعددة في نفس الوقت. </p><br><h3 id="primery" style=";text-align:right;direction:rtl">  أمثلة </h3><br><p style=";text-align:right;direction:rtl">  والآن دعونا نلقي نظرة على الطبقات الموضحة أعلاه باستخدام مثال لتطبيق بسيط. </p><br><h4 id="biznes-logika-v-servise" style=";text-align:right;direction:rtl">  منطق الأعمال في الخدمة </h4><br><p style=";text-align:right;direction:rtl">  تم تصميم منطق الأعمال في الخدمة باستخدام الواجهات.  سنلقي نظرة على مثال لأمر في التجارة الإلكترونية: </p><br><pre style=";text-align:right;direction:rtl"><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  تعمل واجهة خدمة الطلب مع كيان مجال الطلب: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا نقوم بتنفيذ واجهة خدمة الطلب: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov" style=";text-align:right;direction:rtl">  طلبات وإجابات نقاط نهاية RPC </h4><br><p style=";text-align:right;direction:rtl">  يتم كشف طرق الخدمة كنقاط نهاية RPC.  لذلك نحن بحاجة إلى تحديد أنواع الرسائل ( <em>تقريبًا لكل DTO - كائن نقل البيانات</em> ) التي سيتم استخدامها لإرسال واستقبال الرسائل من خلال نقاط نهاية RPC.  دعنا الآن نحدد الهياكل لأنواع الطلبات والاستجابات لنقاط نهاية RPC في خدمة الطلب: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy" style=";text-align:right;direction:rtl">  نقاط نهاية مجموعة أدوات النقل لطرق الخدمة مثل نقاط نهاية RPC </h4><br><p style=";text-align:right;direction:rtl">  يتم فصل جوهر منطق أعمالنا عن باقي الكود ووضعه في طبقة الخدمة ، التي يتم كشفها باستخدام نقاط نهاية RPC ، والتي تستخدم تجريد مجموعة Go يسمى <code>Endpoint</code> . </p><br><p style=";text-align:right;direction:rtl">  هذا ما تبدو عليه نقطة النهاية من مجموعة Go: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  كما قلنا أعلاه ، تمثل نقطة النهاية طريقة RPC منفصلة.  يتم تحويل كل طريقة خدمة إلى <code>endpoint.Endpoint</code> .  دعونا نجعل نقاط نهاية أدوات Go لأساليب خدمة الطلب: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يقبل محول نقطة النهاية الواجهة كوسيطة للمدخلات ويحولها إلى تجريد <code>endpoint.Enpoint</code> مجموعة أدوات Go. يشير إلى جعل كل طريقة خدمة فردية نقطة نهاية.  تقوم وظيفة المحول هذه بإجراء مقارنة ونوع التحويلات للطلبات ، واستدعاء طريقة الخدمة وإرجاع رسالة استجابة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http" style=";text-align:right;direction:rtl">  فضح الخدمة باستخدام HTTP </h4><br><p style=";text-align:right;direction:rtl">  أنشأنا خدمتنا ووصفنا نقاط نهاية RPC لكشف طرق خدمتنا.  نحتاج الآن إلى نشر خدمتنا في الخارج حتى تتمكن الخدمات الأخرى من استدعاء نقاط نهاية RCP.  لفضح خدمتنا ، نحتاج إلى تحديد بروتوكول النقل لخدمتنا ، والذي بموجبه سيقبل الطلبات.  مجموعة أدوات Go تدعم عمليات النقل المختلفة ، مثل HTTP و gRPC و NATS و AMQP و Thrift خارج الصندوق. </p><br><p style=";text-align:right;direction:rtl">  على سبيل المثال ، نستخدم نقل HTTP لخدمتنا.  توفر حزمة go go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=http://github.com/go-kit/kit/transport/">github.com/go-kit/kit/transport/http</a> القدرة على خدمة طلبات HTTP.  <code>NewServer</code> وظيفة <code>NewServer</code> من حزمة <code>transport/http</code> إنشاء خادم http جديد يقوم بتطبيق <code>http.Handler</code> ويلف نقاط النهاية المقدمة. </p><br><p style=";text-align:right;direction:rtl">  فيما يلي الكود الذي يحول نقاط نهاية مجموعة أدوات Go إلى نقل HTTP يخدم طلبات HTTP: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  نقوم بإنشاء <code>http.Handler</code> باستخدام وظيفة <code>NewServer</code> من حزمة <code>transport/http</code> ، والتي تزودنا <code>NewServer</code> نهاية وطلب وظائف فك التشفير (إرجاع قيمة <code>type DecodeRequestFunc func</code> ) وترميز الاستجابة (على سبيل المثال <code>type EncodeReponseFunc func</code> ). </p><br><p style=";text-align:right;direction:rtl">  فيما يلي أمثلة على <code>DecodeRequestFunc</code> و <code>EncodeResponseFunc</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera" style=";text-align:right;direction:rtl">  بدء خادم HTTP </h4><br><p style=";text-align:right;direction:rtl">  أخيرًا ، يمكننا تشغيل خادم HTTP الخاص بنا لمعالجة الطلبات.  تطبق وظيفة <code>NewService</code> الموضحة أعلاه واجهة <code>http.Handler</code> والتي تتيح لنا تشغيلها <code>http.Handler</code> HTTP: </p><br><pre style=";text-align:right;direction:rtl"> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن تم إطلاق خدمتنا وتستخدم بروتوكول HTTP على مستوى النقل.  يمكن بدء نفس الخدمة باستخدام وسيلة نقل أخرى. على سبيل المثال ، يمكن كشف الخدمة باستخدام gRPC أو Apache Thrift. </p><br><p style=";text-align:right;direction:rtl">  بالنسبة للمقالة التمهيدية ، استخدمنا بالفعل بدائل Go kit بشكل كافٍ ، ولكنه يوفر أيضًا المزيد من الوظائف لإنشاء أنظمة ذات أنماط شفافة وموثوقة واكتشاف الخدمة وموازنة الحمل وما إلى ذلك.  سنناقش هذه الأشياء وأشياء أخرى في مجموعة Go في المقالات التالية. </p><br><h3 id="ishodnyy-kod" style=";text-align:right;direction:rtl">  كود المصدر </h3><br><p style=";text-align:right;direction:rtl">  يمكن الاطلاع على شفرة المصدر الكاملة للأمثلة على GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا.</a> </p><br><h3 id="middlewares-v-go-kit" style=";text-align:right;direction:rtl">  الوسيطة في مجموعة Go </h3><br><p style=";text-align:right;direction:rtl">  مجموعة أدوات Go تستعد لاستخدام المبادئ الجيدة لتصميم النظام ، مثل الطبقات.  يمكن عزل مكونات الخدمة ونقاط النهاية باستخدام Middlewares ( <em>نمط وسيط</em> المسار <em>تقريبًا</em> ).  توفر الوسيطة في مجموعة Go آلية قوية يمكنك من خلالها التفاف الخدمات ونقاط النهاية وإضافة وظائف (مكونات معزولة) ، مثل تسجيل الدخول أو مقاطعة الطلب أو الحد من عدد الطلبات أو موازنة التحميل أو التتبع الموزع. </p><br><p style=";text-align:right;direction:rtl">  فيما يلي صورة من موقع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Go kit على</a> الويب ، والتي تم تصويرها على أنها "هندسة بصل" نموذجية باستخدام Middlewares في مجموعة Go: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="الصورة"></p><br><h3 id="osteregaytes-sindroma-spring-boot-misroservices" style=";text-align:right;direction:rtl">  حذار من متلازمة Microservices الربيع التمهيد </h3><br><p style=";text-align:right;direction:rtl">  مثل مجموعة أدوات Go ، يعد Spring Boot مجموعة أدوات للخدمة الصغيرة في عالم Java.  ولكن ، على عكس مجموعة Go ، يعتبر Spring Boot إطارًا ناضجًا للغاية.  أيضًا ، يستخدم العديد من مطوري Java Spring Boot لإنشاء خدمات عالمية باستخدام مكدس Java مع ملاحظات إيجابية من الاستخدام ، ويعتقد البعض أن الخدمات الدقيقة تتعلق فقط باستخدام Spring Boot.  أرى العديد من فرق التطوير التي تسيء تفسير استخدام الخدمات الدقيقة ، وأنه لا يمكن تطويرها إلا باستخدام Spring Boot و OSS Netflix ولا يرون الخدمات الدقيقة كنمط عند تطوير الأنظمة الموزعة. </p><br><p style=";text-align:right;direction:rtl">  لذا ضع في اعتبارك أنه من خلال مجموعة من الأدوات ، مثل مجموعة Go أو نوع ما من إطار العمل ، يمكنك توجيه تطويرك نحو أجهزة صغرى ، كنمط تصميم.  على الرغم من أن الخدمات الصغيرة تحل العديد من مشكلات القياس لكل من الأوامر والأنظمة ، إلا أنها تخلق أيضًا العديد من المشاكل لأن البيانات في أنظمة الخدمات الدقيقة متناثرة عبر قواعد بيانات مختلفة ، والتي تخلق أحيانًا العديد من المشاكل عند إنشاء استعلامات المعاملات أو البيانات.  كل هذا يتوقف على مشكلة مجال الموضوع وسياق نظامك.  الشيء الرائع هو أن مجموعة Go ، المصممة كأداة لإنشاء خدمات دقيقة ، كانت مناسبة أيضًا لإنشاء متجانسة أنيقة تم إنشاؤها باستخدام تصميم معماري جيد لأنظمتك. </p><br><p style=";text-align:right;direction:rtl">  كما تتوفر بعض ميزات مجموعة أدوات Go ، مثل مقاطعة الطلبات وتقييدها ، على الأنظمة الأساسية لشبكات الخدمة ، مثل Istio.  لذا ، إذا كنت تستخدم شيئًا مثل Istio لإطلاق وحدات الميكروسيك الخاصة بك ، فقد لا تحتاج إلى بعض الأشياء من مجموعة Go ، ولكن ليس لدى الجميع ما يكفي من عرض القناة لاستخدام شبكة الخدمة لإنشاء اتصال بين الخدمات ، لأن هذا يضيف المزيد مستوى واحد وتعقيد إضافي. </p><br><h2 id="ps" style=";text-align:right;direction:rtl">  ملاحظة </h2><br><p style=";text-align:right;direction:rtl">  قد لا يشارك مؤلف الترجمة رأي مؤلف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">النص الأصلي</a> ، وقد تمت ترجمة هذه المقالة لأغراض تعليمية فقط لمجتمع اللغة الروسية Go. </p><br><p style=";text-align:right;direction:rtl">  <strong>UPD</strong> <br>  هذه هي أيضًا المقالة الأولى في قسم الترجمة وسأكون ممتنًا لأية تعليقات على الترجمة. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar430300/">https://habr.com/ru/post/ar430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar430286/index.html">تفاصيل الجانب الفوضوي والمظلم لألعاب القراصنة لـ Nintendo Switch</a></li>
<li><a href="../ar430290/index.html">محاولة للتنبؤ بالتكرار الرابع لمشروع SpaceX BFR</a></li>
<li><a href="../ar430292/index.html">مؤسسة الحدود الإلكترونية: أداء شبكة لوحة ترخيص الشرطة الأمريكية 0.5٪</a></li>
<li><a href="../ar430294/index.html">10 فوائد غير واضحة لاستخدام الصدأ</a></li>
<li><a href="../ar430296/index.html">اجعل أفكارك تأتي التطبيق. تطبيق بدون خادم - تعليمات خطوة بخطوة</a></li>
<li><a href="../ar430302/index.html">مقدمة عن ptrace أو إدخال الرمز في sshd من أجل المتعة</a></li>
<li><a href="../ar430304/index.html">موقع رائع في المدار</a></li>
<li><a href="../ar430306/index.html">النفق الأول لشركة مملة حفر بواسطة إيلونا ماسك</a></li>
<li><a href="../ar430308/index.html">الثعبان الداخلي. بيض عيد الفصح</a></li>
<li><a href="../ar430312/index.html">التحقق من الأشكال المعقدة للتفاعل. الجزء الأول</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>