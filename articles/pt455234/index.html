<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍟 🐐 🏞️ Tipos de referência anuláveis ​​em C # 8.0 e análise estática 🎟️ ▶️ 🐥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Não é segredo que a Microsoft esteja trabalhando na 8ª versão da linguagem C # há algum tempo. A versão do novo idioma (C # 8.0) já está disponível na...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de referência anuláveis ​​em C # 8.0 e análise estática</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455234/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Quadro 9"></p><br>  Não é segredo que a Microsoft esteja trabalhando na 8ª versão da linguagem C # há algum tempo.  A versão do novo idioma (C # 8.0) já está disponível na versão recente do Visual Studio 2019, mas ainda está na versão beta.  Esta nova versão terá alguns recursos implementados de uma maneira um tanto não óbvia ou bastante inesperada.  Tipos de referência anuláveis ​​são um deles.  Esse recurso é anunciado como um meio de combater as exceções de referência nulas (NRE). <br><a name="habracut"></a><br>  É bom ver a linguagem evoluir e adquirir novos recursos para ajudar os desenvolvedores.  Por coincidência, há algum tempo, aprimoramos significativamente a capacidade do analisador C # do PVS-Studio em detectar NREs.  E agora estamos nos perguntando se os analisadores estáticos em geral e o PVS-Studio em particular ainda devem se preocupar em diagnosticar possíveis desreferências nulas, uma vez que, pelo menos no novo código que fará uso da Referência Nula, essas desreferências se tornarão "impossíveis"?  Vamos tentar esclarecer isso. <br><br><h2>  Prós e contras do novo recurso </h2><br>  Um lembrete antes de continuarmos: a versão beta mais recente do C # 8.0, disponível no momento da redação deste post, tem os tipos de Referência Anulável desativados por padrão, ou seja, o comportamento dos tipos de referência não mudou. <br><br>  Então, quais são os tipos de referência exatamente anuláveis ​​no C # 8.0, se habilitarmos essa opção?  Eles são basicamente os mesmos tipos de referência antigos, exceto que agora você precisará adicionar '?'  após o nome do tipo (por exemplo, <i>string?</i> ), semelhante a <i>Nullable &lt;T&gt;</i> , ou seja, tipos de valores anuláveis ​​(por exemplo, <i>int?</i> ).  Sem o '?', Nosso tipo de <i>string</i> agora será interpretado como referência não anulável, ou seja, um tipo de referência que não pode ser atribuído como <i>nulo</i> . <br><br>  Exceção de referência nula é uma das exceções mais irritantes para entrar no seu programa, porque não fala muito sobre sua origem, especialmente se o método de arremesso contiver várias operações de desreferência em uma linha.  A capacidade de proibir a atribuição nula a uma variável de um tipo de referência parece legal, mas e os casos em que a passagem de um <i>nulo</i> para um método tem alguma lógica de execução dependendo disso?  Em vez de <i>nulo</i> , poderíamos, é claro, usar um valor literal, constante ou simplesmente "impossível" que logicamente não pode ser atribuído à variável em nenhum outro lugar.  Mas isso representa o risco de substituir uma falha do programa por uma execução "silenciosa", mas incorreta, que geralmente é pior do que enfrentar o erro imediatamente. <br><br>  Que tal lançar uma exceção então?  Uma exceção significativa lançada em um local onde algo deu errado é sempre melhor do que um <i>NRE em</i> algum lugar acima ou abaixo da pilha.  Mas isso só é bom em seu próprio projeto, onde você pode corrigir os consumidores inserindo um bloco <i>try-catch</i> e é de sua exclusiva responsabilidade.  Ao desenvolver uma biblioteca usando a Referência Nulável (não), precisamos garantir que um determinado método sempre retorne um valor.  Afinal, nem sempre é possível (ou pelo menos fácil), mesmo em seu próprio código, substituir o retorno de <i>null</i> por lançamento de exceção (já que isso pode afetar muito código). <br><br>  A Referência Nullable pode ser ativada no nível global do projeto, adicionando a propriedade <i>NullableContextOptions</i> com o valor <i>enable,</i> ou no nível do arquivo por meio da diretiva pré-processador: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  O recurso Referência Anulável tornará os tipos mais informativos.  A assinatura do método fornece uma pista sobre seu comportamento: se ele tem uma verificação nula ou não, se pode retornar <i>nulo</i> ou não.  Agora, quando você tenta usar uma variável de referência anulável sem verificá-la, o compilador emitirá um aviso. <br><br>  Isso é bastante conveniente ao usar bibliotecas de terceiros, mas também acrescenta o risco de enganar o usuário da biblioteca, pois ainda é possível passar <i>nulo</i> usando o novo operador que perdoa nulo (!).  Ou seja, adicionar apenas um ponto de exclamação pode quebrar todas as outras suposições sobre a interface usando essas variáveis: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Sim, você pode argumentar que essa é uma programação ruim e ninguém escreveria um código como esse de verdade, mas enquanto isso puder ser feito, você não poderá se sentir seguro confiando apenas no contrato imposto pela interface de um determinado método ( dizendo que não pode retornar <i>nulo</i> ). <br><br>  A propósito, você pode escrever o mesmo código usando vários <i>!</i>  operadores, como o C # agora permite que você faça isso (e esse código é perfeitamente compilável): <br><br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Ao escrever dessa maneira, enfatizamos a idéia: "veja, isso pode ser <i>nulo</i> !!!"  (nós, em nossa equipe, chamamos isso de programação "emocional").  De fato, ao criar a árvore de sintaxe, o compilador (de Roslyn) interpreta o <i>!</i>  operador da mesma maneira que interpreta parênteses regulares, o que significa que você pode escrever tantos <i>!</i>  é como você gosta - assim como entre parênteses.  Mas se você escrever o suficiente deles, poderá "derrubar" o compilador.  Talvez isso seja corrigido na versão final do C # 8.0. <br><br>  Da mesma forma, você pode contornar o aviso do compilador ao acessar uma variável de referência anulável sem uma verificação: <br><br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Vamos adicionar mais emoções: <br><br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Você quase nunca verá uma sintaxe assim em código real.  Escrevendo o operador que <i>perdoa nulos</i> , dizemos ao compilador: "Este código está correto, verifique se não é necessário".  Adicionando o operador Elvis, dizemos: “Ou talvez não;  vamos verificá-lo por precaução. ” <br><br>  Agora, você pode perguntar razoavelmente por que você ainda pode ter <i>nulos</i> atribuídos a variáveis ​​de tipos de referência não anuláveis ​​tão facilmente se o próprio conceito desse tipo implica que essas variáveis ​​não podem ter o valor <i>nulo</i> ?  A resposta é que "sob o capô", no nível do código IL, nosso tipo de referência não anulável ainda é ... o bom e velho tipo de referência "regular" e toda a sintaxe de anulabilidade é na verdade apenas uma anotação para o built-in do compilador analisador (que, acreditamos, não é muito conveniente de usar, mas irei detalhar isso mais tarde).  Pessoalmente, não achamos uma solução "pura" incluir a nova sintaxe simplesmente como uma anotação para uma ferramenta de terceiros (mesmo incorporada ao compilador) porque o fato de ser apenas uma anotação pode não ser óbvio. para o programador, pois essa sintaxe é muito semelhante à sintaxe para estruturas anuláveis, mas funciona de uma maneira totalmente diferente. <br><br>  Voltando a outras maneiras de quebrar os tipos de Referência Nulável.  No momento em que escrevemos este artigo, quando você tem uma solução composta por vários projetos, passando uma variável de um tipo de referência, por exemplo, <i>String</i> de um método declarado em um projeto para um método em outro projeto que possui o <i>NullableContext</i> o compilador assume que está lidando com uma String não anulável e o compilador permanecerá silencioso.  E isso apesar das toneladas de atributos <i>[Nullable (1)]</i> adicionados a todos os campos e métodos no código IL ao ativar as Referências Nullable <i>.</i>  A propósito, esses atributos devem ser levados em consideração se você usar a reflexão para manipular os atributos e assumir que o código contém apenas os personalizados. <br><br>  Essa situação pode causar problemas adicionais ao adaptar uma base de código grande ao estilo de Referência nula.  Esse processo provavelmente estará em execução por um tempo, projeto por projeto.  Se você for cuidadoso, é claro, poderá integrar gradualmente o novo recurso, mas se já tiver um projeto em funcionamento, quaisquer alterações nele serão perigosas e indesejáveis ​​(se funcionar, não toque nele!).  É por isso que garantimos que você não precise modificar seu código-fonte ou marcá-lo para detectar possíveis <i>NREs</i> ao usar o analisador PVS-Studio.  Para verificar os locais que podem gerar uma <i>NullReferenceException,</i> basta executar o analisador e procurar por avisos do V3080.  Não há necessidade de alterar as propriedades do projeto ou o código fonte.  Não há necessidade de adicionar diretivas, atributos ou operadores.  Não há necessidade de alterar o código legado. <br><br>  Ao adicionar o suporte a Nullable Reference no PVS-Studio, tivemos que decidir se o analisador deveria assumir que variáveis ​​de tipos de referência não anuláveis ​​sempre têm valores não nulos.  Após investigarmos como essa garantia poderia ser violada, decidimos que o PVS-Studio não deveria fazer essa suposição.  Afinal, mesmo que um projeto use tipos de referência não anuláveis ​​o tempo todo, o analisador poderá adicionar esse recurso detectando aquelas situações específicas em que essas variáveis ​​podem ter o valor <i>nulo</i> . <br><br><h2>  Como o PVS-Studio procura exceções de referência nulas </h2><br>  Os mecanismos de fluxo de dados no analisador C # do PVS-Studio rastreiam possíveis valores de variáveis ​​durante o processo de análise.  Isso também inclui análise interprocedural, ou seja, rastrear possíveis valores retornados por um método e seus métodos aninhados, e assim por diante.  Além disso, o PVS-Studio lembra variáveis ​​que podem ter valor <i>nulo</i> atribuído.  Sempre que essa variável for desreferenciada sem verificação, seja no código atual em análise ou dentro de um método invocado nesse código, ele emitirá um aviso V3080 sobre uma possível exceção de referência nula em potencial. <br><br>  A idéia por trás desse diagnóstico é fazer com que o analisador fique com raiva apenas quando vir uma atribuição <i>nula</i> .  Essa é a principal diferença do comportamento do nosso diagnóstico e do analisador interno do compilador que lida com os tipos de Referência Nula.  O analisador embutido apontará para cada desreferência de uma variável de referência nula não verificada - já que não foi enganada pelo uso da <i>!</i>  operador ou mesmo apenas uma verificação complicada (deve-se notar, no entanto, que absolutamente qualquer analisador estático, o PVS-Studio não é uma exceção aqui, pode ser "enganado" de uma maneira ou de outra, especialmente se você pretende fazê-lo). <br><br>  O PVS-Studio, por outro lado, avisa apenas se vir um <i>nulo</i> (seja no contexto local ou no contexto de um método externo).  Mesmo se a variável for de um tipo de referência não anulável, o analisador continuará apontando para ela se vir uma atribuição <i>nula</i> para essa variável.  Essa abordagem, acreditamos, é mais apropriada (ou pelo menos mais conveniente para o usuário), pois não exige "borrar" todo o código com verificações nulas para rastrear possíveis desreferências - afinal, essa opção estava disponível mesmo antes da referência nula. foram introduzidos, por exemplo, através do uso de contratos.  Além disso, o analisador agora pode fornecer um melhor controle sobre as próprias variáveis ​​de referência não anuláveis.  Se essa variável for usada "razoavelmente" e nunca for atribuída <i>nula</i> , o PVS-Studio não dirá uma palavra.  Se a variável for atribuída <i>nula</i> e desreferenciada sem uma verificação prévia, o PVS-Studio emitirá um aviso V3080: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br>  Agora, vamos dar uma olhada em alguns exemplos que demonstram como esse diagnóstico é acionado pelo código do próprio Roslyn.  Já <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verificamos este projeto</a> recentemente, mas desta vez analisaremos apenas as possíveis exceções de referência nula não mencionadas nos artigos anteriores.  Veremos como o PVS-Studio detecta NREs em potencial e como eles podem ser corrigidos usando a nova sintaxe Nullable Reference. <br><br>  <i>V3080 [CWE-476] Possível desreferência nula dentro do método.</i>  <i>Considere inspecionar o segundo argumento: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Como você pode ver, a variável <i>chainedTupleType</i> pode receber o valor <i>nulo</i> em uma das ramificações de execução.  Em seguida, é passado para o método <i>ConstructTupleUnderlyingType</i> e usado após uma verificação <i>Debug.Assert</i> .  É um padrão muito comum em Roslyn, mas lembre-se de que o <i>Debug.Assert</i> foi removido na versão de lançamento.  É por isso que o analisador ainda considera perigosa a desreferência dentro do método <i>ConstructTupleUnderlyingType</i> .  Aqui está o corpo desse método, onde a desreferência ocorre: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Na verdade, é uma questão em disputa se o analisador deve levar em consideração as declarações assim (alguns de nossos usuários desejam) - afinal, o analisador leva em consideração os contratos do System.Diagnostics.Contracts.  Aqui está um pequeno exemplo da vida real de nossa experiência de usar Roslyn em nosso próprio analisador.  Ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adicionar o suporte da versão mais recente do Visual Studio</a> recentemente, também atualizamos o Roslyn para sua terceira versão.  Depois disso, o PVS-Studio começou a travar em determinado código que nunca havia travado antes.  A falha, acompanhada por uma exceção de referência nula, ocorreria não em nosso código, mas no código de Roslyn.  A depuração revelou que o fragmento de código no qual Roslyn estava travando tinha esse tipo de verificação nula baseada em <i>Debug.Assert</i> várias linhas mais altas - e essa verificação obviamente não ajudou. <br><br>  É um exemplo gráfico de como você pode ter problemas com o Nullable Reference, porque o compilador trata o <i>Debug.Assert</i> como uma verificação confiável em qualquer configuração.  Ou seja, se você adicionar <i>#nullable enable</i> e marcar o argumento <i>chainedTupleTypeOpt</i> como uma referência nula <i>,</i> o compilador não emitirá nenhum aviso sobre a desreferência dentro do método <i>ConstructTupleUnderlyingType</i> . <br><br>  Passando para outros exemplos de avisos do PVS-Studio. <br><br>  <i>V3080 Possível desreferência nula.</i>  <i>Considere inspecionar 'eficazRuleset'.</i>  <i>RuleSet.cs 146</i> <br><br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Esse aviso diz que a chamada do método <i>WithEffectiveAction</i> pode retornar <i>nulo</i> , enquanto o valor de retorno atribuído à variável <i>effectiveRuleset</i> não é verificado antes do uso ( <i>effectiveRuleset.GeneralDiagnosticOption</i> ).  Aqui está o corpo do método <i>WithEffectiveAction</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  Com a Referência nula ativada para o método <i>GetEffectiveRuleSet</i> , obteremos dois locais em que o comportamento do código deve ser alterado.  Como o método mostrado acima pode gerar uma exceção, é lógico supor que a chamada para ela seja agrupada em um bloco <i>try-catch</i> e seria correto reescrever o método para gerar uma exceção em vez de retornar <i>nulo</i> .  No entanto, se você rastrear algumas chamadas de volta, verá que o código de captura está muito longe para prever com segurança as conseqüências.  Vamos dar uma olhada no consumidor da variável <i>effectiveRuleset</i> , o método <i>IsStricterThan</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Como você pode ver, é uma declaração de opção simples escolhendo entre duas enumerações, com <i>ReportDiagnostic.Default</i> como o valor padrão.  Portanto, seria melhor reescrever a chamada da seguinte maneira: <br><br>  A assinatura de <i>WithEffectiveAction</i> mudará: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  É assim que a chamada será: <br><br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  Como <i>IsStricterThan</i> realiza apenas a comparação, a condição pode ser reescrita - por exemplo, assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Próximo exemplo. <br><br>  <i>V3080 Possível desreferência nula.</i>  <i>Considere inspecionar 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  Para corrigir esse aviso, precisamos ver o que acontece com a variável <i>propertySymbol a</i> seguir. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  O método <i>GetMemberSymbol</i> também pode retornar <i>nulo</i> em determinadas condições. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Com os tipos de referência anuláveis ​​ativados, a chamada será alterada para isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  É muito fácil de corrigir quando você sabe onde procurar.  A análise estática pode capturar esse erro em potencial sem nenhum esforço, coletando todos os valores possíveis do campo de todas as cadeias de chamadas de procedimento. <br><br>  <i>V3080 Possível desreferência nula.</i>  <i>Considere inspecionar 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  O problema está na linha da verificação <i>simpleName.Length</i> .  A variável <i>simpleName</i> resulta da execução de uma longa série de métodos e pode ser atribuída <i>nula</i> .  A propósito, se você estiver curioso, poderá examinar o método <i>RemoveExtension</i> para ver como ele é diferente de <i>Path.GetFileNameWithoutExtension.</i>  Uma verificação <i>simpleName! = Null</i> seria suficiente, mas com tipos de referência não anuláveis, o código será alterado para algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  É assim que a chamada pode parecer: <br><br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclusão </h2><br>  Os tipos de referência anulável podem ser uma grande ajuda ao projetar a arquitetura do zero, mas a reformulação do código existente pode exigir muito tempo e cuidado, pois pode levar a uma série de erros indescritíveis.  Este artigo não visa desencorajá-lo a usar os tipos de Referência Anulável.  Consideramos esse novo recurso geralmente útil, mesmo que a maneira exata como ele seja implementado possa ser controversa. <br><br>  No entanto, lembre-se sempre das limitações dessa abordagem e lembre-se de que a ativação do modo de Referência Nula não protege você contra as NREs e que, quando mal utilizadas, pode se tornar a fonte desses erros.  Recomendamos que você complemente o recurso Nullable Reference com uma ferramenta de análise estática moderna, como o PVS-Studio, que oferece suporte à análise interprocedural para proteger seu programa contra NREs.  Cada uma dessas abordagens - análise interprocedural profunda e assinaturas de métodos de anotação (que é de fato o que o modo Nullable Reference faz) - tem seus prós e contras.  O analisador fornecerá uma lista de locais potencialmente perigosos e permitirá ver as consequências da modificação do código existente.  Se houver uma atribuição nula em algum lugar, o analisador apontará para cada consumidor da variável onde ela é desreferenciada sem uma verificação. <br><br>  Você pode verificar este projeto ou seus próprios projetos em busca de outros defeitos - basta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baixar o</a> PVS-Studio e experimentá-lo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455234/">https://habr.com/ru/post/pt455234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455218/index.html">Abordagem Ecossistêmica à Tecnologia Empresarial</a></li>
<li><a href="../pt455224/index.html">Música Finger: Tocar qualquer coisa com SpecDrums de Sphero</a></li>
<li><a href="../pt455226/index.html">Por que aplicar um linguista aplicado?</a></li>
<li><a href="../pt455228/index.html">Aquele que ressuscitou Duke Nukem: Entrevista com Randy Pitchford, Assistente de caixa de velocidades</a></li>
<li><a href="../pt455230/index.html">Tipos de referência anuláveis ​​em C # 8.0 e análise estática</a></li>
<li><a href="../pt455236/index.html">Comodo revoga certificados sem motivo</a></li>
<li><a href="../pt455240/index.html">Usando a taxa de defeitos rejeitados para melhorar o relatório de erros</a></li>
<li><a href="../pt455244/index.html">História em quadrinhos "A soldagem é fácil" na versão atualizada (2019)</a></li>
<li><a href="../pt455246/index.html">As inscrições para o Customer Experience Day em São Petersburgo estão abertas em 20 de junho</a></li>
<li><a href="../pt455248/index.html">Principais erros de desenvolvimento ao trabalhar com o PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>