<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçü üêê üèûÔ∏è Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica üéüÔ∏è ‚ñ∂Ô∏è üê•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="N√£o √© segredo que a Microsoft esteja trabalhando na 8¬™ vers√£o da linguagem C # h√° algum tempo. A vers√£o do novo idioma (C # 8.0) j√° est√° dispon√≠vel na...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455234/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Quadro 9"></p><br>  N√£o √© segredo que a Microsoft esteja trabalhando na 8¬™ vers√£o da linguagem C # h√° algum tempo.  A vers√£o do novo idioma (C # 8.0) j√° est√° dispon√≠vel na vers√£o recente do Visual Studio 2019, mas ainda est√° na vers√£o beta.  Esta nova vers√£o ter√° alguns recursos implementados de uma maneira um tanto n√£o √≥bvia ou bastante inesperada.  Tipos de refer√™ncia anul√°veis ‚Äã‚Äãs√£o um deles.  Esse recurso √© anunciado como um meio de combater as exce√ß√µes de refer√™ncia nulas (NRE). <br><a name="habracut"></a><br>  √â bom ver a linguagem evoluir e adquirir novos recursos para ajudar os desenvolvedores.  Por coincid√™ncia, h√° algum tempo, aprimoramos significativamente a capacidade do analisador C # do PVS-Studio em detectar NREs.  E agora estamos nos perguntando se os analisadores est√°ticos em geral e o PVS-Studio em particular ainda devem se preocupar em diagnosticar poss√≠veis desrefer√™ncias nulas, uma vez que, pelo menos no novo c√≥digo que far√° uso da Refer√™ncia Nula, essas desrefer√™ncias se tornar√£o "imposs√≠veis"?  Vamos tentar esclarecer isso. <br><br><h2>  Pr√≥s e contras do novo recurso </h2><br>  Um lembrete antes de continuarmos: a vers√£o beta mais recente do C # 8.0, dispon√≠vel no momento da reda√ß√£o deste post, tem os tipos de Refer√™ncia Anul√°vel desativados por padr√£o, ou seja, o comportamento dos tipos de refer√™ncia n√£o mudou. <br><br>  Ent√£o, quais s√£o os tipos de refer√™ncia exatamente anul√°veis ‚Äã‚Äãno C # 8.0, se habilitarmos essa op√ß√£o?  Eles s√£o basicamente os mesmos tipos de refer√™ncia antigos, exceto que agora voc√™ precisar√° adicionar '?'  ap√≥s o nome do tipo (por exemplo, <i>string?</i> ), semelhante a <i>Nullable &lt;T&gt;</i> , ou seja, tipos de valores anul√°veis ‚Äã‚Äã(por exemplo, <i>int?</i> ).  Sem o '?', Nosso tipo de <i>string</i> agora ser√° interpretado como refer√™ncia n√£o anul√°vel, ou seja, um tipo de refer√™ncia que n√£o pode ser atribu√≠do como <i>nulo</i> . <br><br>  Exce√ß√£o de refer√™ncia nula √© uma das exce√ß√µes mais irritantes para entrar no seu programa, porque n√£o fala muito sobre sua origem, especialmente se o m√©todo de arremesso contiver v√°rias opera√ß√µes de desrefer√™ncia em uma linha.  A capacidade de proibir a atribui√ß√£o nula a uma vari√°vel de um tipo de refer√™ncia parece legal, mas e os casos em que a passagem de um <i>nulo</i> para um m√©todo tem alguma l√≥gica de execu√ß√£o dependendo disso?  Em vez de <i>nulo</i> , poder√≠amos, √© claro, usar um valor literal, constante ou simplesmente "imposs√≠vel" que logicamente n√£o pode ser atribu√≠do √† vari√°vel em nenhum outro lugar.  Mas isso representa o risco de substituir uma falha do programa por uma execu√ß√£o "silenciosa", mas incorreta, que geralmente √© pior do que enfrentar o erro imediatamente. <br><br>  Que tal lan√ßar uma exce√ß√£o ent√£o?  Uma exce√ß√£o significativa lan√ßada em um local onde algo deu errado √© sempre melhor do que um <i>NRE em</i> algum lugar acima ou abaixo da pilha.  Mas isso s√≥ √© bom em seu pr√≥prio projeto, onde voc√™ pode corrigir os consumidores inserindo um bloco <i>try-catch</i> e √© de sua exclusiva responsabilidade.  Ao desenvolver uma biblioteca usando a Refer√™ncia Nul√°vel (n√£o), precisamos garantir que um determinado m√©todo sempre retorne um valor.  Afinal, nem sempre √© poss√≠vel (ou pelo menos f√°cil), mesmo em seu pr√≥prio c√≥digo, substituir o retorno de <i>null</i> por lan√ßamento de exce√ß√£o (j√° que isso pode afetar muito c√≥digo). <br><br>  A Refer√™ncia Nullable pode ser ativada no n√≠vel global do projeto, adicionando a propriedade <i>NullableContextOptions</i> com o valor <i>enable,</i> ou no n√≠vel do arquivo por meio da diretiva pr√©-processador: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  O recurso Refer√™ncia Anul√°vel tornar√° os tipos mais informativos.  A assinatura do m√©todo fornece uma pista sobre seu comportamento: se ele tem uma verifica√ß√£o nula ou n√£o, se pode retornar <i>nulo</i> ou n√£o.  Agora, quando voc√™ tenta usar uma vari√°vel de refer√™ncia anul√°vel sem verific√°-la, o compilador emitir√° um aviso. <br><br>  Isso √© bastante conveniente ao usar bibliotecas de terceiros, mas tamb√©m acrescenta o risco de enganar o usu√°rio da biblioteca, pois ainda √© poss√≠vel passar <i>nulo</i> usando o novo operador que perdoa nulo (!).  Ou seja, adicionar apenas um ponto de exclama√ß√£o pode quebrar todas as outras suposi√ß√µes sobre a interface usando essas vari√°veis: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Sim, voc√™ pode argumentar que essa √© uma programa√ß√£o ruim e ningu√©m escreveria um c√≥digo como esse de verdade, mas enquanto isso puder ser feito, voc√™ n√£o poder√° se sentir seguro confiando apenas no contrato imposto pela interface de um determinado m√©todo ( dizendo que n√£o pode retornar <i>nulo</i> ). <br><br>  A prop√≥sito, voc√™ pode escrever o mesmo c√≥digo usando v√°rios <i>!</i>  operadores, como o C # agora permite que voc√™ fa√ßa isso (e esse c√≥digo √© perfeitamente compil√°vel): <br><br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  Ao escrever dessa maneira, enfatizamos a id√©ia: "veja, isso pode ser <i>nulo</i> !!!"  (n√≥s, em nossa equipe, chamamos isso de programa√ß√£o "emocional").  De fato, ao criar a √°rvore de sintaxe, o compilador (de Roslyn) interpreta o <i>!</i>  operador da mesma maneira que interpreta par√™nteses regulares, o que significa que voc√™ pode escrever tantos <i>!</i>  √© como voc√™ gosta - assim como entre par√™nteses.  Mas se voc√™ escrever o suficiente deles, poder√° "derrubar" o compilador.  Talvez isso seja corrigido na vers√£o final do C # 8.0. <br><br>  Da mesma forma, voc√™ pode contornar o aviso do compilador ao acessar uma vari√°vel de refer√™ncia anul√°vel sem uma verifica√ß√£o: <br><br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Vamos adicionar mais emo√ß√µes: <br><br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Voc√™ quase nunca ver√° uma sintaxe assim em c√≥digo real.  Escrevendo o operador que <i>perdoa nulos</i> , dizemos ao compilador: "Este c√≥digo est√° correto, verifique se n√£o √© necess√°rio".  Adicionando o operador Elvis, dizemos: ‚ÄúOu talvez n√£o;  vamos verific√°-lo por precau√ß√£o. ‚Äù <br><br>  Agora, voc√™ pode perguntar razoavelmente por que voc√™ ainda pode ter <i>nulos</i> atribu√≠dos a vari√°veis ‚Äã‚Äãde tipos de refer√™ncia n√£o anul√°veis ‚Äã‚Äãt√£o facilmente se o pr√≥prio conceito desse tipo implica que essas vari√°veis ‚Äã‚Äãn√£o podem ter o valor <i>nulo</i> ?  A resposta √© que "sob o cap√¥", no n√≠vel do c√≥digo IL, nosso tipo de refer√™ncia n√£o anul√°vel ainda √© ... o bom e velho tipo de refer√™ncia "regular" e toda a sintaxe de anulabilidade √© na verdade apenas uma anota√ß√£o para o built-in do compilador analisador (que, acreditamos, n√£o √© muito conveniente de usar, mas irei detalhar isso mais tarde).  Pessoalmente, n√£o achamos uma solu√ß√£o "pura" incluir a nova sintaxe simplesmente como uma anota√ß√£o para uma ferramenta de terceiros (mesmo incorporada ao compilador) porque o fato de ser apenas uma anota√ß√£o pode n√£o ser √≥bvio. para o programador, pois essa sintaxe √© muito semelhante √† sintaxe para estruturas anul√°veis, mas funciona de uma maneira totalmente diferente. <br><br>  Voltando a outras maneiras de quebrar os tipos de Refer√™ncia Nul√°vel.  No momento em que escrevemos este artigo, quando voc√™ tem uma solu√ß√£o composta por v√°rios projetos, passando uma vari√°vel de um tipo de refer√™ncia, por exemplo, <i>String</i> de um m√©todo declarado em um projeto para um m√©todo em outro projeto que possui o <i>NullableContext</i> o compilador assume que est√° lidando com uma String n√£o anul√°vel e o compilador permanecer√° silencioso.  E isso apesar das toneladas de atributos <i>[Nullable (1)]</i> adicionados a todos os campos e m√©todos no c√≥digo IL ao ativar as Refer√™ncias Nullable <i>.</i>  A prop√≥sito, esses atributos devem ser levados em considera√ß√£o se voc√™ usar a reflex√£o para manipular os atributos e assumir que o c√≥digo cont√©m apenas os personalizados. <br><br>  Essa situa√ß√£o pode causar problemas adicionais ao adaptar uma base de c√≥digo grande ao estilo de Refer√™ncia nula.  Esse processo provavelmente estar√° em execu√ß√£o por um tempo, projeto por projeto.  Se voc√™ for cuidadoso, √© claro, poder√° integrar gradualmente o novo recurso, mas se j√° tiver um projeto em funcionamento, quaisquer altera√ß√µes nele ser√£o perigosas e indesej√°veis ‚Äã‚Äã(se funcionar, n√£o toque nele!).  √â por isso que garantimos que voc√™ n√£o precise modificar seu c√≥digo-fonte ou marc√°-lo para detectar poss√≠veis <i>NREs</i> ao usar o analisador PVS-Studio.  Para verificar os locais que podem gerar uma <i>NullReferenceException,</i> basta executar o analisador e procurar por avisos do V3080.  N√£o h√° necessidade de alterar as propriedades do projeto ou o c√≥digo fonte.  N√£o h√° necessidade de adicionar diretivas, atributos ou operadores.  N√£o h√° necessidade de alterar o c√≥digo legado. <br><br>  Ao adicionar o suporte a Nullable Reference no PVS-Studio, tivemos que decidir se o analisador deveria assumir que vari√°veis ‚Äã‚Äãde tipos de refer√™ncia n√£o anul√°veis ‚Äã‚Äãsempre t√™m valores n√£o nulos.  Ap√≥s investigarmos como essa garantia poderia ser violada, decidimos que o PVS-Studio n√£o deveria fazer essa suposi√ß√£o.  Afinal, mesmo que um projeto use tipos de refer√™ncia n√£o anul√°veis ‚Äã‚Äão tempo todo, o analisador poder√° adicionar esse recurso detectando aquelas situa√ß√µes espec√≠ficas em que essas vari√°veis ‚Äã‚Äãpodem ter o valor <i>nulo</i> . <br><br><h2>  Como o PVS-Studio procura exce√ß√µes de refer√™ncia nulas </h2><br>  Os mecanismos de fluxo de dados no analisador C # do PVS-Studio rastreiam poss√≠veis valores de vari√°veis ‚Äã‚Äãdurante o processo de an√°lise.  Isso tamb√©m inclui an√°lise interprocedural, ou seja, rastrear poss√≠veis valores retornados por um m√©todo e seus m√©todos aninhados, e assim por diante.  Al√©m disso, o PVS-Studio lembra vari√°veis ‚Äã‚Äãque podem ter valor <i>nulo</i> atribu√≠do.  Sempre que essa vari√°vel for desreferenciada sem verifica√ß√£o, seja no c√≥digo atual em an√°lise ou dentro de um m√©todo invocado nesse c√≥digo, ele emitir√° um aviso V3080 sobre uma poss√≠vel exce√ß√£o de refer√™ncia nula em potencial. <br><br>  A id√©ia por tr√°s desse diagn√≥stico √© fazer com que o analisador fique com raiva apenas quando vir uma atribui√ß√£o <i>nula</i> .  Essa √© a principal diferen√ßa do comportamento do nosso diagn√≥stico e do analisador interno do compilador que lida com os tipos de Refer√™ncia Nula.  O analisador embutido apontar√° para cada desrefer√™ncia de uma vari√°vel de refer√™ncia nula n√£o verificada - j√° que n√£o foi enganada pelo uso da <i>!</i>  operador ou mesmo apenas uma verifica√ß√£o complicada (deve-se notar, no entanto, que absolutamente qualquer analisador est√°tico, o PVS-Studio n√£o √© uma exce√ß√£o aqui, pode ser "enganado" de uma maneira ou de outra, especialmente se voc√™ pretende faz√™-lo). <br><br>  O PVS-Studio, por outro lado, avisa apenas se vir um <i>nulo</i> (seja no contexto local ou no contexto de um m√©todo externo).  Mesmo se a vari√°vel for de um tipo de refer√™ncia n√£o anul√°vel, o analisador continuar√° apontando para ela se vir uma atribui√ß√£o <i>nula</i> para essa vari√°vel.  Essa abordagem, acreditamos, √© mais apropriada (ou pelo menos mais conveniente para o usu√°rio), pois n√£o exige "borrar" todo o c√≥digo com verifica√ß√µes nulas para rastrear poss√≠veis desrefer√™ncias - afinal, essa op√ß√£o estava dispon√≠vel mesmo antes da refer√™ncia nula. foram introduzidos, por exemplo, atrav√©s do uso de contratos.  Al√©m disso, o analisador agora pode fornecer um melhor controle sobre as pr√≥prias vari√°veis ‚Äã‚Äãde refer√™ncia n√£o anul√°veis.  Se essa vari√°vel for usada "razoavelmente" e nunca for atribu√≠da <i>nula</i> , o PVS-Studio n√£o dir√° uma palavra.  Se a vari√°vel for atribu√≠da <i>nula</i> e desreferenciada sem uma verifica√ß√£o pr√©via, o PVS-Studio emitir√° um aviso V3080: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br>  Agora, vamos dar uma olhada em alguns exemplos que demonstram como esse diagn√≥stico √© acionado pelo c√≥digo do pr√≥prio Roslyn.  J√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verificamos este projeto</a> recentemente, mas desta vez analisaremos apenas as poss√≠veis exce√ß√µes de refer√™ncia nula n√£o mencionadas nos artigos anteriores.  Veremos como o PVS-Studio detecta NREs em potencial e como eles podem ser corrigidos usando a nova sintaxe Nullable Reference. <br><br>  <i>V3080 [CWE-476] Poss√≠vel desrefer√™ncia nula dentro do m√©todo.</i>  <i>Considere inspecionar o segundo argumento: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Como voc√™ pode ver, a vari√°vel <i>chainedTupleType</i> pode receber o valor <i>nulo</i> em uma das ramifica√ß√µes de execu√ß√£o.  Em seguida, √© passado para o m√©todo <i>ConstructTupleUnderlyingType</i> e usado ap√≥s uma verifica√ß√£o <i>Debug.Assert</i> .  √â um padr√£o muito comum em Roslyn, mas lembre-se de que o <i>Debug.Assert</i> foi removido na vers√£o de lan√ßamento.  √â por isso que o analisador ainda considera perigosa a desrefer√™ncia dentro do m√©todo <i>ConstructTupleUnderlyingType</i> .  Aqui est√° o corpo desse m√©todo, onde a desrefer√™ncia ocorre: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Na verdade, √© uma quest√£o em disputa se o analisador deve levar em considera√ß√£o as declara√ß√µes assim (alguns de nossos usu√°rios desejam) - afinal, o analisador leva em considera√ß√£o os contratos do System.Diagnostics.Contracts.  Aqui est√° um pequeno exemplo da vida real de nossa experi√™ncia de usar Roslyn em nosso pr√≥prio analisador.  Ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adicionar o suporte da vers√£o mais recente do Visual Studio</a> recentemente, tamb√©m atualizamos o Roslyn para sua terceira vers√£o.  Depois disso, o PVS-Studio come√ßou a travar em determinado c√≥digo que nunca havia travado antes.  A falha, acompanhada por uma exce√ß√£o de refer√™ncia nula, ocorreria n√£o em nosso c√≥digo, mas no c√≥digo de Roslyn.  A depura√ß√£o revelou que o fragmento de c√≥digo no qual Roslyn estava travando tinha esse tipo de verifica√ß√£o nula baseada em <i>Debug.Assert</i> v√°rias linhas mais altas - e essa verifica√ß√£o obviamente n√£o ajudou. <br><br>  √â um exemplo gr√°fico de como voc√™ pode ter problemas com o Nullable Reference, porque o compilador trata o <i>Debug.Assert</i> como uma verifica√ß√£o confi√°vel em qualquer configura√ß√£o.  Ou seja, se voc√™ adicionar <i>#nullable enable</i> e marcar o argumento <i>chainedTupleTypeOpt</i> como uma refer√™ncia nula <i>,</i> o compilador n√£o emitir√° nenhum aviso sobre a desrefer√™ncia dentro do m√©todo <i>ConstructTupleUnderlyingType</i> . <br><br>  Passando para outros exemplos de avisos do PVS-Studio. <br><br>  <i>V3080 Poss√≠vel desrefer√™ncia nula.</i>  <i>Considere inspecionar 'eficazRuleset'.</i>  <i>RuleSet.cs 146</i> <br><br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Esse aviso diz que a chamada do m√©todo <i>WithEffectiveAction</i> pode retornar <i>nulo</i> , enquanto o valor de retorno atribu√≠do √† vari√°vel <i>effectiveRuleset</i> n√£o √© verificado antes do uso ( <i>effectiveRuleset.GeneralDiagnosticOption</i> ).  Aqui est√° o corpo do m√©todo <i>WithEffectiveAction</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  Com a Refer√™ncia nula ativada para o m√©todo <i>GetEffectiveRuleSet</i> , obteremos dois locais em que o comportamento do c√≥digo deve ser alterado.  Como o m√©todo mostrado acima pode gerar uma exce√ß√£o, √© l√≥gico supor que a chamada para ela seja agrupada em um bloco <i>try-catch</i> e seria correto reescrever o m√©todo para gerar uma exce√ß√£o em vez de retornar <i>nulo</i> .  No entanto, se voc√™ rastrear algumas chamadas de volta, ver√° que o c√≥digo de captura est√° muito longe para prever com seguran√ßa as conseq√º√™ncias.  Vamos dar uma olhada no consumidor da vari√°vel <i>effectiveRuleset</i> , o m√©todo <i>IsStricterThan</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Como voc√™ pode ver, √© uma declara√ß√£o de op√ß√£o simples escolhendo entre duas enumera√ß√µes, com <i>ReportDiagnostic.Default</i> como o valor padr√£o.  Portanto, seria melhor reescrever a chamada da seguinte maneira: <br><br>  A assinatura de <i>WithEffectiveAction</i> mudar√°: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  √â assim que a chamada ser√°: <br><br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  Como <i>IsStricterThan</i> realiza apenas a compara√ß√£o, a condi√ß√£o pode ser reescrita - por exemplo, assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Pr√≥ximo exemplo. <br><br>  <i>V3080 Poss√≠vel desrefer√™ncia nula.</i>  <i>Considere inspecionar 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  Para corrigir esse aviso, precisamos ver o que acontece com a vari√°vel <i>propertySymbol a</i> seguir. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  O m√©todo <i>GetMemberSymbol</i> tamb√©m pode retornar <i>nulo</i> em determinadas condi√ß√µes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Com os tipos de refer√™ncia anul√°veis ‚Äã‚Äãativados, a chamada ser√° alterada para isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  √â muito f√°cil de corrigir quando voc√™ sabe onde procurar.  A an√°lise est√°tica pode capturar esse erro em potencial sem nenhum esfor√ßo, coletando todos os valores poss√≠veis do campo de todas as cadeias de chamadas de procedimento. <br><br>  <i>V3080 Poss√≠vel desrefer√™ncia nula.</i>  <i>Considere inspecionar 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  O problema est√° na linha da verifica√ß√£o <i>simpleName.Length</i> .  A vari√°vel <i>simpleName</i> resulta da execu√ß√£o de uma longa s√©rie de m√©todos e pode ser atribu√≠da <i>nula</i> .  A prop√≥sito, se voc√™ estiver curioso, poder√° examinar o m√©todo <i>RemoveExtension</i> para ver como ele √© diferente de <i>Path.GetFileNameWithoutExtension.</i>  Uma verifica√ß√£o <i>simpleName! = Null</i> seria suficiente, mas com tipos de refer√™ncia n√£o anul√°veis, o c√≥digo ser√° alterado para algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  √â assim que a chamada pode parecer: <br><br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclus√£o </h2><br>  Os tipos de refer√™ncia anul√°vel podem ser uma grande ajuda ao projetar a arquitetura do zero, mas a reformula√ß√£o do c√≥digo existente pode exigir muito tempo e cuidado, pois pode levar a uma s√©rie de erros indescrit√≠veis.  Este artigo n√£o visa desencoraj√°-lo a usar os tipos de Refer√™ncia Anul√°vel.  Consideramos esse novo recurso geralmente √∫til, mesmo que a maneira exata como ele seja implementado possa ser controversa. <br><br>  No entanto, lembre-se sempre das limita√ß√µes dessa abordagem e lembre-se de que a ativa√ß√£o do modo de Refer√™ncia Nula n√£o protege voc√™ contra as NREs e que, quando mal utilizadas, pode se tornar a fonte desses erros.  Recomendamos que voc√™ complemente o recurso Nullable Reference com uma ferramenta de an√°lise est√°tica moderna, como o PVS-Studio, que oferece suporte √† an√°lise interprocedural para proteger seu programa contra NREs.  Cada uma dessas abordagens - an√°lise interprocedural profunda e assinaturas de m√©todos de anota√ß√£o (que √© de fato o que o modo Nullable Reference faz) - tem seus pr√≥s e contras.  O analisador fornecer√° uma lista de locais potencialmente perigosos e permitir√° ver as consequ√™ncias da modifica√ß√£o do c√≥digo existente.  Se houver uma atribui√ß√£o nula em algum lugar, o analisador apontar√° para cada consumidor da vari√°vel onde ela √© desreferenciada sem uma verifica√ß√£o. <br><br>  Voc√™ pode verificar este projeto ou seus pr√≥prios projetos em busca de outros defeitos - basta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baixar o</a> PVS-Studio e experiment√°-lo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455234/">https://habr.com/ru/post/pt455234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455218/index.html">Abordagem Ecossist√™mica √† Tecnologia Empresarial</a></li>
<li><a href="../pt455224/index.html">M√∫sica Finger: Tocar qualquer coisa com SpecDrums de Sphero</a></li>
<li><a href="../pt455226/index.html">Por que aplicar um linguista aplicado?</a></li>
<li><a href="../pt455228/index.html">Aquele que ressuscitou Duke Nukem: Entrevista com Randy Pitchford, Assistente de caixa de velocidades</a></li>
<li><a href="../pt455230/index.html">Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica</a></li>
<li><a href="../pt455236/index.html">Comodo revoga certificados sem motivo</a></li>
<li><a href="../pt455240/index.html">Usando a taxa de defeitos rejeitados para melhorar o relat√≥rio de erros</a></li>
<li><a href="../pt455244/index.html">Hist√≥ria em quadrinhos "A soldagem √© f√°cil" na vers√£o atualizada (2019)</a></li>
<li><a href="../pt455246/index.html">As inscri√ß√µes para o Customer Experience Day em S√£o Petersburgo est√£o abertas em 20 de junho</a></li>
<li><a href="../pt455248/index.html">Principais erros de desenvolvimento ao trabalhar com o PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>