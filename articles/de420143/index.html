<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö™Ô∏è üëäüèæ üëéüèΩ Kotlin Leistung auf Android üêî üçà üë∞üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns heute √ºber die Leistung von Kotlin auf Android in der Produktion sprechen. Lassen Sie uns unter die Haube schauen, knifflige Optimierun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin Leistung auf Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420143/">  Lassen Sie uns heute √ºber die Leistung von Kotlin auf Android in der Produktion sprechen.  Lassen Sie uns unter die Haube schauen, knifflige Optimierungen implementieren und den Bytecode vergleichen.  Schlie√ülich werden wir uns dem Vergleich ernsthaft n√§hern und die Benchmarks messen. <br><br>  Dieser Artikel basiert auf einem Bericht von <strong>Alexander Smirnov</strong> auf der AppsConf 2017 und hilft herauszufinden, ob es m√∂glich ist, Code in Kotlin zu schreiben, der in seiner Geschwindigkeit Java nicht unterlegen ist. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher:</strong> Alexander Smirnov CTO bei PapaJobs, betreibt den Videoblog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android in Faces</a> und ist auch einer der Organisatoren der Mosdroid-Community. <br><a name="habracut"></a><br>  Beginnen wir mit Ihren Erwartungen. <br><br><blockquote>  Denken Sie, dass Kotlin zur Laufzeit langsamer ist als Java?  Oder schneller?  Oder gibt es keinen gro√üen Unterschied?  Schlie√ülich arbeiten beide an dem Bytecode, den uns die virtuelle Maschine zur Verf√ºgung stellt. </blockquote><br>  Lass es uns richtig machen.  Wenn sich die Frage nach dem Leistungsvergleich stellt, m√∂chte traditionell jeder Benchmarks und bestimmte Zahlen sehen.  Leider gibt es f√ºr Android kein JMH ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Microbenchmark Harness</a> ), sodass wir nicht einfach messen k√∂nnen, wie cool es in Java sein kann.  Was k√∂nnen wir also tun, um die Messung wie unten beschrieben durchzuf√ºhren? <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br>  Wenn Sie jemals versuchen, Ihren Code auf diese Weise zu messen, wird einer der JMH-Entwickler traurig sein, weinen und in einem Traum zu Ihnen kommen - tun Sie das niemals. <br><br>  Auf Android k√∂nnen Sie Benchmarks erstellen, insbesondere hat Google dies auf der I / O im letzten Jahr demonstriert.  Sie sagten, dass sie die virtuelle Maschine, in diesem Fall ART, erheblich verbessert h√§tten. Wenn unter Android 4.1 eine Zuordnung eines Objekts etwa 600 bis 700 Nanosekunden dauerte, w√ºrde dies in der achten Version etwa 60 Nanosekunden dauern.  Das hei√üt,  Sie konnten es in einer virtuellen Maschine mit solcher Genauigkeit messen.  Warum wir das auch nicht k√∂nnen - wir haben keine solchen Tools. <br><br>  Wenn wir uns die gesamte Dokumentation ansehen, k√∂nnen wir nur die obige Empfehlung finden, wie die Benutzeroberfl√§che gemessen werden kann: <br><br>  <strong>adb shell dumpsys gfxinfo% paketname%</strong> <br><br>  Eigentlich machen wir es so und sehen am Ende, was es geben wird.  Aber zuerst werden wir bestimmen, was wir messen und was wir sonst noch tun k√∂nnen. <br><br><blockquote>  Die n√§chste Frage.  Wo ist Ihrer Meinung nach Leistung wichtig, wenn Sie eine erstklassige Anwendung erstellen? <br><br><ol><li>  Auf jeden Fall √ºberall. </li><li>  UI-Thread. </li><li>  Benutzerdefinierte Ansicht + Animationen. </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br>  Ich mag die erste Option am meisten, aber h√∂chstwahrscheinlich wird angenommen, dass es unm√∂glich ist, den gesamten Code sehr, sehr schnell zum Laufen zu bringen, und es ist wichtig, dass zumindest kein UiThread oder keine benutzerdefinierte Ansicht vorhanden ist.  Dem stimme ich auch zu - es ist sehr, sehr wichtig.  Die Tatsache, dass in Ihrem separaten JSON-Stream 10 Millisekunden l√§nger deserialisiert wird, wird niemand bemerken. <br><br>  Die Gestaltpsychologie sagt, dass das menschliche Auge unscharf ist und nicht sieht, was dort tats√§chlich passiert, wenn wir etwa 150 bis 300 Millisekunden lang blinken.  Und dann diese 10 Millisekunden Wetter nicht.  Aber wenn wir zur Gestaltpsychologie zur√ºckkehren, ist es nicht wichtig, was ich wirklich sehe und was wirklich passiert, sondern was ich als Benutzer verstehe. <br><br>  Das hei√üt,  Wenn wir den Benutzer glauben lassen, dass er alles sehr, sehr schnell hat, aber tats√§chlich einfach sch√∂n geschlagen wird, zum Beispiel mit Hilfe einer sch√∂nen Animation, dann wird er zufrieden sein, auch wenn dies tats√§chlich nicht der Fall ist. <br><br>  Gestaltpsychologische Motive in iOS bewegen sich seit geraumer Zeit.  Wenn Sie also zwei Anwendungen mit derselben Verarbeitungszeit, jedoch auf unterschiedlichen Plattformen, nebeneinander stellen, scheint unter iOS alles schneller zu sein.  Die Animation in iOS wird etwas schneller verarbeitet, fr√ºhere Animationen beginnen beim Start und viele andere Animationen, sodass sie sch√∂n sind. <br><br>  Die <strong>erste Regel ist also, an den Benutzer zu denken.</strong> <br><br>  Und f√ºr die zweite Regel m√ºssen Sie in Hardcore eintauchen. <br><br><h2>  KOTLIN STYLE <br></h2><br>  Um die Leistung von Kotlin ehrlich zu bewerten, werden wir sie mit Java vergleichen.  Daher stellt sich heraus, dass es unm√∂glich ist, einige Dinge zu messen, die nur in Kotlin sind, zum Beispiel: <br><br><ul><li>  Sammlung Api. </li><li>  Standardparameter der Methode. </li><li>  Datenklassen. </li><li>  Reified Typen. </li><li>  Coroutinen. </li></ul><br>  <strong>Die Sammlungs-API</strong> , die Kotlin uns zur Verf√ºgung stellt, ist sehr cool, sehr schnell.  In Java existiert dies einfach nicht, es gibt nur unterschiedliche Implementierungen.  Beispielsweise ist die Liteweight Stream-API-Bibliothek langsamer, da sie alles wie Kotlin ausf√ºhrt, jedoch mit ein oder zwei zus√§tzlichen Zuordnungen f√ºr den Vorgang, da alles zu einem zus√§tzlichen Objekt wird. <br><br>  Wenn wir die Stream-API von Java 8 √ºbernehmen, funktioniert sie langsamer als die Kotlin Collection-API, jedoch unter einer Bedingung: Es gibt keine solche L√§hmung in der Collection-API, wenn wir sie parallel f√ºr gro√üe Mengen von Stream-API-Daten einbeziehen. Java umgeht die Kotlin Collection API.  Daher k√∂nnen wir solche Dinge nicht vergleichen, da wir den Vergleich genau aus der Sicht von Android durchf√ºhren. <br><br>  Die zweite Sache, die meines Erachtens nicht verglichen werden kann, sind die <strong>Standardparameter der Methode</strong> - eine sehr coole Funktion, die √ºbrigens in Dart enthalten ist.  Wenn Sie eine Methode aufrufen, enth√§lt sie m√∂glicherweise einige Parameter, die einen bestimmten Wert annehmen, jedoch NULL sein k√∂nnen.  Daher erstellen Sie nicht 10 verschiedene Methoden, sondern eine Methode und sagen, dass einer der Parameter NULL sein kann, und verwenden Sie ihn in Zukunft ohne Parameter.  Das hei√üt,  er wird schauen, der Parameter ist gekommen oder er ist nicht gekommen.  Es ist sehr praktisch, dass Sie viel weniger Code schreiben k√∂nnen, aber der Nachteil ist, dass Sie daf√ºr bezahlen m√ºssen.  Dies ist syntaktischer Zucker: Sie als Entwickler denken, dass dies eine API-Methode ist, aber in Wirklichkeit wird unter der Haube jede Variation der Methode mit fehlenden Parametern im Bytecode generiert.  Und jede dieser Methoden pr√ºft auch St√ºck f√ºr St√ºck, ob dieser Parameter angekommen ist.  Wenn es kam, dann ok, wenn es nicht kam, dann machen wir eine Bitmaske und abh√§ngig von dieser Bitmaske wird die urspr√ºngliche Methode, die Sie geschrieben haben, tats√§chlich aufgerufen.  Bitweise Operationen, alles <em>wenn / sonst</em> ein wenig Geld kostet, aber sehr wenig, und es ist normal, dass Sie f√ºr die Bequemlichkeit bezahlen m√ºssen.  Es scheint mir, dass dies absolut normal ist. <br><br>  Das n√§chste Element, das nicht verglichen werden kann, sind <strong>Datenklassen</strong> . <br><br>  Jeder weint, dass es in Java Parameter gibt, f√ºr die es Modellklassen gibt.  Das hei√üt,  Sie nehmen Parameter und machen mehr Methoden, Getter und Setter f√ºr all diese Parameter.  Es stellt sich heraus, dass Sie f√ºr eine Klasse mit zehn Parametern immer noch eine ganze Menge Getter, Setter und eine ganze Menge mehr ben√∂tigen.  Wenn Sie keine Generatoren verwenden, m√ºssen Sie au√üerdem mit Ihren H√§nden schreiben, was im Allgemeinen schrecklich ist. <br><br>  Mit Kotlin k√∂nnen Sie dem Alltag entfliehen.  Erstens, da es Eigenschaften in Kotlin gibt, m√ºssen Sie keine Getter und Setter schreiben.  Es hat <strong>keine Klassenparameter, alle Eigenschaften</strong> .  Auf jeden Fall denken wir so.  Zweitens, wenn Sie schreiben, dass dies Datenklassen sind, wird eine ganze Reihe von allem anderen generiert.  Zum Beispiel equals (), toStrung () / hasCode () usw. <br><br>  Dies hat nat√ºrlich auch Nachteile.  Zum Beispiel musste ich nicht alle 20 Parameter meiner Datenklassen gleichzeitig in meinem equals () vergleichen, sondern nur 3 vergleichen. Jemand mag das alles nicht, weil die Leistung dadurch verloren geht und au√üerdem viel generiert wird Service-Funktionen, und der kompilierte Code ist ziemlich umfangreich.  Das hei√üt, wenn Sie alles von Hand schreiben, gibt es weniger Code als bei Verwendung von Datenklassen. <br><br>  Ich verwende keine Datenklassen aus einem anderen Grund.  Zuvor gab es Einschr√§nkungen bei der Erweiterung solcher Klassen und etwas anderem.  Jetzt ist jeder besser damit, aber die Gewohnheit bleibt. <br><br>  Was ist in Kotlin sehr, sehr cool und was wird es immer schneller sein als Java?  Dies sind <strong>Reified-Typen</strong> , die √ºbrigens auch in Dart vorkommen. <br><br>  Sie wissen, dass bei Verwendung von Generika die Typl√∂schung in der Kompilierungsphase gel√∂scht wird und Sie zur Laufzeit nicht mehr wissen, welches Objekt dieses Generikums tats√§chlich verwendet wird. <br><br>  Bei Reified-Typen m√ºssen Sie Reflection nicht an vielen Stellen verwenden, wenn Sie es in Java ben√∂tigen w√ºrden, da Sie bei Inified-Methoden bei Reified den Typ kennen und sich daher herausstellt, dass Sie Reflection nicht verwenden und Ihr Code schneller arbeitet.  Die Magie. <br><br>  Und es gibt <strong>Coroutinen</strong> .  Sie sind sehr cool, ich mag sie sehr, aber zum Zeitpunkt der Auff√ºhrung waren sie nur in der Alpha-Version enthalten, so dass es nicht m√∂glich war, korrekte Vergleiche mit ihnen anzustellen. <br><br><h2>  FELDER <br></h2><br>  Gehen wir also weiter zu dem, was wir mit Java vergleichen und was wir allgemein beeinflussen k√∂nnen. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  Wie gesagt, wir haben keine Parameter f√ºr die Klasse, wir haben Eigenschaften. <br><br>  Wir haben var, wir haben val, wir haben eine externe Klasse, deren Eigenschaften @JvmField sind, und wir werden untersuchen, was tats√§chlich mit der Funktion work () passiert: Wir summieren den Wert von Feld a und Feld b unserer eigenen Klasse und Werte von Feld a und Feld b der √§u√üeren Klasse, die in das unver√§nderliche Feld c geschrieben sind. <br><br>  Die Frage ist, wie tats√§chlich in d = a + b genannt wird.  Wir alle wissen, dass diese Eigenschaft einmal, der Getter dieser Klasse, f√ºr diesen Parameter aufgerufen wird. <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Wenn wir uns jedoch den Bytecode ansehen, werden wir sehen, dass tats√§chlich auf getfield zugegriffen wird.  Das hei√üt, dies im Bytecode ist kein Aufruf der InvokeVirtual-Funktion, sondern ein direkter Zugriff auf das Feld.  Es wurde uns zun√§chst nichts versprochen, dass wir alle Eigenschaften haben, nicht die Felder.  Es stellt sich heraus, dass Kotlin uns t√§uscht, es gibt einen direkten Appell. <br><br>  Was passiert, wenn wir sehen, welcher Bytecode f√ºr eine andere Zeile generiert wird: val e = ca + cb? <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Wenn Sie zuvor auf eine private Immobilie zugegriffen haben, hatten Sie immer einen InvokeVirtual-Aufruf.  Wenn dies ein Privateigentum war, erfolgte der Zugriff √ºber GetField.  GetField ist viel schneller als InvokeVirtual. Die Spezifikation von Android besagt, dass der direkte Zugriff auf ein Feld drei- bis siebenmal schneller ist.  Daher wird empfohlen, dass Sie sich immer auf Field beziehen und nicht √ºber Getter oder Setter.  Insbesondere in der achten virtuellen ART-Maschine gibt es bereits unterschiedliche Nummern. Wenn Sie jedoch weiterhin 4.1 unterst√ºtzen, ist dies der Fall. <br><br>  Daher stellt sich heraus, dass es f√ºr uns immer noch von Vorteil ist, GetField und nicht InvokeVirtual zu haben. <br><br>  Jetzt k√∂nnen Sie GetField erreichen, wenn Sie auf eine Eigenschaft Ihrer eigenen Klasse zugreifen oder wenn dies eine √∂ffentliche Eigenschaft ist, m√ºssen Sie @JvmField festlegen.  Genau das gleiche im Bytecode ist dann ein GetField-Aufruf, der drei- bis siebenmal schneller ist. <br><br>  Es ist klar, dass wir hier in Nanosekunden sprechen und mit einem Thron sehr, sehr klein sind.  Wenn Sie dies jedoch im UI-Thread tun, z. B. in der Ondraw-Methode, greifen Sie auf eine Ansicht zu, wirkt sich dies auf das Rendern jedes Frames aus, und Sie k√∂nnen dies etwas schneller tun. <br><br>  <strong>Wenn wir alle Optimierungen addieren, kann dies insgesamt etwas ergeben.</strong> <br><br><h2>  STATISCH !? <br></h2><br>  Was ist mit Statik?  Wir alle wissen, dass Statik in Kotlin ein Begleitobjekt ist.  Zuvor haben Sie wahrscheinlich eine Art Tag hinzugef√ºgt, z. B. public static, final static usw. Wenn Sie dies in Kotlin-Code konvertieren, erhalten Sie ein Begleitobjekt, das etwa Folgendes schreibt: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote>  Denken Sie, dass dieser Eintrag mit der statischen Standarddeklaration in Java identisch ist?  Ist es √ºberhaupt statisch oder nicht? </blockquote><br>  Ja, tats√§chlich erkl√§rt Kotlin, dass es hier in Kotlin ist - statisch, dieses Objekt sagt, dass es statisch ist.  In Wirklichkeit ist dies nicht statisch. <br><br>  Wenn wir uns den generierten Bytecode ansehen, sehen wir Folgendes: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Ein Test.Companion wird generiert, ein Singleton-Objekt, f√ºr das die Instanz erstellt wird. Diese Instanz wird in ein eigenes Feld geschrieben.  Danach erfolgt der Zugriff auf eines der Begleitobjekte √ºber dieses Objekt.  Er nimmt getstatic, dh eine statische Instanz dieser Klasse, und ruft die getK-Funktion invKvirtual auf, und genau das gleiche gilt f√ºr die work2-Funktion.  Wir bekommen also, dass es nicht statisch ist. <br><br>  Dies ist wichtig, da bei √§lteren JVMs invokestatic etwa 30% schneller war als invokevirtual.  Bei HotSpot l√§uft die optimierte Virtualisierung nat√ºrlich sehr cool und ist fast unsichtbar.  Sie m√ºssen dies jedoch ber√ºcksichtigen, zumal es eine zus√§tzliche Zuordnung gibt und ein zus√§tzlicher Speicherort auf 4ST1 700 Nanosekunden zu viel ist. <br><br>  Schauen wir uns den Java-Code an, der ausgegeben wird, wenn Sie den Bytecode r√ºckw√§rts bereitstellen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Ein statisches Feld wird erstellt, eine statische endg√ºltige Implementierung des Companion-Objekts, Getter und Setter werden erstellt, und wie Sie sehen k√∂nnen, wird unter Bezugnahme auf das darin enthaltene statische Feld eine zus√§tzliche statische Methode angezeigt.  Alles ist traurig genug. <br><br>  Was k√∂nnen wir tun, um sicherzustellen, dass es nicht statisch ist?  Wir k√∂nnen versuchen, @JvmField und @JvmStatic hinzuzuf√ºgen und sehen, was passiert. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br>  Ich sage sofort, dass Sie @JvmStatic nicht verlassen, es wird dasselbe Objekt sein, da es sich um ein Begleitobjekt handelt, wird dieses Objekt zus√§tzlich zugewiesen und es wird zus√§tzlich aufgerufen. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Der Aufruf √§ndert sich jedoch nur f√ºr k, da er @JvmField ist und direkt als getstatic verwendet wird. Getter und Setter werden nicht mehr generiert.  Aber f√ºr die Funktion work2 wird sich nichts √§ndern. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Die zweite Option zum Erstellen von Statik wird in der Kotlin-Dokumentation vorgeschlagen. Es wird also gesagt, dass wir nur ein Objekt erstellen k√∂nnen, und dies ist statischer Code. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br>  In Wirklichkeit ist dies auch nicht so. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br>  Es stellt sich heraus, dass wir einen getstatic-Instanzaufruf von Singletone ausf√ºhren, der erstellt wird, und genau dieselben virtuellen Methoden aufrufen. <br><br>  Der einzige Weg, wie wir invokestatisch erreichen k√∂nnen, sind Funktionen h√∂herer Ordnung.  Wenn wir zum Beispiel nur eine Funktion au√üerhalb der Klasse schreiben, wird fun test2 wirklich als statisch bezeichnet. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br>  Das Interessanteste ist au√üerdem, dass eine Klasse erstellt wird, ein Objekt, in diesem Fall testKt, ein Objekt f√ºr sich selbst generiert, eine Funktion generiert, die in dieses Objekt eingef√ºgt wird, und jetzt als invokestatisch bezeichnet wird. <br><br>  Warum dies getan wurde, ist unverst√§ndlich.  Viele sind damit unzufrieden, aber es gibt diejenigen, die eine solche Implementierung f√ºr ganz normal halten.  Da die virtuelle Maschine inkl.  Kunst verbessert sich, jetzt ist sie nicht mehr so ‚Äã‚Äãkritisch.  In der achten Version von Android ist genau wie bei HotSpot alles optimiert, aber diese kleinen Dinge wirken sich immer noch geringf√ºgig auf die Gesamtleistung aus. <br><br><h2>  NULLABILIT√ÑT <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Dies ist das n√§chste interessante Beispiel.  Es scheint, dass wir festgestellt haben, dass die Sekunde nullwertf√§hig sein kann und √ºberpr√ºft werden muss, bevor etwas damit unternommen wird.  In diesem Fall erwarte ich, dass wir eine haben, wenn.  Wenn dieser Code bereitgestellt wird, wenn second ungleich Null ist, wird die Ausf√ºhrung meiner Meinung nach weiter gehen und nur zuerst ausgegeben. <br><br>  Wie entfaltet sich das alles wirklich im Java-Code?  Eigentlich wird es einen Scheck geben. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br>  Wir werden zun√§chst Intrinsics bekommen.  Nehmen wir an, ich sage das hier <br><br>  If wird zu einem tern√§ren Operator erweitert.  Abgesehen davon, obwohl wir sogar behoben haben, dass der erste Parameter nicht nullwertf√§hig sein kann, wird er dennoch √ºber Intrinsics √ºberpr√ºft. <br><br>  Intrinsics ist eine interne Klasse in Kotlin, die bestimmte Parameter und Pr√ºfungen enth√§lt.  Und jedes Mal, wenn Sie den Methodenparameter nicht nullbar machen, wird er trotzdem √ºberpr√ºft.  Warum?  Dann, dass wir in Interop Java arbeiten, und es kann vorkommen, dass Sie erwarten, dass es hier nicht nullbar ist, aber mit Java wird es von irgendwoher kommen. <br><br>  Wenn Sie dies √ºberpr√ºfen, wird es weiter entlang des Codes gehen, und dann werden Sie nach 10-20 Methodenaufrufen etwas mit einem Parameter tun, der zwar nicht nullwertf√§hig ist, sich aber aus irgendeinem Grund herausgestellt hat.  Alles wird auf Sie hereinfallen und Sie werden nicht verstehen k√∂nnen, was tats√§chlich passiert ist.  Um diese Situation zu vermeiden, m√ºssen Sie den Parameter null jedes Mal √ºberpr√ºfen, wenn Sie ihn √ºbergeben.  Und wenn es nullbar ist, gibt es eine Ausnahme. <br><br>  Dieser Scheck ist auch etwas wert, und wenn es viele davon gibt, wird es nicht sehr gut sein. <br><br>  Wenn wir jedoch √ºber HotSpot sprechen, dauern 10 Aufrufe dieser Intrinsics ungef√§hr vier Nanosekunden.  Dies ist sehr, sehr klein, und Sie sollten sich dar√ºber keine Sorgen machen, aber dies ist ein interessanter Faktor. <br><br><h2>  PRIMITIVE <br></h2><br>  In Java gibt es so etwas wie Primitive.  Wie wir alle wissen, gibt es in Kotlin keine Grundelemente, wir arbeiten immer mit Objekten.  In Java werden sie verwendet, um Objekten bei einigen kleineren Berechnungen eine h√∂here Leistung zu bieten.  Das Hinzuf√ºgen von zwei Objekten ist viel teurer als das Hinzuf√ºgen von zwei Grundelementen.  Betrachten Sie ein Beispiel. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  Es gibt drei Zahlen, f√ºr die die ersten beiden nicht Null-Typen abgeleitet werden, und f√ºr die dritte sagen wir, dass es nullbar sein kann. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  Wenn Sie sich den Bytecode ansehen und sehen, welcher Java-Code generiert wird, sind die ersten beiden Zahlen nicht null und k√∂nnen daher primitiv sein.  Das Grundelement kann jedoch keine Null enthalten. Dies kann nur ein Objekt. Daher wird ein Objekt f√ºr die dritte Zahl generiert. <br><br><h2>  AUTOBOXING <br></h2><br>  Wenn Sie mit Grundelementen arbeiten und eine Operation mit einem Grundelement und einem Nicht-Grundelement ausf√ºhren, m√ºssen Sie entweder eines davon in ein Grundelement oder in ein Objekt √ºbersetzen. <br><br>  Und es scheint nicht verwunderlich, dass Sie ein wenig an Leistung verlieren, wenn Sie Operationen mit nullable und nicht nullable in Kotlin ausf√ºhren.  Wenn es viele solcher Operationen gibt, verlieren Sie au√üerdem viel. <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Sehen Sie, wo Boxen / Unboxen hier sein wird?  Ich habe es auch nicht gesehen, bis ich mir den Bytecode angesehen habe. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  Eigentlich habe ich erwartet, dass es so etwas wie diesen Vergleich geben w√ºrde: Wenn die Zeichenfolge nicht null ist und wenn sie leer ist, dann auf true setzen, andernfalls auf false setzen.  Alles scheint einfach zu sein, aber in Wirklichkeit wird der folgende Code generiert: <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br>  Schauen wir mal rein.  Die Variable <em>a wird</em> genommen, sie wird in CharSequence umgewandelt, nachdem sie umgewandelt wurde, was auch f√ºr einige Zeit ausgegeben wurde, wird eine weitere Pr√ºfung aufgerufen - StringsKt.isBlank - auf diese Weise wird die Erweiterungsfunktion f√ºr CharSequence geschrieben, also wird sie umgewandelt und gesendet.  Da der erste Ausdruck nullwertf√§hig sein kann, nimmt er ihn und f√ºhrt Boxing aus und umschlie√üt alles in Boolean.valueOf.  Daher wird das wahre Grundelement auch zu einem Objekt, und erst danach findet die √úberpr√ºfung bereits statt und Intrinsics.areEqual wird aufgerufen. <br><br>  Es scheint eine so einfache Operation zu sein, aber ein so unerwartetes Ergebnis.  Tats√§chlich gibt es nur sehr wenige solche Dinge.  Aber wenn Sie nullable / nicht nullable haben k√∂nnen, k√∂nnen Sie eine Menge solcher Dinge generieren, und eines, das Sie nie erwartet h√§tten.  Daher empfehle ich Ihnen, sich so schnell wie m√∂glich von der Dunkelheit zu entfernen.  Das hei√üt,  <strong>Kommen Sie so fr√ºh wie m√∂glich zur Immunit√§t von Werten und entfernen Sie sich von nullable,</strong> damit Sie nicht so schnell wie m√∂glich null arbeiten. <br><br><h2>  Schleifen <br></h2><br>  Das n√§chste interessante Ding. <br><br>  Sie k√∂nnen das √ºbliche f√ºr verwenden, das in Java verf√ºgbar ist, aber Sie k√∂nnen auch die neue praktische API verwenden - schreiben Sie die Aufz√§hlung der Elemente in der Liste sofort. ,      work,  it  -   . <br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br>         .  ,    .    ,     Google,  ,       ArrayList   for   3  ,   .        . <br><br>    ,    ArrayList,     ‚Äî   foreach. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br>    API,     -  .     ,    Kotlin:   extension ,   ¬´¬ª,    reified, ..    ,    ,   ,    crossinline.      ,  ,    .  3  ,      Android  Google. <br><br><h2> RANGES <br></h2><br>        Ranges. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br>     : Unit     -.        ‚àí1,  until ,   ,    .   ,    ,    ranges.  Das hei√üt,   ,     .           step.    . <br><br><h2> INTRINSICS <br></h2><br> -  Intrinsics,      : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>    Intrinsics    ‚Äî   second,   first. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   ‚Äî Xno-param-assertions ‚Äî    Intrinsics,     . <br><br>    ,     ,     ,    ,     ,    .    ,    ,     ,    . <br><br><h2> REDEX <br></h2><br>  ,    ,    ,   Proguard.    ,   99%  ,     ,   .  Android 8.0  ,    .   ,      . <br><br>  ,    Proguard,   Facebook,   <strong>Redex</strong> .      -,        ,        . ,  Jvm Fields     ,         . <br><br>  ,  Redex   .  ,    ,      ,    Proguard,   ,    .          Redex    7%   APK.  ,   . <br><br><h2> BENCHMARKS </h2><br>   .     ,       ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,        . ,   dumpsys gfxinfo     ,       .   github  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>github.com/smred</strong></a>      . <br><br> ,     Huawei. <br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br>       .  ‚Äî ,     .     ,    ,    0,04 . ,  ,        ‚Äî   ,         . <br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br>      Kotlin,      .  ,    ,     .  - ,     Kotlin  ,   Java.    , , ,     ,      .       . <br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br> , ,    ,      ,  Kotlin          Java. , -    , ,  ,    ,    ,        . <br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br> ,   : -      Kotlin       , ..   .       ,     .    -             -  ‚Äî   2  ,    Galaxy S6,     . <br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br>    Google Pixel.     ,    0,1 . <br><br><h1>  SCHLUSSFOLGERUNGEN <br></h1><br>  ,   ,    ,  <br><br><ul><li>     UI   custom view. </li><li>    onmeasure-onlayout-ondraw.     autoboxing, not null   .. </li><li>       Kotlin,      Java ,        . </li><li>   ‚Äî . </li></ul><br>  ,   ,       .  ,  ,    , , Kotlin,     .       ,  Kotlin             . <br><br>    ,      . <br><br><blockquote>        brand new <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a> ,        Android   . ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,   8  9       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420143/">https://habr.com/ru/post/de420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420131/index.html">Probabilistische Bitcoin-Mining-Methode</a></li>
<li><a href="../de420133/index.html">Modellierung dynamischer Systeme: Wie bewegt sich der Mond?</a></li>
<li><a href="../de420135/index.html">Dies ist auch Toshiba: unerwartete Produkte des japanischen Unternehmens</a></li>
<li><a href="../de420139/index.html">Buch ‚ÄûSite Reliability Engineering. Zuverl√§ssigkeit und Zuverl√§ssigkeit wie bei Google ¬ª</a></li>
<li><a href="../de420141/index.html">Aus dem geladenen MPP DBMS - peppy Data Lake mit Analysetools: Teilen Sie die Details der Erstellung</a></li>
<li><a href="../de420145/index.html">Wie ist der Arbeitstag der Mitglieder der PC AppsConf</a></li>
<li><a href="../de420147/index.html">OpenSource auf Clojure</a></li>
<li><a href="../de420151/index.html">Einfacher als es klingt. Kapitel 12</a></li>
<li><a href="../de420153/index.html">3D-Druck komplexer Teile aus ABS und PLA mit viel Unterst√ºtzung</a></li>
<li><a href="../de420155/index.html">Intel Datacenter SSD. Gro√üe Mengen und neue Namen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>