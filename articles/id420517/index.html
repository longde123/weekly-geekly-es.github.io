<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎥 🤳🏻 🏇 Implementasi FFT Integer FPGA 🐎 🥗 🚴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Suatu kali, pelanggan bertanya kepada saya apakah saya memiliki FFT integer dalam proyek saya, yang saya selalu jawab bahwa ini suda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi FFT Integer FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420517/"> Halo semuanya! <br><br>  Suatu kali, pelanggan bertanya kepada saya apakah saya memiliki FFT integer dalam proyek saya, yang saya selalu jawab bahwa ini <u>sudah dilakukan oleh orang lain</u> dalam bentuk siap pakai, meskipun melengkung, tetapi core IP gratis (Altera / Xilinx) - ambil dan gunakan.  Namun, core ini <b>tidak optimal</b> , memiliki seperangkat "fitur" dan memerlukan penyempurnaan lebih lanjut.  Dalam hubungan ini, setelah pergi pada liburan terencana yang lain, yang saya tidak ingin menghabiskan biasa-biasa saja, saya mulai menerapkan kernel yang dapat dikonfigurasi dari integer FFT. <br><br><img src="https://habrastorage.org/webt/rn/s4/d1/rns4d1s48360ir8tjj1pwu7qcee.png"><br>  <sub><i>KDPV (proses debugging data error overflow)</i></sub> <br><br>  Dalam artikel ini saya ingin memberi tahu Anda apa metode dan cara operasi matematika direalisasikan ketika menghitung transformasi Fourier cepat dalam format integer pada kristal FPGA modern.  Dasar dari setiap FFT adalah simpul yang disebut "kupu-kupu".  Kupu-kupu mengimplementasikan operasi matematika - penambahan, perkalian dan pengurangan.  Ini adalah tentang implementasi "kupu-kupu" dan simpul-simpulnya yang sudah selesai yang akan menjadi cerita pertama.  Berdasarkan keluarga Xilinx FPGA modern - ini adalah seri Ultrascale dan Ultrascale +, serta seri 6 yang lebih lama (Virtex) dan 7- (Artix, Kintex, Virtex) terpengaruh.  Seri lama dalam proyek-proyek modern tidak menarik di 2018.  Tujuan artikel ini adalah untuk mengungkapkan fitur-fitur dari implementasi kernel khusus pemrosesan sinyal digital menggunakan contoh FFT. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Bukan rahasia bagi siapa pun bahwa algoritma untuk mengambil FFT tertanam kuat dalam kehidupan insinyur pemrosesan sinyal digital, dan oleh karena itu alat ini selalu dibutuhkan.  Pabrikan FPGA terkemuka seperti Altera / Xilinx sudah memiliki core FFT / IFFT yang dapat dikonfigurasi dengan fleksibel, tetapi mereka memiliki sejumlah keterbatasan dan fitur, dan oleh karena itu saya harus menggunakan pengalaman saya sendiri lebih dari sekali.  Jadi kali ini saya harus mengimplementasikan FFT dalam format integer sesuai dengan skema Radix-2 pada FPGA.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir saya, saya sudah melakukan FFT</a> dalam format floating point, dan dari sana Anda tahu bahwa algoritma dengan paralelisme ganda digunakan untuk mengimplementasikan FFT, yaitu, <b>inti dapat memproses dua sampel kompleks pada frekuensi yang sama</b> .  Ini adalah fitur FFT utama yang tidak tersedia di kernel siap pakai Xilinx FFT. <br><br>  <i>Contoh:</i> diperlukan untuk mengembangkan simpul FFT yang melakukan operasi kontinu dari aliran input bilangan kompleks pada frekuensi 800 MHz.  Inti dari Xilinx tidak akan melakukan ini (frekuensi clock pemrosesan yang dapat dicapai dalam FPGA modern adalah dari urutan 300-400 MHz), atau itu akan memerlukan menipiskan aliran input entah bagaimana.  Inti kustom memungkinkan Anda untuk mencatat dua sampel input pada frekuensi 400 MHz tanpa intervensi sebelumnya, alih-alih sampel tunggal pada 800 MHz.  <u>Kekurangan</u> lain <u>dari inti Filin Xilinx adalah ketidakmampuan untuk menerima aliran input dalam urutan bit-reverse</u> .  Dalam hubungan ini, sumber daya memori chip besar FPGA dihabiskan untuk mengatur ulang data dalam urutan normal.  Untuk tugas konvolusi sinyal yang cepat, ketika dua node FFT berdiri di belakang satu sama lain, ini bisa menjadi momen kritis, yaitu, tugas itu tidak akan terletak pada chip FPGA yang dipilih.  Inti FFT khusus memungkinkan Anda menerima data dalam urutan normal pada input, dan mengeluarkannya dalam mode bit-reverse, sedangkan inti dari FFT terbalik - sebaliknya, menerima data dalam urutan bit-reverse, dan mengeluarkannya dalam mode normal.  Dua buffer untuk permutasi data disimpan sekaligus !!! <br><br>  Karena sebagian besar materi dalam artikel ini bisa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpang tindih dengan yang sebelumnya</a> , saya memutuskan untuk fokus pada topik operasi matematika dalam format integer pada FPGA untuk implementasi FFT. <br><br><h3>  Parameter kernel FFT </h3><br><ul><li>  <i>NFFT</i> - jumlah kupu-kupu (panjang FFT), </li><li>  <i>DATA_WIDTH</i> - kedalaman bit data input (4-32), </li><li>  <i>TWDL_WIDTH</i> - kedalaman bit dari faktor belok (8-27). </li><li>  <i>SERIES</i> - mendefinisikan keluarga FPGA di mana FFT diimplementasikan ("BARU" - Ultrascale, "LAMA" - 6/7 seri Xilinx FPGA). </li></ul><br><img src="https://habrastorage.org/webt/jr/ko/rp/jrkorpz6jkzl7tiltyajcgy_2ns.png"><br><br>  Seperti tautan lainnya di sirkuit, FFT memiliki port kontrol input - sinyal jam dan reset, serta port data input dan output.  Selain itu, sinyal USE_FLY digunakan dalam kernel, yang memungkinkan Anda untuk mematikan kupu-kupu FFT secara dinamis untuk proses debugging atau untuk melihat aliran input asli. <br><br>  Tabel di bawah ini menunjukkan jumlah sumber daya FPGA yang digunakan, tergantung pada panjang NFFT FFT untuk DATA_WIDTH = 16 dan dua bit TWDL_WIDTH = 16 dan 24 bit. <br><br><img src="https://habrastorage.org/webt/12/cg/5d/12cg5dao_i8ihsv3-_0bqjufmgy.png"><br><br>  Inti pada NFFT = 64K stabil pada frekuensi pemrosesan <b>FREQ = 375 MHz</b> pada kristal Kintex-7 (410T). <br><br><h3>  Struktur proyek </h3><br><br>  Grafik skematis dari simpul FFT ditunjukkan pada gambar berikut: <br><img src="https://habrastorage.org/webt/af/4t/zx/af4tzxcjc6sltju9ldyi8clctz8.png"><br><br>  Untuk kenyamanan memahami fitur komponen tertentu, saya akan memberikan daftar file proyek dan deskripsi singkatnya dalam urutan hierarkis: <br><ul><li>  <b>Kernel FFT:</b> <br><ul><li>  <i>int_fftNk</i> - Node FFT, sirkuit Radix-2, penipisan frekuensi (DIF), aliran input normal, aliran output sedikit terbalik. </li><li>  <i>int_ifftNk</i> - Node <i>OBPF</i> , sirkuit Radix-2, penipisan waktu (DIT), aliran input sedikit terbalik, aliran keluaran normal. </li></ul></li><li>  <b>Kupu-kupu:</b> <br><br><ul><li>  <i>int_dif2_fly</i> - butterfly Radix-2, penipisan frekuensi, </li><li>  <i>int_dit2_fly</i> - butterfly Radix-2, penipisan waktu, </li></ul></li><li>  <b>Pengganda Kompleks:</b> <br><br><ul><li>  <i>int_cmult_dsp48</i> - pengganda yang dapat dikonfigurasi secara umum, termasuk: </li><li>  <i>int_cmult18x25_dsp48</i> - pengali untuk <i>kedalaman</i> bit kecil <i>dari</i> data dan faktor rotasi, </li><li>  <i>int_cmult_dbl18_dsp48</i> - pengganda berlipat ganda, lebar bit dari faktor belok hingga 18 bit, </li><li>  <i>int_cmult_dbl35_dsp48</i> - pengganda dua kali lipat, lebar bit dari faktor-faktor berputar hingga 25 * bit, </li><li>  <i>int_cmult_trpl18_dsp48</i> - pengali tiga, kapasitas faktor balik hingga 18 bit, </li><li>  <i>int_cmult_trpl52_dsp48</i> - pengali tiga, kapasitas faktor berputar hingga 25 * bit, </li></ul></li><li>  <b>Pengganda:</b> <br><br><ul><li>  <i>mlt42x18_dsp48e1</i> - pengganda dengan bit operan hingga 42 dan 18 bit berdasarkan DSP48E1, </li><li>  <i>mlt59x18_dsp48e1</i> - pengganda dengan bit operan hingga 59 dan 18 bit berdasarkan pada DSP48E1, </li><li>  <i>mlt35x25_dsp48e1</i> - pengganda dengan bit operan hingga 35 dan 25 bit berdasarkan DSP48E1, </li><li>  <i>mlt52x25_dsp48e1</i> - pengganda dengan bit operan hingga 52 dan 25 bit berdasarkan DSP48E1, </li><li>  <i>mlt44x18_dsp48e2</i> - pengganda dengan bit operan hingga 44 dan 18 bit berdasarkan DSP48E2, </li><li>  <i>mlt61x18_dsp48e2</i> - pengganda dengan bit operan hingga 61 dan 18 bit berdasarkan pada DSP48E2, </li><li>  <i>mlt35x27_dsp48e2</i> - pengganda dengan bit operan hingga 35 dan 27 bit berdasarkan pada DSP48E2, </li><li>  <i>mlt52x27_dsp48e2</i> adalah pengganda dengan bit operan hingga 52 dan 27 bit berdasarkan pada DSP48E2. </li></ul></li><li>  <b>Penghancur:</b> <br><br><ul><li>  <i>int_addsub_dsp48</i> - penambah universal, operan bit hingga 96 bit. </li></ul></li><li>  <b>Garis keterlambatan:</b> <br><br><ul><li>  <i>int_delay_line</i> - garis dasar penundaan, memberikan permutasi data antara kupu-kupu, </li><li>  <i>int_align_fft</i> - penyelarasan data input dan faktor balik pada input kupu-kupu FFT, </li><li>  <i>int_align_fft</i> - penyelarasan data input dan faktor balik pada input kupu-kupu <i>OBPF</i> , </li></ul></li><li>  <b>Rotating Factor:</b> <br><br><ul><li>  <i>rom_twiddle_int</i> - generator faktor rotari, dari panjang tertentu FFT mempertimbangkan koefisien berdasarkan sel FPGA DSP, </li><li>  <i>row_twiddle_tay</i> - generator faktor rotari menggunakan seri Taylor (NFFT&gt; 2K) **. </li></ul></li><li>  <b>Buffer data:</b> <br><br><ul><li>  <i>inbuf_half_path</i> - buffer input, menerima aliran dalam mode normal dan menghasilkan dua urutan sampel yang digeser setengah panjang FFT ***, </li><li>  <i>outbuf_half_path</i> - buffer output, mengumpulkan dua urutan dan menghasilkan satu kontinu yang sama dengan panjang FFT, </li><li>  <i>iobuf_flow_int2</i> - buffer berfungsi dalam dua mode: ia menerima aliran dalam mode Interleave-2 dan menghasilkan dua urutan FFT yang digeser setengah panjangnya.  Atau sebaliknya, tergantung pada opsi BITREV. </li><li>  <i>int_bitrev_ord</i> adalah konverter data sederhana dari urutan alami ke bit-mundur. </li></ul></li></ul><br>  <i>* - untuk DSP48E1: 25 bit, untuk DSP48E2 - 27 bit.</i> <br>  <i>** - dari tahap tertentu FFT, sejumlah memori blok dapat digunakan untuk menyimpan koefisien rotasi, dan koefisien antara dapat dihitung dengan menggunakan node DSP48 menggunakan rumus Taylor dengan turunan pertama.</i>  <i>Karena fakta bahwa sumber daya memori lebih penting untuk FFT, Anda dapat dengan aman mengorbankan unit komputasi demi memori.</i> <i><br></i>  <i>*** - garis buffer dan delay input - memberikan kontribusi signifikan terhadap jumlah sumber daya memori FPGA yang diduduki</i> <br><br>  <b>Kupu-kupu</b> <br><br>  Setiap orang yang setidaknya pernah mengalami algoritma transformasi Fourier cepat tahu bahwa algoritma ini didasarkan pada operasi dasar - "kupu-kupu".  Ini mengubah input stream dengan mengalikan input dengan faktor twiddle.  Ada dua skema konversi klasik untuk FFT - penipisan dalam frekuensi (DIF, penipisan-dalam-frekuensi) dan penipisan dalam waktu (DIT, penipisan-dalam-waktu).  Algoritme DIT ditandai dengan membagi urutan input menjadi dua urutan durasi setengah, dan algoritma DIF menjadi dua urutan sampel genap dan ganjil dari durasi NFFT.  Selain itu, algoritma ini berbeda dalam operasi matematika untuk operasi kupu-kupu. <br><br><img src="https://habrastorage.org/webt/ka/d9/hr/kad9hr8dktrs2l7jhb9iq3lm6em.png"><br><br>  <i>A, B</i> - pasang input sampel kompleks, <br>  <i>X, Y</i> - pasangan keluaran sampel kompleks, <br>  Faktor balik <i>W</i> - kompleks. <br><br>  Karena data input adalah jumlah yang kompleks, kupu-kupu memerlukan satu pengali kompleks (4 operasi perkalian dan 2 operasi penambahan) dan dua penambahan kompleks (4 operasi penambahan).  Ini adalah seluruh dasar matematika yang harus diimplementasikan pada FPGA. <br><br><h3>  Pengganda </h3><br>  Perlu dicatat bahwa semua operasi matematika pada FPGA sering dilakukan dalam kode tambahan (komplemen 2's).  Pengganda FPGA dapat diimplementasikan dalam dua cara - pada logika menggunakan pemicu dan tabel LUT, atau pada unit perhitungan DSP48 khusus, yang telah lama dan tegas dimasukkan dalam semua FPGA modern.  Pada blok logis, penggandaan diimplementasikan menggunakan algoritma Booth atau modifikasinya, membutuhkan sumber daya logis yang layak dan tidak selalu memenuhi batasan waktu pada frekuensi pemrosesan data yang tinggi.  Dalam hal ini, pengganda FPGA dalam proyek modern hampir selalu dirancang berdasarkan node DSP48 dan hanya sesekali pada logika.  Node DSP48 adalah sel jadi kompleks yang mengimplementasikan fungsi matematika dan logis.  Operasi dasar: penggandaan, penambahan, pengurangan, akumulasi, penghitung, operasi logis (XOR, NAND, AND, OR, NOR), kuadrat, perbandingan angka, shift, dll.  Gambar berikut menunjukkan sel DSP48E2 untuk keluarga Xilinx Ultrascale + FPGA. <br><br><img src="https://habrastorage.org/webt/rz/_w/bu/rz_wbuxd3sx1d1llz0psh-8tt1e.png"><br><br>  Melalui konfigurasi port input yang sederhana, operasi perhitungan dalam node dan penundaan pengaturan di dalam node, Anda dapat membuat data matematika berkecepatan tinggi. <br>  Perhatikan bahwa semua vendor FPGA teratas dalam lingkungan pengembangan memiliki core IP standar dan gratis untuk menghitung fungsi matematika berdasarkan pada simpul DSP48.  Mereka memungkinkan Anda untuk menghitung fungsi matematika primitif dan mengatur berbagai penundaan pada input dan output dari node.  Untuk Xilinx, ini adalah IP-Core "pengganda" (ver. 12.0, 2018), yang memungkinkan Anda untuk mengonfigurasikan pengganda ke kedalaman bit data input mulai dari 2 hingga 64 bit.  Selain itu, Anda dapat menentukan bagaimana pengali diimplementasikan - pada sumber daya logis atau pada primitif DSP48 bawaan. <br><br>  <b>Perkirakan berapa banyak logika pengali "makan"</b> dengan kedalaman bit dari input data pada port A dan B = 64 bit.  Jika Anda menggunakan node DSP48, maka mereka hanya perlu 16. <br><br><img src="https://habrastorage.org/webt/r5/_e/pb/r5_epbvkf-45ayqoi8jebye_rcu.png"><br><br>  Keterbatasan utama pada sel DSP48 adalah kedalaman bit dari data input.  Node DSP48E1, yang merupakan sel dasar dari seri FPGA Xilinx 6 dan 7, lebar port input untuk perkalian: "A" - 25 bit, "B" - 18 bit, Oleh karena itu, hasil penggandaan adalah angka 43-bit.  Untuk keluarga Xilinx Ultrascale dan Ultrascale + FPGA, node telah mengalami beberapa perubahan, khususnya, kapasitas port pertama meningkat dua bit: "A" - 27 bit, "B" - 18 - bit.  Selain itu, simpul itu sendiri disebut DSP48E2. <br><br>  Agar tidak terikat dengan keluarga tertentu dan chip FPGA, untuk memastikan "kemurnian kode sumber", dan untuk memperhitungkan semua kedalaman bit yang mungkin dari data input, diputuskan untuk merancang set pengganda sendiri.  Ini akan memungkinkan implementasi pengganda kompleks yang paling efisien untuk kupu-kupu FFT, yaitu, pengganda dan pengurang-penambah berdasarkan blok DSP48.  Input pertama dari pengali adalah input data, input kedua dari pengali adalah faktor-faktor yang berputar (sinyal harmonik dari memori).  Seperangkat pengganda diimplementasikan menggunakan pustaka UNISIM bawaan, yang darinya perlu untuk menghubungkan primitif DSP48E1 dan DSP48E2 untuk digunakan lebih lanjut dalam proyek.  Satu set pengganda disajikan dalam tabel.  Perlu dicatat bahwa: <br><br><ul><li>  Pengoperasian angka yang berlipat ganda mengarah pada peningkatan kapasitas produk sebagai jumlah dari kapasitas operan. </li><li>  Setiap pengganda 25x18 dan 27x18 digandakan, pada kenyataannya - ini adalah salah satu komponen untuk keluarga yang berbeda. </li><li>  Semakin besar tahap paralelisme operasi, semakin besar keterlambatan dalam komputasi dan semakin besar jumlah sumber daya yang digunakan. </li><li>  Dengan kedalaman bit yang lebih rendah pada input "B", pengganda dengan kedalaman bit yang lebih tinggi pada input lain dapat diimplementasikan. </li><li>  Keterbatasan utama dalam meningkatkan kedalaman bit diperkenalkan oleh port "B" (port sebenarnya dari DSP48 primitif) dan register geser internal sebesar 17-bit. </li></ul><br><img src="https://habrastorage.org/webt/aw/ma/p9/awmap93marfh0kvrj8loqdrekoo.png"><br><br>  Peningkatan kedalaman bit lebih lanjut tidak menarik dalam kerangka tugas karena alasan yang dijelaskan di bawah ini: <br><br><h3>  Kedalaman faktor pembalikan </h3><br>  Diketahui bahwa semakin besar resolusi sinyal harmonik, semakin akurat jumlahnya muncul (semakin banyak tanda di bagian fraksional).  Tetapi ukuran bit port adalah B &lt;25 bit karena fakta bahwa untuk faktor-faktor rotasi dalam node FFT, kedalaman bit ini cukup untuk memastikan penggandaan kualitas tinggi dari input stream dengan elemen sinyal harmonik dalam "kupu-kupu" (untuk setiap panjang FFT yang dapat dicapai secara realistis pada FPGA modern).  Nilai khas dari kedalaman bit dari koefisien balik dalam tugas yang saya laksanakan adalah 16 bit, 24 - lebih jarang, 32 - tidak pernah. <br><br><h3>  Kedalaman sampel input sedikit </h3><br>  Kapasitas node penerimaan dan perekaman (ADCs, DACs) ini tidak besar - dari 8 hingga 16 bit, dan jarang - 24 atau 32 bit.  Selain itu, dalam kasus yang terakhir, akan lebih efisien untuk menggunakan format data floating point sesuai dengan standar IEEE-754.  Di sisi lain, setiap tahap "kupu-kupu" di FFT menambahkan satu bit data ke sampel keluaran karena operasi matematika.  Misalnya, untuk panjang NFFT = 1024, log2 (NFFT) = 10 kupu-kupu digunakan. <br><br>  Oleh karena itu, kedalaman bit output akan sepuluh bit lebih besar dari input, WOUT = WIN + 10. Secara umum, rumusnya terlihat seperti ini: <br><br>  WOUT = WIN + log2 (NFFT); <br><br>  Contoh: <br><br>  Kedalaman bit dari aliran input MENANG = 32 bit, <br>  Kedalaman bit dari faktor belok TWD = 27, <br>  Kapasitas port “A” dari daftar pengganda yang diimplementasikan dalam artikel ini tidak melebihi 52 bit.  Ini berarti bahwa jumlah maksimum kupu-kupu adalah FFT = 52-32 = 20. Artinya, dimungkinkan untuk mewujudkan FFT dengan panjang hingga 2 ^ 20 = 1M sampel.  (Namun, dalam praktiknya, ini tidak mungkin dengan cara langsung karena sumber daya yang terbatas bahkan untuk kristal FPGA yang paling kuat, tetapi ini berkaitan dengan topik lain dan tidak akan dipertimbangkan dalam artikel). <br><br>  Seperti yang Anda lihat, ini adalah salah satu alasan utama mengapa saya tidak mengimplementasikan pengganda dengan kedalaman bit input port yang lebih tinggi.  <b>Pengganda yang digunakan mencakup berbagai</b> ukuran <b>bit</b> input yang <b>diperlukan</b> dan faktor rotasi untuk tugas menghitung FFT integer.  Dalam semua kasus lain, Anda dapat menggunakan perhitungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>FFT dalam format floating point</b></a> ! <br><br><h3>  Implementasi pengganda "lebar" </h3><br>  Berdasarkan contoh sederhana mengalikan dua angka yang tidak sesuai dengan kedalaman bit dari simpul DSP48 standar, saya akan menunjukkan bagaimana Anda dapat mengimplementasikan pengganda data yang luas.  Gambar berikut menunjukkan diagram bloknya.  Pengganda mengimplementasikan perkalian dua angka yang ditandatangani dalam kode tambahan, lebar operan X pertama adalah 42 bit, Y kedua adalah 18 bit.  Ini berisi dua node DSP48E2.  Dua register digunakan untuk menyamakan penundaan di simpul atas.  Ini dilakukan karena di adder atas Anda perlu menambahkan angka dengan benar dari simpul atas dan bawah DSP48.  Pengiklan bawah sebenarnya tidak digunakan.  Pada output dari simpul bawah ada penundaan tambahan produk untuk menyelaraskan nomor keluaran dengan waktu.  Total keterlambatan adalah 4 siklus. <br><br><img src="https://habrastorage.org/webt/rp/_t/he/rp_the-qaroc7pgzedutsbcb-ee.png"><br><br>  Pekerjaan terdiri dari dua komponen: <br><br><ul><li>  Bagian termuda: <b>P1 = '0' &amp; X [16: 0] * Y [17: 0];</b> </li><li>  Bagian yang lebih tua: <b>P2 = X [42:17] * Y [17: 0] + (P1 &gt;&gt; 17);</b> </li></ul><br><h3>  Penghancur </h3><br>  Seperti pengganda, penambah dapat dibangun di atas sumber daya logis menggunakan rantai transfer, atau di blok DSP48.  Untuk mencapai throughput maksimum, metode kedua lebih disukai.  Satu DSP48 primitif memungkinkan implementasi operasi penambahan hingga 48 bit, dua node hingga 96 bit.  Untuk tugas saat ini, kedalaman bit tersebut cukup.  Selain itu, DSP48 primitif memiliki mode "SIMD MODE" khusus, yang memaralelkan ALU 48-bit bawaan ke dalam beberapa operasi dengan data yang berbeda dari kapasitas kecil.  Yaitu, dalam mode “SATU” digunakan kisi bit penuh 48 bit dan dua operan, dan dalam mode “DUA” kisi bit dibagi menjadi beberapa aliran paralel masing-masing 24 bit (4 operan).  Mode ini, dengan menggunakan hanya satu penambah, membantu mengurangi jumlah sumber daya chip FPGA yang diduduki pada kedalaman bit sampel sampel yang kecil (pada tahap pertama perhitungan). <br><br><h3>  Peningkatan kedalaman bit </h3><br>  Operasi <b>mengalikan</b> dua angka dengan bit N dan M dalam kode tambahan biner mengarah pada peningkatan kapasitas bit output ke <b>P = N + M.</b> <br><br>  Contoh: untuk mengalikan angka tiga-bit N = M = 3, angka positif maksimum adalah +3 = <i>(011) <sub>2</sub></i> , dan angka negatif maksimum adalah 4 = <i>(100) <sub>2</sub></i> .  Bit paling signifikan bertanggung jawab atas tanda nomor.  Oleh karena itu, jumlah maksimum yang mungkin ketika mengalikan adalah +16 = <i>(010000) <sub>2</sub></i> , yang dibentuk sebagai hasil dari mengalikan dua angka negatif maksimum -4.  Kedalaman bit dari output sama dengan jumlah bit input P = N + M = 6 bit. <br><br>  Operasi <b>menambahkan</b> dua angka dengan bit N dan M dalam kode tambahan biner mengarah pada peningkatan bit output dengan satu bit. <br><br>  Contoh: tambahkan dua angka positif, N = M = 3, angka positif maksimum adalah 3 = <i>(011) <sub>2</sub></i> , dan angka negatif maksimum adalah 4 = <i>(100) <sub>2</sub></i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit paling signifikan bertanggung jawab atas tanda nomor. </font><font style="vertical-align: inherit;">Oleh karena itu, angka positif maksimum adalah 6 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0110) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan angka negatif maksimum adalah -8 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1000) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Resolusi output meningkat satu bit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertimbangan fitur algoritma </font></font></h3><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemotongan kedalaman bit dari atas:</font></font></b></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk meminimalkan sumber daya FPGA dalam algoritma FFT, diputuskan bahwa ketika mengalikan data dalam kupu-kupu, jangan pernah menggunakan angka negatif maksimum yang mungkin untuk mengubah koefisien. Amandemen ini tidak mempengaruhi hasil. Misalnya, ketika menggunakan representasi 16-bit dari faktor rotasi, angka minimum adalah -32768 = 0x8000, dan yang berikutnya -32767 = 0x8001. Kesalahan saat mengganti angka negatif maksimum dengan nilai tetangga terdekat akan</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ~ 0,003%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan sepenuhnya dapat diterima untuk tugas tersebut.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan menghapus angka minimum dalam produk dua angka, pada setiap iterasi Anda dapat mengurangi satu bit orde tinggi yang tidak terpakai. Contoh: data - 4 = (100)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , koefisien +3 = (011)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hasil Multiplikasi = -12 = (110100) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bit kelima bisa dibuang karena duplikat tetangga, yang keempat adalah sedikit tanda. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemotongan bit dari bawah:</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, mengalikan sinyal input dalam "kupu-kupu" dengan efek harmonik, tidak perlu menarik kedalaman bit output ke kupu-kupu berikutnya, tetapi pembulatan atau pemotongan diperlukan. Rotating factor disajikan dalam format M-bit yang nyaman, tetapi pada kenyataannya itu adalah sinus normal dan cosinus dinormalisasi menjadi satu. Yaitu, angka 0x8000 = -1, dan angka 0x7FFF = +1. Oleh karena itu, hasil penggandaan harus dipotong ke kedalaman bit asli dari data (yaitu, bit M dari faktor-faktor yang berputar dipotong dari bawah). Dalam semua implementasi FFT yang kebetulan saya lihat, faktor balik dinormalisasi menjadi 1 dengan satu atau lain cara. Oleh karena itu, dari hasil perkalian perlu untuk mengambil bit dalam kisi berikut [N + M-1-1: M-1]. Bit yang paling signifikan tidak digunakan (kurangi 1 tambahan), bit paling tidak signifikan dipotong.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penambahan / pengurangan data dalam operasi "kupu-kupu" tidak diminimalisasi dengan cara apa pun, dan hanya operasi ini yang berkontribusi terhadap </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peningkatan kedalaman bit dari data output dengan satu bit pada setiap tahap perhitungan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa pada tahap pertama dari algoritma DFT FFT atau pada tahap terakhir dari algoritma FFT DIF, data harus dikalikan dengan faktor balik dengan indeks nol W0 = {Re, Im} = {1, 0}. Karena fakta bahwa perkalian dengan persatuan dan nol adalah operasi primitif, mereka dapat dihilangkan. Dalam hal ini, operasi multiplikasi kompleks tidak diperlukan sama sekali: komponen nyata dan imajiner mengalami "belokan" tanpa perubahan. Pada tahap kedua, dua koefisien digunakan: W0 = {Re, Im} = {1, 0} dan W1 = {Re, Im} = {0, -1}. Demikian pula, operasi dapat direduksi menjadi transformasi elementer dan menggunakan multiplexer untuk memilih sampel keluaran. Ini memungkinkan Anda untuk secara signifikan menyimpan blok DSP48 pada dua kupu-kupu pertama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengganda kompleks dibangun dengan cara yang sama - berdasarkan pengganda dan pengurang-penambah, untuk beberapa opsi untuk kedalaman bit data input, sumber daya tambahan tidak diperlukan, yang akan dijelaskan di bawah ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garis input buffer dan delay dan cross-switch mirip dengan yang dijelaskan dalam artikel sebelumnya. </font><font style="vertical-align: inherit;">Rotating factor menjadi bilangan bulat dengan kedalaman bit yang dapat dikonfigurasi. </font><font style="vertical-align: inherit;">Kalau tidak, tidak ada perubahan global dalam desain inti FFT.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fitur inti FFT INT_FFTK </font></font></h3><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Skema pemrosesan data sepenuhnya pipelined. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panjang konversi NFFT = 8-512K poin. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penyesuaian panjang konversi NFFT yang fleksibel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format input integer, lebar bit dapat dikonfigurasi. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format bilangan bulat dari faktor rotari, lebar bit dapat dikonfigurasi. </font></font></li><li>            . </li><li>          ! </li><li>        . </li><li> :    –   ,    -. </li><li> :     - ,   –  . </li><li>      . Radix-2. </li><li>       NFFT *. </li><li>        . </li><li>      (Virtex-6, 7-Series, Ultrascale). </li><li>    <b>~375MHz</b>  Kintex-7 </li><li>   – VHDL. </li><li>     bitreverse   +. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyek open source tanpa menyertakan IP-core pihak ketiga. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode sumber </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode sumber untuk kernel FFT INTFFTK pada VHDL (termasuk operasi dasar dan satu set pengganda) dan skrip m untuk Matlab / Octave </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tersedia di profil saya di github</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3>  Kesimpulan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama pengembangan, inti FFT baru dirancang, yang memberikan kinerja lebih besar dibandingkan dengan rekan-rekan. </font><font style="vertical-align: inherit;">Kombinasi core FFT dan OBPF tidak memerlukan terjemahan ke dalam urutan alami, dan panjang konversi maksimum hanya dibatasi oleh sumber daya FPGA. </font><font style="vertical-align: inherit;">Konkurensi ganda memungkinkan Anda memproses aliran input frekuensi ganda, yang tidak dapat dilakukan IP-CORE Xilinx. </font><font style="vertical-align: inherit;">Kedalaman bit pada output integer FFT meningkat secara linear tergantung pada jumlah tahap konversi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel sebelumnya, saya menulis tentang rencana masa depan: inti FFT Radix-4, Radix-8, Ultra-Long FFT untuk jutaan poin, FFT-FP32 (dalam format IEEE-754). </font><font style="vertical-align: inherit;">Singkatnya, hampir semuanya diizinkan, tetapi karena satu dan lain alasan, saat ini mereka tidak dapat dipublikasikan. </font><font style="vertical-align: inherit;">Pengecualiannya adalah algoritma FFT Radix-8, yang bahkan tidak saya pedulikan (sulit dan malas). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekali lagi, saya mengucapkan terima kasih kepada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dsmv2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang selalu menyambut ide-ide petualangan saya.</font></font> Terima kasih atas perhatian anda! <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PEMBARUAN 2018/08/22 </font></font></h3><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menambahkan opsi SCALED FFT / IFFT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke kode sumber </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pada setiap kupu-kupu, kedalaman bit dipotong oleh 1 bit (truncate LSB). </font><font style="vertical-align: inherit;">Output bit depth = kedalaman bit input. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, saya akan memberikan dua grafik lintasan sinyal nyata melalui FPGA untuk menunjukkan properti integral dari transformasi, yaitu: bagaimana pemotongan mempengaruhi hasil akumulasi kesalahan pada output FFT. </font><font style="vertical-align: inherit;">Dari teori diketahui bahwa sebagai hasil dari transformasi Fourier, sinyal-to-noise ratio memburuk ketika sinyal input terpotong relatif terhadap versi non-terpotong. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh: Amplitudo dari amplitudo input adalah 6 bit. </font><font style="vertical-align: inherit;">Sinyal adalah gelombang sinus pada 128 sampel PF. </font><font style="vertical-align: inherit;">NFFT = 1024 sampel, DATA_WIDTH = 16, TWDL_WIDTH = 16.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dua grafik lintasan sinyal melalui FFT</font></font></b> <div class="spoiler_text">  <b>Fig.</b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Rasio sinyal terhadap noise lemah:</font></font></b> <br><img src="https://habrastorage.org/webt/ww/4b/rg/ww4brg3lv-rb1i_52hqggjfv4fw.png"><br><br>  <b>Fig.</b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 Rasio sinyal terhadap noise kuat:</font></font></b> <br><img src="https://habrastorage.org/webt/kx/uh/go/kxuhgoybynu2kiduizld8r6fvmo.png"><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merah Muda - FFT UNSCALED, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biru - FFT SCALED. </font></font></li></ul><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang Anda lihat, opsi SCALED tidak "menarik" gelombang sinus keluar dari kebisingan, sementara opsi UNSCALED menunjukkan hasil yang baik. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420517/">https://habr.com/ru/post/id420517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420507/index.html">Latar Belakang: Internet global untuk semua dan penciptanya</a></li>
<li><a href="../id420509/index.html">Masalah yang jelas dengan menggunakan menegaskan</a></li>
<li><a href="../id420511/index.html">Bekerja sebagai spesialis IT di Timur Jauh - Wilayah Amur</a></li>
<li><a href="../id420513/index.html">Salinan bajakan dari layanan berbayar dalam 39 baris kode Python</a></li>
<li><a href="../id420515/index.html">Diarisasi berdasarkan model GMM-UBM dan algoritma adaptasi MAP</a></li>
<li><a href="../id420519/index.html">Mempopulerkan sains</a></li>
<li><a href="../id420521/index.html">Sekarang secara resmi: TLS 1.3 diakui sebagai standar</a></li>
<li><a href="../id420523/index.html">Analisis grafik opsi biner atau bagaimana saya sekali lagi membuktikan pada diri saya bahwa gratis tidak ada</a></li>
<li><a href="../id420525/index.html">Jaringan untuk yang paling berpengalaman. Bagian lima belas. QoS</a></li>
<li><a href="../id420527/index.html">Senyum bisa terdengar dan menular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>