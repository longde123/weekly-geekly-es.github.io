<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🏭 🤮 🥋 Ankündigung von TypeScript 3.4 RC 🔸 👐🏿 👨🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Tagen haben wir die Verfügbarkeit unseres Release Candidate (RC) von TypeScript 3.4 angekündigt. Wir hoffen, Feedback und frühe Ausgaben z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ankündigung von TypeScript 3.4 RC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/443996/"><p>  Vor einigen Tagen haben wir die Verfügbarkeit unseres Release Candidate (RC) von TypeScript 3.4 angekündigt.  Wir hoffen, Feedback und frühe Ausgaben zu sammeln, um sicherzustellen, dass unsere endgültige Version einfach zu erfassen und sofort zu verwenden ist. </p><br><p>  Um mit der Verwendung des RC zu beginnen, können Sie ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">über NuGet herunterladen</a> oder npm mit dem folgenden Befehl verwenden: </p><br><pre><code class="javascript hljs">npm install -g typescript@rc</code> </pre> <br><p>  Sie können auch Editor-Unterstützung von erhalten </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Herunterladen für Visual Studio 2017</a> (für Version 15.2 oder höher) </li><li>  Befolgen Sie die Anweisungen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Visual Studio Code</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sublime Text</a> . </li></ul><br><p>  Lassen Sie uns untersuchen, was in 3.4 neu ist! </p><br><img src="https://habrastorage.org/webt/rh/0u/3d/rh0u3dh_1qkmnyia12ksyuuozso.jpeg"><a name="habracut"></a><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel in unserem Blog.</a> <br><br><h2>  Schnellere nachfolgende Builds mit dem Flag <code>--incremental</code> </h2><br><p>  Da TypeScript-Dateien kompiliert werden, wird ein Zwischenschritt zwischen dem Schreiben und Ausführen Ihres Codes eingeführt.  Eines unserer Ziele ist es, die Bauzeit bei Änderungen an Ihrem Programm zu minimieren.  Eine Möglichkeit, dies zu tun, besteht darin, TypeScript im <code>--watch</code> Modus <code>--watch</code> .  Wenn sich eine Datei im <code>--watch</code> Modus ändert, kann TypeScript <code>--watch</code> des zuvor erstellten Abhängigkeitsdiagramms Ihres Projekts ermitteln, welche Dateien möglicherweise betroffen sind und erneut überprüft und möglicherweise erneut ausgegeben werden müssen.  Dies kann eine vollständige Typprüfung und erneute Ausgabe vermeiden, was kostspielig sein kann. </p><br><p>  Es ist jedoch unrealistisch zu erwarten, dass <em>alle</em> Benutzer einen <code>tsc --watch</code> Prozess über Nacht <code>tsc --watch</code> , um morgen früh schnellere Builds zu erhalten.  Was ist mit kalten Builds?  In den letzten Monaten haben wir daran gearbeitet, ob es eine Möglichkeit gibt, die entsprechenden Informationen aus dem <code>--watch</code> Modus in einer Datei zu speichern und von Build zu Build zu verwenden. </p><br><p>  TypeScript 3.4 führt ein neues Flag namens <code>--incremental</code> das TypeScript <code>--incremental</code> , Informationen über das Projektdiagramm aus der letzten Kompilierung zu speichern.  <code>--incremental</code> TypeScript das nächste Mal mit <code>--incremental</code> aufgerufen <code>--incremental</code> , werden diese Informationen verwendet, um die kostengünstigste Methode zur Typprüfung und Ausgabe von Änderungen an Ihrem Projekt zu ermitteln. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tsconfig.json { "compilerOptions": { "incremental": true, "outDir": "./lib" }, "include": ["./src"] }</span></span></code> </pre> <br><p>  Standardmäßig <code>tsc</code> TypeScript bei diesen Einstellungen beim Ausführen von <code>.tsbuildinfo</code> in unserem Ausgabeverzeichnis ( <code>./lib</code> ) nach einer Datei mit dem Namen <code>.tsbuildinfo</code> .  Wenn <code>./lib/.tsbuildinfo</code> nicht vorhanden ist, wird es generiert.  In diesem Fall versucht <code>tsc</code> , diese Datei zu verwenden, um unsere Ausgabedateien schrittweise zu überprüfen und zu aktualisieren. </p><br><p>  Diese <code>.tsbuildinfo</code> Dateien können sicher gelöscht werden und haben zur Laufzeit keine Auswirkungen auf unseren Code. Sie dienen lediglich dazu, die Kompilierung zu beschleunigen.  Wir können sie auch beliebig <code>--tsBuildInfoFile</code> und sie mit dem Flag <code>--tsBuildInfoFile</code> beliebigen Stelle <code>--tsBuildInfoFile</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// front-end.tsconfig.json { "compilerOptions": { "incremental": true, "tsBuildInfoFile": "./buildcache/front-end", "outDir": "./lib" }, "include": ["./src"] }</span></span></code> </pre> <br><p>  Solange niemand anderes versucht, in dieselbe Cache-Datei zu schreiben, sollten wir in der Lage sein, schnellere inkrementelle Cold-Builds zu genießen. </p><br><h3>  Zusammengesetzte Projekte </h3><br><p>  Ein Teil der Absicht bei zusammengesetzten Projekten ( <code>tsconfig.json</code> s mit zusammengesetztem <code>composite</code> auf <code>true</code> ) besteht darin, dass Referenzen zwischen verschiedenen Projekten inkrementell erstellt werden können.  Daher erstellen zusammengesetzte Projekte <strong>immer</strong> <code>.tsbuildinfo</code> Dateien. </p><br><h3> <code>outFile</code> </h3> <br><p>  Wenn <code>outFile</code> verwendet wird, basiert der Name der Build-Informationsdatei auf dem Namen der Ausgabedatei.  Wenn unsere JavaScript-Ausgabedatei beispielsweise <code>./output/foo.js</code> <code>--incremental</code> , generiert TypeScript unter dem Flag <code>--incremental</code> die Datei <code>./output/foo.tsbuildinfo</code> .  Wie oben kann dies mit dem Flag <code>--tsBuildInfoFile</code> gesteuert werden. </p><br><h3>  Das <code>--incremental</code> Dateiformat und die Versionierung </h3><br><p>  Während die von <code>--incremental</code> generierte Datei JSON ist, <code>--incremental</code> die Datei nicht von einem anderen Tool verwendet werden.  Wir können keine Garantie für die Stabilität des Inhalts geben. Unsere derzeitige Richtlinie lautet, dass eine Version von TypeScript <code>.tsbuildinfo</code> Dateien, die aus einer anderen Version generiert wurden, nicht versteht. </p><br><h2>  Verbesserungen für <code>ReadonlyArray</code> und <code>readonly</code> Tupel </h2><br><p>  TypeScript 3.4 erleichtert die Verwendung von schreibgeschützten Array-ähnlichen Typen ein wenig. </p><br><h3>  Eine neue Syntax für <code>ReadonlyArray</code> </h3><br><p>  Der <code>ReadonlyArray</code> Typ beschreibt <code>Array</code> , aus denen nur gelesen werden kann.  Jede Variable mit einem Handle für ein <code>ReadonlyArray</code> kann keine Elemente des Arrays hinzufügen, entfernen oder ersetzen. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr: ReadonlyArray&lt;string&gt;</span></span></span><span class="hljs-function">) </span></span>{ arr.slice(); <span class="hljs-comment"><span class="hljs-comment">// okay arr.push("hello!"); // error! }</span></span></code> </pre> <br><p>  Während es oft eine gute Praxis ist, <code>ReadonlyArray</code> über <code>Array</code> zum Zweck der Absicht zu verwenden, war es oft ein Schmerz, da Arrays eine schönere Syntax haben.  Insbesondere ist <code>number[]</code> eine Kurzversion von <code>Array&lt;number&gt;</code> , ebenso wie <code>Date[]</code> eine Kurzform für <code>Array&lt;Date&gt;</code> . </p><br><p>  TypeScript 3.4 führt eine neue Syntax für <code>ReadonlyArray</code> , die einen neuen <code>readonly</code> Modifikator für Array-Typen verwendet. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr: readonly string[]</span></span></span><span class="hljs-function">) </span></span>{ arr.slice(); <span class="hljs-comment"><span class="hljs-comment">// okay arr.push("hello!"); // error! }</span></span></code> </pre> <br><h3>  <code>readonly</code> Tupel </h3><br><p>  TypeScript 3.4 <code>readonly</code> außerdem eine neue Unterstützung für <code>readonly</code> Tupel.  Wir können jedem <code>readonly</code> Schlüsselwort <code>readonly</code> , um es zu einem <code>readonly</code> Tupel zu machen, ähnlich wie wir es jetzt mit der Array-Kurzschrift-Syntax tun können.  Wie zu erwarten ist, erlauben <code>readonly</code> Tupel im Gegensatz zu normalen Tupeln, in die Slots geschrieben werden können, nur das Lesen von diesen Positionen aus. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pair: readonly [string, string]</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// okay pair[1] = "hello!"; // error }</span></span></code> </pre> <br><p>  Genauso wie gewöhnliche Tupel Typen sind, die sich von <code>Array</code> aus erstrecken - ein Tupel mit Elementen vom Typ <code>T</code> <sub><code>1</code></sub> , <code>T</code> <sub><code>2</code></sub> , ... <code>T</code> <sub><code>n</code></sub> erstreckt sich von <code>Array&lt;</code> <code>T</code> <sub><code>1</code></sub> |  <code>T</code> <sub><code>2</code></sub> |  ... <code>T</code> <sub><code>n</code></sub> <code>&gt;</code> - <code>readonly</code> Tupel sind Typen, die sich von <code>ReadonlyArray</code> .  Ein <code>readonly</code> Tupel mit den Elementen <code>T</code> <sub><code>1</code></sub> , <code>T</code> <sub><code>2</code></sub> , ... <code>T</code> <sub><code>n</code></sub> erstreckt sich also von <code>ReadonlyArray&lt;</code> <code>T</code> <sub><code>1</code></sub> |  <code>T</code> <sub><code>2</code></sub> |  ... <code>T</code> <sub><code>n</code></sub> <code>&gt;</code> . </p><br><h3>  <code>readonly</code> zugeordnete <code>readonly</code> und <code>readonly</code> Arrays </h3><br><p>  In früheren Versionen von TypeScript haben wir zugeordnete Typen so verallgemeinert, dass sie bei Array-ähnlichen Typen unterschiedlich funktionieren.  Dies bedeutete, dass ein zugeordneter Typ wie <code>Boxify</code> auf Arrays und Tupeln gleichermaßen <code>Boxify</code> konnte. </p><br><pre> <code class="javascript hljs">interface Box&lt;T&gt; { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: T } type Boxify&lt;T&gt; = { [K <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keyof T]: Box&lt;T[K]&gt; } <span class="hljs-comment"><span class="hljs-comment">// { a: Box&lt;string&gt;, b: Box&lt;number&gt; } type A = Boxify&lt;{ a: string, b: number }&gt;; // Array&lt;Box&lt;number&gt;&gt; type B = Boxify&lt;number[]&gt;; // [Box&lt;string&gt;, Box&lt;number&gt;] type C = Boxify&lt;[string, boolean]&gt;;</span></span></code> </pre> <br><p>  Leider waren zugeordnete Typen wie der Dienstprogrammtyp <code>Readonly</code> und <code>Readonly</code> keine <code>Readonly</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// lib.d.ts type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] } // How code acted *before* TypeScript 3.4 // { readonly a: string, readonly b: number } type A = Readonly&lt;{ a: string, b: number }&gt;; // number[] type B = Readonly&lt;number[]&gt;; // [string, boolean] type C = Readonly&lt;[string, boolean]&gt;;</span></span></code> </pre> <br><p>  In TypeScript 3.4 <code>readonly</code> der <code>readonly</code> Modifikator in einem zugeordneten Typ automatisch Array-ähnliche Typen in die entsprechenden <code>readonly</code> Gegenstücke. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// How code acts now *with* TypeScript 3.4 // { readonly a: string, readonly b: number } type A = Readonly&lt;{ a: string, b: number }&gt;; // readonly number[] type B = Readonly&lt;number[]&gt;; // readonly [string, boolean] type C = Readonly&lt;[string, boolean]&gt;;</span></span></code> </pre> <br><p>  In ähnlicher Weise könnten Sie einen Dienstprogrammtyp wie den beschreibbaren zugeordneten Typ schreiben, der die <code>readonly</code> entfernt und <code>readonly</code> Array-Container wieder in ihre veränderlichen Entsprechungen konvertiert. </p><br><pre> <code class="javascript hljs">type Writable&lt;T&gt; = { -readonly [K <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keyof T]: T[K] } <span class="hljs-comment"><span class="hljs-comment">// { a: string, b: number } type A = Writable&lt;{ readonly a: string; readonly b: number }&gt;; // number[] type B = Writable&lt;readonly number[]&gt;; // [string, boolean] type C = Writable&lt;readonly [string, boolean]&gt;;</span></span></code> </pre> <br><h3>  Vorsichtsmaßnahmen </h3><br><p>  Trotz seines Erscheinungsbilds kann der <code>readonly</code> nur für die Syntax von <code>readonly</code> und <code>readonly</code> verwendet werden.  Es ist kein Allzweckoperator. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err1: readonly <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>&lt;number&gt;; <span class="hljs-comment"><span class="hljs-comment">// error! let err2: readonly Array&lt;boolean&gt;; // error! let okay: readonly boolean[]; // works fine</span></span></code> </pre> <br><h2>  <code>const</code> Behauptungen </h2><br><p>  Beim Deklarieren einer veränderlichen Variablen oder Eigenschaft erweitert TypeScript häufig die Werte, um sicherzustellen, dass wir später Dinge zuweisen können, ohne einen expliziten Typ zu schreiben. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// hurray! we can assign to 'x' later on! x = "world";</span></span></code> </pre> <br><p>  Technisch gesehen hat jeder Literalwert einen Literaltyp.  Oben wurde der Typ <code>"hello"</code> auf die Typzeichenfolge erweitert, bevor auf einen Typ für <code>x</code> . </p><br><p>  Eine alternative Sichtweise könnte sein, zu sagen, dass <code>x</code> den ursprünglichen Literaltyp <code>"hello"</code> und dass wir später nicht <code>"world"</code> wie <code>"hello"</code> zuweisen können: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-string"><span class="hljs-string">"hello"</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error! x = "world";</span></span></code> </pre> <br><p>  In diesem Fall scheint das extrem, kann aber in anderen Situationen nützlich sein.  Beispielsweise erstellen TypeScripters häufig Objekte, die in diskriminierten Gewerkschaften verwendet werden sollen. </p><br><pre> <code class="javascript hljs">type Shape = | { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"circle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">radius</span></span>: number } | { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"square"</span></span>, <span class="hljs-attr"><span class="hljs-attr">sideLength</span></span>: number } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShapes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shape</span></span></span><span class="hljs-function">[] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = [ { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"circle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">radius</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">"square"</span></span>, <span class="hljs-attr"><span class="hljs-attr">sideLength</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, }, ]; <span class="hljs-comment"><span class="hljs-comment">// Some terrible error message because TypeScript inferred // 'kind' to have the type 'string' instead of // either '"circle"' or '"square"'. return result; }</span></span></code> </pre> <br><p>  Die Veränderlichkeit ist eine der besten Heuristiken der Absicht, mit der TypeScript bestimmen kann, wann sie erweitert werden muss (anstatt unser gesamtes Programm zu analysieren). </p><br><p>  Wie wir im letzten Beispiel gesehen haben, sind die Eigenschaften von JavaScript leider standardmäßig veränderbar.  Dies bedeutet, dass die Sprache häufig unerwünschte Typen erweitert und an bestimmten Stellen explizite Typen erfordert. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShapes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shape</span></span></span><span class="hljs-function">[] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// This explicit annotation gives a hint // to avoid widening in the first place. let result: readonly Shape[] = [ { kind: "circle", radius: 100, }, { kind: "square", sideLength: 50, }, ]; return result; }</span></span></code> </pre> <br><p>  Bis zu einem gewissen Punkt ist dies in Ordnung, aber da unsere Datenstrukturen immer komplexer werden, wird dies umständlich. </p><br><p>  Um dies zu lösen, führt TypeScript 3.4 ein neues Konstrukt für Literalwerte ein, das als <em><code>const</code></em> assertions bezeichnet wird.  Seine Syntax ist eine Typzusicherung mit <code>const</code> anstelle des <code>const</code> (z <code>123 as const</code> B. <code>123 as const</code> ).  Wenn wir neue wörtliche Ausdrücke mit <code>const</code> Aussagen konstruieren, können wir der Sprache signalisieren, dass </p><br><ul><li>  Es sollten keine Literaltypen in diesem Ausdruck erweitert werden (z. B. kein Übergang von <code>"hello"</code> zu <code>string</code> ). </li><li>  Objektliterale erhalten <code>readonly</code> Eigenschaften </li><li>  Array-Literale werden zu <code>readonly</code> Tupeln </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Type '10' let x = 10 as const; // Type 'readonly [10, 20]' let y = [10, 20] as const; // Type '{ readonly text: "hello" }' let z = { text: "hello" } as const;</span></span></code> </pre> <br><p>  Außerhalb von <code>.tsx</code> Dateien kann auch die Syntax für die Assertion von spitzen Klammern verwendet werden. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Type '10' let x = &lt;const&gt;10; // Type 'readonly [10, 20]' let y = &lt;const&gt;[10, 20]; // Type '{ readonly text: "hello" }' let z = &lt;const&gt;{ text: "hello" };</span></span></code> </pre> <br><p>  Diese Funktion bedeutet häufig, dass Typen, die ansonsten nur verwendet würden, um dem Compiler auf Unveränderlichkeit hinzuweisen, häufig weggelassen werden können. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Works with no types referenced or declared. // We only needed a single const assertion. function getShapes() { let result = [ { kind: "circle", radius: 100, }, { kind: "square", sideLength: 50, }, ] as const; return result; } for (const shape of getShapes()) { // Narrows perfectly! if (shape.kind === "circle") { console.log("Circle radius", shape.radius); } else { console.log("Square side length", shape.sideLength); } }</span></span></code> </pre> <br><p>  Beachten Sie, dass oben keine Typanmerkungen erforderlich sind.  Mit der <code>const</code> Zusicherung konnte TypeScript den spezifischsten Typ des Ausdrucks verwenden. </p><br><h3>  Vorsichtsmaßnahmen </h3><br><p>  Zu beachten ist, dass <code>const</code> Zusicherungen nur sofort auf einfache Literalausdrücke angewendet werden können. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Error! // A 'const' assertion can only be applied to a string, number, boolean, array, or object literal. let a = (Math.random() &lt; 0.5 ? 0 : 1) as const; // Works! let b = Math.random() &lt; 0.5 ? 0 as const : 1 as const;</span></span></code> </pre> <br><p>  Eine andere Sache, die Sie beachten sollten, ist, dass <code>const</code> Kontexte einen Ausdruck nicht sofort in eine vollständig unveränderliche konvertieren. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">contents</span></span>: arr, }; foo.name = <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error! foo.contents = []; // error! foo.contents.push(5); // ...works!</span></span></code> </pre> <br><h2>  Typprüfung für <code>globalThis</code> </h2><br><p>  Es kann überraschend schwierig sein, auf Werte im globalen Bereich zuzugreifen oder diese zu deklarieren, möglicherweise weil wir unseren Code in Modulen schreiben (deren lokale Deklarationen standardmäßig nicht auslaufen) oder weil wir möglicherweise eine lokale Variable haben, die den Namen von schattiert ein globaler Wert.  In verschiedenen Umgebungen gibt es verschiedene Möglichkeiten, auf den globalen Bereich zuzugreifen - <code>global</code> in Knoten, <code>window</code> , <code>self</code> oder <code>frames</code> im Browser oder an bestimmten Orten außerhalb des strengen Modus.  Nichts davon ist offensichtlich und führt häufig dazu, dass Benutzer sich nicht sicher sind, ob sie den richtigen Code schreiben. </p><br><p>  TypeScript 3.4 <code>globalThis</code> Unterstützung für die Typprüfung des neuen <code>globalThis</code> ECMAScript - eine globale Variable, die sich auf den globalen Bereich bezieht.  Im Gegensatz zu den oben genannten Lösungen bietet <code>globalThis</code> eine Standardmethode für den Zugriff auf den globalen Bereich, der in verschiedenen Umgebungen verwendet werden kann. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// in a global file: let abc = 100; // Refers to 'abc' from above. globalThis.abc = 200;</span></span></code> </pre> <br><p>  <code>globalThis</code> auch widerspiegeln, ob eine globale Variable als <code>const</code> deklariert wurde oder nicht, indem sie beim Zugriff als <code>readonly</code> Eigenschaft behandelt wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> answer = <span class="hljs-number"><span class="hljs-number">42</span></span>; globalThis.answer = <span class="hljs-number"><span class="hljs-number">333333</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error!</span></span></code> </pre> <br><p>  Es ist wichtig zu beachten, dass TypeScript beim Kompilieren auf ältere Versionen von ECMAScript keine Verweise auf <code>globalThis</code> transformiert.  Sofern Sie nicht auf immergrüne Browser abzielen (die bereits <code>globalThis</code> ), möchten Sie möglicherweise stattdessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine geeignete Polyfüllung</a> verwenden. </p><br><h2>  In benannte Parameter konvertieren </h2><br><p>  Manchmal werden Parameterlisten unhandlich. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> hue?: number, saturation?: number, brightness?: number, positionX?: number, positionY?: number positionZ?: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .... }</span></span></code> </pre> <br><p>  Im obigen Beispiel ist es für einen Aufrufer viel zu einfach, die Reihenfolge der angegebenen Argumente zu verwechseln.  Ein gängiges JavaScript-Muster besteht darin, stattdessen ein „Optionsobjekt“ zu verwenden, sodass jede Option explizit benannt wird und die Reihenfolge keine Rolle spielt.  Dies emuliert eine Funktion, die andere Sprachen als "benannte Parameter" bezeichnet haben. </p><br><pre> <code class="javascript hljs">interface Options { hue?: number, saturation?: number, brightness?: number, positionX?: number, positionY?: number positionZ?: number } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options: Options = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .... }</span></span></code> </pre> <br><p>  Das TypeScript-Team arbeitet nicht nur an einem Compiler, sondern bietet auch die Funktionen, die Editoren für umfangreiche Funktionen wie Vervollständigungen, Definitionen und Refactorings verwenden.  In TypeScript 3.4 hat unsere Praktikantin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabriela Britto</a> ein neues Refactoring implementiert, um vorhandene Funktionen für die Verwendung dieses Musters mit benannten Parametern zu konvertieren. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><img src="https://habrastorage.org/getpro/habr/post_images/f33/305/761/f3330576172c94151d7e13408c82a418.gif" alt="Ein Refactoring, das auf eine Funktion angewendet wird, damit benannte Parameter verwendet werden."></a> </p><br><p>  Obwohl wir den Namen der Funktion bis zu unserer endgültigen Version 3.4 ändern können und wir glauben, dass möglicherweise Platz für einen Teil der Ergonomie vorhanden ist, würden wir uns freuen, wenn Sie die Funktion ausprobieren und uns Ihr Feedback geben. </p><br><h2>  Änderungen brechen </h2><br><h3>  Auf oberster Ebene ist <code>this</code> jetzt eingegeben </h3><br><p>  Der Typ der obersten Ebene wird jetzt als Typ von <code>typeof globalThis</code> anstelle von <code>any</code> <code>typeof globalThis</code> .  Infolgedessen erhalten Sie möglicherweise Fehler beim Zugriff auf unbekannte Werte unter <code>noImplicitAny</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// previously okay in noImplicitAny, now an error this.whargarbl = 10;</span></span></code> </pre> <br><p>  Beachten Sie, dass der unter <code>noImplicitThis</code> kompilierte Code hier keine Änderungen erfährt. </p><br><h3>  Propagierte generische Typargumente </h3><br><p>  In bestimmten Fällen kann die verbesserte Inferenz von TypeScript 3.4 zu generischen Funktionen führen, anstatt zu Funktionen, die ihre Einschränkungen übernehmen und zurückgeben (normalerweise <code>{}</code> ). </p><br><pre> <code class="javascript hljs">declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">U</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f: (arg: T</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">U</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-function">: (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg: U</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V</span></span></span><span class="hljs-function">): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg: T</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: T</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">box</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value: T</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { value }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = compose(list, box); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = f(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-comment"><span class="hljs-comment">// In TypeScript 3.4, 'x.value' has the type // // number[] // // but it previously had the type // // {}[] // // So it's now an error to push in a string. x.value.push("hello");</span></span></code> </pre> <br><p>  Eine explizite Typanmerkung auf <code>x</code> kann den Fehler beseitigen. </p><br><h2>  Was kommt als nächstes? </h2><br><p>  TypeScript 3.4 ist unsere erste Version mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterationsplan</a> , der unsere Pläne für diese Version umreißt und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserer 6-Monats-Roadmap übereinstimmen soll</a> .  Sie können beide und unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roadmap-Seite</a> für fortlaufende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen</a> für alle anstehenden Arbeiten im Auge behalten. </p><br><p>  Im Moment freuen wir uns darauf, von Ihren Erfahrungen mit dem RC zu hören. Probieren Sie es jetzt aus und teilen Sie uns Ihre Gedanken mit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443996/">https://habr.com/ru/post/de443996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443986/index.html">Wie ein Eichhörnchen in einem Rad oder ein wenig über Benutzerforschung in einer Behinderungssituation</a></li>
<li><a href="../de443988/index.html">Microservice Architecture = Distributed Computing</a></li>
<li><a href="../de443990/index.html">13 neue Spiele, die im Rahmen des ID @ Xbox-Programms eingeführt wurden</a></li>
<li><a href="../de443992/index.html">Spiele mit MonoGame erstellen</a></li>
<li><a href="../de443994/index.html">Der US-Präsidentschaftskandidat schlägt vor, das Geschäft mit Amazon, Google und Facebook aufzuteilen, um den Wettbewerb voranzutreiben</a></li>
<li><a href="../de443998/index.html">Neuer Weltrekord für die Berechnung der Anzahl der pi: 31,4 Billionen Zeichen</a></li>
<li><a href="../de444000/index.html">Wo soll ich anfangen, wenn ich zum ersten Mal Personal anheuere?</a></li>
<li><a href="../de444002/index.html">Der weltweit erste „geschlechtsneutrale“ Sprachassistent, der auf dem SXSW IT Festival vorgestellt wurde</a></li>
<li><a href="../de444004/index.html">CLRium # 5: Alles über GC und mehr. Peter und Moskau</a></li>
<li><a href="../de444006/index.html">DIY Do-it-yourself-Spielekonsole</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>