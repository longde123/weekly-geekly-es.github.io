<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏻 🅾️ 🌾 20 kesalahan teratas saat bekerja dengan multithreading di C ++ dan cara untuk menghindarinya 👨🏼‍🏫 🕥 😁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya membawa kepada Anda terjemahan dari artikel “20 kesalahan multithreading C ++ teratas dan bagaimana cara menghindarinya” oleh Deb Hal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>20 kesalahan teratas saat bekerja dengan multithreading di C ++ dan cara untuk menghindarinya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443406/">  Halo, Habr!  Saya membawa kepada Anda terjemahan dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“20 kesalahan multithreading C ++ teratas dan bagaimana cara menghindarinya”</a> oleh Deb Haldar. <br><br><img src="https://habrastorage.org/webt/wi/a8/4v/wia84vtxrf1vqym4rwoynnvtfw0.jpeg" title="KDPV.  Adegan dari film &quot;The Loop of Time (2012)&quot;"><br>  <i>Adegan dari film "The Loop of Time" (2012)</i> <br><br>  Multithreading adalah salah satu bidang yang paling sulit dalam pemrograman, terutama di C ++.  Selama bertahun-tahun pembangunan, saya membuat banyak kesalahan.  Untungnya, sebagian besar dari mereka diidentifikasi oleh kode ulasan dan pengujian.  Namun demikian, beberapa entah bagaimana tergelincir pada yang produktif, dan kami harus mengedit sistem operasi, yang selalu mahal. <br><br>  Pada artikel ini, saya mencoba mengategorikan semua kesalahan yang saya tahu dengan solusi yang mungkin.  Jika Anda mengetahui adanya jebakan lain, atau memiliki saran untuk menyelesaikan kesalahan yang dijelaskan, silakan tinggalkan komentar Anda di bawah artikel. <br><a name="habracut"></a><br><h3>  Kesalahan # 1: Jangan gunakan join () untuk menunggu utas latar belakang sebelum keluar dari aplikasi </h3><br>  Jika Anda lupa untuk bergabung dengan aliran ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabung ()</a> ) atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lepaskan</a> sematan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lepaskan ()</a> ) (buat itu tidak dapat digabungkan) sebelum program berakhir, ini akan menyebabkan crash.  (Terjemahan akan berisi kata-kata join dalam konteks <i>join ()</i> dan <i>detach</i> dalam konteks <i>detach ()</i> , meskipun ini tidak sepenuhnya benar. Faktanya, <i>join ()</i> adalah titik di mana satu utas eksekusi menunggu penyelesaian yang lain, dan tidak ada penggabungan atau penggabungan utas yang terjadi [penerjemah komentar]). <br><br>  Pada contoh di bawah ini, kami lupa mengeksekusi <i>join () dari</i> utas t1 di utas utama: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//t1.join(); //     join-     </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Kenapa programnya crash ?!  Karena pada akhir fungsi <i>main ()</i> , variabel t1 keluar dari ruang lingkup dan pemanggil thread dipanggil.  <i>Destuktor</i> memeriksa apakah utas t1 dapat <i>digabung</i> .  Thread dapat <i>digabung</i> jika belum dilepas.  Dalam hal ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: terminate</a> disebut dalam destruktornya.  Inilah yang, sebagai contoh, kompiler MSVC ++ tidak. <br><br> <code>~thread <font color="#008000">(</font> <font color="#008000">)</font> _NOEXCEPT <br> <font color="#008000">{</font> <font color="#666666">// clean up</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> joinable <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> XSTD terminate <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Ada dua cara untuk memperbaiki masalah, tergantung pada tugas: <br><br>  1. Panggil <i>join () dari</i> utas t1 di utas utama: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//  join  t1,        </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  2. Lepaskan aliran t1 dari arus utama, biarkan aliran berfungsi sebagai aliran "yang di-demonisasi": <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   t1   </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Kesalahan # 2: Mencoba melampirkan utas yang sebelumnya terlepas </h3><br>  Jika pada titik tertentu dalam program kerja Anda memiliki aliran <i>pelepasan</i> , Anda tidak dapat melampirkannya kembali ke aliran utama.  Ini adalah kesalahan yang sangat jelas.  Masalahnya adalah Anda dapat membatalkan sematan aliran, dan kemudian menulis beberapa ratus baris kode dan mencoba memasangnya kembali.  Lagi pula, siapa yang ingat bahwa ia menulis 300 baris kembali, kan? <br><br>  Masalahnya adalah ini tidak akan menyebabkan kesalahan kompilasi, sebaliknya program akan macet saat startup.  Sebagai contoh: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">// CRASH !!!</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Solusinya adalah selalu memeriksa utas yang dapat <i>digabung ()</i> sebelum mencoba melampirkannya ke utas panggilan. <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> t1. <font color="#007788">joinable</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Kesalahan # 3: Kesalahpahaman bahwa std :: thread :: join () memblokir panggilan thread eksekusi </h3><br>  Dalam aplikasi nyata, Anda sering harus memisahkan operasi "lama" dari pemrosesan jaringan I / O atau menunggu pengguna mengklik tombol, dll.  Panggilan untuk <i>bergabung ()</i> untuk alur kerja seperti itu (misalnya, utas render UI) dapat menyebabkan antarmuka pengguna hang.  Ada metode implementasi yang lebih cocok. <br><br>  Misalnya, dalam aplikasi GUI, utas pekerja, setelah selesai, dapat mengirim pesan ke utas UI.  Aliran UI memiliki loop pemrosesan acara sendiri seperti: menggerakkan mouse, menekan tombol, dll.  Loop ini juga dapat menerima pesan dari utas pekerja dan meresponsnya tanpa harus memanggil metode blocking <i>join ()</i> . <br><br>  Untuk alasan ini, hampir semua interaksi pengguna di platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WinRT</a> dari Microsoft dibuat tidak sinkron, dan alternatif sinkron tidak tersedia.  Keputusan ini dibuat untuk memastikan bahwa pengembang akan menggunakan API yang memberikan pengalaman pengguna akhir sebaik mungkin.  Anda dapat merujuk ke manual “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modern C ++ dan Windows Store Apps</a> ” untuk informasi lebih lanjut tentang topik ini. <br><br><h3>  Kesalahan # 4: Mengasumsikan bahwa argumen fungsi aliran diteruskan oleh referensi secara default </h3><br>  Argumen untuk fungsi aliran diteruskan oleh nilai secara default.  Jika Anda perlu membuat perubahan pada argumen yang diteruskan, Anda harus meneruskannya dengan referensi menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: ref ()</a> . <br><br>  Di bawah spoiler, contoh-contoh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel C ++ 11 lain Tutorial Multithreading melalui T&amp;J - Dasar-dasar Manajemen Thread (Deb Haldar)</a> , menggambarkan parameter yang lewat [kira-kira.  penerjemah]. <br><br><div class="spoiler">  <b class="spoiler_title">lebih detail:</b> <div class="spoiler_text">  Saat mengeksekusi kode: <br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, targetCity <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Ini akan ditampilkan di terminal: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Star City</code> <br> <br>  Seperti yang Anda lihat, nilai variabel <i>targetCity yang</i> diterima oleh fungsi yang dipanggil dalam aliran dengan referensi tidak berubah. <br><br>  Tulis ulang kode menggunakan <i>std :: ref ()</i> untuk memberikan argumen: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, std <font color="#008080">::</font> <font color="#007788">ref</font> <font color="#008000">(</font> targetCity <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Ini akan menampilkan: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Metropolis</code> <br> <br>  Perubahan yang dilakukan pada utas baru akan memengaruhi nilai variabel <i>targetCity yang</i> dideklarasikan dan diinisialisasi dalam fungsi <i>utama</i> . <br></div></div><br><h3>  Kesalahan # 5: Jangan melindungi data dan sumber daya bersama dengan bagian kritis (misalnya, sebuah mutex) </h3><br>  Dalam lingkungan multi-utas, biasanya lebih dari satu utas bersaing untuk sumber daya dan data bersama.  Seringkali ini mengarah ke keadaan yang tidak pasti untuk sumber daya dan data, kecuali ketika akses ke mereka dilindungi oleh beberapa mekanisme yang memungkinkan hanya satu utas eksekusi untuk melakukan operasi pada mereka kapan saja. <br><br>  Pada contoh di bawah ini, <i>std :: cout</i> adalah sumber daya bersama yang bekerja dengan 6 utas (t1-t5 + main). <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t3 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Moon"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> CallHome <font color="#008000">(</font> <font color="#FF0000">"Hello from Main/Earth"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> thread t4 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Uranus"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t5 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Neptune"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t3. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t4. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t5. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Jika kami menjalankan program ini, kami mendapatkan kesimpulan: <br><br> <code>Thread 0x1000fb5c0 says Hello from Main/Earth <br> Thread Thread Thread 0x700005bd20000x700005b4f000 says says Thread Thread Hello from Pluto0x700005c55000Hello from Jupiter says 0x700005d5b000Hello from Moon <br> 0x700005cd8000 says says Hello from Uranus <br> <br> Hello from Neptune <br></code> <br><br>  Ini karena lima utas secara bersamaan mengakses aliran output dalam urutan acak.  Untuk membuat kesimpulan lebih spesifik, Anda harus melindungi akses ke sumber daya bersama menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: mutex</a> .  Cukup ubah fungsi <i>CallHome ()</i> sehingga ia menangkap mutex sebelum menggunakan <i>std :: cout</i> dan membebaskannya setelah itu. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Kesalahan # 6: Lupa melepaskan kunci setelah keluar dari bagian kritis </h3><br>  Di paragraf sebelumnya, Anda melihat cara melindungi bagian penting dengan mutex.  Namun, memanggil metode <i>kunci ()</i> dan <i>membuka kunci ()</i> langsung pada mutex bukan pilihan yang disukai karena Anda mungkin lupa memberikan kunci yang ditahan.  Apa yang akan terjadi selanjutnya?  Semua utas lainnya yang sedang menunggu rilis sumber daya akan diblokir tanpa batas dan program dapat hang. <br><br>  Dalam contoh sintetis kami, jika Anda lupa membuka kunci mutex di panggilan fungsi <i>CallHome ()</i> , pesan pertama dari stream t1 akan menjadi output ke stream standar dan program akan macet.  Ini disebabkan oleh fakta bahwa utas t1 menerima kunci mutex, dan utas lainnya menunggu kunci ini dilepaskan. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#666666">//mu.unlock();     </font> <br> <font color="#008000">}</font></code> <br> <br>  Berikut ini adalah output dari kode ini - program macet, menampilkan satu-satunya pesan di terminal, dan tidak berakhir: <br><br> <code>Thread 0x700005986000 says Hello from Pluto <br> <br></code> <br><br>  Kesalahan seperti itu sering terjadi, itulah sebabnya mengapa tidak diinginkan untuk menggunakan metode <i>kunci () / membuka kunci ()</i> langsung dari mutex.  Sebagai gantinya, gunakan kelas template <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: lock_guard</a> , yang menggunakan idiom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RAII</a> untuk mengontrol masa pakai kunci.  Ketika objek <i>lock_guard</i> dibuat, ia mencoba untuk mengambil alih mutex.  Ketika program meninggalkan ruang lingkup objek <i>lock_guard</i> , destructor dipanggil, yang membebaskan mutex. <br><br>  Kami menulis ulang fungsi <i>CallHome ()</i> menggunakan objek <i>std :: lock_guard</i> : <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   </font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#666666">//  lock_guard    </font></code> <br> <br><h3>  Kesalahan # 7: Buat ukuran bagian kritis lebih besar dari yang diperlukan </h3><br>  Ketika satu utas dieksekusi di dalam bagian kritis, semua yang lain yang mencoba memasukkannya pada dasarnya diblokir.  Kita harus menyimpan instruksi sesedikit mungkin di bagian kritis.  Sebagai ilustrasi, contoh kode buruk dengan bagian kritis besar diberikan: <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//    lock_guard    mu </font></code> <br> <br>  Metode <i>ReadFifyThousandRecords ()</i> tidak mengubah data.  Tidak ada alasan untuk menjalankannya di bawah kunci.  Jika metode ini dijalankan selama 10 detik, membaca 50 ribu baris dari database, semua utas lainnya akan diblokir untuk seluruh periode ini secara tidak perlu.  Ini serius dapat mempengaruhi kinerja program. <br><br>  Solusi yang benar adalah dengan tetap di bagian kritis hanya bekerja dengan <i>std :: cout</i> . <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//         ..    </font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//     lock_guard    mu </font></code> <br> <br><h3>  Kesalahan # 8: Mengambil banyak kunci dalam urutan berbeda </h3><br><br>  Ini adalah salah satu penyebab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebuntuan yang</a> paling umum, situasi di mana utas diblokir tanpa batas karena menunggu akses ke sumber daya diblokir oleh utas lain.  Pertimbangkan sebuah contoh: <br><br><table><tbody><tr><th>  aliran 1 </th><th>  aliran 2 </th></tr><tr><td>  kunci A </td><td>  kunci B </td></tr><tr><td>  // ... beberapa operasi </td><td>  // ... beberapa operasi </td></tr><tr><td>  kunci B </td><td>  kunci A </td></tr><tr><td>  // ... beberapa operasi lain </td><td>  // ... beberapa operasi lain </td></tr><tr><td>  membuka kunci B </td><td>  membuka kunci A </td></tr><tr><td>  membuka kunci A </td><td>  membuka kunci B </td></tr></tbody></table><br>  Suatu situasi dapat muncul di mana utas 1 akan mencoba untuk menangkap kunci B dan diblokir karena utas 2 telah menangkapnya.  Pada saat yang sama, utas kedua mencoba menangkap kunci A, tetapi tidak dapat melakukan ini, karena ia ditangkap oleh utas pertama.  Thread 1 tidak dapat melepaskan kunci A sampai mengunci B, dll.  Dengan kata lain, program macet. <br><br>  Contoh kode ini akan membantu Anda mereproduksi <i>kebuntuan</i> : <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muA <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muB <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th1 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//  - </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th2 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">// -  </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome_Th1, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome_Th2, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Jika Anda menjalankan kode ini, itu akan macet.  Jika Anda masuk lebih dalam ke debugger di jendela utas, Anda akan melihat bahwa utas pertama (dipanggil dari <i>CallHome_Th1 ()</i> ) sedang mencoba untuk mendapatkan kunci B mutex, sementara utas 2 (dipanggil dari <i>CallHome_Th2 ()</i> ) mencoba untuk memblokir mutex A. Tidak ada utas tidak bisa berhasil, yang mengarah ke jalan buntu! <br><br> <a href=""><img src="https://habrastorage.org/webt/ud/kf/a5/udkfa53cvuh8xsrn8lljglb09fa.png"></a> <br>  (gambar dapat diklik) <br><br>  Apa yang bisa kamu lakukan?  Solusi terbaik adalah merestrukturisasi kode sehingga mengunci kunci terjadi dalam urutan yang sama setiap kali. <br><br>  Bergantung pada situasinya, Anda dapat menggunakan strategi lain: <br><br>  1. Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas</a> wrapper <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: scoped_lock</a> untuk bersama-sama menangkap beberapa kunci: <br><br> <code>std <font color="#008080">::</font> <font color="#007788">scoped_lock</font> lock <font color="#008000">{</font> muA, muB <font color="#008000">}</font> <font color="#008080">;</font></code> <br> <br>  2. Gunakan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: timed_mutex</a> , di mana Anda dapat menentukan batas waktu, setelah itu kunci akan dilepaskan jika sumber daya belum tersedia. <br><br> <code>std <font color="#008080">::</font> <font color="#007788">timed_mutex</font> m <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> DoSome <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> timeout <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> m. <font color="#007788">try_lock_for</font> <font color="#008000">(</font> timeout <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": acquire mutex successfully"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> m. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#0000ff">else</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": can't  acquire mutex, do something else"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Kesalahan # 9: Mencoba meraih std :: mutex lock dua kali </h3><br>  Mencoba mengunci kunci dua kali akan menghasilkan perilaku yang tidak terdefinisi.  Di sebagian besar implementasi debug, ini akan macet.  Misalnya, dalam kode di bawah ini, <i>LaunchRocket () akan</i> mengunci mutex dan kemudian memanggil <i>StartThruster ()</i> .  Yang aneh, dalam kode di atas Anda tidak akan menemukan masalah ini selama operasi normal program, masalah hanya terjadi ketika pengecualian dilemparkan, yang disertai dengan perilaku yang tidak ditentukan atau program berakhir secara tidak normal. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">int</font> counter <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#666666">// - </font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching rocket"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Untuk mengatasi masalah ini, Anda harus memperbaiki kode sedemikian rupa untuk mencegah pengambilan kembali kunci yang diterima sebelumnya.  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: recursive_mutex</a> sebagai solusi kruk, tetapi solusi seperti itu hampir selalu menunjukkan arsitektur program yang buruk. <br><br><h3>  Kesalahan # 10: Gunakan mutex ketika std :: jenis atom sudah cukup </h3><br><br>  Saat Anda perlu mengubah tipe data sederhana, seperti nilai Boolean atau penghitung bilangan bulat, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std: atomic</a> umumnya akan memberikan kinerja yang lebih baik daripada menggunakan mutex. <br><br>  Misalnya, alih-alih menggunakan konstruk berikut: <br><br> <code><font color="#0000ff">int</font> counter <font color="#008080">;</font> <br> ... <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br></code> <br><br>  Lebih baik mendeklarasikan variabel sebagai <i>std :: atomic</i> : <br><br> <code>std <font color="#008080">::</font> <font color="#007788">atomic</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> counter <font color="#008080">;</font> <br> ... <br> <font color="#007788">counter</font> <font color="#000040">++</font> <font color="#008080">;</font></code> <br> <br>  Untuk perbandingan terperinci tentang mutex dan atom, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perbandingan: Pemrograman tanpa kunci dengan atom dalam C ++ 11 vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mutex dan kunci RW »</a> <br><br><h3>  Kesalahan # 11: Membuat dan menghancurkan sejumlah besar utas secara langsung, alih-alih menggunakan kumpulan utas gratis </h3><br>  Membuat dan menghancurkan utas adalah operasi yang mahal dalam hal waktu prosesor.  Bayangkan sebuah upaya untuk membuat aliran saat sistem melakukan operasi intensif secara komputasi, misalnya, merender grafik atau menghitung fisika gim.  Pendekatan yang sering digunakan untuk tugas-tugas tersebut adalah untuk membuat kumpulan untaian pra-dialokasikan yang dapat menangani tugas-tugas rutin, seperti menulis ke disk atau mengirim data melalui jaringan sepanjang seluruh siklus hidup proses. <br><br>  Keuntungan lain dari kumpulan utas dibandingkan dengan pemijahan dan penghancuran utas sendiri adalah bahwa Anda tidak perlu khawatir tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berlebihnya thread</a> (situasi di mana jumlah utas melebihi jumlah inti yang tersedia dan sebagian besar waktu prosesor dihabiskan untuk mengubah konteks [kira-kira. penerjemah]).  Ini dapat mempengaruhi kinerja sistem. <br><br>  Selain itu, penggunaan kumpulan menyelamatkan kita dari kepedihan mengelola siklus hidup utas, yang pada akhirnya diterjemahkan menjadi kode yang lebih ringkas dengan lebih sedikit kesalahan. <br><br>  Dua perpustakaan paling populer yang mengimplementasikan kumpulan thread adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel Thread Building Blocks (TBB)</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Parallel Patterns Library (PPL)</a> . <br><br><h3>  Kesalahan No. 12: Jangan menangani pengecualian yang terjadi di utas latar belakang </h3><br>  Pengecualian yang dilemparkan dalam satu utas tidak dapat ditangani pada utas lainnya.  Mari kita bayangkan bahwa kita memiliki fungsi yang melempar pengecualian.  Jika kami menjalankan fungsi ini dalam utas terpisah yang bercabang dari utas utama eksekusi, dan berharap bahwa kami akan menangkap pengecualian yang dilemparkan dari utas tambahan, maka ini tidak akan berfungsi.  Pertimbangkan sebuah contoh: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> teptr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Ketika program ini dieksekusi, ia akan crash, namun, catch block di fungsi main () tidak akan dieksekusi dan tidak akan menangani pengecualian yang dilemparkan ke thread t1. <br><br>  Solusi untuk masalah ini adalah dengan menggunakan fitur-fitur dari C ++ 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: exception_ptr</a> digunakan untuk menangani pengecualian yang dilemparkan di utas latar belakang.  Berikut langkah-langkah yang perlu Anda ambil: <br><br><ul><li>  Buat instance global dari <i>std :: exception_ptr</i> class diinisialisasi ke <i>nullptr</i> </li><li>  Di dalam fungsi yang berjalan di utas terpisah, menangani semua pengecualian dan mengatur nilai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: current_exception () dari</a> variabel global <i>std :: exception_ptr</i> dideklarasikan pada langkah sebelumnya </li><li>  Periksa nilai variabel global di dalam utas utama </li><li>  Jika nilainya diatur, gunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: rethrow_exception (exception_ptr p)</a> untuk berulang kali memanggil pengecualian yang sebelumnya ditangkap, meneruskannya dengan referensi sebagai parameter </li></ul><br>  Memanggil pengecualian dengan referensi tidak terjadi di utas tempat ia dibuat, jadi fitur ini bagus untuk menangani pengecualian di utas berbeda. <br><br>  Dalam kode di bawah ini, Anda dapat dengan aman menangani pengecualian yang dilemparkan ke utas latar belakang. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> globalExceptionPtr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> globalExceptionPtr <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">current_exception</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">rethrow_exception</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Kesalahan # 13: Gunakan utas untuk mensimulasikan operasi asinkron, alih-alih menggunakan std :: async </h3><br>  Jika Anda memerlukan kode untuk dieksekusi secara tidak sinkron, mis.  tanpa memblokir utas eksekusi, pilihan terbaik adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: async ()</a> .  Ini setara dengan membuat aliran dan meneruskan kode yang diperlukan untuk mengeksekusi dalam aliran ini melalui pointer ke fungsi atau parameter dalam bentuk fungsi lambda.  Namun, dalam kasus terakhir, Anda perlu memantau kreasi, lampiran / pelepasan utas ini, serta penanganan semua pengecualian yang mungkin terjadi pada utas ini.  Jika Anda menggunakan <i>std :: async ()</i> , Anda membebaskan diri dari masalah ini dan juga secara tajam mengurangi peluang Anda untuk <i>menemui jalan buntu</i> . <br><br>  Keuntungan signifikan lainnya dari menggunakan <i>std :: async</i> adalah kemampuan untuk mendapatkan hasil dari operasi asinkron kembali ke utas panggilan menggunakan objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: future</a> .  Bayangkan bahwa kita memiliki fungsi <i>ConjureMagic ()</i> yang mengembalikan int.  Kita bisa memulai operasi asinkron, yang akan menetapkan nilai di masa depan ke objek di <i>masa depan</i> , ketika tugas selesai, dan kita bisa mengekstraksi hasil eksekusi dari objek ini dalam aliran eksekusi dari mana operasi dipanggil. <br><br> <code><font color="#666666">//        future</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> asyncResult2 <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> <font color="#000040">&amp;</font> ConjureMagic <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//...  -   future   </font> <br> <br> <font color="#666666">//     future</font> <br> <font color="#0000ff">int</font> v <font color="#000080">=</font> asyncResult2. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Mendapatkan hasilnya kembali dari utas berjalan ke pemanggil lebih rumit.  Ada dua cara yang mungkin: <br><br><ol><li>  Melewati referensi ke variabel output ke aliran yang akan menyimpan hasilnya. </li><li>  Menyimpan hasil dalam variabel bidang objek alur kerja, yang dapat dibaca segera setelah utas menyelesaikan eksekusi. </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kurt Guntheroth</a> menemukan bahwa dalam hal kinerja, overhead untuk menciptakan aliran adalah 14 kali lipat menggunakan <i>async</i> . <br><br>  Intinya: gunakan <i>std :: async ()</i> secara default sampai Anda menemukan argumen kuat yang mendukung penggunaan <i>std :: thread</i> secara langsung. <br><br><h3>  Kesalahan No. 14: Jangan gunakan std :: launch :: async jika diperlukan sinkronisasi </h3><br>  Fungsi <i>std :: async ()</i> bukan nama yang tepat, karena secara default mungkin tidak berjalan secara asinkron! <br><br>  Ada dua kebijakan runtime <i>std :: async</i> : <br><br><ol><li>  <i>std :: launch :: async</i> : fungsi yang diteruskan mulai dijalankan segera di utas terpisah </li><li>  <i>std :: launch :: deferred</i> : fungsi yang diteruskan tidak segera dimulai, peluncurannya ditunda sebelum panggilan <i>get ()</i> atau <i>wait ()</i> dilakukan pada objek <i>std :: future</i> , yang akan dikembalikan dari panggilan <i>std :: async</i> .  Di tempat memanggil metode ini, fungsi akan dieksekusi secara serempak. </li></ol><br>  Ketika kita memanggil <i>std :: async ()</i> dengan parameter default, itu dimulai dengan kombinasi dari dua parameter ini, yang pada kenyataannya mengarah pada perilaku yang tidak dapat diprediksi.  Ada sejumlah kesulitan lain yang terkait dengan penggunaan <i>std: async ()</i> dengan kebijakan startup default: <br><br><ul><li>  ketidakmampuan untuk memprediksi akses yang benar ke variabel aliran lokal </li><li>  tugas asinkron mungkin tidak dimulai sama sekali karena fakta bahwa panggilan ke metode <i>get ()</i> dan <i>wait ()</i> mungkin tidak dipanggil selama eksekusi program </li><li>  ketika digunakan dalam loop di mana kondisi keluar mengharapkan objek std :: future siap, loop ini mungkin tidak pernah berakhir, karena std :: masa depan dikembalikan oleh panggilan ke std :: async dapat mulai dalam keadaan ditangguhkan. </li></ul><br>  Untuk menghindari semua kesulitan ini, <b>selalu</b> panggil <i>std :: async</i> dengan kebijakan <i>peluncuran std :: launch :: async</i> . <br><br>  Jangan lakukan ini: <br><br> <code><font color="#666666">//  myFunction  std::async     </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Sebaliknya, lakukan ini: <br><br> <code><font color="#666666">//  myFunction </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Poin ini dipertimbangkan secara lebih rinci dalam buku oleh Scott Meyers "C ++ Efektif dan Modern". <br><br><h3>  Kesalahan # 15: Memanggil metode get () objek std :: future dalam blok kode yang waktu eksekusi-nya sangat kritis </h3><br>  Kode di bawah ini memproses hasil yang diperoleh dari objek <i>std :: future</i> dari operasi asinkron.  Namun, <i>loop sementara</i> akan dikunci hingga operasi asinkron selesai (dalam kasus ini, selama 10 detik).  Jika Anda ingin menggunakan loop ini untuk menampilkan informasi di layar, ini dapat menyebabkan penundaan yang tidak menyenangkan dalam rendering antarmuka pengguna. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <font color="#666666">//  -   Val</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  <b>Catatan</b> : masalah lain dari kode di atas adalah bahwa ia mencoba mengakses objek <i>std :: future</i> untuk kedua kalinya, meskipun status objek <i>std :: future</i> diambil pada iterasi pertama dari loop dan tidak dapat diambil. <br><br>  Solusi yang benar adalah dengan memeriksa validitas objek <i>std :: future</i> sebelum memanggil metode <i>get ()</i> .  Dengan demikian, kami tidak memblokir penyelesaian tugas asinkron dan tidak mencoba untuk menginterogasi objek <i>std :: future yang</i> sudah diekstraksi. <br><br>  Cuplikan kode ini memungkinkan Anda untuk mencapai ini: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <br> <font color="#666666">//   -   Val</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  №16:  ,  ,    ,        std::future::get() </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bayangkan kita memiliki fragmen kode berikut, menurut Anda apa hasil dari memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: future :: get ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Jika Anda berasumsi bahwa program akan macet - Anda memang benar! </font><font style="vertical-align: inherit;">Pengecualian yang dilemparkan dalam operasi asinkron dilemparkan hanya ketika metode </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> dipanggil </font><font style="vertical-align: inherit;">pada objek </font><i><font style="vertical-align: inherit;">std :: future</font></i><font style="vertical-align: inherit;"> . Dan jika metode </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> tidak dipanggil, maka pengecualian akan diabaikan dan dibuang ketika objek </font><i><font style="vertical-align: inherit;">std :: future</font></i><font style="vertical-align: inherit;"> keluar dari ruang lingkup. </font><font style="vertical-align: inherit;">Jika operasi asinkron Anda dapat melempar pengecualian, Anda harus selalu membungkus panggilan ke </font><i><font style="vertical-align: inherit;">std :: future :: get ()</font></i><font style="vertical-align: inherit;"> di </font><font style="vertical-align: inherit;">blok </font><i><font style="vertical-align: inherit;">coba / tangkap</font></i><font style="vertical-align: inherit;"> . Contoh bagaimana ini terlihat:</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#000040">&amp;</font> e <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Async task threw exception: "</font> <font color="#000080">&lt;&lt;</font> e. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  №17:  std::async,        </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cukup dalam banyak kasus, ada beberapa situasi di mana Anda mungkin perlu kontrol yang hati-hati atas eksekusi kode Anda dalam aliran. Misalnya, jika Anda ingin mengikat utas tertentu ke inti prosesor tertentu dalam sistem multiprosesor (misalnya, Xbox). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen kode yang diberikan menetapkan pengikatan utas ke inti prosesor ke-5 dalam sistem. </font><font style="vertical-align: inherit;">Hal ini dimungkinkan karena metode </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">native_handle ()</font></a><font style="vertical-align: inherit;"> keberatan </font><i><font style="vertical-align: inherit;">std :: benang</font></i><font style="vertical-align: inherit;"> , dan transfer ke fungsi mengalir </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Win32 API</font></a><font style="vertical-align: inherit;"> . Ada banyak fitur lain yang disediakan melalui streaming Win32 API yang tidak tersedia di </font><i><font style="vertical-align: inherit;">std :: thread</font></i><font style="vertical-align: inherit;"> atau </font><i><font style="vertical-align: inherit;">std :: async ()</font></i><font style="vertical-align: inherit;"> . Saat mengerjakan</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;windows.h&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> DWORD result <font color="#000080">=</font> <font color="#008080">::</font> <font color="#007788">SetThreadIdealProcessor</font> <font color="#008000">(</font> t1. <font color="#007788">native_handle</font> <font color="#008000">(</font> <font color="#008000">)</font> , <font color="#0000dd">5</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async (),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fungsi platform dasar ini tidak tersedia, yang membuat metode ini tidak cocok untuk tugas yang lebih kompleks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatifnya adalah membuat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: packaged_task</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan memindahkannya ke utas eksekusi yang diinginkan setelah menyetel properti utas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesalahan # 18: Membuat lebih banyak thread "running" daripada core tersedia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari sudut pandang arsitektur, aliran dapat diklasifikasikan ke dalam dua kelompok: "berlari" dan "menunggu". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread yang berjalan memanfaatkan 100% waktu prosesor dari kernel yang mereka jalankan. Ketika lebih dari satu thread berjalan dialokasikan ke satu inti, efisiensi penggunaan CPU turun. Kami tidak mendapatkan peningkatan kinerja jika kami menjalankan lebih dari satu utas berjalan pada satu inti prosesor - pada kenyataannya, kinerja turun karena beralih konteks tambahan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utas Menunggu hanya menggunakan beberapa siklus clock yang menjalankannya saat mereka menunggu peristiwa sistem atau I / O jaringan, dll. Dalam hal ini, sebagian besar waktu prosesor yang tersedia dari kernel tetap tidak digunakan. Satu utas tunggu dapat memproses data, sedangkan yang lainnya sedang menunggu peristiwa untuk dipicu - inilah mengapa menguntungkan untuk mendistribusikan beberapa utas tunggu ke satu inti. Menjadwalkan beberapa pending threads per core dapat memberikan kinerja program yang jauh lebih besar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, bagaimana memahami berapa banyak thread yang berjalan yang didukung sistem? Gunakan metode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: thread :: hardware_concurrency ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Fungsi ini biasanya mengembalikan jumlah inti prosesor, tetapi memperhitungkan inti yang berperilaku sebagai dua atau lebih inti logis karena</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hipertensi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda harus menggunakan nilai yang diperoleh dari platform target untuk merencanakan jumlah maksimum utas yang berjalan secara bersamaan dari program Anda. Anda juga dapat menetapkan satu inti untuk semua utas tertunda, dan menggunakan sisa jumlah inti untuk menjalankan utas. Misalnya, dalam sistem quad-core, gunakan satu inti untuk SEMUA utas tertunda, dan untuk tiga core sisanya, tiga utas berjalan. Bergantung pada efisiensi penjadwal utas Anda, beberapa utas yang dapat dieksekusi Anda dapat mengalihkan konteks (karena kegagalan akses halaman, dll.), Membiarkan kernel tidak aktif untuk beberapa waktu. Jika Anda mengamati situasi ini selama pembuatan profil, Anda harus membuat jumlah utas yang dieksekusi sedikit lebih besar daripada jumlah inti, dan mengonfigurasi nilai ini untuk sistem Anda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesalahan # 19: Menggunakan kata kunci yang mudah menguap untuk sinkronisasi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata kunci yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mudah menguap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">sebelum menentukan jenis variabel, tidak membuat operasi pada atom atau utas variabel ini aman. </font><font style="vertical-align: inherit;">Yang mungkin Anda inginkan adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: atomic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat diskusi tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk detail lebih lanjut.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesalahan # 20: Menggunakan Arsitektur Bebas Kunci kecuali benar-benar diperlukan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada sesuatu dalam kompleksitas yang disukai setiap insinyur. Membuat program bebas kunci terdengar sangat menggoda dibandingkan dengan mekanisme sinkronisasi biasa seperti mutex, variabel kondisional, asinkron, dll. Namun, setiap pengembang C ++ berpengalaman yang saya ajak bicara memiliki pendapat bahwa penggunaan pemrograman non-penguncian sebagai opsi awal adalah semacam optimisasi prematur yang dapat berjalan menyamping pada saat yang paling tidak tepat (pikirkan tentang kegagalan dalam sistem operasi ketika Anda tidak memiliki heap dump penuh!).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam karir saya di C ++, hanya ada satu situasi yang mengharuskan eksekusi kode tanpa kunci, karena kami bekerja dalam sistem dengan sumber daya terbatas, di mana setiap transaksi dalam komponen kami harus tidak lebih dari 10 mikrodetik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum berpikir untuk menerapkan pendekatan pengembangan tanpa memblokir, harap jawab tiga pertanyaan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudahkah Anda mencoba merancang arsitektur sistem Anda sehingga tidak memerlukan mekanisme sinkronisasi? </font><font style="vertical-align: inherit;">Sebagai aturan, sinkronisasi terbaik adalah kurangnya sinkronisasi.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda membutuhkan sinkronisasi, sudahkah Anda membuat profil kode Anda untuk memahami karakteristik kinerja? </font><font style="vertical-align: inherit;">Jika ya, sudahkah Anda mencoba mengoptimalkan kemacetan?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bisakah Anda membuat skala secara horizontal, bukan skala secara vertikal? </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singkatnya, untuk pengembangan aplikasi normal, harap pertimbangkan pemrograman non-penguncian hanya ketika Anda telah kehabisan semua alternatif lain. </font><font style="vertical-align: inherit;">Cara lain untuk melihat ini adalah bahwa jika Anda masih membuat beberapa 19 kesalahan di atas, Anda mungkin harus menjauh dari pemrograman tanpa memblokir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Dari. </font><font style="vertical-align: inherit;">penerjemah: terima kasih </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kepada </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;">vovo4K</font></a><font style="vertical-align: inherit;"> karena telah membantu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;">saya</font></a><font style="vertical-align: inherit;"> mempersiapkan artikel ini.]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443406/">https://habr.com/ru/post/id443406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443396/index.html">Pencetakan 3D dan airsoft: bagaimana saya mencetak "drive"</a></li>
<li><a href="../id443398/index.html">Menerapkan ERP di perusahaan industri: Alevtina Svetozarovna dan Excel terhadap arsitek keras dan pabrik Inggris</a></li>
<li><a href="../id443400/index.html">Menghitung Bug di Windows Calculator</a></li>
<li><a href="../id443402/index.html">Cara membuat ulasan kode lebih cepat dan lebih efisien</a></li>
<li><a href="../id443404/index.html">Tujuan Baru NASA untuk Pencarian Peradaban Luar Angkasa: Tanda-Tanda Teknologi</a></li>
<li><a href="../id443408/index.html">Foton, kuanta, dan keadaan Fock: manipulasi tingkat kuantum dengan resonator frekuensi radio</a></li>
<li><a href="../id443412/index.html">Mengapa programmer terus menggunakan Java verbose, meskipun ada Python ringkas</a></li>
<li><a href="../id443414/index.html">Plang: ketika breakpoints tidak cukup</a></li>
<li><a href="../id443416/index.html">Winnti: serangan terhadap rantai pasokan - Pengembang game Asia berada di garis depan</a></li>
<li><a href="../id443418/index.html">Metode Pengujian Perangkat Lunak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>