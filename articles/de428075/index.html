<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÉè ü•ì üßõüèº Trotzdem kannst du es nicht tun! - Verwenden von Schnittstellen und Abh√§ngigkeitsinjektion f√ºr das langfristige Design ü§ù ‚§µÔ∏è üêû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Wir haben endlich einen Vertrag, um Mark Simans Buch " Dependency Injection in .NET " zu aktualisieren - Hauptsache, er beendet e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trotzdem kannst du es nicht tun! - Verwenden von Schnittstellen und Abh√§ngigkeitsinjektion f√ºr das langfristige Design</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428075/">  Hallo allerseits! <br><br>  Wir haben endlich einen Vertrag, um Mark Simans Buch " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dependency Injection in .NET</a> " zu aktualisieren - Hauptsache, er beendet es so schnell wie m√∂glich.  Wir haben auch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> im Herausgeber des angesehenen Dinesh Rajput √ºber Entwurfsmuster im Fr√ºhjahr 5, in dem eines der Kapitel auch der Implementierung von Abh√§ngigkeiten gewidmet ist. <br><br>  Wir haben lange nach interessantem Material gesucht, das an die St√§rken des DI-Paradigmas erinnert und unser Interesse daran verdeutlicht - und jetzt wurde es gefunden.  Der Autor zog es vor, Beispiele in Go zu nennen.  Wir hoffen, dass dies Sie nicht daran hindert, seinen Gedanken zu folgen, und hilft, die allgemeinen Prinzipien der Steuerungsinversion und der Arbeit mit Schnittstellen zu verstehen, wenn dieses Thema in Ihrer N√§he ist. <br><br>  Die emotionale F√§rbung des Originals ist etwas leiser, die Anzahl der Ausrufezeichen in der √úbersetzung ist reduziert.  Viel Spa√ü beim Lesen! <br><a name="habracut"></a><br>  Die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellen</a> ist eine verst√§ndliche Technik, mit der Sie Code erstellen k√∂nnen, der einfach zu testen und leicht erweiterbar ist.  Ich war wiederholt davon √ºberzeugt, dass dies das leistungsst√§rkste Architektur-Design-Tool von allen ist. <br><br>  In diesem Artikel wird erl√§utert, was Schnittstellen sind, wie sie verwendet werden und wie sie die Erweiterbarkeit und Testbarkeit von Code bieten.  Schlie√ülich sollte der Artikel zeigen, wie Schnittstellen dazu beitragen k√∂nnen, das Software Delivery Management zu optimieren und die Planung zu vereinfachen! <br><br>  <b>Schnittstellen</b> <br><br>  Die Schnittstelle beschreibt den Vertrag.  Abh√§ngig von der Sprache oder dem Framework kann die Verwendung von Schnittstellen explizit oder implizit diktiert werden.  In der Go-Sprache werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellen also explizit diktiert</a> .  Wenn Sie versuchen, eine Entit√§t als Schnittstelle zu verwenden, diese jedoch nicht vollst√§ndig mit den Regeln dieser Schnittstelle √ºbereinstimmt, tritt ein Fehler bei der Kompilierung auf.  Wenn Sie beispielsweise das obige Beispiel ausf√ºhren, wird der folgende Fehler angezeigt: <br><br><pre><code class="hljs sql">prog.go:22:85: cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> BadPricer literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BadPricer) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockPricer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> isPricerHigherThan100: BadPricer does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implement StockPricer (<span class="hljs-keyword"><span class="hljs-keyword">missing</span></span> CurrentPrice method) Program exited.</code> </pre> <br>  Interfaces ist ein Tool, mit dem der Anrufer vom Angerufenen getrennt werden kann. Dies erfolgt √ºber einen Vertrag. <br><br>  Lassen Sie uns dieses Problem anhand eines Beispiels f√ºr ein Programm f√ºr den automatischen B√∂rsenhandel konkretisieren.  Das H√§ndlerprogramm wird mit einem festgelegten Kaufpreis und einem Tickersymbol aufgerufen.  Dann geht das Programm zur B√∂rse, um das aktuelle Angebot dieses Tickers herauszufinden.  Wenn der Kaufpreis f√ºr diesen Ticker den festgelegten Preis nicht √ºberschreitet, wird das Programm einen Kauf t√§tigen. <br><br><img src="https://habrastorage.org/webt/pp/hx/mv/pphxmvus0-rkxh-vffl9o18bjsq.png"><br><br>  In vereinfachter Form kann die Architektur dieses Programms wie folgt dargestellt werden.  Aus dem obigen Beispiel ist klar, dass der Vorgang des Erhaltens des aktuellen Preises direkt vom HTTP-Protokoll abh√§ngt, √ºber das das Programm den Austauschdienst kontaktiert. <br><br>  Der Status der <code>Action</code> auch direkt von HTTP ab.  Daher sollten beide Staaten vollst√§ndig verstehen, wie HTTP zum Extrahieren von Austauschdaten und / oder zum Abschlie√üen von Transaktionen verwendet wird. <br><br>  So k√∂nnte die Implementierung aussehen: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err)</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... currentPrice := parsePriceFromBody(body) var hasTraded bool var err error if currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) if err == nil { hasTraded = true } } return hasTraded, err }</span></span></code> </pre> <br>  Hier ist der Anrufer ( <code>analyze</code> ) direkt von HTTP abh√§ngig.  Sie muss wissen, wie HTTP-Anforderungen formuliert sind.  Wie wird sie analysiert?  Umgang mit Wiederholungsversuchen, Zeit√ºberschreitungen, Authentifizierung usw.  Sie hat <code>http</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Griff</a> .  <b>Wann immer wir analyse aufrufen, m√ºssen wir auch die <code>http</code> Bibliothek aufrufen</b> . <br><br>  Wie kann uns die Schnittstelle hier helfen?  In dem von der Schnittstelle bereitgestellten Vertrag k√∂nnen Sie das <b>Verhalten</b> und nicht die spezifische <b>Implementierung beschreiben</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockExchange <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CurrentPrice(ticker <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br>  Das Obige definiert das Konzept von <code>StockExchange</code> .  Hier hei√üt es, dass <code>StockExchange</code> das Aufrufen der einzigen <code>CurrentPrice</code> Funktion unterst√ºtzt.  Diese drei Linien scheinen mir die m√§chtigste Architekturtechnik von allen zu sein.  Sie helfen uns, Anwendungsabh√§ngigkeiten viel sicherer zu steuern.  Testen.  Erweiterbarkeit bereitstellen. <br><br>  <b>Abh√§ngigkeitsinjektion</b> <br><br>  Um den Wert von Schnittstellen vollst√§ndig zu verstehen, m√ºssen Sie die als ‚ÄûAbh√§ngigkeitsinjektion‚Äú bezeichnete Technik beherrschen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abh√§ngigkeitsinjektion</a> bedeutet, dass der Anrufer etwas bereitstellt, das der Anrufer ben√∂tigt.  Normalerweise sieht es so aus: Der Anrufer konfiguriert das Objekt und gibt es dann an den Angerufenen weiter.  Dann abstrahiert der angerufene Teilnehmer von der Konfiguration und Implementierung.  In diesem Fall ist eine Mediation bekannt.  Betrachten Sie eine Anfrage an den HTTP Rest-Dienst.  Um den Client zu implementieren, m√ºssen wir eine HTTP-Bibliothek verwenden, die HTTP-Anforderungen formulieren, senden und empfangen kann. <br><br>  Wenn wir die HTTP-Anfrage hinter die Schnittstelle stellen w√ºrden, k√∂nnte der Anrufer getrennt werden, und er w√ºrde "nicht wissen", dass die HTTP-Anfrage tats√§chlich stattgefunden hat. <br><br>  Der Aufrufer sollte nur einen generischen Funktionsaufruf durchf√ºhren.  Dies kann ein lokaler Anruf, ein Fernanruf, ein HTTP-Anruf, ein RPC-Anruf usw. sein.  Der Anrufer wei√ü nicht, was passiert, und normalerweise passt es perfekt zu ihm, solange er die erwarteten Ergebnisse erzielt.  Das Folgende zeigt, wie die Abh√§ngigkeitsinjektion in unserer <code>analyze</code> aussehen k√∂nnte. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StockExchange, ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasTraded <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { hasTraded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasTraded, err }</code> </pre> <br>  Ich bin immer wieder erstaunt dar√ºber, was hier passiert.  Wir haben unseren Abh√§ngigkeitsbaum vollst√§ndig umgekehrt und begonnen, das gesamte Programm besser zu steuern.  Dar√ºber hinaus ist die gesamte Implementierung auch optisch sauberer und verst√§ndlicher geworden.  Wir sehen deutlich, dass die Analysemethode den aktuellen Preis ausw√§hlen, pr√ºfen sollte, ob dieser Preis f√ºr uns geeignet ist, und wenn ja, einen Deal abschlie√üen sollte. <br><br>  Am wichtigsten ist, dass wir in diesem Fall den Anrufer vom Anrufer trennen.  Da der Aufrufer und die gesamte Implementierung √ºber die Schnittstelle von der aufgerufenen getrennt sind, k√∂nnen Sie die Schnittstelle erweitern, indem Sie viele verschiedene Implementierungen davon erstellen.  Mit Schnittstellen k√∂nnen Sie viele verschiedene spezifische Implementierungen erstellen, ohne den Code des angerufenen Teilnehmers √§ndern zu m√ºssen! <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Der Status "Aktuellen Preis <code>StockExchange</code> " in diesem Programm h√§ngt nur von der <code>StockExchange</code> Oberfl√§che ab.  Diese Implementierung wei√ü <b>nichts</b> dar√ºber, wie man den Austauschdienst kontaktiert, wie Preise gespeichert werden oder wie Anfragen gestellt werden.  Wirklich gl√ºckselige Unwissenheit.  Dar√ºber hinaus bilateral.  Die <code>HTTPStockExchange</code> Implementierung wei√ü auch nichts √ºber die Analyse.  √úber den Kontext, in dem die Analyse durchgef√ºhrt wird, wenn sie durchgef√ºhrt wird - weil die Herausforderungen indirekt auftreten. <br><br>  Da Programmfragmente (solche, die von Schnittstellen abh√§ngen) beim √Ñndern / Hinzuf√ºgen / L√∂schen bestimmter Implementierungen nicht ge√§ndert werden m√ºssen, <b>erweist sich ein solches Design als dauerhaft</b> .  Angenommen, wir stellen fest, dass <code>StockService</code> sehr oft nicht verf√ºgbar ist. <br><br>  Wie unterscheidet sich das obige Beispiel vom Aufruf einer Funktion?  Wenn Sie einen Funktionsaufruf anwenden, wird auch die Implementierung sauberer.  Der Unterschied besteht darin, dass wir beim Aufrufen der Funktion immer noch auf HTTP zur√ºckgreifen m√ºssen.  Die <code>analyze</code> delegiert einfach die Aufgabe der Funktion, die <code>http</code> aufrufen soll, anstatt <code>http</code> selbst direkt aufzurufen.  Die ganze St√§rke dieser Technik liegt in der ‚ÄûInjektion‚Äú, dh darin, dass der Anrufer die Schnittstelle zum Angerufenen bereitstellt.  Genau so kommt es zur Abh√§ngigkeitsinversion, bei der die Abrufpreise nur von der Schnittstelle und nicht von der Implementierung abh√§ngen. <br><br>  <b>Mehrere sofort einsatzbereite Implementierungen</b> <br><br>  Zu diesem Zeitpunkt haben wir die <code>analyze</code> und die <code>StockExchange</code> Schnittstelle, aber wir k√∂nnen tats√§chlich nichts N√ºtzliches tun.  Habe gerade unser Programm angek√ºndigt.  Im Moment ist es unm√∂glich, es aufzurufen, da wir noch keine einzige spezifische Implementierung haben, die die Anforderungen unserer Schnittstelle erf√ºllen w√ºrde. <br><br>  Das Hauptaugenmerk im folgenden Diagramm liegt auf dem <code>StockExchange</code> "Aktuellen Preis <code>StockExchange</code> " und seiner Abh√§ngigkeit von der <code>StockExchange</code> Schnittstelle.  Das Folgende zeigt, wie zwei v√∂llig unterschiedliche Implementierungen nebeneinander existieren und der aktuelle Preis nicht bekannt ist.  Dar√ºber hinaus sind beide Implementierungen nicht miteinander verbunden, sondern h√§ngen jeweils nur von der <code>StockExchange</code> Schnittstelle ab. <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Produktion <br><br>  Die urspr√ºngliche HTTP-Implementierung ist bereits in der prim√§ren <code>analyze</code> .  Alles, was uns bleibt, ist, es zu extrahieren und hinter einer konkreten Implementierung der Schnittstelle zu kapseln. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HTTPStockExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se HTTPStockExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... return parsePriceFromBody(body) }</span></span></code> </pre> <br>  Der Code, den wir zuvor mit der Analysefunktion verkn√ºpft haben, ist jetzt autonom und erf√ºllt die <code>StockExchange</code> Schnittstelle. Das hei√üt, wir k√∂nnen ihn jetzt zur <code>analyze</code> .  Wie Sie sich aus den obigen Diagrammen erinnern, ist die Analyse nicht mehr mit der HTTP-Abh√§ngigkeit verbunden.  √úber die Benutzeroberfl√§che kann sich <code>analyze</code> nicht vorstellen, was hinter den Kulissen passiert.  Er wei√ü nur, dass ihm garantiert ein Objekt gegeben wird, mit dem er <code>CurrentPrice</code> aufrufen <code>CurrentPrice</code> . <br><br>  Auch hier nutzen wir die typischen Vorteile der Einkapselung.  Fr√ºher, als http-Anfragen an die Analyse gebunden waren, war die einzige M√∂glichkeit, √ºber http mit dem Austausch zu kommunizieren, indirekt - √ºber die <code>analyze</code> .  Ja, wir k√∂nnten diese Aufrufe in Funktionen kapseln und die Funktion unabh√§ngig ausf√ºhren, aber die Schnittstellen zwingen uns, den Anrufer vom Anrufer zu trennen.  Jetzt k√∂nnen wir <code>HTTPStockExchange</code> unabh√§ngig vom Aufrufer testen.  Dies wirkt sich grundlegend auf den Umfang unserer Tests aus und darauf, wie wir Testfehler verstehen und darauf reagieren. <br><br>  <b>Testen</b> <br><br>  Im vorhandenen Code haben wir die <code>HTTPStockService</code> Struktur, mit der wir separat sicherstellen k√∂nnen, dass sie mit dem Austauschdienst kommunizieren und die von ihm empfangenen Antworten analysieren kann.  <code>StockExchange</code> wir nun sicher, dass die Analyse die Antwort von der <code>StockExchange</code> Schnittstelle korrekt verarbeiten kann und dass dieser Vorgang zuverl√§ssig und reproduzierbar ist. <br><br><pre> <code class="go hljs">currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maxTradePrice { err := doTrade(ticker, currentPrice) }</code> </pre> <br>  Wir k√∂nnten die Implementierung mit HTTP verwenden, aber es h√§tte viele Nachteile.  Das T√§tigen von Netzwerkanrufen beim Testen von Einheiten kann insbesondere bei externen Diensten langsam sein.  Aufgrund von Verz√∂gerungen und einer instabilen Netzwerkverbindung k√∂nnen die Tests unzuverl√§ssig sein.  Wenn wir au√üerdem Tests mit der Aussage ben√∂tigen, dass wir die Transaktion abschlie√üen k√∂nnen, und Tests mit der Aussage, dass wir F√§lle herausfiltern k√∂nnen, in denen die Transaktion NICHT abgeschlossen werden sollte, w√§re es schwierig, echte Produktionsdaten zu finden, die beide zuverl√§ssig erf√ºllen Bedingungen.  Man k√∂nnte <code>maxTradePrice</code> w√§hlen und jede der Bedingungen auf diese Weise k√ºnstlich imitieren, zum Beispiel mit <code>maxTradePrice := -100</code> Transaktion nicht abgeschlossen werden und <code>maxTradePrice := 10000000</code> sollte offensichtlich mit der Transaktion enden. <br><br>  Aber was passiert, wenn uns im Austauschdienst ein bestimmtes Kontingent zugewiesen wird?  Oder ob wir den Zugang bezahlen m√ºssen?  Werden (und sollten) wir unsere Quote wirklich bezahlen oder ausgeben, wenn es um Unit-Tests geht?  Im Idealfall sollten Tests so oft wie m√∂glich durchgef√ºhrt werden, damit sie schnell, kosteng√ºnstig und zuverl√§ssig sind.  Ich denke, aus diesem Absatz geht hervor, warum die Verwendung einer Version mit reinem HTTP in Bezug auf Tests irrational ist! <br><br>  <b>Es gibt einen besseren Weg, und es beinhaltet die Verwendung von Schnittstellen!</b> <br><br>  Mit einer Schnittstelle k√∂nnen Sie die <code>StockExchange</code> Implementierung sorgf√§ltig herstellen, <code>StockExchange</code> wir schnell, sicher und zuverl√§ssig <code>analyze</code> k√∂nnen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StubExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.Price } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_MakeTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">11</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Errorf(<span class="hljs-string"><span class="hljs-string">"expected err == nil received: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !traded { t.Error(<span class="hljs-string"><span class="hljs-string">"expected traded == true"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_DontTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">9</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  Der Stub des Austauschdienstes wird oben verwendet, wodurch der f√ºr uns interessante Zweig der <code>analyze</code> gestartet wird.  Anschlie√üend werden in jedem Test Aussagen getroffen, um sicherzustellen, dass die Analyse das tut, was ben√∂tigt wird.  Obwohl dies ein Testprogramm ist, deutet meine Erfahrung darauf hin, dass Komponenten / Architekturen, bei denen die Schnittstellen ungef√§hr auf diese Weise verwendet werden, auf diese Weise auch auf Haltbarkeit im Kampfcode getestet werden !!!  Dank der Schnittstellen k√∂nnen wir den im Speicher gesteuerten <code>StockExchange</code> , der zuverl√§ssige, leicht konfigurierbare, leicht verst√§ndliche, reproduzierbare und blitzschnelle Tests bietet !!! <br><br>  <b>Unpin - Anruferkonfiguration</b> <br><br>  Nachdem wir nun besprochen haben, wie Schnittstellen verwendet werden, um den Anrufer vom Angerufenen zu trennen, und wie mehrere Implementierungen durchgef√ºhrt werden, haben wir noch keinen kritischen Aspekt angesprochen.  Wie kann eine bestimmte Implementierung zu einem genau definierten Zeitpunkt konfiguriert und bereitgestellt werden?  Sie k√∂nnen die Analysefunktion direkt aufrufen, aber was ist in der Produktionskonfiguration zu tun? <br><br>  Hier bietet sich die Implementierung von Abh√§ngigkeiten an. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ticker = flag.String(<span class="hljs-string"><span class="hljs-string">"ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stock ticker symbol to trade for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxTradePrice = flag.Float64(<span class="hljs-string"><span class="hljs-string">"maxtradeprice"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"max price to pay for a share of the ticker symbol."</span></span> se := HTTPStockExchange{} analyze(se, *ticker, *maxTradePrice) }</code> </pre> <br>  Genau wie in unserem Testfall wird die spezifische konkrete Implementierung von StockExchange, die mit <code>analyze</code> wird, vom Aufrufer au√üerhalb von analyse konfiguriert.  Dann wird es zur <code>analyze</code> √ºbergeben (injiziert).  Dadurch wird sichergestellt, dass bei der Analyse von NICHTS bekannt ist, wie <code>HTTPStockExchange</code> konfiguriert ist.  Vielleicht m√∂chten wir die http-Dom√§ne, die wir verwenden m√∂chten, in Form eines Befehlszeilenflags bereitstellen, und dann muss die Analyse nicht ge√§ndert werden.  Oder was tun, wenn wir eine Art Authentifizierung oder Token bereitstellen m√ºssen, um auf <code>HTTPStockExchange</code> , das aus der Umgebung extrahiert wird?  Auch hier sollte sich die Analyse nicht √§ndern. <br><br>  Die Konfiguration erfolgt auf einer Ebene au√üerhalb der <code>analyze</code> , wodurch die Analyse vollst√§ndig von der Notwendigkeit befreit wird, ihre eigenen Abh√§ngigkeiten zu konfigurieren.  Damit wird eine strikte Aufgabentrennung erreicht. <br><br><img src="https://habrastorage.org/webt/nq/jt/_i/nqjt_id9j2-yc7rzozkrldtrwxq.png"><br><br>  <b>Regale Entscheidungen</b> <br><br>  Vielleicht reichen die obigen Beispiele v√∂llig aus, aber Schnittstellen und Abh√§ngigkeitsinjektion bieten noch viele andere Vorteile.  Schnittstellen erm√∂glichen es, Entscheidungen √ºber bestimmte Implementierungen zu verschieben.  Obwohl Entscheidungen erfordern, dass wir entscheiden, welches Verhalten wir unterst√ºtzen, k√∂nnen wir sp√§ter Entscheidungen √ºber bestimmte Implementierungen treffen.  Angenommen, wir wussten, dass wir automatisierte Transaktionen durchf√ºhren wollten, waren uns aber noch nicht sicher, welchen Angebotsanbieter wir verwenden w√ºrden.  Eine √§hnliche Klasse von L√∂sungen wird bei der Arbeit mit Data Warehouses st√§ndig behandelt.  Was sollte unser Programm verwenden: MySQL, Postgres, Redis, Dateisystem, Cassandra?  Letztendlich sind dies alles Implementierungsdetails, und die Schnittstellen erm√∂glichen es uns, endg√ºltige Entscheidungen zu diesen Themen aufzuschieben.  Sie erm√∂glichen es uns, die Gesch√§ftslogik unserer Programme zu entwickeln und im letzten Moment auf bestimmte technologische L√∂sungen umzusteigen! <br><br>  Trotz der Tatsache, dass diese Technik allein viele M√∂glichkeiten l√§sst, geschieht auf der Ebene der Projektplanung etwas Magisches.  Stellen Sie sich vor, was passieren wird, wenn wir der Austauschschnittstelle eine weitere Abh√§ngigkeit hinzuf√ºgen. <br><br><img src="https://habrastorage.org/webt/pb/bf/x-/pbbfx-mcx9oabbpa-tkkeivgtnq.png"><br><br>  Hier werden wir unsere Architektur in Form eines gerichteten azyklischen Graphen neu konfigurieren, so dass wir, sobald wir uns auf die Details der Austauschschnittstelle einigen, mit <code>HTTPStockExchange</code> mit der Pipeline <code>HTTPStockExchange</code> .  Wir haben eine Situation geschaffen, in der das Hinzuf√ºgen einer neuen Person zum Projekt uns hilft, schneller voranzukommen.  Indem wir unsere Architektur auf diese Weise optimieren, sehen wir besser, wo, wann und wie lange wir zus√§tzliche Personen in das Projekt einbeziehen k√∂nnen, um die Bereitstellung des gesamten Projekts zu beschleunigen.  Da die Verbindung zwischen unseren Schnittstellen schwach ist, ist es au√üerdem normalerweise einfach, sich an der Arbeit zu beteiligen, beginnend mit den Implementierungsschnittstellen.  Sie k√∂nnen <code>HTTPStockExchange</code> v√∂llig unabh√§ngig von unserem Programm entwickeln, testen und testen! <br><br>  Die Analyse architektonischer Abh√§ngigkeiten und die Planung anhand dieser Abh√§ngigkeiten k√∂nnen Projekte drastisch beschleunigen.  Mit dieser speziellen Technik konnte ich sehr schnell Projekte abschlie√üen, f√ºr die mehrere Monate vorgesehen waren. <br><br>  <b>Vor uns</b> <br><br>  Jetzt sollte klarer sein, wie die Schnittstellen und die Implementierung von Abh√§ngigkeiten die Dauerhaftigkeit des entworfenen Programms sicherstellen.  Angenommen, wir wechseln unseren Angebotsanbieter oder starten das Streaming von Kontingenten und speichern sie in Echtzeit.  Es gibt so viele andere M√∂glichkeiten, wie Sie m√∂chten.  Die <code>StockExchange</code> in ihrer aktuellen Form unterst√ºtzt jede Implementierung, die f√ºr die Integration in die <code>StockExchange</code> Schnittstelle geeignet ist. <br><br><pre> <code class="go hljs">se.CurrentPrice(ticker)</code> </pre> <br>  So k√∂nnen Sie in vielen F√§llen auf √Ñnderungen verzichten.  Nicht in allen, aber in den vorhersehbaren F√§llen, denen wir begegnen k√∂nnen.  Wir sind nicht nur immun gegen die Notwendigkeit, den <code>analyze</code> zu √§ndern und seine Schl√ºsselfunktionalit√§t zu √ºberpr√ºfen, sondern k√∂nnen auch problemlos neue Implementierungen anbieten oder zwischen Lieferanten wechseln.  Wir k√∂nnen auch die spezifischen Implementierungen, die wir bereits haben, problemlos erweitern oder aktualisieren, ohne die <code>analyze</code> √§ndern oder √ºberpr√ºfen zu m√ºssen! <br><br>  Ich hoffe, dass die obigen Beispiele √ºberzeugend zeigen, wie die Schw√§chung der Kommunikation zwischen Entit√§ten im Programm durch die Verwendung von Schnittstellen die Abh√§ngigkeiten vollst√§ndig neu ausrichtet und den Anrufer vom Anrufer trennt.  Dank dieser Trennung h√§ngt das Programm nicht von einer bestimmten Implementierung ab, sondern von einem bestimmten <b>Verhalten</b> .  Dieses Verhalten kann durch eine Vielzahl von Implementierungen bereitgestellt werden.  Dieses kritische Konstruktionsprinzip wird auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ententypisierung bezeichnet</a> . <br><br>  Das Konzept der Schnittstellen und die Abh√§ngigkeit vom Verhalten und nicht von der Implementierung ist so m√§chtig, dass ich Schnittstellen als ein Sprachprimitiv betrachte - ja, das ist ziemlich radikal.  Ich hoffe, dass sich die oben diskutierten Beispiele als ziemlich √ºberzeugend erwiesen haben, und Sie werden zustimmen, dass die Schnittstellen und die Abh√§ngigkeitsinjektion von Anfang an verwendet werden sollten.  In fast allen Projekten, an denen ich gearbeitet habe, waren nicht eine, sondern mindestens zwei Implementierungen erforderlich: f√ºr die Produktion und zum Testen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428075/">https://habr.com/ru/post/de428075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428063/index.html">Browser verweigern die Unterst√ºtzung f√ºr TLS 1.0 und 1.1</a></li>
<li><a href="../de428065/index.html">Weniger bedeutet nicht schlimmer: Skyrmionen und Dom√§nenw√§nde in Ferromagneten</a></li>
<li><a href="../de428067/index.html">AntiFuzzing: Sicherheit durch Dunkelheit !?</a></li>
<li><a href="../de428069/index.html">Optimieren Sie den Lastausgleich in der Veeam Backup & Replication-Infrastruktur</a></li>
<li><a href="../de428073/index.html">Rust 1.30 Release</a></li>
<li><a href="../de428077/index.html">React.js: Ein Leitfaden f√ºr Anf√§nger</a></li>
<li><a href="../de428079/index.html">Anwendung von SOLID-Prinzipien zur Reaktion auf die Anwendungsentwicklung</a></li>
<li><a href="../de428081/index.html">Verwenden von RxJS in der Reaktionsentwicklung zum Verwalten des Anwendungsstatus</a></li>
<li><a href="../de428083/index.html">Webanalyse beeinflusst Matrix - das strategische System von Avinash Koshik</a></li>
<li><a href="../de428085/index.html">Frontend schl√§gt zur√ºck: Top 10 (?) HolyJS 2018 Piter berichtet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>