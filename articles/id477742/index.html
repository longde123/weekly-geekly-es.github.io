<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎨 🙊 🗒️ "Halo, Checkmarx!" Cara menulis permintaan untuk Checkmarx SAST dan menemukan kerentanan keren 📖 🌴 👨🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Dalam artikel ini saya ingin berbicara tentang pengalaman kami dalam membuat pertanyaan saya di Checkmarx SAST. 

 Ketika Anda pertama ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Halo, Checkmarx!" Cara menulis permintaan untuk Checkmarx SAST dan menemukan kerentanan keren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/477742/"><img src="https://habrastorage.org/webt/sh/ll/ln/shlllnc6iduoendolw26rabdugk.jpeg"><br><br>  Halo, Habr! <br><br>  Dalam artikel ini saya ingin berbicara tentang pengalaman kami dalam membuat pertanyaan saya di Checkmarx SAST. <br><br>  Ketika Anda pertama kali berkenalan dengan analisa ini, Anda mungkin mendapatkan kesan bahwa selain mencari enkripsi / hashing algoritma yang lemah dan tumpukan false positive, itu tidak mengembalikan apa pun.  Tetapi ketika dikonfigurasi dengan benar, itu adalah alat yang sangat kuat yang dapat mencari bug serius. <br><br>  Kami akan memahami seluk-beluk bahasa query Checkmarx SAST dan menulis 2 pertanyaan untuk mencari injeksi SQL dan Referensi Objek Langsung Tidak Aman. <br><a name="habracut"></a><br><br><h2>  Entri </h2><br>  Setelah lama mencari panduan atau artikel tentang Checkmarx, menjadi jelas bagi saya bahwa selain dokumentasi resmi, tidak ada informasi yang cukup berguna.  Dan dokumentasi resmi tidak mengatakan bahwa semuanya menjadi sangat jelas dan dapat dimengerti.  Misalnya, saya tidak bisa menemukan praktik terbaik, bagaimana mengatur permintaan override dengan benar, bagaimana menulis kueri "untuk boneka," dll. Ya, ada dokumentasi tentang fungsi Bahasa Query CMx, tapi di sini cara menggabungkan fungsi-fungsi ini menjadi satu permintaan, dokumentasi tidak ditulis. <br><br>  Mungkin kurangnya artikel dan panduan dari komunitas Checkmarx terkait dengan tingginya biaya alat dan, sebagai akibatnya, audiens yang kecil.  Atau mungkin hanya beberapa orang yang repot melakukan fine tuning dan menggunakan solusinya, di luar kotak. <br><br>  Dalam pengalaman saya, saya melihat lebih banyak bahwa SAST lebih banyak digunakan untuk mematuhi formalitas yang terkait dengan berbagai persyaratan di pihak pelanggan daripada untuk mencari bug nyata.  Dengan pendekatan ini, sebagai hasilnya, kami memiliki, paling tidak, sejumlah kecil “kerentanan,” yang hampir secara otomatis dikenal sebagai “tidak dapat dieksploitasi” (karena mereka ada dalam 99,9% kasus). <br><br>  Perlu dicatat bahwa Checkmarx sendiri berusaha memperbarui kueri mereka sehingga mereka memberikan hasil terbaik di luar kotak.  Tapi pertanyaan CMx Query Language disesuaikan dengan "kasus umum".  Pencarian awal untuk token didasarkan pada nama.  Sebagai contoh, CMx SAST mengasumsikan bahwa semua permintaan ke database akan terlihat seperti ini: * createQuery * atau * createSQLQuery *.  Tetapi jika pengembangan internal digunakan untuk bekerja dengan database, dan metode untuk query database disebut berbeda, misalnya * driveMyQuery *, maka semua metode SQL akan dilewati.  Misalnya, pelanggan kami menggunakan ORM khusus untuk SQL DB.  Dalam hal ini, CMx kueri dari kotak dilewati semua injeksi SQL. <br><br><h4>  Singkatan dan Definisi </h4><br>  <b>CMx</b> - Checkmarx SAST. <br>  <b>CMxQL</b> - Checkmarx SAST bahasa permintaan <br>  <b>Token</b> - string dengan nilai tertentu adalah hasil kerja penganalisa leksikal (yang juga disebut tokenization) <br><br><h3>  Aplikasi tes </h3><br>  Untuk menulis artikel, saya membuat sketsa beberapa kode Java, sebuah aplikasi tes kecil.  Kode ini adalah salinan perkiraan sebagian kecil dari sistem nyata.  Meskipun secara umum kode aplikasi pengujian tidak jauh berbeda dari kode backend HTTP lainnya.  Bagian kunci dari kode aplikasi pengujian akan terlihat di tangkapan layar. <br><br><h4>  Aplikasi tes memiliki struktur sebagai berikut </h4><br>  Kelas <i>WebRouter</i> untuk memproses permintaan HTTP yang masuk; 4 metode untuk memproses URL di dalam: <br><ul><li>  <i>/ getTransaction</i> - menerima <i>id</i> transaksi di input <i>dan mengembalikan info</i> tentang itu, <i>id</i> mengambilnya sebagai string, dan meneruskannya ke <i>getTransactionInfo (transactionId)</i> =&gt; <i>getTransactionInfo (transactoinId)</i> - membuat transactionId digabungkan dengan permintaan SQL (mis., injeksi SQL diperoleh); </li><li>  <i>/ getSecureTransaction</i> - menerima <i>id</i> transaksi sebagai input <i>dan mengembalikan info</i> tentang itu, <i>id</i> mengambilnya sebagai string dan meneruskannya <i>getTransactionInfoSecured ()</i> =&gt; <i>getTransactionInfoSecured (transactoinId)</i> - pertama-tama <i>melemparkan</i> string <i>transactionId</i> untuk mengetik Long, dan kemudian menggabungkannya dengan query SQL (dalam hal ini kasus injeksi tidak dieksploitasi); </li><li>  <i>/ getSettings</i> - menerima <i>userId</i> dan <i>mailboxId sebagai input</i> - dan mengeluarkan pengaturan kotak surat.  Tidak memverifikasi bahwa kotak <i>pesan</i> milik pengguna; </li><li>  <i>/ getSecureSettings</i> - juga menerima <i>userId</i> dan <i>mailboxId ke input</i> dan menampilkan pengaturan kotak pesan.  TETAPI memeriksa bahwa kotak <i>surat itu</i> milik pengguna. </li></ul><br><br><h2>  CMx: Informasi Umum dan Definisi Dasar </h2><br><h3>  Sebelum Anda mulai mengembangkan kueri </h3><br>  Pengembangan kueri dilakukan dalam program terpisah CxAuditor.  Di CxAuditor Anda perlu memindai semua kode (buat proyek lokal), yang akan kami tulis pertanyaannya.  Setelah itu, Anda dapat menulis dan menjalankan kueri baru.  Dengan basis kode yang besar, pemindaian primer dapat memakan waktu berjam-jam dan memori sebesar gigabita.  Setelah itu, setiap permintaan tidak akan dieksekusi cukup cepat.  Ini sama sekali tidak cocok untuk pengembangan. <br><br>  Oleh karena itu, Anda dapat mengambil satu set kecil file dari proyek, idealnya dengan bug yang ditemukan dalam kode di depan jenis di mana kami menulis permintaan (atau menempatkan bug di sana secara manual) dan memindai hanya set file ini.  Tidak perlu mematuhi struktur file proyek.  Yaitu, jika Anda memiliki paket Java A dan B, dan kelas-kelas dalam paket B menggunakan kelas-kelas dan metode-metode paket A, Anda dapat meletakkan semua ini ke dalam satu direktori, dan CMx akan tetap memahami hubungan dan membangun rantai panggilan antar file dengan benar (baik, atau hampir selalu benar, meskipun kesalahan hampir tidak terkait dengan struktur file proyek). <br><br><h3>  Definisi dasar </h3><br><h4>  Cxlist </h4><br>  Jenis data utama dalam CMx.  Hasil dari hampir semua fungsi <i>CMxQL</i> adalah <i>CxList</i> .  Ini banyak elemen dengan properti tertentu.  Properti yang paling berguna untuk pengembangan akan dipertimbangkan di bawah ini. <br><br><h4>  hasil </h4><br>  CMxQL memiliki <i>hasil</i> variabel bawaan.  Set yang berisi variabel <i>hasil</i> , setelah eksekusi seluruh kueri akan ditampilkan sebagai hasilnya. <br><br>  Artinya, operasi terakhir dari setiap kueri harus berupa <i>hasil</i> string <i>= WHATEVER</i> , misalnya: <br><pre><code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"anyname"</span></span>);</code> </pre> <br><h4>  elemen aliran dan kode </h4><br>  Sebagian besar fungsi CMxQL berdasarkan jenis nilai yang dikembalikan dibagi menjadi 2, yang mengembalikan "elemen kode" dan yang mengembalikan Flow.  Dalam kedua kasus, hasilnya adalah <i>CxList</i> .  Tetapi isinya akan sedikit berbeda untuk elemen Flow dan kode. <br><ul><li>  <b>Elemen kode</b> - token - misalnya, variabel, pemanggilan metode, penugasan, dll.; </li><li>  <b>Flow</b> - hubungan antara token yang diberikan. </li></ul><br><br><h4>  Semua dan “sub” Semua </h4><br>  Setiap fungsi CMxQL dapat dilakukan pada set <i>Semua</i> (itu berisi semua token dari seluruh kode yang dipindai, kita sudah melihat contoh dengan <i>hasil</i> ) atau pada set <i>CxList</i> , yang pada gilirannya diperoleh sebagai hasil dari beberapa operasi dalam permintaan, misalnya, permintaan: <br><pre> <code class="actionscript hljs">CxList newList = CxList.New();</code> </pre> <br>  akan membuat set kosong, yang kemudian bisa kita isi dengan elemen menggunakan metode <i>Add ()</i> , dan kemudian cari dengan elemen set baru: <br><pre> <code class="actionscript hljs">CxList newFind = newList.FindByName(<span class="hljs-string"><span class="hljs-string">"narrowedScope"</span></span>);</code> </pre> <br><h4>  Properti item yang ditemukan </h4><br>  Setiap elemen dari set CxList memiliki beberapa properti.  Saat menganalisis hasil untuk menulis kueri, yang paling berguna adalah: <br><br><ul><li>  <b>SourceFile</b> - nama file yang berisi elemen ini; </li><li>  <b>Source Line</b> - nomor baris dengan token; </li><li>  <b>Nama Sumber</b> - nama token.  Setara dengan token, yaitu jika variabel tersebut disebut var1, maka Sumber Nama = var1; </li><li>  <b>Jenis Sumber</b> - jenis token.  Misalnya, jika itu adalah string, maka itu akan menjadi StringLiteral, jika metode ini disebut, maka MethodInvokeExpr, dan banyak lainnya; </li><li>  <b>File tujuan</b> </li><li>  <b>Jalur Tujuan;</b> </li><li>  <b>Nama Tujuan;</b> </li><li>  <b>Jenis Tujuan.</b> </li></ul><br><br>  Sumber dan Tujuan akan berbeda jika elemen dari set hasil adalah Flow, dan sebaliknya mereka akan cocok jika hasilnya adalah elemen kode. <br><br><h2>  Mulai buat kueri </h2><br>  Semua fungsi CMxQL dapat dibagi menjadi beberapa jenis.  Di sini, menurut pendapat saya, orang dapat mencatat kelemahan utama dari dokumentasi CMxQL, semua fungsi di dock dijelaskan secara sederhana dalam urutan abjad, sementara akan jauh lebih mudah untuk menyusunnya berdasarkan fungsi dan hanya berdasarkan abjad. <br><br><ul><li>  Fungsi pencarian - hampir semua fungsi CMxQL dengan nama <b>FindBy *</b> dan <b>GetBy *</b> ; </li><li>  Fungsi operasi pada set adalah penambahan, pengurangan, persimpangan, iterasi atas elemen, dll. </li><li>  Fungsi Analisis - Ini pada dasarnya adalah <b>* Dipengaruhi oleh *</b> <b>* Mempengaruhi</b> fungsi <b>*</b> . </li></ul><br><br>  Prinsip dasar pertanyaan adalah pergantian jenis fungsi ini.  Pertama, menggunakan fungsi pencarian, kami hanya memilih token yang menarik bagi kami oleh properti tertentu.  Menggunakan operasi pada set, kita dapat menggabungkan set yang berbeda dengan sifat token yang berbeda menjadi satu, atau sebaliknya, kurangi yang lain dari yang satu.  Kemudian, menggunakan fungsi analisis, kami membangun Aliran Kode dan mencoba memahami apakah kerentanan potensial bergantung pada parameter di titik masuk. <br><br>  Pilihan tempat untuk memulai pencarian, dan secara umum seluruh jalur pencarian, tergantung pada kode spesifik, dan lebih tepatnya, bahkan pada "teks".  Dalam beberapa kasus, lebih mudah untuk mencari pertanyaan pengguna dari titik masuk, dalam beberapa kasus lebih mudah untuk memulai dari "akhir" atau bahkan dari tengah.  Itu semua tergantung pada kode spesifik dan Anda perlu mendekati masing-masing repositori. <br><br><h2>  Contoh: Cari injeksi SQL </h2><br>  Paket pencarian, dalam kurung saya menunjukkan nama set (variabel dalam kueri): <br><br><ol><li>  Tetapkan pengecualian - token yang dapat segera dibuang dari lingkup pencarian ( <i>exclusionList</i> ); </li><li>  Menentukan lokasi pemeriksaan sanitasi / keamanan ( <i>sanitasi</i> ); </li><li>  Temukan semua tempat tingkat rendah dengan eksekusi permintaan di database ( <i>runSuperSecureSQLQuery</i> ); </li><li>  Temukan semua parameter dari metode yang disebut <i>runSuperSecureSQLQuery</i> ( <i>runSSSQParams</i> ); </li><li>  Temukan titik entri (metode induk dan parameternya) untuk tempat pelaksanaan kueri dalam database ( <i>entryPointsParameters</i> ); </li><li>  Temukan dependensi parameter <i>runSSSQParams</i> pada <i>entryPoints</i> , sementara hanya tempat-tempat di mana tidak ada <i>sanitasi sanitasi</i> input <i>sanitasi</i> . </li></ol><br><br>  Akibatnya, kami mendapatkan metode tingkat rendah dengan kueri SQL, di mana parameter kueri SQL: <br><br><ul><li>  tergantung pada parameter metode; </li><li>  parameter diterima sebagai string; </li><li>  parameter digabungkan dengan permintaan. </li></ul><br>  Kami tidak akan memeriksa apakah kami dapat mengontrol parameter ini, seperti  kami percaya bahwa ada mekanisme untuk memetakan variabel ke dalam kueri dan ada pemain ke tipe numerik untuk angka, dan penggabungan string selalu dianggap berbahaya.  Bahkan jika tidak ada kontrol atas saluran sekarang, itu mungkin muncul di rilis baru. <br><br><h3>  SQLi: Langkah 1. Mendefinisikan Pengecualian </h3><br>  Dalam pengecualian, Anda perlu menambahkan kelas-kelas atau file di mana nama token dapat cocok dengan yang Anda cari, karena  token ini akan menyebabkan entri yang tidak valid. <br><br>  Misalnya, metode untuk mengakses database disebut <i>runSuperSecureSQLquery</i> .  Kami berasumsi bahwa metode <i>runSuperSecureSQLquery</i> di dalam diimplementasikan dengan aman.  Dan tugas kita adalah menemukan tempat-tempat yang tidak aman menggunakan metode itu sendiri.  Untuk injeksi SQL, tempat penyatuan parameter yang dikontrol pengguna tidak akan menjadi tempat yang aman.  Dan tempat-tempat yang aman untuk memetakan parameter ke dalam struktur ORM atau, misalnya, untuk parameter numerik, ini merupakan cetakan untuk tipe yang sesuai.  Kita tidak perlu memindai semua kode yang terletak "lebih dalam" daripada <i>runSuperSecureSQLquery</i> , yang berarti lebih baik untuk mengecualikannya untuk menghindari temuan yang tidak berguna. <br><br>  Untuk mencari pengecualian seperti itu, nyaman untuk menggunakan fungsi CMxQL: <br><ul><li>  <b>FindByFileName ()</b> - akan menemukan set semua token dalam file tertentu; </li><li>  <b>GetByClass ()</b> - akan menemukan set semua token di kelas dengan nama yang diberikan. </li></ul><br><br>  Untuk aplikasi pengujian, pengecualian ini adalah kelas <i>Sesi</i> , yang berisi implementasi metode <i>runSuperSecureSQLquery</i> . <br>  Contoh permintaan untuk mengecualikan kode di kelas <i>Session</i> (metode <i>GetByClass () akan</i> memeriksa token mana yang diteruskan ke input yang memiliki tipe <i>CMx</i> dari <i>ClassDecl</i> dan akan mengeluarkan banyak token dari kelas ini) <br><br><pre> <code class="java hljs">CxList exclusionList = All.GetByClass(All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Session*"</span></span>)); result = exclusionList;</code> </pre> <br><br>  Atau cara lain adalah dengan membuang kode di seluruh file <i>Session.java</i> : <br><br><pre> <code class="java hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*Session.java"</span></span>); result = exclusionList;</code> </pre> <br><br>  Tanda bintang sebelum nama itu penting, karena nama file menyertakan seluruh jalur. <br>  Sekarang kami memiliki banyak token yang dapat dikurangi pada langkah-langkah selanjutnya dari lingkup pencarian. <br><br>  Hasil pencarian token di dalam kelas <i>Sesi</i> : <br><br><img src="https://habrastorage.org/webt/x3/gz/vx/x3gzvxxumbbu-th01llyjbymkoo.png"><br><br><h3>  SQLi: Langkah 2. Menentukan Tempat Sanitasi </h3><br>  Ada 2 metode API dalam aplikasi pengujian (lihat deskripsi singkat tentang aplikasi pengujian).  Perbedaan antara kedua metode API adalah <i>getTransactionInfo ()</i> menggabungkan parameter transactionId dalam query SQL, dan <i>getTransactionInfoSecured ()</i> pertama-tama <i>mengubah</i> transactionId menjadi Long, dan kemudian meneruskannya sebagai string.  Kerentanan (gabungan parameter) tertanam di kedua metode.  Tetapi berkat casting ke Long di <i>getTransactionInfoSecured ()</i> , metode terakhir tidak rentan terhadap injeksi, karena ketika kita mencoba untuk melewatkan injeksi (string) kita mendapatkan Java Exception. <br><br>  Dalam contoh ini, kami akan mempertimbangkan pemeran untuk Long sebagai situs sanitasi.  Untuk menemukan token ini: <br><br><pre> <code class="java hljs">CxList sanitization = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Long*"</span></span>); result = sanitization;</code> </pre> <br><br>  Contoh hasil: <br><br><img src="https://habrastorage.org/webt/hb/ms/vx/hbmsvxmjwynfncf96eyclx2ey8y.png"><br><br>  Hasilnya termasuk token dengan metode YP <i>Long</i> dan metode <i>getValueAsLong</i> , yang secara internal <i>mengkonversi</i> nilai menjadi <i>Long</i> .  Anda perlu meninjau hasilnya dengan hati-hati untuk memastikan tidak ada yang berlebihan. <br><br><h3>  SQLi: Langkah 3. Temukan semua tempat tingkat rendah dengan eksekusi permintaan dalam database </h3><br>  Kueri berikut akan menemukan semua tempat menggunakan token runSuperSecureSQLQuery (yang digunakan untuk mengakses database): <br><br><pre> <code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>)</code> </pre> <br>  Hasil pencarian berdasarkan nama token runSuperSecureSQLQuery: <br><img src="https://habrastorage.org/webt/qm/bh/ci/qmbhci6ucl_wx3sb_9zqfkkpim8.png"><br><br>  Selain itu, untuk tempat di mana metode ini disebut (kelas <i>Penagihan</i> ), hanya token pemanggilan metode (tipe <i>MethodInvokeExpr</i> ) yang akan ditemukan, dan untuk tempat deklarasi metode (kelas <i>Sesi</i> ), semua token - variabel juga akan ditemukan. <br><br>  Kami memfilter hanya token panggilan metode: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery;</code> </pre> <br>  Hasil: <br><img src="https://habrastorage.org/webt/or/82/dw/or82dwxfoze-fcbko2b2mljfyus.png"><br><br>  Akibatnya, kami mendapat 7 tempat, 4 di antaranya panggilan yang diperlukan untuk metode <i>runSuperSecureSQLQuery ()</i> (kelas <i>Penagihan</i> dan <i>Pengguna</i> ).  2 - panggilan ke metode internal runSuperSecureSQLQuery () di dalam kelas <i>Session</i> , dan satu lagi adalah metode <i>add</i> , yang merupakan sejenis keanehan pencarian CMxQL.  Anggap saja saya tidak mengharapkannya ada di daftar =) Token di kelas <i>Sesi</i> , seperti yang kami temukan di langkah 1, tidak menarik bagi kami, jadi kami hanya akan mengurangi mereka dari hasilnya: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery - exclusionList;</code> </pre> <br>  Kami mendapatkan daftar panggilan yang valid ke metode yang diperlukan: <br><br><img src="https://habrastorage.org/webt/sh/c8/ix/shc8ixcpk9wrkmdv_vzqfz5wj80.png"><br><br>  Perhatikan fungsi <i>FindByType ()</i> dan <i>typeof ()</i> di kueri sebelumnya.  Jika kita ingin mencari berdasarkan tipe CMx, yaitu, dengan properti <i>CxList</i> “Source Type” - maka kita menggunakan <i>typeof (Source Type)</i> .  Jika kita ingin melakukan pencarian berdasarkan tipe data, maka kita perlu melewatkan parameter hanya sebagai string.  Sebagai contoh: <br><br><pre> <code class="java hljs">result = All.FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre><br>  akan menemukan semua token java dengan tipe String. <br><br><h3>  SQLi: Langkah 4. Temukan semua parameter metode yang disebut runSuperSecureSQLQuery </h3><br>  Untuk mencari parameter metode, fungsi <i>CMxQL GetParameters () digunakan</i> : <br><br><pre> <code class="actionscript hljs">CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); result = runSSSQParams;</code> </pre> <br>  Hasil: <br><br><img src="https://habrastorage.org/webt/s4/4h/id/s44hidweor1j61xs1dkwbewrpja.png"><br><br><h3>  SQLi: Langkah 5. Temukan titik masuk untuk lokasi eksekusi kueri dalam database </h3><br>  Untuk melakukan ini, pertama kita mendapatkan nama-nama metode induk, yang di dalamnya adalah panggilan ke database <i>runSuperSecureSQLQuery</i> , dan kemudian kita mendapatkan parameternya.  Untuk mencari token induk, fungsi <i>CMxQL GetAncOfType () digunakan</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodDecl)); result = entryPoints;</code> </pre> <br><br>  Dalam kueri ini, untuk set runSuperSecureSQLQuery, kembalikan semua token induk dari tipe MethodDecl - ini adalah metode sebelumnya dalam tumpukan panggilan: <br><br><img src="https://habrastorage.org/webt/we/8w/7u/we8w7ucxjxvtgzerknbgjxir8fa.png"><br><br>  Untuk mencari parameter metode, kami juga menggunakan <i>GetParameters ()</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre> <br><br>  Kueri akan mengembalikan parameter subset dari <i>entryPoints</i> dengan Java type String: <br><br><img src="https://habrastorage.org/webt/7y/mw/tf/7ymwtfxg94oxlwggez3zhpfvcko.png"><br><br><h3>  SQLi: Langkah 6. Cari dependensi parameter runSSSQParams pada entryPointsParameters, sementara hanya tempat-tempat di mana tidak ada input input sanitasi </h3><br>  Pada langkah ini, kami menggunakan fungsi analisis.  Fungsi-fungsi berikut digunakan untuk menganalisis kode aliran: <br><br><ul><li>  Dipengaruhi oleh () </li><li>  Dipengaruhi oleh BlyAndNotSanitized () </li><li>  Pengaruh pada () </li><li>  InfluencingOnAndNotSanitized () </li><li>  NotInfluencedBy () </li><li>  NotInfluencingOn () </li></ul><br><br>  Untuk menemukan Alur parameter permintaan <i>runSSSQParams</i> tergantung pada parameter metode induk <i>entryPointsParameters</i> dan mengecualikan token sanitasi: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization);</code> </pre> <br><br>  Namun, saya tidak yakin apakah fungsi <i>* AndNotSanitized</i> di dalam melakukan beberapa sulap, dan itu lebih mirip metode hanya mengurangi set sanitasi dari hasilnya.  Yaitu, jika Anda melakukannya: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedBy(entryPointsParameters) - sanitization;</code> </pre> <br><br>  ternyata hal yang sama.  Walaupun mungkin saya hanya tidak menemukan opsi ketika masih ada perbedaan. <br><br>  Hasil kueri memberi kita Aliran yang dibangun dengan benar: <br><br><img src="https://habrastorage.org/webt/ru/hs/2d/ruhs2dlh7alil7njbzsf2jke9qw.png"><br><br>  Got Flow dengan potensi injeksi SQL.  Seperti yang bisa dilihat dari tangkapan layar, Checkmarx mengembalikan 3 Flow.  Aliran dalam tangkapan layar adalah yang terpendek, dimulai dan diakhiri dalam satu file dan satu metode.  Aliran berikutnya berangkat sudah di kelas Sesi.  Perhatikan Sumber / Tujuan.  Dan yang terakhir adalah metode lain di kelas Sesi.  Aliran di dalam <i>Sesi</i> akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/mv/o7/uu/mvo7uuu6wp_dq-ggltm8lb5m5p0.png"><br><br>  Untuk memilih satu aliran, metode <i>ReduceFlow (CxList.ReduceFlowType flowType) digunakan</i> , di mana flowType dapat: <br><br><ul><li>  <i>CxList.ReduceFlowType.ReduceBigFlow</i> - pilih Flow terpendek </li><li>  <i>CxList.ReduceFlowType.ReduceSmallFlow</i> - pilih Flow terpanjang </li></ul><br><br><h3>  SQLi: Permintaan terakhir untuk menemukan injeksi SQL </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.GetByClass(All.FindByName("*Session*")); // 2.    CxList sanitization = All.FindByName("*Long*"); // 3.    runSuperSecureSQLQuery() CxList runSuperSecureSQLQuery = All.FindByName("*runSuperSecureSQLQuery*").FindByType(typeof(MethodInvokeExpr)); runSuperSecureSQLQuery -= exclusionList; // 4.     runSuperSecureSQLQuery() CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); // 5.   ,     runSuperSecureSQLQuery() CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(typeof(MethodDecl)); CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType("String"); // 6.       (runSuperSecureSQLQuery)     CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization); // 7.   result = dataInflOnTable.ReduceFlow(CxList.ReduceFlowType.ReduceBigFlow);</span></span></code> </pre> <br><br><h2>  Contoh 2: Mencari Referensi Objek Langsung Tidak Aman </h2><br>  Dalam permintaan ini, kami akan mencari semua tempat di mana bekerja dengan objek terjadi tanpa memeriksa pemilik objek.  Dalam kasus ini, nama parameter HTTP yang berbeda untuk kotak surat dapat digunakan (kami menganggap ini Legacy), dan verifikasi itu sendiri dapat terjadi pada tahapan yang berbeda: di suatu tempat tepat di titik API entri HTTP, di suatu tempat sebelum permintaan ke database, dan kadang-kadang dalam metode menengah. <br><br>  Rencana pencarian <br><ol><li>  Tentukan pengecualian ( <i>exclusionList</i> ); </li><li>  Identifikasi tempat untuk pemeriksaan otorisasi ( <i>idorSanitizer</i> ); </li><li>  Temukan titik masuk - tempat untuk pemrosesan utama permintaan HTTP ( <i>webRemoteMethods</i> ); </li><li>  Hanya dengan token titik masuk untuk menemukan lokasi ekstraksi dari parameter HTTP <i>mailboxid</i> ( <i>mailboxidInit</i> ); </li><li>  Temukan semua panggilan dari webRemoteMethods ke metode dan parameter middleware dari panggilan ini ( <i>middlewareMethods</i> ); </li><li>  Temukan metode middleware yang bergantung pada kotak surat ( <i>apiPotentialIDOR</i> ); </li><li>  Temukan semua tempat di mana metode middleware didefinisikan ( <i>middlewareDecl</i> ); </li><li>  Buka semua <i>apiPotentialIDOR</i> dan pilih hanya <i>middlewareDecl</i> yang tidak ada verifikasi pemilik objek <i>mailboxid</i> . </li></ol><br><br><h3>  IDOR: Langkah 1. Identifikasi Pengecualian </h3><br>  Dalam hal ini, kecualikan semua token dalam file tertentu: <br><br><pre> <code class="actionscript hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*WebMethodContext.java"</span></span>); result = exclusionList;</code> </pre> <br>  <i>WebMethodContext.java</i> berisi implementasi metode seperti <i>getMailboxId</i> dan <i>getUserId</i> , serta string "mailboxid".  Karena nama token akan bertepatan dengan yang kita butuhkan untuk mencari kerentanan, file ini akan mengeluarkan temuan palsu. <br><br><h3>  IDOR: Langkah 2. Temukan Cek Otorisasi </h3><br>  Dalam aplikasi pengujian, metode <i>validateMailbox ()</i> digunakan untuk menentukan apakah objek yang diminta milik pengguna: <br><br><pre> <code class="actionscript hljs">CxList idorSanitizer = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*validateMailbox*"</span></span>); result = idorSanitizer;</code> </pre><br>  Hasil: <br><br><img src="https://habrastorage.org/webt/a7/jx/3e/a7jx3eqcxzb5pwgzze9yuqbysos.png"><br><br><h3>  IDOR: Langkah 3. Temukan titik masuk untuk permintaan HTTP API khusus </h3><br>  Penangan permintaan HTTP memiliki anotasi khusus yang membuatnya mudah ditemukan.  Dalam kasus saya, ini adalah "WebRemote"; fungsi <i>CMxQL FindByCustomAttribute ()</i> digunakan untuk mencari anotasi.  Untuk <i>FindByCustomAttribute ()</i> , fungsi pencarian token induk <i>GetAncOfType ()</i> akan mengembalikan metode di bawah anotasi: <br><br><pre> <code class="java hljs">CxList webRemoteMethods = All.FindByCustomAttribute(<span class="hljs-string"><span class="hljs-string">"WebRemote"</span></span>) .GetAncOfType(typeof(MethodDecl)); result = webRemoteMethods;</code> </pre> <br><br>  Hasil permintaan: <br><br><img src="https://habrastorage.org/webt/rc/xt/q_/rcxtq_rfostgwmdtmwrfyg-9ly4.png"><br><br><h3>  IDOR: Langkah 4. Hanya menggunakan token titik masuk, cari lokasi ekstraksi HTTP untuk parameter kotak surat </h3><br>  Untuk menemukan token terkait dengan pemrosesan parameter HTTP mailboxid: <br><br><pre> <code class="java hljs">CxList getMailboxId = All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxId\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxId;</code> </pre> <br>  kami menambahkan 3 set dengan 3 garis yang berbeda, karena  menurut legenda, nama parameter HTTP dapat berbeda di berbagai bagian sistem. <br><br>  Kueri akan menemukan semua tempat di mana <i>mailboxid / mid / boxid</i> ditulis sebagai string (dalam tanda kutip ganda).  Tapi kueri ini akan mengembalikan banyak temuan, tk.  string semacam itu dapat ditemukan tidak hanya di tempat-tempat di mana parameter HTTP diekstraksi.  Jika kami terus bekerja dengan set ini, kami akan mendapatkan sejumlah besar temuan palsu. <br><br>  Karenanya, kami hanya akan mencari token dari titik masuk ( <i>webRemoteMethods</i> ).  Untuk menemukan semua token anak, fungsi <i>CMBQL GetByAncs () digunakan</i> : <br><br><pre> <code class="java hljs">result = All.GetByAncs(webRemoteMethods);</code> </pre> <br>  Permintaan akan mengembalikan semua token milik metode yang dianotasikan sebagai <i>WebRemote</i> .  Sudah pada tahap ini, kita dapat memfilter token metode-metode di mana pemilik objek diperiksa.  Oleh karena itu, kami menulis ulang kueri sebelumnya untuk mencari token anak sehingga kami hanya memilih token anak dari metode <i>WebRemote</i> , di mana tidak ada pemeriksaan keamanan dari pemilik objek.  Untuk melakukan ini, gunakan loop dengan ketentuan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//          CxList entry_point_tokens = All.NewCxList(); //      webRemoteMethods foreach (CxList method in webRemoteMethods) { //        CxList method_tokens = All.GetByAncs(method); // ,       ,    owner if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { //  ,     , ,     } else { //  ,         entry_point_tokens.Add(method_tokens); } }</span></span></code> </pre><br>  Sekarang kita dapat membuat pilihan yang lebih akurat menggunakan parameter <i>kotak surat</i> HTTP: <br><br><pre> <code class="java hljs">CxList getMailboxHTTPParams = entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxHTTPParams;</code> </pre> <br>  Tetapi kami tidak tertarik pada tempat-tempat di mana parameter HTTP diambil, tetapi pada variabel yang pada akhirnya diberi nilai parameter HTTP.  Karena lebih dapat diandalkan untuk mencari Flow secara tepat dengan token variabel. <br><br>  Fungsi <i>CMxQL FindByInitialization ()</i> akan menemukan tempat inisialisasi variabel untuk token yang diberikan: <br><br><pre> <code class="java hljs">CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); result = mailboxidInit;</code> </pre> <br>  Hasil: <br><br><img src="https://habrastorage.org/webt/cp/e7/5q/cpe75qru5pcwzikvaona3h7w67c.png"><br><br><h3>  IDOR: Langkah 5. Temukan semua panggilan dari webRemoteMethods ke metode middleware dan parameter panggilan ini </h3><br>  Dengan middleware, maksud saya kode yang lebih dalam dari metode pemrosesan permintaan HTTP API, yaitu, lebih dalam dari titik masuk permintaan pengguna.  Misalnya, untuk tangkapan layar di atas, ini adalah metode kelas <i>Pengguna</i> , panggilan ke <i>user.getSettings ()</i> dan <i>user.getSecureSettings ()</i> : <br><br><pre> <code class="java hljs">CxList middlewareMethods = All.FindByShortName(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); result = middlewareMethodsParams;</code> </pre> <br>  Pertama, kami memilih semua token dengan nama pengguna, dan kemudian menggunakan <i>GetRightmostMember () kami</i> memilih token panggilan untuk middleware.  <i>GetRightmostMember ()</i> dalam rantai panggilan metode akan mengembalikan yang paling kanan.  Kemudian kami menurunkan parameter metode yang ditemukan menggunakan <i>GetParameters ()</i> . <br><br>  Hasil: <br><br><img src="https://habrastorage.org/webt/8b/mm/2a/8bmm2ad7zg-xwponufdxuocn-t0.png"><br><br><h3>  IDOR: Langkah 6. Temukan metode middleware yang bergantung pada kotak surat </h3><br>  Analisis aliran menggunakan <i>metode</i> <i>* InfluencedBy *</i> dan <i>* InfluncingOn *</i> .  Perbedaan di antara mereka jelas berdasarkan nama. <br><br>  Sebagai contoh: <br><br><pre> <code class="java hljs">All.InfluencedBy(getMailboxHTTPParams)</code> </pre> <br>  akan melewati set All dan menemukan semua token yang bergantung pada <i>getMailboxHTTPParams</i> . <br><br>  Hal yang sama dapat ditulis dengan cara lain: <br><br><pre> <code class="java hljs">getMailboxHTTPParams.InfluencingOn(All)</code> </pre> <br><br>  Untuk mencari token yang bergantung pada <i>mailboxidInit</i> : <br><br><pre> <code class="java hljs">CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); result = apiPotentialIDOR;</code> </pre><br>  Hasil: <br><br><img src="https://habrastorage.org/webt/xl/wa/rq/xlwarqf4bvr96xchztinpiua7h4.png"><br><br><h3>  IDOR: Langkah 7. Temukan semua tempat untuk mendefinisikan metode middleware </h3><br>  Mari kita temukan definisi dari semua metode perantara yang dapat digunakan di tempat-tempat di mana permintaan pengguna diproses.  Untuk melakukan ini, kami menyoroti properti umum mereka, misalnya, dalam semua metode seperti ada penciptaan objek <i>Request ()</i> , penciptaan objek adalah tipe <i>CMx ObjectCreateExpr</i> : <br><br><pre> <code class="java hljs">CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName(<span class="hljs-string"><span class="hljs-string">"*Request*"</span></span>); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); result = middlewareDecl;</code> </pre> <br><br>  <i>(Semua - exclusionList)</i> - Anda dapat melakukan pengurangan set ini, dan kemudian memanggil fungsi CMxQL yang diinginkan dari hasilnya.  <i>Permintaan</i> sekarang berisi semua token dengan nama <i>Permintaan</i> dan jenis yang sesuai dengan pembuatan objek. <br><br>  Selanjutnya, menggunakan <i>GetAncOfType () yang</i> kita kenal <i>,</i> kita menemukan token induk dari tipe <i>MethodDecl</i> . <br><br>  Hasil: <br><br><img src="https://habrastorage.org/webt/pp/ie/21/ppie21nmruhnqfekmune0fa5ytu.png"><br><br><h3>  IDOR: Langkah 8. Telusuri semua apiPotentialIDOR dan pilih hanya middlewareDecl yang tidak ada verifikasi pemilik objek mailboxid </h3><br>  Di bagian akhir dari permintaan, kami akan menentukan metode middleware mana yang dipanggil langsung dari metode titik masuk dan tidak memeriksa siapa pemilik kotak <i>surat</i> .  Kemudian gabungkan Flow untuk analisis hasil yang lebih nyaman. <br><br>  Fitur baru yang belum kami gunakan: <br>  <i>GetCxListByPath ()</i> - fungsi ini diperlukan untuk beralih lebih dari Aliran, jika TIDAK digunakan, maka CMx akan memampatkan Aliran dalam Elemen Kode (pada simpul aliran pertama) <br>  <i>Concatenate * ()</i> - sejumlah fungsi yang diperlukan untuk menggabungkan beberapa aliran menjadi satu <br>  <i>FindByParameters ()</i> - temukan metode dengan token parameter tertentu <br>  <i>GetName ()</i> - akan mengembalikan string dengan nama token, jika ada lebih dari satu elemen di CxList, maka itu akan mengembalikan yang pertama.  Metode ini hanya digunakan ketika iterasi elemen-elemen dari set. <br><br>  Bagian terakhir dari permintaan: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    CxList vulns = All.NewCxList(); //   Flow  apiPotentialIDOR foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { //    Flow CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); //       flow (mailboxid) CxList method_call = entry_point_tokens.FindByParameters(endNode); //     CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); //     if (method_decl.Count &gt; 0) { //       CxList _all = (All - exclusionList).GetByAncs(method_decl); //       if (_all.FindByName(idorSanitizer).Count &gt; 0) { //  ,       cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); //  ,   Flow     vulns } else { //     Flow       vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } }</span></span></code> </pre> <br><br>  Hasil: <br><br><img src="https://habrastorage.org/webt/_z/qs/rj/_zqsrju8bqoni7u0ksolmokizhe.png"><br><br> <i>CocatenatePath</i>  ,          .     Code Element  Flow <br><br><h3> IDOR:     IDOR </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.FindByFileName("*WebMethodContext.java"); // 2.     CxList idorSanitizer = All.FindByName("*validateMailbox*"); // 3.    –    HTTP  CxList webRemoteMethods = All.FindByCustomAttribute("WebRemote").GetAncOfType(typeof(MethodDecl)); // 4.         HTTP  mailboxid //     CxList entry_point_tokens = All.NewCxList(); foreach (CxList method in webRemoteMethods) { CxList method_tokens = All.GetByAncs(method); if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { } else { entry_point_tokens.Add(method_tokens); } } //    HTTP    -  CxList getMailboxHTTPParams = entry_point_tokens.FindByName("\"mailboxId\"") + entry_point_tokens.FindByName("\"mid\"") + entry_point_tokens.FindByName("\"boxid\""); CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); // 5.      middleware     CxList middlewareMethods = All.FindByShortName("user").GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); // 6.  middleware ,     mailboxid CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); // 7.      middleware      CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName("*Request*"); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); // 8.    apiPotentialIDOR     middlewareDecl,      CxList vulns = All.NewCxList(); foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); CxList method_call = entry_point_tokens.FindByParameters(endNode); CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); if (method_decl.Count &gt; 0) { CxList _all = (All - exclusionList).GetByAncs(method_decl); if (_all.FindByName(idorSanitizer).Count &gt; 0) { cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); } else { vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } } result = vulns;</span></span></code> </pre><br><br><h2>  Kesimpulan </h2><br> Checkmarx      ,     .        ,      ,   ,     ..      Flow (    ).           ,         ,    «» . <br><br>     false positive,     : <br><ul><li>     ,       (   ). </li><li>     ,    (  ). ,     «Privacy Violation»,   ,         ,    Web UI.    , ..       UI    .       TLS        XSS     . </li><li>  -    ,           (,   ). ,   XXE  ,   , -    ,   . </li><li>   false positive,   ,           CMxQL   FindBy/GetBy.         ,     (        SQL). </li><li>   false positives,    ,      ,   ,       ,   CMx,      . ,       LDAP ,      .       c LDAP-   ,   ,      . </li></ul><br><br>   how-to     «hello world»  ,        Checkmarx. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477742/">https://habr.com/ru/post/id477742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477732/index.html">Klasifikasi jari yang salah dari sistem navigasi bawah air</a></li>
<li><a href="../id477734/index.html">Memahami UICollectionViewLayout dengan Aplikasi Foto</a></li>
<li><a href="../id477736/index.html">Jalur penguji: dari "rem tangan" ke otomatisasi</a></li>
<li><a href="../id477738/index.html">iKassa atau bagaimana kami menjinakkan "kasir digital"</a></li>
<li><a href="../id477740/index.html">Dan ke mana harus melihat teleskop ini dengan mata Anda?</a></li>
<li><a href="../id477744/index.html">Mengapa profesional terkadang membuat aplikasi yang buruk?</a></li>
<li><a href="../id477746/index.html">Desainer Monetisasi: siapa dia dan bagaimana menjadi satu</a></li>
<li><a href="../id477752/index.html">Backend United # 5: Shawarma - Layanan Mikro, Sistem Terdistribusi dan Kafka</a></li>
<li><a href="../id477754/index.html">Bandingkan micro: bit dengan Arduino. Dan bagaimana cara mendapatkan micro: bit gratis jika Anda bukan pelajar bahasa Inggris?</a></li>
<li><a href="../id477756/index.html">Bagaimana kami menikahi dua sistem CRM perbankan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>