<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèæ ü•ö ‚ôäÔ∏è Apple Metal bei MAPS.ME üèì üéí üöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 In der Welt gibt es eine gro√üe Anzahl von Anwendungen auf OpenGL, und es scheint, dass Apple dem nicht ganz zustimmt. Ab iOS 12 u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apple Metal bei MAPS.ME</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/430850/"><img src="https://habrastorage.org/webt/jf/bk/ix/jfbkixzquc9k0dnnqnaorskj4bk.png" alt="Bild" align="left">  Hallo allerseits! <br><br>  In der Welt gibt es eine gro√üe Anzahl von Anwendungen auf OpenGL, und es scheint, dass Apple dem nicht ganz zustimmt.  Ab iOS 12 und MacOS Mojave ist OpenGL veraltet.  Wir haben Apple Metal in MAPS.ME integriert und sind bereit, unsere Erfahrungen und Ergebnisse zu teilen.  Wir werden Ihnen sagen, wie unsere Grafik-Engine √ºberarbeitet wurde, mit welchen Schwierigkeiten wir konfrontiert waren und vor allem, wie viele FPS wir jetzt haben. <br><br>  Jeder, der interessiert ist oder erw√§gt, der Grafik-Engine Apple Metal-Unterst√ºtzung hinzuzuf√ºgen, ist bei cat willkommen. <br><a name="habracut"></a><br><h2>  Problem </h2><br>  Unsere Grafik-Engine wurde plattform√ºbergreifend konzipiert. Da OpenGL tats√§chlich die einzige plattform√ºbergreifende Grafik-API f√ºr die f√ºr uns interessanten Plattformen (iOS, Android, MacOS und Linux) ist, haben wir sie als Basis ausgew√§hlt.  Wir haben keine zus√§tzliche Abstraktionsebene erstellt, die die f√ºr OpenGL spezifischen Funktionen verbirgt, aber gl√ºcklicherweise das Potenzial f√ºr deren Implementierung gelassen. <br><br>  Mit dem Aufkommen der neuen Generation von Grafik-APIs Apple Metal und Vulkan haben wir nat√ºrlich die M√∂glichkeit ihres Auftretens in unserer Anwendung in Betracht gezogen. Wir wurden jedoch durch Folgendes gestoppt: <br><br><ol><li>  Vulkan konnte nur unter Android und Linux funktionieren, und Apple Metal konnte nur unter iOS und MacOS funktionieren.  Wir wollten nicht die plattform√ºbergreifende Funktionalit√§t auf der Ebene der Grafik-API verlieren. Dies w√ºrde die Entwicklungs- und Debugging-Prozesse erschweren und den Arbeitsaufwand erh√∂hen. </li><li>  Eine Anwendung auf Apple Metal kann (√ºbrigens bis jetzt) ‚Äã‚Äãnicht auf einem iOS-Simulator erstellt und ausgef√ºhrt werden, was auch unsere Entwicklung erschweren und es uns nicht erm√∂glichen w√ºrde, OpenGL vollst√§ndig loszuwerden. </li><li>  Das Qt-Framework, mit dem wir interne Tools erstellen, unterst√ºtzt nur OpenGL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vulkan wird jetzt unterst√ºtzt</a> ). </li><li>  Apple Metal hatte und hat keine C ++ - API, was uns zwingen w√ºrde, Abstraktionen nicht nur f√ºr die Laufzeit, sondern auch f√ºr die Erstellungsphase der Anwendung zu erstellen, wenn ein Teil der Engine in Objective-C ++ kompiliert wird und der andere, wesentlich gr√∂√üere, in C ++. </li><li>  Wir waren nicht bereit, eine separate Engine oder einen separaten Code-Zweig speziell f√ºr iOS zu erstellen. </li><li>  Die Implementierung wurde in der Arbeit eines Grafikentwicklers mindestens sechs Monate lang evaluiert. </li></ol><br>  Als Apple im Fr√ºhjahr 2018 die √úbertragung von OpenGL in den veralteten Status ank√ºndigte, wurde klar, dass eine Verschiebung nicht mehr m√∂glich war und die oben genannten Probleme auf die eine oder andere Weise gel√∂st werden mussten.  Dar√ºber hinaus haben wir lange daran gearbeitet, sowohl die Anwendungsgeschwindigkeit als auch den Stromverbrauch zu optimieren, und Apple Metal schien in der Lage zu sein, zu helfen. <br><br><h2>  Entscheidungsauswahl </h2><br>  Fast sofort bemerkten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MoltenVK</a> .  Dieses Framework emuliert die Vulkan-API mithilfe von Apple Metal und der Quellcode wurde k√ºrzlich ge√∂ffnet.  Die Verwendung von MoltenVK w√ºrde es anscheinend erm√∂glichen, OpenGL durch Vulkan zu ersetzen und sich √ºberhaupt nicht mit einer separaten Apple Metal-Integration zu befassen.  Dar√ºber hinaus haben Qt-Entwickler die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separate Unterst√ºtzung f√ºr das Rendern auf Apple Metal</a> zugunsten von MoltenVK abgelehnt.  Wir wurden jedoch gestoppt: <br><br><ul><li>  die Notwendigkeit, Android-Ger√§te zu unterst√ºtzen, auf denen Vulkan nicht verf√ºgbar ist; </li><li>  die Unf√§higkeit, auf dem iOS-Simulator ohne Fallback auf OpenGL zu starten; </li><li>  die Unf√§higkeit, Apple-Tools zum Debuggen, Profilieren und Vorkompilieren von Shadern zu verwenden, da MoltenVK Echtzeit-Shader f√ºr Apple Metal aus SPIR-V- oder GLSL-Quellcodes generiert; </li><li>  die Notwendigkeit, auf Updates und Fehlerbehebungen von MoltenVK zu warten, wenn neue Versionen von Metal ver√∂ffentlicht werden; </li><li>  die Unm√∂glichkeit einer subtilen Optimierung, die spezifisch f√ºr Metall ist, aber nicht spezifisch oder nicht existent f√ºr Vulkan. </li></ul><br>  Es stellte sich heraus, dass wir OpenGL speichern m√ºssen, was bedeutet, dass wir nicht darauf verzichten k√∂nnen, die Engine von der grafischen API zu abstrahieren.  Apple Metal, OpenGL ES und in Zukunft Vulkan werden verwendet, um unabh√§ngige interne Komponenten der Grafik-Engine zu erstellen, die vollst√§ndig austauschbar sind.  OpenGL spielt die Rolle der Fallback-Option, wenn Metal oder Vulkan aus dem einen oder anderen Grund nicht verf√ºgbar sind. <br><br>  Der Umsetzungsplan lautete wie folgt: <br><br><ol><li>  Refactoring der Grafik-Engine zur Zusammenfassung der verwendeten Grafik-API. </li><li>  Rendern Sie f√ºr die iOS-Version der App auf Apple Metal. </li><li>  Erstellen Sie geeignete Benchmarks f√ºr die Rendergeschwindigkeit und den Stromverbrauch, um festzustellen, ob moderne Grafik-APIs auf niedrigerer Ebene dem Produkt zugute kommen k√∂nnen. </li></ol><br><h2>  Hauptunterschiede zwischen OpenGL und Metal </h2><br>  Um zu verstehen, wie die grafische API abstrahiert wird, m√ºssen wir zun√§chst die wichtigsten konzeptionellen Unterschiede zwischen OpenGL und Metal ermitteln. <br><br><ol><li>  Es wird angenommen, und nicht ohne Grund, dass Metal eine untergeordnete API ist.  Dies bedeutet jedoch nicht, dass Sie in Assembler schreiben oder die Rasterisierung selbst implementieren m√ºssen.  Metal kann als Low-Level-API bezeichnet werden, da es eine sehr kleine Anzahl impliziter Aktionen ausf√ºhrt, dh fast alle Aktionen m√ºssen selbst in den Programmierer geschrieben werden.  OpenGL f√ºhrt viele Dinge implizit aus, angefangen bei der Unterst√ºtzung eines impliziten Verweises auf einen OpenGL-Kontext bis hin zur Verkn√ºpfung dieses Kontexts mit dem Stream, in dem er erstellt wurde. </li><li>  In Metal "keine" Echtzeitvalidierung von Teams.  Im Debug-Modus gibt es nat√ºrlich eine Validierung, die viel besser ist als in vielen anderen APIs, was haupts√§chlich auf die enge Integration mit Xcode zur√ºckzuf√ºhren ist.  Wenn das Programm jedoch an den Benutzer gesendet wird, erfolgt keine Validierung mehr. Das Programm st√ºrzt einfach beim ersten Fehler ab.  Nat√ºrlich st√ºrzt OpenGL nur in den extremsten F√§llen ab.  Die h√§ufigste Vorgehensweise: Den Fehler ignorieren und weiterarbeiten. </li><li>  Metal kann Shader vorkompilieren und daraus Bibliotheken erstellen.  In OpenGL werden Shader im Verlauf des Programms aus dem Quellcode kompiliert, da dies f√ºr die spezifische Implementierung von OpenGL auf niedriger Ebene auf einem bestimmten Ger√§t verantwortlich ist.  Unterschiede und / oder Fehler bei der Implementierung von Shader-Compilern f√ºhren manchmal zu fantastischen Fehlern, insbesondere auf Android-Ger√§ten chinesischer Marken. </li><li>  OpenGL nutzt aktiv die Zustandsmaschine, die fast jeder Funktion Nebenwirkungen hinzuf√ºgt.  Daher sind OpenGL-Funktionen keine reinen Funktionen, und die Reihenfolge und der Anrufverlauf sind h√§ufig wichtig.  Metall verwendet Zust√§nde nicht implizit und bewahrt sie nicht l√§nger auf, als f√ºr das Rendern erforderlich ist.  Zust√§nde existieren als vorgefertigte und fehlgeschlagene Objekte. </li></ol><br><h2>  Graphic Engine Refactoring und Einbettung von Metall </h2><br>  Der Prozess der √úberarbeitung der Grafik-Engine bestand im Wesentlichen darin, die beste L√∂sung zu finden, um die OpenGL-Funktionen zu entfernen, die unsere Engine aktiv verwendet hat.  Das Einbetten von Metall, beginnend von einer der Stufen, verlief parallel. <br><br><ul><li>  Wie bereits erw√§hnt, verf√ºgt die OpenGL-API √ºber eine implizite Entit√§t, die als Kontext bezeichnet wird.  Der Kontext ist einem bestimmten Thread zugeordnet, und die in diesem Thread aufgerufene OpenGL-Funktion findet und verwendet diesen Kontext.  Metal, Vulkan (ja, und andere APIs, zum Beispiel Direct3D) funktionieren nicht auf diese Weise, sie haben √§hnliche explizite Objekte, die als Ger√§t oder Instanz bezeichnet werden.  Der Benutzer selbst erstellt diese Objekte und ist f√ºr deren √úbertragung auf verschiedene Subsysteme verantwortlich.  √úber diese Objekte werden alle Aufrufe von Grafikbefehlen ausgef√ºhrt. <br><br>  Wir haben unser abstraktes Objekt als grafischen Kontext bezeichnet. Im Fall von OpenGL werden die Aufrufe von OpenGL-Befehlen einfach dekoriert, und im Fall von Metal enth√§lt es die MTLDevice-Root-Schnittstelle, √ºber die die Metal-Befehle aufgerufen werden. <br><br>  Nat√ºrlich musste ich dieses Objekt (und da wir Multithread-Rendering haben, dann sogar mehrere solcher Objekte) auf alle Subsysteme verteilen. <br><br>  Wir haben die Erstellung von Warteschlangen f√ºr Befehle, Encoder und deren Verwaltung im grafischen Kontext versteckt, um keine Entit√§ten zu verbreiten, die in OpenGL einfach nicht vorhanden sind. </li><li>  Die Aussicht auf das Verschwinden der Validierung von Grafikbefehlen auf Benutzerger√§ten hat uns nicht offen gefallen.  Eine breite Palette von Ger√§ten und Betriebssystemversionen konnte von unserer QS-Abteilung nicht vollst√§ndig abgedeckt werden.  Daher mussten wir detaillierte Protokolle hinzuf√ºgen, bei denen wir zuvor einen aussagekr√§ftigen Fehler von der grafischen API erhalten hatten.  Nat√ºrlich wurde diese Validierung nur an potenziell gef√§hrlichen und kritischen Stellen der Grafik-Engine hinzugef√ºgt, da das Abdecken der gesamten Engine mit einem Diagnosecode praktisch unm√∂glich und im Allgemeinen leistungssch√§dlich ist.  Die neue Realit√§t ist, dass Benutzertests und das Debuggen von Protokollen zumindest in Bezug auf das Rendern der Vergangenheit angeh√∂ren. </li><li>  Unser bisheriges Shader-System war f√ºr das Refactoring ungeeignet, ich musste es komplett neu schreiben.  Hier geht es nicht nur um die Vorkompilierung von Shadern und deren Validierung in der Phase der Projektmontage.  OpenGL verwendet die sogenannten einheitlichen Variablen, um Parameter an Shader zu √ºbergeben.  Die strukturierte Daten√ºbertragung ist nur mit OpenGL ES 3.0 verf√ºgbar. Da wir OpenGL ES 2.0 weiterhin unterst√ºtzen, haben wir diese Methode einfach nicht verwendet.  Metal brachte uns dazu, Datenstrukturen zu verwenden, um Parameter zu √ºbergeben, und f√ºr OpenGL mussten wir Strukturfelder auf einheitliche Variablen abbilden.  Au√üerdem musste ich jeden der Shader in der Metal Shading Language neu schreiben. </li><li>  Bei der Verwendung von Zustandsobjekten mussten wir einen Trick machen.  In OpenGL werden in der Regel alle Zust√§nde unmittelbar vor dem Rendern festgelegt, und in Metal sollte dies ein zuvor erstelltes und validiertes Objekt sein.  Unsere Engine verwendete offensichtlich den OpenGL-Ansatz, und das Refactoring mit der vorl√§ufigen Erstellung von Statusobjekten war vergleichbar mit einem vollst√§ndigen Umschreiben der Engine.  Um diesen Knoten zu schneiden, haben wir einen Statuscache im grafischen Kontext erstellt.  Wenn zum ersten Mal eine eindeutige Kombination von Statusparametern generiert wird, wird ein Statusobjekt in Metal erstellt und im Cache abgelegt.  Zum zweiten und nachfolgenden Mal wird das Objekt einfach aus dem Cache abgerufen.  Dies funktioniert in unseren Karten, da die Anzahl der verschiedenen Kombinationen von Zustandsparametern nicht zu gro√ü ist (ca. 20-30).  F√ºr eine komplexe Spielgrafik-Engine ist diese Methode kaum geeignet. </li></ul><br>  Infolgedessen konnten wir nach etwa 5 Monaten Arbeit MAPS.ME zum ersten Mal mit vollst√§ndigem Rendering auf Apple Metal starten.  Es war Zeit herauszufinden, was passiert war. <br><br><h2>  Testen der Rendergeschwindigkeit </h2><br><h4>  Experimentelle Technik </h4><br>  Wir haben im Experiment verschiedene Generationen von Apple-Ger√§ten verwendet.  Alle von ihnen wurden auf iOS 12 aktualisiert. Das gleiche Benutzerskript wurde f√ºr die All-Map-Navigation (Verschieben und Skalieren) ausgef√ºhrt.  Das Skript wurde so geschrieben, dass bei jedem Start auf jedem Ger√§t eine nahezu vollst√§ndige Identit√§t der Prozesse in der Anwendung gew√§hrleistet ist.  Als Teststandort haben wir das Gebiet von Los Angeles ausgew√§hlt - eines der am st√§rksten belasteten Gebiete in MAPS.ME. <br><br>  Zuerst wurde das Skript mit Rendering unter OpenGL ES 3.0 ausgef√ºhrt, dann auf demselben Ger√§t mit Rendering unter Apple Metal.  Zwischen den Starts wurde die Anwendung vollst√§ndig aus dem Speicher entladen. <br>  Folgende Indikatoren wurden gemessen: <br><br><ul><li>  FPS (Bilder pro Sekunde) f√ºr das gesamte Bild; </li><li>  FPS f√ºr den Teil des Frames, der nur mit dem Rendern besch√§ftigt ist, ausgenommen Datenaufbereitung und andere Frame-f√ºr-Frame-Operationen; </li><li>  Der Prozentsatz langsamer Bilder (gr√∂√üer als ~ 30 ms), d.h.  diejenigen, die das menschliche Auge als Idioten wahrnehmen kann. </li></ul><br>  Bei der Messung von FPS wurde das Zeichnen direkt auf dem Bildschirm des Ger√§ts ausgeschlossen, da die vertikale Synchronisation mit der Bildwiederholfrequenz des Bildschirms keine zuverl√§ssigen Ergebnisse erm√∂glicht.  Daher wurde der Rahmen in die Textur im Speicher gezeichnet.  Um die CPU und die GPU zu synchronisieren, verwendete OpenGL einen zus√§tzlichen Aufruf von <code>glFinish</code> , w√§hrend Apple Metal <code>waitUntilCompleted</code> f√ºr <code>MTLFrameCommandBuffer</code> . <br><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100"></th><th width="100">  iPhone 7+ </th><th width="100"></th><th width="100">  iPhone 8 </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  Metall </th><th>  Opengl </th><th>  Metall </th><th>  Opengl </th><th>  Metall </th></tr><tr><td>  Fps </td><td>  106 </td><td>  160 </td><td>  159 </td><td>  221 </td><td>  196 </td><td>  298 </td></tr><tr><td>  FPS (nur Rendern) </td><td>  157 </td><td>  596 </td><td>  247 </td><td>  597 </td><td>  271 </td><td>  833 </td></tr><tr><td>  Bruchteil langsamer Bilder (&lt;30 fps) </td><td>  4,13% </td><td>  1,25% </td><td>  5,45% </td><td>  0,76% </td><td>  1,5% </td><td>  0,29% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone X. </th><th width="100"></th><th width="100">  iPad Pro 12.9 ' </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  Metall </th><th>  Opengl </th><th>  Metall </th></tr><tr><td>  Fps </td><td>  145 </td><td>  210 </td><td>  104 </td><td>  137 </td></tr><tr><td>  FPS (nur Rendern) </td><td>  248 </td><td>  705 </td><td>  147 </td><td>  463 </td></tr><tr><td>  Bruchteil langsamer Bilder (&lt;30 fps) </td><td>  0,15% </td><td>  0,15% </td><td>  17,52% </td><td>  4,46% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100">  iPhone 7+ </th><th width="100">  iPhone 8 </th><th width="100">  iPhone X. </th><th width="100">  iPad Pro 12.9 ' </th></tr><tr><td>  Beschleunigung des Rahmens auf Metall (N-mal) </td><td>  1,5 </td><td>  1,39 </td><td>  1,52 </td><td>  1.45 </td><td>  1.32 </td></tr><tr><td>  Beschleunigung des Renderns auf Metall (N-mal) </td><td>  3,78 </td><td>  2.41 </td><td>  3,07 </td><td>  2.84 </td><td>  3.15 </td></tr><tr><td>  Verbesserung in langsamen Frames (N-mal) </td><td>  3.3 </td><td>  7.17 </td><td>  5.17 </td><td>  1 </td><td>  3.93 </td></tr></tbody></table><br><h4>  Ergebnisanalyse </h4><br>  Im Durchschnitt betrug der Frame-Performance-Gewinn mit Apple Metal 43%.  Der Mindestwert ist auf dem iPad Pro 12,9 'festgelegt - 32%, der H√∂chstwert - 52% auf dem iPhone 8. Es besteht eine Abh√§ngigkeit: Je niedriger die Bildschirmaufl√∂sung, desto mehr √ºbertrifft Apple Metal OpenGL ES 3.0. <br><br>  Wenn wir den Teil des Frames bewerten, der direkt f√ºr das Rendern verantwortlich ist, hat sich die durchschnittliche Rendergeschwindigkeit auf Apple Metal dreimal erh√∂ht.  Dies weist auf eine deutlich bessere Organisation und damit auf die Effizienz der Apple Metal API im Vergleich zu OpenGL ES 3.0 hin. <br><br>  Die Anzahl der langsamen Frames (mehr als ~ 30 ms) auf Apple Metal wurde um das Vierfache reduziert.  Dies bedeutet, dass die Wahrnehmung von Animationen und das Bewegen auf der Karte reibungsloser geworden ist.  Das schlechteste Ergebnis wurde auf dem iPad Pro 12.9 'mit einer Aufl√∂sung von 2732 x 2048 Pixel aufgezeichnet: OpenGL ES 3.0 liefert etwa 17,5% langsame Bilder, w√§hrend Apple Metal nur 4,5% liefert. <br><br><h2>  Leistungspr√ºfung </h2><br><h4>  Experimentelle Technik </h4><br>  Der Stromverbrauch wurde auf dem iPhone 8 unter iOS 12 getestet. Das gleiche Benutzerszenario wurde ausgef√ºhrt - Kartennavigation (Verschieben und Skalieren) f√ºr 1 Stunde.  Das Skript wurde so geschrieben, dass bei jedem Start eine nahezu vollst√§ndige Identit√§t der Prozesse innerhalb der Anwendung gew√§hrleistet ist.  Das Gebiet von Los Angeles wurde ebenfalls als Teststandort ausgew√§hlt. <br><br>  Wir haben den folgenden Ansatz zur Messung des Energieverbrauchs verwendet.  Das Ger√§t ist nicht an das Laden angeschlossen.  In den Einstellungen des Entwicklers ist die Energieprotokollierung aktiviert.  Vor Beginn des Experiments ist das Ger√§t vollst√§ndig aufgeladen.  Das Experiment endet am Ende des Skripts.  Am Ende des Experiments wurde der Zustand der Batterieladung aufgezeichnet und die Stromverbrauchsprotokolle wurden in das Dienstprogramm zum Profilieren der Batterie in Xcode importiert.  Wir haben aufgezeichnet, wie viel der Ladung f√ºr die GPU ausgegeben wurde.  Zus√§tzlich haben wir hier das Rendering zus√§tzlich gewichtet, indem wir die Anzeige des U-Bahn-Schemas und das Vollbild-Antialiasing einbezogen haben. <br><br>  Die Bildschirmhelligkeit √§nderte sich nicht in allen F√§llen.  Es wurden keine anderen Prozesse au√üer system und MAPS.ME ausgef√ºhrt.  Der Flugzeugmodus wurde eingeschaltet, Wi-Fi und GPS wurden ausgeschaltet.  Zus√§tzlich wurden mehrere Kontrollmessungen durchgef√ºhrt. <br><br>  Als Ergebnis wurde f√ºr jeden der Indikatoren ein Vergleich von Metall mit OpenGL gebildet, und dann wurden die Verh√§ltnisse gemittelt, um eine aggregierte Sch√§tzung zu erhalten. <br><br><table><tbody><tr><th width="100"></th><th width="100">  Opengl </th><th width="100">  Metall </th><th width="100">  Gewinn </th></tr><tr><td>  Batterie entladen </td><td>  32% </td><td>  28% </td><td>  12,5% </td></tr><tr><td>  Profilierung der Batterieverwendung in Xcode </td><td>  1,95% </td><td>  1,83% </td><td>  6,16% </td></tr></tbody></table><br><h4>  Ergebnisanalyse </h4><br>  Im Durchschnitt hat sich der Stromverbrauch der Rendering-Version auf Apple Metal leicht verbessert.  Der Stromverbrauch unserer GPU-Anwendung ist mit 2% nicht sehr stark betroffen, da MAPS.ME im Hinblick auf die Verwendung der GPU nicht als hoch belastet bezeichnet werden kann.  Ein kleiner Gewinn wird wahrscheinlich durch die Reduzierung der Rechenkosten bei der Erstellung von Anweisungen f√ºr die GPU auf der CPU erzielt, die mit Hilfe von Profiling-Tools leider nicht unterschieden werden k√∂nnen. <br><br><h2>  Zusammenfassung </h2><br>  Das Einbetten von Metall hat uns 5 Monate Entwicklungszeit gekostet.  Zwei Entwickler haben dies jedoch fast immer nacheinander getan.  Offensichtlich haben wir beim Rendern deutlich gewonnen, beim Energieverbrauch ein wenig.  Dar√ºber hinaus hatten wir die M√∂glichkeit, neue Grafik-APIs, insbesondere Vulkan, mit viel weniger Aufwand einzubetten.  Die Grafik-Engine wurde fast vollst√§ndig ‚Äûaussortiert‚Äú. Infolgedessen haben wir einige alte Fehler und Leistungsprobleme gefunden und behoben. <br><br>  Auf die Frage, ob unser Projekt wirklich auf Apple Metal gerendert werden muss, sind wir bereit, dies zu bejahen.  Es ist nicht so sehr, dass wir Innovation lieben oder dass Apple OpenGL endg√ºltig aufgeben kann.  Es ist erst 2018 und OpenGL erschien im fernen 1997, es ist h√∂chste Zeit, den n√§chsten Schritt zu tun. <br><br>  <b>PS</b> Bis wir die Funktion auf allen iOS-Ger√§ten gestartet haben.  Um es manuell zu aktivieren, geben Sie <code>?metal</code> in die Suchleiste ein und starten Sie die Anwendung neu.  <code>?gl</code> Befehl <code>?gl</code> und starten Sie die Anwendung neu, um das Rendering an OpenGL zur√ºckzugeben. <br><br>  <b>PPS</b> MAPS.ME ist ein Open-Source-Projekt.  Sie k√∂nnen den Quellcode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github lesen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430850/">https://habr.com/ru/post/de430850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430838/index.html">Die Wunder des Crowd-Marketings oder wie man ein Unternehmen mit Bewertungen f√∂rdert</a></li>
<li><a href="../de430840/index.html">Welche Beweise k√∂nnen Mathematiker √ºberzeugen, wenn es keine strengen Beweise gibt?</a></li>
<li><a href="../de430842/index.html">Wir verwenden Blockchain, um Korruption und Cybermobbing zu bek√§mpfen</a></li>
<li><a href="../de430844/index.html">So w√§hlen Sie eine Batterie f√ºr die USV</a></li>
<li><a href="../de430846/index.html">Was ist neu: Details zur Implementierung der neuen Zen 2-Architektur wurden bekannt</a></li>
<li><a href="../de430852/index.html">Konsistenz- und ACID-Garantien in verteilten Speichersystemen</a></li>
<li><a href="../de430854/index.html">‚ÄûJS wird reifer‚Äú: ein Interview mit dem Moskauer Programmkomitee HolyJS 2018</a></li>
<li><a href="../de430856/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 21. Postf√§cher: Einf√ºhrung und Basisdienste</a></li>
<li><a href="../de430860/index.html">Laden Sie PDF in Swift herunter, speichern Sie es und zeigen Sie es an</a></li>
<li><a href="../de430862/index.html">"Monster in Spielen - wie man einen Spieler dazu bringt, dich zu hassen"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>