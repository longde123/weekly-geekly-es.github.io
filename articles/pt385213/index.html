<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏾 🕺🏽 👱 Evitando o desgaste da EEPROM 🤴🏿 🥉 📤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resumo: Se você atualizar periodicamente um valor na EEPROM a cada poucos minutos (ou vários segundos), poderá encontrar o problema do desgaste das cé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evitando o desgaste da EEPROM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/385213/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumo: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você atualizar periodicamente um valor na EEPROM a cada poucos minutos (ou vários segundos), poderá encontrar o problema do desgaste das células da EEPROM. </font><font style="vertical-align: inherit;">Para evitar isso, você precisa reduzir a frequência de entradas na célula. </font><font style="vertical-align: inherit;">Para alguns tipos de EEPROM, até velocidades de gravação mais de uma vez por hora podem ser um problema.</font></font></i><br>
<br>
<a name="habracut"></a><br>
<br>
<h2><font color="#cc0000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando você grava dados, o tempo passa rápido</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A EEPROM é universalmente usada para salvar configurações e logs de operação em sistemas embarcados. Por exemplo, você pode querer que o recurso de caixa preta registre os dados mais recentes no momento de um acidente ou perda de energia. Vi especificações exigindo a gravação desses dados a cada poucos segundos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas o problema é que a EEPROM possui um recurso de número de registro limitado. Após 100.000 ou um milhão de registros (dependendo do chip específico), alguns de seus sistemas começarão a ter problemas com a falha da EEPROM. (Procure um número específico na folha de dados. Se você deseja liberar um grande número de dispositivos, o "pior caso" provavelmente é mais importante que o "típico"). Um milhão de registros parece um grande número, mas na verdade terminará muito rapidamente. Vejamos um exemplo, supondo que precisamos armazenar a tensão medida em uma célula a cada 15 segundos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.000.000 de registros com um registro em 15 segundos fornecem registros por minuto: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1.000.000 / (4 * 60 minutos / hora * 24 horas / dia) = 173,6 dias. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em outras palavras, sua EEPROM ficará sem reservas de um milhão de registros em menos de 6 meses.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abaixo está um gráfico mostrando o tempo de uso (em anos) com base no período de atualização de uma célula EEPROM específica. </font><font style="vertical-align: inherit;">A linha limite para um produto com expectativa de vida de 10 anos é uma atualização a cada 5 minutos e 15 segundos para um chip com um recurso de 1 milhão de registros. </font><font style="vertical-align: inherit;">Para uma EEPROM com um recurso de 100K, você pode atualizar uma célula específica não mais que uma vez a cada 52 minutos. </font><font style="vertical-align: inherit;">Isso significa que você não deve esperar atualizar a célula a cada poucos segundos, se desejar que seu produto funcione por anos, não meses. </font><font style="vertical-align: inherit;">As escalas acima são lineares, no entanto, neste dispositivo também existem fatores secundários, como temperatura e modo de acesso.</font></font><br>
<br>
<img src="https://habrastorage.org/files/147/941/974/147941974f174f3e83e91e0ef92f0396.gif"><br>
<br>
<h2><font color="#cc0000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diminuir frequência </font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira mais simples de resolver o problema é simplesmente escrever dados com menos frequência. </font><font style="vertical-align: inherit;">Em alguns casos, os requisitos do sistema permitem isso. </font><font style="vertical-align: inherit;">Ou você pode gravar apenas com as principais alterações. </font><font style="vertical-align: inherit;">No entanto, com uma entrada vinculada a eventos, esteja ciente de um cenário possível em que o valor flutue constantemente e acione um fluxo de eventos que levará ao desgaste da EEPROM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Seria bom se você pudesse determinar quantas vezes uma EEPROM foi gravada. Mas isso exigirá um contador que será armazenado na EEPROM ... e o problema se tornará um problema de contra-desgaste.)</font></font><br>
<br>
<h2><font color="#cc0000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interrupção da redução da nutrição </font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns processadores têm uma baixa interrupção de energia que pode ser usada para gravar o último valor na EEPROM, enquanto o sistema é desligado devido à perda de energia. </font><font style="vertical-align: inherit;">Em geral, você armazena o valor do interesse na RAM e o salva apenas na EEPROM quando desligar a energia. </font><font style="vertical-align: inherit;">Ou talvez você grave a EEPROM de tempos em tempos e escreva outra cópia na EEPROM como parte do procedimento de desligamento para garantir que os dados mais recentes sejam gravados. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É importante garantir que exista um capacitor de energia grande que mantenha uma tensão suficiente para programar a EEPROM por um tempo suficientemente longo. </font><font style="vertical-align: inherit;">Isso pode funcionar se você precisar gravar um ou dois valores, mas não um grande bloco de dados. </font><font style="vertical-align: inherit;">Cuidado, há muito espaço para erro!</font></font><br>
<br>
<h2><font color="#cc0000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffer de anel</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução clássica para o problema de desgaste é usar o buffer de anel FIFO contendo N entradas de último valor. Você também precisa salvar um ponteiro no final do buffer na EEPROM. Isso reduz o desgaste da EEPROM em um valor proporcional ao número de cópias nesse buffer. Por exemplo, se um buffer passar por 10 endereços diferentes para salvar um único valor, cada célula específica será modificada 10 vezes menos e o recurso de gravação aumentará 10 vezes. Você também precisará de um contador ou carimbo de data / hora separados para cada uma das 10 cópias, para poder determinar qual é a última no momento do desligamento. Em outras palavras, você precisa de dois buffers, um para o valor e outro para o contador. (Se você salvar o contador no mesmo endereço, isso causará sua deterioração, pois aumentará a cada ciclo de gravação.) A desvantagem deste método éque você precisa de 10 vezes mais espaço para obter uma vida 10 vezes maior. Você pode ser inteligente e embalar o contador junto com os dados. Se você escrever uma grande quantidade de dados, adicionar alguns bytes ao contador não é um problema tão grande. Mas, em qualquer caso, você precisará de muita EEPROM.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Atmel preparou uma nota contendo todos os detalhes: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVR-101: Armazenamento EEPROM de alta resistência: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.atmel.com/images/doc2526.pdf</font></font></a><br>
<br>
<h2><font color="#cc0000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um caso especial para o contador do número de registros </font></font><br>
</font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Às vezes, você precisa salvar o contador, não os valores em si. Por exemplo, você pode querer saber o número de vezes que o dispositivo foi ligado ou o tempo de operação do seu dispositivo. O pior dos contadores é que eles estão constantemente mudando o bit menos significativo, desgastando as células EEPROM inferiores mais rapidamente. Mas aqui é possível aplicar alguns truques. Existem várias idéias inteligentes no miniaplicativo do Microchip, como o uso de um código Gray para que apenas um bit de um contador multibyte seja alterado quando o valor do contador for alterado. Eles também recomendam o uso de códigos corretivos para compensar o desgaste. (Não sei quão eficaz será o uso de tais códigos, porque dependerá de quão independentes são os erros nos bits nos bytes do contador, use por seu próprio risco, aprox. Autor). Veja Appnote:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ww1.microchip.com/downloads/en/AppNotes/01449A.pdf</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nota: para quem gostaria de saber mais, a Microchip preparou um documento contendo informações detalhadas sobre o arranjo das células EEPROM e seu desgaste com diagramas: </font></font><br>
<a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ftp.microchip.com/tools /memory/total50/tutorial.html</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Deixe-me saber se você tem alguma idéia interessante sobre como lidar com o desgaste da EEPROM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fonte: Phil Koopman, SW de Melhor Sistema Incorporado </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betterembsw.blogspot.ru/2015/07/avoiding-eeprom-wearout.html</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota do tradutor: nos últimos anos, os chips EEPROM apareceram com uma organização de limpeza de páginas (semelhante aos chips FLASH), onde é possível endereçar logicamente as células (ler, escrever e apagar) byte-bye, mas o chip apaga a página inteira invisivelmente para o usuário e a substitui por novos dados. </font><font style="vertical-align: inherit;">Essa. </font><font style="vertical-align: inherit;">Depois de apagar as células no endereço 0, na verdade, as células foram apagadas e reescritas com os endereços 0 ... 255 (com um tamanho de página de 256 bytes), portanto, um truque de buffer não ajudará nesse caso. </font><font style="vertical-align: inherit;">Quando o recurso de registro de um microcircuito está esgotado, não uma célula falha, mas a página inteira. </font><font style="vertical-align: inherit;">Nas planilhas de dados para esses microcircuitos, o recurso de gravação é indicado </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a página</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e não para uma célula específica. </font><font style="vertical-align: inherit;">Consulte, por exemplo, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ficha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> técnica sobre 25LC1024 da Microchip.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt385213/">https://habr.com/ru/post/pt385213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt385199/index.html">Foi obtida uma lista de genes cuja remoção leva a um aumento significativo na vida útil da levedura</a></li>
<li><a href="../pt385201/index.html">As melhores fotos astronômicas de 2015</a></li>
<li><a href="../pt385205/index.html">Reino Unido e Espanha digitalizados pelo lidar</a></li>
<li><a href="../pt385207/index.html">Lockheed Martin coloca em produção a produção de lasers de combate</a></li>
<li><a href="../pt385209/index.html">A tecnologia do inversor permitirá o uso eficiente da energia de frenagem dos trens do metrô de Londres</a></li>
<li><a href="../pt385215/index.html">Sistemas de bateria Tesla serão instalados nos prédios de escritórios da Califórnia</a></li>
<li><a href="../pt385217/index.html">Relógio estúpido</a></li>
<li><a href="../pt385219/index.html">Mozilla: Erro sec_error_unknown_issuer (pensamentos em voz alta)</a></li>
<li><a href="../pt385221/index.html">Como é uma microrrede de metal ultraleve?</a></li>
<li><a href="../pt385225/index.html">Android 6.0 portado para o Nexus 10, Nexus 7 (2012)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>