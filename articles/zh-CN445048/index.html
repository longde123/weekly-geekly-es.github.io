<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌧️ 👨🏽‍🚀 🐞 扫线法Delaunay三角剖分算法 👃🏿 👩🏼‍🎤 🧒🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="美好的一天！ 

 在本文中，我将详细描述由于使用“扫描直线”思想在平面上构造Delaunay三角剖分而获得的算法。 当我阅读有关三角测量的文章时，其中有很多想法从未见过。 
 也许有人也会发现它们不寻常。 我将尝试按照最佳传统做所有事情，并在故事中包括以下内容：对使用的数据结构的描述，算法步骤的描...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>扫线法Delaunay三角剖分算法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445048/"> 美好的一天！ <br><br> 在本文中，我将详细描述由于使用“扫描直线”思想在平面上构造Delaunay三角剖分而获得的算法。 当我阅读有关三角测量的文章时，其中有很多想法从未见过。 <br> 也许有人也会发现它们不寻常。 我将尝试按照最佳传统做所有事情，并在故事中包括以下内容：对使用的数据结构的描述，算法步骤的描述，正确性证明，时间估计以及与使用kD树的迭代算法的比较。 <br><a name="habracut"></a><br><h2> 问题的定义和陈述 </h2><br><h4> 三角剖分 </h4><br> 他们说，如果通过边连接几对点，则在平面上的点集上指定了三角剖分，结果图形中的任何有限面都形成三角形，边不相交，并且图的边数最大。 <br><br><p><img src="https://habrastorage.org/webt/go/f6/x5/gof6x5u4p967b-k_rkp5vur3-wc.png" width="511" height="300"></p><br><br><h4> 德劳内三角剖分 </h4><br>  Delaunay三角剖分是一种三角剖分，其中对于任何三角形来说，围绕它的外接圆内的原始设置中确实没有任何点是正确的。 <br><br><p><img src="https://habrastorage.org/webt/fz/vv/az/fzvvaz-xuli8vyiit6xskbrysfa.png" width="508" height="300"></p><br><br>  <i>注意</i> ：对于一组给定的点，其中在同一圆上没有4个点，则仅存在一个Delaunay三角剖分。 <br><br><h4> 德劳内条件 </h4><br> 让我们对点集进行三角剖分。 我们说如果某个点的子集满足Delaunay条件，则该子集上的三角剖分是他的Delaunay三角剖分。 <br><br><h4>  Delaunay三角剖分准则 </h4><br> 对于在三角剖分中形成四边形的所有点，满足Delaunay条件的情况等同于该三角剖分是Delaunay三角剖分的事实。 <br><br>  <i>注意</i> ：对于非凸四边形，始终满足Delaunay条件，而对于凸四边形（其顶点不在同一圆上），恰好有2个可能的三角剖分（其中一个是Delaunay三角剖分）。 <br><br><p><img src="https://habrastorage.org/webt/32/qt/bv/32qtbvo-eil1x1o3w5-h86hb_ee.png" width="470" height="300"></p><br><br>  <b>任务是为给定的点集构造Delaunay三角剖分。</b> <br><br><h2> 算法说明 </h2><br><h4> 可见点和可见边缘 </h4><br> 让最小凸包（以下称为MBO）具有有限的一组点（连接某些点的边，以便它们形成包含该组所有点的多边形）和位于包壳外部的点A。 如果将平面连接到点A的线段不与MBO相交，则将点A称为可见点。 <br><br> 如果MBO边缘的端点对于A可见，则称为MBO边缘。 <br><br> 在下图中，红点可见的边缘用红色标记： <br><br><p><img src="https://habrastorage.org/webt/lv/jz/s9/lvjzs9fxcxn1yqvu4aqdo8mohwy.png" width="456" height="400"></p><br><br>  <i>注意</i> ：Delaunay三角剖分轮廓是建立点的MBO。 <br><br>  <i>备注2</i> ：在算法中，添加的点A可见的边形成一条链，即，一行中有多个MBO边 <br><br><h4> 将三角剖分存储在内存中 </h4><br>  Skvortsov [1]一书中很好地描述了一些标准方法。 由于算法的特殊性，我将提供自己的版本。 由于我们要检查Delaunay条件的4边形，因此考虑它们的结构。 三角剖分中的每个四边形是2个具有共同边的三角形。 每条边均具有与其相邻的2个三角形。 因此，三角剖分中的每个四边形都是由一个边和与相邻三角形中与该边相对的两个顶点生成的。 <br> 由于沿着边缘和两个顶点恢复了两个三角形及其邻接，因此我们可以为所有此类结构恢复三角剖分。 因此，提出了将具有两个顶点的边缘存储在集合中并沿着该边缘（有序的一对顶点）执行搜索。 <br><br><p><img src="https://habrastorage.org/webt/kp/yx/hf/kpyxhfrurcwtwf53gvu37-nkdko.png" width="309" height="200"></p><br><br><h3> 演算法 </h3><br> 扫掠线的思想是将所有点沿一个方向排序，然后依次处理。 <br><br><ol><li> 沿直线对所有点排序（为简单起见，按坐标 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> x </script>  ） </li><li> 我们在前三个点上构造一个三角形。 <br><br> 此外，对于每个下一个点，我们将执行以下步骤，以保持不变：已添加的点存在Delaunay三角剖分，因此，对其进行MBO。 </li><li> 添加由可见边缘和点本身形成的三角形（即，将所讨论点的边缘添加到可见边缘的所有末端）。 </li><li> 我们在Delaunay条件下检查可见边缘生成的所有四边形。 如果在某处未满足该条件，则我们在四边形中重建三角剖分（我记得其中只有两个）并递归运行当前四边形的边生成的四边形的检查（因为只有在它们之后才可能违反Delaunay条件）。 </li></ol><br>  <i>注意</i> ：在递归开始过程中的步骤（4）中，您无法检查由在此迭代中考虑的点产生的边所生成的四边形（总是有四个中的两个）。 大多数情况下，它们将是非凸的，因为凸的证明是纯几何的，我将其留给读者。 此外，我们假设每次重建仅执行2次递归启动。 <br><br><h4> 验证Delaunay条件 </h4><br> 在同一本书中可以找到测试Delaunay条件的四边形的方法[1]。 我只注意到，当从那里选择具有三角函数的方法时，如果实现不正确，则可以得到正弦的负值，将它们取模是有意义的。 <br><br><h4> 搜索可见边缘 </h4><br> 有待了解如何有效地找到可见的边缘。 请注意，先前添加的点S在当前迭代中位于MBO中，因为它具有最大的坐标 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> x </script>  ，并且在当前点也可见。 然后，注意到可见边缘的末端形成了可见点的连续链，我们可以沿着MBO在两个方向上从点S出发，并在可见时收集边缘（使用向量积检查边缘的可见性）。 因此，将MBO存储为双重连接的列表很方便，在每次迭代中都删除可见边缘并从考虑的点添加2个新边缘。 <br><br><p><img src="https://habrastorage.org/webt/n9/0_/ub/n90_ubf1nbeabdhapitulxvuxgo.png" width="429" height="500"></p><br><br><h4> 算法可视化 </h4><br> 两个红点-已添加和在前。 时刻的红色边缘构成步骤（4）中的递归堆栈： <br><br><p><img src="https://habrastorage.org/webt/yq/0a/jc/yq0ajcb3zw7403xa4mvtds17xcs.gif"></p><br><br><h2> 算法正确性 </h2><br> 为了证明算法的正确性，足以证明步骤（3）和（4）中不变量的守恒。 <br><br><h4> 步骤（3） </h4><br> 显然，在步骤（3）之后，我们对当前点集进行了三角剖分。 <br><br><h4> 步骤（4） </h4><br> 在步骤（4）的过程中，所有不满足Delaunay条件的四边形都在递归堆栈中（根据说明进行），这意味着在步骤（4）的末尾，所有四边形都满足Delaunay条件，即实际上构造了Delaunay三角剖分。 然后剩下的就是证明步骤（4）中的过程总有一天会结束。 这是由于以下事实：在重建过程中添加的所有边都来自所讨论的当前顶点（即 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> k </script> 不超过 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.214ex" height="2.178ex" viewBox="0 -780.1 2244.9 937.7" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-2212" x="743" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-31" x="1744" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> k-1 </script>  ），并且在添加这些边后，我们将不再考虑由它们生成的四边形（请参见前面的说明），这意味着我们将添加不超过一次。 <br><br><h2> 时间复杂度 </h2><br> 平均而言，该算法在均匀的正态分布上效果很好（结果显示在下表中）。 假设其工作时间为 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.693ex" height="2.419ex" viewBox="0 -780.1 5465 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="1593" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6C" x="2481" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6F" x="2780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-67" x="3265" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="3746" y="0"></use><g transform="translate(4634,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-5"> O（NlogN）</script>  。 最坏的情况是进行评估 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><msup><mi>N</mi><mn>2</mn></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.806ex" height="2.66ex" viewBox="0 -935.7 3791.4 1145.2" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(1593,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-32" x="1292" y="513"></use></g><g transform="translate(2961,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><msup><mi>N</mi><mn>2</mn></msup><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-6"> O（N ^ 2）</script>  。 <br><br><p><img src="https://habrastorage.org/webt/bw/9s/qt/bw9sqtpuuwm9vtnsdcfhhluyaew.png"></p><br><br> 让我们看一下各部分的工作时间，了解哪个对总时间有最大的影响： <br><br><h4> 按方向排序 </h4><br> 为了进行排序，我们将使用估计值 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.693ex" height="2.419ex" viewBox="0 -780.1 5465 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="1593" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6C" x="2481" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6F" x="2780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-67" x="3265" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="3746" y="0"></use><g transform="translate(4634,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-7"> O（NlogN）</script>  。 <br><br><h4> 搜索可见边缘 </h4><br> 首先，我们证明搜索可见边缘所花费的总时间为 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.692ex" height="2.298ex" viewBox="0 -780.1 3312 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="1593" y="0"></use><g transform="translate(2481,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-8"> O（N）</script>  。 请注意，在每次迭代中，我们发现所有可见边缘以及线性时间内的另外2个（第一次不可见）。 在步骤（3）中，我们向MBO添加新的2条边。 因此，总计不超过 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>N</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.226ex" height="2.057ex" viewBox="0 -780.1 1389 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>N</mi></math></span></span><script type="math/tex" id="MathJax-Element-9"> 2N </script> 因此，各种可见的肋骨将不再存在 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>N</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.226ex" height="2.057ex" viewBox="0 -780.1 1389 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>N</mi></math></span></span><script type="math/tex" id="MathJax-Element-10"> 2N </script>  。 我们还会发现 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>N</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.226ex" height="2.057ex" viewBox="0 -780.1 1389 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>N</mi></math></span></span><script type="math/tex" id="MathJax-Element-11"> 2N </script> 不可见的边缘。 因此，总而言之 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>4</mn><mi>N</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.226ex" height="2.057ex" viewBox="0 -780.1 1389 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-34" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>4</mn><mi>N</mi></math></span></span><script type="math/tex" id="MathJax-Element-12"> 4N </script> 对应时间的肋骨 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.692ex" height="2.298ex" viewBox="0 -780.1 3312 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="1593" y="0"></use><g transform="translate(2481,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-13"> O（N）</script>  。 <br><br><h4> 建立新的三角形 </h4><br> 从步骤（3）构造具有已知边缘的三角形的总时间显然是 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.692ex" height="2.298ex" viewBox="0 -780.1 3312 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="1593" y="0"></use><g transform="translate(2481,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-14"> O（N）</script>  。 <br><br><h4> 重建三角剖分 </h4><br> 剩下要处理步骤（4）。 首先，请注意，检查Delaunay条件并进行重建（如果未满足）是非常昂贵的操作（尽管它们适用于 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.791ex" height="2.298ex" viewBox="0 -780.1 2924 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-31" x="1593" y="0"></use><g transform="translate(2093,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mn>1</mn><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-15"> O（1）</script>  ） 仅在检查Delaunay条件时，才能执行约28个算术运算。 让我们看一下此步骤中的平均重建次数。 下面给出了一些分布的实际结果。 对于他们，我真的想说平均重排数以对数速度增长，但让我们将此作为假设。 <br><br><p><img src="https://habrastorage.org/webt/vm/ld/5u/vmld5u3pzetnfsdkyjx2cuhkabg.png"></p><br><br> 在这里，我还想指出，每个点的平均重排数量可能与执行排序的方向有很大不同。 因此，对于长宽比为100000：1的长百万个矩形上均匀分布的一百万，此数字在1.2到24之间变化（这些值分别在对数据进行水平和垂直排序时获得）。 因此，我看到了以任意方式选择排序方向的要点（在此示例中，通过任意选择，平均可以获得大约2次重建），或者如果事先知道数据，则手动选择它。 <br><br> 因此，程序通常将主要时间带到步骤（4）。 如果运行很快，则考虑加快排序是有意义的。 <br><br><h4> 最坏的情况 </h4><br> 最坏的情况 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span><script type="math/tex" id="MathJax-Element-16"> k </script> 第迭代发生 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.214ex" height="2.178ex" viewBox="0 -780.1 2244.9 937.7" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-2212" x="743" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-31" x="1744" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-17"> k-1 </script> 步骤（4）中的递归调用，即对所有i求和，我们得到最坏情况下的渐近行为 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><msup><mi>N</mi><mn>2</mn></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.806ex" height="2.66ex" viewBox="0 -935.7 3791.4 1145.2" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(1593,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMAIN-32" x="1292" y="513"></use></g><g transform="translate(2961,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><msup><mi>N</mi><mn>2</mn></msup><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-18"> O（N ^ 2）</script>  。 下图显示了一个可以长时间运行程序的漂亮示例（添加输入10,000点的新点时，平均重建1100个）。 <br><br><p><img src="https://habrastorage.org/webt/mq/jm/xe/mqjmxeapcrztwr_rrelmjd9to4e.png" width="355" height="400"></p><br><br><h2> 与使用kD树构造Delaunay三角剖分的迭代算法的比较 </h2><br><h4> 迭代算法的描述 </h4><br> 我将简要描述上述算法。 当下一个点到达时，我们使用kD树（如果您不知道，我建议您在某处阅读），我们发现一个已经非常接近它的三角形。 然后绕过深度，我们寻找一个三角形，点本身掉入其中。 我们将边缘扩展到找到的三角形的顶点，并针对新的四边形实际执行算法中的步骤（4）。 由于该点可以在三角剖分之外，为简化起见，建议使用大三角形覆盖所有点（预先构建），这将解决该问题。 <br><br><h4> 算法的相似性 </h4><br> 实际上，如果按方向将点按顺序添加，则我们的算法实际上与迭代的工作原理相同，只不过重排的次数较少。 以下动画完美地展示了这一点。 在其上，从右到左添加了点，它们全部被一个大三角形覆盖，随后将其删除。 <br><p><img src="https://habrastorage.org/webt/va/hk/hv/vahkhve0ibbfy9mh3daeqcqkxjk.gif"></p><br><br><h4> 算法差异 </h4><br> 在迭代算法中，点的定位（搜索所需三角形）平均发生在 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.629ex" height="2.419ex" viewBox="0 -780.1 4576.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6C" x="1593" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-6F" x="1891" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-67" x="2377" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/445048/&amp;usg=ALkJrhgWb9fDq-e6woEzAxesnq-Y2uYa2Q#MJMATHI-4E" x="2857" y="0"></use><g transform="translate(3746,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-19"> O（logN）</script>  ，在上述分布上，在任意顺序的积分供应条件下，平均会发生3次重排（如[1]所示）。 因此，扫描线在本地化中赢得了迭代算法的时间，但在重建中却失去了它（我记得这是非常困难的）。 另外，迭代算法在线运行，这也是它的显着特征。 <br><br><h2> 结论 </h2><br> 在这里，我仅展示了算法运算产生的一些有趣的三角剖分。 <br><br><h4> 美丽的图案 </h4><br><p><img src="https://habrastorage.org/webt/tm/gz/0w/tmgz0wuwxltnm3qsyylyz_lfbhs.png" width="703" height="600"></p><br><br><h4> 正态分布，1000点 </h4><br><p><img src="https://habrastorage.org/webt/gu/1g/ga/gu1ggatmijtapwt1macmzovasuo.png" width="648" height="600"></p><br><br><h4> 平均分配1000点 </h4><br><p><img src="https://habrastorage.org/webt/vt/er/mn/vtermnwtifbyshrnan2nckbkqqw.png" width="686" height="600"></p><br><br><h4> 建立在俄罗斯所有城市位置的三角剖分 </h4><br><p><img src="https://habrastorage.org/webt/tz/fw/bj/tzfwbjwjhaevthspbs3gsxv89oy.png"></p><br><p><img src="https://habrastorage.org/webt/ex/fw/9e/exfw9epur4gydutw6ok3dxpt1vc.png"></p><br><br> 在这里，您可以看到我的算法示例代码： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/Vemmy124/Delaunay-Triangulation-Algorithm</a> <br><br>  <b>感谢您的关注！</b> <br><br><h3> 文学作品 </h3><br>  [1] Skvortsov A.V.  Delaunay三角剖分及其应用。 汤姆斯克：汤姆出版社。 大学，2002.-128羽 书号5-7511-1501-5 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445048/">https://habr.com/ru/post/zh-CN445048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445036/index.html">什么是第一部iPhone？</a></li>
<li><a href="../zh-CN445038/index.html">在GitHub上100,000个存储库中发现的分类信息泄漏</a></li>
<li><a href="../zh-CN445040/index.html">我们建立模型，“出售”知识管理以进行管理，并纠正幸存者的错误</a></li>
<li><a href="../zh-CN445042/index.html">Ulan-Ude程序员的Delphic成功故事</a></li>
<li><a href="../zh-CN445044/index.html">在生产系统中进行应用。 验证者</a></li>
<li><a href="../zh-CN445052/index.html">为什么不能设置访问链接的字体大小？</a></li>
<li><a href="../zh-CN445054/index.html">AI现在对肺癌和实验室诊断进行分类</a></li>
<li><a href="../zh-CN445056/index.html">Web开发课程概述</a></li>
<li><a href="../zh-CN445058/index.html">特斯拉自动驾驶学习了如何确定相邻汽车的车道变化</a></li>
<li><a href="../zh-CN445060/index.html">使用Spring Data键值存储库组织数据搜索</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>