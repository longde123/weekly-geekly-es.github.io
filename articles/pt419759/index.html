<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßì üôçüèø üå† √Årvores DSL internas e de express√£o - cria√ß√£o din√¢mica de serializar, copiar, clonar, fun√ß√µes iguais (Parte I) ‚ôÇÔ∏è üëãüèº ü¶é</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo se concentra no uso duplo da API Expression Trees - para analisar express√µes e gerar c√≥digo. A an√°lise de express√µes ajuda a criar estrutu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Årvores DSL internas e de express√£o - cria√ß√£o din√¢mica de serializar, copiar, clonar, fun√ß√µes iguais (Parte I)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419759/"><p><img src="https://habrastorage.org/webt/_c/m3/gr/_cm3grewmg9yewpcch1nqkl2ho8.png"></p><br><p>  Este artigo se concentra no uso duplo da API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Expression Trees</a> - para analisar express√µes e gerar c√≥digo.  A an√°lise de express√µes ajuda a criar estruturas de apresenta√ß√£o (elas tamb√©m s√£o estruturas de apresenta√ß√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DSL interna da</a> linguagem orientada a problemas) e a gera√ß√£o de c√≥digo permite criar dinamicamente fun√ß√µes eficazes - conjuntos de instru√ß√µes definidas pelas estruturas de apresenta√ß√£o. </p><br><p> Vou demonstrar a cria√ß√£o din√¢mica de <strong>iteradores</strong> de <strong>propriedades: serializar, copiar, clonar, iguais</strong> .  Usando serialize como exemplo, mostrarei como otimizar a serializa√ß√£o (em compara√ß√£o com os serializadores de fluxo) na situa√ß√£o cl√°ssica em que o conhecimento "preliminar" √© usado para melhorar o desempenho.  A id√©ia √© que chamar o serializador de streaming sempre perder√° a fun√ß√£o "non-streaming", sabendo exatamente quais n√≥s da √°rvore para contornar.  Ao mesmo tempo, esse serializador √© criado "n√£o √† m√£o", mas dinamicamente, mas de acordo com regras de desvio predefinidas.  <strong>O DSL interno proposto resolve o problema de uma descri√ß√£o compacta das regras para percorrer as estruturas em √°rvore dos objetos por suas propriedades / propriedades (e, no caso geral: atravessar a √°rvore de computa√ß√£o com o nome de n√≥s)</strong> .  O benchmark do serializador √© modesto, mas √© importante, pois contribui para a abordagem criada em torno do uso de um Internal <strong>DSL</strong> Include espec√≠fico (um dialeto de Include / ThenInclude from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EF Core</a> ) e o uso do Internal DSL como um todo, a persuas√£o necess√°ria. </p><a name="habracut"></a><br><h2 id="vvedenie">  1. Introdu√ß√£o </h2><br><p>  Compare: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = $"{{\"X\":{pX}, \"Y\":{pY}}}";</span></span></code> </pre> <br><p>  O segundo m√©todo √© obviamente mais r√°pido (os n√≥s s√£o conhecidos e est√£o "amontoados no c√≥digo"), enquanto o m√©todo √© obviamente mais complicado.  Mas quando voc√™ obt√©m esse c√≥digo como uma fun√ß√£o (gerada e compilada dinamicamente), a complexidade fica oculta (mesmo o que fica claro fica oculto <br>  onde est√° reflex√£o e onde est√° o tempo de execu√ß√£o da gera√ß√£o de c√≥digo). </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); var json2 = formatter(p);</span></span></code> </pre> <br><p>  Aqui, o <code>JsonManager.ComposeFormatter</code> √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta real</a> .  A regra pela qual o desvio de estrutura √© gerado durante a serializa√ß√£o n√£o √© √≥bvia, mas soa assim "com os par√¢metros padr√£o, pois os tipos de valor personalizados percorrem todos os campos do primeiro n√≠vel".  Se voc√™ configur√°-lo explicitamente: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    var formatter2 = JsonManager.ComposeFormatter&lt;Point&gt;( chain=&gt;chain .Include(e=&gt;eX) .Include(e=&gt;eY) // DSL Includes )</span></span></code> </pre> <br><p>  Esta √© a descri√ß√£o dos metadados atrav√©s de Inclui DSL.  O DSL esclareceu a an√°lise dos pr√≥s e contras da descri√ß√£o de metadados, mas agora ignorando a forma de metadados de grava√ß√£o, enfatizo que o C # fornece a capacidade de compilar e compilar o "serializador ideal" usando as √Årvores de Express√£o. </p><br><div class="spoiler">  <b class="spoiler_title">Como ele faz isso - muitos c√≥digos e guia de gera√ß√£o de c√≥digo das √Årvores de Express√£o ...</b> <div class="spoiler_text"><p>  transi√ß√£o do <code>formatter</code> para o <code>serilizer</code> (at√© agora sem √°rvores de express√£o): </p><br><pre> <code class="cs hljs"> Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = ... <span class="hljs-comment"><span class="hljs-comment">// later string formatter(Point p) { var stringBuilder = new StringBuilder(); serializer(stringBuilder, p); return stringBuilder.ToString(); }</span></span></code> </pre> <br><p>  Por sua vez, o <code>serializer</code> √© constru√≠do assim (se definido com c√≥digo est√°tico): </p><br><pre> <code class="cs hljs">Expression&lt;Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; serializerExpression = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ); Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = serializerExpression.Compile();</code> </pre> <br><p>  Por que √© t√£o "funcional", por que voc√™ n√£o pode serializar dois campos atrav√©s de um ponto e v√≠rgula?  Em resumo: porque esta express√£o pode ser atribu√≠da a uma vari√°vel do tipo <code>Expression&lt;Func&lt;StringBuilder, Box, bool&gt;&gt;</code> , mas um ponto-e-v√≠rgula n√£o √© permitido. <br>  Por que n√£o consegui escrever diretamente <code>Func&lt;StringBuilder, Point, bool&gt; serializer = (sb,p)=&gt;SerializeAssociativeArray(sb,p,...</code> ? √â poss√≠vel, mas n√£o estou demonstrando a cria√ß√£o de um delegado, mas de um assembly (neste caso, c√≥digo est√°tico) √°rvore de express√£o, com uma compila√ß√£o para o delegado no futuro, em uso pr√°tico, <code>serializerExpression</code> ser√° definido de uma maneira completamente diferente - dinamicamente (abaixo). </p><br><p>  Mas o que √© importante na pr√≥pria solu√ß√£o: <code>SerializeAssociativeArray</code> aceita uma matriz de <code>params Func&lt;..&gt; propertySerializers</code> acordo com o n√∫mero de n√≥s a serem ignorados.  Ignorar alguns deles pode ser definido pelos serializadores SerializeValueProperty de folhas (aceitando o formatador <code>SerializeValueToString</code> ) e outros novamente pelo <code>SerializeAssociativeArray</code> (ou seja, ramifica√ß√µes) e, portanto, um iterador (√°rvore) do percurso √© constru√≠do. </p><br><p>  Se Point continha a propriedade NextPoint: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"NextPoint"</span></span>, o =&gt; o.NextPoint, (sb4, t4) =&gt;SerializeAssociativeArray(sb1, p1, (sb1, t1) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ) ) );</code> </pre> <br><p>  O dispositivo das tr√™s fun√ß√µes <code>SerializeAssociativeArray</code> , <code>SerializeValueProperty</code> , <code>SerializeValueToString</code> n√£o <code>SerializeValueToString</code> complicado: </p><br><div class="spoiler">  <b class="spoiler_title">Serializar ...</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeAssociativeArray&lt;T&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Func&lt;StringBuilder, T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;[] propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertySerializer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = propertySerializer(stringBuilder, t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notEmpty) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">','</span></span>); } }; stringBuilder.Length--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueProperty&lt;T, TProp&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Func&lt;T, TProp&gt; getter, Func&lt;StringBuilder, TProp, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TProp : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(propertyName).Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(<span class="hljs-string"><span class="hljs-string">':'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = getter(t); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = serializer(stringBuilder, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!notEmpty) stringBuilder.Length -= (propertyName.Length + <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notEmpty; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueToString&lt;T&gt;(StringBuilder stringBuilder, T t) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> </div></div><br><p>  Muitos detalhes n√£o s√£o fornecidos aqui (suporte de lista, tipo de refer√™ncia e nulo).  E, no entanto, est√° claro que realmente recebo <em>json</em> na sa√≠da, e todo o resto s√£o ainda mais das fun√ß√µes padr√£o <code>SerializeArray</code> , <code>SerializeNullable</code> , <code>SerializeRef</code> . </p><br><p>  Era uma √°rvore de express√£o est√°tica, sem din√¢mica, sem avalia√ß√£o <em>em C #</em> . </p><br><p>  Voc√™ pode ver como a √Årvore de Express√µes √© criada dinamicamente em duas etapas: </p><br><h4 id="shag-1---decompilerom-posmotret-na-kod-prisvoennyy-expressiont">  Etapa 1 - descompilador observe o c√≥digo atribu√≠do pela <code>Expression&lt;T&gt;</code> </h4><br><p><img src="https://habrastorage.org/webt/ox/p3/g2/oxp3g2newr9bhr3oba5bajcrkco.png"></p><br><p>  √â claro que isso ir√° surpreend√™-lo pela primeira vez.  Nada est√° claro, mas voc√™ pode ver como as quatro primeiras linhas formam algo como: </p><br><pre> <code class="cs hljs">(<span class="hljs-string"><span class="hljs-string">"sb"</span></span>,<span class="hljs-string"><span class="hljs-string">"t"</span></span>) .. SerializeAssociativeArray..</code> </pre> <br><p>  Em seguida, a conex√£o com o c√≥digo fonte √© capturada.  E deve ficar claro que, se voc√™ dominar esse registro (combinando 'Expression.Const', 'Expression.Parameter', 'Expression.Call', 'Expression.Lambda' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">etc</a> ...), poder√° realmente compor dinamicamente - qualquer desvio de n√≥s (com base em metadados).  Isso √© <em>eval em c #</em> . </p><br><h4 id="shag-2----shodit-po-etoy-ssylkehttpsgithubcomdashboardcoderoutinesblobmastertestsconsoleappsclrmdautomationprogramcsl99-l194">  Etapa 2 - siga <a href="">este link</a> , </h4><br><p>  O mesmo c√≥digo de descompilador, mas compilado pelo homem. </p><br><p>  Somente o autor do int√©rprete √© obrigado a se envolver neste bordado de mi√ßangas.  Todas essas artes permanecem dentro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da biblioteca de serializa√ß√£o</a> .  √â importante aprender a id√©ia de que voc√™ pode fornecer bibliotecas que geram dinamicamente fun√ß√µes eficientes compiladas em C # (e .NET Standard). </p></div></div><br><p>  No entanto, um serializador de streaming ultrapassar√° uma fun√ß√£o gerada dinamicamente se voc√™ chamar a compila√ß√£o todas as vezes antes da serializa√ß√£o (a compila√ß√£o dentro do <code>ComposeFormatter</code> √© uma opera√ß√£o cara), mas voc√™ pode salvar o link e reutiliz√°-lo: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;Point, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = formatter(p); return json2; }</span></span></code> </pre> <br><p>  Se voc√™ precisar criar e salvar o serializador de tipo an√¥nimo para reutiliza√ß√£o, precisar√° de infraestrutura adicional: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Point&gt; list</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// there json formatter will be build only for first call // and assigned to cachedFormatter.Formatter // in all next calls cachedFormatter.Formatter will be used. // since building of formatter is determenistic it is lock free var json3 = list.Select(e=&gt; {X:eX, Sum:e.X+EY}) .ToJson(cachedFormatter, e=&gt;e.Sum); return json3; }</span></span></code> </pre> <br><p>  Depois disso, levamos em conta com confian√ßa a primeira microoptimiza√ß√£o para n√≥s mesmos e acumulamos, acumulamos, acumulamos ... Quem √© a piada, quem n√£o √©, mas antes de passar √† pergunta de que o novo serializador √© novo, eu fixo a vantagem √≥bvia - ser√° mais r√°pido. </p><br><h2 id="chto-vzamen">  O que em troca? </h2><br><p>  O int√©rprete DSL Inclui em serilizar (e da mesma maneira que √© poss√≠vel em iteradores iguais, copiar, clonar - e isso tamb√©m ser√° necess√°rio) exigiu os seguintes custos: </p><br><p>  <strong>1</strong> - custos da infraestrutura para armazenar links para c√≥digo compilado. </p><br><p>  Esses custos geralmente n√£o s√£o necess√°rios, assim como o uso de √Årvores de Express√£o na compila√ß√£o - o int√©rprete pode criar um serializador em reflexos e at√© lamber tanto que chegar√° √† velocidade em termos de serializadores de fluxo (a prop√≥sito, copie, clone e iguais n√£o s√£o coletados atrav√©s de √°rvores de express√£o, nem s√£o lambidos, n√£o existe tal tarefa, ao contr√°rio de ultrapassar o ServiceStack e o Json.NET dentro da estrutura da bem-compreendida tarefa de otimizar a serializa√ß√£o no json - uma condi√ß√£o necess√°ria para apresentar uma nova solu√ß√£o). </p><br><p>  <strong>2</strong> - voc√™ precisa ter em mente vazamentos de abstra√ß√µes e um problema semelhante: altera√ß√µes na sem√¢ntica em compara√ß√£o com as solu√ß√µes existentes. </p><br><p>  Por exemplo, Point e IEnumerable precisam de dois serializadores diferentes para serializar. <br></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter1 = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter2 = JsonManager.ComposeEnumerableFormatter&lt;Point&gt;(); <span class="hljs-comment"><span class="hljs-comment">// but not // var formatter2 = JsonManager.ComposeEnumerableFormatter&lt;List&lt;Point&gt;&gt;();</span></span></code> </pre> <br><p>  Ou: "o fechamento funciona?".  Funciona, apenas o n√≥ precisa definir um nome (exclusivo): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> DATEFORMAT= <span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter3 = JsonManager.ComposeFormatter&lt;Record&gt;( chain =&gt; chain .Include(i =&gt; i.RecordId) .Include(i =&gt; i.CreatedAt.ToString(DATEFORMAT) , <span class="hljs-string"><span class="hljs-string">"CreatedAt"</span></span>); );</code> </pre> <br><p>  Esse comportamento √© determinado pelo dispositivo interno do interpretador <code>ComposeFormatter</code> . </p><br><p>  Custos desse tipo s√£o inevit√°veis.  Al√©m disso, verifica-se que, expandindo a funcionalidade e o escopo do DSL interno, os vazamentos de abstra√ß√£o tamb√©m aumentam.  Certamente oprimir√° o desenvolvedor do Internal DSL; aqui voc√™ precisa estocar um clima filos√≥fico. </p><br><p>  Para o usu√°rio, os vazamentos de abstra√ß√£o s√£o superados pelo conhecimento dos detalhes t√©cnicos do DSL interno ( <em>o que esperar?</em> ) E a riqueza da funcionalidade de um DSL espec√≠fico e de seus int√©rpretes (o <em>que, em troca?</em> ).  Portanto, a resposta √† pergunta: "vale a pena criar e usar DSL interno?", S√≥ pode haver uma hist√≥ria sobre a funcionalidade de uma DSL espec√≠fica - sobre todos os seus detalhes e conveni√™ncias e suas poss√≠veis aplica√ß√µes (int√©rpretes), ou seja,  uma hist√≥ria sobre como superar custos. </p><br><p>  Com tudo isso em mente, volto √† efic√°cia de um determinado DSL Inclui. </p><br><p>  Uma efici√™ncia significativamente maior √© alcan√ßada quando o objetivo √© substituir o triplo (DTO, transformar em DTO, serializar DTO) por uma fun√ß√£o de serializa√ß√£o gerada e detalhada localmente.  No final, o dualismo fun√ß√£o-objeto permite que voc√™ diga "DTO √© uma fun√ß√£o" e defina uma meta: aprender a definir uma fun√ß√£o DTO. </p><br><p>  A serializa√ß√£o deve ser configurada: </p><br><ol><li>  √Årvore de desvio (para descrever os n√≥s atrav√©s dos quais a serializa√ß√£o ocorrer√°, pela maneira como isso resolve o problema dos links circulares), no caso de folhas - atribua um formatador (por tipo). </li><li>  A regra para incluir folhas (se n√£o estiverem especificadas) - propriedade vs campos?  somente leitura? </li><li>  Para poder especificar uma ramifica√ß√£o (um n√≥ com navega√ß√£o) e uma planilha n√£o √© apenas MemberExpression ( <code>e=&gt;e.Name</code> ), mas geralmente qualquer fun√ß√£o (`e =&gt; e.Name.ToUpper ()," MyMemberName ") - defina o formatador como um espec√≠fico n√≥ </li></ol><br><p>  Outras op√ß√µes para aumentar a flexibilidade: </p><br><ol><li>  serializar uma planilha contendo uma string json "como est√°" (formatador de string especial); </li><li>  definir formatadores para grupos, ou seja,  ramos inteiros, neste ramo como este - de outro de uma maneira diferente (por exemplo, data aqui com tempo e neste sem tempo). </li></ol><br><p>  Em todos os lugares, as constru√ß√µes envolvidas: desvio de √°rvore, ramo, folha e tudo isso pode ser escrito usando o DSL Inclui. </p><br><h2 id="dsl-includes">  DSL Inclui </h2><br><p>  Como todos est√£o familiarizados com o EF Core, o significado das seguintes express√µes deve ser capturado imediatamente (este √© um subconjunto do xpath). </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// DSL Includes Include&lt;User&gt; include1 = chain=&gt; chain .IncludeAll(e =&gt; e.Groups) .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) // EF Core syntax // https://docs.microsoft.com/en-us/ef/core/querying/related-data var users = context.Users .Include(blog =&gt; blog.Groups) .Include(blog =&gt; blog.Roles) .ThenInclude(blog =&gt; blog.Privileges);</span></span></code> </pre> <br><p>  Aqui est√£o os n√≥s "com navega√ß√£o" - "ramifica√ß√µes". <br>  A resposta para a pergunta que n√≥s "deixa" (campos / propriedades) est√° inclu√≠da na √°rvore assim definida - nenhuma.  Para incluir folhas, voc√™ deve list√°-las explicitamente: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include2 = chain=&gt; chain .Include(e =&gt; e.UserName) <span class="hljs-comment"><span class="hljs-comment">// leaf member .IncludeAll(e =&gt; e.Groups) .ThenInclude(e =&gt; e.GroupName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenInclude(e =&gt; e.RoleName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .ThenInclude(e =&gt; e.PrivilegeName) // leaf member</span></span></code> </pre><br><p>  Ou adicione dinamicamente pela regra, atrav√©s de um int√©rprete especializado: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Func&lt;ChainNode, MemberInfo&gt; rule = ... var include2 = IncludeExtensions.AppendLeafs(include1, rule);</span></span></code> </pre> <br><p>  Aqui, a regra √© uma regra que pode ser selecionada por ChainNode.Type, ou seja,  por tipo de express√£o retornada pelo n√≥ (ChainNode - representa√ß√£o interna do DSL Inclui, que ser√° discutido mais adiante) propriedades (MemberInfo) para participa√ß√£o na serializa√ß√£o, por exemplo  somente propriedade, ou apenas propriedade de leitura / grava√ß√£o, ou apenas aquelas para as quais existe um formatador, voc√™ pode selecionar em uma lista de tipos e at√© a pr√≥pria express√£o include pode definir uma regra (se listar n√≥s de folha - ou seja, a forma de jun√ß√£o de √°rvore) . </p><br><p>  Ou ... deixe a crit√©rio do int√©rprete do usu√°rio, que decide o que fazer com os n√≥s.  Inclui DSL √© apenas um registro de metadados - como interpretar esse registro depende do int√©rprete.  Ele pode interpretar os metadados como quiser, at√© ignor√°-los.  Alguns int√©rpretes executam a a√ß√£o eles mesmos, enquanto outros constroem uma fun√ß√£o pronta para execut√°-la (via Expression Tree ou mesmo Reflection.Emit).  Uma boa DSL interna √© projetada para uso universal e a exist√™ncia de muitos int√©rpretes, cada um com suas pr√≥prias especificidades, sua pr√≥pria abstra√ß√£o vaza. <br>  C√≥digo usando DSL interno pode ser muito diferente do que era antes. </p><br><h4 id="out-of-the-box">  Fora da caixa </h4><br><p>  Integra√ß√£o com o EF Core. <br>  A tarefa em execu√ß√£o √© "interromper links c√≠clicos", para inicializar apenas o que √© especificado na express√£o de inclus√£o: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json = EfCoreExtensions.ToJsonEf&lt;User&gt;(cachedFormatter1, dbContext, chain=&gt;chain .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges)); } }</code> </pre> <br><p>  <code>ToJsonEf</code> aceita a sequ√™ncia de navega√ß√£o, ao serializar, a usa (seleciona folhas pela regra "padr√£o para EF Core", isto √©, propriedade p√∫blica de leitura / grava√ß√£o), est√° interessada no modelo - onde string / json usa formatadores de campo para inserir como est√° por padr√£o (byte [] por string, data e hora em ISO, etc.).  Portanto, ele deve executar o IQuaryable de baixo de si mesmo. </p><br><p>  No caso em que o resultado √© transformado, as regras mudam - n√£o √© necess√°rio usar o DSL Inclui para especificar a navega√ß√£o (se n√£o houver reutiliza√ß√£o da regra), outro int√©rprete √© usado e a configura√ß√£o ocorre localmente: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = dbContext.ParentRecords <span class="hljs-comment"><span class="hljs-comment">// back to EF core includes // but .Include(include1) also possible .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .Select(e =&gt; new { FieldA: e.FieldA, FieldJson:"[1,2,3]", Role: e.Roles().First() }) .ToJson(cachedFormatter1, chain =&gt; chain.Include(e =&gt; e.Role), LeafRuleManager.DefaultEfCore, config: rules =&gt; rules .AddRule&lt;string[]&gt;(GetStringArrayFormatter) .SubTree( chain =&gt; chain.Include(e =&gt; e.FieldJson), stringAsJsonLiteral: true) // json as is .SubTree( chain =&gt; chain.Include(e =&gt; e.Role), subRules =&gt; subRules .AddRule&lt;DateTime&gt;( dateTimeFormat: "YYYMMDD", floatingPointFormat: "N2" ) ), ), useToString: false, // no default ToString for unknown leaf type (throw exception) dateTimeFormat: "YYMMDD", floatingPointFormat: "N2" } }</span></span></code> </pre> <br><p>  √â claro que todos esses detalhes, tudo isso √© "por padr√£o", s√≥ podem ser lembrados se voc√™ realmente precisar e / ou se esse for seu pr√≥prio int√©rprete.  Por outro lado, voltamos novamente √†s vantagens: o DTO n√£o √© manchado pelo c√≥digo, √© especificado por uma fun√ß√£o espec√≠fica, os int√©rpretes s√£o universais.  O c√≥digo est√° ficando menor - isso √© bom. </p><br><p>  <strong>√â necess√°rio avisar</strong> : embora pare√ßa que o conhecimento preliminar esteja sempre dispon√≠vel no ASP, e um serializador de streaming n√£o √© uma coisa muito necess√°ria no mundo da Web, onde at√© bancos de dados transmitem dados em json, mas o uso do DSL Include no ASP MVC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o √© a hist√≥ria mais f√°cil</a> .  Como combinar programa√ß√£o funcional com ASP MVC merece um estudo separado. </p><br><p>  Neste artigo, vou me limitar aos meandros do DSL Inclui, mostrarei novas funcionalidades e vazamentos de abstra√ß√µes para mostrar que o problema de an√°lise de "custos e aquisi√ß√µes" √© realmente esgot√°vel. </p><br><h2 id="esche-bolshe-dsl-includes">  Mais DSL Inclui </h2><br><pre> <code class="cs hljs">Include&lt;Point&gt; include = chain =&gt; chain.Include(e=&gt;eX).Include(e=&gt;eY);</code> </pre> <br><p>  Isso difere do EF Core Inclui fun√ß√µes est√°ticas que n√£o podem ser atribu√≠das a vari√°veis ‚Äã‚Äãe passadas como par√¢metros.  O DSL Include em si nasceu da necessidade de passar "include" para minha implementa√ß√£o do modelo de Reposit√≥rio sem degradar as informa√ß√µes de tipo que apareceriam quando fossem padronizadas em strings. </p><br><p>  A diferen√ßa mais dram√°tica ainda est√° no compromisso.  EF Core Inclui - inclus√£o de propriedades de navega√ß√£o (n√≥s das filiais), DSL Inclui - registro da travessia de uma √°rvore de c√°lculos, atribuindo um nome (caminho) ao resultado de cada c√°lculo. </p><br><p>  A representa√ß√£o interna do EF Core Include √© uma lista de seq√º√™ncias de caracteres recebidas pelo MemberExpression.Member (a express√£o especificada por <code>e=&gt;User.Name</code> pode ser apenas [MemberExpression] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://msdn.microsoft.com/en-us/library/system.linq.expressions. memberexpression (v = vs. 110) .aspx</a> e, nas visualiza√ß√µes internas, apenas a linha <code>Name</code> √© salva. </p><br><p>  No DSL Inclui, a representa√ß√£o interna s√£o as classes <a href="">ChainNode e ChainMemberNode</a> que <a href="">salvam a</a> express√£o <a href="">inteira</a> (por exemplo, <code>e=&gt;User.Name</code> ), que, como est√°, est√° embutida na √Årvore de Express√£o.  √â precisamente disso que o DSL Inclui suporta campos e tipos de valor do usu√°rio e chamadas de fun√ß√£o: </p><br><p>  Execu√ß√£o de fun√ß√µes: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .Include(i =&gt; i.Email.ToUpper(),<span class="hljs-string"><span class="hljs-string">"EAddress"</span></span>);</code> </pre> <br><p>  O que fazer com isso depende do int√©rprete.  CreateFormatter- retornar√° {"UserName": "John", "EAddress": "JOHN@MAIL.COM"} </p><br><p>  A execu√ß√£o tamb√©m pode ser √∫til para definir a travessia sobre estruturas anul√°veis. </p><br><pre> <code class="cs hljs">Include&lt;StrangePointF&gt; include = chain =&gt; chain .Include(e =&gt; e.NextPoint) <span class="hljs-comment"><span class="hljs-comment">// NextPoint is nullable struct .ThenIncluding(e =&gt; e.Value.X) .ThenInclude(e =&gt; e.Value.Y); // but not this way (abstraction leak) // Include&lt;StrangePointF&gt; include // = chain =&gt; chain // now this can throw an exception // .Include(e =&gt; e.NextPoint.Value) // .ThenIncluding(e =&gt; eX) // .ThenInclude(e =&gt; eY);</span></span></code> </pre> <br><p>  O DSL Inclui tamb√©m possui uma pequena entrada para a solu√ß√£o alternativa de v√°rios n√≠veis ThenIncluding. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) <span class="hljs-comment"><span class="hljs-comment">// ING-form - doesn't change current node .ThenIncluding(e =&gt; e.GroupName) // leaf .ThenIncluding(e =&gt; e.GroupDescription) // leaf .ThenInclude(e =&gt; e.AdGroup); // leaf</span></span></code> </pre> <br><p>  compare com </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupDescription) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.AdGroup);</code> </pre> <br><p>  E aqui tamb√©m h√° um vazamento de abstra√ß√£o.  Se eu escrevi a navega√ß√£o neste formul√°rio, eu deveria saber como funciona um int√©rprete que chamar√° QuaryableExtensions.  E ele traduz as chamadas para Include e ThenInclude para Include "string".  O que pode importar (voc√™ deve ter em mente). </p><br><p>  <strong>√Ålgebra inclui express√µes</strong> . </p><br><p>  As express√µes de inclus√£o podem ser: </p><br><div class="spoiler">  <b class="spoiler_title">Compare</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b1 = InlcudeExtensions.IsEqualTo(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b2 = InlcudeExtensions.IsSubTreeOf(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b3 = InlcudeExtensions.IsSuperTreeOf(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Clonar</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include2 = InlcudeExtensions.Clone(include1);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Mesclar</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include3 = InlcudeExtensions.Merge(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Converter em listas XPath - todos os caminhos para folhas</b> <div class="spoiler_text"><pre> <code class="cs hljs">IReadOnlyCollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; paths1 = InlcudeExtensions.ListLeafXPaths(include); <span class="hljs-comment"><span class="hljs-comment">// as xpaths IReadOnlyCollection&lt;string[]&gt; paths2 = InlcudeExtensions.ListLeafKeyPaths(include); // as string[]</span></span></code> </pre> </div></div><br><p>  etc. </p><br><p>  A boa not√≠cia √©: n√£o h√° vazamentos de abstra√ß√µes, o n√≠vel de pura abstra√ß√£o √© alcan√ßado aqui.  Existem metadados e funcionam com metadados. </p><br><h2 id="dialektika">  Dial√©tica </h2><br><p>  O DSL inclui permite alcan√ßar um novo n√≠vel de abstra√ß√£o, mas no momento da conquista, √© necess√°ria uma necessidade de ir para o pr√≥ximo n√≠vel: gerar as pr√≥prias express√µes de inclus√£o. </p><br><p>  Nesse caso, a gera√ß√£o de DSL como uma cadeia fluente n√£o √© necess√°ria, voc√™ s√≥ precisa criar estruturas de representa√ß√£o interna. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainNode(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainPropertyNode( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), expression: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point).CreatePropertyLambda(<span class="hljs-string"><span class="hljs-string">"X"</span></span>), memberName:<span class="hljs-string"><span class="hljs-string">"X"</span></span>, isEnumerable:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, parent:root ); root.Children.Add(<span class="hljs-string"><span class="hljs-string">"X"</span></span>, child); <span class="hljs-comment"><span class="hljs-comment">// or there is number of extension methods eg: var child = root.AddChild("X"); Include&lt;Point&gt; include = ChainNodeExtensions.ComposeInclude&lt;Point&gt;(root);</span></span></code> </pre> <br><p>  Voc√™ tamb√©m pode passar estruturas de apresenta√ß√£o para int√©rpretes.  Por que, ent√£o, o registro DSL fluente inclui?  Esta √© uma pergunta puramente especulativa, cuja resposta: porque na pr√°tica - desenvolver uma representa√ß√£o interna (e tamb√©m se desenvolve) √© obtida apenas com o desenvolvimento da DSL (isto √©, um pequeno registro expressivo conveniente para c√≥digo est√°tico).  Mais uma vez, isso ser√° dito mais perto da conclus√£o. </p><br><h2 id="copy-clone-equals">  Copiar, Clonar, Igual a </h2><br><p>  Todos os itens acima s√£o verdadeiros para os int√©rpretes de inclus√£o-express√£o que implementam <strong>copiar</strong> , <strong>clonar</strong> e <strong>iguais</strong> iteradores. </p><br><div class="spoiler">  <b class="spoiler_title">Igual a</b> <div class="spoiler_text"><p>  Compara√ß√£o apenas nas folhas da express√£o Incluir. <br>  Problema sem√¢ntico oculto: avalie ou n√£o a ordem na lista </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b1 = ObjectExtensions.Equals(user1, user2, include); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b2 = ObjectExtensions.EqualsAll(userList1, userList2, include);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Clonar</b> <div class="spoiler_text"><p>  Passe pelos n√≥s de express√£o.  As propriedades correspondentes √† regra s√£o copiadas. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUser = ObjectExtensions.Clone(user1, include, leafRule1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUserList = ObjectExtensions.CloneAll(userList1, leafRule1);</code> </pre> <br><p>  Pode haver um int√©rprete que selecionar√° a folha de inclus√µes.  Por que isso √© feito - atrav√©s de uma regra separada?  O que era semelhante √† sem√¢ntica de ObjectExtensions.Copy </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Copiar</b> <div class="spoiler_text"><p>  Passar por n√≥s - um ramo de express√£o e identifica√ß√£o por n√≥s de folha.  As propriedades correspondentes √† regra s√£o copiadas (semelhante ao Clone). </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.IncludeAll(e=&gt;e.Groups); ObjectExtensions.Copy(user1, user2, include, supportedLeafsRule); ObjectExtensions.CopyAll(userList1, userList2, include, supportedLeafsRule);</code> </pre> <br><p>  Pode haver um int√©rprete que selecionar√° a folha de inclus√µes.  Por que isso √© feito - atrav√©s de uma regra separada?      ObjectExtensions.Copy (   ‚Äî  include   ,  supportedLeafsRule ‚Äî   ). </p></div></div><br><p>  copy / clone   : </p><br><ol><li>   readonly ,     Tuple&lt;,&gt;  Anonymous Type.    ,     . </li><li>   (. IEnumerable   ) ‚Äî  public   . </li><li>  expression  include-,       ‚Äî  . </li><li> "  "    . </li></ol><br><p>  DSL                   , ..               . ,     <code>Tuple&lt;,&gt;</code> , ..  c readonly ,   <code>ValueTuple&lt;,&gt;</code> c writabale      (      ). </p><br><p>  ,         (    Expression Trees) Includes  ‚Äî  .     Include DSL  . </p><br><p>    Detach, FindDifferences  .. </p><br><h2 id="pochemu-run-time-a-ne-cs-sgenerirovannyy-do-nachala-kompilyacii">  run-time,   .cs    ? </h2><br><p>    .cs  ,   ,   <em>run-time</em>   : </p><br><ol><li>       ( ,  , source control). </li><li>     , ,  ,   ‚Äî     . </li><li>         . </li><li>   "  ".  dev time   ,     : ""      ""   ,  ""    , ,  ""   . </li></ol><br><p>   Roslyn',          .    Typescript  (  DTO  , ..   ) ‚Äî   DSL Includes  Roslyn' ( ) ‚Äî      typescript ( ).  " "    " "  .cs (   Expression Trees). </p><br><p> :   run time ‚Äî   ,  .             (        Expression Trees). </p><br><h2 id="problemy-s-effektivnostyu-skompilirovannyh-funkciy-expression-trees">      Expression Trees </h2><br><p>   Internal DSL   Expression Tree    : </p><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>LambdaExpression.Compile</code></a>    <em>Lambda</em> .     ,  .    ,   "" expression tree,   CallExpression    ‚Äî  LambdaExpression,   (.  LambdaExpression)    ConstantExpression.    ,  " /" ‚Äî      ,    Expression Trees. </p><br></li><li><p>       <em>ssmbly</em> ,     ( 10    )    ( assembly  ,    ‚Äî  ). , ,  ,      ‚Äî  . </p><br></li></ol><br><p>     ,        (  ),     ,       .    :       .   ‚Äî  ‚Äî   .cs     . </p><br><h2 id="benchmark-serializacii">   </h2><br><p>  ‚Äî     600   15   .  JSON.NET, ServiceStack    reflection' GetProperties(). </p><br><p> dslComposeFormatter ‚Äî ComposeFormatter   ,   <a href=""></a> . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BenchmarkDotNet</a> =v0.10.14, OS=Windows 10.0.17134 <br> Intel Core i5-2500K CPU 3.30GHz (Sandy Bridge), 1 CPU, 4 logical and 4 physical cores <br> .NET Core SDK=2.1.300 </p><br><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Min </th><th> Max </th><th> Median </th><th> Allocated </th></tr></thead><tbody><tr><td> dslComposeFormatter </td><td> 2.208 ms </td><td> 0.0093 ms </td><td> 0.0078 ms </td><td> 2.193 ms </td><td> 2.220 ms </td><td> 2.211 ms </td><td> 849.47 KB </td></tr><tr><td> JsonNet_Default </td><td> 2.902 ms </td><td> 0.0160 ms </td><td> 0.0150 ms </td><td> 2.883 ms </td><td> 2.934 ms </td><td> 2.899 ms </td><td> 658.63 KB </td></tr><tr><td> JsonNet_NullIgnore </td><td> 2.944 ms </td><td> 0.0089 ms </td><td> 0.0079 ms </td><td> 2.932 ms </td><td> 2.960 ms </td><td> 2.942 ms </td><td> 564.97 KB </td></tr><tr><td> JsonNet_DateFormatFF </td><td> 3.480 ms </td><td> 0.0121 ms </td><td> 0.0113 ms </td><td> 3.458 ms </td><td> 3.497 ms </td><td> 3.479 ms </td><td> 757.41 KB </td></tr><tr><td> JsonNet_DateFormatSS </td><td> 3.880 ms </td><td> 0.0139 ms </td><td> 0.0130 ms </td><td> 3.854 ms </td><td> 3.899 ms </td><td> 3.877 ms </td><td> 785.53 KB </td></tr><tr><td> ServiceStack_SerializeToString </td><td> 4.225 ms </td><td> 0.0120 ms </td><td> 0.0106 ms </td><td> 4.201 ms </td><td> 4.243 ms </td><td> 4.226 ms </td><td> 805.13 KB </td></tr><tr><td> fake_expressionManuallyConstruted </td><td> 54.396 ms </td><td> 0.1758 ms </td><td> 0.1644 ms </td><td> 54.104 ms </td><td> 54.629 ms </td><td> 54.383 ms </td><td> 7401.58 KB </td></tr></tbody></table><br><p> fake_expressionManuallyConstruted ‚Äî expression      ( ). </p><br><h2 id="formalizaciya">  </h2><br><p>   DSL   : <strong>   DSL      ;    Internal DSL   run-time</strong> . </p><br><p> Expression Tree         <em></em>   .NET Standard . </p><br><p>     Expression Trees  <em> </em>     Internal DSL    Fluent API.      #      . </p><br><p>         fluent   (   Expression Trees),      Internal DSL  #     fluent,      ""   Expression Trees. </p><br><p> <strong>Expression Trees</strong>  <strong>DSL Includes</strong>      (  ,      ),      /  run-time ‚Äî  (run-time ). </p><br><p>  <strong>Internal DSL</strong>       :   -  <strong>serialize</strong> , <strong>copy</strong> , <strong>clone</strong> , <strong>equals</strong>        <strong>       ""</strong> .   ,      " ",      .    :  includes    (   ) ,       (       ,  ). </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>   DSL Includes    DTO           ‚Äî   ( json).        ,    ,    ,   " ",        .   =   . </p><br><p>       Internal DSL       ,   DSL,      Internal DSL (    Expression)         (     Expression Tree). </p><br><p>  DSL Includes  json  ComposeFormatter    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DashboardCodes.Routines</a>   nuget  GitHub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419759/">https://habr.com/ru/post/pt419759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419735/index.html">Examinando o sinal I / Q com SDR usando o Adobe Audition</a></li>
<li><a href="../pt419743/index.html">O que h√° de errado com artigos populares dizendo que foo √© mais r√°pido que o bar?</a></li>
<li><a href="../pt419745/index.html">G√™nero cl√°ssico de IA: ML procura-se em poesia</a></li>
<li><a href="../pt419747/index.html">DJI Ronin S - Primeiro lan√ßamento e principais recursos</a></li>
<li><a href="../pt419757/index.html">Tradu√ß√£o do livro de Andrew Un, Passion for Machine Learning, Cap√≠tulos 1 - 14</a></li>
<li><a href="../pt419763/index.html">Exemplos de c√°lculo do "fator de disponibilidade" para conjuntos de equipamentos de rede</a></li>
<li><a href="../pt419765/index.html">O curso "Linguagens de programa√ß√£o da Web" (baseado em Ruby) do MSTU. N.E. Bauman no canal Technostream</a></li>
<li><a href="../pt419767/index.html">O criador da Wikipedia responde a perguntas: programa√ß√£o, sono, livros, dicas para a vida</a></li>
<li><a href="../pt419769/index.html">O WireGuard "chegar√°" ao kernel do Linux - por qu√™?</a></li>
<li><a href="../pt419771/index.html">Resumo da Fintech: o Banco Central acelera a coleta de biometria dos clientes, as criptomoedas est√£o caindo e o mercado para a Internet das coisas est√° crescendo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>