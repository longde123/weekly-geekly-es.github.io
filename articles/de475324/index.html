<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÖ üåá üêøÔ∏è Funktionale Programmierung aus Sicht von EcmaScript. Zusammensetzung, Currying, Teilanwendung üê∫ üî¶ üëÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 Heute setzen wir unsere Forschung zur funktionalen Programmierung im Kontext von EcmaScript fort, dessen Spezifikation auf JavaScript ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionale Programmierung aus Sicht von EcmaScript. Zusammensetzung, Currying, Teilanwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475324/"> Hallo habr <br><br>  Heute setzen wir unsere Forschung zur funktionalen Programmierung im Kontext von EcmaScript fort, dessen Spezifikation auf JavaScript basiert.  Im vorigen Artikel haben wir die Grundkonzepte untersucht: reine Funktionen, Lambdas, das Konzept der Immunit√§t.  Heute sprechen wir √ºber etwas komplexere FP-Techniken: Komposition, Curry und reine Funktionen.  Der Artikel ist im Stil einer "Pseudo-Codevorschau" geschrieben, d.h.  Wir werden ein praktisches Problem l√∂sen und gleichzeitig die Konzepte der Phasen√ºberg√§nge und des Refactor-Codes untersuchen, um diesen mit den Idealen der Phasen√ºberg√§nge in Einklang zu bringen. <br><br>  Also fangen wir an! <br><br>  Angenommen, wir haben eine Aufgabe: eine Reihe von Werkzeugen f√ºr die Arbeit mit Palindromen zu erstellen. <br><blockquote>  Palindrom <br>  M√§nnliches Geschlecht <br>  Ein Wort oder eine Phrase, die in gleicher Weise von links nach rechts und von rechts nach links gelesen wird. <br>  "P.  "Ich gehe mit dem Schwert des Richters" <br></blockquote>  Eine der m√∂glichen Implementierungen dieser Aufgabe k√∂nnte folgenderma√üen aussehen: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPalindrom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regexp = <span class="hljs-regexp"><span class="hljs-regexp">/[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g</span></span>; str = str.replace(regexp, <span class="hljs-string"><span class="hljs-string">''</span></span>).toLowerCase().split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -       ,       return str; } function isPalindrom (str) { const regexp = /[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g; str = str.replace(regexp, '').toLowerCase(); return str === str.split('').reverse().join(''); }</span></span></code> </pre> <a name="habracut"></a><br>  Nat√ºrlich funktioniert diese Implementierung.  Wir k√∂nnen davon ausgehen, dass getPalindrom korrekt funktioniert, wenn die API die richtigen Daten zur√ºckgibt.  Ein Aufruf von isPalindrom ("Ich gehe mit einem Schwertrichter") gibt "wahr" zur√ºck, und ein Aufruf von isPalindrom ("kein Palindrom") gibt "falsch" zur√ºck.  Ist diese Implementierung in Bezug auf Ideale der funktionalen Programmierung gut?  Auf keinen Fall gut! <br><br>  Gem√§√ü der Definition von Pure Functions aus diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> : <br><blockquote>  Reine Funktionen (PF) - geben immer ein vorhergesagtes Ergebnis zur√ºck. <br>  PF-Eigenschaften: <br><br>  Das Ergebnis der PF-Ausf√ºhrung h√§ngt nur von den √ºbergebenen Argumenten und dem Algorithmus ab, der PF implementiert <br>  Verwenden Sie keine globalen Werte <br>  √Ñndern Sie keine externen Werte oder √ºbergebenen Argumente <br>  Schreiben Sie keine Daten in Dateien, Datenbanken oder anderswo <br></blockquote>  Und was sehen wir in unserem Beispiel mit Palindromen? <br><br>  Erstens gibt es eine Vervielf√§ltigung von Code, d.h.  das Prinzip von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRY wird</a> verletzt.  Zweitens greift die Funktion getPalindrom auf die Datenbank zu.  Drittens √§ndern Funktionen ihre Argumente.  Insgesamt sind unsere Funktionen nicht sauber. <br><br>  Erinnern Sie sich an die Definition: Funktionale Programmierung ist eine M√∂glichkeit, Code durch Kompilieren einer Reihe von Funktionen zu schreiben. <br><br>  Wir stellen eine Reihe von Funktionen f√ºr diese Aufgabe zusammen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">;//(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);<span class="hljs-comment"><span class="hljs-comment">//(2) const toLowerCase = str =&gt; str.toLowerCase();//(3) const stringReverse = str =&gt; str.split('').reverse().join('');//(4) const isStringsEqual = (strA, strB) =&gt; strA === strB;//(5)</span></span></code> </pre><br>  In Zeile 1 haben wir die Konstante des regul√§ren Ausdrucks in funktionaler Form deklariert.  Diese Methode zur Beschreibung von Konstanten wird h√§ufig in FP verwendet.  In Zeile 2 haben wir die String.prototype.replace-Methode in eine funktionale Ersetzungsabstraktion gekapselt, sodass sie (der Ersetzungsaufruf) dem Vertrag f√ºr die funktionale Programmierung entspricht.  In Zeile 3 wurde auf die gleiche Weise eine Abstraktion f√ºr String.prototype.toLowerCase erstellt.  In der vierten implementierten sie eine Funktion, die aus der √ºbergebenen eine neue erweiterte Zeichenfolge erstellt.  5. √úberpr√ºft die Stringgleichheit. <br><br>  Bitte beachten Sie, dass unsere Funktionen √§u√üerst sauber sind!  Wir haben in einem fr√ºheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber die Vorteile reiner Funktionen gesprochen. <br><br>  Jetzt m√ºssen wir √ºberpr√ºfen, ob es sich bei der Zeichenfolge um ein Palindrom handelt.  Eine Zusammenstellung von Funktionen wird uns dabei helfen. <br><br>  <b>Die Zusammensetzung von Funktionen</b> ist die Vereinigung von zwei oder mehr Funktionen zu einer bestimmten resultierenden Funktion, die das Verhalten derjenigen implementiert, die in der gew√ºnschten algorithmischen Sequenz kombiniert sind. <br><br>  Die Definition mag kompliziert erscheinen, ist aber aus praktischer Sicht fair. <br><br>  Wir k√∂nnen das machen: <br><br><pre> <code class="javascript hljs">isStringsEqual(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)), stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))));</code> </pre><br>  oder so: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strA = toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strB = stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isStringsEqual(strA, strB));</code> </pre><br>  oder geben Sie f√ºr jeden Schritt des implementierten Algorithmus eine weitere Gruppe erkl√§render Variablen ein.  Ein solcher Code ist h√§ufig in Projekten zu sehen, und dies ist ein typisches Beispiel f√ºr die Komposition: Sie √ºbergeben einen Aufruf an eine Funktion als Argument an eine andere.  Trotzdem ist dieser Ansatz, wie wir sehen, in einer Situation, in der es viele Funktionen gibt, schlecht, weil  Dieser Code ist nicht lesbar!  Also was jetzt?  Sind wir nicht einverstanden mit der funktionalen Programmierung? <br><br>  Tats√§chlich m√ºssen wir, wie es normalerweise bei der funktionalen Programmierung der Fall ist, nur eine weitere Funktion schreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x);</code> </pre><br>  Die Funktion compose verwendet eine Liste ausf√ºhrbarer Funktionen als Argumente, wandelt sie in ein Array um, speichert sie in einem Closure und gibt eine Funktion zur√ºck, die einen Anfangswert erwartet.  Nachdem der Anfangswert √ºbergeben wurde, beginnt die sequentielle Ausf√ºhrung aller Funktionen aus dem fns-Array.  Das Argument der ersten Funktion ist der √ºbergebene Anfangswert x, und die Argumente aller nachfolgenden Funktionen sind das Ergebnis der vorherigen.  So k√∂nnen wir Kompositionen mit beliebig vielen Funktionen erstellen. <br><br>  Beim Erstellen funktionaler Kompositionen ist es sehr wichtig, die Typen der Eingabeparameter und die R√ºckgabewerte der einzelnen Funktionen zu √ºberwachen, damit keine unerwarteten Fehler auftreten  Wir √ºbergeben das Ergebnis der vorherigen Funktion an die n√§chste. <br><br>  Bereits jetzt sehen wir jedoch Probleme bei der Anwendung der Kompositionstechnik auf unseren Code, da die Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replace = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);</code> </pre><br>  Erwartet, dass 3 Eingabeparameter akzeptiert werden, und wir senden nur einen zum Komponieren.  Eine andere FP-Technik, Currying, wird uns helfen, dieses Problem zu l√∂sen. <br><br>  <b>Currying</b> ist die Umwandlung einer Funktion aus vielen Argumenten in eine Funktion aus einem Argument. <br><br>  Erinnern Sie sich an unsere Add-Funktion aus dem ersten Artikel? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">) =&gt;</span></span> x+y;</code> </pre><br>  Es kann so gewechselt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; x+y;</code> </pre><br>  Die Funktion nimmt x und gibt ein Lambda zur√ºck, das y erwartet und die Aktion ausf√ºhrt. <br><br>  Curry Vorteile: <br><br><ul><li>  der Code sieht besser aus; </li><li>  Curry-Funktionen sind immer sauber. </li></ul><br>  Jetzt transformieren wir unsere Ersetzungsfunktion so, dass sie nur ein Argument akzeptiert.  Da wir die Funktion ben√∂tigen, um Zeichen in der Zeichenfolge durch einen zuvor bekannten regul√§ren Ausdruck zu ersetzen, k√∂nnen wir eine teilweise angewendete Funktion erstellen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str);</code> </pre><br>  Wie Sie sehen, korrigieren wir eines der Argumente mit einer Konstante.  Dies liegt daran, dass das Currying tats√§chlich ein Sonderfall der Teilnutzung ist. <br><br>  <b>Eine Teilanwendung</b> umschlie√üt eine Funktion mit einem Wrapper, der weniger Argumente akzeptiert als die Funktion selbst. Der Wrapper sollte eine Funktion zur√ºckgeben, die den Rest der Argumente √ºbernimmt. <br><br>  In unserem Fall haben wir die Funktion replaceAllNotWordSymbolsGlobal erstellt, bei der es sich um eine teilweise angewendete Ersetzungsoption handelt.  Es akzeptiert das Ersetzen, speichert es in einem Closure und erwartet eine Eingabezeile, f√ºr die es das Ersetzen aufruft, und wir rechnen mit einer Konstanten. <br><br>  Zur√ºck zu den Palindromen.  Erstellen Sie eine Zusammenstellung von Funktionen f√ºr das Palindrome-Timing: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse );</code> </pre><br>  und die Zusammensetzung der Funktionen f√ºr die Linie, mit der wir das potentielle Palindrom vergleichen wollen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, );</code> </pre><br>  Denken Sie jetzt daran, was wir oben gesagt haben: <br><blockquote>  Ein typisches Kompositionsbeispiel ist die √úbergabe eines Aufrufs an eine Funktion als Argument an eine andere </blockquote>  und schreibe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>;<span class="hljs-comment"><span class="hljs-comment">//          , .. ,    ,  ,   -   ,    const isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br>  Hier haben wir eine funktionierende und gut aussehende L√∂sung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toLowerCase = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stringReverse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringsEqual = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strA, strB</span></span></span><span class="hljs-function">) =&gt;</span></span> strA === strB; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</code> </pre><br>  Wir m√∂chten jedoch nicht jedes Mal ein Currying durchf√ºhren oder teilweise angewandte Funktionen mit unseren H√§nden erstellen.  Nat√ºrlich wollen wir nicht, Programmierer sind faule Leute.  Aus diesem Grund werden wir, wie in FP √ºblich, ein paar weitere Funktionen schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> curry = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fn.length &gt; args.length) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = fn.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, ...args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curry(f); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args) } }</code> </pre><br>  Die Curry-Funktion √ºbernimmt eine Curry-Funktion, speichert sie in einem Verschluss und gibt ein Lambda zur√ºck.  Das Lambda erwartet den Rest der Argumente f√ºr die Funktion.  Jedes Mal, wenn ein Argument empfangen wird, wird √ºberpr√ºft, ob alle deklarierten Argumente akzeptiert werden.  Wenn akzeptiert, wird die Funktion aufgerufen und ihr Ergebnis zur√ºckgegeben.  Wenn nicht, wird die Funktion erneut ausgef√ºhrt. <br><br>  Wir k√∂nnen auch eine teilweise angewendete Funktion erstellen, um den ben√∂tigten regul√§ren Ausdruck durch eine leere Zeichenfolge zu ersetzen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = curry(replace)(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br>  Alles scheint in Ordnung zu sein, aber wir sind Perfektionisten und wir m√∂gen nicht zu viele Klammern, wir m√∂chten noch besser, also schreiben wir eine andere Funktion oder vielleicht zwei: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, x</span></span></span><span class="hljs-function">) =&gt;</span></span> (...args) =&gt; fn(x, ...args);</code> </pre><br>  Dies ist eine Abstraktionsimplementierung zum Erstellen von teilweise angewendeten Funktionen.  Es nimmt eine Funktion und das erste Argument, gibt ein Lambda zur√ºck, das den Rest erwartet und die Funktion ausf√ºhrt. <br><br>  Jetzt schreiben wir party neu, damit wir eine teilweise angewendete Funktion mehrerer Argumente erstellen k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, ...args</span></span></span><span class="hljs-function">) =&gt;</span></span> (...rest) =&gt; fn(...args.concat(rest));</code> </pre><br>  Es ist erw√§hnenswert, dass auf diese Weise ausgef√ºhrte Funktionen mit einer beliebigen Anzahl von Argumenten aufgerufen werden k√∂nnen, die kleiner als deklariert sind (fn.length). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b,c,d</span></span></span><span class="hljs-function">) =&gt;</span></span> a+b+c+d; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = curry(sum); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r1 = fn(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>);<span class="hljs-comment"><span class="hljs-comment">//,   const r2 = fn(1, 2, 3)(4);//       const r3 = fn(1, 2)(3)(4); const r4 = fn(1)(2)(3)(4); const r5 = fn(1)(2, 3, 4); const r6 = fn(1)(2)(3, 4); const r7 = fn(1, 2)(3, 4);</span></span></code> </pre><br>  Kommen wir zur√ºck zu unseren Palindromen.  Wir k√∂nnen unser replaceAllNotWordSymbolsToEmpltyGlobal ohne zus√§tzliche Klammern umschreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br>  Schauen wir uns den gesamten Code an: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    -       const allNotWordSymbolsRegexpGlobal = () =&gt; /[\.,\/#!$%\^&amp;\*;:{}=\-_~()?\s]/g; const replace = (regexp, replacement, str) =&gt; str.replace(regexp, replacement); const toLowerCase = str =&gt; str.toLowerCase(); const stringReverse = str =&gt; str.split('').reverse().join(''); const isStringsEqual = (strA, strB) =&gt; strA === strB; //       const testString = '    '; //           -    rambda.js const compose = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x); const curry = fn =&gt; (...args) =&gt; { if (fn.length &gt; args.length) { const f = fn.bind(null, ...args); return curry(f); } else { return fn(...args) } } const party = (fn, ...args) =&gt; (...rest) =&gt; fn(...args.concat(rest)); //       const replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), ''); const processFormPalindrom = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, stringReverse ); const processFormTestString = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, ); const checkPalindrom = testString =&gt; isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br>  Es sieht gut aus, aber was ist, wenn es f√ºr uns kein String ist, sondern ein Array kommt?  Deshalb f√ºgen wir eine weitere Funktion hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; args.map(fn);</code> </pre><br>  Wenn wir nun ein Array zum Testen auf Palindrome haben, dann: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palindroms = [<span class="hljs-string"><span class="hljs-string">'    '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>. <span class="hljs-string"><span class="hljs-string">' '</span></span>] map(checkPalindrom )(...palindroms ); <span class="hljs-comment"><span class="hljs-comment">// [true, true, true, false]  </span></span></code> </pre><br>  So haben wir die Aufgabe gel√∂st, indem wir Feature-Sets geschrieben haben.  Achten Sie auf die sinnlose Art, Code zu schreiben - dies ist ein Lackmustest der funktionalen Reinheit. <br><br>  Jetzt etwas mehr Theorie.  Vergessen Sie nicht, dass Sie jedes Mal, wenn Sie eine Funktion aufrufen, eine neue erstellen, d. H.  W√§hlen Sie eine Speicherzelle daf√ºr.  Es ist wichtig, dies zu √ºberwachen, um Undichtigkeiten zu vermeiden. <br><br>  Funktionsbibliotheken wie ramda.js haben Compose- und Pipe-Funktionen.  compose implementiert den Kompositionsalgorithmus von rechts nach links und die Pipe von links nach rechts.  Unsere Compose-Funktion ist eine Analogie zur Pipe von Ramda.  In der Bibliothek gibt es seitdem zwei verschiedene Kompositionsfunktionen  Komposition von rechts nach links und von links nach rechts sind zwei verschiedene Vertr√§ge der funktionalen Programmierung.  Wenn einer der Leser einen Artikel findet, der alle bestehenden Vertr√§ge der FP beschreibt, dann teile ihn in den Kommentaren mit, ich werde ihn gerne lesen und dem Kommentar ein Plus hinzuf√ºgen! <br><br>  Die Anzahl der formalen Parameter einer Funktion wird als <b>Arit√§t bezeichnet</b> .  Dies ist auch eine wichtige Definition aus Sicht der Theorie der Phasen√ºberg√§nge. <br><br><h2>  Fazit </h2><br>  Im Rahmen dieses Artikels haben wir funktionale Programmiertechniken wie Komposition, Currying und Teilanwendung untersucht.  Nat√ºrlich werden Sie in realen Projekten mit diesen Tools vorgefertigte Bibliotheken verwenden, aber als Teil des Artikels habe ich alles auf native JS implementiert, damit Leser mit vielleicht nicht sehr viel Erfahrung im FP verstehen k√∂nnen, wie diese Techniken unter der Haube funktionieren. <br><br>  Ich habe mich auch bewusst f√ºr die Methode der Narration entschieden - die Pseudo-Codevorschau, um meine Logik zu veranschaulichen, funktionale Reinheit im Code zu erreichen. <br><br>  √úbrigens k√∂nnen Sie die Entwicklung dieses Moduls zur Arbeit mit Palindromen fortsetzen und seine Ideen weiterentwickeln, z. B. Linien per API herunterladen, in Buchstabens√§tze konvertieren und an den Server senden, auf dem die Linie vom Palindrom generiert wird, und vieles mehr ... Nach Ihrem Ermessen. <br><br>  Es w√§re auch sch√∂n, die Duplizierung in den Prozessen dieser Zeilen loszuwerden: <br><br><pre> <code class="javascript hljs"> replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase,</code> </pre><br>  Generell ist es m√∂glich und notwendig, den Code st√§ndig zu verbessern! <br><br>  Bis zu zuk√ºnftigen Artikeln. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475324/">https://habr.com/ru/post/de475324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475306/index.html">Der Anzug: Geschichte und Perspektiven</a></li>
<li><a href="../de475308/index.html">Wie man sich als guter Programmierer ausgibt</a></li>
<li><a href="../de475314/index.html">√ñko-Fantasie zum Schutz des Planeten</a></li>
<li><a href="../de475320/index.html">Microsoft-Empfehlungen zum Deaktivieren des Kennwortablaufs: Konsequenzen und Schlussfolgerungen</a></li>
<li><a href="../de475322/index.html">Bone Sound der n√§chsten Stufe - Aftershokz Aeropex Review</a></li>
<li><a href="../de475328/index.html">Operation TA505, vierter Teil. Zwillinge</a></li>
<li><a href="../de475330/index.html">Miro Platform Plugin-Wettbewerb mit einem Preispool von 21.000 US-Dollar</a></li>
<li><a href="../de475332/index.html">3. Enterprise Network Design auf Extreme Switches</a></li>
<li><a href="../de475336/index.html">So beenden Sie richtig (Anleitung)</a></li>
<li><a href="../de475340/index.html">AMD stellte Threadripper-Prozessoren vor - die schnellsten Desktop-CPUs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>