<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏾 💪🏽 👨🏿‍🎨 Comment les graphiques NES ont-ils été organisés? 🙍🏻 ⛵️ 🏇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lancée en 1983, la console de salon Nintendo Entertainment System (NES) était une machine bon marché mais puissante qui a connu un succès phénoménal. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment les graphiques NES ont-ils été organisés?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="image"></div><br>  Lancée en 1983, la console de salon Nintendo Entertainment System (NES) était une machine bon marché mais puissante qui a connu un succès phénoménal.  À l'aide de l'unité de traitement d'image (PPU), le système pourrait créer des graphiques assez impressionnants pour l'époque, ce qui semble encore assez bon dans le bon contexte.  L'aspect le plus important était l'efficacité de la mémoire - lors de la création de graphiques, nous devions gérer avec le moins d'octets possible.  Cependant, NES a fourni aux développeurs des fonctionnalités puissantes et faciles à utiliser qui lui ont permis de se démarquer des anciennes consoles de salon.  Après avoir compris les principes de création de graphiques NES, vous pouvez sentir la perfection technique du système et réaliser à quel point il est plus facile pour les développeurs de jeux modernes de travailler. <br><br>  Les graphiques d'arrière-plan NES ont été assemblés à partir de quatre composants distincts, dont la combinaison a formé l'image que nous voyons à l'écran.  Chaque composante était responsable d'un aspect distinct;  couleur, disposition, graphiques en pixels bruts, etc.  Un tel système peut sembler inutilement compliqué et encombrant, mais il a finalement utilisé la mémoire beaucoup plus efficacement et a permis de créer des effets simples dans une petite quantité de code.  Si vous voulez comprendre les graphiques NES, ces quatre composants seront des informations clés. <br><br>  Cet article suppose que vous êtes familier avec les mathématiques informatiques, et en particulier avec le fait que 8 bits = 1 octet et 8 bits peuvent représenter 256 valeurs.  Une compréhension du fonctionnement de la notation hexadécimale est également nécessaire.  Mais même sans cette connaissance technique, l'article peut sembler intéressant. <br><a name="habracut"></a><br><h1>  Brève revue </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/6f8/9a7/ca16f89a75e658d68c28f81e9794ff86.png" width="512" height="480"></div><br>  Ci-dessus est une image de la première scène de Castlevania (1986): la porte menant au château, où le jeu aura lieu.  Cette image mesure 256 × 240 pixels et utilise 10 couleurs différentes.  Pour décrire cette image en mémoire, nous devons tirer parti de la palette de couleurs limitée et économiser de l'espace en ne stockant qu'une quantité minimale d'informations.  L'une des approches naïves consiste à utiliser une palette indexée dans laquelle chaque pixel a un volume de 4 bits, c'est-à-dire que 2 pixels sont placés dans un octet.  Cela nécessitera 256 * 240/2 = 30720 octets, mais comme nous le verrons bientôt, NES peut faire face à cette tâche beaucoup plus efficacement. <br><br>  Les principaux concepts du thème graphique NES sont les tuiles et les blocs [1].  Une tuile est une zone de 8 × 8 pixels, et un bloc est une zone de 16 × 16 pixels, et chacun d'eux est lié à une grille avec la même taille de cellule.  Après avoir ajouté ces grilles, nous pouvons voir la structure des graphiques.  Voici l'entrée du château avec une grille à double grossissement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uz/de/sk/uzdeskry1wkruscxe8xsyephbnc.png"></div><br>  Dans cette grille, les blocs sont affichés en vert clair et les tuiles en vert foncé.  Les règles le long des axes ont des valeurs hexadécimales qui peuvent être ajoutées pour trouver une position;  par exemple, le cœur dans la barre d'état est à 15 $ + 60 $ = 75 $, ce qui en décimal est 117. Chaque écran contient 16 × 15 blocs (240) et 32 ​​× 30 tuiles (960).  Voyons maintenant comment cette image est décrite et commençons par les graphiques en pixels bruts. <br><br><h1>  CHR </h1><br>  La structure CHR décrit des graphiques de pixels «bruts» sans sa couleur et sa position, et est définie en mosaïques.  La page de mémoire entière contient 256 tuiles CHR, et chaque tuile a une profondeur de 2 bits.  Voici les graphiques du cœur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/d14/fb3/ad9d14fb3cc4321c5ae65e1e7f61dd52.png" width="128" height="128"></div><br>  Et voici comment cela est décrit dans CHR [2]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/162/974/e0f/162974e0fe800447c8edecf9157d1763.png" alt="pixel-heart-chr" width="128" height="128"></div><br>  Une telle description prend 2 bits par pixel, c'est-à-dire qu'avec une taille de 8 × 8, il s'avère que 8 * 8 * 2 = 128 bits = 16 octets.  Ensuite, la page entière prend 16 * 256 = 4096 octets.  Voici tous les CHR utilisés dans l'image de Castlevania. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/3ef/83d/5da3ef83d0e339ca2d91d799745157e9.png" width="271" height="101"></div><br>  Rappelons que le remplissage d'une image nécessite 960 tuiles, mais CHR n'en autorise que 256. Cela signifie que la plupart des tuiles sont répétées, en moyenne, 3,75 fois, mais le plus souvent seulement un petit nombre d'entre elles sont utilisées (par exemple, fond vide, tuiles monochromes). ou répétition de motifs).  L'image de Castlevania utilise de nombreuses tuiles vides, ainsi que du bleu uni.  Pour voir comment les tuiles sont attribuées, nous utilisons des tables de noms. <br><br><h1>  NAMETABLE </h1><br>  La table de noms attribue un fichier CHR à chaque position sur l'écran, et il y en a 960 au total. Chaque position est spécifiée dans un octet, c'est-à-dire que la table de noms entière prend jusqu'à 960 octets.  Les tuiles sont attribuées dans l'ordre de gauche à droite, de haut en bas et correspondent à la position calculée trouvée en ajoutant les valeurs des règles indiquées ci-dessus.  Autrement dit, la position dans le coin supérieur gauche est de 0 $, à droite de 1 $ et en dessous de 20 $. <br><br>  Les valeurs de la table de noms dépendent de l'ordre dans lequel le CHR est rempli.  Voici l'une des options [3]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h_/vs/qc/h_vsqc5mxdu8ydb1o8cu4mflf9e.png"></div><br>  <i>Dans ce cas, le cœur (à la position 75 $) a une valeur de 13 $.</i> <br><br>  Ensuite, pour ajouter de la couleur, nous devons sélectionner une palette. <br><br><h1>  Palette </h1><br>  NES possède une palette système de 64 couleurs [4], et nous en sélectionnons les palettes qui seront utilisées dans le rendu.  Chaque palette contient 3 couleurs uniques plus la couleur de fond globale.  L'image a un maximum de 4 palettes, qui occupent au total 16 octets.  Voici les palettes de l'image de Castlevania: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f03/59a/259/f0359a259c032b5f6c9048c0231ffb85.png" alt="castlevania-pal" width="168" height="24"></div><br>  Les palettes ne peuvent pas être utilisées arbitrairement.  Une seule palette est appliquée par bloc.  C'est à cause de ce besoin de séparer chaque zone 16 × 16 selon la palette de couleurs du jeu pour que NES ait un tel aspect «bloc».  Les graphiques exécutés de manière magistrale, par exemple à partir de l'écran de démarrage Castlevania, peuvent être évités en mélangeant les couleurs sur les bords des blocs, ce qui masque la présence d'une grille. <br><br>  La sélection d'une palette pour chaque bloc est effectuée en utilisant les derniers composants - attributs. <br><br><h1>  Attributs </h1><br>  Les attributs occupent 2 bits par bloc.  Ils déterminent laquelle des 4 palettes utiliser.  Cette image montre quelles palettes définies par les attributs utilisent différents blocs [5]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/kj/3i/k4kj3imqlxxbwnasjcz3t60abym.png"></div><br>  Comme vous pouvez le voir, les palettes sont divisées en sections, mais cela est délicat en raison de l'utilisation des mêmes couleurs dans différentes zones.  Le rouge au milieu de la porte se confond avec les murs qui l'entourent et un fond noir brouille la ligne entre le château <br>  et portes. <br><br>  Avec 2 bits par bloc ou 4 blocs par octet, les attributs d'image n'occupent que 240/4 = 60 octets, mais en raison de la façon dont ils sont codés, 4 autres octets sont perdus, c'est-à-dire que 64 octets au total sont obtenus.  Cela signifie que l'image entière, y compris CHR, table de noms, palettes et attributs, prend 4096 + 960 + 16 + 64 = 5136 octets - bien mieux que le 30720 mentionné ci-dessus. <br><br><h1>  MAKECHR </h1><br>  La création de ces quatre composants pour les graphiques NES est plus difficile que l'utilisation des API bitmap standard, mais les outils viennent à la rescousse.  Les développeurs NES avaient probablement une sorte de chaîne d'outils, mais quoi que ce soit, l'histoire ne l'a pas enregistrée.  Aujourd'hui, les développeurs écrivent généralement des programmes pour convertir des graphiques au format NES souhaité. <br><br>  Toutes les images de ce post ont été créées à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">makechr</a> , un outil réécrit utilisé par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Star Versus</a> .  Il s'agit d'un outil en ligne de commande conçu pour les versions automatisées et destiné à la vitesse, la qualité des messages d'erreur, la portabilité et l'intelligibilité.  Il crée également des visualisations intéressantes comme celles utilisées dans le post. <br><br><h1>  Les références </h1><br>  Surtout des connaissances sur la programmation pour NES, et en particulier sur la création de graphiques, j'ai obtenu des sources suivantes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nintendo Age Nerdy Nights</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wiki de NesDev</a> </li></ul><br><h1>  Remarques </h1><br>  [1] Terminologie - dans certains documents, les blocs sont appelés «méta-tuiles», ce qui me semble personnellement moins utile. <br><br>  [2] Codage CHR - 2 bits par pixel ne sont pas stockés côte à côte.  L'image complète est d'abord enregistrée uniquement avec les bits faibles, puis à nouveau enregistrée uniquement avec les bits élevés. <br><br>  Autrement dit, le cœur sera stocké comme ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc5/68c/f95/cc568cf959b148d1d11a408876806ae8.png" alt="pixel-coeur-bas" width="128" height="128"><img src="https://habrastorage.org/getpro/habr/post_images/f87/947/070/f879470703605322e98a2582241b071e.png" alt="pixel-coeur-haut" width="128" height="128"><br><br>  Chaque ligne est un octet.  Autrement dit, 01100110 est de 66 $, 01111111 est de 7 $.  Au total, les octets du cœur ressemblent à ceci: <br><br>  $ 66 $ 7f $ ff $ ff $ ff $ 7e $ 3c $ 18 $ 66 $ 5f $ bf $ bf $ ff $ 7e $ 3c $ 18 $ <br><br>  [3] Table de noms - dans ce tableau en jeu, la table des noms est utilisée différemment.  En règle générale, les lettres de l'alphabet sont conservées en mémoire dans le quartier, y compris Castlevania. <br><br>  [4] Palette système - NES n'utilise pas de palette RVB et les couleurs réelles qu'elle rend dépendent du téléviseur particulier.  Les émulateurs utilisent généralement des palettes RVB complètement différentes.  Les couleurs de cet article correspondent à la palette énoncée dans makechr. <br><br>  [5] Encodage des attributs - Les attributs sont stockés dans un ordre étrange.  Ils ne vont pas de gauche à droite, de haut en bas - la zone de bloc 2 × 2 est codée avec un octet, sous la forme de la lettre Z. C'est pourquoi 4 octets sont gaspillés;  la ligne de fond est un plein 8 octets. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/951/0db/71a9510db28128bca1841689ce909c27.png" alt="pal-block-group" width="64" height="64"></div><br>  Par exemple, un bloc de 308 $ est stocké avec 30 $, 348 $ et 34 $.  Leurs valeurs de palette sont 1, 2, 3 et 3 et sont stockées dans l'ordre de la position la plus basse à la position la plus élevée, ou 11 :: 11 :: 10 :: 01 = 11111001. Par conséquent, la valeur en octets de ces attributs est $ f9. <br><br><h2>  2e partie </h2><br>  Dans la première partie, nous avons parlé des composants des graphiques d'arrière-plan NES - CHR, table de noms, palettes et attributs.  Mais ce n'est que la moitié de l'histoire. <br><br>  Pour commencer, il existe en fait deux tables de noms [6].  Chacun d'eux a ses propres attributs pour définir la couleur, mais ils ont le même CHR.  L'équipement des cartouches détermine leur position: soit côte à côte, soit l'une au-dessus de l'autre.  Voici des exemples de deux types d'emplacements différents: Lode Runner (1984) et Bubble Bobble (1988). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/7ef/7c9/7597ef7c97f3e31ed3bb4198727dee37.png" width="512" height="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/035/72a/0e703572ad771478c13bffa254a86579.png" alt="bulle-bobble-scrolling" width="532" height="480"></div><br><h1>  Défilement </h1><br>  Pour profiter de la présence de deux tables de noms, PPU prend en charge la possibilité de faire défiler les pixels à la fois le long des axes X et Y. Il est contrôlé par un registre avec affichage en mémoire à 2005 $: l'écriture de seulement deux octets à cette adresse déplace tout l'écran au nombre de pixels souhaité [7] .  Au moment de la sortie de NES, c'était le principal avantage par rapport aux autres consoles de salon, dans lesquelles pour le défilement, il fallait souvent réécrire toute la mémoire vidéo.  Un tel système facile à utiliser a conduit à l'émergence d'un grand nombre de plateformes et de tireurs, et est devenu la principale raison d'un tel succès du système. <br><br>  Pour un jeu simple, dont le champ ne fait que deux écrans de large, par exemple, Load Runner, il suffisait juste de remplir les deux tableaux de noms et de modifier le défilement en conséquence.  Mais dans la plupart des jeux à défilement, les niveaux avaient une largeur arbitraire.  Pour les implémenter, le jeu doit mettre à jour la partie hors écran des tables de noms avant qu'elles n'apparaissent à l'écran.  La valeur de défilement est bouclée, mais comme la table des noms est constamment mise à jour, cela crée l'illusion d'une taille infinie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/936/ab4/829936ab4b2855cd7f824ebd01941bb3.gif" width="512" height="500"></div><br><h1>  Sprites </h1><br>  En plus de faire défiler les tableaux de noms, NES avait également un aspect complètement différent des graphiques: les sprites.  Contrairement aux tables de noms qui doivent être alignées dans des grilles, les sprites peuvent être positionnés arbitrairement, de sorte qu'ils peuvent être utilisés pour afficher les personnages des joueurs, les obstacles, les projectiles et tous les objets avec des mouvements complexes.  Par exemple, dans la scène ci-dessus de Mega Man (1987) pour afficher le personnage d'un joueur.  les points et les bandes d'énergie sont des sprites utilisés, ce qui leur permet de sortir de la grille des tables de noms lors du défilement de l'écran. <br><br>  Les sprites ont leur propre page CHR [8] et un ensemble de 4 palettes.  De plus, ils occupent une page de mémoire de 256 octets.  qui répertorie la position et l'apparence de chaque image-objet (il s'avère que la mémoire vidéo NES est deux fois et demie plus grande que celle mentionnée dans la première partie de l'article).  Le format de ces enregistrements est assez inhabituel - ils contiennent d'abord une position en Y, puis un numéro de tuile, puis un attribut, puis une position en X [9].  Étant donné que chaque enregistrement prend 4 octets, il existe une restriction stricte: à l'écran, il ne peut pas y avoir plus de 256/4 = 64 sprites à la fois. <br><br>  Les octets Y et X spécifient le pixel supérieur gauche du sprite dessiné.  Par conséquent, sur le côté droit de l'écran, le sprite peut être rogné, mais sur le côté gauche, il laisse un espace vide.  L'octet de la tuile est similaire à la valeur dans la table des noms, seulement pour ces tuiles les sprites utilisent leur propre CHR.  Un octet d'attribut est un paquet de bits qui effectue trois tâches: deux bits sont alloués à la palette, deux bits sont utilisés pour refléter le sprite horizontalement ou verticalement, et un bit détermine s'il faut rendre le sprite sous les tables de noms [10]. <br><br><h1>  Limitations </h1><br>  Les systèmes modernes permettent de travailler avec des sprites de n'importe quelle taille arbitraire, mais sur NES, le sprite dû aux limitations CHR devait avoir une taille de 8 × 8 [11].  Les objets plus grands sont constitués de plusieurs sprites, et le programme doit s'assurer que toutes les parties individuelles sont rendues côte à côte.  Par exemple, une taille de personnage Megaman peut atteindre 10 sprites, ce qui vous permet également d'utiliser plus de couleurs, en particulier pour ses yeux blancs et son teint. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/fea/3dc/dd8fea3dc4880761b52885c8ff83acdd.png"></div><br>  La principale limitation associée à l'utilisation de sprites est qu'il ne doit pas y avoir plus de 8 sprites par ligne raster.  Si plus de 8 sprites apparaissent sur une ligne horizontale de l'écran, ceux qui sont apparus plus tard ne seront tout simplement pas rendus.  C'est la raison du scintillement dans les jeux avec beaucoup de sprites;  le programme échange les adresses des sprites en mémoire afin que chacun d'eux soit rendu au moins occasionnellement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/b67/13c/5f0b6713c1be1837d0da2d8213253932.gif" alt="mégaman-scintillement" width="332" height="128"></div><br>  Enfin, le défilement n'affecte pas les sprites: la position du sprite sur l'écran est déterminée par ses valeurs Y et X, quelle que soit la position du défilement.  Parfois, c'est un plus, par exemple, lorsque le niveau se déplace par rapport au joueur ou que l'interface reste dans une position fixe.  Cependant, dans d'autres cas, c'est un inconvénient - vous devez déplacer l'objet en mouvement, puis changer sa position en fonction de la quantité de changement dans le défilement. <br><br><h1>  Remarques </h1><br>  [6] En théorie, il y a en fait quatre tables de noms, mais elles sont reflétées de telle manière que seulement 2 d'entre elles contiennent des graphiques uniques.  Lorsqu'ils sont placés côte à côte, cela s'appelle la mise en miroir verticale, et lorsque les tables de noms sont situées l'une au-dessus de l'autre, la mise en miroir horizontale. <br><br>  [7] Il existe également un registre qui sélectionne la table de noms avec laquelle commencer le rendu, c'est-à-dire que le défilement est en fait une valeur de 10 bits, ou 9 bits, compte tenu de la mise en miroir. <br><br>  [8] Ce n'est pas toujours le cas.  PPU peut être configuré pour utiliser la même page CHR pour les tables de noms que pour les sprites. <br><br>  [9] Cette commande a peut-être été utilisée car elle correspond aux données que le PPU doit traiter pour un rendu efficace. <br><br>  [10] Ce bit est utilisé pour divers effets, par exemple, pour déplacer Mario sous les blocs blancs dans Super Mario Bros 3, ou pour rendre le brouillard sur les sprites dans Castlevania 3. <br><br>  [11] PPU a également une option pour activer les sprites 8 × 16, qui est utilisé dans des jeux comme Contra, où il y a de grands personnages.  Cependant, toutes les autres restrictions s'appliquent. <br><br><h2>  3e partie </h2><br>  Dans les parties précédentes, nous avons parlé des données CHR, des arrière-plans basés sur des tables de noms, des sprites et du défilement.  Et c'est pratiquement tout ce qu'une simple cartouche NES peut faire sans matériel supplémentaire.  Mais pour aller plus loin, nous devons expliquer en détail le fonctionnement du rendu. <br><br><h1>  Rendu </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/0d4/0ad/12b0d40ad74d27ce6d8ff2499c6df163.gif" width="200" height="200"></div><br>  <i>Raster rendu avec une pause pour vblank</i> <br><br>  Comme d'autres anciens ordinateurs, NES a été conçu pour fonctionner avec les téléviseurs CRT.  Ils dessinent des lignes de balayage sur l'écran, une à la fois, de gauche à droite, de haut en bas, à l'aide d'un canon à électrons qui se déplace physiquement jusqu'au point de l'écran où ces lignes sont tracées.  Après avoir atteint le coin inférieur, une période de temps appelée «blanc vertical» (ou vblank) s'installe: le canon à électrons retourne dans le coin supérieur gauche pour préparer le dessin de l'image suivante.  A l'intérieur de NES, le PPU (Picture Processing Unit) effectue automatiquement le rendu raster, dans chaque image, et le code travaillant dans le CPU fait toutes les tâches que le jeu doit effectuer.  Vblank permet au programme de remplacer les données dans la mémoire PPU, car sinon ces données seront utilisées pour le rendu.  Le plus souvent, des modifications sont apportées à la table des noms et aux palettes PPU pendant cette petite fenêtre. <br><br>  Cependant, certains changements dans l'état du PPU peuvent être effectués pendant le rendu d'écran.  Ils sont appelés «effets raster».  L'action la plus courante effectuée pendant le rendu d'écran consiste à définir la position de défilement.  Grâce à cela, une partie de l'image reste statique (par exemple, l'interface de jeu), et tout le reste continue de défiler.  Pour obtenir cet effet, il est nécessaire de sélectionner précisément l'heure de modification de la valeur de défilement afin qu'elle se produise sur la ligne raster souhaitée.  Il existe de nombreuses méthodes pour implémenter une telle synchronisation entre le code du jeu et PPU. <br><br><h1>  Écran partagé </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/4bf/c1e/36e4bfc1e8e92ae1dbfb83225946dc0f.png" width="512" height="480"></div><br>  <i>Le niveau défile et l'interface en haut de l'écran reste immobile</i> <br><br>  Premièrement, PPU a un matériel intégré qui traite les sprites dans la position de mémoire zéro d'une manière spéciale.  Lors du rendu de cette image-objet, si l'un de ses pixels chevauche la partie visible de l'arrière-plan, un bit est défini sous le nom "indicateur de l'image-objet".  Le code du jeu peut d'abord placer ce sprite là où le fractionnement d'écran doit se produire, puis attendre en boucle, en vérifiant la valeur du drapeau sprite0.  Par conséquent, lorsque la boucle est terminée, le jeu saura avec certitude quelle ligne raster est actuellement en cours de rendu.  Cette technique est utilisée pour implémenter le partage d'écran simple dans de nombreux jeux NES, notamment Ninja Gaiden (1989), illustré ci-dessus [12] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/acd/f19/66bacdf196bab83b91ea70c2657dd497.png" alt="ninja-hud" width="256" height="240"></div><br>  <i>Sprite0 est situé à Y $ 26, X $ a0.</i>  <i>Lorsque sa rangée inférieure de pixels est rendue, le drapeau sprite0 est défini</i> <br><br>  Dans certains jeux, le drapeau sprite0 est combiné avec une autre technique - boucle temporisée de manière prévisible («un cycle avec un timing prévisible»): le programme attend jusqu'à ce que plusieurs lignes supplémentaires soient rendues pour diviser l'écran en plusieurs parties. ,       Ninja Gaiden    , ,       .    ,       ,    ,   sprite0    ,      timed loops. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/19a/bfd/cf919abfdd1c0d786440e0af2c99bb24.gif" alt="ninjas-in-field" width="512" height="480"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/fab/d51/f77fabd51c4431db2c98ee1bf64e0eb2.gif" alt="castle-view" width="512" height="480"></div><br>             ,    ,      .          ( ,         (memory mapping)),          [13],       .             ,     .      NES,      ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/9c3/f4f/6189c3f4fa79e5c31b80b2c14df75dcb.gif" alt="train-level" width="512" height="480"></div><br>    Ninja Gaiden 2,           ,      ,     . ,         ;            .   ,           . <br><br><h1>   </h1><br>       ,        .  ,       ,      [14].        (        ),     CHR,      ,       .      ,       .                 .    Ninja Gaiden             ,     ,           CHR. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69f/896/804/69f8968042bded347183e35af32c16ae.gif" alt="goofall-bg" width="512" height="480"></div><br> <i> ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/882/f90/290882f90bb731af9e98f7ee65b4e64f.png" alt="goofall-nt" width="512" height="480"></div><br> <i>  ,        </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/077/b23/cf7077b23ea5242b4f27d308b7514077.png" width="512" height="480"></div><br> <i>      CHR.     ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/335/28e/7a233528e53b01341d21112b3651310e.png" alt="who-are-they-bottom-bank" width="512" height="480"></div><br> <i>      CHR.       </i> <br><br>        ,   (   ) .      ,     ,              .        ,      .               ,      [15].      ,           CHR. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/6b4/281/5016b4281a88523177dffef3f8de4250.gif" alt="metal-storm-bg" width="512" height="464"></div><br> <i>Metal Storm (1991 )      </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c05/7d4/6cb/c057d46cbf7f4d2cfb3e401d1658692f.png" alt="metal-storm-nt" width="512" height="464"></div><br> <i>      </i> <br><br> CHR    —    ,     .       ,           ;       .  ,  CHR   ,     ,    . ,       ,        ,      . <br><br><h1>   </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="vice-fire" width="512" height="480"></div><br> <i> Vice: Project Doom (1991 )    ,        .       ,     .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/25b/9b9/25325b9b935359508dc420aa35ef1748.gif" alt="sword-master" width="512" height="480"></div><br> <i>Sword Master (1990 )        ,            .</i> <br><br><h1>  Remerciements </h1><br>              ,   FCEUX.  ,      sprite0    NesDev: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FCEUX</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NesDev wiki</a> </li></ul><br><h1>  </h1><br> [12]   ,   Ninja Gaiden  .     8×16 sprites —  ,  PPU,       .   sprite0  ,  sprite1      .    z-  ,      ,   . <br><br> [13]    .          .      PPU  , ,     .          (IRQ),      ,  ,        . <br><br> [14]      ,         ,    .   ,    , -      4   8 . <br><br> [15]     CHR        :      ,      .        , ,  1   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470614/">https://habr.com/ru/post/fr470614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470602/index.html">À quoi ressemblerait le métro de Moscou dans un monde en trois dimensions</a></li>
<li><a href="../fr470604/index.html">Vitesse de chargement des sites dans le commerce électronique: analyse des 48 meilleurs magasins en ligne en Russie</a></li>
<li><a href="../fr470608/index.html">Optimisation de l'interface utilisateur Unity</a></li>
<li><a href="../fr470610/index.html">Un jour dans la vie d'un développeur</a></li>
<li><a href="../fr470612/index.html">Ce qu'un voltmètre montre, ou des prises mathématiques</a></li>
<li><a href="../fr470616/index.html">Une nouvelle solution au paradoxe de Fermi (pourquoi nous sommes seuls dans l'univers)</a></li>
<li><a href="../fr470618/index.html">Modélisation thématique de l'actualité à l'aide de l'analyse factorielle</a></li>
<li><a href="../fr470620/index.html">Infrastructure en tant que code: comment surmonter les problèmes avec XP</a></li>
<li><a href="../fr470622/index.html">Présentation des méthodes de sélection des fonctionnalités</a></li>
<li><a href="../fr470628/index.html">Construction navale de simulateur de vaisseau spatial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>