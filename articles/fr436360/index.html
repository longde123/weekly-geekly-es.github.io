<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∂ üï∑Ô∏è üéûÔ∏è Je dois aller vite: construire pour la vitesse dans iOS. Partie 1 üêô üë©üèø‚Äçü§ù‚Äçüë©üèº üìΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe de nombreux conseils et astuces qui permettent aux d√©veloppeurs iOS de savoir comment optimiser les performances pour que les animations dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Je dois aller vite: construire pour la vitesse dans iOS. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/436360/"><img src="https://habrastorage.org/webt/cl/ww/k-/clwwk-yxw7f1pbfvtly5lytqnac.png"><br><br>  Il existe de nombreux conseils et astuces qui permettent aux d√©veloppeurs iOS de savoir comment optimiser les performances pour que les animations dans les applications s'ex√©cutent correctement.  Apr√®s avoir lu l'article, vous comprendrez ce que signifie 16,67 millisecondes pour le d√©veloppeur iOS et quels outils sont les meilleurs √† utiliser pour retrouver le code. <br><br>  L'article est bas√© sur le discours-programme prononc√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Luke Parham</a> , actuellement ing√©nieur iOS chez Apple et auteur de tutoriels pour le d√©veloppement iOS sur RayWenderlich.com, √† l'International Mobile Developers Conference <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MBLT DEV 2017</a> . <a name="habracut"></a><br><br><blockquote>  ¬´H√© les gars.  Si vous le pouvez, disons, vous pouvez r√©duire de 10 secondes le temps de d√©marrage, multiplier cela par 5 millions d'utilisateurs et c'est 50 millions de secondes chaque jour.  Sur un an, cela repr√©sente probablement des dizaines de vies.  Donc, si vous le faites d√©marrer dix secondes plus vite, vous avez sauv√© une dizaine de vies.  √áa en vaut vraiment la peine, tu ne crois pas? </blockquote><br>  <i>Steve Jobs sur les performances (temps de d√©marrage d'Apple II).</i> <br><br><h2>  Les performances dans iOS ou comment sortir du principal </h2><br>  Le thread principal est charg√© d'accepter les entr√©es des utilisateurs et d'afficher les r√©sultats √† l'√©cran.  Accepter les tapotements, les panoramiques, tous les gestes, puis le rendu.  La plupart des t√©l√©phones mobiles modernes affichent 60 images par seconde.  Cela signifie que tout le monde veut faire tout le travail en 16,67 millisecondes.  Donc, sortir du fil principal est une chose vraiment importante. <br><br>  Si quelque chose prend plus de 16,67 millisecondes, vous perdrez automatiquement des images et vos utilisateurs le verront lorsqu'il y aura des animations.  Certains appareils ont encore moins de temps √† rendre, par exemple, le nouvel iPad a 120 Hertz, il n'y a donc que 8 millisecondes par image pour faire le travail. <br><br><h2>  Cadres supprim√©s </h2><br><h3>  R√®gle n ¬∞ 1: utilisez CADisplayLink pour suivre les images perdues </h3><br>  CADisplayLink est une minuterie sp√©ciale qui se d√©clenche sur le Vsync.  Le Vsync est lorsque l'application est rendue √† l'√©cran, et cela se produit toutes les 16 millisecondes.  √Ä des fins de test, dans votre AppDelegate, vous pouvez configurer CADisplayLink ajout√© √† la boucle d'ex√©cution principale, puis avoir simplement une autre fonction o√π vous faites un peu de calcul.  Ensuite, vous suivez depuis combien de temps l'application fonctionne et depuis combien de temps cette derni√®re fonction a √©t√© lanc√©e.  Et voyez si cela a pris plus de 16 millisecondes. <br><br><img src="https://habrastorage.org/webt/pm/jv/r_/pmjvr_ketfth1a_vhcp36_lu-mu.png"><br><br>  Cela ne se d√©clenche que lorsqu'il est r√©ellement rendu.  Si vous faisiez beaucoup de travail et que vous ralentissiez le thread principal, cela s'ex√©cuterait 100 millisecondes plus tard, ce qui signifie que vous avez fait trop de travail et que vous avez perdu des images pendant cette p√©riode. <br><br>  Par exemple, il s'agit de l'application Catstagram.  Il a des b√©gaiements lors du chargement de l'image.  Et puis vous pouvez voir que l'image a √©t√© supprim√©e √† un certain moment et qu'elle a eu un temps √©coul√© d'environ 200 millisecondes.  Cela signifie que cette application fait quelque chose qui prend trop de temps. <br><br><img src="https://habrastorage.org/webt/tz/8b/_u/tz8b_u-2r_f5-p7k9pjll9hvhfk.gif"><br><br>  Les utilisateurs n'aiment pas une telle exp√©rience, surtout si l'application prend en charge les appareils plus anciens comme l'iPhone 5, les anciens iPod, etc. <br><br><h3>  Profileur de temps </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Time Profiler</a> est probablement l'outil le plus utile pour retrouver les informations.  Les autres outils sont utiles mais, au final, dans Fyusion, nous utilisons Time Profiler comme 90% du temps.  Les suspects habituels de l'application sont la vue d√©filante, le texte et les images. <br><br>  Les images sont vraiment grandes.  Nous avons le d√©codage JPEG - "UIImageView" est √©gal √† certains UIImage.  UIimages d√©code tous les JPEG de l'application.  Ils le font lentement, vous ne pouvez donc pas vraiment suivre directement les performances.  Cela ne se produit pas correctement lorsque vous d√©finissez l'image, mais vous pouvez la voir dans les traces du profileur temporel. <br>  La mesure du texte est une autre grande chose.  Cela appara√Æt, par exemple si vous en avez beaucoup de tr√®s complexes comme le japonais ou le chinois.  Cela peut prendre beaucoup de temps pour effectuer la mesure des lignes. <br><br>  La disposition de la hi√©rarchie ralentit √©galement le rendu de l'application.  Cela est particuli√®rement vrai avec la disposition automatique.  C'est pratique, mais c'est aussi tr√®s lent par rapport √† la mise en page manuelle.  C'est donc l'un de ces compromis.  Si cela ralentit l'application, il est peut-√™tre temps de s'en √©loigner et d'essayer une autre technique de mise en page. <br><br><h3>  Exemple de trace </h3><br><br><img src="https://habrastorage.org/webt/sx/od/dw/sxoddwfs536ehipsoclxey4yysw.png"><br><br>  Dans l'exemple d'arborescence d'appels, vous pouvez voir combien de travail vos CPU font.  Vous pouvez changer les vues, les regarder par threads, les regarder par CPU.  Habituellement, la chose la plus int√©ressante est de s√©parer par threads et de regarder ensuite ce qui se trouve sur main. <br><br>  Souvent, lorsque vous commencez √† regarder cela, cela semble super √©crasant.  Vous avez parfois le sentiment: ¬´Qu'est-ce que toutes ces ordures?  Je ne sais pas ce que cela signifie "FRunLoopDoSource0". <br><br>  Mais c'est l'une des choses o√π vous pouvez creuser et comprendre comment les choses fonctionnent et cela commence √† avoir un sens.  Vous pouvez donc suivre la trace de la pile et regarder toutes les choses du syst√®me que vous n'avez pas √©crites.  Mais en bas, vous pouvez voir votre code r√©el. <br><br><h3>  L'arbre d'appel </h3><br>  Par exemple, nous avons une application tr√®s simple qui a la fonction principale, puis elle appelle quelques m√©thodes √† l'int√©rieur de la principale.  Le profileur temporel fait qu'il prend un instantan√© de la trace de votre pile actuellement par d√©faut toutes les millisecondes.  Ensuite, il attend une milliseconde et prend un instantan√©, o√π vous avez appel√© ¬´principal¬ª qui a appel√© ¬´foo¬ª qui a appel√© ¬´bar¬ª.  Il y a la premi√®re trace de pile sur la capture d'√©cran.  Donc, cela est collect√©.  Nous avons ces chiffres: 1, 1, 1. <br><br><img src="https://habrastorage.org/webt/uc/rc/uq/ucrcuqen-b5unzzu3hinwhxny6e.png"><br><br>  Chacune de ces fonctions a √©t√© appel√©e une fois.  Puis, une milliseconde plus tard, nous capturons une autre pile.  Et cette fois, c'est exactement la m√™me chose, nous augmentons tous les d√©comptes de 2. <br><br><img src="https://habrastorage.org/webt/r2/ak/ez/r2akezneiolgd_p4robekqxddtg.jpeg"><br><br>  Ensuite, √† la troisi√®me milliseconde, nous avons une pile d'appels l√©g√®rement diff√©rente.  Main appelle directement ¬´bar¬ª.  Le bar et le bar sont en hausse de un.  Mais alors nous avons une scission.  Parfois, les appels principaux ¬´foo¬ª, parfois les appels principaux ¬´bar¬ª directement.  Cela arrive une fois.  Une m√©thode a √©t√© appel√©e √† l'int√©rieur d'une autre. <br><br>  Plus loin, une m√©thode a √©t√© appel√©e √† l'int√©rieur d'une autre qui appelle la troisi√®me m√©thode.  Nous voyons que ¬´buz¬ª a √©t√© appel√© deux fois.  Mais c'est une m√©thode si petite qu'elle se produit entre une milliseconde. <br><br>  En utilisant Time Profileer, il est important de se rappeler qu'il ne donne pas les heures exactes.  Il ne dit pas exactement combien de temps prend une m√©thode.  Il indique la fr√©quence √† laquelle il appara√Æt dans les instantan√©s, ce qui ne peut qu'approcher le temps d'ex√©cution de chaque m√©thode.  Parce que si quelque chose est assez court, il n'appara√Ætra jamais. <br><br><img src="https://habrastorage.org/webt/2x/9_/3a/2x9_3a7jrotn2hmb7qwcrstnqq8.jpeg"><br><br>  Si vous passez en mode console dans l'arborescence des appels, vous pouvez voir tous les √©v√©nements de chute de trame et vous pouvez les faire correspondre.  Nous avons un tas d'images en cours de suppression et nous avons un tas de travail en cours.  Vous pouvez zoomer dans le profileur temporel et voir ce qui √©tait ex√©cut√© uniquement dans cette section. <br><br><img src="https://habrastorage.org/webt/py/rr/mg/pyrrmgpd2zi_g7sfmd0bxkrb0jw.jpeg"><br><br>  En fait, dans Mac, en g√©n√©ral, vous pouvez cliquer sur les triangles de divulgation et cela s'ouvrira comme par magie et vous montrera ce qui est le plus important l√†-dedans.  Il descendra √† ce qui fait le plus de travail.  Et 90% du temps, ce sera CFRunLoopRun, puis les rappels. <br><br><img src="https://habrastorage.org/webt/a9/v-/u0/a9v-u04m0cv1rlw6iodwjhale3y.jpeg"><br><br>  L'application enti√®re est bas√©e sur une boucle d'ex√©cution.  Vous avez cette boucle qui dure ind√©finiment, puis √† chaque it√©ration de la boucle, les rappels sont appel√©s.  Lorsque vous arrivez √† ce point, vous pouvez approfondir chacun de ces √©l√©ments et regarder essentiellement quels sont vos trois ou quatre principaux goulots d'√©tranglement. <br><br>  Si nous explorons l'un de ces √©l√©ments, nous pouvons voir de telles choses o√π il est vraiment facile de les regarder, et dire: "Wow, je ne sais pas ce que cela fait."  Comme les rendus, le fournisseur d'images, IO. <br><br><img src="https://habrastorage.org/webt/jd/ay/wp/jdaywpohjztghohyu9qnxpgqkky.jpeg"><br><br>  Il existe une option o√π vous pouvez masquer les biblioth√®ques syst√®me.  Il est vraiment tentant de se cacher, mais en r√©alit√©, c'est en fait le plus gros goulot d'√©tranglement de l'application. <br><br>  Il y a les pond√©rations qui indiquent le pourcentage du travail effectu√© par cette fonction ou m√©thode particuli√®re.  Et si nous explorons l'exemple, nous avons 34% et cela se produit √† cause d'Apple jpeg_decode_image_all.  Apr√®s un peu de recherche, il devient clair que cela signifie que le d√©codage JPEG se produit sur le thread principal et provoque la majorit√© des pertes d'images. <br><br><img src="https://habrastorage.org/webt/ke/zk/zl/kezkzlggrh1akcegmmvuqefzl7u.png"><br><br><h3>  R√®gle n ¬∞ 2 </h3><br>  En r√®gle g√©n√©rale, il est pr√©f√©rable de d√©coder les JPEG en arri√®re-plan.  La plupart des biblioth√®ques tierces (AsyncDisplayKit, SDWebImage, ...) le font imm√©diatement.  Si vous ne souhaitez pas utiliser de frameworks, vous pouvez le faire vous-m√™me.  Ce que vous faites, c'est que vous passez une image, dans ce cas, c'est une extension de UIImage, puis vous configurez un contexte et vous dessinez l'image manuellement dans un contexte dans un CGBitmap. <br><br><img src="https://habrastorage.org/webt/yu/7j/k3/yu7jk3lnsy0csn-k2kddmjha-_w.jpeg"><br><br>  Lorsque vous faites cela, vous pouvez appeler la m√©thode Image () d√©cod√©e √† partir d'un thread d'arri√®re-plan.  Cela retournera toujours l'image d√©cod√©e.  Il n'y a aucun moyen de v√©rifier si en particulier UIImage est d√©j√† d√©cod√©, et vous devez toujours les passer ici.  Mais si vous mettez les choses en cache correctement, cela ne fait aucun travail suppl√©mentaire. <br><br>  Cela est techniquement moins efficace.  Utiliser UIimageView est super optimis√©, super efficace.  Il fera le d√©codage mat√©riel donc c'est un compromis.  Vos images seront d√©cod√©es plus lentement de cette fa√ßon.  Mais la bonne chose est que vous pouvez envoyer √† une file d'attente en arri√®re-plan, d√©coder votre image avec cette m√©thode que nous venons de voir, puis revenir sur le fil principal et d√©finir votre contenu. <br><br><img src="https://habrastorage.org/webt/xu/lv/dg/xulvdgmhnxm6zk4hrfaslok81fg.png"><br><br>  M√™me si ce travail a pris plus de temps, peut-√™tre qu'il ne s'est pas produit sur le thread principal, il ne bloquait donc pas l'interaction avec l'utilisateur car il ne bloquait pas le d√©filement.  C'est donc une victoire. <br><br><h3>  Avertissements de m√©moire </h3><br>  Tout signe que vous obtenez un avertissement de m√©moire que vous souhaitez tout supprimer, supprimez toute la m√©moire inutilis√©e que vous pouvez.  Mais si vous rencontrez des probl√®mes sur les threads d'arri√®re-plan, l'allocation de ces gros fichiers JPEG d√©cod√©s prend beaucoup de nouvelle m√©moire sur les threads d'arri√®re-plan. <br><br>  Cela s'est produit dans l'application Fyuse.  Si je passais √† un fil d'arri√®re-plan, d√©codais tous mes JPEG, dans certains cas sur des t√©l√©phones plus anciens, le syst√®me le tuerait instantan√©ment.  Et c'est parce qu'il envoie un avertissement de m√©moire disant: ¬´H√©!  D√©barrassez-vous de votre m√©moire ¬ªmais les files d'attente en arri√®re-plan n'√©coutent pas.  Que se passe-t-il si vous allouez toutes ces images et que cela se bloque √† chaque fois.  Le contournement consiste √† envoyer une requ√™te ping au thread principal √† partir du thread d'arri√®re-plan. <br><br><img src="https://habrastorage.org/webt/i2/pj/fb/i2pjfbbvytxdsiut5jqirpaibvi.png"><br><br>  En g√©n√©ral, le thread principal est une file d'attente.  Les choses sont mises en file d'attente et se produisent sur le thread principal.  Lorsque vous passez en arri√®re-plan dans Objective-C, vous pouvez utiliser performSelectorOnMainThread: withObject: waitUntilDone:.  Cela le placera √† la fin de la ligne des files d'attente principales, donc si la file d'attente principale est occup√©e √† traiter les avertissements de m√©moire, cet appel de fonction ira √† la fin de la ligne et attendra que tous les avertissements de m√©moire soient trait√©s avant de faire toute cette lourde allocation m√©moire <br><br>  Dans Swift, c'est plus simple.  Vous pouvez effectuer une r√©partition du bloc vide principal de mani√®re synchrone sur le principal. <br><br>  Voici un exemple o√π nous avons nettoy√© les choses et nous faisons le d√©codage d'images sur les files d'attente en arri√®re-plan.  Et le d√©filement visuel est beaucoup plus joli.  Nous avons encore des baisses de trame, mais c'est sur un iPod 5g, c'est donc l'une des pires choses que vous pouvez tester sur qui prend toujours en charge comme iOS 10 et 11. <br><br><img src="https://habrastorage.org/webt/bw/fa/og/bwfaog8aavwenf4h1lkqipapnds.gif"><br><br>  Lorsque vous avez ces gouttes de cadre, vous pouvez continuer √† chercher.  Il y a encore du travail qui se produit et qui cause ces chutes de trame.  Il y a plus de choses que vous pourriez faire pour l'acc√©l√©rer. <br><br>  Pour r√©sumer, ce n'est pas toujours aussi simple, mais si vous avez de petites choses qui prennent beaucoup de temps, vous pouvez les faire en arri√®re-plan. <br><br>  Assurez-vous qu'il n'est pas li√© √† UIKit.  De nombreuses classes UIKit ne sont pas thread-safe et vous ne pouvez pas allouer cette UIView en arri√®re-plan. <br><br>  Utilisez Core Graphics si vous avez besoin de cr√©er des images en arri√®re-plan.  Ne masquez pas les biblioth√®ques syst√®me.  Et n'oubliez pas les avertissements de m√©moire. <br><br>  Ceci est la premi√®re partie d'un article bas√© sur la pr√©sentation de Luke Parham.  Si vous souhaitez en savoir plus sur le fonctionnement de l'interface utilisateur dans iOS, pourquoi utiliser un chemin d'acc√®s plus pr√©cis et quand revenir √† la gestion manuelle de la m√©moire, lisez la deuxi√®me partie d'un article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Vid√©o </h2><br>  Regardez le discours complet ici: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tZIQjrPdFcI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436360/">https://habr.com/ru/post/fr436360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436350/index.html">Apprenez les tactiques, techniques et connaissances communes contradictoires (ATT @ CK). Tactiques d'entreprise. Partie 7</a></li>
<li><a href="../fr436352/index.html">R√©sum√© des nouvelles de PostgreSQL. Num√©ro 14</a></li>
<li><a href="../fr436354/index.html">L'arm√©e am√©ricaine n√©glige les probl√®mes de cybers√©curit√©</a></li>
<li><a href="../fr436356/index.html">[Int√©ressant de derri√®re la colline] Comment arr√™ter la d√©pendance technologique?</a></li>
<li><a href="../fr436358/index.html">Pourquoi les d√©veloppeurs seniors enseignent-ils aux √©tudiants</a></li>
<li><a href="../fr436364/index.html">Liveprof vous montrera quand et pourquoi les performances de votre application PHP ont chang√©</a></li>
<li><a href="../fr436370/index.html">Infrastructure √† cl√© publique Cha√Æne de certificats racine X509 v.3</a></li>
<li><a href="../fr436372/index.html">Plugin isom√©trique pour Unity3D</a></li>
<li><a href="../fr436374/index.html">Tendances de conception UI et UX 2019</a></li>
<li><a href="../fr436376/index.html">Pr√©sentation du robot tout-terrain EZ-Robot Roli Rover</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>