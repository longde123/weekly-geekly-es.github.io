<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèæ üßîüèΩ üéÇ Infrastruktur Kunci Publik X509 v.3 Rantai Sertifikat Root üë∞ üõï ü•£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jam "H" semakin mendekati: "penggunaan skema tanda tangan GOST R 34.10-2001 untuk menghasilkan tanda tangan setelah 31 Desember 2018 tidak diizinkan!"...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infrastruktur Kunci Publik X509 v.3 Rantai Sertifikat Root</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436370/"><img src="https://habrastorage.org/webt/tk/9x/m3/tk9xm3b0z6etzpbcvbk2qypdgmo.png" align="left"><blockquote>  Jam "H" semakin mendekati: "penggunaan skema tanda tangan GOST R 34.10-2001 untuk menghasilkan tanda tangan setelah 31 Desember 2018 tidak diizinkan!". </blockquote> <a name="habracut"></a>  Namun, kemudian terjadi kesalahan, seseorang tidak siap, dan penggunaan GOST R 34.10-2001 diperpanjang untuk 2019.  Tapi tiba-tiba semua orang bergegas untuk mentransfer CA ke GOST R 34.10-2012, dan untuk mentransfer warga biasa ke sertifikat baru.  Orang-orang memiliki beberapa sertifikat di tangan mereka.  Saat memeriksa sertifikat atau tanda tangan elektronik, pertanyaan mulai muncul, dan dari mana mendapatkan sertifikat root untuk menginstal di toko sertifikat akar tepercaya. <br><br>  Ini berlaku untuk kedua toko sertifikat di Windows dan toko sertifikat di Firefox dan Google Chrome, GnuPG, LibreOffice, klien email, dan bahkan OpenSSL.  Tentu saja, perlu untuk mengurus ini ketika menerima sertifikat di CA dan menulis rantai sertifikat ke USB flash drive.  Dan di sisi lain, kami memiliki masyarakat digital dan setiap saat harus bisa mendapatkan rantai ini dari jaringan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Simpleadmin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> cara melakukan ini di halaman Habr.  Namun, bagi warga negara biasa itu masih sulit (terutama jika Anda memperhitungkan bahwa sebagian besar dari mereka ada di Windows): Anda perlu memiliki beberapa jenis openssl, sebuah utilitas besar yang tidak saya miliki di komputer saya, dan tidak semua orang tahu Anda bisa menggunakan wget sebagai gantinya.  Dan berapa banyak tindakan yang perlu dilakukan.  Tentu saja ada jalan keluar, menulis skrip, tetapi tidak hanya skrip di atas openssl dan sejenisnya, tetapi dikemas dalam modul yang dapat dieksekusi mandiri untuk berbagai platform. <br><br>  Tidak ada keraguan apa yang harus ditulis - dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tcl dan Python</a> .  Dan kita mulai dengan Tcl dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inilah sebabnya</a> : <br><blockquote>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki</a> sialan di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahkan ada mainan</a> (Anda dapat melihat hal-hal menarik di sana :) <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar contekan</a> <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">build tclkit</a> normal (1,5 - 2 MB sebagai biaya untuk platform lintas nyata) <br>  * dan perakitan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eTcl</a> favorit saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari Evolane</a> (dipelihara dengan hati-hati dari situs yang telah meninggal :( <br>  pertahankan peringkat Tcl / Tk yang tinggi pada daftar toolkit pribadi saya <br>  dan, ya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki.tcl.tk/16867</a> (server web kecil dari cgi ke Tcl, secara berkala digunakan dengan keteguhan yang patut ditiru di bawah tclkit) <br>  dan juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indah</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cantik</a> :) </blockquote>  Untuk ini saya akan menambahkan ketersediaan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">freewrap</a> , yang akan membantu kami membangun utilitas mandiri untuk Linux dan MS Windows.  Sebagai hasilnya, kita akan memiliki utilitas chainfromcert: <br><br><pre><code class="bash hljs">bash-4.3$ ./chainfromcert_linux64 Copyright(C)2019 Usage: chainfromcert &lt;file with certificate&gt; &lt;directory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chain certificate&gt; Bad usage! bash-4.3$</code> </pre> <br>  Sebagai parameter, utilitas menetapkan file dengan sertifikat pengguna (baik dalam format PEM dan format DER) dan direktori di mana sertifikat CA yang termasuk dalam rantai akan disimpan: <br><br><pre> <code class="bash hljs">bash-4.3$ ./chainfromcert_linux64 ./cert_test.der /tmp Loading file: cert_test.der Directory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chain: . cert 1 from http://ca.ekey.ru/cdp/ekeyUC2012.cer cert 2 from http://reestr-pki.ru/cdp/guc_gost12.crt Goodby! Length chain=2 Copyright(C) 2019 bash-4.3$</code> </pre> <br>  Sekarang pertimbangkan cara kerja utilitas. <br>  Informasi tentang otoritas sertifikasi yang menerbitkan sertifikat kepada pengguna disimpan dalam ekstensi dengan oid 1.3.6.1.5.5.7.1.1.  Ekstensi ini dapat menyimpan lokasi sertifikat CA (oid 1.3.6.1.5.5.7.48.2) dan informasi tentang layanan OCSP CA (oid 1.3.6.1.5.5.7.48.1): <br><br><img src="https://habrastorage.org/webt/v2/rg/n5/v2rgn5yw6sjb3pygp-vziqcvrys.png"><br><br>  Dan informasi, misalnya, tentang periode penggunaan kunci tanda tangan elektronik disimpan dalam ekstensi dengan oid 2.5.29.16. <br><br>  Untuk mengurai sertifikat dan mengakses ekstensi sertifikat, kami akan menggunakan paket pki: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh -f package require pki</code> </pre> <br>  Kami juga akan membutuhkan paket base64: <br><br><pre> <code class="plaintext hljs">package require base64</code> </pre> <br>  Paket pki, serta paket asn dan paket base64 yang dimuatnya, akan membantu kami mengonversi sertifikat dari PEM encoding ke pengkodean DER, mengurai struktur ASN dan benar-benar mengakses informasi tentang lokasi sertifikat CA. <br><br>  Utilitas dimulai dengan memeriksa parameter dan mengunduh file dengan sertifikat: <br><br><pre> <code class="plaintext hljs">proc usage {use } { puts "Copyright(C) 2011-2019" if {$use == 1} { puts "Usage:\nchainfromcert &lt;file with certificate&gt; &lt;directory for chain certificate&gt;\n" } } if {[llength $argv] != 2 } { usage 1 puts "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { puts "File $file not exist" usage 1 exit } puts "Loading file: $file" set dir [lindex $argv 1] if {![file exists $dir]} { puts "Dir $dir not exist" usage 1 exit } puts "Directory for chain: $dir" set fd [open $file] chan configure $fd -translation binary set data [read $fd] close $fd if {$data == "" } { puts "Bad file with certificate=$file" usage 1 exit }</code> </pre> <br>  Semuanya jelas di sini dan kami mencatat hanya satu hal - file dengan sertifikat dianggap sebagai file biner: <br><br><pre> <code class="plaintext hljs">chan configure $fd -translation binary</code> </pre> <br>  Hal ini disebabkan oleh fakta bahwa sertifikat dapat disimpan baik dalam format DER (kode biner) dan dalam format PEM (pengkodean base64). <br><br>  Setelah file dimuat, prosedur chainfromcert disebut: <br><br><pre> <code class="plaintext hljs">set depth [chainfromcert $data $dir]</code> </pre>  yang sebenarnya mengunduh sertifikat root: <br><br><pre> <code class="plaintext hljs">proc chainfromcert {cert dir} { if {$cert == "" } { exit } set asndata [cert_to_der $cert] if {$asndata == "" } { #    ,    return -1 } array set cert_parse [::pki::x509::parse_cert $asndata] array set extcert $cert_parse(extensions) if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} { #    return 0 } set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0] # if {$a == "false"} { # puts $a # } # ASN1-   Hex- set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1] #    set c [binary format H* $b] #Sequence 1.3.6.1.5.5.7.1.1 ::asn::asnGetSequence c c_par_first #     1.3.6.1.5.5.7.1.1 while {[string length $c_par_first] &gt; 0 } { #   (sequence) ::asn::asnGetSequence c_par_first c_par # oid   ::asn::asnGetObjectIdentifier c_par c_type set tas1 [::pki::_oid_number_to_name $c_type] #   ::asn::asnGetContext c_par c_par_two # oid     if {$tas1 == "1.3.6.1.5.5.7.48.2" } { #    set certca [readca $c_par $dir] if {$certca == ""} { #   .      continue } else { global count #      set f [file join $dir [file tail $c_par]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $certca close $fd incr count puts "cert $count from $c_par" #     chainfromcert $certca $dir continue } } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } { # puts "OCSP server (oid=$tas1)=$c_par" } } #   return $count }</code> </pre> <br>  Tidak ada yang ditambahkan ke komentar, tetapi kami masih belum mempertimbangkan prosedur readca: <br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer }</code> </pre> <br>  Prosedur ini didasarkan pada penggunaan paket http: <br><br><pre> <code class="plaintext hljs">package require http</code> </pre> <br>  Untuk membaca sertifikat, kami menggunakan fungsi berikut: <br><br><pre> <code class="plaintext hljs">set token [http::geturl $url -binary 1]</code> </pre> <br>  Tujuan dari sisa fungsi yang digunakan jelas dari komentar.  Kami hanya akan memberikan dekripsi kode pengembalian untuk fungsi http :: ncodel: <br><blockquote>  200 Permintaan berhasil diselesaikan <br>  206 Permintaan berhasil diselesaikan, tetapi hanya sebagian file yang diunduh <br>  301 File dipindahkan ke lokasi lain. <br>  302 File dipindahkan sementara ke lokasi lain. <br>  Diperlukan 401 otentikasi server <br>  403 Akses ke sumber ini ditolak <br>  404 Sumber yang ditentukan tidak dapat ditemukan. <br>  500 Kesalahan internal </blockquote>  Satu prosedur masih harus dipertimbangkan, yaitu cert_to_der: <br><br><pre> <code class="plaintext hljs">proc cert_to_der {data} { set lines [split $data \n] set hlines 0 set total 0 set first 0 # PEM-   foreach line $lines { incr total if {[regexp {^-----BEGIN CERTIFICATE-----$} $line]} { if {$first} { incr total -1 break } else { set first 1 incr hlines } } if {[regexp {^(.*):(.*)$} $line ]} { incr hlines } } if { $first == 0 &amp;&amp; [string range $data 0 0 ] == "0" } { #   DER- "0" == 0x30 return $data } if {$first == 0} {return ""} set block [join [lrange $lines $hlines [expr {$total-1}]]] #from PEM to DER set asnblock [base64::decode $block] return $asnblock }</code> </pre> <br>  Prosedurnya sangat sederhana.  Jika ini adalah file PEM dengan sertifikat ("----- BEGIN CERTIFICATE -----"), maka badan file ini dipilih dan dikonversi ke kode binar: <br><br><pre> <code class="plaintext hljs">set asnblock [base64::decode $block]</code> </pre> <br>  Jika ini bukan file PEM, maka ini "kesamaan" dengan pengkodean asn diperiksa (bit nol harus 0x30). <br><br>  Itu saja, tetap menambahkan baris terakhir: <br><br><pre> <code class="plaintext hljs">if {$depth == -1} { puts "Bad file with certificate=$file" usage 1 exit } puts "Goodby!\nLength chain=$depth" usage 0 exit</code> </pre><br>  Sekarang kami mengumpulkan semuanya dalam satu file dengan nama <br><br><div class="spoiler">  <b class="spoiler_title">chainfromcert.tcl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/usr/bin/tclsh encoding system utf-8 package require pki package require base64 #package require asn package require http global count set count 0 proc chainfromcert {cert dir} { if {$cert == "" } { exit } set asndata [cert_to_der $cert] if {$asndata == "" } { #    ,    return -1 } array set cert_parse [::pki::x509::parse_cert $asndata] array set extcert $cert_parse(extensions) if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} { #    return 0 } set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0] # if {$a == "false"} { # puts $a # } # ASN1-   Hex- set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1] #    set c [binary format H* $b] #Sequence 1.3.6.1.5.5.7.1.1 ::asn::asnGetSequence c c_par_first #     1.3.6.1.5.5.7.1.1 while {[string length $c_par_first] &gt; 0 } { #   (sequence) ::asn::asnGetSequence c_par_first c_par # oid   ::asn::asnGetObjectIdentifier c_par c_type set tas1 [::pki::_oid_number_to_name $c_type] #   ::asn::asnGetContext c_par c_par_two # oid     if {$tas1 == "1.3.6.1.5.5.7.48.2" } { #    set certca [readca $c_par $dir] if {$certca == ""} { #   .      continue } else { global count #      set f [file join $dir [file tail $c_par]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $certca close $fd incr count puts "cert $count from $c_par" #     chainfromcert $certca $dir continue } } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } { # puts "OCSP server (oid=$tas1)=$c_par" } } #   return $count } proc readca {url dir} { set cer "" #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer } proc cert_to_der {data} { set lines [split $data \n] set hlines 0 set total 0 set first 0 # PEM-   foreach line $lines { incr total # if {[regexp {^-----(.*?)-----$} $line]} {} if {[regexp {^-----BEGIN CERTIFICATE-----$} $line]} { if {$first} { incr total -1 break } else { set first 1 incr hlines } } if {[regexp {^(.*):(.*)$} $line ]} { incr hlines } } if { $first == 0 &amp;&amp; [string range $data 0 0 ] == "0" } { #   DER- "0" == 0x30 return $data } if {$first == 0} {return ""} set block [join [lrange $lines $hlines [expr {$total-1}]]] #from PEM to DER set asnblock [base64::decode $block] return $asnblock } proc usage {use } { puts "Copyright(C) Orlov Vladimir 2011-2019" if {$use == 1} { puts "Usage:\nchainfromcert &lt;file with certificate&gt; &lt;directory for chain certificate&gt;\n" } } if {[llength $argv] != 2 } { usage 1 puts "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { puts "File $file not exist" usage 1 exit } puts "Loading file: $file" set dir [lindex $argv 1] if {![file exists $dir]} { puts "Dir $dir not exist" usage 1 exit } puts "Directory for chain: $dir" set fd [open $file] chan configure $fd -translation binary set data [read $fd] close $fd if {$data == "" } { puts "Bad file with certificate=$file" usage 1 exit } set depth [chainfromcert $data $dir] if {$depth == -1} { puts "Bad file with certificate=$file" usage 1 exit } puts "Goodby!\nLength chain=$depth" usage 0 exit</code> </pre><br></div></div><br>  Anda dapat memeriksa operasi file ini menggunakan interpreter tclsh: <br><br><pre> <code class="plaintext hljs">$ tclsh ./chainfromcert.tcl cert_orlov.der /tmp Loading file: cert_test.der Directory for chain: /tmp cert 1 from http://ca.ekey.ru/cdp/ekeyUC2012.cer cert 2 from http://reestr-pki.ru/cdp/guc_gost12.crt Goodby! Length chain=2 Copyright(C) 2019 $</code> </pre> <br>  Akibatnya, kami mendapat rantai dua sertifikat di direktori / tmp. <br><br>  Tetapi kami ingin mendapatkan modul yang dapat dieksekusi untuk platform Linux dan Windows dan agar pengguna tidak memikirkan penerjemah apa pun. <br><br>  Untuk tujuan ini kita akan menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">freewrapTCLSH</a> .  Dengan menggunakan utilitas ini, kami akan membuat modul yang dapat dieksekusi dari utilitas kami untuk platform Linux dan Windows, baik 32-bit dan 64-bit.  Utilitas dapat dibangun untuk semua platform di platform apa pun.  Maaf untuk tautologi.  Saya akan membangun di linux_x86_64 (Mageia). <br><br>  Untuk membangun, Anda perlu: <br><blockquote>  1. Utilitas freewrapTCLSH untuk platform linux_x86_64; <br>  2. File freewrapTCLSH dengan utilitas ini untuk setiap platform: <br>  - freewrapTCLSH_linux32 <br>  - freewrapTCLSH_linux64 <br>  - freewrapTCLSH_win32 <br>  - freewrapTCLSH_win64 <br>  3. File sumber utilitas kami: chainfromcert.tcl </blockquote>  Jadi, chainfromcerty_linuxx86 rakitan yang dapat dieksekusi untuk platform Linux x86: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$freewrapTCLSH</span></span> chainfromcert.tcl ‚Äìw freewrapTCLSH_linux32 ‚Äìo chainfromcerty_linuxx86 $</code> </pre> <br>  Perakitan utilitas untuk platform Windows 64-bit terlihat seperti ini: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$freewrapTCLSH</span></span> chainfromcert.tcl ‚Äìw freewrapTCLSH_win64 ‚Äìo chainfromcerty_win64.exe $</code> </pre> <br>  Dll  Utilitas siap digunakan.  Mereka telah menyerap semua yang diperlukan untuk pekerjaan mereka. <br>  Kode ditulis dengan cara yang sama dengan Python. <br><br>  Dalam beberapa hari mendatang, saya berpikir untuk menambah paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fsb795</a> (yang ditulis dengan Python) dengan fungsi untuk mendapatkan rantai sertifikat root. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436370/">https://habr.com/ru/post/id436370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436354/index.html">Militer AS mengabaikan masalah keamanan siber</a></li>
<li><a href="../id436356/index.html">[Menarik dari belakang bukit] Bagaimana kita menghentikan ketergantungan teknologi?</a></li>
<li><a href="../id436358/index.html">Mengapa pengembang senior mengajar siswa</a></li>
<li><a href="../id436360/index.html">Gotta Go Fast: Membangun untuk Kecepatan di iOS. Bagian 1</a></li>
<li><a href="../id436364/index.html">Liveprof akan menunjukkan kapan dan mengapa kinerja aplikasi PHP Anda telah berubah</a></li>
<li><a href="../id436372/index.html">Plugin Isometrik untuk Unity3D</a></li>
<li><a href="../id436374/index.html">Tren desain UI dan UX 2019</a></li>
<li><a href="../id436376/index.html">Sekilas tentang robot semua medan EZ-Robot Roli Rover</a></li>
<li><a href="../id436378/index.html">bobaos.pub - KNX TP / UART, Raspberry Pi dan Redis</a></li>
<li><a href="../id436380/index.html">Mulai cepat dalam pencetakan 3D: printer anggaran untuk pemula atau teknologi untuk massa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>