<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–•ğŸ½ ğŸ‘©ğŸ¿â€ğŸ¤ ğŸ¤·ğŸ½ 10 kesalahan paling umum yang saya temui di Go-proyek ğŸŒ± ğŸšï¸ ğŸ•·ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting ini adalah kesalahan saya yang paling umum yang saya temui di Go-proyek. Urutan tidak masalah. 



 Nilai Enum yang tidak diketahui 
 Mari kit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 kesalahan paling umum yang saya temui di Go-proyek</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461051/">  <b><i>Posting ini adalah kesalahan saya yang paling umum yang saya temui di Go-proyek.</i></b>  Urutan tidak masalah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b01/9ed/114/b019ed114553265d5cd0c773c2d2e2c6.jpg" alt="gambar"><br><br><h3>  Nilai Enum yang tidak diketahui </h3><br>  Mari kita lihat contoh sederhana: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusOpen Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusClosed StatusUnknown )</code> </pre> <br>  Di sini kita membuat enumerator menggunakan iota, yang akan mengarah ke keadaan ini: <br><br><pre> <code class="go hljs">StatusOpen = <span class="hljs-number"><span class="hljs-number">0</span></span> StatusClosed = <span class="hljs-number"><span class="hljs-number">1</span></span> StatusUnknown = <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <a name="habracut"></a><br>  Sekarang mari kita bayangkan bahwa jenis Status ini adalah bagian dari permintaan JSON yang akan dikemas / dibongkar.  Kita dapat merancang struktur berikut: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Id"`</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"Timestamp"`</span></span> Status Status <span class="hljs-string"><span class="hljs-string">`json:"Status"`</span></span> }</code> </pre> <br>  Lalu kami mendapatkan hasil permintaan ini: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Status"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Secara umum, tidak ada yang istimewa - Status akan dibuka ke StatusOpen. <br>  Sekarang, mari kita dapatkan jawaban lain di mana nilai status tidak disetel: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Id"</span></span>: <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1563362390</span></span> }</code> </pre> <br>  Dalam kasus ini, bidang Status dari struktur Permintaan akan diinisialisasi ke nol (untuk uint32 itu adalah 0).  Karenanya, kami kembali mendapatkan StatusOpen alih-alih StatusUnknown. <br><br>  Dalam hal ini, yang terbaik adalah menetapkan nilai enumerator yang tidak diketahui terlebih dahulu - yaitu.  0: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusUnknown Status = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> StatusOpen StatusClosed )</code> </pre><br>  Jika statusnya bukan bagian dari permintaan JSON, itu akan diinisialisasi dalam StatusUnknown, seperti yang kita harapkan. <br><br><h3>  Benchmarking </h3><br>  Pembandingan yang benar cukup sulit.  Terlalu banyak faktor yang dapat mempengaruhi hasil. <br><br>  Satu kesalahan umum sedang diakali oleh optimisasi kompiler.  Mari kita lihat contoh spesifik dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan teivah / bitvector</a> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (math.MaxUint64&lt;&lt;j | ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; n }</code> </pre> <br>  Fungsi ini membersihkan bit dalam rentang tertentu.  Kami dapat menguji kinerja dengan cara ini: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkWrong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } }</code> </pre> <br>  Dalam pengujian ini, kompiler akan melihat bahwa clear tidak memanggil fungsi lain, jadi ia hanya menyematkan apa adanya.  Setelah dibangun, kompiler akan melihat bahwa tidak ada efek samping yang terjadi.  Dengan demikian, panggilan yang jelas hanya akan dihapus, yang akan menyebabkan hasil yang tidak akurat. <br><br>  Salah satu solusinya adalah mengatur hasil ke variabel global, seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkCorrect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = clear(<span class="hljs-number"><span class="hljs-number">1221892080809121</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>) } result = r }</code> </pre> <br>  Di sini kompiler tidak akan tahu apakah panggilan itu menciptakan efek samping.  Karena itu, tolok ukurnya akan akurat. <br><br><h3>  Pointer!  Pointer ada di mana-mana! </h3><br>  Melewati variabel dengan nilai akan membuat salinan variabel ini.  Saat melewati pointer, cukup salin alamat ke memori. <br><br>  Akibatnya, melewati pointer akan selalu lebih cepat, bukan? <br><br>  Jika Anda berpikir begitu, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh ini</a> .  Ini adalah patokan untuk struktur data 0,3 KB yang pertama kali kami kirim dan terima dengan penunjuk, lalu menurut nilainya.  0,3 KB sedikit - tentang struktur data yang biasa kami kerjakan setiap hari menempati sebanyak itu. <br><br>  Ketika saya menjalankan tes ini di lingkungan lokal, transmisi nilai demi nilai lebih dari 4 kali lebih cepat.  Sangat tak terduga, bukan? <br><br>  Penjelasan hasil ini terkait dengan pemahaman tentang bagaimana manajemen memori terjadi di Go.  Saya tidak bisa menjelaskannya secemerlang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">William Kennedy</a> , tapi mari kita simpulkan secara singkat. <br><br>  Sebuah variabel dapat ditempatkan di heap atau stack: <br><ul><li>  Tumpukan berisi variabel saat ini dari program ini.  Segera setelah fungsi kembali, variabel muncul dari tumpukan. </li><li>  Tumpukan berisi variabel umum (variabel global, dll.). </li></ul><br>  Mari kita lihat contoh sederhana di mana kita mengembalikan nilai: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return result }</span></span></code> </pre> <br>  Di sini variabel hasil dibuat oleh goroutine saat ini.  Variabel ini didorong ke tumpukan saat ini.  Segera setelah fungsi kembali, klien akan menerima salinan variabel ini.  Variabel itu sendiri muncul dari tumpukan.  Itu masih ada dalam memori sampai variabel lain ditimpa, tetapi tidak dapat diakses lagi. <br>  Sekarang contoh yang sama, tetapi dengan pointer: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFooPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result foo <span class="hljs-comment"><span class="hljs-comment">// Do something return &amp;result }</span></span></code> </pre> <br>  Variabel hasil masih dibuat oleh goroutine saat ini, tetapi klien akan menerima pointer (salinan alamat variabel).  Jika variabel hasil muncul dari tumpukan, klien fungsi ini tidak akan dapat mengaksesnya. <br><br>  Dalam skenario ini, kompilator Go akan menampilkan variabel hasil ke tempat variabel dapat dibagi, yaitu  dalam banyak. <br><br>  Script lain untuk melewati pointer: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := &amp;foo{} f(p) }</code> </pre> <br>  Karena kita memanggil f dalam program yang sama, variabel p tidak perlu ditumpuk.  Ini hanya didorong ke stack, dan subfungsi dapat mengaksesnya. <br><br>  Misalnya, dengan cara ini sepotong diperoleh dalam metode Baca dari io.Reader.  Mengembalikan slice (yang merupakan pointer) meletakkannya di heap. <br><br>  Mengapa tumpukan itu begitu cepat?  Ada dua alasan: <br><ul><li>  Tidak perlu menggunakan pengumpul sampah di tumpukan.  Seperti yang telah kami katakan, variabel hanya didorong setelah dibuat, dan kemudian muncul dari tumpukan ketika fungsi kembali.  Tidak perlu membangkitkan proses yang rumit untuk mengembalikan variabel yang tidak digunakan, dll. </li><li>  Tumpukan milik satu goroutine, sehingga penyimpanan variabel tidak perlu disinkronkan, seperti yang terjadi dengan penyimpanan di heap, yang juga mengarah pada peningkatan kinerja. </li></ul><br>  Kesimpulannya, saat kita membuat fungsi, tindakan default kita seharusnya menggunakan nilai alih-alih pointer.  Pointer hanya boleh digunakan jika kita ingin membagikan variabel. <br><br>  Juga, jika kita menderita masalah kinerja, salah satu optimasi yang mungkin dilakukan adalah memeriksa apakah pointer membantu dalam situasi tertentu?  Apakah kompiler menampilkan variabel ke heap dapat ditemukan dengan perintah berikut: <pre> <code class="bash hljs">go build -gcflags <span class="hljs-string"><span class="hljs-string">"-m -m"</span></span></code> </pre>  . <br>  Tetapi, sekali lagi, untuk sebagian besar tugas kita sehari-hari, menggunakan nilai adalah yang terbaik. <br><br><h3>  Batalkan untuk / beralih atau untuk / pilih </h3><br>  Apa yang terjadi dalam contoh berikut jika f mengembalikan true? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> f() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Do something } }</span></span></code> </pre> <br>  Kami menyebutnya istirahat.  Hanya istirahat ini yang memecah saklar, bukan untuk loop. <br><br>  Masalah yang sama di sini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break } }</span></span></code> </pre> <br>  Break dikaitkan dengan pernyataan pilih, bukan untuk loop. <br><br>  Salah satu solusi yang mungkin untuk mengganggu / beralih atau untuk / pilih adalah dengan menggunakan label: <br><br><pre> <code class="go hljs">loop: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-ch: <span class="hljs-comment"><span class="hljs-comment">// Do something case &lt;-ctx.Done(): break loop } }</span></span></code> </pre> <br><h3>  Menangani kesalahan </h3><br>  Go masih muda, terutama di bidang penanganan kesalahan.  Mengatasi kekurangan ini adalah salah satu inovasi yang paling diantisipasi di Go 2. <br><br>  Perpustakaan standar saat ini (sebelum Go 1.13) hanya menawarkan fungsi untuk membangun kesalahan.  Oleh karena itu, akan menarik untuk melihat pada paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>pkg / error</i></a> . <br><br>  Perpustakaan ini adalah cara yang baik untuk mengikuti aturan yang tidak selalu dihormati: <br><blockquote>  Kesalahan harus diproses hanya sekali.  Kesalahan logging adalah penanganan kesalahan </blockquote>  .  Dengan demikian, kesalahan harus dicatat atau dilemparkan lebih tinggi. <br><br>  Dalam pustaka standar saat ini, prinsip ini sulit untuk diamati, karena kita mungkin ingin menambahkan konteks ke kesalahan dan memiliki semacam hierarki. <br><br>  Mari kita lihat contoh dengan panggilan REST yang mengarah ke kesalahan basis data: <br><br><pre> <code class="bash hljs">unable to server HTTP POST request <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> customer 1234 |_ unable to insert customer contract abcd |_ unable to commit transaction</code> </pre><br>  Jika kita menggunakan pkg / kesalahan, kita dapat melakukan hal berikut: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do something then fail return errors.New("unable to commit transaction") }</span></span></code> </pre> <br>  Kesalahan awal (jika tidak dikembalikan oleh perpustakaan eksternal) dapat dibuat menggunakan kesalahan. Baru.  Lapisan tengah, masukkan, bungkus kesalahan ini, tambahkan lebih banyak konteks untuknya.  Kemudian orang tua mencatatnya.  Dengan demikian, setiap level akan mengembalikan atau memproses kesalahan. <br><br>  Kami mungkin juga ingin menemukan penyebab kesalahan, misalnya, untuk menelepon kembali.  Misalkan kita memiliki paket db dari perpustakaan eksternal yang memiliki akses ke database.  Perpustakaan ini dapat mengembalikan kesalahan sementara yang disebut db.DBError.  Untuk menentukan apakah kita perlu mencoba lagi, kita harus menentukan penyebab kesalahan: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(customer Customer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Status</span></span></span></span> { err := insert(customer.Contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err).(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(contract Contract)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := db.dbQuery(contract) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to insert customer contract %s"</span></span>, contract.ID) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Ini dilakukan dengan menggunakan kesalahan. Penyebab, yang juga termasuk dalam <i>pkg / kesalahan</i> : <br><br>  Salah satu kesalahan umum yang saya temui adalah penggunaan <i>pkg / kesalahan</i> hanya sebagian.  Pemeriksaan kesalahan, misalnya, dilakukan sebagai berikut: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: log.WithError(err).Errorf(<span class="hljs-string"><span class="hljs-string">"unable to server HTTP POST request for customer %s"</span></span>, customer.ID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status{ok: <span class="hljs-literal"><span class="hljs-literal">false</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *db.DBError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retry(customer) }</code> </pre> <br>  Dalam contoh ini, jika db.DBError dibungkus, itu tidak akan pernah membuat panggilan kedua. <br><br><h3>  Inisialisasi irisan </h3><br>  Terkadang kita tahu berapa panjang akhir irisan itu.  Sebagai contoh, misalkan kita ingin mengubah irisan Foo menjadi irisan Bar, yang berarti kedua irisan ini akan memiliki panjang yang sama. <br><br>  Saya sering menemukan irisan yang diinisialisasi dengan cara ini: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bars []Bar bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Iris bukanlah struktur magis.  Di bawah tenda, ia menerapkan strategi untuk meningkatkan ukuran jika tidak ada lagi ruang kosong.  Dalam hal ini, array baru dibuat secara otomatis (dengan kapasitas lebih besar), dan semua elemen disalin ke sana. <br><br>  Sekarang mari kita bayangkan bahwa kita perlu mengulangi operasi peningkatan ukuran ini beberapa kali, karena [] Foo kita mengandung ribuan elemen.  Kompleksitas algoritma penyisipan akan tetap O (1), tetapi dalam praktiknya ini akan mempengaruhi kinerja. <br><br>  Karena itu, jika kita mengetahui panjang akhir, kita dapat: <br><br><ul><li>  Inisialisasi dengan panjang yang telah ditentukan: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars[i] = fooToBar(foo) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br><ul><li>  Atau inisialisasi dengan panjang 0 dan kapasitas yang telah ditentukan: </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(foos []Foo)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span></span> { bars := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Bar, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(foos)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, foo := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> foos { bars = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bars, fooToBar(foo)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bars }</code> </pre> <br>  Apa pilihan terbaik?  Yang pertama sedikit lebih cepat.  Namun, Anda dapat memilih yang terakhir, karena lebih konsisten: terlepas dari apakah kami tahu ukuran awal, menambahkan elemen di akhir irisan dilakukan menggunakan append. <br><br><h3>  Manajemen konteks </h3><br>  context.Context sering disalahpahami oleh pengembang.  Menurut dokumentasi resmi: <br><blockquote>  Konteksnya membawa tenggat waktu, membatalkan sinyal, dan nilai-nilai lain melintasi batas API. <br>  Deskripsi ini cukup umum, karena itu dapat membingungkan programmer bagaimana menggunakannya dengan benar. </blockquote><br>  Mari kita coba mencari tahu.  Konteks dapat membawa: <br><ul><li>  Batas waktu - berarti durasi (misalnya, 250 ms) atau tanggal-waktu (misalnya, 2019-01-08 01:00:00), yang menurut kami percaya bahwa jika tercapai, tindakan saat ini harus dibatalkan (permintaan I / O ), menunggu input saluran, dll.). </li><li>  Batalkan sinyal (pada dasarnya &lt;-chan struct {}).  Di sini perilakunya mirip.  Segera setelah kami menerima sinyal, kami harus menghentikan pekerjaan saat ini.  Sebagai contoh, katakanlah kita mendapatkan dua permintaan.  Satu untuk memasukkan data, dan yang lainnya untuk membatalkan permintaan pertama (karena tidak lagi relevan, misalnya).  Ini dapat dicapai dengan menggunakan konteks yang dibatalkan pada panggilan pertama, yang kemudian akan dibatalkan segera setelah kami menerima permintaan kedua. </li><li>  Daftar kunci / nilai (keduanya berdasarkan pada antarmuka {} type). </li></ul><br>  Dua poin lagi.  Pertama, konteksnya komposable.  Karenanya, kami mungkin memiliki konteks yang memuat tenggat waktu dan daftar kunci / nilai, misalnya.  Selain itu, beberapa goroutine dapat berbagi konteks yang sama, sehingga sinyal batal berpotensi menghentikan beberapa pekerjaan. <br><br>  Kembali ke topik kita, inilah kesalahan yang saya temui. <br><br>  Aplikasi Go didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>urfave / cli</i></a> (jika Anda tidak tahu, ini adalah perpustakaan yang baik untuk membuat aplikasi baris perintah di Go).  Setelah diluncurkan, pengembang mewarisi semacam konteks aplikasi.  Ini berarti bahwa ketika aplikasi dihentikan, perpustakaan akan menggunakan konteks untuk mengirim sinyal batal. <br><br>  Saya perhatikan bahwa konteks ini ditransmisikan secara langsung, misalnya, ketika titik akhir gRPC dipanggil.  Ini sama sekali bukan yang kita butuhkan. <br><br>  Sebagai gantinya, kami ingin memberi tahu perpustakaan gRPC: harap batalkan permintaan saat aplikasi dihentikan, atau setelah 100 ms, misalnya. <br><br>  Untuk mencapai ini, kita cukup membuat konteks gabungan.  Jika orang tua adalah nama konteks aplikasi (dibuat oleh <i>urfave / cli</i> ), maka kita bisa melakukan ini: <br><br><pre> <code class="go hljs">ctx, cancel := context.WithTimeout(parent, <span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) response, err := grpcClient.Send(ctx, request)</code> </pre> <br>  Konteksnya tidak begitu sulit untuk dipahami, dan, menurut saya, ini adalah salah satu fitur terbaik dari bahasa tersebut. <br><br><h3>  Tidak menggunakan opsi -race </h3><br>  Menguji aplikasi Go tanpa opsi -race adalah bug yang selalu saya temui. <br><br>  Seperti yang ditulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel ini</a> , meskipun Go " <i>dirancang untuk membuat pemrograman paralel lebih sederhana dan lebih sedikit kesalahan,</i> " kami masih sangat menderita dari masalah konkurensi. <br><br>  Jelas, detektor ras Go tidak akan membantu dengan masalah apa pun.  Namun, ini adalah alat yang berharga, dan kita harus selalu memasukkannya saat menguji aplikasi kita. <br><br><h3>  Menggunakan nama file sebagai input </h3><br>  Kesalahan umum lainnya adalah meneruskan nama file ke suatu fungsi. <br><br>  Misalkan kita perlu mengimplementasikan fungsi untuk menghitung jumlah baris kosong dalam file.  Implementasi paling alami akan terlihat seperti ini: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() scanner := bufio.NewScanner(file) count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scanner.Text() == <span class="hljs-string"><span class="hljs-string">""</span></span> { count++ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Nama file ditetapkan sebagai input, jadi kami membukanya dan kemudian menerapkan logika kami, bukan? <br><br>  Sekarang anggaplah kita ingin membahas fungsi ini dengan unit test.  Kami akan menguji dengan file biasa, file kosong, file dengan jenis pengkodean yang berbeda, dll. Mungkin sangat sulit untuk mengelolanya. <br><br>  Selain itu, jika kita ingin menerapkan logika yang sama, misalnya, untuk badan HTTP, kita perlu membuat fungsi lain untuk ini. <br><br>  Go hadir dengan dua abstraksi hebat: io.Reader dan io.Writer.  Alih-alih meneruskan nama file, kita bisa meneruskan io.Reader, yang akan mengabstraksi sumber data. <br>  Apakah ini file?  Badan HTTP?  Buffer byte?  Itu tidak masalah, karena kita masih akan menggunakan metode Baca yang sama. <br><br>  Dalam kasus kami, kami bahkan dapat menyangga input untuk membacanya baris demi baris.  Untuk melakukan ini, Anda dapat menggunakan bufio.Reader dan metode ReadLine-nya: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader *bufio.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { count := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { line, _, err := reader.ReadLine() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to read"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io.EOF: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(line) == <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ } } }</code> </pre> <br>  Sekarang tanggung jawab untuk membuka file telah didelegasikan ke klien hitungan: <br><br><pre> <code class="go hljs">file, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrapf(err, <span class="hljs-string"><span class="hljs-string">"unable to open %s"</span></span>, filename) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> file.Close() count, err := count(bufio.NewReader(file))</code> </pre> <br>  Dalam implementasi kedua, suatu fungsi dapat dipanggil terlepas dari sumber data aktual.  Sementara itu, ini akan memudahkan pengujian unit kami, karena kami dapat dengan mudah membuat bufio.Reader dari baris: <br><br><pre> <code class="go hljs">count, err := count(bufio.NewReader(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"input"</span></span>)))</code> </pre> <br><h3>  Goroutine dan variabel siklus </h3><br>  Kesalahan umum terakhir yang saya temui adalah ketika menggunakan goroutine dengan variabel loop. <br><br>  Apa yang akan menjadi kesimpulan dari contoh berikut? <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  1 2 3 secara acak?  Tidak. <br><br>  Dalam contoh ini, setiap goroutine menggunakan instance variabel yang sama, sehingga akan menghasilkan 3 3 3 (kemungkinan besar). <br><br>  Ada dua solusi untuk masalah ini.  Yang pertama adalah meneruskan nilai variabel i ke penutup (fungsi internal): <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }(i) }</code> </pre> <br>  Yang kedua adalah membuat variabel lain di dalam for loop: <br><br><pre> <code class="go hljs">ints := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ints { i := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%v\n"</span></span>, i) }() }</code> </pre> <br>  Menetapkan i: = i mungkin tampak sedikit aneh, tetapi desain ini sangat valid.  Berada dalam satu lingkaran berarti berada dalam ruang lingkup yang berbeda.  Oleh karena itu, i: = i membuat instance lain dari variabel i.  Tentu saja, kita dapat menyebutnya dengan nama yang berbeda agar mudah dibaca. <br><br>  <i>Jika Anda mengetahui kesalahan umum lainnya, silakan menuliskannya di komentar.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461051/">https://habr.com/ru/post/id461051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461041/index.html">Bulat atau sudut akut?</a></li>
<li><a href="../id461043/index.html">Manajemen konflik dalam tindakan penyeimbangan tim atau kebutuhan vital?</a></li>
<li><a href="../id461045/index.html">Dapatkan ekstrak dari Rosreestr melalui FSIS USRN dan python. Bagian 1</a></li>
<li><a href="../id461047/index.html">Menulis atau tidak menulis. Surat kepada pihak berwenang selama acara</a></li>
<li><a href="../id461049/index.html">ONYX BOOX Faust - Dia yang mencari tidak dipaksa untuk berkeliaran</a></li>
<li><a href="../id461053/index.html">Kami menghubungkan peta online ke navigator di smartphone. Bagian 2 - kartu vektor</a></li>
<li><a href="../id461055/index.html">Tantangan Rekko 2019: bagaimana itu</a></li>
<li><a href="../id461057/index.html">Saluran telegram tentang pengembangan game</a></li>
<li><a href="../id461059/index.html">Menulis Aplikasi Android untuk Penggemar Film - Bagian 1 (Prototyping)</a></li>
<li><a href="../id461061/index.html">Paduan magnesium, batas kembar, dan pemisahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>