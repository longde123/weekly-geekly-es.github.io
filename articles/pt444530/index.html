<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📛 🙇🏽 🤹🏽 O futuro da injeção de dependência no Android 👩🏾‍🚒 🚴🏾 😥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trago à sua atenção uma tradução do artigo original de Jamie Sanson 

 Criando atividade antes do Android 9 Pie 


 A injeção de dependência (DI) é um...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O futuro da injeção de dependência no Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444530/"><p>  <sup><em>Trago à sua atenção uma tradução do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo original</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jamie Sanson</a></em></sup> <br><img src="https://habrastorage.org/getpro/habr/post_images/392/ae0/ac2/392ae0ac22d5b2d9b82a01e41d975278.jpg" alt="imagem"></p><br><h3 id="sozdanie-activity-do-android-9-pie">  Criando atividade antes do Android 9 Pie </h3><br><p> <em>A injeção de dependência (DI)</em> é um modelo comum usado em todas as formas de desenvolvimento por vários motivos.  Graças ao projeto Dagger, ele é usado como modelo usado no desenvolvimento para Android.  As mudanças recentes no Android 9 Pie nos fizeram ter agora mais opções no que diz respeito ao DI, especialmente com a nova classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>AppComponentFactory</code></a> . </p><br><hr><br><p>  DI é muito importante quando se trata de desenvolvimento moderno do Android.  Isso permite reduzir a quantidade total de código ao obter links para serviços usados ​​entre classes e geralmente divide bem o aplicativo em componentes.  Neste artigo, focaremos no Dagger 2, a biblioteca DI mais comum usada no desenvolvimento do Android.  Supõe-se que você já tenha conhecimento básico de como isso funciona, mas não é necessário entender todas as sutilezas.  Vale ressaltar que este artigo é um pouco de aventura.  Isso é interessante e tudo, mas no momento em que foi escrito, o Android 9 Pie nem apareceu no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">painel da versão da plataforma</a> , portanto esse tópico provavelmente não será relevante para o desenvolvimento cotidiano por pelo menos vários anos. </p><a name="habracut"></a><br><h3 id="vnedrenie-zavisimostey-v-android-segodnya">  Injeção de dependência no Android hoje </h3><br><p>  Simplificando, usamos o DI para fornecer instâncias de classes de “dependência” para nossas classes dependentes, ou seja, aquelas que fazem o trabalho.  Digamos que usamos o <a href="">padrão de repositório</a> para processar nossa lógica relacionada a dados e queremos usar nosso repositório em Activity para mostrar alguns dados para o usuário.  Podemos querer usar o mesmo repositório em vários lugares, portanto, usamos injeção de dependência para facilitar o compartilhamento da mesma instância entre várias classes diferentes. </p><br><p>  Primeiro, forneceremos um repositório.  Definiremos a função <code>Provides</code> no módulo, permitindo que o Dagger saiba que esta é exatamente a instância que queremos implementar.  Observe que nosso repositório precisa de uma instância de contexto para trabalhar com arquivos e a rede.  Forneceremos o contexto do aplicativo. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appContext: Context) { <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Context = appContext <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context) }</code> </pre> <br><p>  Agora precisamos definir o <code>Component</code> para lidar com a implementação das classes nas quais queremos usar nosso <code>Repository</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component(modules = [AppModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Finalmente, podemos configurar nossa <code>Activity</code> para usar nosso repositório.  Suponha que tenhamos criado uma instância do nosso <code>ApplicationComponent</code> em outro lugar. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository: Repository <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//    application.applicationComponent.inject(this) //       } }</span></span></code> </pre> <br><p>  Isso é tudo!  Acabamos de configurar a injeção de dependência no aplicativo usando o Dagger.  Existem várias maneiras de fazer isso, mas essa parece ser a abordagem mais fácil. </p><br><h3 id="chto-ne-tak-s-tekuschim-podhodom">  O que há de errado com a abordagem atual? </h3><br><p>  Nos exemplos acima, vimos dois tipos diferentes de injeções, uma mais óbvia que a outra. </p><br><p>  O primeiro que você pode ter perdido é conhecido como <strong>incorporação no construtor</strong> .  Este é um método de fornecer dependências por meio do construtor de uma classe, o que significa que uma classe que usa dependências não tem idéia sobre a origem das instâncias.  Essa é considerada a forma mais pura de injeção de dependência, pois encapsula nossa lógica de injeção em nossas classes de <code>Module</code> perfeitamente.  Em nosso exemplo, usamos essa abordagem para fornecer um repositório: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context)</code> </pre> <br><p>  Para isso, precisávamos de <code>Context</code> , que fornecemos na função <code>provideApplicationContext()</code> . </p><br><p>  A segunda coisa mais óbvia que vimos é a <strong>implementação da classe no campo</strong> .  Este método foi usado em nossa <code>MainActivity</code> para fornecer nossa loja.  Aqui, definimos os campos como destinatários das injeções usando a anotação <code>Inject</code> .  Em seguida, em nossa função <code>onCreate</code> informamos ao <code>ApplicationComponent</code> que as dependências devem ser injetadas em nossos campos.  Não parece tão limpo quanto a incorporação em um construtor, porque temos uma referência explícita ao nosso componente, o que significa que o conceito de incorporação está se infiltrando em nossas classes dependentes.  Outra falha nas classes do Android Framework, pois precisamos ter certeza de que a primeira coisa que fazemos é fornecer dependências.  Se isso acontecer no ponto errado do ciclo de vida, podemos tentar acidentalmente usar um objeto que ainda não foi inicializado. </p><br><p>  Idealmente, você deve se livrar completamente das implementações nos campos de classe.  Essa abordagem ignora as informações de implementação de classes que não precisam saber sobre isso e pode causar problemas no ciclo de vida.  Vimos tentativas de fazê-lo melhor, e o <em>Dagger</em> no Android é uma maneira bastante confiável, mas no final seria melhor se pudéssemos usar a incorporação no construtor.  Atualmente, não podemos usar essa abordagem para várias classes de estrutura, como "Atividade", "Serviço", "Aplicativo" etc., pois elas são criadas para nós pelo sistema.  Parece que, no momento, estamos presos à introdução de classes em campos.  No entanto, o Android 9 Pie está preparando algo interessante, que, talvez, mudará fundamentalmente tudo. </p><br><h3 id="vnedrenie-zavisimostey-v-android-9-pie">  Injeção de dependência no Android 9 Pie </h3><br><p>  Conforme mencionado no começo do artigo, o Android 9 Pie possui uma classe AppComponentFactory.  A documentação para isso é bastante escassa e é simplesmente postada no site do desenvolvedor, como tal: </p><br><blockquote>  <em>A interface usada para controlar a criação de elementos do manifesto.</em> </blockquote><p>  Isso é intrigante.  "Elementos manifestos" aqui se referem às classes que listamos em nosso arquivo <code>AndroidManifest</code> - como Activity, Service e nossa classe Application.  Isso nos permite "controlar a criação" desses elementos ... então, ei, agora podemos definir as regras para a criação de nossas atividades?  Que delícia! </p><br><p>  Vamos cavar mais fundo.  Começaremos estendendo o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>AppComponentFactory</code></a> e substituindo o método <code>instantiateActivity</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository = NonContextRepository() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { className == MainActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span></span>(repository) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } } }</code> </pre> <br><p>  Agora precisamos declarar nossa fábrica de componentes no manifesto dentro da tag do <strong>aplicativo</strong> . </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".InjectionApp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:appComponentFactory</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.mypackage.injectiontest.component.InjectionComponentFactory"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tools:replace</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:appComponentFactory"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Finalmente, podemos lançar nosso aplicativo ... e funciona!  Nosso <code>NonContextRepository</code> fornecido por meio do construtor MainActivity.  Graciosamente! </p><br><p>  Por favor, note que existem algumas reservas.  Não podemos usar o <code>Context</code> aqui, pois mesmo antes de sua existência, ocorre uma chamada para nossa função - isso é confuso!  Podemos ir além para que o construtor implemente nossa classe Application, mas vamos ver como o Dagger pode tornar isso ainda mais fácil. </p><br><h3 id="vstrechayte--dagger-multi-binds">  Conheça - Dagger Multi-Binds </h3><br><p>  Não entrarei em detalhes da operação de ligação múltipla do Dagger sob o capô, pois isso está além do escopo deste artigo.  Tudo que você precisa saber é que ele fornece uma boa maneira de injetar no construtor de classe sem precisar chamar manualmente o construtor.  Podemos usar isso para implementar facilmente classes de estrutura de maneira escalável.  Vamos ver como tudo isso se soma. </p><br><p>  Vamos configurar nossa Atividade primeiro para descobrir para onde ir a seguir. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: NonContextRepository ): Activity() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//       } }</span></span></code> </pre> <br><p>  Isso mostra imediatamente que quase <em>não há</em> menção à injeção de dependência.  A única coisa que vemos é a anotação <code>Inject</code> antes do construtor. </p><br><p>  Agora você precisa alterar o componente e o módulo Dagger: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component(modules = [ApplicationModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(factory: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">InjectionComponentFactory</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module(includes = [ComponentModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: NonContextRepository = NonContextRepository() }</code> </pre> <br><p>  Nada mudou muito.  Agora, precisamos apenas implementar nossa fábrica de componentes, mas como criamos nossos elementos manifestos?  Aqui precisamos de um <code>ComponentModule</code> .  Vamos ver: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@IntoMap</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentKey(MainActivity::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindMainActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Any <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindComponentHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(componentHelper: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ComponentHelper</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ComponentInstanceHelper } <span class="hljs-meta"><span class="hljs-meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span></span> <span class="hljs-meta"><span class="hljs-meta">@MapKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentKey</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clazz: KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;)</code> </pre> <br><p>  Sim, bem, apenas algumas anotações.  Aqui, conectamos nossa <code>Activity</code> a um mapa, implementamos esse mapa em nossa classe <code>ComponentHelper</code> e fornecemos esse <code>ComponentHelper</code> - tudo em duas instruções <code>Binds</code> .  O Dagger sabe como instanciar nossa <code>MainActivity</code> graças à anotação <code>MainActivity</code> <code>Inject</code> para que ele possa "vincular" o provedor a essa classe, fornecendo automaticamente as dependências que precisamos para o construtor.  Nosso <code>ComponentHelper</code> o seguinte. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> creators: Map&lt;Class&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;, <span class="hljs-meta"><span class="hljs-meta">@JvmSuppressWildcards</span></span> Provider&lt;Any&gt;&gt; ): ComponentInstanceHelper { <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UNCHECKED_CAST"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? = creators .filter { it.key.name == className } .values .firstOrNull() ?.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstanceComponentHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? }</code> </pre> <br><p>  Simplificando, agora temos um mapa de classes para fornecedores dessas classes.  Quando tentamos resolver uma classe pelo nome, simplesmente encontramos o provedor dessa classe (se tivermos uma), chamamos para obter uma nova instância dessa classe e a retornamos. </p><br><p>  Finalmente, precisamos fazer alterações em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>AppComponentFactory</code></a> para usar nossa nova classe auxiliar. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> componentHelper: ComponentInstanceHelper <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { DaggerApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentHelper .resolve&lt;Activity&gt;(className) ?.apply { setIntent(intent) } ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } }</code> </pre> <br><p>  Execute o código novamente.  Tudo funciona!  Que delícia. </p><br><h3 id="problemy-vnedreniya-v-konstruktor">  Problemas de implementação do construtor </h3><br><p>  Esse título pode não parecer muito impressionante.  Embora possamos incorporar a maioria das instâncias no modo normal injetando-as no construtor, não temos uma maneira óbvia de fornecer contexto para nossas dependências de maneira padrão.  Mas o <code>Context</code> no Android é tudo.  É necessário para acessar configurações, rede, configuração de aplicativos e muito mais.  Nossas dependências geralmente são coisas que usam serviços relacionados a dados, como rede e configurações.  Podemos contornar isso reescrevendo nossas dependências para serem funções puras ou inicializando tudo com instâncias de contexto em nossa classe <code>Application</code> , mas é preciso muito mais trabalho para determinar a melhor maneira de fazer isso. </p><br><p>  Outra desvantagem dessa abordagem é a definição de escopo.  No Dagger, um dos principais conceitos para implementar a injeção de dependência de alto desempenho com uma boa separação de relacionamentos de classe é a modularidade do gráfico de objetos e o uso do escopo.  Embora essa abordagem não proíba o uso de módulos, ela limita o uso do escopo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>AppComponentFactory</code></a> existe em um nível completamente diferente de abstração em relação às nossas classes de estrutura padrão - não podemos obter um link para ele programaticamente, portanto, não temos como instruí-lo a fornecer dependências para o <code>Activity</code> em um escopo diferente. </p><br><p>  Existem muitas maneiras de resolver nossos problemas com escopos na prática, uma das quais é usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>FragmentFactory</code></a> para incorporar nossos fragmentos no construtor com escopos.  Não entrarei em detalhes, mas agora temos um método para controlar a criação de fragmentos, que não apenas nos dá uma liberdade muito maior em termos de escopo, mas também tem compatibilidade com versões anteriores. </p><br><h3 id="zaklyuchenie">  Conclusão </h3><br><p>  O Android 9 Pie introduziu uma maneira de usar a incorporação no construtor para fornecer dependências em nossas classes de estrutura, como "Atividade" e "Aplicativo".  Vimos que, com a <em>Dagger Multi-binding,</em> podemos facilmente fornecer dependências no nível do aplicativo. </p><br><p>  Um construtor que implementa todos os nossos componentes é extremamente atraente, e podemos até fazer algo para fazê-lo funcionar corretamente com instâncias de contexto.  Este é um futuro promissor, mas está disponível apenas a partir da API 28. Se você deseja atingir menos de 0,5% dos usuários, pode experimentá-lo.  Caso contrário, você deve esperar e ver se esse método permanece relevante em alguns anos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444530/">https://habr.com/ru/post/pt444530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444520/index.html">2. Introdução ao Ponto de Verificação R80.20. Arquitetura da solução</a></li>
<li><a href="../pt444522/index.html">Apocalipse é cancelado</a></li>
<li><a href="../pt444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../pt444526/index.html">Pilha de DOTS: C ++ e C #</a></li>
<li><a href="../pt444528/index.html">Situação: o Japão pode limitar o download de conteúdo da rede - entendemos e discutimos</a></li>
<li><a href="../pt444534/index.html">Verificação de vulnerabilidades e desenvolvimento seguro. Parte 1</a></li>
<li><a href="../pt444536/index.html">MVCC-2. Camadas, arquivos, páginas</a></li>
<li><a href="../pt444540/index.html">Intel está pronta para começar a produção de memória MRAM</a></li>
<li><a href="../pt444542/index.html">Transmissão ao vivo e programação de conferências para SmartMail Conf: Machine Learning</a></li>
<li><a href="../pt444544/index.html">Algo sobre data centers distribuídos para empresas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>