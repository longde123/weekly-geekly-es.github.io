<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐪 🏔️ 🔶 Mengurai ekspresi lambda di Jawa 👨‍👨‍👧‍👦 👼 🏴󠁧󠁢󠁳󠁣󠁴󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari seorang penerjemah: LambdaMetafactory mungkin adalah salah satu mekanisme Java 8. yang paling diremehkan Kami baru-baru ini menemukannya, tetapi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengurai ekspresi lambda di Jawa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/432418/"><p><img src="https://habrastorage.org/webt/nh/bc/r2/nhbcr2a_t-abgnja2uip1sl-uki.jpeg" alt="gambar"></p><br><p>  <em>Dari seorang penerjemah: LambdaMetafactory mungkin adalah salah satu mekanisme Java 8. yang paling diremehkan Kami baru-baru ini menemukannya, tetapi sudah menghargai kemampuannya.</em>  <em>Versi 7.0 dari kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA</a> meningkatkan kinerja dengan menghindari panggilan reflektif untuk menghasilkan ekspresi lambda.</em>  <em>Salah satu aplikasi dari mekanisme ini dalam kerangka kerja kami adalah pengikatan penangan event aplikasi dengan anotasi, tugas umum, analog dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">EventListener</a> dari Spring.</em>  <em>Kami percaya bahwa pengetahuan tentang prinsip-prinsip LambdaFactory dapat berguna di banyak aplikasi Java, dan kami segera berbagi terjemahan ini dengan Anda.</em> </p><br><p> Pada artikel ini, kami akan menunjukkan beberapa trik yang kurang dikenal ketika bekerja dengan ekspresi lambda di Java 8 dan keterbatasan ekspresi ini.  Target pembaca artikel ini adalah pengembang senior Java, peneliti dan pengembang toolkit.  Hanya Java API publik yang akan digunakan tanpa <code>com.sun.*</code> Dan kelas internal lainnya, sehingga kodenya portabel di antara berbagai implementasi JVM. </p><a name="habracut"></a><br><h3 id="korotkoe-predislovie">  Kata Pengantar </h3><br><p>  Ekspresi Lambda muncul di Java 8 sebagai cara untuk menerapkan metode anonim dan, <br>  dalam beberapa kasus, sebagai alternatif untuk kelas anonim.  Pada level bytecode, ekspresi lambda digantikan oleh <code>invokedynamic</code> .  Instruksi ini digunakan untuk membuat implementasi antarmuka fungsional dan satu-satunya metode mendelegasikan panggilan ke metode aktual, yang berisi kode yang didefinisikan dalam tubuh ekspresi lambda. </p><br><p>  Misalnya, kami memiliki kode berikut: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; strings)</span></span></span></span>{ strings.forEach(item -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Item = %s"</span></span>, item)); }</code> </pre> <br><p>  Kode ini akan dikonversi oleh kompiler Java menjadi sesuatu yang mirip dengan: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Java  System.out.println("Item = %s", item); } private static CallSite bootstrapLambda(Lookup lookup, String name, MethodType type) { // //lookup =  VM //name = "lambda_forEach",  VM //type = String -&gt; void MethodHandle lambdaImplementation = lookup.findStatic(lookup.lookupClass(), name, type); return LambdaMetafactory.metafactory(lookup, "accept", MethodType.methodType(Consumer.class), //  - MethodType.methodType(void.class, Object.class), //  Consumer.accept    lambdaImplementation, //     - type); } void printElements(List&lt;String&gt; strings) { Consumer&lt;String&gt; lambda = invokedynamic# bootstrapLambda, #lambda_forEach strings.forEach(lambda); }</span></span></code> </pre> <br><p>  Instruksi <code>invokedynamic</code> dapat secara kasar direpresentasikan sebagai kode Java seperti itu: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite cs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; strings)</span></span></span><span class="hljs-function"> </span></span>{ Consumer&lt;String&gt; lambda; <span class="hljs-comment"><span class="hljs-comment">//begin invokedynamic if (cs == null) cs = bootstrapLambda(MethodHandles.lookup(), "lambda_forEach", MethodType.methodType(void.class, String.class)); lambda = (Consumer&lt;String&gt;)cs.getTarget().invokeExact(); //end invokedynamic strings.forEach(lambda); }</span></span></code> </pre> <br><p>  Seperti yang Anda lihat, <code>LambdaMetafactory</code> digunakan untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CallSite</a> yang menyediakan metode pabrik yang mengembalikan penangan untuk metode target.  Metode ini mengembalikan implementasi antarmuka fungsional menggunakan <code>invokeExact</code> .  Jika ada variabel yang ditangkap dalam ekspresi lambda, maka <code>invokeExact</code> menerima variabel-variabel ini sebagai parameter aktual. </p><br><p>  Di Oracle JRE 8, metafactory secara dinamis menghasilkan kelas Java menggunakan ObjectWeb Asm, yang menciptakan kelas yang mengimplementasikan antarmuka fungsional.  Bidang tambahan dapat ditambahkan ke kelas yang dibuat jika ekspresi lambda menangkap variabel eksternal.  Yang ini terlihat seperti kelas anonim Java, tetapi ada perbedaan berikut: </p><br><ul><li>  Kelas anonim dihasilkan oleh kompiler Java. </li><li>  Kelas untuk mengimplementasikan ekspresi lambda dibuat oleh JVM pada saat run time. </li></ul><br><hr><br><p>  <strong>Implementasi metafactory tergantung pada vendor dan versi JVM</strong> </p><br><hr><br><p>  Tentu saja, <code>invokedynamic</code> tidak hanya digunakan untuk ekspresi lambda di Jawa.  Ini terutama digunakan ketika menjalankan bahasa dinamis di lingkungan JVM.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin</a> JavaScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nashorn</a> , yang dibangun di Jawa, memanfaatkan instruksi ini secara intensif. </p><br><p>  Selanjutnya, kita akan fokus pada kelas <code>LambdaMetafactory</code> dan kemampuannya.  Selanjutnya <br>  Bagian dari artikel ini mengasumsikan bahwa Anda mengerti betul bagaimana metode metafactory bekerja dan apa itu <code>MethodHandle</code> </p><br><h2 id="tryuki-s-lyambda-vyrazheniyami">  Trik dengan ekspresi lambda </h2><br><p>  Pada bagian ini, kami akan menunjukkan cara membangun lambda dinamis untuk digunakan dalam tugas sehari-hari. </p><br><h3 id="proveryaemye-isklyucheniya-i-lyambdy">  Pengecualian dan lambda yang diperiksa </h3><br><p>  Bukan rahasia lagi bahwa semua antarmuka fungsional yang ada di Jawa tidak mendukung pengecualian yang diperiksa.  Keuntungan dari pengecualian yang diperiksa dibandingkan yang biasa adalah perdebatan yang sudah berlangsung lama (dan masih panas). </p><br><p>  Tetapi bagaimana jika Anda perlu menggunakan kode dengan pengecualian diperiksa di dalam ekspresi lambda dalam kombinasi dengan Java Streams?  Misalnya, Anda perlu mengonversi daftar string ke daftar URL seperti ini: </p><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"http://localhost/"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://github.com"</span></span>).stream() .map(URL::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) .collect(Collectors.toList())</code> </pre> <br><p>  Pengecualian yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibuang</a> dideklarasikan dalam konstruktor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">URL (String)</a> , sehingga tidak dapat digunakan secara langsung sebagai referensi metode di kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Functiion</a> . </p><br><p>  Anda akan berkata: "Tidak, mungkin jika Anda menggunakan trik ini di sini": </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uncheckCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;T&gt; callable)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callable.call(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sneakyThrow(e); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E extends Throwable, T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sneakyThrow0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> E </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (E)t; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sneakyThrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Util.&lt;RuntimeException, T&gt;sneakyThrow0(e); } <span class="hljs-comment"><span class="hljs-comment">//   //return s.filter(a -&gt; uncheckCall(a::isActive)) // .map(Account::getNumber) // .collect(toSet());</span></span></code> </pre> <br><p>  Ini adalah hack yang kotor.  Dan inilah alasannya: </p><br><ul><li>  Blok try-catch digunakan. </li><li>  Pengecualian dilemparkan lagi. </li><li>  Penggunaan tipe erasure yang kotor di Jawa. </li></ul><br><p>  Masalahnya dapat diselesaikan dengan cara yang lebih "legal", menggunakan pengetahuan tentang fakta-fakta berikut: </p><br><ul><li>  Pengecualian yang diperiksa hanya dikenali pada tingkat kompiler Java. </li><li>  Bagian <code>throws</code> hanya metadata untuk metode tanpa nilai semantik di tingkat JVM. </li><li>  Pengecualian yang diperiksa dan normal tidak dapat dibedakan pada tingkat bytecode di JVM. </li></ul><br><p>  Solusinya adalah dengan membungkus metode <code>Callable.call</code> dalam metode tanpa bagian <code>throws</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;V&gt; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callUnchecked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;V&gt; callable)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callable.call(); }</code> </pre> <br><p>  Kode ini tidak dikompilasi karena metode <code>Callable.call</code> menyatakan pengecekan pengecualian di bagian <code>throws</code> .  Tetapi kita dapat menghapus bagian ini menggunakan ekspresi lambda yang dibangun secara dinamis. </p><br><p>  Pertama kita perlu mendeklarasikan antarmuka fungsional yang tidak memiliki bagian <code>throws</code> . <br>  tetapi siapa yang akan dapat mendelegasikan panggilan ke <code>Callable.call</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SilentInvoker</span></span></span><span class="hljs-class"> </span></span>{ MethodType SIGNATURE = MethodType.methodType(Object.class, Callable.class);<span class="hljs-comment"><span class="hljs-comment">//  INVOKE &lt;V&gt; V invoke(final Callable&lt;V&gt; callable); }</span></span></code> </pre> <br><p>  Langkah kedua adalah membuat implementasi antarmuka ini menggunakan <code>LambdaMetafactory</code> dan mendelegasikan panggilan metode <code>SilentInvoker.invoke</code> ke metode <code>Callable.call</code> .  Seperti disebutkan sebelumnya, bagian <code>throws</code> diabaikan pada level bytecode, sehingga metode <code>SilentInvoker.invoke</code> dapat memanggil metode <code>Callable.call</code> tanpa mendeklarasikan pengecualian: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SilentInvoker SILENT_INVOKER; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandles.Lookup lookup = MethodHandles.lookup(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"invoke"</span></span>, MethodType.methodType(SilentInvoker.class), SilentInvoker.SIGNATURE, lookup.findVirtual(Callable.class, <span class="hljs-string"><span class="hljs-string">"call"</span></span>, MethodType.methodType(Object.class)), SilentInvoker.SIGNATURE); SILENT_INVOKER = (SilentInvoker) site.getTarget().invokeExact();</code> </pre> <br><p>  Ketiga, kami menulis metode pembantu yang memanggil <code>Callable.call</code> tanpa menyatakan pengecualian: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;V&gt; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callUnchecked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Callable&lt;V&gt; callable)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*no throws*/</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SILENT_INVOKER.invoke(callable); }</code> </pre> <br><p>  Sekarang Anda dapat menulis ulang streaming tanpa masalah dengan pengecualian yang dicentang: </p><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"http://localhost/"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://dzone.com"</span></span>).stream() .map(url -&gt; callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(url))) .collect(Collectors.toList());</code> </pre> <br><p>  Kode ini dikompilasi tanpa masalah karena <code>callUnchecked</code> tidak menyatakan pengecualian yang diperiksa.  Selain itu, memanggil metode ini dapat digarisbawahi menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">caching inline monomorfik</a> , karena hanya satu kelas di seluruh JVM yang mengimplementasikan antarmuka <code>SilentOnvoker</code> </p><br><p>  Jika implementasi <code>Callable.call</code> melempar pengecualian pada saat run time, maka itu akan <code>Callable.call</code> oleh fungsi panggilan tanpa masalah: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"Invalid URL"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Exception e){ System.out.println(e); }</code> </pre> <br><p>  Terlepas dari kemungkinan metode ini, Anda harus selalu mengingat rekomendasi berikut: </p><br><hr><br><p>  <strong>Sembunyikan pengecualian yang dicentang dengan callUnchecked hanya jika Anda yakin kode yang dipanggil tidak akan membuang pengecualian apa pun</strong> </p><br><hr><br><p>  Contoh berikut menunjukkan contoh pendekatan ini: </p><br><pre> <code class="java hljs">callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"https://dzone.com"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// URL        MalformedURLException</span></span></code> </pre> <br><p>  Implementasi penuh dari metode ini ada di <a href="">sini</a> , ini adalah bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SNAMP</a> . </p><br><h3 id="rabotaem-s-getters-i-setters">  Bekerja dengan Getters and Setters </h3><br><p>  Bagian ini akan berguna bagi mereka yang menulis serialisasi / deserialisasi untuk berbagai format data seperti JSON, Thrift, dll.  Selain itu, ini bisa sangat berguna jika kode Anda sangat bergantung pada refleksi untuk Getters and Setters di JavaBeans. </p><br><p>  Seorang pengambil yang dideklarasikan di JavaBean adalah metode bernama <code>getXXX</code> tanpa parameter dan tipe data kembali selain <code>void</code> .  Setter yang dideklarasikan di JavaBean adalah metode bernama <code>setXXX</code> , dengan satu parameter dan mengembalikan <code>void</code> .  Dua notasi ini dapat direpresentasikan sebagai antarmuka fungsional: </p><br><ul><li>  Getter dapat diwakili oleh kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Function</a> , di mana argumennya adalah nilai dari <code>this</code> . </li><li>  Setter dapat diwakili oleh kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BiConsumer</a> , di mana argumen pertama adalah <code>this</code> , dan yang kedua adalah nilai yang diteruskan ke Setter. </li></ul><br><p>  Sekarang kita akan membuat dua metode yang dapat mengubah setiap pengambil atau penyetel menjadi ini <br>  antarmuka fungsional.  Dan tidak masalah bahwa kedua antarmuka adalah generik.  Setelah menghapus tipe <br>  tipe data nyata adalah <code>Object</code> .  Pengecoran tipe kembali dan argumen otomatis dapat dilakukan menggunakan <code>LambdaMetafactory</code> .  Selain itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan Guava</a> akan membantu dengan caching ekspresi lambda untuk getter dan setter yang sama. </p><br><p>  Langkah pertama: buat cache untuk getter dan setter.  Kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode</a> API Refleksi mewakili pengambil atau penyetel nyata dan digunakan sebagai kunci. <br>  Nilai cache adalah antarmuka fungsional yang dibangun secara dinamis untuk pengambil atau penyetel tertentu. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache&lt;Method, Function&gt; GETTERS = CacheBuilder.newBuilder().weakValues().build(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache&lt;Method, BiConsumer&gt; SETTERS = CacheBuilder.newBuilder().weakValues().build();</code> </pre> <br><p>  Kedua, kita akan membuat metode pabrik yang membuat instance dari antarmuka fungsional berdasarkan referensi ke pengambil atau penyetel. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandle getter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(Function.class), MethodType.methodType(Object.class, Object.class), <span class="hljs-comment"><span class="hljs-comment">//signature of method Function.apply after type erasure getter, getter.type()); //actual signature of getter try { return (Function) site.getTarget().invokeExact(); } catch (final Exception e) { throw e; } catch (final Throwable e) { throw new Error(e); } } private static BiConsumer createSetter(final MethodHandles.Lookup lookup, final MethodHandle setter) throws Exception { final CallSite site = LambdaMetafactory.metafactory(lookup, "accept", MethodType.methodType(BiConsumer.class), MethodType.methodType(void.class, Object.class, Object.class), //signature of method BiConsumer.accept after type erasure setter, setter.type()); //actual signature of setter try { return (BiConsumer) site.getTarget().invokeExact(); } catch (final Exception e) { throw e; } catch (final Throwable e) { throw new Error(e); } }</span></span></code> </pre> <br><p>  Konversi tipe otomatis antara argumen <code>Object</code> tipe dalam antarmuka fungsional (setelah penghapusan tipe) dan tipe nyata argumen dan nilai pengembalian dicapai dengan menggunakan perbedaan antara <code>samMethodType</code> dan <code>instantiatedMethodType</code> (masing-masing argumen ketiga dan kelima dari metode metafactory).  Jenis instance metode yang dibuat - ini adalah spesialisasi metode yang menyediakan implementasi ekspresi lambda. </p><br><p>  Ketiga, kami akan membuat fasad untuk pabrik-pabrik ini dengan dukungan untuk caching: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reflectGetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method getter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GETTERS.get(getter, () -&gt; createGetter(lookup, lookup.unreflect(getter))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutionException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(e.getCause()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BiConsumer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reflectSetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method setter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SETTERS.get(setter, () -&gt; createSetter(lookup, lookup.unreflect(setter))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutionException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(e.getCause()); } }</code> </pre> <br><p>  Informasi metode yang diperoleh dari instance kelas <code>Method</code> menggunakan Java Reflection API dapat dengan mudah dikonversi ke <code>MethodHandle</code> .  Ingatlah bahwa metode instance kelas selalu memiliki argumen pertama tersembunyi yang digunakan untuk meneruskan <code>this</code> ke metode ini.  Metode statis tidak memiliki parameter seperti itu.  Misalnya, tanda tangan aktual dari metode <code>Integer.intValue()</code> terlihat seperti <code>int intValue(Integer this)</code> .  Trik ini digunakan dalam penerapan pembungkus fungsional kami untuk getter dan setter. </p><br><p>  Dan sekarang saatnya untuk menguji kodenya: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Date d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiConsumer&lt;Date, Long&gt; timeSetter = reflectSetter(MethodHandles.lookup(), Date.class.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"setTime"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.class)); timeSetter.accept(d, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">//the same as d.setTime(42L); final Function&lt;Date, Long&gt; timeGetter = reflectGetter(MethodHandles.lookup(), Date.class.getDeclaredMethod("getTime")); System.out.println(timeGetter.apply(d)); //the same as d.getTime() //output is 42</span></span></code> </pre> <br><p>  Pendekatan ini dengan getter dan setter yang di-cache dapat digunakan secara efektif dalam perpustakaan serialisasi / deserialisasi (seperti Jackson) yang menggunakan getter dan setter selama serialisasi dan deserialisasi. </p><br><hr><br><p>  <strong>Memanggil antarmuka fungsional dengan implementasi yang dihasilkan secara dinamis menggunakan <code>LambdaMetaFactory</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">signifikan lebih cepat</a> daripada memanggil melalui Java Reflection API</strong> </p><br><hr><br><p>  Versi lengkap kode dapat ditemukan di <a href="">sini</a> , ini adalah bagian dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SNAMP</a> . </p><br><h2 id="ogranicheniya-i-bagi">  Keterbatasan dan bug </h2><br><p>  Pada bagian ini, kita akan melihat beberapa bug dan batasan yang terkait dengan ekspresi lambda di kompiler Java dan JVM.  Semua batasan ini dapat direproduksi dalam OpenJDK dan Oracle JDK dengan <code>javac</code> versi 1.8.0_131 untuk Windows dan Linux. </p><br><h3 id="sozdanie-lyambda-vyrazheniy-iz-obrabotchikov-metodov">  Membuat ekspresi lambda dari penangan metode </h3><br><p>  Seperti yang Anda ketahui, ekspresi lambda dapat dibangun secara dinamis menggunakan <code>LambdaMetaFactory</code> .  Untuk melakukan ini, Anda perlu mendefinisikan handler - kelas <code>MethodHandle</code> , yang mengindikasikan implementasi dari satu-satunya metode yang didefinisikan dalam antarmuka fungsional.  Mari kita lihat contoh sederhana ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestClass</span></span></span><span class="hljs-class"> </span></span>{ String value = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TestClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestClass(); obj.setValue(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandles.Lookup lookup = MethodHandles.lookup(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"get"</span></span>, MethodType.methodType(Supplier.class, TestClass.class), MethodType.methodType(Object.class), lookup.findVirtual(TestClass.class, <span class="hljs-string"><span class="hljs-string">"getValue"</span></span>, MethodType.methodType(String.class)), MethodType.methodType(String.class)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; getter = (Supplier&lt;String&gt;) site.getTarget().invokeExact(obj); System.out.println(getter.get());</code> </pre> <br><p>  Kode ini setara dengan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TestClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestClass(); obj.setValue(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; elementGetter = () -&gt; obj.getValue(); System.out.println(elementGetter.get());</code> </pre> <br><p>  Tetapi bagaimana jika kita mengganti penangan metode yang menunjuk ke <code>getValue</code> dengan penangan yang mewakili bidang pengambil: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"get"</span></span>, MethodType.methodType(Supplier.class, TestClass.class), MethodType.methodType(Object.class), lookup.findGetter(TestClass.class, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, String.class), <span class="hljs-comment"><span class="hljs-comment">//field getter instead of method handle to getValue MethodType.methodType(String.class));</span></span></code> </pre> <br><p>  Kode ini seharusnya, seperti yang diharapkan, berfungsi karena <code>findGetter</code> mengembalikan penangan yang menunjuk ke bidang pengambil dan memiliki tanda tangan yang benar.  Tetapi, jika Anda menjalankan kode ini, Anda akan melihat pengecualian berikut: </p><br><pre> <code class="plaintext hljs">java.lang.invoke.LambdaConversionException: Unsupported MethodHandle kind: getField</code> </pre> <br><p>  Menariknya, pengambil untuk bidang berfungsi dengan baik jika kita menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MethodHandleProxies</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; getter = MethodHandleProxies .asInterfaceInstance(Supplier.class, lookup.findGetter(TestClass.class, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, String.class) .bindTo(obj));</code> </pre> <br><p>  Perlu dicatat bahwa <code>MethodHandleProxies</code> bukan cara yang baik untuk secara dinamis membuat ekspresi lambda, karena kelas ini hanya membungkus <code>MethodHandle</code> di kelas proxy dan mendelegasikan pemanggilanHandler.invoke ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MethodHandle.invokeWithArguments</a> .  Pendekatan ini menggunakan Java Reflection dan sangat lambat. </p><br><p>  Seperti yang ditunjukkan sebelumnya, tidak semua penangan metode dapat digunakan untuk membuat ekspresi lambda saat runtime. </p><br><hr><br><p>  <strong>Hanya beberapa jenis penangan metode yang dapat digunakan untuk secara dinamis membuat ekspresi lambda.</strong> </p><br><hr><br><p>  Inilah mereka: </p><br><ul><li>  REF_invokeInterface: dapat dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lookup.findVirtual</a> untuk metode antarmuka </li><li>  REF_invokeVirtual: dapat dibuat menggunakan Lookup.findVirtual untuk metode virtual kelas </li><li>  REF_invokeStatic: dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lookup.findStatic</a> untuk metode statis </li><li>  REF_newInvokeSpecial: dapat dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lookup.findConstructor</a> untuk konstruktor </li><li>  REF_invokeSpecial: dapat dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lookup.findSpecial</a> <br>  untuk metode pribadi dan penjilidan awal dengan metode virtual kelas </li></ul><br><p>  Jenis penangan lain akan <code>LambdaConversionException</code> kesalahan <code>LambdaConversionException</code> . </p><br><h3 id="generic-isklyucheniya">  Pengecualian Umum </h3><br><p>  Bug ini terkait dengan kompiler Java dan kemampuan untuk menyatakan pengecualian umum di bagian <code>throws</code> .  Contoh kode berikut menunjukkan perilaku ini: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtendedCallable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> E</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt; urlFactory = () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>); urlFactory.call();</code> </pre> <br><p>  Kode ini harus dikompilasi karena konstruktor dari kelas <code>URL</code> melempar <code>MalformedURLException</code> .  Tapi itu tidak dikompilasi.  Pesan kesalahan berikut ditampilkan: </p><br><pre> <code class="plaintext hljs">Error:(46, 73) java: call() in &lt;anonymous Test$CODEgt; cannot implement call() in ExtendedCallable overridden method does not throw java.lang.Exception</code> </pre> <br><p>  Tetapi, jika kita mengganti ekspresi lambda dengan kelas anonim, maka kode tersebut mengkompilasi: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt; urlFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> MalformedURLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>); } }; urlFactory.call();</code> </pre> <br><p>  Berikut dari ini: </p><br><hr><br><p>  <strong>Ketik inferensi untuk pengecualian umum tidak berfungsi dengan benar dalam kombinasi dengan ekspresi lambda</strong> </p><br><hr><br><h3 id="ogranicheniya-tipov-parametrizacii">  Keterbatasan Tipe Parameterisasi </h3><br><p>  Anda dapat membuat objek generik dengan beberapa batasan tipe menggunakan tanda <code>&amp;</code> : <code>&lt;T extends A &amp; B &amp; C &amp; ... Z&gt;</code> . <br>  Metode penentuan parameter generik ini jarang digunakan, tetapi dengan cara tertentu memengaruhi ekspresi lambda di Jawa karena beberapa batasan: </p><br><ul><li>  Setiap jenis kendala, kecuali yang pertama, harus berupa antarmuka. </li><li>  Versi murni dari kelas dengan generik seperti itu hanya memperhitungkan kendala tipe pertama dari daftar. </li></ul><br><p>  Keterbatasan kedua mengarah pada perilaku kode yang berbeda pada waktu kompilasi dan pada saat runtime, ketika pengikatan ke ekspresi lambda terjadi.  Perbedaan ini dapat ditunjukkan dengan menggunakan kode berikut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutableInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSupplier</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//mutable container of int value private int value; public MutableInteger(final int v) { value = v; } @Override public int intValue() { return value; } @Override public long longValue() { return value; } @Override public float floatValue() { return value; } @Override public double doubleValue() { return value; } @Override public int getAsInt() { return intValue(); } @Override public void accept(final int value) { this.value = value; } } static &lt;T extends Number &amp; IntSupplier&gt; OptionalInt findMinValue(final Collection &lt;T&gt; values) { return values.stream().mapToInt(IntSupplier::getAsInt).min(); } final List &lt;MutableInteger&gt; values = Arrays.asList(new MutableInteger(10), new MutableInteger(20)); final int mv = findMinValue(values).orElse(Integer.MIN_VALUE); System.out.println(mv);</span></span></code> </pre> <br><p>  Kode ini benar sekali dan berhasil dikompilasi.  Kelas <code>MutableInteger</code> memenuhi batasan tipe T generik: </p><br><ul><li>  <code>MutableInteger</code> mewarisi dari <code>Number</code> . </li><li>  <code>MutableInteger</code> mengimplementasikan <code>IntSupplier</code> . </li></ul><br><p>  Tetapi kode akan macet dengan pengecualian saat runtime: </p><br><pre> <code class="java hljs">java.lang.BootstrapMethodError: call site initialization exception at java.lang.invoke.CallSite.makeSite(CallSite.java:<span class="hljs-number"><span class="hljs-number">341</span></span>) at java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:<span class="hljs-number"><span class="hljs-number">307</span></span>) at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:<span class="hljs-number"><span class="hljs-number">297</span></span>) at Test.minValue(Test.java:<span class="hljs-number"><span class="hljs-number">77</span></span>) Caused by: java.lang.invoke.LambdaConversionException: Invalid receiver type <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span></span>; not a subtype of implementation type <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">util</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSupplier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractValidatingLambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">validateMetafactoryArgs</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractValidatingLambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:233) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">metafactory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:303) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallSite</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">makeSite</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallSite</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:302)</span></span></code> </pre> <br><p>  Ini terjadi karena pipa JavaStream hanya menangkap tipe murni, yang, dalam kasus kami, adalah kelas <code>Number</code> dan itu tidak mengimplementasikan antarmuka <code>IntSupplier</code> .  Masalah ini dapat diperbaiki dengan secara eksplisit mendeklarasikan tipe parameter dalam metode yang terpisah, digunakan sebagai referensi ke metode: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntSupplier i)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.getAsInt(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Number &amp; IntSupplier&gt; <span class="hljs-function"><span class="hljs-function">OptionalInt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findMinValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Collection&lt;T&gt; values)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values.stream().mapToInt(UtilsTest::getInt).min(); }</code> </pre> <br><p>  Contoh ini menunjukkan inferensi tipe yang salah dalam kompiler dan runtime. </p><br><hr><br><p>  <strong>Menangani beberapa batasan tipe parameter umum bersamaan dengan menggunakan ekspresi lambda pada waktu kompilasi dan pada saat runtime tidak konsisten</strong> </p><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432418/">https://habr.com/ru/post/id432418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432408/index.html">Intisari Fintech: persiapan untuk memutuskan hubungan bank kecil dari Visa dan Mastercard, kalkulator pensiun dan tidak hanya</a></li>
<li><a href="../id432410/index.html">Entitas gaya DDD dengan Entity Framework Core</a></li>
<li><a href="../id432412/index.html">Highload ++: Cara membantu sistem ERP mengatasi 500.000 permintaan per detik</a></li>
<li><a href="../id432414/index.html">Rahasia Lama untuk Debugging Cepat: Animasi Kode Sumber</a></li>
<li><a href="../id432416/index.html">Jenis Tanggungan - Masa Depan Bahasa Pemrograman</a></li>
<li><a href="../id432420/index.html">Pengantar Git Merge dan Git Rebase: Mengapa dan Kapan Menggunakannya</a></li>
<li><a href="../id432422/index.html">Mode offline di iOS dan fitur implementasinya di Realm</a></li>
<li><a href="../id432424/index.html">Infrastruktur Bersertifikat HyperFlex untuk SAP HANA</a></li>
<li><a href="../id432426/index.html">Melakukan debug bug yang tidak bisa diputar</a></li>
<li><a href="../id432428/index.html">Centralized bus vs Service Mesh: bagaimana mengubah mitap menjadi pertempuran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>