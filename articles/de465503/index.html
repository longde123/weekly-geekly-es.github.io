<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏻 🛀🏿 🛌 Tarantool Cartridge: Zerkleinern des Lua-Backends in drei Zeilen 👩🏽‍⚕️ 🛂 💆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Mail.ru Group haben wir Tarantool - dies ist ein solcher Anwendungsserver auf Lua, der auch eine Datenbank hat (oder umgekehrt?). Es ist schnell u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool Cartridge: Zerkleinern des Lua-Backends in drei Zeilen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/465503/"><img src="https://habrastorage.org/webt/zl/9w/og/zl9wogkzbdgwzzedtahlcg1f8ys.jpeg"><br><br>  Bei Mail.ru Group haben wir Tarantool - dies ist ein solcher Anwendungsserver auf Lua, der auch eine Datenbank hat (oder umgekehrt?).  Es ist schnell und cool, aber die Funktionen eines Servers sind immer noch nicht unbegrenzt.  Die vertikale Skalierung ist auch kein Allheilmittel, daher verfügt Tarantool über Werkzeuge für die horizontale Skalierung - das vshard-Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> .  Es ermöglicht Ihnen, Daten auf mehreren Servern zu teilen, aber Sie müssen daran basteln, um sie zu konfigurieren und die Geschäftslogik zu befestigen. <br><br>  Gute Nachricht: Wir haben die Kegel gesammelt (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[3]</a> ) und ein anderes Framework abgesägt, das die Lösung dieses Problems erheblich vereinfacht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge</a> ist ein neues Framework für die Entwicklung komplexer verteilter Systeme.  Sie können sich darauf konzentrieren, Geschäftslogik zu schreiben, anstatt Infrastrukturprobleme zu lösen.  Unter dem Strich werde ich Ihnen sagen, wie dieses Framework organisiert ist und wie verteilte Dienste damit geschrieben werden. <br><a name="habracut"></a><br><h2>  Und was ist eigentlich das Problem? </h2><br>  Wir haben eine Vogelspinne, es gibt Vshard - was willst du mehr? <br><br>  Erstens geht es um Bequemlichkeit.  Die Vshard-Konfiguration wird über Lua-Tabellen konfiguriert.  Damit ein verteiltes System mit mehreren Tarantool-Prozessen ordnungsgemäß funktioniert, muss die Konfiguration überall gleich sein.  Niemand möchte dies manuell tun.  Daher werden alle Arten von Skripten, Ansible und Bereitstellungssysteme verwendet. <br><br>  Cartridge selbst verwaltet die vshard-Konfiguration, basierend auf seiner <i>eigenen verteilten Konfiguration</i> .  Im Wesentlichen handelt es sich hierbei um eine einfache YAML-Datei, deren Kopie in jeder Instanz von Tarantool gespeichert ist.  Die Vereinfachung liegt in der Tatsache, dass das Framework selbst seine Konfiguration überwacht und somit überall gleich ist. <br><br>  Zweitens ist der Punkt wieder bequem.  Die Konfiguration hat keinen Bezug zur Entwicklung der Geschäftslogik und lenkt den Programmierer nur von der Arbeit ab.  Wenn wir die Architektur eines Projekts diskutieren, sprechen wir meistens über einzelne Komponenten und deren Interaktion.  Es ist noch zu früh, um über die Einführung eines Clusters in drei Rechenzentren nachzudenken. <br><br>  Wir haben diese Probleme immer wieder gelöst und irgendwann einen Ansatz entwickelt, um die Arbeit mit der Anwendung über den gesamten Lebenszyklus hinweg zu vereinfachen: Erstellung, Entwicklung, Test, CI / CD, Wartung. <br><br>  Cartridge führt das Rollenkonzept für jeden Tarantool-Prozess ein.  Rollen sind ein Konzept, mit dem sich der Entwickler auf das Schreiben von Code konzentrieren kann.  Alle im Projekt verfügbaren Rollen können auf einer Instanz von Tarantool ausgeführt werden. Dies reicht für Tests aus. <br><br>  Hauptmerkmale der Tarantool-Patrone: <br><br><ul><li>  automatisierte Cluster-Orchestrierung; <br></li><li>  Erweiterung der Anwendungsfunktionalität um neue Rollen; <br></li><li>  Anwendungsentwicklungs- und Bereitstellungsvorlage; <br></li><li>  eingebautes automatisches Sharding; <br></li><li>  Integration in das Luatest-Testframework; <br></li><li>  Clusterverwaltung über WebUI und API; <br></li><li>  Verpackungs- und Bereitstellungstools. <br></li></ul><br><h2>  Hallo Welt! </h2><br>  Ich bin gespannt darauf, das Framework selbst zu zeigen. Lassen wir also die Geschichte über Architektur für später und beginnen mit einer einfachen.  Vorausgesetzt, Tarantool selbst ist bereits installiert, bleibt nur noch etwas zu tun <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Mit diesen beiden Befehlen werden die Befehlszeilenprogramme installiert und Sie können Ihre erste Anwendung aus der Vorlage erstellen: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  Und hier ist was wir bekommen: <br><br><pre> <code class="plaintext hljs">myapp/ ├── .git/ ├── .gitignore ├── app/roles/custom.lua ├── deps.sh ├── init.lua ├── myapp-scm-1.rockspec ├── test │ ├── helper │ │ ├── integration.lua │ │ └── unit.lua │ ├── helper.lua │ ├── integration/api_test.lua │ └── unit/sample_test.lua └── tmp/</code> </pre><br>  Dies ist ein Git-Repository mit dem fertigen "Hallo Welt!"  Anwendung.  Versuchen wir sofort, es auszuführen und die Abhängigkeiten (einschließlich des Frameworks selbst) vorinstallieren: <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Daher haben wir einen Knoten der zukünftigen Sharded-Anwendung gestartet.  Ein neugieriger Laie kann sofort die Weboberfläche öffnen, mit der Maus einen Cluster von einem Knoten aus konfigurieren und das Ergebnis genießen, aber es ist zu früh, um sich zu freuen.  Bisher weiß die Anwendung nicht, wie sie etwas Nützliches tun soll. Daher werde ich Sie später über die Bereitstellung informieren. Jetzt ist es an der Zeit, Code zu schreiben. <br><br><h2>  Anwendungsentwicklung </h2><br>  Stellen Sie sich vor, wir entwerfen ein Projekt, das Daten empfangen, speichern und einmal täglich einen Bericht erstellen soll. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/357/881/992/3578819921cd1788d44a85856c6aac45.png"><br><br>  Wir beginnen ein Diagramm zu zeichnen und platzieren drei Komponenten darauf: Gateway, Speicher und Scheduler.  Wir arbeiten weiter an der Architektur.  Da wir vshard als Speicher verwenden, fügen wir dem Schema vshard-router und vshard-storage hinzu.  Weder das Gateway noch der Scheduler greifen direkt auf das Repository zu. Dafür gibt es einen Router, der dafür erstellt wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/65d/b72/2d465db72cc6c6db294c84748566513d.png"><br><br>  Dieses Schema spiegelt immer noch nicht ganz genau wider, was wir im Projekt erstellen werden, da die Komponenten abstrakt aussehen.  Wir müssen auch sehen, wie dies auf ein echtes Tarantool projiziert wird - wir werden unsere Komponenten nach Prozessen gruppieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e88/314/779/e8831477921e9be63de6ada1e9385b86.png"><br><br>  Es macht wenig Sinn, vshard-router und gateway auf getrennten Instanzen zu belassen.  Warum müssen wir noch einmal über das Netzwerk gehen, wenn dies bereits in der Verantwortung des Routers liegt?  Sie müssen im selben Prozess ausgeführt werden.  Das heißt, in einem Prozess werden sowohl das Gateway als auch vshard.router.cfg initialisiert und können lokal interagieren. <br><br>  Es war praktisch, in der Entwurfsphase mit drei Komponenten zu arbeiten, aber als Entwickler möchte ich beim Schreiben von Code nicht daran denken, drei Instanzen von Tarnatool zu starten.  Ich muss Tests ausführen und überprüfen, ob ich das Gateway richtig geschrieben habe.  Oder vielleicht möchte ich meinen Kollegen eine Funktion demonstrieren.  Warum sollte ich unter der Bereitstellung von drei Kopien leiden?  So wurde das Konzept der Rollen geboren.  Eine Rolle ist ein reguläres Loach-Modul, dessen Lebenszyklus von Cartridge verwaltet wird.  In diesem Beispiel gibt es vier davon: Gateway, Router, Speicher, Scheduler.  In einem anderen Projekt kann es mehr geben.  Alle Rollen können in einem Prozess gestartet werden, und dies wird ausreichen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdf/726/90c/fdf72690c30cc9b2b3ade8af667494dc.png"><br><br>  Und wenn es um die Bereitstellung für das Staging oder den Betrieb geht, werden wir jedem Tarantool-Prozess jeden Rollensatz zuweisen, abhängig von den Hardwarefunktionen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/945/59f/a0394559f3f372e9de056ab4a080dff4.png"><br><br><h2>  Topologieverwaltung </h2><br>  Informationen darüber, wo welche Rollen gestartet werden, müssen irgendwo gespeichert werden.  Und dieses "irgendwo" ist die verteilte Konfiguration, die ich oben erwähnt habe.  Das Wichtigste dabei ist die Clustertopologie.  Hier sind 3 Replikationsgruppen von 5 Tarantool-Prozessen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/04d/28a/14004d28a893832830ac61ad9c4207dd.png"><br><br>  Wir möchten keine Daten verlieren, daher behandeln wir Informationen über laufende Prozesse sorgfältig.  Cartridge überwacht die Konfiguration mit einem zweiphasigen Commit.  Sobald wir die Konfiguration aktualisieren möchten, überprüft sie zunächst die Verfügbarkeit aller Instanzen und ihre Bereitschaft, die neue Konfiguration zu akzeptieren.  Danach wendet die zweite Phase die Konfiguration an.  Selbst wenn eine Instanz vorübergehend nicht verfügbar war, wird nichts Schreckliches passieren.  Die Konfiguration wird einfach nicht angewendet und Sie werden im Voraus einen Fehler sehen. <br><br>  Auch im Topologieabschnitt wird ein so wichtiger Parameter wie der Leiter jeder Replikationsgruppe angegeben.  Normalerweise ist dies die Instanz, die aufgezeichnet wird.  Der Rest ist meistens schreibgeschützt, obwohl es Ausnahmen geben kann.  Manchmal haben mutige Entwickler keine Angst vor Konflikten und können Daten parallel auf mehrere Replikate schreiben, aber es gibt einige Vorgänge, die trotz allem nicht zweimal ausgeführt werden sollten.  Dafür gibt es ein Zeichen eines Führers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/6db/376/7256db376d8fe207bbf57f5f82054c3f.png"><br><br><h2>  Rollenleben </h2><br>  Damit eine abstrakte Rolle in einer solchen Architektur existiert, muss das Framework sie irgendwie verwalten.  Die Steuerung erfolgt natürlich ohne Neustart des Tarantool-Prozesses.  Es gibt 4 Rückrufe zum Verwalten von Rollen.  Cartridge selbst ruft sie auf, je nachdem, was in einer verteilten Konfiguration angegeben ist, und wendet die Konfiguration dann auf bestimmte Rollen an. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre><br>  Jede Rolle hat eine <code>init</code> Funktion.  Es wird einmal aufgerufen, entweder wenn die Rolle aktiviert ist oder wenn Tarantool neu gestartet wird.  Dort ist es beispielsweise praktisch, box.space.create zu initialisieren, oder der Scheduler kann eine Hintergrundfaser starten, die die Arbeit in bestimmten Intervallen erledigt. <br><br>  Die <code>init</code> Funktion <code>init</code> möglicherweise nicht aus.  Mit Cartridge können Rollen die verteilte Konfiguration nutzen, die zum Speichern der Topologie verwendet wird.  In derselben Konfiguration können wir einen neuen Abschnitt deklarieren und ein Fragment der Geschäftskonfiguration darin speichern.  In meinem Beispiel kann dies ein Datenschema oder Zeitplaneinstellungen für die Scheduler-Rolle sein. <br><br>  Der Cluster ruft <code>apply_config</code> jeder Änderung der verteilten Konfiguration <code>validate_config</code> und <code>apply_config</code> .  Wenn eine Konfiguration durch ein zweiphasiges Commit angewendet wird, überprüft der Cluster, ob jede Rolle bereit ist, diese neue Konfiguration zu akzeptieren, und meldet dem Benutzer gegebenenfalls einen Fehler.  Wenn sich alle einig waren, dass die Konfiguration normal ist, wird <code>apply_config</code> . <br><br>  Rollen haben auch eine <code>stop</code> , die erforderlich ist, um die Vitalfunktionen der Rolle zu löschen.  Wenn wir sagen, dass der Scheduler auf diesem Server nicht mehr benötigt wird, kann er die Fasern stoppen, die mit <code>init</code> gestartet wurden. <br><br>  Rollen können miteinander interagieren.  Wir sind es gewohnt, Funktionsaufrufe in Lua zu schreiben, aber es kann vorkommen, dass wir nicht die Rolle haben, die wir in diesem Prozess benötigen.  Um den Netzwerkzugriff zu erleichtern, verwenden wir das Hilfsmodul rpc (Remote Procedure Call), das auf der in Tarantool integrierten Standard-Netbox basiert.  Dies kann nützlich sein, wenn Ihr Gateway beispielsweise den Scheduler direkt bitten möchte, die Aufgabe sofort zu erledigen, anstatt einen Tag zu warten. <br><br>  Ein weiterer wichtiger Punkt ist die Gewährleistung der Fehlertoleranz.  Cartridge verwendet das SWIM-Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[4]</a> , um den Zustand zu überwachen.  Kurz gesagt, die Prozesse tauschen über UDP „Gerüchte“ miteinander aus - jeder Prozess teilt seinen Nachbarn die neuesten Nachrichten mit und sie reagieren.  Wenn die Antwort nicht kommt, beginnt Tarantool zu vermuten, dass etwas nicht stimmt, und nach einer Weile rezitiert er den Tod und beginnt, allen von diesen Neuigkeiten zu erzählen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/612/8f8/dd66128f843008534c5bd2b7d3b3474d.png"><br><br>  Basierend auf diesem Protokoll organisiert Cartridge ein automatisches Failover.  Jeder Prozess überwacht seine Umgebung. Wenn der Leiter plötzlich nicht mehr reagiert, kann das Replikat seine Rolle selbst übernehmen, und Cartridge konfiguriert die ausgeführten Rollen entsprechend. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23f/5b9/cc1/23f5b9cc17987df38ddddcf5000ab328.png"><br><br>  Hier müssen Sie vorsichtig sein, da ein häufiges Hin- und Herwechseln zu Datenkonflikten während der Replikation führen kann.  Ein zufälliges automatisches Failover lohnt sich natürlich nicht.  Sie müssen klar verstehen, was passiert, und sicherstellen, dass die Replikation nicht unterbrochen wird, nachdem sich der Anführer erholt hat und die Krone an ihn zurückgegeben wird. <br><br>  Nach allem, was gesagt wurde, scheint es, dass die Rollen ähnlich wie bei Microservices sind.  In gewissem Sinne sind sie nur als Module innerhalb von Tarantool-Prozessen.  Es gibt jedoch eine Reihe grundlegender Unterschiede.  Erstens müssen alle Projektrollen in einer Codebasis leben.  Alle Tarantool-Prozesse sollten von einer Codebasis aus gestartet werden, damit es keine Überraschungen gibt, wenn wir versuchen, den Scheduler zu initialisieren, aber dies ist einfach nicht der Fall.  Lassen Sie auch keine Unterschiede in den Versionen des Codes zu, da das Verhalten des Systems in einer solchen Situation sehr schwer vorherzusagen und zu debuggen ist. <br><br>  Im Gegensatz zu Docker können wir das „Image“ einer Rolle nicht einfach auf einen anderen Computer übertragen und dort ausführen.  Unsere Rollen sind nicht so isoliert wie Docker-Container.  Außerdem können wir nicht zwei identische Rollen auf derselben Instanz ausführen.  Die Rolle ist entweder da oder nicht, in gewissem Sinne ist es Singleton.  Und drittens sollten die Rollen innerhalb der gesamten Replikationsgruppe gleich sein, da dies sonst lächerlich wäre - die Daten sind gleich und die Konfiguration ist unterschiedlich. <br><br><h2>  Bereitstellungstools </h2><br>  Ich habe versprochen zu zeigen, wie Cartridge bei der Bereitstellung von Apps hilft.  Um anderen das Leben zu erleichtern, enthält das Framework RPM-Pakete: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp #    ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  Das installierte Paket enthält fast alles, was Sie benötigen: sowohl die Anwendung als auch die installierten Lauch-Abhängigkeiten.  Tarantool wird auch als RPM-Paketabhängigkeit auf den Server übertragen, und unser Service ist startbereit.  Dies geschieht über systemd, aber zuerst müssen Sie eine kleine Konfiguration schreiben.  Geben Sie mindestens den URI jedes Prozesses an.  Drei zum Beispiel sind genug. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Hier gibt es eine interessante Nuance.  Anstatt nur den binären Protokollport anzugeben, geben wir die öffentliche Adresse des gesamten Prozesses einschließlich des Hostnamens an.  Dies ist erforderlich, damit die Clusterknoten wissen, wie sie sich miteinander verbinden können.  Es ist eine schlechte Idee, die Adresse 0.0.0.0 als Advertise_uri zu verwenden. Es sollte sich um eine externe IP-Adresse handeln, nicht um einen Bind-Socket.  Ohne sie funktioniert nichts, sodass Cartridge den Knoten mit der falschen Advertise_uri einfach nicht starten lässt. <br><br>  Nachdem die Konfiguration fertig ist, können Sie die Prozesse starten.  Da eine normale systemd-Einheit nicht das Starten von mehr als einem Prozess zulässt, installieren Anwendungen auf Cartridge den sogenannten  instanziierte Einheiten, die so funktionieren: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  In der Konfiguration haben wir den HTTP-Port angegeben, an dem Cartridge die Webschnittstelle bedient - 8080. Lassen Sie uns das durchgehen und sehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7c/1dd/64f/d7c1dd64fdca2fed35c71dca3caaf382.png"><br><br>  Wir sehen, dass die Prozesse, obwohl sie ausgeführt werden, noch nicht konfiguriert sind.  Die Kassette weiß noch nicht, wer mit wem replizieren soll, und kann nicht selbst entscheiden. Daher wartet sie auf unsere Aktion.  Und unsere Wahl ist nicht groß: Die Lebensdauer eines neuen Clusters beginnt mit der Konfiguration des ersten Knotens.  Anschließend fügen wir den Rest dem Cluster hinzu, weisen ihnen Rollen zu und können bei dieser Bereitstellung als erfolgreich abgeschlossen gelten. <br><br>  Gießen Sie ein Glas Ihres Lieblingsgetränks ein und entspannen Sie sich nach einer langen Arbeitswoche.  Die Anwendung kann ausgenutzt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf6/c86/e44/cf6c86e448cf42c9ce190a4d13307c3a.png"><br><br><h2>  Zusammenfassung </h2><br>  Und was sind die Ergebnisse?  Versuchen Sie, verwenden Sie, hinterlassen Sie Feedback, starten Sie Tickets auf dem Github. <br><br><h2>  Referenzen </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool »2.2» Referenz »Rocks Referenz» Modul vshard</a> <br><br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie wir den Kern des Investmentgeschäfts der Alfa-Bank basierend auf Tarantool implementiert haben</a> <br><br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrechnungsarchitektur der nächsten Generation: Übergang zu Tarantool</a> <br><br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIM - Clusterbuilding-Protokoll</a> <br><br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - tarantool / cartridge-cli</a> <br><br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - Tarantool / Cartridge</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465503/">https://habr.com/ru/post/de465503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465493/index.html">Schnelle Programmiersprache auf Raspberry Pi</a></li>
<li><a href="../de465495/index.html">So verlieren Sie keinen Datenverkehr beim Wechsel zu einer neuen Domain: case "Vse10"</a></li>
<li><a href="../de465497/index.html">Geheime Nachrichtenübermittlung über Serverprotokolle</a></li>
<li><a href="../de465499/index.html">Ein neues Gesetz zur Beschreibung der Entwicklungsgeschwindigkeit von Quantencomputern?</a></li>
<li><a href="../de465501/index.html">Lehren aus 40 Jahren nach dem Start und dem raschen Niedergang der ersten „Killer-Anwendung“</a></li>
<li><a href="../de465509/index.html">Asya Patrysheva: „Das Internet ist nicht mehr nur ein Netzwerk. Das ist das Leben"</a></li>
<li><a href="../de465511/index.html">Zwischen der ersten und zweiten technischen Supportlinie</a></li>
<li><a href="../de465513/index.html">Ein Protokoll im Auge: Welche Schwachstellen haben CCTV-Systeme?</a></li>
<li><a href="../de465515/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 27. Einführung in ACL. Teil 1</a></li>
<li><a href="../de465517/index.html">DoodleBattle Paper Brettspiel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>