<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤±ğŸ» ğŸ›€ğŸ¿ ğŸ›Œ Tarantool Cartridge: Zerkleinern des Lua-Backends in drei Zeilen ğŸ‘©ğŸ½â€âš•ï¸ ğŸ›‚ ğŸ’†ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Mail.ru Group haben wir Tarantool - dies ist ein solcher Anwendungsserver auf Lua, der auch eine Datenbank hat (oder umgekehrt?). Es ist schnell u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool Cartridge: Zerkleinern des Lua-Backends in drei Zeilen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/465503/"><img src="https://habrastorage.org/webt/zl/9w/og/zl9wogkzbdgwzzedtahlcg1f8ys.jpeg"><br><br>  Bei Mail.ru Group haben wir Tarantool - dies ist ein solcher Anwendungsserver auf Lua, der auch eine Datenbank hat (oder umgekehrt?).  Es ist schnell und cool, aber die Funktionen eines Servers sind immer noch nicht unbegrenzt.  Die vertikale Skalierung ist auch kein Allheilmittel, daher verfÃ¼gt Tarantool Ã¼ber Werkzeuge fÃ¼r die horizontale Skalierung - das vshard-Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> .  Es ermÃ¶glicht Ihnen, Daten auf mehreren Servern zu teilen, aber Sie mÃ¼ssen daran basteln, um sie zu konfigurieren und die GeschÃ¤ftslogik zu befestigen. <br><br>  Gute Nachricht: Wir haben die Kegel gesammelt (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[3]</a> ) und ein anderes Framework abgesÃ¤gt, das die LÃ¶sung dieses Problems erheblich vereinfacht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge</a> ist ein neues Framework fÃ¼r die Entwicklung komplexer verteilter Systeme.  Sie kÃ¶nnen sich darauf konzentrieren, GeschÃ¤ftslogik zu schreiben, anstatt Infrastrukturprobleme zu lÃ¶sen.  Unter dem Strich werde ich Ihnen sagen, wie dieses Framework organisiert ist und wie verteilte Dienste damit geschrieben werden. <br><a name="habracut"></a><br><h2>  Und was ist eigentlich das Problem? </h2><br>  Wir haben eine Vogelspinne, es gibt Vshard - was willst du mehr? <br><br>  Erstens geht es um Bequemlichkeit.  Die Vshard-Konfiguration wird Ã¼ber Lua-Tabellen konfiguriert.  Damit ein verteiltes System mit mehreren Tarantool-Prozessen ordnungsgemÃ¤ÃŸ funktioniert, muss die Konfiguration Ã¼berall gleich sein.  Niemand mÃ¶chte dies manuell tun.  Daher werden alle Arten von Skripten, Ansible und Bereitstellungssysteme verwendet. <br><br>  Cartridge selbst verwaltet die vshard-Konfiguration, basierend auf seiner <i>eigenen verteilten Konfiguration</i> .  Im Wesentlichen handelt es sich hierbei um eine einfache YAML-Datei, deren Kopie in jeder Instanz von Tarantool gespeichert ist.  Die Vereinfachung liegt in der Tatsache, dass das Framework selbst seine Konfiguration Ã¼berwacht und somit Ã¼berall gleich ist. <br><br>  Zweitens ist der Punkt wieder bequem.  Die Konfiguration hat keinen Bezug zur Entwicklung der GeschÃ¤ftslogik und lenkt den Programmierer nur von der Arbeit ab.  Wenn wir die Architektur eines Projekts diskutieren, sprechen wir meistens Ã¼ber einzelne Komponenten und deren Interaktion.  Es ist noch zu frÃ¼h, um Ã¼ber die EinfÃ¼hrung eines Clusters in drei Rechenzentren nachzudenken. <br><br>  Wir haben diese Probleme immer wieder gelÃ¶st und irgendwann einen Ansatz entwickelt, um die Arbeit mit der Anwendung Ã¼ber den gesamten Lebenszyklus hinweg zu vereinfachen: Erstellung, Entwicklung, Test, CI / CD, Wartung. <br><br>  Cartridge fÃ¼hrt das Rollenkonzept fÃ¼r jeden Tarantool-Prozess ein.  Rollen sind ein Konzept, mit dem sich der Entwickler auf das Schreiben von Code konzentrieren kann.  Alle im Projekt verfÃ¼gbaren Rollen kÃ¶nnen auf einer Instanz von Tarantool ausgefÃ¼hrt werden. Dies reicht fÃ¼r Tests aus. <br><br>  Hauptmerkmale der Tarantool-Patrone: <br><br><ul><li>  automatisierte Cluster-Orchestrierung; <br></li><li>  Erweiterung der AnwendungsfunktionalitÃ¤t um neue Rollen; <br></li><li>  Anwendungsentwicklungs- und Bereitstellungsvorlage; <br></li><li>  eingebautes automatisches Sharding; <br></li><li>  Integration in das Luatest-Testframework; <br></li><li>  Clusterverwaltung Ã¼ber WebUI und API; <br></li><li>  Verpackungs- und Bereitstellungstools. <br></li></ul><br><h2>  Hallo Welt! </h2><br>  Ich bin gespannt darauf, das Framework selbst zu zeigen. Lassen wir also die Geschichte Ã¼ber Architektur fÃ¼r spÃ¤ter und beginnen mit einer einfachen.  Vorausgesetzt, Tarantool selbst ist bereits installiert, bleibt nur noch etwas zu tun <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Mit diesen beiden Befehlen werden die Befehlszeilenprogramme installiert und Sie kÃ¶nnen Ihre erste Anwendung aus der Vorlage erstellen: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  Und hier ist was wir bekommen: <br><br><pre> <code class="plaintext hljs">myapp/ â”œâ”€â”€ .git/ â”œâ”€â”€ .gitignore â”œâ”€â”€ app/roles/custom.lua â”œâ”€â”€ deps.sh â”œâ”€â”€ init.lua â”œâ”€â”€ myapp-scm-1.rockspec â”œâ”€â”€ test â”‚ â”œâ”€â”€ helper â”‚ â”‚ â”œâ”€â”€ integration.lua â”‚ â”‚ â””â”€â”€ unit.lua â”‚ â”œâ”€â”€ helper.lua â”‚ â”œâ”€â”€ integration/api_test.lua â”‚ â””â”€â”€ unit/sample_test.lua â””â”€â”€ tmp/</code> </pre><br>  Dies ist ein Git-Repository mit dem fertigen "Hallo Welt!"  Anwendung.  Versuchen wir sofort, es auszufÃ¼hren und die AbhÃ¤ngigkeiten (einschlieÃŸlich des Frameworks selbst) vorinstallieren: <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Daher haben wir einen Knoten der zukÃ¼nftigen Sharded-Anwendung gestartet.  Ein neugieriger Laie kann sofort die WeboberflÃ¤che Ã¶ffnen, mit der Maus einen Cluster von einem Knoten aus konfigurieren und das Ergebnis genieÃŸen, aber es ist zu frÃ¼h, um sich zu freuen.  Bisher weiÃŸ die Anwendung nicht, wie sie etwas NÃ¼tzliches tun soll. Daher werde ich Sie spÃ¤ter Ã¼ber die Bereitstellung informieren. Jetzt ist es an der Zeit, Code zu schreiben. <br><br><h2>  Anwendungsentwicklung </h2><br>  Stellen Sie sich vor, wir entwerfen ein Projekt, das Daten empfangen, speichern und einmal tÃ¤glich einen Bericht erstellen soll. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/357/881/992/3578819921cd1788d44a85856c6aac45.png"><br><br>  Wir beginnen ein Diagramm zu zeichnen und platzieren drei Komponenten darauf: Gateway, Speicher und Scheduler.  Wir arbeiten weiter an der Architektur.  Da wir vshard als Speicher verwenden, fÃ¼gen wir dem Schema vshard-router und vshard-storage hinzu.  Weder das Gateway noch der Scheduler greifen direkt auf das Repository zu. DafÃ¼r gibt es einen Router, der dafÃ¼r erstellt wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/65d/b72/2d465db72cc6c6db294c84748566513d.png"><br><br>  Dieses Schema spiegelt immer noch nicht ganz genau wider, was wir im Projekt erstellen werden, da die Komponenten abstrakt aussehen.  Wir mÃ¼ssen auch sehen, wie dies auf ein echtes Tarantool projiziert wird - wir werden unsere Komponenten nach Prozessen gruppieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e88/314/779/e8831477921e9be63de6ada1e9385b86.png"><br><br>  Es macht wenig Sinn, vshard-router und gateway auf getrennten Instanzen zu belassen.  Warum mÃ¼ssen wir noch einmal Ã¼ber das Netzwerk gehen, wenn dies bereits in der Verantwortung des Routers liegt?  Sie mÃ¼ssen im selben Prozess ausgefÃ¼hrt werden.  Das heiÃŸt, in einem Prozess werden sowohl das Gateway als auch vshard.router.cfg initialisiert und kÃ¶nnen lokal interagieren. <br><br>  Es war praktisch, in der Entwurfsphase mit drei Komponenten zu arbeiten, aber als Entwickler mÃ¶chte ich beim Schreiben von Code nicht daran denken, drei Instanzen von Tarnatool zu starten.  Ich muss Tests ausfÃ¼hren und Ã¼berprÃ¼fen, ob ich das Gateway richtig geschrieben habe.  Oder vielleicht mÃ¶chte ich meinen Kollegen eine Funktion demonstrieren.  Warum sollte ich unter der Bereitstellung von drei Kopien leiden?  So wurde das Konzept der Rollen geboren.  Eine Rolle ist ein regulÃ¤res Loach-Modul, dessen Lebenszyklus von Cartridge verwaltet wird.  In diesem Beispiel gibt es vier davon: Gateway, Router, Speicher, Scheduler.  In einem anderen Projekt kann es mehr geben.  Alle Rollen kÃ¶nnen in einem Prozess gestartet werden, und dies wird ausreichen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdf/726/90c/fdf72690c30cc9b2b3ade8af667494dc.png"><br><br>  Und wenn es um die Bereitstellung fÃ¼r das Staging oder den Betrieb geht, werden wir jedem Tarantool-Prozess jeden Rollensatz zuweisen, abhÃ¤ngig von den Hardwarefunktionen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/945/59f/a0394559f3f372e9de056ab4a080dff4.png"><br><br><h2>  Topologieverwaltung </h2><br>  Informationen darÃ¼ber, wo welche Rollen gestartet werden, mÃ¼ssen irgendwo gespeichert werden.  Und dieses "irgendwo" ist die verteilte Konfiguration, die ich oben erwÃ¤hnt habe.  Das Wichtigste dabei ist die Clustertopologie.  Hier sind 3 Replikationsgruppen von 5 Tarantool-Prozessen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/04d/28a/14004d28a893832830ac61ad9c4207dd.png"><br><br>  Wir mÃ¶chten keine Daten verlieren, daher behandeln wir Informationen Ã¼ber laufende Prozesse sorgfÃ¤ltig.  Cartridge Ã¼berwacht die Konfiguration mit einem zweiphasigen Commit.  Sobald wir die Konfiguration aktualisieren mÃ¶chten, Ã¼berprÃ¼ft sie zunÃ¤chst die VerfÃ¼gbarkeit aller Instanzen und ihre Bereitschaft, die neue Konfiguration zu akzeptieren.  Danach wendet die zweite Phase die Konfiguration an.  Selbst wenn eine Instanz vorÃ¼bergehend nicht verfÃ¼gbar war, wird nichts Schreckliches passieren.  Die Konfiguration wird einfach nicht angewendet und Sie werden im Voraus einen Fehler sehen. <br><br>  Auch im Topologieabschnitt wird ein so wichtiger Parameter wie der Leiter jeder Replikationsgruppe angegeben.  Normalerweise ist dies die Instanz, die aufgezeichnet wird.  Der Rest ist meistens schreibgeschÃ¼tzt, obwohl es Ausnahmen geben kann.  Manchmal haben mutige Entwickler keine Angst vor Konflikten und kÃ¶nnen Daten parallel auf mehrere Replikate schreiben, aber es gibt einige VorgÃ¤nge, die trotz allem nicht zweimal ausgefÃ¼hrt werden sollten.  DafÃ¼r gibt es ein Zeichen eines FÃ¼hrers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/6db/376/7256db376d8fe207bbf57f5f82054c3f.png"><br><br><h2>  Rollenleben </h2><br>  Damit eine abstrakte Rolle in einer solchen Architektur existiert, muss das Framework sie irgendwie verwalten.  Die Steuerung erfolgt natÃ¼rlich ohne Neustart des Tarantool-Prozesses.  Es gibt 4 RÃ¼ckrufe zum Verwalten von Rollen.  Cartridge selbst ruft sie auf, je nachdem, was in einer verteilten Konfiguration angegeben ist, und wendet die Konfiguration dann auf bestimmte Rollen an. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre><br>  Jede Rolle hat eine <code>init</code> Funktion.  Es wird einmal aufgerufen, entweder wenn die Rolle aktiviert ist oder wenn Tarantool neu gestartet wird.  Dort ist es beispielsweise praktisch, box.space.create zu initialisieren, oder der Scheduler kann eine Hintergrundfaser starten, die die Arbeit in bestimmten Intervallen erledigt. <br><br>  Die <code>init</code> Funktion <code>init</code> mÃ¶glicherweise nicht aus.  Mit Cartridge kÃ¶nnen Rollen die verteilte Konfiguration nutzen, die zum Speichern der Topologie verwendet wird.  In derselben Konfiguration kÃ¶nnen wir einen neuen Abschnitt deklarieren und ein Fragment der GeschÃ¤ftskonfiguration darin speichern.  In meinem Beispiel kann dies ein Datenschema oder Zeitplaneinstellungen fÃ¼r die Scheduler-Rolle sein. <br><br>  Der Cluster ruft <code>apply_config</code> jeder Ã„nderung der verteilten Konfiguration <code>validate_config</code> und <code>apply_config</code> .  Wenn eine Konfiguration durch ein zweiphasiges Commit angewendet wird, Ã¼berprÃ¼ft der Cluster, ob jede Rolle bereit ist, diese neue Konfiguration zu akzeptieren, und meldet dem Benutzer gegebenenfalls einen Fehler.  Wenn sich alle einig waren, dass die Konfiguration normal ist, wird <code>apply_config</code> . <br><br>  Rollen haben auch eine <code>stop</code> , die erforderlich ist, um die Vitalfunktionen der Rolle zu lÃ¶schen.  Wenn wir sagen, dass der Scheduler auf diesem Server nicht mehr benÃ¶tigt wird, kann er die Fasern stoppen, die mit <code>init</code> gestartet wurden. <br><br>  Rollen kÃ¶nnen miteinander interagieren.  Wir sind es gewohnt, Funktionsaufrufe in Lua zu schreiben, aber es kann vorkommen, dass wir nicht die Rolle haben, die wir in diesem Prozess benÃ¶tigen.  Um den Netzwerkzugriff zu erleichtern, verwenden wir das Hilfsmodul rpc (Remote Procedure Call), das auf der in Tarantool integrierten Standard-Netbox basiert.  Dies kann nÃ¼tzlich sein, wenn Ihr Gateway beispielsweise den Scheduler direkt bitten mÃ¶chte, die Aufgabe sofort zu erledigen, anstatt einen Tag zu warten. <br><br>  Ein weiterer wichtiger Punkt ist die GewÃ¤hrleistung der Fehlertoleranz.  Cartridge verwendet das SWIM-Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[4]</a> , um den Zustand zu Ã¼berwachen.  Kurz gesagt, die Prozesse tauschen Ã¼ber UDP â€GerÃ¼chteâ€œ miteinander aus - jeder Prozess teilt seinen Nachbarn die neuesten Nachrichten mit und sie reagieren.  Wenn die Antwort nicht kommt, beginnt Tarantool zu vermuten, dass etwas nicht stimmt, und nach einer Weile rezitiert er den Tod und beginnt, allen von diesen Neuigkeiten zu erzÃ¤hlen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/612/8f8/dd66128f843008534c5bd2b7d3b3474d.png"><br><br>  Basierend auf diesem Protokoll organisiert Cartridge ein automatisches Failover.  Jeder Prozess Ã¼berwacht seine Umgebung. Wenn der Leiter plÃ¶tzlich nicht mehr reagiert, kann das Replikat seine Rolle selbst Ã¼bernehmen, und Cartridge konfiguriert die ausgefÃ¼hrten Rollen entsprechend. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23f/5b9/cc1/23f5b9cc17987df38ddddcf5000ab328.png"><br><br>  Hier mÃ¼ssen Sie vorsichtig sein, da ein hÃ¤ufiges Hin- und Herwechseln zu Datenkonflikten wÃ¤hrend der Replikation fÃ¼hren kann.  Ein zufÃ¤lliges automatisches Failover lohnt sich natÃ¼rlich nicht.  Sie mÃ¼ssen klar verstehen, was passiert, und sicherstellen, dass die Replikation nicht unterbrochen wird, nachdem sich der AnfÃ¼hrer erholt hat und die Krone an ihn zurÃ¼ckgegeben wird. <br><br>  Nach allem, was gesagt wurde, scheint es, dass die Rollen Ã¤hnlich wie bei Microservices sind.  In gewissem Sinne sind sie nur als Module innerhalb von Tarantool-Prozessen.  Es gibt jedoch eine Reihe grundlegender Unterschiede.  Erstens mÃ¼ssen alle Projektrollen in einer Codebasis leben.  Alle Tarantool-Prozesse sollten von einer Codebasis aus gestartet werden, damit es keine Ãœberraschungen gibt, wenn wir versuchen, den Scheduler zu initialisieren, aber dies ist einfach nicht der Fall.  Lassen Sie auch keine Unterschiede in den Versionen des Codes zu, da das Verhalten des Systems in einer solchen Situation sehr schwer vorherzusagen und zu debuggen ist. <br><br>  Im Gegensatz zu Docker kÃ¶nnen wir das â€Imageâ€œ einer Rolle nicht einfach auf einen anderen Computer Ã¼bertragen und dort ausfÃ¼hren.  Unsere Rollen sind nicht so isoliert wie Docker-Container.  AuÃŸerdem kÃ¶nnen wir nicht zwei identische Rollen auf derselben Instanz ausfÃ¼hren.  Die Rolle ist entweder da oder nicht, in gewissem Sinne ist es Singleton.  Und drittens sollten die Rollen innerhalb der gesamten Replikationsgruppe gleich sein, da dies sonst lÃ¤cherlich wÃ¤re - die Daten sind gleich und die Konfiguration ist unterschiedlich. <br><br><h2>  Bereitstellungstools </h2><br>  Ich habe versprochen zu zeigen, wie Cartridge bei der Bereitstellung von Apps hilft.  Um anderen das Leben zu erleichtern, enthÃ¤lt das Framework RPM-Pakete: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp #    ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  Das installierte Paket enthÃ¤lt fast alles, was Sie benÃ¶tigen: sowohl die Anwendung als auch die installierten Lauch-AbhÃ¤ngigkeiten.  Tarantool wird auch als RPM-PaketabhÃ¤ngigkeit auf den Server Ã¼bertragen, und unser Service ist startbereit.  Dies geschieht Ã¼ber systemd, aber zuerst mÃ¼ssen Sie eine kleine Konfiguration schreiben.  Geben Sie mindestens den URI jedes Prozesses an.  Drei zum Beispiel sind genug. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Hier gibt es eine interessante Nuance.  Anstatt nur den binÃ¤ren Protokollport anzugeben, geben wir die Ã¶ffentliche Adresse des gesamten Prozesses einschlieÃŸlich des Hostnamens an.  Dies ist erforderlich, damit die Clusterknoten wissen, wie sie sich miteinander verbinden kÃ¶nnen.  Es ist eine schlechte Idee, die Adresse 0.0.0.0 als Advertise_uri zu verwenden. Es sollte sich um eine externe IP-Adresse handeln, nicht um einen Bind-Socket.  Ohne sie funktioniert nichts, sodass Cartridge den Knoten mit der falschen Advertise_uri einfach nicht starten lÃ¤sst. <br><br>  Nachdem die Konfiguration fertig ist, kÃ¶nnen Sie die Prozesse starten.  Da eine normale systemd-Einheit nicht das Starten von mehr als einem Prozess zulÃ¤sst, installieren Anwendungen auf Cartridge den sogenannten  instanziierte Einheiten, die so funktionieren: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  In der Konfiguration haben wir den HTTP-Port angegeben, an dem Cartridge die Webschnittstelle bedient - 8080. Lassen Sie uns das durchgehen und sehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7c/1dd/64f/d7c1dd64fdca2fed35c71dca3caaf382.png"><br><br>  Wir sehen, dass die Prozesse, obwohl sie ausgefÃ¼hrt werden, noch nicht konfiguriert sind.  Die Kassette weiÃŸ noch nicht, wer mit wem replizieren soll, und kann nicht selbst entscheiden. Daher wartet sie auf unsere Aktion.  Und unsere Wahl ist nicht groÃŸ: Die Lebensdauer eines neuen Clusters beginnt mit der Konfiguration des ersten Knotens.  AnschlieÃŸend fÃ¼gen wir den Rest dem Cluster hinzu, weisen ihnen Rollen zu und kÃ¶nnen bei dieser Bereitstellung als erfolgreich abgeschlossen gelten. <br><br>  GieÃŸen Sie ein Glas Ihres LieblingsgetrÃ¤nks ein und entspannen Sie sich nach einer langen Arbeitswoche.  Die Anwendung kann ausgenutzt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf6/c86/e44/cf6c86e448cf42c9ce190a4d13307c3a.png"><br><br><h2>  Zusammenfassung </h2><br>  Und was sind die Ergebnisse?  Versuchen Sie, verwenden Sie, hinterlassen Sie Feedback, starten Sie Tickets auf dem Github. <br><br><h2>  Referenzen </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Â»2.2Â» Referenz Â»Rocks ReferenzÂ» Modul vshard</a> <br><br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie wir den Kern des InvestmentgeschÃ¤fts der Alfa-Bank basierend auf Tarantool implementiert haben</a> <br><br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrechnungsarchitektur der nÃ¤chsten Generation: Ãœbergang zu Tarantool</a> <br><br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIM - Clusterbuilding-Protokoll</a> <br><br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - tarantool / cartridge-cli</a> <br><br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - Tarantool / Cartridge</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465503/">https://habr.com/ru/post/de465503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465493/index.html">Schnelle Programmiersprache auf Raspberry Pi</a></li>
<li><a href="../de465495/index.html">So verlieren Sie keinen Datenverkehr beim Wechsel zu einer neuen Domain: case "Vse10"</a></li>
<li><a href="../de465497/index.html">Geheime NachrichtenÃ¼bermittlung Ã¼ber Serverprotokolle</a></li>
<li><a href="../de465499/index.html">Ein neues Gesetz zur Beschreibung der Entwicklungsgeschwindigkeit von Quantencomputern?</a></li>
<li><a href="../de465501/index.html">Lehren aus 40 Jahren nach dem Start und dem raschen Niedergang der ersten â€Killer-Anwendungâ€œ</a></li>
<li><a href="../de465509/index.html">Asya Patrysheva: â€Das Internet ist nicht mehr nur ein Netzwerk. Das ist das Leben"</a></li>
<li><a href="../de465511/index.html">Zwischen der ersten und zweiten technischen Supportlinie</a></li>
<li><a href="../de465513/index.html">Ein Protokoll im Auge: Welche Schwachstellen haben CCTV-Systeme?</a></li>
<li><a href="../de465515/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 27. EinfÃ¼hrung in ACL. Teil 1</a></li>
<li><a href="../de465517/index.html">DoodleBattle Paper Brettspiel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>