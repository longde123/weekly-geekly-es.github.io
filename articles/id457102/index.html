<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤕 🐛 👂🏽 File QVD - apa yang ada di dalamnya, bagian 3 🧒🏾 🤽🏾 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel pertama tentang struktur file QVD, saya menggambarkan struktur umum dan membahas metadata dengan cukup detail, dan yang kedua tentang pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>File QVD - apa yang ada di dalamnya, bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/457102/"><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> tentang struktur file QVD, saya menggambarkan struktur umum dan membahas metadata dengan cukup detail, dan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> tentang penyimpanan kolom (karakter).  Dalam artikel ini, saya akan menjelaskan format untuk menyimpan informasi tentang string, merangkum, dan berbicara tentang rencana dan pencapaian. </p><br><p>  Jadi (ingat) file QVD sesuai dengan tabel relasional, dalam file QVD tabel disimpan dalam dua bagian yang terhubung secara tidak langsung: </p><br><p>  Tabel karakter (istilah saya) mengandung nilai unik untuk setiap kolom di tabel sumber.  Saya berbicara tentang mereka di artikel kedua. </p><br><p>  Tabel baris berisi baris tabel sumber, setiap baris menyimpan indeks nilai kolom (bidang) dari baris dalam tabel simbol yang sesuai.  Tentang hal inilah artikel ini akan dibuat. </p><a name="habracut"></a><br><p>  Pada contoh piring kami (ingat - dari bagian pertama) </p><br><pre><code class="plaintext hljs">SET NULLINTERPRET =&lt;sym&gt;; tab1: LOAD * INLINE [ ID, NAME 123.12,"Pete" 124,12/31/2018 -2,"Vasya" 1,"John" &lt;sym&gt;,"None" ];</code> </pre> <br><p>  Di tabel baris file QVD kami, label ini akan sesuai dengan 5 baris - selalu cocok dengan persis: berapa banyak baris dalam tabel, berapa banyak baris dalam tabel baris file QVD. </p><br><p>  Baris dalam tabel baris terdiri dari bilangan bulat non-negatif, masing-masing angka ini adalah indeks ke dalam tabel simbol yang sesuai.  Pada tingkat logis, semuanya sederhana, tetap mengklarifikasi nuansa dan memberikan contoh (membongkar - karena papan nama kami disajikan dalam QVD). </p><br><h2 id="format-tablicy-strok">  Format Tabel Baris </h2><br><p>  Tabel baris terdiri dari K * N byte, di mana </p><br><ul><li>  K - jumlah baris dalam tabel sumber (nilai tag metadata "NoOfRecords") </li><li>  Panjang N-byte dari string tabel karakter (nilai tag metadata "RecordByteSize") </li></ul><br><p>  Tabel garis dimulai dengan offset "Offset" (tag metadata) relatif ke awal bagian biner file. </p><br><p>  Informasi tentang tabel baris (panjang, ukuran baris, offset) disimpan di bagian umum metadata. </p><br><h2 id="format-stroki-tablicy-strok">  Format baris tabel baris </h2><br><p>  Semua baris tabel baris memiliki format yang sama dan merupakan gabungan dari "angka yang tidak ditandai".  Panjang angka minimal cukup untuk mewakili bidang tertentu: panjangnya tergantung pada jumlah nilai unik bidang tertentu. </p><br><p>  Untuk bidang dengan satu nilai (seperti yang sudah saya tulis), panjang ini akan menjadi nol (nilai ini sama di setiap baris tabel sumber dan disimpan dalam tabel simbol yang sesuai). </p><br><p>  Untuk bidang dengan dua nilai, panjang ini akan sama dengan satu (nilai indeks yang mungkin dalam tabel simbol adalah 0 dan 1), dan seterusnya. </p><br><p>  Karena total panjang baris dari tabel baris harus merupakan kelipatan byte, panjang "karakter terakhir" disejajarkan dengan batas byte (lihat di bawah ini ketika kita akan menguraikan plat kita). </p><br><p>  Informasi tentang format masing-masing bidang disimpan di bagian metadata yang dikhususkan untuk bidang ini (kami akan tinggal sedikit lebih di bawah), panjang representasi bit bidang disimpan dalam tag "BitWidth". </p><br><h2 id="hranenie-znacheniy-null">  Menyimpan Nilai NULL </h2><br><p>  Bagaimana cara menyimpan nilai yang hilang?  Menahan diri dari mendiskusikan topik mengapa, saya akan menjawab dengan cara ini: seperti yang saya pahami, kombinasi berikut ini sesuai dengan nilai NULL </p><br><ul><li>  tag "Bias" dari bidang yang sesuai mengambil nilai "-2" (semuanya, saya menemukan dua nilai yang mungkin dari tag ini - "0" dan "-2") </li><li>  indeks bidang untuk baris tempat bidang ini NULL adalah 0 </li></ul><br><p>  Dengan demikian, semua indeks lain dalam kolom yang memiliki nilai NULL meningkat 2 - kita akan melihat dalam contoh kita sedikit lebih rendah. </p><br><h2 id="poryadok-sledovaniya-poley-v-stroke">  Urutan bidang di baris </h2><br><p>  Urutan bidang di baris tabel baris sesuai dengan bit offset bidang, yang disimpan dalam tag "BitOffset" pada bagian metadata yang terkait dengan bidang ini. </p><br><p>  Mari kita menganalisis contoh kita (lihat metadata di bagian pertama dari seri ini). </p><br><p>  Bidang ID </p><br><ul><li>  bit offset 0 - bidang akan menjadi "paling kanan" </li><li>  bit length 3 - bidang akan menempati 3 bit dalam satu baris tabel baris </li><li>  Bias adalah "-2" - bidang memiliki nilai NULL, semua indeks bertambah 2 </li></ul><br><p>  Bidang "NAME" </p><br><ul><li>  bit offset 3 - bidang terletak di sebelah kiri bidang ID sebanyak 3 bit </li><li>  bit length 5 - bidang akan menempati 5 bit di baris tabel baris (sejajar dengan batas byte) </li><li>  Bias adalah "0" - bidang tidak memiliki nilai NULL, semua indeks "jujur" </li></ul><br><h2 id="predstavlenie-nashey-tablichki">  Presentasi papan nama kami. </h2><br><p>  Mari kita lihat "nol dan satu" yang sebenarnya - saya akan memberikan fragmen file QVD sebagai representasi biner "dalam format heksadesimal" (sangat ringkas). </p><br><p>  Pertama, seluruh bagian biner (yang disorot dengan warna merah muda, metadata terpotong - itu menyakitkan banyak dari mereka ...) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_1.png" alt="gambar"></p><br><p>  Cukup kompak, setuju.  Mari kita lihat lebih dekat - tepat setelah metadata ada tabel simbol (by the way, dalam file ini berakhir dengan linefeed dan byte nol - secara teknis ini terjadi, nol byte setelah metadata perlu dilewati ...). </p><br><p>  Tabel simbol pertama disorot pada gambar di bawah ini. </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_2.png" alt="gambar"></p><br><p>  Kita melihat: </p><br><p>  Nilai unik pertama dari <strong>bidang ID</strong> adalah </p><br><ul><li>  ketik "6" (byte pertama dialokasikan) adalah angka floating-point dengan string (lihat artikel kedua) </li><li>  setelah byte pertama, 8 dari byte berikutnya adalah biner yang mewakili angka floating-point </li><li>  setelah mereka datang representasi string - sangat mudah (tidak perlu diingat - berapa nomornya), berakhir dengan byte nol </li></ul><br><p>  Tiga nilai unik yang tersisa adalah tipe 5 (integer dengan string) - nilainya "124", "-2" dan "1" (mudah dilihat di sepanjang garis). </p><br><p>  Pada gambar di bawah ini, saya menyoroti tabel simbol kedua (untuk bidang "NAME") </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_3.png" alt="gambar"></p><br><p>  Nilai unik pertama dari <strong>bidang "NAME"</strong> adalah ketik "4" (byte pertama dialokasikan) - string yang diakhiri dengan nol. </p><br><p>  Empat nilai unik lainnya adalah string "12/31/2018", "Vaysa", "John" dan "None". </p><br><p>  Sekarang - tabel baris (disorot pada gambar di bawah) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_4.png" alt="gambar"></p><br><p>  Seperti yang diharapkan - 5 byte (5 baris dengan satu byte). </p><br><p>  <strong>Baris pertama</strong> (sesuai dengan baris 123.12, "Pete" dari piring kami) </p><br><p>  Nilai string adalah byte "02" (biner 000000010). </p><br><p>  Pisahkan itu (ingat deskripsi di atas) </p><br><ul><li>  3 bit kanan (biner 010, menurut kami ini 2) - ini adalah indeks ke dalam tabel simbol dari bidang "ID" </li><li>  kami memiliki bidang "ID" yang berisi NULL, sehingga indeksnya naik 2, yaitu  indeks yang dihasilkan adalah 0, yang sesuai dengan karakter "123.12". </li><li>  5 bit berikutnya (biner dan desimal 0) adalah indeks dalam tabel simbol dari bidang "NAME", itu tidak mengandung NULL, oleh karena itu ini adalah indeks "Pete" dalam tabel simbol. </li></ul><br><p>  <strong>Baris kedua</strong> (124.12 / 31/2018) di tabel baris </p><br><p>  Nilai - byte "0B" (biner 00001011) </p><br><ul><li>  3 bit kanan (biner 011, menurut kami 3) - ini adalah indeks ke dalam tabel simbol dari bidang "ID" </li><li>  kami memiliki bidang "ID" yang berisi NULL, sehingga indeksnya naik 2, yaitu  indeks yang dihasilkan adalah 1, yang sesuai dengan simbol "124". </li><li>  5 bit berikutnya (biner dan desimal 1) adalah indeks dalam tabel simbol dari bidang "NAME", itu tidak mengandung NULL, oleh karena itu ini adalah indeks "12/31/2018" dalam tabel simbol. </li></ul><br><p>  Nah dan seterusnya, mari kita lihat <strong>baris terakhir</strong> - di sana kita memilikinya, "Tidak ada" (yaitu NULL dan string "Tidak Ada"): <br></p><p>  Nilainya byte "20" (biner 0010000) </p><br><ul><li>  3 bit kanan (biner dan desimal 0) - ini adalah indeks ke dalam tabel simbol bidang "ID" </li><li>  kami memiliki bidang "ID" yang berisi NULL, sehingga indeksnya naik 2, yaitu  indeks akhir adalah -2, yang sesuai dengan nilai NULL. </li><li>  5 bit berikutnya (biner 100, desimal 4) adalah indeks dalam tabel simbol dari bidang "NAME", itu tidak mengandung NULL, jadi ini adalah indeks "Tidak Ada" di tabel simbol. </li></ul><br><p>  <strong>PENTING</strong> Saya tidak dapat menemukan contoh yang mengonfirmasi hal ini, tetapi saya menemukan file yang berisi indeks akhir -1 untuk nilai NULL.  Oleh karena itu, dalam program saya, saya menganggap NULL semua bidang yang indeks akhirnya negatif. </p><br><h2 id="bolee-dlinnye-stroki-v-tablice-strok">  Baris yang lebih panjang di tabel baris </h2><br><p>  Pada akhir parsing format QVD, saya akan secara singkat memikirkan nuansa penting - garis panjang di bidang tabel toko baris dalam urutan kanan-ke-kiri, di mana bidang dengan offset bit nol akan menjadi yang paling kanan (seperti yang saya jelaskan di atas).  <strong>TETAPI</strong> urutan byte terbalik, mis.  byte pertama akan menjadi yang paling kanan (dan akan berisi bidang "kanan" - bidang dengan offset bit nol), byte terakhir akan menjadi yang pertama (yaitu, berisi bidang paling "kiri" - bidang dengan bit offset maksimum). </p><br><p>  Sebuah contoh harus diberikan, tetapi tidak dibebani dengan detail.  Mari kita lihat label seperti itu (saya kutip sebuah fragmen - untuk mendapatkan garis panjang di tabel baris, Anda perlu menambah jumlah nilai unik). </p><br><pre> <code class="plaintext hljs">tab2: LOAD * INLINE [ ID, VAL, NAME, PHONE, SINGLE 1, 100001, "Pete1", "1234567890", "single value" 2, 200002, "Pete2", "2234567890", "single value" ... ];</code> </pre> <br><p>  Informasi singkat tentang bidang (memeras metadata): </p><br><ul><li>  ID: lebar 8 bit, bit offset - 0, bias - 0 </li><li>  VAL: lebar 5 bit, bit offset - 8, bias - 0 </li><li>  NAME: lebar 6 bit, bit offset - 18, bias - 0 </li><li>  TELEPON: lebar 5 bit, bit offset - 13, bias - 0 </li><li>  TUNGGAL: lebar 0 bit (memiliki satu nilai) </li></ul><br><p>  Tabel baris terdiri dari string dengan panjang 3 byte, masing-masing, di baris tabel baris data tentang bidang akan didekomposisi secara logis sebagai berikut: </p><br><ul><li>  6 bit pertama - bidang "NAME" </li><li>  5 bit berikutnya - bidang "PHONE" </li><li>  lalu 5 bit - bidang "VAL" </li><li>  8 bit terakhir - bidang ID </li></ul><br><p>  Urutan logis dikonversikan ke byte fisik dalam urutan terbalik, mis. </p><br><ul><li>  bidang "ID" sepenuhnya menempati byte pertama (yang dalam urutan logis adalah yang terakhir) </li><li>  bidang "VAL" menempati 5 bit lebih rendah dari byte kedua </li><li>  bidang "PHONE" menempati 3 bit atas dari byte kedua dan 2 bit lebih rendah dari byte ketiga </li><li>  bidang "NAME" menempati 6 bit teratas dari byte ketiga </li></ul><br><p>  Mari kita lihat contoh-contoh, di sini terlihat seperti apa baris pertama dari tabel baris (disorot dengan warna merah muda) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_5.png" alt="gambar"></p><br><p>  Nilai bidang </p><br><ul><li>  ID - biner 00000000, desimal 0 </li><li>  VAL - biner 00010, desimal 2, kurangi 2 dari bias - dapatkan 0 </li><li>  PONSEL - biner 00010, desimal 2, kurangi 2 dari bias - dapatkan 0 </li><li>  NAME - biner 000000, desimal 0 </li></ul><br><p>  Artinya, baris pertama berisi karakter pertama dari tabel karakter yang sesuai. </p><br><p>  Secara umum, lebih mudah untuk memulai parsing dari baris pertama - biasanya berisi nol sebagai indeks (file QVD dibangun sedemikian rupa sehingga nilai-nilai dari baris pertama masuk ke tabel simbol terlebih dahulu). </p><br><p>  Mari kita lihat baris kedua untuk diperbaiki </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_7.png" alt="gambar"></p><br><p>  Nilai bidang </p><br><ul><li>  ID - biner 00000001, desimal 1 </li><li>  VAL - biner 00011, desimal 3, kurangi 2 dari bias - dapatkan 1 </li><li>  PONSEL - biner 00011, desimal 3, kurangi 2 dari bias - dapatkan 1 </li><li>  NAME - biner 000001, desimal 1 </li></ul><br><p>  Yaitu, baris kedua berisi karakter kedua dari tabel karakter yang sesuai. </p><br><h2 id="effektivnyy-razbor-formata">  Format parsing yang efisien </h2><br><p>  Saya akan berbagi sedikit pengalaman - bagaimana saya secara teknis "membaca" QVD. </p><br><p>  Versi pertama ditulis dengan python (saya akan memuliakannya dan meletakkannya di github). </p><br><p>  Masalah utama dengan cepat menjadi jelas: </p><br><ul><li>  tabel simbol hanya dapat dibaca “berturut-turut” (tidak mungkin membaca nomor simbol N tanpa membaca semua karakter sebelumnya) </li><li>  file nyata tidak sesuai dengan RAM </li><li>  dari operasi paling lambat (kecuali untuk bekerja dengan file) - operasi bit (membongkar deretan tabel string) </li><li>  kinerja menurun drastis pada file QVD "lebar" (ketika ada banyak kolom) </li></ul><br><p>  Beberapa masalah ini dapat diatasi dengan mengubah bahasa (dari python ke C, misalnya).  Bagian diperlukan beberapa tindakan tambahan. </p><br><p>  Implementasi saat ini agak cepat terlihat seperti ini - logika umum diimplementasikan dalam python, dan operasi yang paling kritis dilakukan dalam program C terpisah yang berjalan secara paralel. </p><br><p>  Sebentar lagi </p><br><ul><li>  tabel simbol ditulis ke file, indeks juga dibuat untuk bidang teks, sehingga dimungkinkan untuk membaca nomor simbol N </li><li>  bekerja dengan QVD dan file dengan tabel simbol dilaksanakan melalui file yang dipetakan memori (jadi lebih cepat) </li><li>  pertama, secara paralel (dengan batasan jumlah prosesor), file dibuat dengan tabel simbol (dan indeks) </li><li>  kemudian secara paralel (dengan batasan yang sama) baris-baris tabel baris dibaca dan file csv dibuat (dalam HDFS) </li><li>  langkah terakhir adalah mengonversi file-file ini ke tabel ORC (menggunakan alat Hive) </li><li>  di C mengimplementasikan pembuatan file dengan tabel simbol dan pembuatan file CSV untuk berbagai baris </li></ul><br><p>  Saya tidak ingin memberikan angka untuk kinerja - mereka akan membutuhkan pengikatan pada perangkat keras, pada tingkat kualitatif ternyata menyalin file QVD ke tabel ORC dengan kecepatan menyalin data melalui jaringan.  Atau, dengan kata lain, mengambil data dari QVD cukup realistis (di tingkat rumah tangga). </p><br><p>  Saya juga menerapkan logika membuat file QVD - ini bekerja cukup cepat pada python (tampaknya, saya belum mencapai volume besar - tidak perlu. Saya akan sampai di sana - Saya akan menulis ulang dengan cara yang sama seperti versi "membaca"). </p><br><h2 id="plany-na-buduschee">  Rencana masa depan </h2><br><p>  Apa selanjutnya </p><br><ul><li>  Saya berencana untuk meletakkan versi kode Python di github (versi ini akan memungkinkan Anda untuk "menjelajahi" file QVD - lihat metadata, baca dan tulis karakter, string. Versi ini sesederhana dan sejelas mungkin - tanpa file untuk tabel karakter, dengan pembacaan berurutan, menggunakan perpustakaan standar untuk bekerja dengan bit, dll.) </li><li>  Saya berpikir tentang melakukan sesuatu untuk panda (seperti read_qvd ()), ia menahan bahwa itu akan lambat pada python, serta fakta bahwa jelas tidak setiap QVD akan "masuk" ke dalam memori, oleh karena itu </li><li>  Saya berpikir tentang menjadikan file QVD sebagai sumber data untuk Spark - seharusnya tidak ada masalah dengan "tidak masuk ke memori" (dan bahasa di sana - scala - lebih dekat ke perangkat keras) </li></ul><br><h2 id="vmesto-poslesloviya">  Alih-alih kata penutup </h2><br><p>  Untuk waktu yang lama saya berkeliling file QVD, sepertinya "semuanya rumit di sana."  Ternyata itu sulit, tetapi tidak terlalu, dorongan yang baik adalah github, yang saya sebutkan di bagian pertama (semacam katalis).  Lalu itu masalah teknologi.  Saya dan semua orang mencatat (satu konfirmasi lagi) - semuanya dapat dilakukan dalam pemrograman, pertanyaannya adalah waktu dan motivasi. </p><br><p>  Saya harap saya tidak terlalu lelah dengan detailnya, saya siap untuk menjawab pertanyaan (dalam komentar atau dengan cara lain).  Jika akan ada kelanjutan, saya pasti akan menulis. </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457102/">https://habr.com/ru/post/id457102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457092/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 5</a></li>
<li><a href="../id457094/index.html">Add-in Excel yang memudahkan untuk mengatur filter saat bekerja dengan kubus (VBA)</a></li>
<li><a href="../id457096/index.html">Kami membebaskan tangan kami ke beberapa analis: API Livy untuk otomatisasi tugas perbankan yang khas</a></li>
<li><a href="../id457098/index.html">Penanganan kesalahan JavaScript yang elegan dengan Either monad</a></li>
<li><a href="../id457100/index.html">AWS Lambda - Teori, Kenalan</a></li>
<li><a href="../id457106/index.html">Perang robo-panggilan AS - siapa yang menang dan mengapa</a></li>
<li><a href="../id457108/index.html">WWDC19: Memulai dengan Rencana Tes untuk XCTest</a></li>
<li><a href="../id457110/index.html">Unit Pengujian Pola C ++ dan Injeksi Mock Menggunakan Sifat</a></li>
<li><a href="../id457112/index.html">Hasil HolyJS 2019 Piter</a></li>
<li><a href="../id457114/index.html">Pilih sistem pengawasan video: cloud vs lokal dengan Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>