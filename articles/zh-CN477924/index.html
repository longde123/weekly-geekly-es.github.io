<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦁 👨🏻‍🔬 🕓 JavaFX教程：CSS样式 🤭 ‼️ 🎹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如何使用良好的旧CSS样式化JavaFX组件。 

 JavaFX系列中的所有文章： 



1. JavaFX教程：入门 
2. JavaFX教程：世界您好！ 
3. JavaFX教程：FXML和SceneBuilder 
4. JavaFX教程：基本布局 
5. JavaFX教程：高级布局 
6...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaFX教程：CSS样式</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477924/"> 如何使用良好的旧CSS样式化JavaFX组件。 <br><br>  JavaFX系列中的所有文章： <br><br><ol><li>  <a href="https://habr.com/ru/post/474292/">JavaFX教程：入门</a> </li><li>  <a href="https://habr.com/ru/post/474498/">JavaFX教程：世界您好！</a> </li><li>  <a href="https://habr.com/ru/post/474982/">JavaFX教程：FXML和SceneBuilder</a> </li><li>  <a href="https://habr.com/ru/post/475882/">JavaFX教程：基本布局</a> </li><li>  <a href="https://habr.com/ru/post/477408/">JavaFX教程：高级布局</a> </li><li>  JavaFX教程：CSS样式 </li><li>  <a href="https://habr.com/ru/post/478402/">JavaFX Weaver：集成JavaFX和Spring Boot应用程序</a> </li></ol><a name="habracut"></a><br><h3> 视觉元素的分离 </h3><br> 在上<a href="https://habr.com/ru/post/474982/">一篇有关FXML的文章中，</a>我们了解了JavaFX如何通过将UI代码一分为二来提供清晰的任务分离。 组件及其属性在FXML文件中声明，并且交互逻辑已明确分配给控制器。 <br><br> 此外，还有第三部分，FXML语言，它仅控制应用程序的组件，它们的属性以及它们如何相互嵌入。 它没有定义组件的视觉元素，即：字体，颜色，背景，缩进。 通常，您可以在FXML中实现此目的，但您不应该这样做。 相反，视觉元素应在CSS样式表中明确定义。 <br><br> 因此，您的设计变得独立，可以轻松替换或更改而不会影响应用程序的其余部分。 您甚至可以简单地实现几个可以根据用户要求切换的主题。 <br><br><h3> 的CSS </h3><br> 您可能熟悉用于在网络上设置HTML页面样式的CSS（级联样式表）。 尽管JavaFX使用一组自己的自定义属性，但在JavaFX中实现了类似的方法。 <br><br> 让我们看一个例子： <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.button</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-font-size</span></span>: <span class="hljs-number"><span class="hljs-number">15px</span></span>; }</code> </pre> <br> 这里使用两个主要概念。 第一个是<i>.button</i>选择器。 它确定样式应应用于哪些组件。 在此示例中，样式应用于所有按钮。 <br><br> 第二部分是样式的实际属性，它将应用于与我们的选择器匹配的所有组件。 属性是花括号中的所有内容。 <br><br> 每个属性都有特定的含义。 在我们的示例中，有<i>-fx-font-size</i>属性，该属性确定文本<i>的大小</i> 。 在示例中，该值为<i>15px</i> ，但是该值可以是其他任何值。 <br><br> 总而言之，我们创建了一条规则，规定所有按钮都应包含15个像素的文本。 <br><br><h3> 选择器 </h3><br> 现在，让我们仔细看看选择器在JavaFX中的工作方式。 这种情况几乎与常规CSS相同。 <br><br><h3> 班级 </h3><br>  CSS中的类表示几个相似的元素。 例如，按钮或复选框。 选择器应应用于同一个类的所有元素，选择器以点“。”开头，后跟类名。 类的命名约定是用“-”字符分隔各个单词。 以下选择器适用于带有<b>label</b>类的所有元素。 <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.label</span></span> { // Some properties }</code> </pre> <br><h3> 内置类 </h3><br> 好消息是，所有JavaFX内置组件（例如Label或Button）已经具有预定义的类。 如果要自定义应用程序中所有标签的样式，则无需为每个标签添加任何自定义类。 默认情况下，每个标签都有一个<i>标签</i>类。 <br><br> 从组件确定类名很容易： <br><br><ul><li> 以Java组件类的名称为例。  <i>标签</i> </li><li> 将名称改为小写 </li><li> 如果它由多个单词组成，请用“-”符号将它们分开 </li></ul><br> 一些例子： <br><br><ul><li> 标签→标签 </li><li> 复选框→复选框 </li></ul><br> 使用选择器之类的类时，请确保添加“。”。 这意味着<i>标签</i>类的选择器是<i>.label</i> 。 <br><br><h3> 自订课程 </h3><br> 如果内置的类还不够，则可以将自己的类添加到组件中。 您可以使用多个以逗号分隔的类： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">styleClass</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-label,other-class"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 或在Java中： <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I am a simple label"</span></span>); label.getStyleClass().addAll(<span class="hljs-string"><span class="hljs-string">"my-label"</span></span>, <span class="hljs-string"><span class="hljs-string">"other-class"</span></span>);</code> </pre> <br> 默认情况下，以这种方式添加类不会删除组件类（在这种情况下为<i>label</i> ）。 <br><br> 有一个叫做<i>root的</i>特殊类。 它是场景的根源。 您可以使用它来设置场景中所有内容的样式（例如，设置全局字体）。 这类似于在HTML中使用body标签选择器。 <br><br><h3> 编号 </h3><br> 在CSS中选择组件的另一种方法是使用组件标识符（ID）。 它是组件的唯一标识符。 与可以分配给多个组件的类不同，标识符在场景中必须唯一。 <br><br> 而符号“。”用于指示类。 在其选择器名称的前面，标识符用符号“＃”标记。 <br><br><pre> <code class="css hljs"><span class="hljs-selector-id"><span class="hljs-selector-id">#my-component</span></span> { ... }</code> </pre> <br> 在FXML中，可以使用<i>fx：id</i>设置组件的CSS标识符。 <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 但是，有一个警告。 相同的<a href="https://habr.com/ru/post/474982/">标识符用于引用在控制器中声明的</a>具有相同名称<a href="https://habr.com/ru/post/474982/">的组件对象</a> 。 由于控制器中的标识符和字段名称必须匹配，因此<i>fx：id</i>必须考虑字段名称的Java命名限制。 尽管CSS命名约定定义了由“-”字符分隔的单个单词，但对于Java字段名称而言，它是无效字符。 因此，对于带有少量单词的<i>fx：id</i> ，您需要使用其他命名约定，例如CamelCase，或使用下划线。 <br><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- This is not valid --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-label"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- This is valid --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my_label"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fx:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MyLabel"</span></span></span><span class="hljs-tag">&gt;</span></span>I am a simple label<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 在Java中，您可以简单地调用组件的<i>setId（）</i>方法。 <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I am a simple label"</span></span>); label.setId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>);</code> </pre> <br><h3> 物产 </h3><br> 尽管JavaFX中使用的CSS与原始的Web CSS非常相似，但还是有很大的不同。 属性名称不同，并且有许多新的JavaFX特定属性。 它们具有前缀<i>-fx-</i> 。 <br><br> 以下是一些示例： <br><br><ul><li>  <i>-fx-background-color</i> ：背景色 </li><li>  <i>-fx-text-fill</i> ：文本颜色 </li><li>  <i>-fx-font-size</i> ：文字大小 </li></ul><br> 您可以在<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">官方设计指南中</a>找到所有属性的列表。 <br><br><h3> 伪类 </h3><br> 除了标记特定组件的常用类之外，还有指示组件状态的所谓伪类。 例如，这可以是用于标记组件具有焦点或鼠标光标位于其上的类。 <br><br> 有许多内置的伪类。 让我们看一下按钮。 您可以使用几种伪类，例如： <br><br><ul><li>  <i>悬停</i> ：将鼠标<i>悬停</i>在按钮上 </li><li>  <i>有焦点</i> ：按钮有焦点 </li><li>  <i>禁用</i> ：按钮已禁用 </li><li>  <i>按下</i> ：按下按钮 </li></ul><br> 伪类以CSS选择器中的“：”字符（例如<i>:: hover</i> ）开头。 当然，您需要指定您的伪类属于哪个组件-例如， <i>button：hover</i> 。 下面的示例显示一个选择器，该选择器适用于所有具有焦点的按钮： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:focused</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-background-color</span></span>: red; }</code> </pre> <br> 与CSS仅有状态（例如<i>focus</i>和<i>hover）的</i>基本伪类的CSS不同，JavaFX具有与组件不同的状态或属性相关的特定于组件的伪类。 <br><br> 例如： <br><br><ul><li> 滚动条具有<i>水平</i>和<i>垂直</i>伪类 </li><li> 元素（单元）具有伪类<i>奇数</i>和<i>偶数</i> </li><li>  TitledPane已<i>扩展</i>和<i>折叠</i>伪类。 </li></ul><br><h3> 自定义伪类 </h3><br> 除了内置的伪类，您还可以定义和使用自己的伪类。 <br><br> 让我们创建自己的标签（从Label类继承）。 它将具有一个称为<i>Shiny</i>的新逻辑属性。 在这种情况下，我们希望我们的标签具有<i>闪亮的</i>伪<i>类</i> 。 <br><br> 由于标签具有<i>闪亮的</i>伪<i>类</i> ，我们可以设置<i>金色</i>标签的背景： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.shiny-label</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:shiny</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-fx-background-color</span></span>: gold; }</code> </pre><br> 现在创建类本身。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShinyLabel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BooleanProperty shiny; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShinyLabel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ getStyleClass().add(<span class="hljs-string"><span class="hljs-string">"shiny-label"</span></span>); shiny = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleBooleanProperty(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); shiny.addListener(e -&gt; { pseudoClassStateChanged(PseudoClass.getPseudoClass(<span class="hljs-string"><span class="hljs-string">"shiny"</span></span>), shiny.get()); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isShiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shiny.get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setShiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shiny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shiny.set(shiny); } }</code> </pre><br> 这里有几个重要部分： <br><br><ol><li> 我们具有<i>BooleanProperty</i> <i>布尔</i>属性，而不是通常的<i>boolean</i> 。 这意味着<i>有光泽的</i>对象是可观察到的，并且我们可以跟踪（监听）其值的变化。 </li><li> 我们注册一个侦听器，每当<i>闪亮</i>对象的值更改时，就会使用<i>shiny.addListener（）</i>进行<i>调用</i> 。 </li><li> 当<i>闪亮</i>值更改时，我们将根据<i>pseudoClassStateChanged（PseudoClass.getPseudoClass（“ shiny”），shiny.get（））</i>的当前值添加/删除<i>闪亮</i>伪<i>类</i> 。 </li><li> 我们为所有<i>闪亮标签标签</i>添加一个自定义类，而不是仅从父类继承<i>标签</i>类。 因此，我们只能选择<i>闪亮的</i>标签。 </li></ol><br><h3> 默认样式表 </h3><br> 即使您自己不提供任何样式，每个JavaFX应用程序也已经具有一些视觉样式。 有一个默认样式表适用于每个应用程序。 它称为<i>Modena</i> （从JavaFX 8开始，以前称为<i>caspian</i> ）。 <br><br> 可以在文件中找到此样式表： <br><br>  <i>jfxrt.jar \ com \ sun \ javafx \ scene \ control \ skin \ modena \ modena.css</i> <br><br> 或者您可以在<a href="">这里</a>找到文件。 在同一目录中，样式表使用了许多图像。 <br><br> 此样式表提供默认样式，但其优先级低于其他类型的样式表，因此您可以轻松地覆盖它。 <br><br><h3> 场景样式表 </h3><br> 除了上述默认样式表之外，您当然可以提供自己的样式表。 可以应用样式化的最高级别是整个场景。 您可以在FXML中实现此功能： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BorderPane</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://javafx.com/javafx"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:fx</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://javafx.com/fxml"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stylesheets</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> &gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BorderPane</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 或在您的Java代码中： <br><br><pre> <code class="java hljs">String stylesheet = getClass().getResource(<span class="hljs-string"><span class="hljs-string">"/styles.css"</span></span>).toExternalForm(); scene.getStylesheets().add(stylesheet);</code> </pre> <br> 注意对<i>externalForm（）</i>的调用。  Scene希望以字符串而不是文件的形式获取样式表的内容，因此我们需要以字符串的形式提供样式表的内容。 <br><br><h3> 父样式表 </h3><br> 除了整个场景的样式表之外，有时在布局级别上使用样式也很有用。 也就是说-对于单独的容器，例如VBox，HBox或GridPane。 所有布局的共同父对象是父类，该类定义用于在布局级别处理样式表的方法。 这些样式仅适用于此布局中的组件，不适用于整个场景。 布局级别的样式优先于场景级别的样式。 <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HBox</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stylesheets</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"styles.css"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HBox</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 在Java中，您需要自己加载样式表的内容，就像场景之前一样： <br><br><pre> <code class="java hljs">HBox box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HBox(); String stylesheet = getClass().getResource(<span class="hljs-string"><span class="hljs-string">"/styles.css"</span></span>).toExternalForm(); box.getStylesheets().add(stylesheet);</code> </pre> <br><h3> 内联样式 </h3><br> 到目前为止，我们仅研究了将外部样式表分配给整个场景或布局的情况。 但是您可以在组件级别设置单个样式属性。 <br><br> 在这里，您不必担心选择器，因为所有属性都是为特定组件设置的。 <br><br> 您可以指定用分号分隔的几个属性： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"-fx-background-color: blue; -fx-text-fill: white"</span></span></span><span class="hljs-tag">&gt;</span></span> I'm feeling blue. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Label</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 在Java中，可以使用<i>setStyle（）</i>方法： <br><br><pre> <code class="java hljs">Label label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"I'm feeling blue."</span></span>); label.setStyle(<span class="hljs-string"><span class="hljs-string">"-fx-background-color: blue; -fx-text-fill: white"</span></span>);</code> </pre><br> 组件级别的样式优先于场景样式以及布局级别的父样式。 <br><br><h3> 为什么需要避免它们 </h3><br> 组件级样式可以很方便，但这是一种快速而肮脏的解决方案。 您将放弃CSS的主要优点，即将样式与组件分离。 现在，您将视觉元素直接绑定到组件。 您不再能在必要时轻松切换样式表，也无法更改主题。 <br><br> 而且，您不再需要在单个中心位置定义样式。 当需要在一组相似的组件中进行更改时，需要分别更改每个组件，而不是仅在外部样式表中编辑一个位置。 因此，应避免内联组件样式。 <br><br><h3> 样式表优先级 </h3><br> 您可以在多个级别上提供样式-场景，父样式，内联样式，并且还有默认的调制解调器样式表。 如果您在多个级别上更改同一组件的相同属性，则JavaFX具有优先级设置，该设置确定应使用的样式。 优先级列表-从最高到最低： <br><br><ol><li> 内联样式 </li><li> 父样式 </li><li> 场景样式 </li><li> 默认样式 </li></ol><br> 这意味着，如果您在内联和场景级都设置了某个标签的背景色，则JavaFX将使用内联样式中设置的值，因为它具有更高的优先级。 <br><br><h3> 补充阅读 </h3><br>  JavaFX具有许多CSS属性，其描述超出了本文的范围；有关详细列表，请参见<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">JavaFX</a>的<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html">官方CSS参考指南</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477924/">https://habr.com/ru/post/zh-CN477924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477908/index.html">木偶3：无需一行代码即可进行自动化测试</a></li>
<li><a href="../zh-CN477910/index.html">黑色星期五2019-莫斯科和阿姆斯特丹的VDS，带GPU的服务器</a></li>
<li><a href="../zh-CN477912/index.html">具有E Ink Carta Mobius屏幕的10.3英寸PocketBook X阅读器的第一印象</a></li>
<li><a href="../zh-CN477914/index.html">投影在天花板上：使用投影机一周后的印象，放在“末端”</a></li>
<li><a href="../zh-CN477916/index.html">恶意软件的创建者如何尝试避免对其进行检测：我们以Spy.GmFUToMitm为例进行分析</a></li>
<li><a href="../zh-CN477926/index.html">如何使用生成器减少内存使用并加速Python代码</a></li>
<li><a href="../zh-CN477928/index.html">QA-mitap Redmadrobot的报告记录</a></li>
<li><a href="../zh-CN477930/index.html">MVP的最佳体系结构：整体式，SOA，微服务还是无服务器？..第2部分</a></li>
<li><a href="../zh-CN477934/index.html">房东在黑色星期五2019的折扣</a></li>
<li><a href="../zh-CN477936/index.html">IT字典还是什么？ 在哪 去哪里 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>