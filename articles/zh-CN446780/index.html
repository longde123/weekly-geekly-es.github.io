<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍✈️ 🌓 🍈 如何创造一个黑暗的主题而不是伤害。 Yandex.Mail团队经验 ⚫️ 🐍 🐉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我叫弗拉基米尔（Vladimir），我从事Yandex.Mail的移动前端。 在我们的应用程序中，已经有一个黑暗的话题，但是还不够：我们能够重绘界面和简单的字母。 但是格式化后的字母仍然保持浅色，并与深色界面形成对比，这可能会使我的眼睛在晚上疲倦。 


 今天，我将告诉哈勃（Habr）的读者我们如...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何创造一个黑暗的主题而不是伤害。 Yandex.Mail团队经验</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/446780/"><p><img src="https://habrastorage.org/webt/ji/4q/pr/ji4qprfkpuotssmzabus4cjflrq.png"></p><br><p> 我叫弗拉基米尔（Vladimir），我从事Yandex.Mail的移动前端。 在我们的应用程序中，已经有一个黑暗的话题，但是还不够：我们能够重绘界面和简单的字母。 但是格式化后的字母仍然保持浅色，并与深色界面形成对比，这可能会使我的眼睛在晚上疲倦。 </p><br><p> 今天，我将告诉哈勃（Habr）的读者我们如何解决这个问题。 您将了解不适合我们的两种简单方法，然后-了解页面自适应重绘的主要方法，最后了解下一次迭代的方向：重绘图片。 尽管任务本身（用任意格式重新粉刷页面）是特定的，但我认为我们的经验也将对您有所帮助。 </p><a name="habracut"></a><br><h2 id="prostye-sposoby"> 简单的方法 </h2><br><p> 在使用神奇的“ repainter”之前，我们尝试了两个简单的选择，例如软木塞：在元素上悬挂一个额外的深色样式或CSS过滤器。 他们不适合我们，但也许在某些情况下会更好（因为这很酷）。 </p><br><h3 id="pereopredelenie-stiley"> 替代样式 </h3><br><p> 最简单的方法是，以逻辑方式在CSS中扩展应用程序本身的深色主题：我们将深色样式悬挂在用于容纳字母的容器上（通常情况下，对于需要重绘其他人的内容）： </p><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; }</code> </pre> <br><p> 但是，如果字母中的元素具有自己的样式，它们将重新定义我们的根样式。 不<code>!important</code>无济于事。 您可以通过砍掉继承来挤压一个想法： </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> * { <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: black <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-color</span></span>: <span class="hljs-number"><span class="hljs-number">#333</span></span> <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre> <br><p> 在这种情况下，您不能没有<code>!important</code> ，因为选择器本身不是很具体。 此外，将需要重新定义内联样式（以及带有<code>!important</code>内联样式无论如何都会爬行​​，没有什么可做的）。 </p><br><p> 我们的风格相当笨拙，并且所有颜色都相同，因此又出现了另一个问题：也许设计师想通过排列颜色（元素优先级和其他设计师的东西）来表达一些想法，但我们还是放弃了整个想法。 </p><br><p><img src="https://habrastorage.org/webt/cu/-1/ka/cu-1kav8ydvyjxlobshlklgio9u.png"></p><br><p> 如果您比我更尊重设计师，并且仍然决定使用此方法，请不要忘记完成一些不明显的琐事： </p><br><ul><li>  <code>box-shadow</code> -只有颜色无法重新定义；您必须删除所有阴影或使用浅色阴影。 </li><li> 语义元素的颜色-链接，输入元素。 </li><li> 内联SVG-而不是<code>background</code>他们需要设置<code>fill</code> ，而不是<code>color</code> - <code>stroke</code> ，但这并不准确，具体取决于哪种SVG-可能相反，反之亦然。 </li></ul><br><p> 从技术上讲，该方法还不错：这是三行代码（好的，对于带重整情况的生产redi版本来说是三十行），与世界上所有浏览器兼容，开箱即用地处理动态页面，并且不绑定原始文档中样式的连接方式。 一个特别的好处是，您可以轻松地调整样式中的颜色，以使其适合主要应用程序（例如，使背景<code>#bbbbb8</code>而不是黑色）。 </p><br><p> 顺便说一句，我们曾经用这种方式重绘字母，但是如果我们发现字母内部有任何样式，我们就会感到害怕，并让字母亮起来。 </p><br><h3 id="css-filtr">  CSS过滤器 </h3><br><p> 非常机智和优雅的选择。 您可以使用CSS过滤器重新绘制页面： </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">filter</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">invert</span></span>(100) <span class="hljs-built_in"><span class="hljs-built_in">hue-rotate</span></span>(180deg); <span class="hljs-comment"><span class="hljs-comment">/* hue-rotate    */</span></span> }</code> </pre> <br><p> 此后，照片将变得令人毛骨悚然，但这没关系-我们将其重新粉刷： </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message-dark</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">img</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">filter</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">invert</span></span>(100) <span class="hljs-built_in"><span class="hljs-built_in">hue-rotate</span></span>(180deg); }</code> </pre> <br><p><img src="https://habrastorage.org/webt/dr/3a/ix/dr3aix8opihd2nlq6oqzjfbdtvs.png"></p><br><p> 内容图像通过<code>background</code>绑定仍然存在问题（我们知道调整宽高比更方便，但是语义呢？）。 假设我们可以找到所有这些元素，对其进行显式标记并重新粉刷它们。 </p><br><p> 该方法的优点在于它保留了亮度和对比度的原始比率。 另一方面，存在很多问题，而它们的好处远胜于它们： </p><br><p><img src="https://habrastorage.org/webt/ed/qe/h1/edqeh1dpkqv-w2gydobzojuaia0.png" width="300"></p><br><ol><li> 深色页面变浅。 </li><li> 最终的颜色无法控制-哪个滤镜可用于微调公司<code>#bbbbb8</code>的背景？ 谜语。 </li><li> 两次重新粉刷后，图片褪色。 </li><li> 一切都变慢了（尤其是在手机上）-这是合乎逻辑的，现在，浏览器不再需要简单的渲染，而是需要在每个屏幕上驱动图像处理。 </li></ol><br><p> 此方法适用于由中性色调的文字组成的字母，但是谁能获得完整的具有这种特殊内容的美感器呢？ 但是过滤器可以重新绘制其内容不可访问的元素-框架，Web组件，图片。 </p><br><h2 id="adaptivnaya-tema"> 响应主题 </h2><br><p> 现在是魔术的时候了！ 从前两种方法的缺点中，我们收集了一个清单： </p><br><ol><li> 使背景变暗，文本变浅，边框变中。 </li><li> 识别已经暗的页面，不要重新粉刷它们。 </li><li> 保持原始的亮度和对比度。 </li><li> 提供自定义颜色的功能。 </li><li> 保留开始时的音调。 </li></ol><br><p> 我们需要更改样式的颜色，以使背景变暗。 为什么不按字面意思做呢？ 我们只需要采用所有样式，查找与颜色（ <code>color</code> ， <code>background</code> ， <code>border</code> ， <code>box-shadow</code> ，它们的子属性）相关的规则，然后将其替换为“变黑”-变暗背景，变浅文本，使边界变暗小于背景，等等。 </p><br><p> 这种方法具有一个令人难以置信的优势，它将温暖任何开发人员的灵魂。 可以配置每个属性（是的，直接用代码来描述！）它自己的颜色转换规则。 有了足够的想象力，您就可以与任何外部主题集成，进行任何颜色校正（例如，使颜色为浅色或灰棕色覆盆子而不是深色主题），甚至还可以添加一些上下文，例如以不同的方式处理宽边框和窄边框。 </p><br><p> 缺点是js中所有内容的标准配置。 是的，我们运行脚本，破坏样式的封装并解析CSS regexp。 嗯，与HTML不同，后者并不是那么可耻，因为CSS语法（我们需要的水平）仍然是常规的。 </p><br><p> 重新粉刷计划如下： </p><br><ol><li> 我们对样式的旧属性（ <code>bgcolor</code>和friends）进行规范化，然后将其转移为<code>style="..."</code> 。 </li><li> 查找所有内联样式。 </li><li> 在每种样式中，我们都找到所有颜色规则（ <code>background-color</code> ， <code>color</code> ， <code>box-shadow</code>等）。 </li><li> 从所有颜色规则中，我们得到了颜色，我们找到了所需的转换器（背景为暗淡，文本为澄清）。 </li><li> 我们称转换器。 </li><li> 将转换后的规则放回CSS中。 </li></ol><br><p> 绑定（规范化，样式搜索，解析）非常简单。 我们将弄清楚魔术<em>转换器的</em>工作原理。 </p><br><h3 id="hsl-preobrazovaniya">  HSL转换 </h3><br><p>  “使颜色变暗”并不像看起来那样简单，特别是如果我们要保持色调（青色变为深蓝色，而不是橙色）时。 这可以在普通RGB中完成，但存在问题。 算法设计的爱好者知道，即使是那里的渐变也是弯曲的。 但是在HSL中使用颜色是一种纯粹的乐趣：除了不清楚要做什么的红色，绿色和蓝色外，我们还有其他三种渠道： </p><br><ul><li> 色调只是我们想要保留的基调。 </li><li> 饱和度-饱和度，这对我们现在不是很重要。 </li><li> 亮度-我们将改变的亮度。 </li></ul><br><p> 方便地以圆柱体的形式想象这样的空间。 我们的任务是将圆柱体倒置。 颜色分级功能的作用类似于<code>(h, s, l) =&gt; [h, s, 1 - l]</code> 。 </p><br><h3 id="cveta-s-kotorymi-i-tak-vsyo-horosho"> 一切都很好的颜色 </h3><br><p> 有时情况是成功的：字母（或其一部分）的专有设计已经很暗。 在这种情况下，您无需进行任何更改，最好保持安静，最好-设计师选择的颜色不会比我们的算法差。 在HSL中，只需查看L-亮度。 如果阈值较高（对于文本）或较低（对于背景）（当然是可自定义的），则我们什么也不做。 </p><br><h3 id="dinamicheskiy-cirk"> 动态马戏团 </h3><br><p> 尽管我们不需要它（再次感谢，消毒剂，您使我免于疯狂！），但我还是会告诉您自适应主题需要什么样的附件来使整页变暗，而不仅仅是90年代的愚蠢静态信件。 更准确地说，这对于喜欢早晨选择器气味的人来说是一项任务。 </p><br><h4 id="dinamicheskie-inlayn-stili"> 动态内联样式 </h4><br><p> 使我们的页面变暗的最简单情况是更改内联样式。 该操作很频繁，但是修复很简单：添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MutationObserver</code></a>并在更改时快速修复内联样式。 </p><br><h4 id="vneshnie-stili"> 外部风格 </h4><br><p> 由于异步和<code>@import</code> ，从页面内部使用<code>&lt;link&gt;</code>样式工作非常痛苦，而CORS不再有趣。 似乎可以通过网络工作者（ <code>*.css</code>代理）很好地解决此问题。 </p><br><h4 id="dinamicheskie-stili"> 动态风格 </h4><br><p> 最后，将所有问题汇总在一起，我们记得该脚本通常可以添加，删除和重新排列（特殊性！级联！） <code>&lt;style&gt;</code>和<code>&lt;link&gt;</code> ，甚至可以更改<code>&lt;style&gt;</code>的规则。 一切都由同一个<code>MutationObserver</code>解决，用于样式元素，但每次更改都会有更多处理。 </p><br><h4 id="css-peremennye">  CSS变量 </h4><br><p> 当CSS变量进入游戏时，将会出现全新的疯狂局面。 我们不能掩盖变量本身：即使我们假设我们将根据变量包含颜色的格式来猜测（尽管我不建议您这样做），也不清楚它将以什么角色遇到我们-背景，文本，边框，一次全部出现？ 而且，变量的值是继承的，因此我们不仅要考虑样式，还要考虑应用变量的元素，所有这些都会迅速升级和爆炸。 </p><br><p> 如果CSS变量成为主流，那我们就有问题了。 另一方面，到那时， <code>color()</code>已经启动，使用它可以不更改JS中的颜色，而只需用<code>color(var(--bg) lightness(-50%))</code>替换颜色即可。 </p><br><h3 id="rezyume"> 总结 </h3><br><p><img src="https://habrastorage.org/webt/46/rl/mz/46rlmzxvgus52n7_77t3ydz2ms0.png"></p><br><p> 对于我们的情况，当消毒剂仅保留内联样式时，在CSS级别上的自适应调光效果很好：它提供了最佳的调光质量，不会打断字母，并且相对快速且容易地工作。 不知道所有带有动态填充的选项是否值得。 幸运的是，如果您使用用户生成的内容并且不编写浏览器，则您的清理程序也应该执行相同的操作。 </p><br><p> 在实践中，自适应模式应与样式的重新定义一起使用：样式通常不显式应用于诸如<code>&lt;input&gt;</code>或<code>&lt;a&gt;</code>类的标准元素，但默认情况下它们为浅色。 </p><br><h2 id="kak-zatemnyat-kartinki"> 如何使图片变暗 </h2><br><p> 重新粉刷图片是一个困扰我个人的独立问题。 这很有趣，我终于有机会使用“光谱分析”一词。 在黑暗的被摄对象中存在几个常见的问题。 </p><br><p> 首先，图片太亮。 它的工作方式与所有未上漆的字母相同。 这些照片通常（但不一定）是普通照片。 由于时事通讯的布局不是很有趣，所以许多人只是将信件的复杂部分导出为图片，而不会重新粉刷，并且在晚上阐明了我的完美主义。 此类图片需要变暗，但不能反转-否则会出现可怕的底片。 </p><br><p><img src="https://habrastorage.org/webt/6-/zz/nx/6-zznxvkap9ywdvgjpglm5v6wqc.png"></p><br><p> 其次，具有真实透明度的深色图片。 此问题通常在徽标上发现-它们是为浅色背景设计的，当我们将其替换为深色背景时，请将其合并。 此类图片需要反转。 </p><br><p><img src="https://habrastorage.org/webt/xo/at/cc/xoatcc7dg3nhb_ufdoyye4hxsoo.png"></p><br><p> 中间某处有一些图片，白色代表“透明背景”，但是现在它们只是站在一些奇怪的白色矩形中。 在理想的世界中，我们将白色背景替换为透明背景，但是如果您曾经在照片编辑器中使用过魔杖，那么您会知道自动执行此操作并不那么容易。 </p><br><p><img src="https://habrastorage.org/webt/fi/o4/v9/fio4v9n1lcpve_wa1jhj5usj4yo.png"></p><br><p> 有趣的是，有时图片根本没有任何意义-它们是跟踪像素和特殊格式的“格式持有者”。 可以安全地使它们不可见（例如， <code>opacity: 0</code> ）。 </p><br><p><img src="https://habrastorage.org/webt/5y/ba/tu/5ybatucrfhczsgc_aqykbgtnop0.png"></p><br><h3 id="evristiki-s-introspekciey"> 内省启发法 </h3><br><p> 要决定如何处理图片，我们需要深入并分析其内容-并以简单快速的方式进行。 根据我们的一系列问题，该算法的第一个版本迫在眉睫。 她在那儿。 </p><br><p> 我们考虑图片中的暗，亮和透明像素，而不是全部像素，而是选择性地-明显的优化。 我们确定图片的整体亮度（亮，暗，中）和透明度。 反转具有透明度的黑暗图像，没有透明度的光-静音，请勿触摸其余部分。 </p><br><p> 当我看到一本慈善通讯和一本非洲学校的课程照片时，这种奇妙的启发式游戏的乐趣就结束了。 一切都很好，但设计人员将其居中，并在边缘添加了透明像素。 我们不想让自己陷入有关冒犯性图片识别的新故事的中心，因此我们决定在第一版中根本不进行图像处理。 </p><br><p> 将来，我称之为“光谱分析”的另一种启发式方法应该可以防止此类问题的发生-我们计算图片中不同颜色的数量，并仅在颜色数量很少的情况下将其反转。 可以使用相同的标准来搜索图形光图片并对其重新粉刷-听起来很诱人。 </p><br><p><img src="https://habrastorage.org/webt/sj/c1/di/sjc1diiz68fpljjzii64f9j7nrq.png"></p><br><h2 id="itog"> 总结 </h2><br><p> 对于邮件中一个完整的深色主题，我们缺少带有样式的粉刷字母，因此我们想出了如何安排它。 纯CSS中的两个简单选项-重新定义样式和CSS过滤器-无效：第一个选项在原始设计上太难了，第二个效果不好。 结果，我们使用了自适应调光-我们解析样式，用更合适的颜色替换颜色，然后将它们收集回来。 现在，我们正在努力将主题扩展为图片-为此，我们需要分析其内容并仅重绘一些内容。 </p><br><p> 如果您需要将自定义HTML重新绘制为深色主题，请记住以下三种方法： </p><br><ul><li> 覆盖样式-无论如何，主要和便宜的样式都需要它，但是它会杀死所有原始颜色。 </li><li>  CSS过滤器很酷，但是它可以正常工作。 仅用于不透明（就访问而言）元素，例如框架或Web组件。 </li><li> 转换样式-使高质量变暗，但比其他方法复杂。 </li></ul><br><p> 即使您从未这样做，也希望您玩得开心！ </p><br><p>  <strong>有用的链接</strong> ： </p><br><ol><li><p> 如果您有兴趣在Android的开发环境中热烈讨论这个主题，那么我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邀请您</a> 4月18日<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">访问</a> Yandex的Petersburg办公室。 </p><br></li><li><p> 最近，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讨论</a>了解决邮件用户的另一个问题-邮件问题。 </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446780/">https://habr.com/ru/post/zh-CN446780/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446768/index.html">标称键入TypeScript或如何保护界面不受外来标识符的影响</a></li>
<li><a href="../zh-CN446770/index.html">大多数教程中找不到12个JavaScript技巧</a></li>
<li><a href="../zh-CN446772/index.html">不要打开通往世界的港口-它们会破坏您（有风险）</a></li>
<li><a href="../zh-CN446774/index.html">低聚角色设计</a></li>
<li><a href="../zh-CN446776/index.html">工作量证明有效</a></li>
<li><a href="../zh-CN446782/index.html">溜溜球和一瓶朗姆酒</a></li>
<li><a href="../zh-CN446786/index.html">为什么我拒绝Disqus，您也应该去</a></li>
<li><a href="../zh-CN446788/index.html">Kubernetes提示和技巧：关于本地开发和网真</a></li>
<li><a href="../zh-CN446790/index.html">我如何在Android的安全性中发现复活节彩蛋而没有在Google找到工作</a></li>
<li><a href="../zh-CN446794/index.html">我们可以正确使用Wordstat。 完整指南</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>