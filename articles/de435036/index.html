<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèΩ üöî ü§ò Gedanken zur modernen C ++ - und Spieleentwicklung üë®üèæ‚Äçüé§ ü§æüèº ü§º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das neue Jahr f√ºr Spieleentwickler begann mit einer Welle von Kritik, die nach der Ver√∂ffentlichung von Aras Prankevichus 'Beschwerden √ºber modernes C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gedanken zur modernen C ++ - und Spieleentwicklung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435036/">  <i>Das neue Jahr f√ºr Spieleentwickler begann mit einer Welle von Kritik, die nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ver√∂ffentlichung von Aras Prankevichus 'Beschwerden √ºber modernes C ++</a> auf das C ++ - Standardisierungskomitee fiel.</i>  <i>Es stellte sich eine ernste Frage: Hat das Standardkomitee wirklich den Kontakt zur Realit√§t verloren oder ist es umgekehrt, und brechen diese Spieleentwickler vom Rest der C ++ - Community ab?</i> <i><br><br></i>  <i>Wir bieten Ihnen eine √úbersetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beliebten Postens von</a> Ben Dean, einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veteranen der Spielebranche</a> , der lange Zeit als C ++ - Entwickler und Teamleiter bei Blizzard, Electronic Arts und Bullfrog gearbeitet hat und in dem er auf Kritik aus seiner eigenen Erfahrung reagiert.</i> <br><blockquote> TL; DR: Das C ++ Standardization Committee hat nicht das versteckte Ziel, die Bed√ºrfnisse von Spieleentwicklern zu ignorieren, und "modernes" C ++ wird keine "debuggte" Sprache. </blockquote>  In der vergangenen Woche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gab</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Twitter</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine aktive Diskussion</a> , in der viele Programmierer - insbesondere diejenigen, die auf dem Gebiet der Spieleentwicklung arbeiten - darauf hinwiesen, dass der aktuelle Entwicklungsvektor von ‚Äûmodernem C ++‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht ihren Anforderungen entspricht</a> .  Insbesondere vom Standpunkt eines gew√∂hnlichen Spieleentwicklers sieht alles so aus, als w√ºrde die Debugging-Leistung in der Sprache ignoriert, und Codeoptimierung wird erwartet und notwendig. <br><br>  Aufgrund der Tatsache, dass ich 2019 mehr als 23 Jahre in der Spielebranche gearbeitet habe, habe ich meine eigene Meinung, die auf Beobachtungen zu diesem Thema in Bezug auf die Spieleentwicklung basiert, die ich gerne teilen m√∂chte.  Ist das Debuggen f√ºr Spieleentwickler wichtig und warum?  Was sind die damit verbundenen Probleme? <br><br>  Zun√§chst einmal - ein kleiner Exkurs in die Geschichte. <br><a name="habracut"></a><br>  Viele C ++ - Spieleentwickler arbeiten in Microsoft Visual C ++.  In der Vergangenheit hat sich um Microsoft-Plattformen ein riesiger Markt f√ºr Spiele gebildet, der die typische Erfahrung eines normalen Spieleprogrammierers beeintr√§chtigt hat.  In den 90er und 2000er Jahren wurden die meisten Spiele unter diesen Umst√§nden geschrieben.  Selbst mit dem Aufkommen von Konsolen anderer Hersteller und der wachsenden Beliebtheit von Handyspielen sind das Eigentum vieler AAA-Studios und zahlreicher Spieleprogrammierer heute Tools von Microsoft. <br><br>  Visual Studio ist wohl der beste Debugger f√ºr C ++ der Welt.  Dar√ºber hinaus sticht Visual Studio beim Debuggen von Programmen am meisten hervor - mehr als beim Front-End, Back-End, der STL-Implementierung oder anderen Dingen.  In den letzten f√ºnf Jahren hat Microsoft erhebliche Fortschritte bei der Entwicklung von C ++ - Entwicklungstools erzielt, aber schon vorher war der Debugger in Visual Studio immer sehr cool.  Wenn Sie also auf einem Windows-PC entwickeln, haben Sie immer einen erstklassigen Debugger zur Hand. <br><br>  Schauen wir uns vor diesem Hintergrund den Prozess zum Abrufen von Code an, bei dem keine Fehler auftreten.  M√∂glichkeiten, die wir aus der Sicht eines Programmierers haben, der sich nicht mit Spielen befasst;  sowie die Einschr√§nkungen, mit denen Spieleentwickler konfrontiert sind.  Wenn Sie das Hauptargument zugunsten des "Entwicklungsvektors von modernem C ++" umformulieren, wird es auf Typen, Tools und Tests reduziert.  Nach diesem Gedanken sollte der Debugger die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzte Verteidigungslinie sein</a> .  Bevor wir es erreichen, haben wir die folgenden Optionen. <br><br><h3>  Gelegenheit Nr. 1: Typen </h3><br>  Wir k√∂nnen so viel starke Typisierung wie n√∂tig verwenden, um ganze Fehlerklassen beim Kompilieren zu beseitigen.  Starkes Tippen ist ohne Zweifel eine Chance, die uns die j√ºngste Entwicklung von C ++ geboten hat.  Ab C ++ 11 haben wir beispielsweise Folgendes erreicht: <br><br><ul><li> signifikante Erweiterung der <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">type traits</a></code> ; </li><li>  Innovationen wie <code>nullptr</code> und <code>scoped enum</code> zur Bek√§mpfung des C-Erbes - schwache Typisierung; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GSL</a> und Hilfswerkzeuge; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konzepte</a> in C ++ 20. </li></ul><br>  Einige von Ihnen m√∂gen m√∂glicherweise keine Metaprogrammierung f√ºr Vorlagen.  Andere m√∂gen den Codierungsstil, der <code>auto</code> fast universell verwendet, m√∂glicherweise nicht.  Unabh√§ngig von diesen Einstellungen wird hier das Hauptmotiv f√ºr die Verwendung der aufgelisteten Stile in C ++ klar nachgezeichnet - dies ist der Wunsch, dem Compiler zu helfen, damit er uns wiederum helfen kann, indem er gleichzeitig das verwendet, was er am besten wei√ü: das Typsystem. <br><br>  Wenn wir √ºber Spieleprogrammierung sprechen, ist das starke Tippen hier ein weites Forschungsfeld und wird von mir bekannten Spielprogrammierern aktiv genutzt, die daran interessiert sind, ihre F√§higkeiten im Umgang mit C ++ in der Praxis zu verbessern.  Zwei wichtige Dinge sind hier von Belang: die Auswirkung auf die Kompilierungszeit und die Auswirkung auf die Lesbarkeit des Codes. <br><br>  Ehrlich gesagt k√∂nnen Sie die Kompilierungszeit leicht ignorieren - aber nur unter der Bedingung, dass Sie Programmierer in einem sehr gro√üen Unternehmen sind, das keine Spiele spielt und √ºber eine etablierte interne Infrastruktur und endlose Rechenleistung verf√ºgt, um jeden Code zu kompilieren, den Sie schreiben k√∂nnen .  Solche gro√üen Unternehmen sind besorgt √ºber die Kosten f√ºr die Kompilierung - daher verwenden sie Module -, aber dies verursacht in der Regel keine Schmerzen f√ºr einzelne Entwickler.  Gleichzeitig ist dies f√ºr die meisten Spielprogrammierer nicht der Fall.  Indie-Entwickler m√ºssen keine Farmen bauen.  AAA-Spieleentwickler verwenden h√§ufig so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Incredibuild</a> . Angesichts der Tatsache, dass sie problemlos mit einer Codebasis arbeiten k√∂nnen, die 10 Jahre oder √§lter ist, kann der Erstellungsprozess dennoch 15 bis 20 Minuten dauern. <br><br>  Wir k√∂nnen √ºber die relativen Kosten f√ºr das Hinzuf√ºgen von Hardware im Vergleich zu den Kosten f√ºr die Zeit des Programmierers streiten, und ich stimme der Ansicht zu, dass Hardware jedoch billiger ist: <br><br><ul><li>  Hardware ist eine echte einmalige Ausgabe, die dem Budget des laufenden Quartals zugewiesen wird, im Gegensatz zu nicht so greifbaren Ausgaben in Bezug auf Zeit / Einstellung / und dergleichen, die √ºber einen l√§ngeren Zeitraum verteilt werden.  Die Entscheidung f√ºr einen solchen Kompromiss kommt den Menschen nicht gut, und Unternehmen sind speziell so aufgebaut, dass sie den kurzfristigen Gewinn optimieren. </li><li>  Die Infrastruktur ben√∂tigt Unterst√ºtzung, und fast niemand steigt in die Spielebranche ein, um Release-Ingenieur zu werden.  Im Vergleich zu anderen Bereichen, in denen C ++ verwendet wird, ist das Gehalt der Spieleentwickler nicht so hoch - und Nicht-Spieleingenieure werden hier noch weniger bezahlt. </li></ul><br>  Man kann auch dar√ºber spekulieren, dass die Kompilierungszeit niemals einen solchen Zustand h√§tte erreichen d√ºrfen;  und wieder stimme ich dir zu.  Der Preis hierf√ºr ist st√§ndige Wachsamkeit - wiederum von einem Release-Ingenieur - und im Idealfall ein automatisiertes Tool, mit dem Sie √Ñnderungen in der f√ºr die Erstellung des Builds erforderlichen Zeit verfolgen k√∂nnen.  Gl√ºcklicherweise kann dieses Ziel mit dem Aufkommen von CI-Systemen heute viel einfacher erreicht werden. <br><br><h3>  Gelegenheit Nr. 2: Werkzeuge </h3><br>  Wir sollten das Maximum der uns zur Verf√ºgung stehenden Tools verwenden - Warnungen, statische Analysen, Desinfektionsmittel, Tools f√ºr dynamische Analysen, Profiler und andere. <br><br>  Ich habe die Erfahrung gemacht, dass Spieleentwickler diese Tools verwenden, wo immer dies m√∂glich ist, aber hier hat die gesamte Branche mehrere Probleme: <br><br><ul><li>  Diese Tools funktionieren in der Regel besser auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nicht-Microsoft-</a> Plattformen - und wie bereits erw√§hnt, ist dies kein typisches Spielentwicklungsszenario. </li><li>  Die meisten dieser Tools sind auf die Arbeit mit "Standard" C ++ ausgerichtet.  Sie unterst√ºtzen <code>CStaticVector</code> <code>std::vector</code> , aber nicht meine selbstgeschriebene Klasse <code>CStaticVector</code> aus einer hypothetischen Engine.  Nat√ºrlich ist es nutzlos, die Tools zu beschuldigen, aber dies ist immer noch eines der Hindernisse f√ºr ihre Verwendung, die Entwickler √ºberwinden m√ºssen. </li><li>  Das Erstellen und Verwalten einer CI-Kette, in der alle diese Tools ausgef√ºhrt werden, erfordert die Anwesenheit von Release-Ingenieuren. Wie bereits erw√§hnt, ist die Einstellung von Mitarbeitern f√ºr Ingenieurjobs, die nicht direkt mit Spielen zusammenh√§ngen, ein systemisches Problem f√ºr die Spielebranche. </li></ul><br>  Warum verwenden Spieleentwickler STL nicht, da diese Tools mit Standard-C ++ so gut funktionieren? <br><br>  Wo soll die Antwort auf diese Frage beginnen?  Vielleicht vom n√§chsten Ausflug in die Geschichte der Spieleentwicklung: <br><br><ul><li>  Bis in die fr√ºhen 90er Jahre vertrauten wir C-Compilern nicht und schrieben Spiele in Assembler. </li><li>  Von Anfang bis Mitte der 90er Jahre vertrauten wir C-Compilern, aber wir vertrauten C ++ - Compilern immer noch nicht.  Unser Code war C, der Kommentare im C ++ - Stil verwendete, und wir mussten nicht mehr st√§ndig Typedefs f√ºr unsere Strukturen schreiben. </li><li>  Um das Jahr 2000 fand die C ++ - Revolution in der Welt der Spieleentwicklung statt.  Es war eine √Ñra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Designmustern</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üen Klassenhierarchien</a> .  Zu dieser Zeit lie√ü die STL-Unterst√ºtzung auf Konsolen zu w√ºnschen √ºbrig, und Konsolen beherrschten damals die Welt.  Auf PS2 bleiben wir f√ºr immer bei GCC 2.95. </li><li>  Um 2010 wurden zwei weitere Revolutionen gestartet.  Der Schmerz, gro√üe Klassenhierarchien zu verwenden, stimulierte die Entwicklung eines Komponentenansatzes f√ºr Code.  Diese √Ñnderung setzt ihre heutige Entwicklung in Form von Entity-Component-System-Architekturen fort.  Hand in Hand damit war die zweite Revolution - ein Versuch, Multiprozessor-Architekturen zu nutzen. </li></ul><br>  W√§hrend dieser Paradigmenwechsel √§nderten sich die Spieleentwicklungsplattformen selbst st√§ndig und sie √§nderten sich ernsthaft.  Der segmentierte Speicher ist einem flachen Adressraum gewichen.  Die Plattformen sind Multiprozessor geworden, symmetrisch und nicht sehr.  Spieleentwickler, die an die Arbeit mit Intel-Architekturen gew√∂hnt waren, mussten sich an MIPS (Playstation) gew√∂hnen, dann an eine spezielle Hardware mit heterogenen CPUs (PS2), dann an PowerPC (XBox 360), dann an noch gr√∂√üere Heterogenit√§t (PS3) ... Die neue Plattform verf√ºgt √ºber neue Leistungsmerkmale f√ºr Prozessoren, Speicher und Laufwerke.  Wenn Sie eine optimale Leistung erzielen wollten, mussten Sie Ihren alten Code h√§ufig und h√§ufig neu schreiben.  Ich werde nicht einmal erw√§hnen, wie sehr die Spiele durch die Entstehung und das Wachstum der Popularit√§t des Internets sowie durch die Einschr√§nkungen beeinflusst wurden, die Plattforminhaber den Entwicklern auferlegt haben. <br><br>  In der Vergangenheit waren STL-Implementierungen auf Spieleplattformen unbefriedigend.  Es ist kein Geheimnis, dass STL-Container f√ºr Spiele schlecht geeignet sind.  Wenn Sie den Spieleentwickler an die Wand schieben, gibt er vielleicht zu, dass <code>std::string</code> ganz in Ordnung ist und <code>std::vector</code> eine vern√ºnftige Standardoption ist.  Alle in der STL enthaltenen Container haben jedoch ein Problem mit der Kontrolle der Zuordnung und Initialisierung.  Viele Spiele m√ºssen sich √ºber Speicherbeschr√§nkungen f√ºr verschiedene Aufgaben Gedanken machen - und f√ºr Objekte, f√ºr die der Speicher w√§hrend des Spiels h√∂chstwahrscheinlich dynamisch zugewiesen werden muss, werden h√§ufig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Platten-</i></a> oder <i>Arena-</i> Allokatoren verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amortisierte konstante Zeit</a> ist kein gutes Ergebnis, da die Zuweisung m√∂glicherweise eines der ‚Äûteuersten‚Äú Dinge ist, die w√§hrend der Programmausf√ºhrung passieren k√∂nnen, und ich m√∂chte keinen Frame √ºberspringen, nur weil es passiert ist, als ich es nicht erwartet habe .  Als Spieleentwickler muss ich meinen Speicherbedarf im Voraus verwalten. <br><br>  Eine √§hnliche Geschichte wird f√ºr andere Abh√§ngigkeiten im Allgemeinen erhalten.  Spieleentwickler m√∂chten wissen, was jeder Prozessorzyklus ben√∂tigt, wo und wann und wof√ºr jedes Byte Speicher verantwortlich ist und wo und wann jeder Ausf√ºhrungsthread gesteuert wird.  Bis vor kurzem haben Microsoft-Compiler ABI mit jedem Update ge√§ndert. Wenn Sie also viele Abh√§ngigkeiten hatten, kann das Wiederherstellen aller Abh√§ngigkeiten ein schmerzhafter Prozess sein.  Spieleentwickler bevorzugen normalerweise kleine Abh√§ngigkeiten, die einfach zu integrieren sind, nur eines tun und gut funktionieren - vorzugsweise mit einer API im C-Stil - und von vielen Unternehmen verwendet werden, gemeinfrei sind oder eine kostenlose Lizenz haben, die dies nicht tut erfordert eine Angabe des Autors.  <i>SQLite</i> und <i>zlib</i> sind gute Beispiele daf√ºr, was Spieleentwickler bevorzugen. <br><br>  Dar√ºber hinaus hat die C ++ - Spielebranche eine reiche Geschichte von Patienten mit dem Syndrom ‚ÄûHier nicht erfunden‚Äú.  Dies sollte von der Branche erwartet werden, die mit einzelnen Enthusiasten begann, die ihre eigenen Sachen mit v√∂llig neuen Ger√§ten herstellten und keine anderen Optionen hatten.  Die Spielebranche ist unter anderem die einzige, in der Programmierer in keiner bestimmten Reihenfolge im Abspann angegeben sind.  <i>Das Schreiben einer Vielzahl von Dingen macht Spa√ü und hilft Ihrer Karriere!</i>  <i>Es ist viel besser, etwas Eigenes zu bauen, als fertige zu kaufen!</i>  Und da wir uns so gro√üe Sorgen um die Leistung machen, k√∂nnen wir unsere L√∂sung so anpassen, dass sie speziell f√ºr unser Projekt geeignet ist - anstatt eine allgemeine L√∂sung zu w√§hlen, die die verf√ºgbaren Ressourcen sinnlos verschwendet.  Die Feindseligkeit gegen√ºber Boost ist das Hauptbeispiel daf√ºr, wie sich ein solches Denken in der Spieleentwicklung manifestiert.  Ich habe an Projekten gearbeitet, die folgenderma√üen abliefen: <br><br><ul><li>  Um ein bestimmtes Problem zu l√∂sen, verbinden wir zun√§chst eine Bibliothek von Boost mit dem Projekt. </li><li>  Alles funktioniert sehr gut.  Wenn Sie ein Update durchf√ºhren m√ºssen, treten einige Schmerzen auf, jedoch nicht mehr als beim Aktualisieren einer anderen Abh√§ngigkeit. </li><li>  Ein anderes Spiel m√∂chte unseren Code verwenden, aber der Stolperstein ist, dass wir Boost verwenden - trotz der Tatsache, dass unsere Erfahrung mit Boost ganz gut gelaufen ist. </li><li>  Wir entfernen den Code mit Boost, aber jetzt stehen wir vor einem neuen Problem: Wir m√ºssen das Problem l√∂sen, das die Bibliothek von Boost anstelle unserer zuvor gel√∂st hat. </li><li>  Wir kopieren im Wesentlichen die Teile des Boost-Codes, die wir ben√∂tigen, in unsere eigenen Namespaces. </li><li>  Sp√§ter sto√üen wir unweigerlich und immer wieder auf die Tatsache, dass wir zus√§tzliche Funktionen ben√∂tigen, die bereits im Originalcode enthalten w√§ren, wenn wir sie nicht weggeworfen h√§tten.  Aber jetzt sind wir die Eigent√ºmer dieses Codes, also m√ºssen wir ihn weiterhin unterst√ºtzen. </li></ul><br>  Wir m√∂gen nichts Gro√ües, das versucht, zu viele Dinge gleichzeitig zu tun, oder das die Kompilierungszeit beeinflussen kann - und das ist durchaus vern√ºnftig.  Was Menschen immer wieder Fehler machen, ist, dass sie es ablehnen, den vermeintlichen Schmerz heute zu akzeptieren - w√§hrend sie aufgrund dieser Entscheidung mit der Unterst√ºtzung von etwas auf Kosten von jemandem einem sehr realen und viel gr√∂√üeren Schmerz gegen√ºberstehen werden - das Budget, das sie in den n√§chsten drei Jahren haben m√ºssen.  Leider kann das Vorhandensein von Beweisen in Form von Spielen, die ein Gericht von STL und Boost erfolgreich verwenden, die menschliche Psychologie in keiner Weise beeinflussen und Spieleentwickler √ºberzeugen. <br><br>  Aus all diesen Gr√ºnden haben viele Spielefirmen ihre eigenen Bibliotheken erstellt, die die Funktionen von STL - und noch mehr - abdecken und gleichzeitig spielspezifische Anwendungsf√§lle unterst√ºtzen.  Einige gro√üe Spielefirmen konnten sogar die Entwicklung ihres eigenen, vollwertigen, fast vollst√§ndig API-kompatiblen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STL-Ersatzes</a> meistern, was in der Folge enorme Kosten f√ºr die Unterst√ºtzung dieses Projekts mit sich brachte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es ist ratsam, eine verbesserte Alternative zu</a> <code>std::map</code> finden oder die <i>Optimierung kleiner Puffer</i> in <code>std::vector</code> anzuwenden.  Es ist viel weniger akzeptabel, zum Scheitern verurteilt zu sein, um Ihre eigenen Implementierungen von <code>algorithms</code> oder Typmerkmalen zu unterst√ºtzen, was wenig n√ºtzt.  F√ºr mich ist es bedauerlich, dass STLs f√ºr die meisten Entwickler nur Container sind.  Da ihnen beim Erlernen von STL zu Beginn genau das beigebracht wird, implizieren die meisten von STL <code>std::vector</code> - obwohl sie eigentlich √ºber <code>std::find_if</code> nachdenken <code>std::find_if</code> . <br><br><h3>  Gelegenheit Nr. 3: Tests </h3><br>  Es wird argumentiert, dass umfangreiche Tests durchgef√ºhrt werden sollten, TDD und / oder BDD den gesamten Code abdecken sollten, der abgedeckt werden kann, und Fehler sollten durch Schreiben neuer Tests behoben werden. <br><br>  Lassen Sie uns daher das Thema Testen diskutieren. <br><br>  Nach meiner Erfahrung werden automatisierte Tests in der Spielebranche praktisch nicht eingesetzt.  Warum? <br><br><h4>  1. Weil Korrektheit <i>nicht so</i> wichtig ist, aber es keine wirkliche Spezifikation gibt </h4><br>  Als junger Programmierer in der Spielebranche wurde ich schnell von der Idee befreit, dass ich mich bem√ºhen sollte, etwas realistisch zu simulieren.  Spiele sind <i>Rauch und Spiegel</i> und die Suche nach kurzen Wegen.  Es interessiert niemanden, wie realistisch Ihre Simulation ist.  Hauptsache, es macht Spa√ü.  Wenn Sie keine andere Spezifikation als "Das Spiel sollte sich richtig anf√ºhlen" haben, fehlt das Thema Test.  Dank Bugs kann das Gameplay sogar noch besser werden.  Sehr oft kommt ein Fehler in die Ver√∂ffentlichung und gewinnt sogar die Liebe der Benutzer ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erinnern Sie sich an denselben Gandhi aus Civilization</a> ).  Spiele unterscheiden sich von anderen Bereichen, die C ++ verwenden.  hier f√ºhrt ein Mangel an Korrektheit nicht dazu, dass jemand irgendwann seine Ersparnisse verliert. <br><br><h4>  2. Weil es schwer ist </h4><br>  Nat√ºrlich m√∂chten Sie automatisierte Tests erstellen, wo immer Sie k√∂nnen.  Dies kann f√ºr einige Subsysteme durchgef√ºhrt werden, f√ºr die eindeutig festgelegte Endergebnisse vorliegen.  Unit-Tests in der Spielebranche sind nat√ºrlich vorhanden, aber in der Regel sind sie auf Low-Level-Code beschr√§nkt - die zuvor erw√§hnten STL-Analoga, String-Konvertierungsverfahren, physikalische Engine-Methoden usw.  Die F√§lle, in denen der ausf√ºhrbare Abschnitt des Codes vorhersehbare Ergebnisse aufweist, werden normalerweise durch Komponententests getestet, obwohl TDD hier nicht verwendet wird - da Spielprogrammierer es vorziehen, ihr Leben zu vereinfachen und nicht umgekehrt.  Aber wie testest du den Gameplay-Code (siehe Punkt eins)?  Sobald Sie √ºber Unit-Tests hinausgehen, sto√üen Sie sofort auf einen anderen Grund, warum das Testen von Spielen so schwierig ist. <br><br><h4>  3. Weil der Inhalt beteiligt ist </h4><br>  Das Testen nicht trivialer Systeme wird wahrscheinlich die Bereitstellung von Inhalten umfassen, mit denen es implementiert wird.  Die meisten Ingenieure sind nicht sehr gut darin, diese Inhalte selbst zu erstellen. Um einen aussagekr√§ftigen Test zu erhalten, m√ºssen Sie jemanden mit den richtigen F√§higkeiten f√ºr die Erstellung der Inhalte gewinnen.  Danach sto√üen Sie auf das Problem, zu messen, was Sie auf der Ausgabe erhalten - schlie√ülich handelt es sich nicht mehr um eine Linie oder eine Zahl, sondern um ein Bild auf dem Bildschirm oder einen Ton, der sich im Laufe der Zeit √§ndert. <br><br><h4>  4. Weil wir es nicht praktizieren </h4><br>  Unit Testing ist eine Funktion, f√ºr die ich die m√∂glichen Ein- und Ausg√§nge kenne.  Das Gameplay ist jedoch ein unvorhersehbares, sich dynamisch entwickelndes Verhalten, und ich wei√ü nicht, wie ein solches Ph√§nomen richtig getestet werden k√∂nnte.  Was kann ich testen - wenn ich nat√ºrlich von meinem Manager die Erlaubnis bekomme, gen√ºgend Zeit daf√ºr aufzuwenden - dies sind zum Beispiel Leistung oder hochrangige Funktionen wie Matchmaking, die ich analysieren kann.  Eine solche Infrastrukturarbeit mag f√ºr einige Spielprogrammierer aufregend sein, ist aber f√ºr die meisten einfach nicht interessant und erfordert au√üerdem die Genehmigung und Unterst√ºtzung des Besitzers der Brieftasche.  Als Spielprogrammierer habe ich nie die M√∂glichkeit, das Schreiben von Tests auf hohem Niveau zu √ºben. <br><br><h4>  5. Da [Unternehmen] keine Notwendigkeit f√ºr automatisierte Tests sieht </h4><br>  Unser Hauptziel ist es, das Spiel zu ver√∂ffentlichen.  Wir leben in einer √Ñra der Industrie, die mit Hits voranschreitet, die im ersten Verkaufsmonat das Beste aus ihrem Geld machen, wenn die Marketingkosten dieser Hits maximiert werden.  Der Lebenszyklus von Konsolen hat uns gelehrt, dass der Code auf keinen Fall so lange leben wird.  Wenn wir an einem Online-Spiel arbeiten, erhalten wir h√∂chstwahrscheinlich zus√§tzliche Zeit zum Testen des Matchmaking oder der Serverlast.  Da f√ºr die Ver√∂ffentlichung des Spiels die Leistung in Ordnung sein muss, sollten wir zumindest Leistungstests durchf√ºhren, diesen Prozess jedoch nicht automatisieren.  F√ºr das Management in der Spielebranche ist automatisiertes Testen nichts anderes als Zeit- und Geldverschwendung.  F√ºr die Implementierung m√ºssen erfahrene Ingenieure eingestellt werden, die die Arbeiten ausf√ºhren, deren Ergebnis kaum wahrnehmbar ist.  Die gleiche Zeit k√∂nnte f√ºr die Entwicklung neuer Funktionen aufgewendet werden.  Kurzfristig ist es viel rentabler, QA-Mitarbeiter zum Testen des Spiels einzusetzen, was uns zum n√§chsten Punkt bringt. <br><br><h4>  6. Weil das Testen in Spielen im Allgemeinen als zweitklassige Aktivit√§t eingestuft wird </h4><br>  Ich liebe gute QS-Profis.  F√ºr mich sind sie Gold wert.  Sie wissen, wie Sie Ihr Spiel verbessern k√∂nnen, indem Sie es auf eine Weise brechen, die Ihnen nie in den Sinn gekommen w√§re.  Sie sind spezialisierte Experten in Ihrem Gameplay in dieser Hinsicht, die Sie nicht verstehen und kaum jemals verstehen.  Sie sind besser als ein Team von hochqualifizierten Compilern, die Ihnen helfen, alles richtig zu machen.  Ich bin froh, dass ich im Laufe der Jahre die Gelegenheit hatte, mit mehreren wunderbaren QS-Spezialisten zusammenzuarbeiten. <br><br>  Ich musste fast immer k√§mpfen, um sicherzustellen, dass sie in meinem Team blieben. <br><br>   AAA-, ,  QA ‚Äî         ,       .     ,         .  ,      . <br><br>   ,      ,              ,       .   ¬´¬ª   ,       ,  QA   ,          ,        ,          . <br><br>   .             ,     .      QA-,          ,     API         ,    ¬´ ¬ª.    ,        ,         . <br><br>   .  ,       ,            ,     ‚Äî       . <br><br>   .       .       ,      ,  ¬´ .¬ª  ¬´ Y.¬ª.      QA- ‚Äî   ,         ,   . <br><br>      ,          ,        ;  ,     ‚Äî ,      ,      ‚Äî   QA   ,     , ,   ,   QA  . <br><br>   ,     ,    ,       QA-,      .            .           .      ,    ,         . <br><br><h3>   </h3><br>     ‚Äî   ,   API  ,     ,   (    )   ‚Äî  ,        . <br><br>        ,    ,         C++. <br><br>      ,    .    ,   ,  ,  ,        ,      .  ,  - ,            ,      . <br><br>  ,     ,    ,   ,               .    ,     ,          ‚Äî    ,    . ,      ( <i>data breakpoints</i> )        ,   ,       ‚Äî ,    ,       ?   ,      ,     ,      ,     ,         ,       ,       ,    ,     ( <i>soak testing</i> )? <br><br>          .      ,    .    ,    ;         ;      ;      ;      ;    ,    ;    ,     ,   . <br><br> ,       ¬´¬ª,      .  ,   ,    ,   ‚Äî      .   ,   ‚Äî  ,         .  -    ,         . <br><br>   ¬´ ++¬ª       ,   .      ;     ,   ;    ,    .   ¬´ C++¬ª     , ‚Äî  ,    ,  STL  _ _,    STL .    ,  STL  ¬´ ¬ª,     ; ,    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   ,      </a> . <br><br>       ,      ,  ¬´ C++¬ª   ‚Äî   ,           .   <i> </i> ‚Äî    ,   . <br><br>      ,    C++      ,         .    ,     .     ,                .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>copy elision</i> ( )   </a> ,         .         . ,      ,      NRVO    ,      ,         . ,  C++     <i></i> . <br><br><h3> :   ++ </h3><br>            ,   C++,           . <br><br><h4> 1.    </h4><br>  ,         C++,         ,     .       ,      .     ,    ,    ‚Äî             . <br><br>       ,        . C++98,       , -    ,     . <br><br> ,      ,           ,         .   ,     C++-,       ¬´¬ª C++.    ‚Äî      , C  C++98.    ,     ,      ,   ‚Äì ,          .       ? <br><br><h4> 2.   </h4><br>  ,         GDC,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CppCon</a> ,        ,     .    ;   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>     .        ,     ,      ‚Äî        ,       . <br><br>     C++   .     ,       SG14,  SG7,  SG15 ‚Äî     ,     ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    isocpp.org</a> .       ‚Äî   ,    ,   200       ?    ¬´¬ª     ¬´¬ª  . <br><br>   ,     ,      ,      ,    Twitter  Reddit. ,    ‚Äî      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435036/">https://habr.com/ru/post/de435036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435018/index.html">Im Jahr 2018 haben wir endlich begonnen, die Zeit, die wir mit dem Smartphone verbracht haben, ernst zu nehmen</a></li>
<li><a href="../de435020/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Ger√§te der letzten 50 Jahre, Teil 2</a></li>
<li><a href="../de435026/index.html">Wir machen einen Boten *, der auch im Aufzug funktioniert</a></li>
<li><a href="../de435028/index.html">C-Tests ohne SMS und Registrierung</a></li>
<li><a href="../de435032/index.html">Das Chang'e-4-Raumschiff landete erfolgreich auf der anderen Seite des Mondes und schickte das erste Foto</a></li>
<li><a href="../de435038/index.html">Weltkraft im Jahr 2018</a></li>
<li><a href="../de435040/index.html">Bitcoin vor 10 Jahren</a></li>
<li><a href="../de435044/index.html">Altert√ºmer: Minidisc in seinem nat√ºrlichen Lebensraum</a></li>
<li><a href="../de435050/index.html">Geschichte, wie .NET 4.5 unter ReactOS installiert wurde</a></li>
<li><a href="../de435054/index.html">ITMO-Universit√§t "in der Praxis": Mit welchen Technologieunternehmen arbeiten wir zusammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>