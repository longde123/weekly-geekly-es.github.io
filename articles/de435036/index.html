<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏽 🚔 🤘 Gedanken zur modernen C ++ - und Spieleentwicklung 👨🏾‍🎤 🤾🏼 🤼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das neue Jahr für Spieleentwickler begann mit einer Welle von Kritik, die nach der Veröffentlichung von Aras Prankevichus 'Beschwerden über modernes C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gedanken zur modernen C ++ - und Spieleentwicklung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435036/">  <i>Das neue Jahr für Spieleentwickler begann mit einer Welle von Kritik, die nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veröffentlichung von Aras Prankevichus 'Beschwerden über modernes C ++</a> auf das C ++ - Standardisierungskomitee fiel.</i>  <i>Es stellte sich eine ernste Frage: Hat das Standardkomitee wirklich den Kontakt zur Realität verloren oder ist es umgekehrt, und brechen diese Spieleentwickler vom Rest der C ++ - Community ab?</i> <i><br><br></i>  <i>Wir bieten Ihnen eine Übersetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beliebten Postens von</a> Ben Dean, einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veteranen der Spielebranche</a> , der lange Zeit als C ++ - Entwickler und Teamleiter bei Blizzard, Electronic Arts und Bullfrog gearbeitet hat und in dem er auf Kritik aus seiner eigenen Erfahrung reagiert.</i> <br><blockquote> TL; DR: Das C ++ Standardization Committee hat nicht das versteckte Ziel, die Bedürfnisse von Spieleentwicklern zu ignorieren, und "modernes" C ++ wird keine "debuggte" Sprache. </blockquote>  In der vergangenen Woche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gab</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Twitter</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine aktive Diskussion</a> , in der viele Programmierer - insbesondere diejenigen, die auf dem Gebiet der Spieleentwicklung arbeiten - darauf hinwiesen, dass der aktuelle Entwicklungsvektor von „modernem C ++“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht ihren Anforderungen entspricht</a> .  Insbesondere vom Standpunkt eines gewöhnlichen Spieleentwicklers sieht alles so aus, als würde die Debugging-Leistung in der Sprache ignoriert, und Codeoptimierung wird erwartet und notwendig. <br><br>  Aufgrund der Tatsache, dass ich 2019 mehr als 23 Jahre in der Spielebranche gearbeitet habe, habe ich meine eigene Meinung, die auf Beobachtungen zu diesem Thema in Bezug auf die Spieleentwicklung basiert, die ich gerne teilen möchte.  Ist das Debuggen für Spieleentwickler wichtig und warum?  Was sind die damit verbundenen Probleme? <br><br>  Zunächst einmal - ein kleiner Exkurs in die Geschichte. <br><a name="habracut"></a><br>  Viele C ++ - Spieleentwickler arbeiten in Microsoft Visual C ++.  In der Vergangenheit hat sich um Microsoft-Plattformen ein riesiger Markt für Spiele gebildet, der die typische Erfahrung eines normalen Spieleprogrammierers beeinträchtigt hat.  In den 90er und 2000er Jahren wurden die meisten Spiele unter diesen Umständen geschrieben.  Selbst mit dem Aufkommen von Konsolen anderer Hersteller und der wachsenden Beliebtheit von Handyspielen sind das Eigentum vieler AAA-Studios und zahlreicher Spieleprogrammierer heute Tools von Microsoft. <br><br>  Visual Studio ist wohl der beste Debugger für C ++ der Welt.  Darüber hinaus sticht Visual Studio beim Debuggen von Programmen am meisten hervor - mehr als beim Front-End, Back-End, der STL-Implementierung oder anderen Dingen.  In den letzten fünf Jahren hat Microsoft erhebliche Fortschritte bei der Entwicklung von C ++ - Entwicklungstools erzielt, aber schon vorher war der Debugger in Visual Studio immer sehr cool.  Wenn Sie also auf einem Windows-PC entwickeln, haben Sie immer einen erstklassigen Debugger zur Hand. <br><br>  Schauen wir uns vor diesem Hintergrund den Prozess zum Abrufen von Code an, bei dem keine Fehler auftreten.  Möglichkeiten, die wir aus der Sicht eines Programmierers haben, der sich nicht mit Spielen befasst;  sowie die Einschränkungen, mit denen Spieleentwickler konfrontiert sind.  Wenn Sie das Hauptargument zugunsten des "Entwicklungsvektors von modernem C ++" umformulieren, wird es auf Typen, Tools und Tests reduziert.  Nach diesem Gedanken sollte der Debugger die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzte Verteidigungslinie sein</a> .  Bevor wir es erreichen, haben wir die folgenden Optionen. <br><br><h3>  Gelegenheit Nr. 1: Typen </h3><br>  Wir können so viel starke Typisierung wie nötig verwenden, um ganze Fehlerklassen beim Kompilieren zu beseitigen.  Starkes Tippen ist ohne Zweifel eine Chance, die uns die jüngste Entwicklung von C ++ geboten hat.  Ab C ++ 11 haben wir beispielsweise Folgendes erreicht: <br><br><ul><li> signifikante Erweiterung der <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">type traits</a></code> ; </li><li>  Innovationen wie <code>nullptr</code> und <code>scoped enum</code> zur Bekämpfung des C-Erbes - schwache Typisierung; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GSL</a> und Hilfswerkzeuge; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konzepte</a> in C ++ 20. </li></ul><br>  Einige von Ihnen mögen möglicherweise keine Metaprogrammierung für Vorlagen.  Andere mögen den Codierungsstil, der <code>auto</code> fast universell verwendet, möglicherweise nicht.  Unabhängig von diesen Einstellungen wird hier das Hauptmotiv für die Verwendung der aufgelisteten Stile in C ++ klar nachgezeichnet - dies ist der Wunsch, dem Compiler zu helfen, damit er uns wiederum helfen kann, indem er gleichzeitig das verwendet, was er am besten weiß: das Typsystem. <br><br>  Wenn wir über Spieleprogrammierung sprechen, ist das starke Tippen hier ein weites Forschungsfeld und wird von mir bekannten Spielprogrammierern aktiv genutzt, die daran interessiert sind, ihre Fähigkeiten im Umgang mit C ++ in der Praxis zu verbessern.  Zwei wichtige Dinge sind hier von Belang: die Auswirkung auf die Kompilierungszeit und die Auswirkung auf die Lesbarkeit des Codes. <br><br>  Ehrlich gesagt können Sie die Kompilierungszeit leicht ignorieren - aber nur unter der Bedingung, dass Sie Programmierer in einem sehr großen Unternehmen sind, das keine Spiele spielt und über eine etablierte interne Infrastruktur und endlose Rechenleistung verfügt, um jeden Code zu kompilieren, den Sie schreiben können .  Solche großen Unternehmen sind besorgt über die Kosten für die Kompilierung - daher verwenden sie Module -, aber dies verursacht in der Regel keine Schmerzen für einzelne Entwickler.  Gleichzeitig ist dies für die meisten Spielprogrammierer nicht der Fall.  Indie-Entwickler müssen keine Farmen bauen.  AAA-Spieleentwickler verwenden häufig so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Incredibuild</a> . Angesichts der Tatsache, dass sie problemlos mit einer Codebasis arbeiten können, die 10 Jahre oder älter ist, kann der Erstellungsprozess dennoch 15 bis 20 Minuten dauern. <br><br>  Wir können über die relativen Kosten für das Hinzufügen von Hardware im Vergleich zu den Kosten für die Zeit des Programmierers streiten, und ich stimme der Ansicht zu, dass Hardware jedoch billiger ist: <br><br><ul><li>  Hardware ist eine echte einmalige Ausgabe, die dem Budget des laufenden Quartals zugewiesen wird, im Gegensatz zu nicht so greifbaren Ausgaben in Bezug auf Zeit / Einstellung / und dergleichen, die über einen längeren Zeitraum verteilt werden.  Die Entscheidung für einen solchen Kompromiss kommt den Menschen nicht gut, und Unternehmen sind speziell so aufgebaut, dass sie den kurzfristigen Gewinn optimieren. </li><li>  Die Infrastruktur benötigt Unterstützung, und fast niemand steigt in die Spielebranche ein, um Release-Ingenieur zu werden.  Im Vergleich zu anderen Bereichen, in denen C ++ verwendet wird, ist das Gehalt der Spieleentwickler nicht so hoch - und Nicht-Spieleingenieure werden hier noch weniger bezahlt. </li></ul><br>  Man kann auch darüber spekulieren, dass die Kompilierungszeit niemals einen solchen Zustand hätte erreichen dürfen;  und wieder stimme ich dir zu.  Der Preis hierfür ist ständige Wachsamkeit - wiederum von einem Release-Ingenieur - und im Idealfall ein automatisiertes Tool, mit dem Sie Änderungen in der für die Erstellung des Builds erforderlichen Zeit verfolgen können.  Glücklicherweise kann dieses Ziel mit dem Aufkommen von CI-Systemen heute viel einfacher erreicht werden. <br><br><h3>  Gelegenheit Nr. 2: Werkzeuge </h3><br>  Wir sollten das Maximum der uns zur Verfügung stehenden Tools verwenden - Warnungen, statische Analysen, Desinfektionsmittel, Tools für dynamische Analysen, Profiler und andere. <br><br>  Ich habe die Erfahrung gemacht, dass Spieleentwickler diese Tools verwenden, wo immer dies möglich ist, aber hier hat die gesamte Branche mehrere Probleme: <br><br><ul><li>  Diese Tools funktionieren in der Regel besser auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nicht-Microsoft-</a> Plattformen - und wie bereits erwähnt, ist dies kein typisches Spielentwicklungsszenario. </li><li>  Die meisten dieser Tools sind auf die Arbeit mit "Standard" C ++ ausgerichtet.  Sie unterstützen <code>CStaticVector</code> <code>std::vector</code> , aber nicht meine selbstgeschriebene Klasse <code>CStaticVector</code> aus einer hypothetischen Engine.  Natürlich ist es nutzlos, die Tools zu beschuldigen, aber dies ist immer noch eines der Hindernisse für ihre Verwendung, die Entwickler überwinden müssen. </li><li>  Das Erstellen und Verwalten einer CI-Kette, in der alle diese Tools ausgeführt werden, erfordert die Anwesenheit von Release-Ingenieuren. Wie bereits erwähnt, ist die Einstellung von Mitarbeitern für Ingenieurjobs, die nicht direkt mit Spielen zusammenhängen, ein systemisches Problem für die Spielebranche. </li></ul><br>  Warum verwenden Spieleentwickler STL nicht, da diese Tools mit Standard-C ++ so gut funktionieren? <br><br>  Wo soll die Antwort auf diese Frage beginnen?  Vielleicht vom nächsten Ausflug in die Geschichte der Spieleentwicklung: <br><br><ul><li>  Bis in die frühen 90er Jahre vertrauten wir C-Compilern nicht und schrieben Spiele in Assembler. </li><li>  Von Anfang bis Mitte der 90er Jahre vertrauten wir C-Compilern, aber wir vertrauten C ++ - Compilern immer noch nicht.  Unser Code war C, der Kommentare im C ++ - Stil verwendete, und wir mussten nicht mehr ständig Typedefs für unsere Strukturen schreiben. </li><li>  Um das Jahr 2000 fand die C ++ - Revolution in der Welt der Spieleentwicklung statt.  Es war eine Ära <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Designmustern</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">großen Klassenhierarchien</a> .  Zu dieser Zeit ließ die STL-Unterstützung auf Konsolen zu wünschen übrig, und Konsolen beherrschten damals die Welt.  Auf PS2 bleiben wir für immer bei GCC 2.95. </li><li>  Um 2010 wurden zwei weitere Revolutionen gestartet.  Der Schmerz, große Klassenhierarchien zu verwenden, stimulierte die Entwicklung eines Komponentenansatzes für Code.  Diese Änderung setzt ihre heutige Entwicklung in Form von Entity-Component-System-Architekturen fort.  Hand in Hand damit war die zweite Revolution - ein Versuch, Multiprozessor-Architekturen zu nutzen. </li></ul><br>  Während dieser Paradigmenwechsel änderten sich die Spieleentwicklungsplattformen selbst ständig und sie änderten sich ernsthaft.  Der segmentierte Speicher ist einem flachen Adressraum gewichen.  Die Plattformen sind Multiprozessor geworden, symmetrisch und nicht sehr.  Spieleentwickler, die an die Arbeit mit Intel-Architekturen gewöhnt waren, mussten sich an MIPS (Playstation) gewöhnen, dann an eine spezielle Hardware mit heterogenen CPUs (PS2), dann an PowerPC (XBox 360), dann an noch größere Heterogenität (PS3) ... Die neue Plattform verfügt über neue Leistungsmerkmale für Prozessoren, Speicher und Laufwerke.  Wenn Sie eine optimale Leistung erzielen wollten, mussten Sie Ihren alten Code häufig und häufig neu schreiben.  Ich werde nicht einmal erwähnen, wie sehr die Spiele durch die Entstehung und das Wachstum der Popularität des Internets sowie durch die Einschränkungen beeinflusst wurden, die Plattforminhaber den Entwicklern auferlegt haben. <br><br>  In der Vergangenheit waren STL-Implementierungen auf Spieleplattformen unbefriedigend.  Es ist kein Geheimnis, dass STL-Container für Spiele schlecht geeignet sind.  Wenn Sie den Spieleentwickler an die Wand schieben, gibt er vielleicht zu, dass <code>std::string</code> ganz in Ordnung ist und <code>std::vector</code> eine vernünftige Standardoption ist.  Alle in der STL enthaltenen Container haben jedoch ein Problem mit der Kontrolle der Zuordnung und Initialisierung.  Viele Spiele müssen sich über Speicherbeschränkungen für verschiedene Aufgaben Gedanken machen - und für Objekte, für die der Speicher während des Spiels höchstwahrscheinlich dynamisch zugewiesen werden muss, werden häufig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>Platten-</i></a> oder <i>Arena-</i> Allokatoren verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amortisierte konstante Zeit</a> ist kein gutes Ergebnis, da die Zuweisung möglicherweise eines der „teuersten“ Dinge ist, die während der Programmausführung passieren können, und ich möchte keinen Frame überspringen, nur weil es passiert ist, als ich es nicht erwartet habe .  Als Spieleentwickler muss ich meinen Speicherbedarf im Voraus verwalten. <br><br>  Eine ähnliche Geschichte wird für andere Abhängigkeiten im Allgemeinen erhalten.  Spieleentwickler möchten wissen, was jeder Prozessorzyklus benötigt, wo und wann und wofür jedes Byte Speicher verantwortlich ist und wo und wann jeder Ausführungsthread gesteuert wird.  Bis vor kurzem haben Microsoft-Compiler ABI mit jedem Update geändert. Wenn Sie also viele Abhängigkeiten hatten, kann das Wiederherstellen aller Abhängigkeiten ein schmerzhafter Prozess sein.  Spieleentwickler bevorzugen normalerweise kleine Abhängigkeiten, die einfach zu integrieren sind, nur eines tun und gut funktionieren - vorzugsweise mit einer API im C-Stil - und von vielen Unternehmen verwendet werden, gemeinfrei sind oder eine kostenlose Lizenz haben, die dies nicht tut erfordert eine Angabe des Autors.  <i>SQLite</i> und <i>zlib</i> sind gute Beispiele dafür, was Spieleentwickler bevorzugen. <br><br>  Darüber hinaus hat die C ++ - Spielebranche eine reiche Geschichte von Patienten mit dem Syndrom „Hier nicht erfunden“.  Dies sollte von der Branche erwartet werden, die mit einzelnen Enthusiasten begann, die ihre eigenen Sachen mit völlig neuen Geräten herstellten und keine anderen Optionen hatten.  Die Spielebranche ist unter anderem die einzige, in der Programmierer in keiner bestimmten Reihenfolge im Abspann angegeben sind.  <i>Das Schreiben einer Vielzahl von Dingen macht Spaß und hilft Ihrer Karriere!</i>  <i>Es ist viel besser, etwas Eigenes zu bauen, als fertige zu kaufen!</i>  Und da wir uns so große Sorgen um die Leistung machen, können wir unsere Lösung so anpassen, dass sie speziell für unser Projekt geeignet ist - anstatt eine allgemeine Lösung zu wählen, die die verfügbaren Ressourcen sinnlos verschwendet.  Die Feindseligkeit gegenüber Boost ist das Hauptbeispiel dafür, wie sich ein solches Denken in der Spieleentwicklung manifestiert.  Ich habe an Projekten gearbeitet, die folgendermaßen abliefen: <br><br><ul><li>  Um ein bestimmtes Problem zu lösen, verbinden wir zunächst eine Bibliothek von Boost mit dem Projekt. </li><li>  Alles funktioniert sehr gut.  Wenn Sie ein Update durchführen müssen, treten einige Schmerzen auf, jedoch nicht mehr als beim Aktualisieren einer anderen Abhängigkeit. </li><li>  Ein anderes Spiel möchte unseren Code verwenden, aber der Stolperstein ist, dass wir Boost verwenden - trotz der Tatsache, dass unsere Erfahrung mit Boost ganz gut gelaufen ist. </li><li>  Wir entfernen den Code mit Boost, aber jetzt stehen wir vor einem neuen Problem: Wir müssen das Problem lösen, das die Bibliothek von Boost anstelle unserer zuvor gelöst hat. </li><li>  Wir kopieren im Wesentlichen die Teile des Boost-Codes, die wir benötigen, in unsere eigenen Namespaces. </li><li>  Später stoßen wir unweigerlich und immer wieder auf die Tatsache, dass wir zusätzliche Funktionen benötigen, die bereits im Originalcode enthalten wären, wenn wir sie nicht weggeworfen hätten.  Aber jetzt sind wir die Eigentümer dieses Codes, also müssen wir ihn weiterhin unterstützen. </li></ul><br>  Wir mögen nichts Großes, das versucht, zu viele Dinge gleichzeitig zu tun, oder das die Kompilierungszeit beeinflussen kann - und das ist durchaus vernünftig.  Was Menschen immer wieder Fehler machen, ist, dass sie es ablehnen, den vermeintlichen Schmerz heute zu akzeptieren - während sie aufgrund dieser Entscheidung mit der Unterstützung von etwas auf Kosten von jemandem einem sehr realen und viel größeren Schmerz gegenüberstehen werden - das Budget, das sie in den nächsten drei Jahren haben müssen.  Leider kann das Vorhandensein von Beweisen in Form von Spielen, die ein Gericht von STL und Boost erfolgreich verwenden, die menschliche Psychologie in keiner Weise beeinflussen und Spieleentwickler überzeugen. <br><br>  Aus all diesen Gründen haben viele Spielefirmen ihre eigenen Bibliotheken erstellt, die die Funktionen von STL - und noch mehr - abdecken und gleichzeitig spielspezifische Anwendungsfälle unterstützen.  Einige große Spielefirmen konnten sogar die Entwicklung ihres eigenen, vollwertigen, fast vollständig API-kompatiblen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STL-Ersatzes</a> meistern, was in der Folge enorme Kosten für die Unterstützung dieses Projekts mit sich brachte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es ist ratsam, eine verbesserte Alternative zu</a> <code>std::map</code> finden oder die <i>Optimierung kleiner Puffer</i> in <code>std::vector</code> anzuwenden.  Es ist viel weniger akzeptabel, zum Scheitern verurteilt zu sein, um Ihre eigenen Implementierungen von <code>algorithms</code> oder Typmerkmalen zu unterstützen, was wenig nützt.  Für mich ist es bedauerlich, dass STLs für die meisten Entwickler nur Container sind.  Da ihnen beim Erlernen von STL zu Beginn genau das beigebracht wird, implizieren die meisten von STL <code>std::vector</code> - obwohl sie eigentlich über <code>std::find_if</code> nachdenken <code>std::find_if</code> . <br><br><h3>  Gelegenheit Nr. 3: Tests </h3><br>  Es wird argumentiert, dass umfangreiche Tests durchgeführt werden sollten, TDD und / oder BDD den gesamten Code abdecken sollten, der abgedeckt werden kann, und Fehler sollten durch Schreiben neuer Tests behoben werden. <br><br>  Lassen Sie uns daher das Thema Testen diskutieren. <br><br>  Nach meiner Erfahrung werden automatisierte Tests in der Spielebranche praktisch nicht eingesetzt.  Warum? <br><br><h4>  1. Weil Korrektheit <i>nicht so</i> wichtig ist, aber es keine wirkliche Spezifikation gibt </h4><br>  Als junger Programmierer in der Spielebranche wurde ich schnell von der Idee befreit, dass ich mich bemühen sollte, etwas realistisch zu simulieren.  Spiele sind <i>Rauch und Spiegel</i> und die Suche nach kurzen Wegen.  Es interessiert niemanden, wie realistisch Ihre Simulation ist.  Hauptsache, es macht Spaß.  Wenn Sie keine andere Spezifikation als "Das Spiel sollte sich richtig anfühlen" haben, fehlt das Thema Test.  Dank Bugs kann das Gameplay sogar noch besser werden.  Sehr oft kommt ein Fehler in die Veröffentlichung und gewinnt sogar die Liebe der Benutzer ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erinnern Sie sich an denselben Gandhi aus Civilization</a> ).  Spiele unterscheiden sich von anderen Bereichen, die C ++ verwenden.  hier führt ein Mangel an Korrektheit nicht dazu, dass jemand irgendwann seine Ersparnisse verliert. <br><br><h4>  2. Weil es schwer ist </h4><br>  Natürlich möchten Sie automatisierte Tests erstellen, wo immer Sie können.  Dies kann für einige Subsysteme durchgeführt werden, für die eindeutig festgelegte Endergebnisse vorliegen.  Unit-Tests in der Spielebranche sind natürlich vorhanden, aber in der Regel sind sie auf Low-Level-Code beschränkt - die zuvor erwähnten STL-Analoga, String-Konvertierungsverfahren, physikalische Engine-Methoden usw.  Die Fälle, in denen der ausführbare Abschnitt des Codes vorhersehbare Ergebnisse aufweist, werden normalerweise durch Komponententests getestet, obwohl TDD hier nicht verwendet wird - da Spielprogrammierer es vorziehen, ihr Leben zu vereinfachen und nicht umgekehrt.  Aber wie testest du den Gameplay-Code (siehe Punkt eins)?  Sobald Sie über Unit-Tests hinausgehen, stoßen Sie sofort auf einen anderen Grund, warum das Testen von Spielen so schwierig ist. <br><br><h4>  3. Weil der Inhalt beteiligt ist </h4><br>  Das Testen nicht trivialer Systeme wird wahrscheinlich die Bereitstellung von Inhalten umfassen, mit denen es implementiert wird.  Die meisten Ingenieure sind nicht sehr gut darin, diese Inhalte selbst zu erstellen. Um einen aussagekräftigen Test zu erhalten, müssen Sie jemanden mit den richtigen Fähigkeiten für die Erstellung der Inhalte gewinnen.  Danach stoßen Sie auf das Problem, zu messen, was Sie auf der Ausgabe erhalten - schließlich handelt es sich nicht mehr um eine Linie oder eine Zahl, sondern um ein Bild auf dem Bildschirm oder einen Ton, der sich im Laufe der Zeit ändert. <br><br><h4>  4. Weil wir es nicht praktizieren </h4><br>  Unit Testing ist eine Funktion, für die ich die möglichen Ein- und Ausgänge kenne.  Das Gameplay ist jedoch ein unvorhersehbares, sich dynamisch entwickelndes Verhalten, und ich weiß nicht, wie ein solches Phänomen richtig getestet werden könnte.  Was kann ich testen - wenn ich natürlich von meinem Manager die Erlaubnis bekomme, genügend Zeit dafür aufzuwenden - dies sind zum Beispiel Leistung oder hochrangige Funktionen wie Matchmaking, die ich analysieren kann.  Eine solche Infrastrukturarbeit mag für einige Spielprogrammierer aufregend sein, ist aber für die meisten einfach nicht interessant und erfordert außerdem die Genehmigung und Unterstützung des Besitzers der Brieftasche.  Als Spielprogrammierer habe ich nie die Möglichkeit, das Schreiben von Tests auf hohem Niveau zu üben. <br><br><h4>  5. Da [Unternehmen] keine Notwendigkeit für automatisierte Tests sieht </h4><br>  Unser Hauptziel ist es, das Spiel zu veröffentlichen.  Wir leben in einer Ära der Industrie, die mit Hits voranschreitet, die im ersten Verkaufsmonat das Beste aus ihrem Geld machen, wenn die Marketingkosten dieser Hits maximiert werden.  Der Lebenszyklus von Konsolen hat uns gelehrt, dass der Code auf keinen Fall so lange leben wird.  Wenn wir an einem Online-Spiel arbeiten, erhalten wir höchstwahrscheinlich zusätzliche Zeit zum Testen des Matchmaking oder der Serverlast.  Da für die Veröffentlichung des Spiels die Leistung in Ordnung sein muss, sollten wir zumindest Leistungstests durchführen, diesen Prozess jedoch nicht automatisieren.  Für das Management in der Spielebranche ist automatisiertes Testen nichts anderes als Zeit- und Geldverschwendung.  Für die Implementierung müssen erfahrene Ingenieure eingestellt werden, die die Arbeiten ausführen, deren Ergebnis kaum wahrnehmbar ist.  Die gleiche Zeit könnte für die Entwicklung neuer Funktionen aufgewendet werden.  Kurzfristig ist es viel rentabler, QA-Mitarbeiter zum Testen des Spiels einzusetzen, was uns zum nächsten Punkt bringt. <br><br><h4>  6. Weil das Testen in Spielen im Allgemeinen als zweitklassige Aktivität eingestuft wird </h4><br>  Ich liebe gute QS-Profis.  Für mich sind sie Gold wert.  Sie wissen, wie Sie Ihr Spiel verbessern können, indem Sie es auf eine Weise brechen, die Ihnen nie in den Sinn gekommen wäre.  Sie sind spezialisierte Experten in Ihrem Gameplay in dieser Hinsicht, die Sie nicht verstehen und kaum jemals verstehen.  Sie sind besser als ein Team von hochqualifizierten Compilern, die Ihnen helfen, alles richtig zu machen.  Ich bin froh, dass ich im Laufe der Jahre die Gelegenheit hatte, mit mehreren wunderbaren QS-Spezialisten zusammenzuarbeiten. <br><br>  Ich musste fast immer kämpfen, um sicherzustellen, dass sie in meinem Team blieben. <br><br>   AAA-, ,  QA —         ,       .     ,         .  ,      . <br><br>   ,      ,              ,       .   «»   ,       ,  QA   ,          ,        ,          . <br><br>   .             ,     .      QA-,          ,     API         ,    « ».    ,        ,         . <br><br>   .  ,       ,            ,     —       . <br><br>   .       .       ,      ,  « .»  « Y.».      QA- —   ,         ,   . <br><br>      ,          ,        ;  ,     — ,      ,      —   QA   ,     , ,   ,   QA  . <br><br>   ,     ,    ,       QA-,      .            .           .      ,    ,         . <br><br><h3>   </h3><br>     —   ,   API  ,     ,   (    )   —  ,        . <br><br>        ,    ,         C++. <br><br>      ,    .    ,   ,  ,  ,        ,      .  ,  - ,            ,      . <br><br>  ,     ,    ,   ,               .    ,     ,          —    ,    . ,      ( <i>data breakpoints</i> )        ,   ,       — ,    ,       ?   ,      ,     ,      ,     ,         ,       ,       ,    ,     ( <i>soak testing</i> )? <br><br>          .      ,    .    ,    ;         ;      ;      ;      ;    ,    ;    ,     ,   . <br><br> ,       «»,      .  ,   ,    ,   —      .   ,   —  ,         .  -    ,         . <br><br>   « ++»       ,   .      ;     ,   ;    ,    .   « C++»     , —  ,    ,  STL  _ _,    STL .    ,  STL  « »,     ; ,    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   ,      </a> . <br><br>       ,      ,  « C++»   —   ,           .   <i> </i> —    ,   . <br><br>      ,    C++      ,         .    ,     .     ,                .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>copy elision</i> ( )   </a> ,         .         . ,      ,      NRVO    ,      ,         . ,  C++     <i></i> . <br><br><h3> :   ++ </h3><br>            ,   C++,           . <br><br><h4> 1.    </h4><br>  ,         C++,         ,     .       ,      .     ,    ,    —             . <br><br>       ,        . C++98,       , -    ,     . <br><br> ,      ,           ,         .   ,     C++-,       «» C++.    —      , C  C++98.    ,     ,      ,   – ,          .       ? <br><br><h4> 2.   </h4><br>  ,         GDC,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CppCon</a> ,        ,     .    ;   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>     .        ,     ,      —        ,       . <br><br>     C++   .     ,       SG14,  SG7,  SG15 —     ,     — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    isocpp.org</a> .       —   ,    ,   200       ?    «»     «»  . <br><br>   ,     ,      ,      ,    Twitter  Reddit. ,    —      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435036/">https://habr.com/ru/post/de435036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435018/index.html">Im Jahr 2018 haben wir endlich begonnen, die Zeit, die wir mit dem Smartphone verbracht haben, ernst zu nehmen</a></li>
<li><a href="../de435020/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Geräte der letzten 50 Jahre, Teil 2</a></li>
<li><a href="../de435026/index.html">Wir machen einen Boten *, der auch im Aufzug funktioniert</a></li>
<li><a href="../de435028/index.html">C-Tests ohne SMS und Registrierung</a></li>
<li><a href="../de435032/index.html">Das Chang'e-4-Raumschiff landete erfolgreich auf der anderen Seite des Mondes und schickte das erste Foto</a></li>
<li><a href="../de435038/index.html">Weltkraft im Jahr 2018</a></li>
<li><a href="../de435040/index.html">Bitcoin vor 10 Jahren</a></li>
<li><a href="../de435044/index.html">Altertümer: Minidisc in seinem natürlichen Lebensraum</a></li>
<li><a href="../de435050/index.html">Geschichte, wie .NET 4.5 unter ReactOS installiert wurde</a></li>
<li><a href="../de435054/index.html">ITMO-Universität "in der Praxis": Mit welchen Technologieunternehmen arbeiten wir zusammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>