<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏾 👁‍🗨 🍓 Criar as bordas de um mapa gerado processualmente 😱 🔗 👇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scott Turner continua trabalhando em seu jogo processualmente gerado e agora decidiu resolver o problema de projetar as bordas dos mapas. Para fazer i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criar as bordas de um mapa gerado processualmente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png" alt="imagem"></div><br>  <i>Scott Turner continua trabalhando em seu jogo processualmente gerado e agora decidiu resolver o problema de projetar as bordas dos mapas.</i>  <i>Para fazer isso, ele precisa resolver vários problemas difíceis e até criar sua própria linguagem para descrever limites.</i> <br><br>  As fronteiras continuavam sendo um elemento importante dos cartões de fantasia, que estavam na minha lista há algum tempo.  Os mapas funcionais geralmente têm uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linha de fronteira</a> simples, mas os mapas de fantasia e os mapas medievais, dos quais os primeiros costumam emprestar idéias, têm limites artísticos e bem pensados.  Esses limites deixam claro que o mapa é intencionalmente tornado fantástico e dão ao espectador uma sensação de admiração. <br><br>  Atualmente, existem algumas maneiras simples de desenhar bordas no meu jogo <b>Dragons Abound</b> .  Ela pode desenhar uma linha simples ou dupla ao redor do perímetro do mapa e adicionar elementos simples nos cantos, como nas figuras: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/9f8/477/aed9f8477ef53b5550b742ea1fde36b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br>  O jogo também pode adicionar um campo na parte inferior da borda para o nome do mapa.  Existem várias variações desse campo em <b>Dragons Abound</b> , incluindo elementos complexos como cabeças de parafusos falsos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/f6f/c3a/42ff6fc3adae5b40293bb82d5a1be325.png"></div><br>  Há variabilidade nesses campos de nome, mas todos são criados manualmente. <br><br>  Um aspecto interessante dos limites dos cartões de fantasia é que eles são criativos e modelo.  Geralmente, eles consistem em um pequeno número de elementos simples que se combinam de maneiras diferentes para criar um resultado único.  Como sempre, o primeiro passo para trabalhar com um novo tópico é estudar uma coleção de exemplos de mapas, criar um catálogo de tipos de elementos de borda e estudar sua aparência. <br><a name="habracut"></a><br>  A borda mais simples é uma linha que percorre as bordas do mapa e indica seus limites.  Como eu disse acima, também é chamada de "linha de quadro": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/c81/c98/99fc81c98e1092077272081464d28752.png"></div><br>  Há também uma variação com a localização das bordas no mapa.  Nesta versão, o mapa atinge as bordas da imagem, mas a borda cria uma borda virtual dentro da imagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/aef/1db/43faef1db7bf3af195c857d7ed673710.png"></div><br>  Isso pode ser feito com qualquer tipo de borda, mas geralmente é usado apenas com bordas simples, como a borda de um quadro. <br><br>  Um conceito de design de cartão de fantasia popular é simular como se fossem desenhados em pergaminho antigo e rasgado.  Às vezes, isso é realizado desenhando a borda como a borda áspera do papel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/cb2/ff1/907cb2ff125bbd178f9a16717e5e724f.png"></div><br>  Aqui está um exemplo mais sofisticado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/751/860/d6e/751860d6e43ed2e857cf6f3ba7f766e0.png"></div><br>  Na minha experiência, esse método se tornou menos popular porque as ferramentas digitais foram usadas.  Se você deseja que o cartão pareça um pergaminho antigo e rasgado, é mais fácil aplicar a textura do pergaminho a ele do que desenhá-lo à mão. <br><br>  A ferramenta mais poderosa na criação de bordas do mapa é a repetibilidade.  No caso mais simples, basta repetir uma única linha para criar duas linhas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/139/e12/31d139e129fe513e07937c5a2bd88979.png"></div><br>  Você pode adicionar interesse ao mapa variando o estilo do elemento repetido, nesse caso combinando uma linha única grossa com uma única linha fina: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/ccd/118/530ccd11872f4aa6a32d4b3271cf94f3.png"></div><br>  Dependendo do elemento, são possíveis várias variações de estilo.  Neste exemplo, a linha se repete, mas a cor muda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc7/89e/96c/fc789e96ccfba58ac4cb595e5ec33fb7.png"></div><br>  Para criar padrões mais complexos, você pode usar a "repetibilidade repetível".  Essa borda consiste em aproximadamente cinco linhas únicas com diferentes larguras e distâncias: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Essa borda repete as linhas, mas as separa para que pareçam duas bordas finas separadas.  Nesta parte do post, não falarei sobre o processamento de ângulos, mas ângulos diferentes para as duas linhas também ajudam a criar essa diferença. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  Essas duas linhas são quatro ou seis?  Eu acho que tudo depende de como você os desenha! <br><br>  Outro elemento de estilização é preencher o espaço entre os elementos com cor, padrão ou textura.  Neste exemplo, a borda ficou mais interessante devido ao preenchimento da cor de destaque entre as duas linhas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/ccf/158/1d8ccf158b9ae0378ddaef1031ba15c9.png"></div><br>  Aqui está um exemplo de como a borda é preenchida com um padrão: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f87/37d/bb2/f8737dbb215166947e42f0da1b45cfc7.png"></div><br>  Além disso, os elementos podem ser estilizados para parecerem tridimensionais.  Aqui está um mapa no qual a borda é sombreada para parecer volumosa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/25b/695/a8025b69549773f8935d2b37680401a3.png"></div><br>  Nesse mapa, a borda é sombreada para ter uma aparência tridimensional e isso é combinado com a localização das bordas dentro das bordas do mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/899/9e7/36c8999e74172c962aef40a4a9e3addc.png"></div><br>  Outro elemento de borda comum é a escala na forma de listras coloridas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Essas faixas formam uma grade ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grade cartográfica</a> ).  Em mapas reais, a escala ajuda a determinar distâncias, mas em mapas de fantasia é principalmente um elemento decorativo. <br><br>  Essas listras são geralmente desenhadas em preto e branco, mas às vezes são adicionadas vermelhas ou outras cores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/f0f/f67/450f0ff67ac1fdf5c5e2ffaf8fbe80c0.png"></div><br>  Este elemento também pode ser combinado com outros, como neste exemplo, com linhas e escala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/d56/29d/313d5629d6ec8b8d7c7c4c1ead322a09.png"></div><br>  Este exemplo é um pouco incomum.  Normalmente, a escala (se houver) é o elemento mais interno da borda. <br><br>  Neste mapa, existem escalas diferentes com resoluções diferentes (além de notas rúnicas estranhas!): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/cd6/217/74bcd62173160e440a4ee6cfad2128c1.png"></div><br>  (No Reddit, o usuário <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AbouBenAdhem</a> me informou que as marcas rúnicas são os números 48 e 47 escritos em cuneiforme babilônico. Além disso, “escalas com resoluções diferentes” têm seis divisões divididas em dez divisões menores, o que corresponde ao sistema numérico hexadecimal da Babilônia. Indico as fontes dos mapas, mas há muitas peças pequenas neste post, então não me incomodei. No entanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este mapa foi</a> criado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thomas Ray</a> para o autor S.E. Boleyn, então, talvez, a ação em seus livros ocorra na comitiva da Babilônia.) <br><br>  Além de linhas e escala, o elemento mais comum é um padrão geométrico repetitivo.  Muitas vezes, consiste em partes como círculos, losangos e retângulos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/6ba/f61/31c6baf612bf2fa11a13905e4482d82e.png"></div><br>  Elementos geométricos, como linhas, podem ser sombreados para torná-los tridimensionais: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/cc8/c33/43ecc8c33bbf3143ba32c18b878d16e2.png"></div><br>  Limites complexos podem ser criados combinando esses elementos de maneiras diferentes.  Aqui está a borda que combina linhas, padrões geométricos e escala: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Os exemplos mostrados acima foram cartões digitais, mas, é claro, o mesmo pode ser feito com cartões manuscritos.  Aqui está um exemplo de um padrão geométrico simples criado à mão: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f7/c2d/e3d/6f7c2de3d5db82a9c7e9884d726be98e.png"></div><br>  Esses elementos também podem ser combinados de forma flexível de várias maneiras.  Aqui está um padrão geométrico combinado com uma “aresta irregular”: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/f1a/150/0faf1a15052e90a479428c4c495ad44c.png"></div><br>  Nos exemplos mostrados acima, o padrão geométrico é bastante simples.  Mas você pode criar padrões muito complexos combinando de maneira diferente os elementos geométricos básicos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/13f/fc2/38e13ffc2a2aac266aabb291a7d7f0e6.png"></div><br>  Outro elemento popular do padrão é a tecelagem ou o nó celta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/00e/8d8/07e00e8d868b6ca48be746fbe07e61ca.png"></div><br>  Aqui está uma borda de vime mais complexa contendo cor, escala e outros elementos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Neste mapa, a tecelagem é combinada com um elemento de borda irregular: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/4df/588/e954df58825bc42d408b61804a1287a9.png"></div><br>  Além dos padrões geométricos e da tecelagem, qualquer padrão repetitivo pode fazer parte da borda do cartão.  Aqui está um exemplo usando formas semelhantes a pontas de seta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  E aqui está um exemplo com um padrão de onda repetido: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/c13/3c2/841c133c2f1c0f724b5d076e5ea415fb.png"></div><br>  E, finalmente, runas ou outros elementos do alfabeto de fantasia são adicionados às bordas das cartas de fantasia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Os exemplos acima são retirados de mapas de fantasia modernos, mas aqui está um exemplo de um mapa histórico (século 18) com linhas e um padrão desenhado à mão: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/b9f/3b8/1d7b9f3b8f0c7eb296079c5f6f6b23aa.png"></div><br>  Obviamente, você pode encontrar exemplos de mapas com muitos outros elementos nas bordas.  Algumas das mais belas são totalmente desenhadas à mão e têm decorações tão cuidadosamente elaboradas que podem superar o próprio cartão ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">World of Alma</a> , Francesca Baerald): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/004/e18/1c7004e186e0d2be63b98539375316ff.png"></div><br>  Também vale a pena conversar um pouco sobre <i>simetria</i> .  Como a repetibilidade, a simetria é uma ferramenta poderosa e as bordas do mapa geralmente são simétricas ou possuem elementos simétricos. <br><br>  Muitas bordas do mapa são simétricas de dentro para fora, como neste exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Aqui, a borda é composta de várias linhas com e sem preenchimento, mas de fora para dentro repete idealmente em relação ao centro da borda. <br><br>  Neste exemplo mais complexo, a borda é simétrica, com exceção das faixas de escala em preto e branco alternadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Como duplicar a escala não faz sentido, geralmente é considerado um elemento separado, mesmo que o restante da borda seja simétrico. <br><br>  Além da simetria interna-externa, as bordas são frequentemente re-simétricas ao longo de seu comprimento.  Algumas bordas ilustradas podem ter um design simples que abrange todo o comprimento da borda do mapa, mas na maioria dos casos o padrão é bastante curto e se repete, preenchendo a borda de um canto para outro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Observe que neste exemplo o padrão contém um elemento que não é simétrico (da esquerda para a direita), mas o padrão geral é simétrico e se repete: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Uma exceção notável a essa regra são as bordas preenchidas com runas ou caracteres alfabéticos.  Muitas vezes, eles se tornam únicos, como se alguma mensagem longa fosse escrita ao longo da fronteira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Obviamente, existem muitos outros exemplos de elementos de borda do mapa que eu não considerei aqui, mas já temos um bom ponto de referência.  Nas próximas partes, desenvolverei várias funções em <b>Dragons Abound</b> para descrever, exibir e gerar bordas de mapa proceduralmente semelhantes a esses exemplos.  Na segunda parte, começaremos definindo o idioma para descrever as bordas dos mapas. <br><br><h2>  Parte 2 </h2><br>  Nesta parte, vou criar a versão inicial do MBDL (Map Border Description Language). <br><br>  Por que gastar tempo criando uma linguagem de descrição de limite de mapa?  Primeiro, esse será o objetivo da minha geração processual.  Mais tarde, escreverei um algoritmo para criar novas bordas do mapa, e a saída desse algoritmo será uma descrição da nova borda no MBDL.  Em segundo lugar, o MBDL servirá como uma representação textual dos limites do mapa.  Em particular, preciso ser capaz de salvar e reutilizar meus limites.  Para fazer isso, preciso de uma notação de texto que possa ser escrita e usada para recriar a borda do mapa. <br><br>  Vou começar a criar o MBDL definindo o elemento mais simples: a linha.  A linha tem cor e largura.  Portanto, no MBDL, apresentarei a linha desta forma: <br><br><blockquote><code>L(width, color)</code> </blockquote> <br>  Aqui estão alguns exemplos (desculpe pelas minhas habilidades no Photoshop): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/db8/68e/db2db868ede7282a34c695f8062a691b.png"></div><br>  A sequência de elementos é renderizada de fora para dentro (*), portanto, assumimos que esta é a borda no topo do mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/75e/b3a/b7c75eb3aefb8f77d1915166c0bdd979.png"></div><br>  Veja o segundo exemplo - uma linha com bordas é representada como três elementos de linha separados. <br><br>  <i>(* Desenhar de fora para dentro era uma escolha arbitrária - pareceu-me que era mais natural do que renderizar de dentro para fora. Infelizmente, como aconteceu muito mais tarde, havia uma boa razão para trabalhar na direção oposta. - antiga, porque levaria muito tempo para refazer todas as ilustrações)</i> <br><br>  Convenientemente, os espaços podem ser representados como linhas sem cor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/1a4/171/0ba1a41719610641d7b5a5e26da0692e.png"></div><br>  Mas seria mais visual ter um elemento espacial vertical específico: <br><br><blockquote>  VS (largura) </blockquote><br>  Os seguintes elementos simples são formas geométricas: listras, losangos e elipses.  Supõe-se que as linhas sejam esticadas por todo o comprimento da borda, para que não tenham um comprimento especificado explicitamente.  Porém, figuras geométricas não podem preencher a linha inteira; portanto, além da largura (*), cada uma deve ter comprimento, cor de contorno, largura de contorno e cor de preenchimento: <br><br><blockquote> <code>B(width, length, outline, outline width, fill) <br> D(width, length, outline, outline width, fill) <br> E(width, length, outline, outline width, fill)</code> </blockquote> <br>  (* Aceitei que considerarei a largura na direção de fora para dentro e o comprimento é medido ao longo da borda.) <br><br>  Aqui estão exemplos de formas geométricas simples: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/fad/cf6/a3dfadcf6a5a98a9785b0b487a6e17fc.png"></div><br>  Para esses elementos preencherem todo o comprimento da borda, eles devem ser repetidos.  Para indicar o grupo de elementos que serão repetidos para preencher o comprimento da borda, use colchetes: <br><br><blockquote> <code>[ element element element ... ]</code> </blockquote> <br>  Aqui está um exemplo de um padrão repetido de retângulos e losangos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Às vezes, precisarei de um espaço (horizontal) entre os elementos de um padrão repetitivo.  Embora você possa usar um elemento sem cores para criar um espaço, será mais inteligente e conveniente ter um elemento de espaço horizontal: <br><br><blockquote> <code>HS(length)</code> </blockquote> <br>  A última função necessária para essa primeira iteração do MBDL é a capacidade de empilhar elementos uns sobre os outros.  Aqui está um exemplo de borda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/7e9/3f3/8ea7e93f3040563ef7ec2715ca39a14d.png"></div><br>  A maneira mais fácil de descrevê-lo é uma ampla linha amarela sob o padrão superior.  Você pode implementar isso de maneiras diferentes (por exemplo, um espaço vertical negativo), mas eu decidi usar chaves para indicar a ordem dos elementos para dentro: <br><br><blockquote> <code>{element element element ...}</code> </blockquote> <br>  De fato, esta entrada diz para você lembrar onde o padrão estava de fora para dentro ao inserir os colchetes e, em seguida, retornar a esse ponto ao deixar os colchetes.  Os colchetes também podem ser considerados como uma descrição dos elementos que ocupam um espaço vertical.  Portanto, a borda mostrada acima pode ser descrita da seguinte maneira: <br><br><blockquote> <code><b>L(1, black) <br> {L(20, yellow)} <br> VS(3) <br> [B(5, 10, black, 3, none) <br> D(5, 10, black,3,red)] <br> VS(3) <br> L(1, black)</b></code> </blockquote> <br>  Desenhamos uma linha preta, fixamos onde estamos, desenhamos uma linha amarela e, em seguida, retornamos à posição anteriormente fixa, caímos um pouco, desenhamos um padrão de retângulos e losangos, caímos um pouco e depois desenhamos outra linha preta. <br><br>  Há muito mais a ser feito no MBDL, mas isso é suficiente para descrever os muitos limites dos mapas.  A próxima etapa é converter a descrição do limite no MBDL na própria borda.  Isso é semelhante à conversão de uma representação escrita de um programa de computador (como Javascript) na execução deste programa.  O primeiro estágio é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">análise lexical (análise) da</a> linguagem - a transformação do texto de origem em uma borda real do mapa ou em algum tipo de forma intermediária, que é mais fácil de converter em uma borda. <br><br>  A análise é uma área bastante estudada da ciência da computação.  A análise de um idioma não é muito simples, mas, no nosso caso, é bom (*) que o MBDL seja uma gramática <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livre de contexto</a> .  As gramáticas sem contexto são analisadas com bastante facilidade e existem muitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramentas de análise de Javascript</a> para elas.  Eu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">decidi</a> pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nearley.js</a> , que parece bastante maduro e (mais importante) uma ferramenta bem documentada. <br><br>  <i>(* Isso não é apenas sorte, eu me certifiquei de que a linguagem fosse livre de contexto.)</i> <br><br>  Não apresentarei gramáticas sem contexto, mas a sintaxe de Nearley é bastante simples e você deve entender o significado sem problemas.  A gramática Nearley consiste em um conjunto de regras.  Cada regra possui um caractere à esquerda, uma seta e a parte direita da regra, que pode ser uma sequência de caracteres e não caracteres, além de várias opções separadas pelo "|"  (ou): <br><br><blockquote> <code><b>border -&gt; element | element border <br> element -&gt;</b> “ <b>L"</b></code> </blockquote> <br>  Cada uma das regras diz que o lado esquerdo pode ser substituído por qualquer uma das opções no lado direito.  Ou seja, a primeira regra diz que uma borda é um elemento, ou um elemento, seguido por outra borda.  Que por si só pode ser um elemento ou um elemento seguido por uma borda e assim por diante.  A segunda regra diz que um elemento pode ser apenas uma string "L".  Ou seja, juntas essas regras correspondem a esses limites: <br><br><blockquote> <code><b>L <br> LLL</b></code> </blockquote> <br>  e não correspondem a esses limites: <br><br><blockquote> <code><b>X <br> L3L</b></code> </blockquote> <br>  A propósito, se você deseja experimentar esta (ou qualquer outra) gramática em Nearley, existe aqui uma caixa de proteção on-line.  Você pode inserir gramática e casos de teste para ver o que corresponde e o que não corresponde. <br><br>  Aqui está uma definição mais completa de uma primitiva de linha: <br><br><blockquote> <code><b>@builtin “number.ne" <br> @builtin “string.ne" <br> border -&gt; element | element border <br> element -&gt; “L(" decimal “," dqstring “)"</b></code> </blockquote> <br>  Nearley possui vários elementos internos comuns e o número é um deles.  Portanto, eu posso usá-lo para reconhecer a largura numérica de uma linha primitiva.  Para reconhecimento de cores, eu uso outro elemento interno e permito o uso de qualquer string entre aspas duplas. <br><br>  Seria bom adicionar espaços entre caracteres diferentes, então vamos fazê-lo.  Nearley suporta classes de caracteres e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RBNF</a> para "zero ou mais" algo com ": *", para que eu possa usar isso para especificar "zero ou mais espaços" e colá-lo em qualquer lugar para permitir espaços nas descrições: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element border <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")"</b></code> </blockquote> <br>  No entanto, o uso de WS por todo o lado dificulta a leitura da gramática, então eu os abandonarei, mas imagine que eles são. <br><br>  Um elemento também pode ser um espaço vertical: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")"</b></code> </blockquote> <br>  Isso corresponde a esses limites <br><br><blockquote> <code><b>L(3.5,"black") VS(3.5)</b></code> </blockquote> <br>  Em seguida, vêm os primitivos de tira, losango e elipse. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")"</b></code> </blockquote> <br>  Combina esses elementos <br><br><blockquote> <code><b>B(34, 17, "white", 3, "black")</b></code> </blockquote> <br>  (Observe que as primitivas geométricas não são "elementos" porque não podem estar sozinhas no nível superior. Elas devem estar entre um padrão.) <br><br>  Também preciso de uma primitiva de espaço horizontal: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Agora vou adicionar uma operação padrão (repetir).  Esta é uma sequência de um ou mais elementos entre colchetes.  Vou usar o operador RBNF ": +", que aqui significa "um ou mais". <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric):+ "]"</b></code> </blockquote> <br>  Observe que o padrão só pode ser preenchido com primitivas geométricas.  Não podemos, por exemplo, colocar uma linha dentro de um padrão.  O elemento padrão agora corresponderá a algo assim. <br><br><blockquote> <code><b>[B(34,17,"white",3,"black")E(13,21,"white",3,"rgb(27,0,0)")]</b></code> </blockquote> <br>  A última parte do idioma é o operador de sobreposição.  Este é qualquer número de elementos dentro de chaves. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric ):+ "]" <br> element -&gt; "{" (element ):+ "}"</b></code> </blockquote> <br>  o que nos permite fazer o seguinte: <br><br><blockquote> <code><b>{L(3.5,"rgb(98,76,15)")VS(3.5)}</b></code> </blockquote> <br>  (Observe que, diferentemente do operador de repetição, o operador de sobreposição pode ser usado internamente.) <br><br>  Depois de limpar a descrição e adicionar espaços aos locais necessários, obtemos a seguinte gramática MBDL: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> element -&gt; "(" WS (element WS):+ ")" <br> element -&gt; "[" WS (geometric WS):+ "]" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Portanto, o MBDL agora está definido e criamos uma gramática da linguagem.  Pode ser usado com o Nearley para reconhecer cadeias de idiomas.  Antes de me aprofundar no MBDL / Nearley, gostaria de implementar as primitivas usadas no MBDL para que o limite descrito no MBDL possa ser exibido.  Isso faremos na próxima parte. <br><br><h2>  Parte 3 </h2><br>  Agora começaremos a implementar as próprias primitivas de renderização.  (Neste momento, ainda não preciso vincular o analisador às primitivas de renderização. Para testar, vou chamá-las apenas manualmente.) <br><br>  Vamos começar com a linha primitiva.  Lembre-se da aparência: <br><br><blockquote> <code><b>L(width, color)</b></code> </blockquote> <br>  Além da largura e cor, há um parâmetro implícito aqui - a distância da borda externa do mapa.  (Eu desenho as bordas da borda do mapa para fora. Observe que começamos de uma diferente!). Não deve apontar para o MBDL, porque isso pode ser rastreado pelo intérprete que executa o MBDL para desenhar a borda.  No entanto, isso deve ser uma entrada para todas as primitivas de renderização, para que elas saibam onde desenhá-las.  Vou chamar esse parâmetro de deslocamento. <br><br>  Se eu apenas precisasse desenhar uma borda na parte superior do mapa, a primitiva de linha seria muito simples de implementar.  No entanto, de fato, precisarei desenhar de cima.  inferior, esquerda e direita.  (Talvez um dia eu perceba bordas oblíquas ou curvas, mas por enquanto vamos aderir às bordas retangulares padrão.) Além disso, o comprimento e a localização do elemento de linha dependem do tamanho do mapa (assim como do deslocamento).  Portanto, como parâmetros, preciso de todos esses dados. <br><br>  Depois de definir todos esses parâmetros, basta criar uma primitiva de linha e usá-la para desenhar uma linha ao redor do mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a56/74f/785/a5674f78512bef22e569656701203401.png"></div><br>  (Observe que eu uso várias funções de <b>Dragons Abound</b> para desenhar a linha "manuscrita".) Vamos tentar criar uma borda mais complexa: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black)</b></code> </blockquote> <br>  É assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86a/ad8/849/86aad88494c1c17f993524ef09ef9b2f.png"></div><br>  Muito bom.  Observe que há lugares em que as linhas pretas e a linha dourada não estão bem alinhadas devido a flutuações.  Se eu quiser me livrar desses pontos, você pode simplesmente reduzir a quantidade de oscilação. <br><br>  A implementação de uma primitiva de espaço vertical é bastante simples;  apenas realiza um incremento de deslocamento.  Vamos adicionar um pouco de espaço: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black) <br> VS(5) <br> L(3, black) L(10, red) L(3, black)</b></code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eab/471/b90/eab471b902eb44e703f460d700936937.png"></div><br>  Ao desenhar linhas, os ângulos podem ser realizados traçando entre o deslocamento e o desenho ao longo do mapa no sentido horário.  Mas, em geral, preciso implementar o truncamento em cada lado da borda do mapa para criar uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conexão angular com um chanfro</a> .  Isso será necessário para criar bordas com padrões unidos corretamente nos cantos e, no caso geral, eliminará a necessidade de desenhar elementos com bordas em um ângulo que seria necessário.  (*) <br><br>  <i>(Observação: como será dito nas partes a seguir, com o tempo, me recusei a usar regiões de truncamento ao implementar ângulos. O principal motivo é que, para criar ângulos complexos, por exemplo, deslocamentos quadrados:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  <i>são necessárias áreas de truncamento cada vez mais complexas.</i>  <i>Além disso, com o tempo, descobri uma maneira melhor de trabalhar com padrões nos cantos.</i>  <i>Em vez de retornar e reescrever esta parte do artigo, decidi deixá-lo para ilustrar o processo de "criatividade".)</i> <br><br>  A idéia principal é truncar cada borda na diagonal e criar quatro áreas truncadas nas quais cada lado da borda será desenhado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/31a/cf9/9fb31acf993cde46b6a7fdc408be6afd.png"></div><br>  Ao truncar, tudo o que for desenhado na área correspondente será cortado no ângulo desejado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/52b/f00/f02/52bf00f026f6979f6425345389fa646a.png"></div><br>  Infelizmente, isso cria pequenas lacunas ao longo das linhas diagonais, provavelmente porque o navegador executa suavemente a suavização ao longo da borda truncada.  O teste mostrou que um fundo brilha através do espaço entre as duas arestas.  Foi possível corrigir isso expandindo um pouco as máscaras (metade do pixel parece ser suficiente), mas isso às vezes não resolve o problema. <br><br>  Em seguida, você precisa implementar formas geométricas.  Diferentemente das linhas, elas são repetidas no padrão, preenchendo a lateral da borda do mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Uma pessoa desenharia esse padrão da esquerda para a direita, desenhando um retângulo, um losango e repetindo o mesmo até que toda a borda fosse preenchida.  Portanto, isso também pode ser implementado no programa, desenhando um padrão ao longo da borda.  No entanto, será mais fácil desenhar primeiro todos os retângulos e depois todos os losangos.  Basta desenhar ao longo da borda a mesma figura geométrica em intervalos.  E é muito conveniente que cada elemento tenha o mesmo intervalo.  Obviamente, uma pessoa não faria isso, porque é muito difícil organizar os elementos nos lugares certos, mas isso não é um problema para o programa. <br><br>  Ou seja, o procedimento para desenhar formas geométricas simples precisa de parâmetros nos quais todas as dimensões e cores da figura são transmitidas (ou seja, largura, comprimento, espessura da linha, cor e preenchimento da linha), bem como a posição inicial (que por razões que ficarão claras em breve, Vou considerar o centro da figura), o intervalo de espaço horizontal para a transição entre repetições e o número de repetições.  Também será conveniente indicar a direção da repetição na forma do vetor [dx, dy], para que possamos executar repetições da esquerda para a direita, da direita para a esquerda, para cima ou para baixo, simplesmente alterando o vetor e o ponto de partida.  Junte tudo e obtenha uma faixa de formas repetidas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bcd/c33/409bcdc33756610ac6ace2d0fde0a3a4.png"></div><br>  Usando esse código várias vezes e renderizando com o mesmo deslocamento, posso combinar as listras em preto e branco para criar a escala do mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/8f5/0d9/b888f50d9f164b9319cc8b3cf8d38588.png"></div><br>  Antes de começar a descobrir como aplicar tudo isso à borda real do mapa, vamos primeiro implementar a mesma funcionalidade para elipses e losangos. <br><br>  Losangos são apenas retângulos com vértices rotacionados, portanto, você só precisa fazer uma pequena alteração no código.  Acontece que eu ainda não tenho código pronto para renderizar a elipse, mas é muito fácil obter a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">visão paramétrica da elipse</a> e criar uma função que me dê os pontos da elipse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fa/74e/079/3fa74e079dd2c29afa5acb0135d4092f.png"></div><br>  Aqui está um exemplo (criado manualmente) que usa os recursos implementados acima: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/bf2/d39/bf8bf2d3992b34bc173622dc86c0d8b5.png"></div><br>  Para uma quantidade tão pequena de código, parece muito bom! <br><br>  Vamos agora resolver o caso complexo de bordas com elementos repetidos: cantos. <br><br>  Se houver uma borda com elementos repetidos, existem várias maneiras de resolver o problema com cantos.  O primeiro é ajustar as repetições para que sejam executadas nos cantos sem casamento perceptível: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Outra opção é parar a repetição em algum lugar próximo à esquina dos dois lados.  Isso geralmente é feito se o padrão não puder ser facilmente “rotacionado” no canto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  A última opção é fechar o padrão com alguma decoração de canto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Algum dia chegarei às decorações dos cantos, mas por enquanto usaremos a primeira opção.  Como fazer com que um padrão de listras ou círculos gire nos cantos do mapa sem espaços? <br><br>  A idéia principal é colocar o elemento do padrão exatamente no canto, para que metade dele esteja em uma borda do mapa e a outra no lado adjacente.  Neste exemplo, o círculo está exatamente no canto e pode ser desenhado de qualquer direção: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Em outros casos, o elemento é meio desenhado em uma direção e metade na outra, mas as arestas coincidem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Nesse caso, uma faixa branca é desenhada nos dois lados, mas é conectada no canto sem espaços. <br><br>  Há dois aspectos a serem considerados ao colocar um elemento em um canto. <br><br>  Primeiro, o elemento de canto será dividido e espelhado em relação à diagonal que passa pelo centro do elemento.  Elementos com simetria radial, por exemplo, quadrados, círculos e estrelas, não mudam de forma.  Elementos sem simetria radial, por exemplo, retângulos e losangos, mudarão de forma ao espelhar em relação à diagonal. <br><br>  Em segundo lugar, para que os elementos de canto dos dois lados se conectem corretamente, deve haver um número inteiro de elementos (*) nos dois lados do mapa.  Eles não precisam ter o mesmo número, mas deve haver um número inteiro de elementos nos dois lados.  Se um número fracionário de padrões estiver contido em um lado, a partir de uma borda, o padrão não coincidirá com o lado adjacente. <br><br>  <i>(* Em alguns casos, por exemplo, com listras longas, a repetição parcial pode ocorrer com repetição total e os elementos ainda estarão alinhados. No entanto, o elemento de canto resultante será assimétrico e diferirá em comprimento do mesmo elemento nas laterais do mapa. Um exemplo disso pode ser visto aqui:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/418/110/263418110aafe94ef8c62d57e8540371.png"></div><br>  <i>Uma barra branca de escala ocorre com diferentes repetições parciais e, como resultado, é obtido um elemento deslocado em relação ao centro.</i>  <i>Para a escala do mapa, esse nem sempre é o caso, porque mostra a distância absoluta e não precisa ser simétrico.</i>  <i>Mas para um padrão decorativo, isso geralmente parece ruim.)</i> <br><br>  Aqui está um exemplo mostrando como um número inteiro de repetições é aparado exatamente no canto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/8de/0a3/8ab8de0a3452332e2813b3771091b165.png"></div><br>  Se você fizer o mesmo dos quatro lados, os cantos coincidirão e o padrão ficará perfeitamente localizado ao longo de toda a extensão da borda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/c9a/e46/dfcc9ae46a68807e983705e553aa2ba3.png"></div><br>  Após um exame cuidadoso, você notará que o padrão não ocorre exatamente nos cantos.  Metade do círculo em cada canto é tirada de cada lado, e essas duas metades são desenhadas à mão independentemente, portanto, não são perfeitas.  Mas agora eles estão perto o suficiente disso. <br><br>  Assim, podemos realizar uma conexão perfeita do padrão nos cantos, escolhendo um número inteiro de repetições para cada aresta.  No entanto, a solução para esse problema não é trivial. <br><br>  Primeiro, suponha que sabemos que o lado tem 866 pixels e queremos repetir o elemento 43 vezes.  Em seguida, o elemento deve ser repetido a cada 20,14 pixels.  Como definimos o comprimento específico de um elemento (e, no caso geral, um padrão de elementos)?  No exemplo acima, adicionei espaço extra entre os círculos.  Mas se os círculos se tocaram inicialmente, isso mudará o padrão.  Talvez valha a pena esticar os círculos para que eles continuem se tocando? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/2b0/ebd/e362b0ebd3fd04e5d8b00de5d3aba151.png"></div><br>  Agora os elementos estão se tocando, mas os círculos se transformaram em elipses e os cantos têm uma forma estranha.  (Lembre-se de que eu disse que elementos sem simetria radial mudam de forma quando refletidos em relação a um ângulo? Para listras, isso não será um grande problema.) Ou talvez valha a pena apertar todos os elementos para que eles se toquem e se ajustem em um comprimento adequado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/ba8/0af/d7cba80afb431dc6c9afc52d7ad94b5c.png"></div><br>  Mas, para perceber isso, precisamos tornar os elementos muito menores do que eram originalmente.  Nenhuma dessas opções parece perfeita. <br><br>  O segundo problema ocorre quando os lados do cartão são de tamanhos diferentes.  Agora precisamos resolver o problema de encontrar um número inteiro de repetições adequado para ambos os lados.  Seria ideal encontrar uma solução adequada para ambos os lados.  Mas não quero fazer isso à custa de muitas mudanças de padrão.  Talvez seja melhor criar padrões ligeiramente diferentes em ambos os lados se ambos estiverem próximos o suficiente do padrão original. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E finalmente, o terceiro problema surge quando eu uso a função de sobrepor vários elementos um ao outro: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4ed/6ac/4d94ed6acf107193f2109bd2b2f07a67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não quero fazer alterações no padrão que destruirão o relacionamento entre os elementos. </font><font style="vertical-align: inherit;">Penso que, com o dimensionamento adequado, as proporções como um todo permanecerão, mas preciso testar isso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarefa interessante, certo? </font><font style="vertical-align: inherit;">Até agora, não tenho soluções particularmente de alta qualidade para ela. </font><font style="vertical-align: inherit;">Talvez eles apareçam mais tarde!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 4 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, implementamos primitivas para desenhar linhas e formas geométricas. Comecei a trabalhar no uso de formas repetidas para preencher as bordas e falei sobre as dificuldades de colocar padrões arbitrários na borda do mapa para que eles se encaixassem perfeitamente nos cantos. O principal problema é que, no caso geral, é necessário tornar o padrão mais longo (ou mais curto) para que ele se ajuste lateralmente. As opções para alterar o comprimento do padrão - adicionar ou remover espaços, alterar o comprimento dos elementos dos padrões - levam a várias alterações no próprio padrão. Parece que a tarefa de selecionar um padrão de vários elementos é muito difícil!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando me deparei com essas tarefas aparentemente intransigentes, gosto de começar implementando uma versão simples. Muitas vezes, as tarefas malsucedidas podem ser resolvidas resolvendo repetidamente problemas "simples" até que o resultado seja bom o suficiente. E, às vezes, a implementação de uma versão simples fornece um entendimento que simplifica a solução de um problema mais complexo. Se não melhorar e o problema permanecer desconfortável, pelo menos teremos uma versão simplificada que ainda pode ser útil, embora não exatamente como deveria.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais fácil é alterar o comprimento do padrão adicionando comprimentos sem alterar nada no padrão. </font><font style="vertical-align: inherit;">Essencialmente, isso adiciona espaço em branco ao final do padrão. </font><font style="vertical-align: inherit;">(Nota: é melhor distribuir o espaço vazio entre todos os elementos no padrão.) Vale a pena considerar que essa solução pode apenas prolongar o padrão. </font><font style="vertical-align: inherit;">Sempre podemos adicionar espaço vazio ao padrão, mas não podemos aceitá-lo se necessário - talvez não haja mais espaço vazio no padrão! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com essa abordagem, o algoritmo de localização do padrão na lateral da placa será muito simples:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Divida o comprimento do lado do cartão pelo comprimento do padrão e arredonde-o para baixo para determinar o número de repetições do padrão que se encaixam nesse lado. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A distância entre os elementos neste caso será igual ao comprimento do lado dividido pelo número de repetições. </font><font style="vertical-align: inherit;">(Este é o local mais próximo do local original, pois só podemos adicionar espaço.)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desenhe um padrão ao longo do lado, levando em consideração a distância calculada. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi difícil implementar esse sistema. </font><font style="vertical-align: inherit;">Os cantos teimosamente não quiseram coincidir. </font><font style="vertical-align: inherit;">Levei muito tempo para perceber que, quando o mapa não é quadrado, não consigo desenhar áreas de truncamento para quatro lados do centro do mapa, porque isso cria ângulos de truncamento que não são iguais a 45 graus. </font><font style="vertical-align: inherit;">De fato, as áreas de truncamento devem se parecer com a parte traseira de um envelope:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/29a/beb/b2029abeb54302b5f7d3335a15c95f86.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando eu descobri isso, o algoritmo começou a funcionar sem problemas. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Mas não se esqueça da observação anterior de que, com o tempo, abandonei as áreas de truncamento!)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui está um exemplo com uma proporção de aproximadamente 2: 1:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/739/d19/bff739d19d76fdb4db63033b970eb241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nessa escala, é muito difícil perceber, mas os cantos se conectam corretamente e há apenas uma pequena diferença visual entre os lados. </font><font style="vertical-align: inherit;">Nesse caso, o algoritmo para alinhar os padrões só precisa inserir pixels fracionários, de modo que fica invisível aos olhos, principalmente porque os contornos dos círculos são sobrepostos por um pixel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui está outro exemplo com listras:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/852/625/aa8852625e15121ce822cc6ca5fe8742.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este é o topo da borda quadrada. </font><font style="vertical-align: inherit;">Aqui está a mesma borda em um mapa mais retangular:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/207/9b1/90d2079b1e869c59ee204f1a75f5dbc7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui você pode ver que no lado do cartão há uma diferença visualmente maior entre as bandas. </font><font style="vertical-align: inherit;">O algoritmo não deve inserir mais espaço do que o comprimento de um elemento completo; </font><font style="vertical-align: inherit;">portanto, o pior caso ocorre quando temos elementos longos e um lado curto ligeiramente diferente de um tamanho adequado. </font><font style="vertical-align: inherit;">Mas na maioria dos casos práticos, o alinhamento não é muito prejudicial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui está um exemplo com um padrão de vários elementos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/602/4f8/d186024f8ee1e4fbcd5918c63537a024.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui as listras se sobrepõem às listras: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/af7/ad6/c60af7ad6c71ee4ef1850f0bf194af62.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode ver que, como o mesmo alinhamento é realizado para cada elemento, as faixas permanecem centradas uma em relação à outra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sugeri que uma boa solução para colocar o padrão ao lado do mapa seria difícil, mas uma abordagem muito simples com a distribuição uniforme do elemento do padrão para preencher o espaço desejado funciona muito bem para muitos padrões. Isso é um lembrete para todos nós: não há necessidade de supor que a decisão deve ser complicada; pode ser mais fácil do que você pensa! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, esta solução não funciona para padrões com elementos tocantes, por exemplo, para escala de mapa. Nesse caso, adicionar espaço muda os elementos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/d7e/27f/3cdd7e27f8c2d92be26d36e7b4807f5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra opção para alongar um padrão, que mencionei acima, é esticar os elementos individuais do padrão. </font><font style="vertical-align: inherit;">É adequado para algo como um padrão de escala, mas ficará ruim em um padrão com elementos simétricos, porque o alongamento os tornará assimétricos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A implementação da opção com alongamento acabou sendo mais difícil do que eu esperava, principalmente porque tive que esticar os elementos em diferentes arestas do mapa por tamanhos diferentes (porque o mapa pode não ser quadrado, mas retangular) e também alterar dinamicamente a disposição dos elementos com base nos novos esticados. tamanhos. </font><font style="vertical-align: inherit;">Mas depois de algumas horas, consegui isso:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/552/3c4/d1c5523c43a9828cd9c1c1bee6f4bbde.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora eu tenho todos os recursos necessários para desenhar a borda do mapa (embora os próprios elementos da borda sejam criados manualmente): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2b/ccc/326/d2bccc326a0500f92267378e137e2f6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Converti a imagem em escala de cinza, porque não queria me preocupar com a seleção de cores, e o cartão em si é bastante entediante, mas como prova de conceito, as bordas parecem muito bonitas. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 5 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte 2, desenvolvi a gramática MBDL (Map Border Description Language) e, nas partes 3 e 4, implementei procedimentos para executar todas as primitivas da linguagem. </font><font style="vertical-align: inherit;">Agora, trabalharei na conexão dessas partes para poder descrever a borda no MBDL e desenhá-la no mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte 3, escrevi a gramática MBDL para que funcione com a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ferramenta de análise de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JavaScript </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Nearley</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A gramática final é assim:</font></font><br><br><blockquote> <code><b>@builtin</b> <b>"</b> <b>number.ne"</b> <br> <b>@builtin</b> <b>"</b> <b>string.ne"</b> <br> <b>border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>VS(" number</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>(" WS (element WS):+</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>[" WS (geometric WS):+</b> <b>"</b> <b>]"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>B(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>E(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>D(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>HS(" number</b> <b>"</b> <b>)"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por padrão, ao analisar com êxito uma regra usando Nearley, a regra retorna uma matriz contendo todos os elementos que correspondem ao lado direito da regra. </font><font style="vertical-align: inherit;">Por exemplo, se a regra</font></font><br><br><blockquote> <code><b>test -&gt;</b> <b>"</b> <b>A" |</b> <b>"</b> <b>B" |</b> <b>"</b> <b>C"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> combinado com string </font></font><br><br><blockquote> <code><b>A</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nearley retornará </font></font><br><br><blockquote> <code><b>[</b> <b>"</b> <b>A" ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma matriz com um único valor é a sequência "A" correspondente ao lado direito da regra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que Nearley retorna quando um elemento é analisado usando esta regra?</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como existem três partes no lado direito da regra, ele retornará uma matriz com três valores. </font><font style="vertical-align: inherit;">O primeiro valor será o que retornará a regra para o WS, o segundo valor será o que retornará a regra para decimal e o terceiro valor será o que retornará a regra para o WS. </font><font style="vertical-align: inherit;">Se, usando a regra acima, pars "57", o resultado será o seguinte:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> [ "5", "7" ], <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O resultado final da análise de Nearley será uma matriz aninhada de matrizes, que é uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">árvore de sintaxe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em alguns casos, a árvore de sintaxe é uma representação muito útil; em outros casos, não é bem assim. Em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por exemplo, essa árvore não é particularmente útil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felizmente, as regras de Nearley podem substituir o comportamento padrão e retornar o que quiserem. De fato, a regra (interna) para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não retorna uma lista de números, retorna o número Javascript equivalente, que na maioria dos casos é muito mais útil, ou seja, o valor de retorno da regra </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numérica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tem a forma:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> 57, <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As regras de Nearley redefinem o comportamento padrão adicionando um pós-processador à regra, pegando uma matriz padrão e substituindo-a pelo que você precisa. Um pós-processador é apenas código Javascript entre colchetes especiais no final de uma regra. Por exemplo, na regra do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">número</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">nunca estou interessado em espaços possíveis em ambos os lados do número. Portanto, seria conveniente se a regra simplesmente retornasse um número, e não uma matriz de três elementos. Aqui está um pós-processador que executa esta tarefa:</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS {% default =&gt; default[1] %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse pós-processador pega o resultado padrão (a matriz de três elementos mostrada acima) e a substitui pelo segundo elemento da matriz, que é o número Javascript da regra </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decimal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Então agora a regra </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numérica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retorna o número real. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa funcionalidade pode ser usada para processar um idioma recebido em um idioma intermediário, mais fácil de trabalhar. </font><font style="vertical-align: inherit;">Por exemplo, eu posso usar a gramática Nearley para transformar uma string MBDL em uma matriz de estruturas Javascript, cada uma das quais representa uma primitiva identificada por um campo "op". </font><font style="vertical-align: inherit;">A regra para a linha primitiva será mais ou menos assim:</font></font><br><br><blockquote> <code><b>element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)" {% data=&gt; {op:</b> <b>"</b> <b>L", width: data[1], color: data[3]} %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou seja, o resultado da análise de "L (13, preto)" será a estrutura Javascript: </font></font><br><br><blockquote> <code><b>{op:</b> <b>"</b> <b>L", width: 13, color:</b> <b>"</b> <b>black"}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após adicionar o pós-processamento apropriado, o resultado retornado da gramática pode ser uma sequência (matriz) de estruturas de operação para a linha de entrada. </font><font style="vertical-align: inherit;">Ou seja, o resultado da análise da string</font></font><br><br><blockquote> <code><b>L( 415, “black") <br> VS(5) <br> [B(1, 2, “black", 3, “white") HS(5) E(1, 2, “black", 3, “white")]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> será </font></font><br><br><blockquote> <code><b>[ <br> {op: "L", width: 415, color: "black"}, <br> {op: "VS", width: 5}, <br> {op: "P", <br> elements: [{op: "B", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}, <br> {op: "HS", width: 5}, <br> {op: "E", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}]} <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o que é muito mais fácil de processar para criar uma borda do mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, você pode ter uma pergunta - se o estágio de pós-processamento da regra Nearley pode conter qualquer Javascript, por que não pular a visualização intermediária e simplesmente desenhar a borda do mapa durante o pós-processamento? </font><font style="vertical-align: inherit;">Para muitas tarefas, essa abordagem seria ideal. </font><font style="vertical-align: inherit;">Decidi não usá-lo por vários motivos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiramente, no MBDL há alguns (*) componentes que não podem ser executados durante o processo de análise. Por exemplo, não podemos desenhar elementos geométricos repetidos (faixa ou losango) durante o processo de análise, porque precisamos conhecer informações de outros elementos no mesmo padrão. Em particular, precisamos saber o comprimento total do padrão para entender até que ponto precisamos organizar as repetições de cada elemento individual. Ou seja, o elemento do padrão ainda deve criar uma representação intermediária de todos os elementos geométricos. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(* Existem outros componentes com limitações semelhantes das quais ainda não falei.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, o Javascript em Nearley está incorporado nas regras, portanto, não poderemos passar informações adicionais ao Javascript, exceto para variáveis ​​globais. Por exemplo, para desenhar a borda, preciso saber o tamanho do mapa, as quatro áreas de truncamento usadas etc. Embora eu possa adicionar um código que disponibilize essas informações para os pós-processadores de Nearley, ele ficará um pouco confuso e poderá ser difícil manter esse código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por esses motivos, estou analisando uma representação intermediária, que é executada para criar a borda do próprio mapa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A próxima etapa é desenvolver um intérprete que receba uma representação intermediária do MBDL e o execute para gerar limites do mapa. Isso não é muito difícil de fazer. Basicamente, a tarefa é definir as condições iniciais (por exemplo, gerar regiões de truncamento para os quatro lados do mapa) e iterar sobre a sequência de estruturas da representação intermediária com cada uma executando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Há alguns momentos escorregadios.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, preciso passar da renderização de dentro para o desenho de dentro para fora. O motivo é que eu quero que a maioria das bordas não se sobreponha ao mapa, então preciso desenhar as bordas para que as linhas da borda interna coincidam com as bordas do mapa. Se eu desenhar de fora para dentro, preciso saber a largura da borda antes de começar a desenhar para que a borda não se sobreponha ao mapa. Se eu desenhar de dentro para fora, eu apenas começo da borda do mapa e desenho. Também permite que você imponha opcionalmente uma borda no mapa; basta iniciar a borda com um espaço vertical negativo (VS).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro ponto difícil são os padrões repetidos. </font><font style="vertical-align: inherit;">Para desenhar padrões repetidos, preciso examinar todos os elementos do padrão e determinar o mais amplo, porque ele definirá a largura de todo o padrão. </font><font style="vertical-align: inherit;">Também preciso observar e acompanhar o comprimento do padrão para saber quanto tempo falta antes de cada repetição. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui está um exemplo de uma borda bastante complexa que eu usei para testar o intérprete:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c8/88a/2a9/3c888a2a96352845f6165f5eca7f6ab3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eu acho que era possível (necessário?) Anexá-lo para teste no analisador, mas para essa borda eu apenas criei uma exibição intermediária manualmente: </font></font><br><br><blockquote> <code><b>[ <br> {op:'P', elements: [ <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'white'}, <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'black'}, <br> ]}, <br> {op:'VS', width: 2}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'PUSH'}, <br> {op:'L', width:10, color: 'rgb(222,183,64)'}, <br> {op:'POP'}, <br> {op:'PUSH'}, <br> {op:'P', elements: [ <br> {op:'E', width: 5, length: 5, lineWidth: 1, color: 'black', fill: 'red'}, <br> {op:'HS', length: 10}, <br> ]}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'POP'}, <br> {op:'VS', width: 2}, <br> {op:'P', elements: [ <br> {op:'E', width: 2, length: 2, lineWidth: 0, color: 'black', fill: 'white'}, <br> {op:'HS', length: 13}, <br> ]}, <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu criei essa visão por tentativa e erro. Seja como for, o intérprete funciona! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como último passo, deixe-me usar o analisador para criar uma exibição intermediária a partir da versão do MBDL. Não há muito para me mostrar aqui: tive que corrigir alguns nomes de campos, mas, caso contrário, o código funcionou bem. Para a borda, usei uma versão ligeiramente diferente do MBDL:</font></font><br><br><blockquote> <code><b>[B(5,37,"black",2,"white") B(5,37,"black",2,"black")] <br> VS(3) <br> L(3,"black") <br> {L(10,"rgb(222,183,64)")} <br> [E(5,5,"black",1,"red") HS(-5) E(2,2,"none",0,"white") HS(10)] <br> L(3,"black")</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ela desenha a mesma borda, mas de uma maneira um pouco diferente. </font><font style="vertical-align: inherit;">Também alterei a sintaxe da sobreposição, substituindo os parênteses por chaves, para que fique mais diferente da outra sintaxe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar por que eu queria desenhar de dentro para fora e não apenas colocar automaticamente a borda do lado de fora do mapa, posso adicionar um espaço vertical negativo ao início dessa borda para mover a escala do mapa para dentro da borda do mapa:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, tenho a maior parte da infraestrutura necessária para a geração procedural de bordas do mapa: uma linguagem de descrição de limites, um analisador de idiomas e procedimentos para executar uma representação intermediária. </font><font style="vertical-align: inherit;">Resta apenas lidar com a parte difícil - a geração processual!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 6 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que todo o MBDL foi implementado, pretendi prosseguir para a geração processual das bordas do mapa, mas ainda não tenho certeza de como quero fazer isso, porque vou demorar um pouco e implementar mais alguns recursos do MBDL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na primeira discussão sobre o processamento de cantos com padrões, falei sobre algumas abordagens diferentes. No final, percebi os cantos chanfrados, mas havia uma segunda opção: interromper o padrão próximo ao canto, como nos exemplos a seguir:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/94d/01b/3b794d01b552c42ed9b8362f5405ff9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/3a8/159/ee23a8159d81afd1f7c95c16a90bcdf7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa solução é frequentemente usada quando o padrão da borda é algum tipo de figura assimétrica, runas ou qualquer outra coisa que não possa ser girada 90 graus, mantendo o alinhamento. Mas é óbvio que isso funcionará com formas geométricas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa pode ser a opção que você escolhe antes de gerar a borda, mas você pode adicionar um pouco de flexibilidade se a ativar em uma parte da borda e usar o canto chanfrado na outra. Para fazer isso, tenho que adicionar um novo comando ao MBDL. Eu suspeito que outras opções possam surgir para diferentes partes da borda, então adicionarei um comando de opções gerais:</font></font><br><br><blockquote> <code><b>element -&gt; "O(MITER)"</b> <br> <b>element -&gt; "O(STOPPED)"</b> <br> <b>element -&gt; "O(STOPPED," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Aqui, novamente, para maior clareza, omitimos espaços e outros detalhes.) Até agora, as únicas opções são "MITRE" para cantos chanfrados e "PARADO" para parar nos cantos próximos. </font><font style="vertical-align: inherit;">Se nenhum valor for transmitido PARADO, o programa interrompe o padrão a uma distância razoável da esquina. </font><font style="vertical-align: inherit;">Se o valor for transmitido, o padrão será interrompido a essa distância do canto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se cantos STOPPED forem usados, paro de desenhar o padrão dos cantos.</font></font> Aqui está o que parece: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/5df/49e/a8e5df49eecf2ebc5e94e571cb7d0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, usei a opção MITRE para o padrão de escala em preto e branco, para que ele espelhe em relação ao ângulo. </font><font style="vertical-align: inherit;">Para um padrão de círculos vermelhos e quadrados pretos dentro de uma linha dourada (e para um padrão de círculos fora da borda), usei STOPPED. </font><font style="vertical-align: inherit;">Você pode ver que esses dois padrões terminam perto da esquina.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, existem alguns problemas. Primeiramente, vemos que, à esquerda, o elemento mais próximo ao canto é um quadrado preto e, no topo, um círculo vermelho. Isso aconteceu porque o canto está próximo ao início da repetição, de um lado, e ao final da repetição, de outro. Mas parece estranho. Seria melhor se os cantos fossem simétricos, mesmo que para isso tivéssemos que adicionar outro elemento ao final do padrão. Em segundo lugar, você pode ver que o padrão fora da borda (semicírculos e pontos pretos) também termina em uma repetição no canto. Mas como a duração dessa repetição é muito menor que a duração dos círculos vermelhos / quadrados pretos, eles terminam em lugares diferentes. Provavelmente seria melhor se todos os padrões parassem à mesma distância da esquina.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para corrigir o primeiro problema, você precisa adicionar outra repetição do primeiro elemento do padrão no final de cada lado da borda. </font><font style="vertical-align: inherit;">Mas, na verdade, é um pouco mais complicado, porque eu poderia usar um deslocamento horizontal negativo dentro do padrão para sobrepor vários elementos (como feito aqui). </font><font style="vertical-align: inherit;">Você também precisa adicionar outra repetição a qualquer elemento do padrão que tenha o mesmo ponto inicial do primeiro elemento.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/331/6fc/9c43316fcd44d79a0b2374401a46240a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, o padrão é simétrico em relação ao ângulo e parece muito melhor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, preciso rastrear o padrão STOPPED mais longo e parar cada padrão STOPPED a essa distância:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a33/920/c6c/a33920c6cda9072bbda915544f1f4926.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, o padrão dos círculos brancos é mais reservado, mas ainda não está alinhado com o padrão dos círculos vermelhos. </font></font> Porque<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso aconteceu porque o padrão de círculo branco está mais distante da borda do mapa e o comprimento da borda é maior do que o local onde o padrão de círculo vermelho é desenhado. </font><font style="vertical-align: inherit;">Para corrigir esse problema, você precisa mover os padrões também, considerando o deslocamento em relação à borda do mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70b/574/2c1/70b5742c1d4f404335b97128f09d6baf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora tudo está maravilhosamente alinhado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda opção para ângulos são os deslocamentos quadrados nos cantos, por exemplo:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Será muito mais difícil implementar isso! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, a gramática desta opção é simples e usa o opcode da opção:</font></font><br><br><blockquote> <code><b>element -&gt; "O(SQOFFSET)"</b> <br> <b>element -&gt; "O(SQOFFSET," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O número indica o tamanho do deslocamento quadrado do elemento na borda do mapa; </font><font style="vertical-align: inherit;">Elementos com deslocamentos diferentes devem ser alinhados de acordo. </font><font style="vertical-align: inherit;">Se não houver número, o programa seleciona o tamanho de deslocamento apropriado. </font><font style="vertical-align: inherit;">Zerar o número desativa o deslocamento quadrado. </font><font style="vertical-align: inherit;">Isso permite criar bordas nas quais alguns elementos usam deslocamentos quadrados, enquanto outros não, como nesta borda:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira coisa que percebi foi que precisaria de áreas de truncamento adicionais porque uso o truncamento para processar locais onde a borda muda de direção. </font><font style="vertical-align: inherit;">SQOFFSET exigirá áreas de truncamento mais complexas; </font><font style="vertical-align: inherit;">Você também precisará de áreas separadas para itens diferentes ao ativar e desativar o SQOFFSET. </font><font style="vertical-align: inherit;">Dado que as áreas de truncamento adicionam artefatos indesejados de qualquer maneira, isso parece muito trabalho.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando trabalhei nos padrões passíveis de parada acima, implementei o preenchimento de um padrão assimétrico para adicionar outra repetição a partir de uma extremidade do padrão. Também percebi que isso eliminaria a necessidade de cantos chanfrados. Simplesmente desenharei todos os padrões ao longo da borda no sentido horário, iniciando o padrão em um canto e terminando próximo ao próximo. Isso permitirá que eu me livre das áreas de truncamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O mais importante nessa nova maneira de trabalhar com cantos é que o primeiro elemento do padrão não é mais "dividido" em dois lados. Se você observar os padrões de escala em preto e branco nos mapas acima, poderá ver que há um retângulo branco passando pelo canto. Agora o retângulo branco fica ao lado do canto:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/909/c83/ead909c83fa91ff80af290ab92ca9fae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os mapas são desenhados nos dois sentidos, mas esse não é um problema muito grande. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para iniciantes, implementei compensações para linhas. </font><font style="vertical-align: inherit;">Para isso, basta girar a linha em relação aos ângulos correspondentes:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/bf6/2fd/9c2bf62fdfec732f56361f4aa17fc19e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como você pode entender, eu posso combinar ângulos com deslocamentos e ângulos regulares, como no mapa acima: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f5b/e02/e0bf5be02606044dd5fba4f82d3dad67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, virar os padrões ao virar da esquina é mais difícil. </font><font style="vertical-align: inherit;">A idéia geral é desenhar de um canto para quase o outro, e assim por diante, ao longo da fronteira, até voltarmos ao início. </font><font style="vertical-align: inherit;">Teoricamente, basta desenhar apenas padrões horizontais e verticais, e tudo deve estar perfeitamente alinhado; </font><font style="vertical-align: inherit;">rastrear tudo isso é bastante triste. </font><font style="vertical-align: inherit;">Na verdade, tive que reescrever completamente o código duas vezes e escrever um monte de papel, mas não falarei sobre isso em detalhes. </font><font style="vertical-align: inherit;">Apenas mostre o resultado:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/35b/889/91235b889603c973fcfe094a1614a993.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma ilusão de ótica irritante surge nos cantos - o elemento do canto parece não centrado perto do lado de fora do canto. </font><font style="vertical-align: inherit;">De fato, isso não é verdade, mas parece que sim, porque mais perto do lado de dentro da esquina há um espaço visualmente mais vazio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os segmentos dos ângulos de deslocamento são bastante curtos, é muito fácil criar um padrão de não equilíbrio no canto:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/601/dff/b1b601dffc11782fb8cbe738a906b0e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Às vezes parece muito feio. </font><font style="vertical-align: inherit;">Isso me lembrou uma velha piada:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paciente: "Doutor, quando faço isso, me dói." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Médico: "Então não faça isso!"</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, tentarei não fazer isso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalmente, não desenharei a escala do mapa ao longo do ângulo de deslocamento, mas, se necessário, precisarei usar a opção que estica o padrão para que a escala do mapa caiba no canto sem espaços entre os retângulos:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26f/a88/0da/26fa880da6d00d380afdae60c489dd9c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode ver que, como resultado, o tamanho dos retângulos da escala varia acentuadamente. </font><font style="vertical-align: inherit;">Ou seja, essa não é uma opção muito boa. </font><font style="vertical-align: inherit;">(A propósito, os ângulos de deslocamento também apresentam um erro no padrão dos círculos. Mais tarde, eu o corrigi, mas como disse, é muito difícil fazê-lo.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o padrão é muito grande para caber no segmento do ângulo de deslocamento, o algoritmo simplesmente desiste:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/044/b2d/b4d044b2dc2bf23cd670113476b9803d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que está longe de ser o ideal, mas, como eu disse acima, "então não faça". </font><font style="vertical-align: inherit;">(Na verdade, não é muito difícil adicionar uma função de compressão ou alongamento, se eu precisar.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que acontece se eu usar os cantos deslocados e a opção que interrompe os padrões na frente dos cantos? </font><font style="vertical-align: inherit;">Nesse caso, apenas paro não muito longe dos cantos do deslocamento:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/170/d60/9c1/170d609c1b789359490e35741215ba04.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parece-me que esta é uma decisão lógica. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444190/">https://habr.com/ru/post/pt444190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444178/index.html">9 dicas para criar jogos independentes a partir de um único desenvolvedor</a></li>
<li><a href="../pt444182/index.html">Ir condições e suas esquisitices</a></li>
<li><a href="../pt444184/index.html">Sobre as perspectivas de data centers pré-montados</a></li>
<li><a href="../pt444186/index.html">Flutter 1.2. Novidades</a></li>
<li><a href="../pt444188/index.html">CG Pods - fones de ouvido TWS que poderiam</a></li>
<li><a href="../pt444192/index.html">Mitap de gerenciamento de API - IBM, Google, Yandex e Leroy Merlin Experience - Registro disponível</a></li>
<li><a href="../pt444198/index.html">O Dropbox limita a sincronização: agora apenas 3 dispositivos</a></li>
<li><a href="../pt444200/index.html">Sessão de resolução de problemas</a></li>
<li><a href="../pt444204/index.html">Apresentando o teste em Python. Parte 3</a></li>
<li><a href="../pt444206/index.html">27 de março de Moscou - JavaScript MeetUP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>