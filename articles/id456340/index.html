<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖋️ 🤱🏽 👹 Sebuah kisah tentang bagaimana tim freelancer menulis aplikasi JavaScript penuh-tumpukan 👨🏿‍🚒 👈🏼 🚺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa repositori GitHub , tempat ia bekerja dan beberapa freelancer lainnya, mener...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sebuah kisah tentang bagaimana tim freelancer menulis aplikasi JavaScript penuh-tumpukan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/456340/">  Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori GitHub</a> , tempat ia bekerja dan beberapa freelancer lainnya, menerima, karena berbagai alasan, sekitar 8.200 bintang dalam 3 hari.  Repositori ini menempati urutan pertama pada HackerNews dan GitHub Trending, dan 20.000 pengguna Reddit memilihnya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/o9/9m/iu/o99miuqh4mzbstufrnaebmv5cxg.jpeg"></a> <br><br>  Repositori ini mencerminkan metodologi untuk mengembangkan aplikasi tumpukan penuh, yang ditujukan untuk artikel ini. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Latar belakang</font> </h2><br>  Saya akan menulis materi ini untuk beberapa waktu.  Saya percaya bahwa saya tidak dapat menemukan momen yang lebih baik daripada ini ketika repositori kami sangat populer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/194/534/9ce194534d51b90329a9698ba8835d09.png"></div><br>  <i><font color="#999999">No. 1 di Tren GitHub</font></i> <br><br>  Saya bekerja di tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">freelancer</a> .  Proyek kami menggunakan React / React Native, NodeJS, dan GraphQL.  Materi ini ditujukan bagi mereka yang ingin belajar tentang bagaimana kami mengembangkan aplikasi.  Selain itu, ini akan bermanfaat bagi mereka yang akan bergabung dengan tim kami di masa depan. <br><br>  Sekarang saya akan berbicara tentang prinsip-prinsip dasar yang kami gunakan ketika mengembangkan proyek. <br><br><h2>  <font color="#3AC1EF">Lebih sederhana, semakin baik.</font> </h2><br>  "Semakin sederhana semakin baik" lebih mudah diucapkan daripada dilakukan.  Sebagian besar pengembang menyadari bahwa kesederhanaan adalah prinsip penting dalam pengembangan perangkat lunak.  Tetapi prinsip ini tidak selalu mudah diikuti.  Jika kodenya sederhana, ini memfasilitasi dukungan proyek dan menyederhanakan kerja tim pada proyek ini.  Selain itu, kepatuhan terhadap prinsip ini membantu dalam bekerja dengan kode yang ditulis, katakanlah, enam bulan lalu. <br><br>  Berikut adalah kesalahan yang saya temui mengenai prinsip ini: <br><br><ul><li>  Keinginan yang tidak dapat dibenarkan untuk memenuhi prinsip KERING.  Terkadang menyalin dan menempel kode cukup normal.  Tidak perlu abstrak setiap 2 fragmen kode yang agak mirip satu sama lain.  Saya sendiri melakukan kesalahan ini.  Semua, mungkin, melakukan itu.  KERING adalah pendekatan pemrograman yang baik, tetapi memilih abstraksi yang gagal hanya dapat memperburuk situasi dan memperumit basis kode.  Jika Anda ingin tahu lebih banyak tentang ide-ide ini, saya sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Program AHA</a> Kent A Dodds '. </li><li> Penolakan untuk menggunakan alat yang tersedia.  Salah satu contoh kesalahan ini adalah penggunaan <code>reduce</code> alih-alih <code>map</code> atau <code>filter</code> .  Tentu saja, menggunakan <code>reduce</code> dapat mereproduksi perilaku <code>map</code> .  Tetapi ini cenderung mengarah pada peningkatan ukuran kode, dan fakta bahwa akan lebih sulit bagi orang lain untuk memahami kode ini, mengingat bahwa "kesederhanaan kode" adalah konsep subyektif.  Terkadang mungkin perlu menggunakan hanya <code>reduce</code> .  Dan jika Anda membandingkan kecepatan pemrosesan set data menggunakan <code>map</code> dan <code>filter</code> panggilan yang digabungkan dalam rantai, dan menggunakan <code>reduce</code> , ternyata opsi kedua bekerja lebih cepat.  Dalam opsi dengan <code>reduce</code> Anda harus melihat kumpulan nilai satu kali, bukan dua.  Di depan kita ada perdebatan tentang produktivitas dan kesederhanaan.  Dalam kebanyakan kasus, saya lebih suka kesederhanaan dan mencoba untuk menghindari optimasi kode prematur, yaitu, saya akan memilih pasangan <code>map</code> / <code>filter</code> daripada <code>reduce</code> .  Dan jika ternyata pembangunan <code>map</code> dan <code>filter</code> menjadi hambatan sistem, itu akan menerjemahkan kode untuk <code>reduce</code> . </li></ul><br>  Banyak ide yang akan dibahas di bawah ini bertujuan untuk membuat basis kode sesederhana mungkin dan mempertahankannya dalam keadaan ini. <br><br><h2>  <font color="#3AC1EF">Dekatkan entitas serupa satu sama lain</font> </h2><br>  Prinsip ini, “prinsip colocation,” berlaku untuk banyak bagian aplikasi.  Ini adalah struktur folder tempat kode klien dan server disimpan, ini adalah penyimpanan kode proyek dalam satu repositori, ini juga merupakan pengambilan keputusan tentang kode mana yang ada dalam file tertentu. <br><br><h3>  <font color="#3AC1EF">▍ Gudang</font> </h3><br>  Disarankan agar Anda menyimpan kode klien dan server dalam repositori yang sama.  Sederhana saja.  Jangan mempersulit apa yang tidak perlu rumit.  Dengan pendekatan ini, akan lebih mudah untuk mengatur kerja tim yang terkoordinasi pada suatu proyek.  Saya mengerjakan proyek yang menggunakan berbagai repositori untuk menyimpan bahan.  Ini bukan bencana, tetapi repositori tunggal membuat hidup lebih mudah. <br><br><h3>  <font color="#3AC1EF">▍ Struktur proyek bagian klien dari aplikasi</font> </h3><br>  Kami sedang menulis aplikasi full-stack.  Yaitu, kode klien dan kode server.  Struktur folder dari proyek klien tipikal menyediakan direktori terpisah untuk komponen, wadah, tindakan, reduksi dan rute. <br><br>  Tindakan dan reduksi hadir dalam proyek-proyek yang menggunakan Redux.  Saya berusaha keras untuk melakukannya tanpa perpustakaan ini.  Saya yakin ada proyek-proyek berkualitas tinggi yang menggunakan struktur yang sama.  Beberapa proyek saya memiliki folder terpisah untuk komponen dan wadah.  Folder komponen dapat menyimpan sesuatu seperti file dengan kode untuk entitas seperti <code>BlogPost</code> dan <code>Profile</code> .  Di folder penampung ada file yang menyimpan kode penampung <code>BlogPostContainer</code> dan <code>ProfileContainer</code> .  Kontainer menerima data dari server dan meneruskannya ke komponen anak "bodoh", yang tugasnya menampilkan data ini di layar. <br><br>  Ini adalah struktur kerja.  Paling tidak homogen, dan ini sangat penting.  Ini mengarah pada fakta bahwa pengembang, yang bergabung dengan proyek ini, dengan cepat memahami apa yang terjadi di dalamnya, dan peran apa yang dimainkan oleh masing-masing bagian.  Kerugian dari pendekatan ini, karena saya baru-baru ini berusaha untuk tidak menggunakannya, adalah bahwa hal itu memaksa programmer untuk terus bergerak di sekitar basis kode.  Sebagai contoh, <code>BlogPostContainer</code> dan <code>BlogPostContainer</code> tidak memiliki kesamaan, tetapi file mereka bersebelahan dan jauh dari file di mana mereka benar-benar digunakan. <br><br>  Untuk beberapa waktu sekarang, saya telah berusaha untuk menempatkan file yang isinya direncanakan untuk dibagikan dalam folder yang sama.  Pendekatan penataan proyek ini didasarkan pada pengelompokan file berdasarkan kemampuannya.  Berkat pendekatan ini, Anda dapat sangat menyederhanakan hidup Anda jika, misalnya, Anda menempatkan komponen induk dan komponen anaknya yang "bodoh" di folder yang sama. <br><br>  Biasanya kami menggunakan folder <code>routes</code> / <code>screens</code> dan folder <code>components</code> .  Folder komponen biasanya menyimpan kode untuk item seperti <code>Button</code> atau <code>Input</code> .  Kode ini dapat digunakan pada halaman aplikasi mana saja.  Setiap folder dalam folder untuk rute adalah halaman aplikasi terpisah.  Pada saat yang sama, file dengan kode komponen dan kode logika aplikasi yang terkait dengan rute ini berada di folder yang sama.  Dan kode komponen yang digunakan pada beberapa halaman termasuk dalam folder <code>components</code> . <br><br>  Dalam folder rute, Anda dapat membuat folder tambahan tempat kode yang bertanggung jawab untuk pembentukan berbagai bagian halaman dikelompokkan.  Ini masuk akal dalam kasus di mana rute diwakili oleh sejumlah besar kode.  Namun, di sini, saya ingin memperingatkan pembaca bahwa tidak layak membuat struktur dari folder dengan tingkat sarang yang sangat tinggi.  Ini menyulitkan pergerakan proyek.  Struktur folder bersarang yang dalam adalah salah satu tanda proyek yang terlalu rumit.  Perlu dicatat bahwa penggunaan alat khusus, seperti perintah pencarian, memberikan programmer alat yang nyaman untuk bekerja dengan kode proyek dan untuk menemukan apa yang dia butuhkan.  Tetapi struktur file proyek juga mempengaruhi kegunaannya. <br><br>  Dengan menyusun kode proyek, Anda dapat mengelompokkan file berdasarkan bukan pada rute, tetapi pada kemampuan proyek yang diterapkan oleh file-file ini.  Dalam kasus saya, pendekatan ini menunjukkan dirinya dengan sempurna pada proyek satu halaman yang mengimplementasikan banyak fitur pada satu-satunya halaman mereka.  Namun perlu dicatat bahwa pengelompokan material proyek berdasarkan rute lebih mudah.  Pendekatan ini tidak memerlukan upaya mental khusus untuk membuat keputusan tentang entitas mana yang harus ditempatkan bersebelahan, dan untuk mencari sesuatu. <br><br>  Jika kita melanjutkan pengelompokan kode lebih lanjut, kita dapat memutuskan bahwa kode kontainer dan komponen akan ditempatkan di file yang sama.  Dan Anda dapat melangkah lebih jauh - memasukkan kode dua komponen dalam satu file.  Saya kira Anda mungkin berpikir sekarang bahwa merekomendasikan hal-hal seperti itu benar-benar penistaan.  Namun dalam kenyataannya, semuanya jauh dari buruk.  Bahkan, pendekatan ini sepenuhnya dibenarkan.  Dan jika Anda menggunakan React hooks, atau kode yang dihasilkan (atau keduanya), saya akan merekomendasikan pendekatan ini. <br><br>  Faktanya, pertanyaan tentang cara menguraikan kode ke dalam file tidak terlalu penting.  Pertanyaan sebenarnya adalah mengapa Anda mungkin perlu membagi komponen menjadi pintar dan bodoh.  Apa manfaat dari pemisahan ini?  Ada beberapa jawaban untuk pertanyaan ini: <br><br><ol><li>  Aplikasi yang dibangun dengan cara ini lebih mudah untuk diuji. </li><li>  Mengembangkan aplikasi seperti itu membuatnya lebih mudah untuk menggunakan alat-alat seperti Storybook. </li><li>  Komponen bodoh dapat digunakan dengan banyak komponen pintar yang berbeda (dan sebaliknya). </li><li>  Komponen pintar dapat digunakan pada platform yang berbeda (misalnya, pada platform Bereaksi dan Bereaksi Asli). </li></ol><br>  Semua ini adalah argumen nyata yang mendukung pembagian komponen menjadi "pintar" dan "bodoh", tetapi mereka tidak berlaku untuk semua situasi.  Misalnya, kami sering menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Klien Apollo</a> dengan kait saat membuat proyek.  Untuk menguji proyek semacam itu, Anda dapat membuat tiruan Apollo atau kait.  Hal yang sama berlaku untuk Buku Cerita.  Jika kita berbicara tentang mencampur dan berbagi komponen "pintar" dan "bodoh", maka, pada kenyataannya, saya belum pernah bertemu ini dalam praktik.  Mengenai penggunaan lintas-platform dari kode, ada satu proyek di mana saya akan melakukan sesuatu yang serupa, tetapi tidak pernah melakukannya.  Itu seharusnya menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> Lerna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mono</a> .  Saat ini, alih-alih pendekatan ini, Anda dapat memilih untuk React Native Web. <br><br>  Akibatnya, kita dapat mengatakan bahwa dalam pemisahan komponen menjadi "pintar" dan "konyol" ada makna tertentu.  Ini adalah konsep penting yang perlu diketahui.  Namun seringkali, Anda tidak perlu terlalu khawatir tentang hal itu, terutama mengingat penampilan React hooks baru-baru ini. <br><br>  Titik kuat menggabungkan kemampuan komponen "pintar" dan "bodoh" dalam satu entitas adalah mempercepat pengembangan, dan menyederhanakan struktur kode. <br><br>  Selain itu, jika kebutuhan seperti itu muncul, komponen selalu dapat dibagi menjadi dua komponen yang terpisah - "pintar" dan "bodoh". <br><br><h4>  Stilisasi </h4><br>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">emosi</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gaya</a> untuk aplikasi gaya.  Selalu ada godaan untuk memisahkan gaya menjadi file terpisah.  Saya telah melihat beberapa pengembang melakukan ini.  Tetapi, setelah saya mencoba kedua pendekatan tersebut, pada akhirnya saya tidak dapat menemukan alasan untuk memindahkan style ke file yang terpisah.  Seperti dalam banyak hal lain, yang kita bicarakan di sini, seorang pengembang dapat membuat hidupnya lebih mudah dengan menggabungkan gaya dan komponen yang mereka hubungkan dalam satu file. <br><br><h3>  <font color="#3AC1EF">▍ Struktur proyek dari bagian server dari aplikasi</font> </h3><br>  Semua hal di atas benar sehubungan dengan penataan kode sisi server dari aplikasi.  Struktur khas yang saya coba hindari secara pribadi mungkin terlihat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> : <br><br><pre> <code class="plaintext hljs">src │ app.js #     └───api #   Express      └───config #      └───jobs #    agenda.js └───loaders #     └───models #    └───services # - └───subscribers #      └───types #    (d.ts)  Typescript</code> </pre> <br>  Kami biasanya menggunakan GraphQL di proyek kami.  Oleh karena itu, mereka menggunakan file yang menyimpan model, layanan, dan pengenal.  Alih-alih menyebarkannya di berbagai tempat proyek, saya mengumpulkannya dalam satu folder.  Paling sering, file-file ini akan dibagikan, dan akan lebih mudah untuk bekerja dengannya jika disimpan di folder yang sama. <br><br><h2>  <font color="#3AC1EF">Jangan menimpa definisi tipe berkali-kali</font> </h2><br>  Kami menggunakan banyak solusi dalam proyek kami yang entah bagaimana terkait dengan tipe data.  Ini adalah TypeScript, GraphQL, skema basis data, dan kadang-kadang MobX.  Sebagai hasilnya, mungkin ternyata tipe untuk entitas yang sama dijelaskan 3-4 kali.  Hal-hal seperti ini harus dihindari.  Kita harus berusaha menggunakan alat yang secara otomatis menghasilkan deskripsi tipe. <br><br>  Di server, kombinasi TypeORM / Typegoose dan TypeGraphQL dapat digunakan untuk tujuan ini.  Ini cukup untuk menggambarkan semua tipe yang digunakan.  TypeORM / Typegoose memungkinkan Anda untuk menggambarkan skema basis data dan tipe-tipe TypeScript yang sesuai.  TypeGraphQL akan membantu dalam menciptakan jenis-jenis GraphQL dan TypeScript. <br><br>  Berikut adalah contoh menentukan jenis TypeORM (MongoDB) dan TypeGraphQL dalam satu file: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field, ObjectType, ID } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'type-graphql'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Entity, ObjectIdColumn, ObjectID, Column, CreateDateColumn, UpdateDateColumn, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span> @ObjectType() @Entity() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Policy</span></span></span><span class="hljs-class"> </span></span>{ @Field(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> ID) @ObjectIdColumn() _id: ObjectID @Field() @CreateDateColumn({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'timestamp'</span></span> }) createdAt: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> @Field({ <span class="hljs-attr"><span class="hljs-attr">nullable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) @UpdateDateColumn({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'timestamp'</span></span>, <span class="hljs-attr"><span class="hljs-attr">nullable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) updatedAt?: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> @Field() @Column() name: string @Field() @Column() version: number }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GraphQL Code Generator</a> juga dapat menghasilkan berbagai jenis.  Kami menggunakan alat ini untuk membuat jenis TypeScript pada klien, serta Bereaksi kait yang mengakses server. <br><br>  Jika Anda menggunakan MobX untuk mengontrol keadaan aplikasi, kemudian menggunakan beberapa baris kode, Anda bisa mendapatkan tipe TS yang dihasilkan secara otomatis.  Jika Anda juga menggunakan GraphQL, maka Anda harus melihat pada paket baru - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MST-GQL</a> , yang menghasilkan pohon negara dari skema GQL. <br><br>  Menggunakan alat-alat ini bersama-sama akan menyelamatkan Anda dari penulisan ulang sejumlah besar kode dan membantu Anda menghindari kesalahan umum. <br><br>  Solusi lain, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prisma</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hasura,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS AppSync</a> , juga dapat membantu menghindari deklarasi tipe duplikat.  Penggunaan alat-alat semacam itu, tentu saja memiliki pro dan kontra.  Dalam proyek-proyek yang kami buat, alat-alat seperti itu tidak selalu digunakan, karena kami perlu menggunakan kode di server organisasi kami sendiri. <br><br><h2>  <font color="#3AC1EF">Kapan pun memungkinkan, gunakan cara pembuatan kode otomatis</font> </h2><br>  Jika Anda melihat kode yang Anda buat tanpa menggunakan alat di atas untuk secara otomatis menghasilkan kode, ternyata pemrogram harus terus-menerus menulis hal yang sama.  Saran utama yang dapat saya berikan tentang ini adalah Anda perlu membuat cuplikan untuk semua yang sering Anda gunakan.  Jika Anda sering memasukkan perintah <code>console.log</code> , buat snippet like <code>cl</code> , yang secara otomatis berubah menjadi <code>console.log()</code> .  Jika Anda tidak melakukan ini dan meminta saya untuk membantu Anda dengan debugging kode, itu akan membuat saya sangat sedih. <br><br>  Ada banyak paket dengan snippet, tetapi mudah untuk membuat snippet Anda sendiri.  Misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generator Snippet</a> . <br><br>  Berikut adalah kode yang memungkinkan saya untuk menambahkan beberapa cuplikan favorit saya ke Kode VS: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"Export default"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"scope"</span></span>: <span class="hljs-string"><span class="hljs-string">"javascript,typescript,javascriptreact,typescriptreact"</span></span>,   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"eid"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [     <span class="hljs-string"><span class="hljs-string">"export { default } from './${TM_DIRECTORY/.*[\\/](.*)$$/$1/}'"</span></span>,     <span class="hljs-string"><span class="hljs-string">"$2"</span></span>   ],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import and export default in a single line"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Filename"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"fn"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"${TM_FILENAME_BASE}"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Print filename"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Import emotion styled"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"imes"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"import styled from '@emotion/styled'"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion js as styled"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Import emotion css only"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"imec"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"import { css } from '@emotion/styled'"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion css only"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Import emotion styled and css only"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"imesc"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"import styled, { css } from ''@emotion/styled'"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion js and css"</span></span> }, <span class="hljs-string"><span class="hljs-string">"Styled component"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"sc"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [<span class="hljs-string"><span class="hljs-string">"const ${1} = styled.${2}`"</span></span>, <span class="hljs-string"><span class="hljs-string">"  ${3}"</span></span>, <span class="hljs-string"><span class="hljs-string">"`"</span></span>],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Import Emotion js and css"</span></span> }, <span class="hljs-string"><span class="hljs-string">"TypeScript React Function Component"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"prefix"</span></span>: <span class="hljs-string"><span class="hljs-string">"rfc"</span></span>,   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: [     <span class="hljs-string"><span class="hljs-string">"import React from 'react'"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>,     <span class="hljs-string"><span class="hljs-string">"interface ${1:ComponentName}Props {"</span></span>,     <span class="hljs-string"><span class="hljs-string">"}"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>,     <span class="hljs-string"><span class="hljs-string">"const ${1:ComponentName}: React.FC&lt;${1:ComponentName}Props&gt; = props =&gt; {"</span></span>,     <span class="hljs-string"><span class="hljs-string">" return ("</span></span>,     <span class="hljs-string"><span class="hljs-string">" &lt;div&gt;"</span></span>,     <span class="hljs-string"><span class="hljs-string">" ${1:ComponentName}"</span></span>,     <span class="hljs-string"><span class="hljs-string">" &lt;/div&gt;"</span></span>,     <span class="hljs-string"><span class="hljs-string">" )"</span></span>,     <span class="hljs-string"><span class="hljs-string">"}"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>,     <span class="hljs-string"><span class="hljs-string">"export default ${1:ComponentName}"</span></span>,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ],   <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"TypeScript React Function Component"</span></span> } }</code> </pre> <br>  Selain potongan, generator kode dapat membantu menghemat waktu.  Anda dapat membuatnya sendiri.  Saya suka menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">celepuk</a> untuk ini. <br><br>  Angular memiliki generator kode bawaannya sendiri.  Menggunakan alat-alat baris perintah, Anda dapat membuat komponen baru, yang terdiri dari 4 file, yang menyajikan segala sesuatu yang dapat Anda harapkan untuk ditemukan di komponen.  Sangat disayangkan React tidak memiliki fitur standar seperti itu, tetapi sesuatu yang serupa dapat dibuat secara independen menggunakan plop.  Jika setiap komponen baru yang Anda buat harus disajikan dalam bentuk folder yang berisi file dengan kode komponen, file tes dan file Storybook, generator akan membantu untuk membuat semua ini dengan satu perintah.  Ini dalam banyak kasus sangat memudahkan kehidupan pengembang.  Misalnya, saat menambahkan fitur baru ke server, jalankan saja satu perintah di baris perintah.  Setelah itu, file entitas, layanan, dan pengenal akan secara otomatis dibuat berisi semua struktur dasar yang diperlukan. <br><br>  Kekuatan lain dari pembuat kode adalah mereka berkontribusi pada keseragaman dalam pengembangan tim.  Jika semua orang menggunakan generator plop yang sama, maka kodenya akan sangat seragam untuk semua orang. <br><br><h2>  <font color="#3AC1EF">Pemformatan kode otomatis</font> </h2><br>  Memformat kode adalah tugas yang sederhana, tetapi, sayangnya, itu tidak selalu diselesaikan dengan benar.  Jangan buang waktu untuk menyelaraskan kode secara manual atau memasukkan titik koma ke dalamnya.  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prettier</a> untuk memformat kode secara otomatis saat melakukan. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Dalam artikel ini saya memberi tahu Anda tentang beberapa hal yang kami pelajari selama bertahun-tahun bekerja, selama bertahun-tahun coba-coba.  Ada banyak pendekatan untuk menyusun basis kode proyek.  Namun di antara mereka tidak ada yang bisa disebut satu-satunya yang benar. <br><br>  Hal paling penting yang ingin saya sampaikan kepada Anda adalah bahwa programmer harus berusaha untuk kesederhanaan dalam mengatur proyek, untuk homogenitas mereka, untuk menggunakan struktur yang mudah dimengerti yang mudah digunakan.  Ini menyederhanakan proyek pengembangan tim. <br><br>  <b>Pembaca yang budiman!</b>  Apa pendapat Anda tentang ide-ide untuk mengembangkan aplikasi JavaScript tumpukan penuh yang diuraikan dalam artikel ini? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456340/">https://habr.com/ru/post/id456340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456320/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 369 (10 - 16 Juni 2019)</a></li>
<li><a href="../id456322/index.html">Cara memanfaatkan konferensi secara maksimal. Instruksi untuk yang terkecil</a></li>
<li><a href="../id456332/index.html">PHP Digest No. 158 (3-17 Juni, 2019)</a></li>
<li><a href="../id456336/index.html">11 tips untuk menggunakan Redux saat mengembangkan Bereaksi aplikasi</a></li>
<li><a href="../id456338/index.html">13 single-liners JavaScript yang bermanfaat</a></li>
<li><a href="../id456342/index.html">Satu bahasa untuk menguasai semua</a></li>
<li><a href="../id456344/index.html">Mengapa ['1', '7', '11']. Peta (parseInt) mengembalikan [1, NaN, 3] dalam Javascript?</a></li>
<li><a href="../id456348/index.html">AERODISK Engine: Catastrophic. Bagian 1</a></li>
<li><a href="../id456350/index.html">Acara digital di Moskow dari 17-23 Juni</a></li>
<li><a href="../id456352/index.html">Modul komunikasi objek nirkabel WISE-4000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>