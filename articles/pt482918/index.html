<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¢ ü•ï ü§üüèº Salvando Dados em uma EEPROM em um Arduino Transacionalmente üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üñ®Ô∏è üë®üèæ‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A presen√ßa de uma EEPROM oferece aos desenvolvedores uma ferramenta conveniente para salvar par√¢metros de configura√ß√£o ou um estado de mudan√ßa lenta e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Salvando Dados em uma EEPROM em um Arduino Transacionalmente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482918/">  A presen√ßa de uma EEPROM oferece aos desenvolvedores uma ferramenta conveniente para salvar par√¢metros de configura√ß√£o ou um estado de mudan√ßa lenta em que uma queda de energia deve sobreviver.  Neste artigo, veremos como fazer isso da maneira mais segura e conveniente poss√≠vel, para n√£o esquecer nada e n√£o lembrar o que n√£o estava l√°. <br><a name="habracut"></a><br>  Suponha que temos uma vari√°vel e queremos armazen√°-la em uma EEPROM.  Parece que todas as ferramentas para isso est√£o em nossas m√£os: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;EEPROM.h&gt; int my_var = DEFAULT_VALUE; EEPROM.get(MY_VAR_ADDR, my_var); my_var = NEW_VALUE; EEPROM.put(MY_VAR_ADDR, my_var);</span></span></span></span></code> </pre> <br>  No entanto, uma an√°lise mais detalhada revela que essa abordagem cria mais problemas do que resolve.  Vamos discuti-los em ordem. <br><br>  1. Como garantir que lemos exatamente o que escrevemos (para garantir a <b>integridade</b> )?  Imagine a seguinte imagem.  Escrevemos uma carta para n√≥s mesmos em caso de morte s√∫bita por perda de energia ou um sinal de redefini√ß√£o e a colocamos em uma gaveta da mesa.  Na pr√≥xima vida, abrimos a gaveta da mesa, pegamos um peda√ßo de papel, lemos a mensagem e continuamos nossa miss√£o.  O problema √© que na caixa sempre h√° folhas de papel rabiscadas com texto aleat√≥rio.  Ent√£o, precisamos de uma maneira de distinguir a mensagem correta da aleat√≥ria.  Pode-se garantir a ele um not√°rio p√∫blico, mas, no caso mais simples, sua assinatura seria suficiente se tiv√©ssemos uma maneira de verificar sua corre√ß√£o.  Por exemplo, podemos usar o resultado de uma express√£o matem√°tica dependendo do texto como uma assinatura, para que a probabilidade de coincid√™ncia aleat√≥ria seja suficientemente pequena.  No caso mais simples, esse √© um CRC ou soma de verifica√ß√£o.  Isso nos proteger√° n√£o apenas da leitura do que n√£o escrevemos, mas tamb√©m da leitura de uma mensagem danificada.  Afinal, o texto desaparece com o tempo e os el√©trons no obturador isolado s√£o ainda menos dur√°veis ‚Äã‚Äã- uma part√≠cula voa do espa√ßo com energia suficiente e o bit muda.  Mas h√° outra maneira de obter uma mensagem danificada - n√£o √© para adicion√°-la ao final.  N√£o √© t√£o ex√≥tico, porque no momento da grava√ß√£o, o consumo atual aumenta acentuadamente, o que pode provocar a morte prematura do escritor. <br><br>  2. Suponha que estiv√©ssemos convencidos da exatid√£o da mensagem, mas como posso ter certeza de que fui eu quem a escreveu (para garantir a <b>autenticidade</b> ).  Como diz o ditado, sou diferente.  De repente, algu√©m estava sentado nessa mesa antes da minha reencarna√ß√£o, e ele teve uma miss√£o diferente, e por que raz√£o agora serei guiado por suas mensagens?  Se fornec√™ssemos nossas anota√ß√µes com um certo r√≥tulo, seria mais f√°cil distinguir as nossas de estranhos.  Por exemplo, esse r√≥tulo pode ser o nome da vari√°vel que estamos salvando.  O √∫nico problema √© que na EEPROM n√£o h√° muito espa√ßo para colocar nomes de vari√°veis ‚Äã‚Äãe √© inconveniente faz√™-lo, porque eles t√™m comprimentos diferentes.  Felizmente, por√©m, existe uma maneira mais simples: voc√™ pode calcular a soma de verifica√ß√£o em nome da vari√°vel e us√°-la como um atalho.  Ao mesmo tempo, √© √∫til adicionar o tamanho da vari√°vel em bytes a essa soma de verifica√ß√£o para n√£o ler acidentalmente a quantidade errada.  Bem, por uma quest√£o de completude, adicionamos outro identificador num√©rico para garantir a distin√ß√£o de nossa vari√°vel de outra pessoa, mesmo que sejam chamadas da mesma.  Chamamos esse n√∫mero de identificador de inst√¢ncia (inspirado no OOP se o nome da vari√°vel for considerado como um campo de objeto).  Se alguma vez atualizarmos nossa miss√£o para uma vers√£o radicalmente nova, para que esta atualiza√ß√£o fa√ßa sentido tudo o que a antiga salvou, basta alterar o identificador da inst√¢ncia para invalidar tudo o que foi salvo pela vers√£o antiga. <br><br>  3. Como fa√ßo para que uma opera√ß√£o de grava√ß√£o incompleta deixe o antigo valor armazenado inalterado?  Ou seja, a opera√ß√£o de salvamento deve ter √™xito ou n√£o deve ter nenhum efeito observ√°vel.  Em outras palavras, deve ser <b>at√¥mico</b> ou transacional se estamos falando de uma transa√ß√£o que se resume a uma atualiza√ß√£o incondicional de um √∫nico valor.  Obviamente, n√£o podemos garantir a atomicidade do registro reescrevendo o valor anterior; precisamos gravar em um novo local para que o antigo valor armazenado permane√ßa intacto, pelo menos at√© a conclus√£o da grava√ß√£o do novo.  Essa t√©cnica costuma ser chamada de 'copiar na grava√ß√£o' se apenas parte do valor salvo for atualizada, mas a parte que permanece inalterada ainda √© copiada e gravada em um novo local.  Desenvolvendo nossa analogia, escreveremos cartas para n√≥s mesmos, deixando as antigas intocadas, mas fornecendo a cada letra um n√∫mero de s√©rie crescente para que, em nossa pr√≥xima vida, tenhamos a oportunidade de encontrar a √∫ltima carta que escrevemos.  Ao mesmo tempo, por√©m, surge um novo problema - o local na caixa em que colocamos as cartas terminar√° mais cedo ou mais tarde se n√£o jogarmos fora as cartas antigas que se tornaram irrelevantes.  √â f√°cil entender que basta armazenar apenas duas letras - uma antiga e outra nova, pode estar em processo de escrita.  Consequentemente, o n√∫mero da letra tamb√©m n√£o precisa de muitos bits. <br><br>  Curiosamente, o autor n√£o conseguiu encontrar uma √∫nica implementa√ß√£o que permitisse a organiza√ß√£o do armazenamento de dados na EEPROM, garantindo integridade, autenticidade e atomicidade.  Eu tive que escrever no <a href="https://github.com/olegv142/NvTx" rel="nofollow">github.com/olegv142/NvTx</a> <br><br>  Para salvar cada vari√°vel na EEPROM, s√£o usadas 2 √°reas consecutivas - c√©lulas com a mesma estrutura.  O identificador da vari√°vel calculada com base em seu tamanho, r√≥tulo de texto e identificador de inst√¢ncia √© gravado nos 2 primeiros bytes.  Em seguida, os dados s√£o gravados, seguidos por 2 bytes da soma de verifica√ß√£o.  No primeiro byte, dois bits t√™m um prop√≥sito especial.  O bit mais significativo √© o sinalizador de corre√ß√£o; ao escrever, √© sempre definido como um.  O bit de ordem baixa √© usado como um n√∫mero de bit √∫nico da √©poca; √© necess√°rio encontrar a √∫ltima mensagem.  A grava√ß√£o √© feita nas c√©lulas 'em um c√≠rculo'.  O n√∫mero da √©poca muda cada vez que um registro √© feito na primeira c√©lula.  Da√≠ o algoritmo para determinar a √∫ltima c√©lula registrada: se as √©pocas das c√©lulas s√£o as mesmas, ent√£o a segunda √© escrita por √∫ltimo, se diferente - ent√£o a primeira. <br><br>  O bit de corre√ß√£o parece redundante, mas tem uma fun√ß√£o importante.  Antes de tudo, lemos os dados armazenados e verificamos a corre√ß√£o de ambas as c√©lulas.  Se a c√©lula n√£o passar na verifica√ß√£o do identificador ou soma de verifica√ß√£o correta, redefiniremos o bit de corre√ß√£o.  As opera√ß√µes de grava√ß√£o subseq√ºentes podem n√£o verificar a corre√ß√£o das c√©lulas, mas dependem desse sinalizador, o que reduz a sobrecarga em cerca de 2 vezes. <br><br>  Quem quiser se aprofundar nos detalhes da implementa√ß√£o pode ver as imagens e o c√≥digo no <a href="https://github.com/olegv142/NvTx" rel="nofollow">reposit√≥rio</a> .  Eu, para n√£o aborrecer o leitor, passo a us√°-lo.  Cada uma das fun√ß√µes de grava√ß√£o / leitura de dados recebe 5 par√¢metros; portanto, a conveni√™ncia de seu uso √© sacrificada em favor da flexibilidade.  Mas √© generosamente compensado por dois conjuntos de macros, que tornam o uso da biblioteca t√£o simples quanto no caso da EEPROM.get / put.  O primeiro conjunto de macros √© usado se voc√™ deseja salvar a vari√°vel no endere√ßo fornecido: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; bool have_my_var = NvTxGetAt(my_var, MY_VAR_ADDR); my_var = NEW_VALUE; NvTxPutAt(my_var, MY_VAR_ADDR);</span></span></span></span></code> </pre><br>  Se houver v√°rias vari√°veis ‚Äã‚Äãa serem salvas, cada uma ter√° que determinar o endere√ßo e, ao mesmo tempo, considerar corretamente o tamanho para que as √°reas de mem√≥ria em que as vari√°veis ‚Äã‚Äãest√£o armazenadas n√£o se sobreponham.  Para simplificar a tarefa, o segundo conjunto de macros implementa a aloca√ß√£o autom√°tica de endere√ßo e faz isso <b>em tempo de compila√ß√£o</b> .  Por exemplo, a <a href="https://github.com/thijse/Arduino-EEPROMEx" rel="nofollow">biblioteca Arduino-EEPROMEx</a> pode alocar mem√≥ria em tempo de execu√ß√£o, enquanto armazena o endere√ßo na RAM para cada vari√°vel armazenada.  A biblioteca <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> aloca espa√ßo na EEPROM sem adicionar nada ao c√≥digo execut√°vel ou ao conte√∫do da RAM. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; char my_string[16] = ""; NvPlace(my_var, MY_START_ADDR, MY_INST_ID); NvAfter(my_string, my_var); bool have_my_var = NvTxGet(my_var); my_var = NEW_VALUE; NvTxPut(my_var);</span></span></span></span></code> </pre><br>  A macro NvPlace define o endere√ßo inicial da √°rea EEPROM, onde armazenaremos as vari√°veis ‚Äã‚Äãe o identificador da inst√¢ncia.  A macro NvAfter reserva uma regi√£o da mem√≥ria para armazenar seu primeiro argumento imediatamente ap√≥s a regi√£o da mem√≥ria reservada para o segundo.  Ao alocar mem√≥ria, tamb√©m √© verificado que n√£o excedemos o tamanho da EEPROM dispon√≠vel e tamb√©m n√£o reservamos √°reas de mem√≥ria sobrepostas (isso pode acontecer se duas macros do NvAfter tiverem o mesmo segundo argumento).  Em caso de viola√ß√£o de qualquer uma das duas condi√ß√µes especificadas, o programa simplesmente n√£o √© compilado.  Aqueles que desejam lidar com o mecanismo de aloca√ß√£o de mem√≥ria o encontrar√£o no arquivo de cabe√ßalho <a href="" rel="nofollow">NvTx.h.</a>  Todas as macros NvPlace e NvAfter fazem √© definir as enumera√ß√µes, formando seus nomes com base nos nomes das vari√°veis ‚Äã‚Äãe tamb√©m usar a constru√ß√£o idiom√°tica muito √∫til da declara√ß√£o do <a href="" rel="nofollow">tempo de compila√ß√£o</a> . <br><br>  Esperamos que a biblioteca <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> ajude os leitores a escrever um c√≥digo confi√°vel e de n√≠vel industrial. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482918/">https://habr.com/ru/post/pt482918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482902/index.html">N√£o, a intelig√™ncia artificial n√£o pode nos derrotar</a></li>
<li><a href="../pt482904/index.html">Uma Breve Hist√≥ria dos Microprocessadores Espaciais, Parte Um</a></li>
<li><a href="../pt482906/index.html">Sobre seguran√ßa de rede</a></li>
<li><a href="../pt482908/index.html">A segunda parte da tradu√ß√£o do livro de David Kouchner, Masters of Doom. Cap√≠tulos 6-12</a></li>
<li><a href="../pt482912/index.html">A ideia de uma rede social descentralizada de pr√≥xima gera√ß√£o</a></li>
<li><a href="../pt482920/index.html">Como o piloto autom√°tico entrou em nossas vidas, mas n√£o percebemos</a></li>
<li><a href="../pt482922/index.html">Drupal Digest - 2019 / Dezembro</a></li>
<li><a href="../pt482926/index.html">O Arc √© um sistema de controle de vers√£o para um monoreposit√≥rio. Relat√≥rio Yandex</a></li>
<li><a href="../pt482928/index.html">Vis√£o Predadora: Efeito de Vis√£o T√©rmica</a></li>
<li><a href="../pt482930/index.html">Pesquisa geneal√≥gica - livros m√©tricos, censos, arquivos, bancos de dados abertos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>