<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß‚Äçüë¶ üë©‚Äç‚öñÔ∏è ü•ù C n√£o √© um idioma de baixo n√≠vel üëÜüèΩ „Ä∞Ô∏è üë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seu computador n√£o √© uma vers√£o r√°pida do PDP-11 
 Ol√° Habr! 

 Meu nome √© Anton Dovgal, sou desenvolvedor C (e n√£o apenas) no Badoo. 

 Me deparei co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C n√£o √© um idioma de baixo n√≠vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/420407/"><img src="https://habrastorage.org/webt/8n/tg/og/8ntgogmuur_qld0ho0701jc83du.jpeg"><br><br><h3>  <i>Seu computador n√£o √© uma vers√£o r√°pida do PDP-11</i> </h3><br>  Ol√° Habr! <br><br>  Meu nome √© Anton Dovgal, sou desenvolvedor C (e n√£o apenas) no Badoo. <br><br>  Me deparei com um artigo de David Chiznell, pesquisador da Universidade de Cambridge, no qual ele contesta a opini√£o geralmente aceita de que C √© uma linguagem de baixo n√≠vel, e seus argumentos pareciam interessantes o suficiente para mim. <br><br>  √Ä luz das vulnerabilidades descobertas recentemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meltdown e Spectre</a> devem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reservar</a> um tempo para descobrir os motivos de sua ocorr√™ncia.  Essas duas vulnerabilidades exploraram a execu√ß√£o especulativa de instru√ß√µes pelos processadores e permitiram que um invasor recebesse resultados por meio de canais de terceiros.  Foram adicionadas vulnerabilidades nos recursos do processador, juntamente com alguns outros, para que os programadores de C continuassem acreditando que programavam em uma linguagem de baixo n√≠vel, embora isso n√£o ocorra h√° d√©cadas. <br><br>  Os fabricantes de processadores n√£o est√£o sozinhos nisso.  Os desenvolvedores do compilador C / C ++ tamb√©m contribu√≠ram. <br><a name="habracut"></a><br><h2>  O que √© um idioma de baixo n√≠vel? </h2><br>  O cientista da computa√ß√£o americano e o primeiro vencedor do Pr√™mio Turing Alan Perlis deram a seguinte defini√ß√£o: <br><blockquote>  "Uma linguagem de programa√ß√£o √© de baixo n√≠vel se os programas escritos nela exigirem aten√ß√£o ao n√£o essencial". </blockquote><br>  Embora essa defini√ß√£o se refira a C, ela n√£o fornece uma compreens√£o do que as pessoas querem ver em um idioma de baixo n√≠vel.  V√°rias propriedades fazem as pessoas considerarem o idioma baixo.  Imagine uma escala de linguagens de programa√ß√£o com assembler em uma extremidade e uma interface para um computador Enterprise na outra.  Os idiomas de baixo n√≠vel est√£o mais pr√≥ximos do ferro, enquanto os idiomas de n√≠vel superior est√£o mais pr√≥ximos de como as pessoas pensam. <br><br>  Para estar ‚Äúmais pr√≥ximo do hardware‚Äù, o idioma deve fornecer abstra√ß√µes que correspondam √†s abstra√ß√µes da plataforma de destino.  √â f√°cil provar que C era uma linguagem de baixo n√≠vel no PDP-11.  A execu√ß√£o seq√ºencial de programas, um espa√ßo de endere√ßo plano, at√© mesmo operadores de pr√© e p√≥s-incremento, caiu perfeitamente nos modos de endere√ßamento do PDP-11. <br><br><h2>  Emuladores r√°pidos PDP-11 </h2><br>  O principal motivo para as vulnerabilidades Spectre e Meltdown √© que os criadores dos processadores n√£o fizeram apenas processadores r√°pidos, eles fizeram processadores r√°pidos com a interface PDP-11.  Isso √© importante porque permite que os programadores de C continuem acreditando que sua linguagem est√° pr√≥xima do hardware. <br><br>  O c√≥digo C fornece um aut√¥mato abstrato principalmente seq√ºencial (at√© C11, √© completamente seq√ºencial, se extens√µes n√£o padronizadas forem exclu√≠das).  Criar um novo encadeamento √© uma chamada para uma fun√ß√£o de biblioteca, uma opera√ß√£o bastante cara.  Portanto, os processadores, desejando continuar executando o c√≥digo C, contam com o paralelismo em n√≠vel de instru√ß√£o (ILP).  Eles analisam opera√ß√µes vizinhas e executam opera√ß√µes independentes em paralelo.  Isso complica muito os processadores e leva ao aumento do consumo de energia, mas permite que os programadores escrevam principalmente c√≥digos sequenciais.  Por outro lado, os processadores gr√°ficos (GPUs) alcan√ßam alto desempenho de outra maneira: eles exigem a grava√ß√£o de programas paralelos. <br><br>  Alta simultaneidade no n√≠vel do comando √© a causa direta do Spectre e do Meltdown.  O processador Intel moderno executa at√© 180 instru√ß√µes simultaneamente (ao contr√°rio da m√°quina abstrata C seq√ºencial, que espera que a instru√ß√£o anterior seja executada antes do in√≠cio da pr√≥xima).  Uma heur√≠stica t√≠pica do c√≥digo C mostra que h√° uma ramifica√ß√£o em m√©dia para cada sete instru√ß√µes.  Se voc√™ quiser manter o pipeline de instru√ß√µes completo, precisar√° adivinhar as pr√≥ximas 25 ramifica√ß√µes.  Isso, por sua vez, aumenta a complexidade - o processador primeiro calcula a ramifica√ß√£o adivinhada incorretamente e depois lan√ßa os resultados dos c√°lculos, que afetam negativamente o consumo de energia.  Esses dados lan√ßados t√™m resultados indiretos vis√≠veis, que foram usados ‚Äã‚Äãnos ataques Spectre e Meltdown. <br><br>  Renomear registros consome muita energia e √°rea de chip nos processadores modernos.  Ele n√£o pode ser desligado ou seu consumo de energia reduzido, o que a torna inconveniente na era do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sil√≠cio escuro</a> , quando os transistores s√£o baixos, mas os transistores envolvidos s√£o um recurso valioso.  Este dispositivo est√° ausente na GPU, onde a simultaneidade √© alcan√ßada usando threads em vez de tentar executar paralelamente o c√≥digo seq√ºencial inicialmente.  Se as instru√ß√µes n√£o tiverem depend√™ncias que precisam ser reconstru√≠das, tamb√©m n√£o ser√° necess√°rio renomear os registros. <br><br>  Considere outra parte fundamental do design de C: mem√≥ria plana.  N√£o existe h√° algumas d√©cadas.  Um processador moderno geralmente possui tr√™s n√≠veis de cache entre os registradores e a mem√≥ria principal, reduzindo assim o tempo necess√°rio para acessar o √∫ltimo. <br><br>  O cache est√° oculto do programador e, portanto, inacess√≠vel a C. O uso efetivo do cache √© uma das maneiras de acelerar a execu√ß√£o de c√≥digo em um processador moderno, no entanto, est√° completamente oculto da m√°quina abstrata e os programadores s√£o for√ßados a confiar no conhecimento dos detalhes da implementa√ß√£o do cache (por exemplo, que dois alinhados de 64 bits valores podem aparecer em uma linha do cache) para escrever c√≥digo eficiente. <br><br><h2>  Otimiza√ß√£o C </h2><br>  Uma das caracter√≠sticas comuns atribu√≠das a idiomas de baixo n√≠vel √© a velocidade.  Em particular, eles devem ser f√°ceis de traduzir em c√≥digo r√°pido sem um compilador complicado.  O argumento de que um compilador inteligente o suficiente pode acelerar um idioma √© frequentemente ignorado pelos proponentes do C quando falam sobre outros idiomas. <br><br>  Infelizmente, usando uma tradu√ß√£o simples, voc√™ n√£o pode obter c√≥digo r√°pido de C. <br>  Os arquitetos de processadores fazem esfor√ßos her√≥icos para criar chips que podem executar o c√≥digo C rapidamente.  Mas os n√≠veis de desempenho que os programadores esperam ver s√£o alcan√ßados apenas com a ajuda de otimiza√ß√µes incrivelmente complexas executadas pelo compilador. <br>  O compilador Clang (incluindo as partes correspondentes do LLVM) possui cerca de 2 milh√µes de linhas de c√≥digo.  Para a an√°lise e transforma√ß√£o do c√≥digo, necess√°rias para acelerar o C, s√£o necess√°rias cerca de 200.000 linhas de c√≥digo (excluindo coment√°rios e linhas em branco). <br><br>  Por exemplo, para processar uma grande quantidade de dados em C, voc√™ precisa escrever um loop que processa cada elemento sequencialmente.  Para a execu√ß√£o ideal desse ciclo em um processador moderno, o compilador deve determinar que as itera√ß√µes do ciclo s√£o independentes uma da outra.  A palavra-chave restringir pode ajudar nesse caso - garante que as grava√ß√µes em um ponteiro n√£o interfiram na leitura de outro ponteiro.  Essas informa√ß√µes em C s√£o muito mais limitadas do que em um idioma como o Fortran, que √© o principal motivo pelo qual o C n√£o conseguiu tir√°-las da computa√ß√£o de alto desempenho. <br><br>  Depois que o compilador determinar que as itera√ß√µes s√£o independentes uma da outra, a pr√≥xima etapa √© uma tentativa de vetorizar o resultado, porque a taxa de transfer√™ncia dos processadores modernos √© quatro a oito vezes maior no c√≥digo vetorizado do que no c√≥digo escalar.  Uma linguagem de baixo n√≠vel para esses processadores teria seus pr√≥prios tipos de vetores de comprimento arbitr√°rio.  Esses tipos est√£o presentes na representa√ß√£o intermedi√°ria do LLVM, porque √© sempre mais f√°cil dividir opera√ß√µes grandes com vetores em v√°rias pequenas do que construir opera√ß√µes vetoriais maiores. <br><br>  Nesse ponto, os otimizadores precisam lidar com as regras de mem√≥ria C. O C assegura que estruturas com o mesmo prefixo possam ser usadas de forma intercambi√°vel e fornece acesso a campos de estruturas de deslocamento no idioma.  Isso significa que o compilador n√£o pode alterar a ordem dos campos na estrutura ou adicionar alinhamento para melhorar a vetoriza√ß√£o (por exemplo, transformar uma estrutura de matrizes em uma matriz de estruturas ou vice-versa).  Isso geralmente n√£o √© um problema em linguagens de baixo n√≠vel, onde √© poss√≠vel controlar a localiza√ß√£o dos campos na estrutura, mas dificulta a tarefa de acelerar o C. <br><br>  C tamb√©m requer alinhamento no final da estrutura, pois garante que o alinhamento n√£o esteja nas matrizes.  O alinhamento √© uma parte bastante complexa da especifica√ß√£o C, que interage mal com outras partes da linguagem.  Por exemplo, voc√™ deve poder comparar duas estruturas usando o m√©todo de compara√ß√£o sem tipo (ou seja, a fun√ß√£o memcmp ()), para que a c√≥pia da estrutura tamb√©m seja alinhada.  Em alguns casos, copiar o alinhamento leva um tempo consider√°vel. <br><br>  Considere as duas otimiza√ß√µes b√°sicas que o compilador C produz: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SROA</a> (substitui√ß√£o escalar de agregados, substitui√ß√£o escalar de agregados) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abertura de loop</a> . <br><br>  O SROA est√° tentando substituir estruturas e matrizes de tamanho fixo por vari√°veis ‚Äã‚Äãseparadas.  Isso permite que o compilador processe o acesso a eles independentemente um do outro e ignore a opera√ß√£o, se for √≥bvio que seu resultado n√£o √© usado.  Em alguns casos, o efeito indireto dessa otimiza√ß√£o √© remover o alinhamento. <br><br>  A segunda otimiza√ß√£o, abrindo o loop, converte o loop com a condi√ß√£o em uma condi√ß√£o com diferentes loops nos dois ramos.  Isso altera a ordem de execu√ß√£o, em oposi√ß√£o √† afirma√ß√£o de que o programador sabe o que ser√° executado em uma linguagem de baixo n√≠vel.  E isso tamb√©m cria s√©rios problemas com a forma como C lida com vari√°veis ‚Äã‚Äãindefinidas e comportamento indefinido. <br><br>  Em C, uma vari√°vel n√£o inicializada possui um valor indefinido, que pode ser diferente a cada chamada.  Isso √© importante porque permite implementar uma reciclagem lenta de p√°ginas de mem√≥ria.  Por exemplo, no FreeBSD, a implementa√ß√£o malloc () informa ao sistema que as p√°ginas n√£o est√£o mais em uso, e o sistema usa a primeira entrada na p√°gina como prova de que esse n√£o √© o caso.  O apelo √† mem√≥ria rec√©m-alocada pode obter o valor antigo, o sistema operacional pode reutilizar a p√°gina de mem√≥ria e substitu√≠-la por uma p√°gina com zero preenchimento na pr√≥xima vez que voc√™ gravar em outro local da p√°gina.  A segunda chamada para o mesmo local na p√°gina ter√° um valor zero. <br><br>  Se a condi√ß√£o usar um valor indefinido, o resultado tamb√©m n√£o ser√° definido - tudo pode acontecer.  Imagine uma otimiza√ß√£o de loop aberto, onde um loop √© executado zero vezes.  No original, todo o loop √© um c√≥digo morto.  Na vers√£o aberta, agora existe uma condi√ß√£o com uma vari√°vel que pode n√£o ser inicializada. <br>  Como resultado, o c√≥digo morto pode ser convertido em comportamento indefinido.  Essa √© apenas uma das muitas otimiza√ß√µes que, ao explorar mais detalhadamente a sem√¢ntica de C, acabam n√£o sendo confi√°veis. <br><br>  No final, voc√™ pode fazer o c√≥digo C rodar rapidamente, mas somente depois de gastar milhares de homens-ano criando um compilador inteligente o suficiente.  Mas isso s√≥ √© poss√≠vel se certas regras do idioma forem violadas.  Os criadores de compiladores permitem que programadores C imaginem que escrevem c√≥digo "pr√≥ximo ao hardware", mas precisam gerar c√≥digo de m√°quina que se comporte de maneira diferente, para que os programadores continuem acreditando que escrevem em uma linguagem r√°pida. <br><br><h2>  Entendendo C </h2><br>  Um dos atributos b√°sicos de uma linguagem de baixo n√≠vel √© que os programadores podem entender facilmente como uma m√°quina de linguagem abstrata √© transferida para uma m√°quina f√≠sica.  Esse foi definitivamente o caso do PDP-11, onde as express√µes C foram traduzidas em uma ou duas instru√ß√µes.  Da mesma forma, o compilador colocou vari√°veis ‚Äã‚Äãnos slots da pilha e converteu tipos simples em compreens√≠veis para o PDP-11. <br><br>  Desde ent√£o, as implementa√ß√µes de C tornaram-se muito mais complicadas - para manter a ilus√£o de que C √© facilmente transportado para uma plataforma de hardware e roda rapidamente.  Em 2015, uma pesquisa entre programadores C, autores de compiladores e membros do comit√™ de padroniza√ß√£o mostrou que havia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problemas para entender C.</a>  Por exemplo, esse idioma permite que uma implementa√ß√£o adicione alinhamento √†s estruturas (mas n√£o √†s matrizes) para garantir que todos os campos estejam alinhados corretamente para a plataforma de destino.  Se voc√™ preencher essa estrutura com zeros e especificar um valor para alguns campos, haver√° zeros nos bits de alinhamento?  Segundo a pesquisa, 36% tinham certeza de que sim e 29% n√£o sabiam a resposta.  Dependendo do compilador e do n√≠vel de otimiza√ß√£o, isso pode ser verdade (ou n√£o). <br><br>  Este √© um exemplo bastante trivial, mas muitos programadores d√£o a resposta errada ou n√£o conseguem responder. <br><br>  Se voc√™ adicionar ponteiros, a sem√¢ntica de C se tornar√° ainda mais confusa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O modelo BCPL</a> era bastante simples: todos os significados s√£o palavras.  Cada palavra √© um dado ou um endere√ßo na mem√≥ria.  A mem√≥ria √© uma matriz plana de c√©lulas indexadas por endere√ßo. <br><br>  O Modelo C permite a implementa√ß√£o de diferentes plataformas, incluindo arquiteturas segmentadas, nas quais o ponteiro pode consistir em IDs e compensa√ß√µes de segmentos, al√©m de m√°quinas virtuais com um coletor de lixo.  A especifica√ß√£o C restringe as opera√ß√µes permitidas do ponteiro para evitar problemas com esses sistemas.  A resposta ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relat√≥rio de Defeitos 260</a> menciona a origem do ponteiro: <br><blockquote>  ‚ÄúAs implementa√ß√µes podem seguir a origem de um conjunto de bits e lidar com aqueles que cont√™m um valor indefinido de forma diferente daqueles que cont√™m um valor espec√≠fico.  "Eles podem lidar com ponteiros de maneira diferente, dependendo de sua origem, mesmo que sejam os mesmos em termos de valor de bits". </blockquote><br>  Infelizmente, a palavra "origem" est√° ausente na especifica√ß√£o C11, ent√£o os compiladores decidem por si mesmos o que isso significa.  O GCC e o Clang, por exemplo, diferem se o ponteiro que foi convertido no n√∫mero inteiro e vice-versa mant√©m sua origem.  Os compiladores podem decidir que dois ponteiros para os resultados de malloc () sempre d√£o um resultado negativo ao comparar, mesmo que apontem para o mesmo endere√ßo. <br><br>  Esses mal-entendidos n√£o s√£o puramente acad√™micos.  Por exemplo, j√° foram observadas vulnerabilidades, que foram o resultado do transbordamento de um n√∫mero inteiro assinado (comportamento indefinido em C) ou da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desreferencia√ß√£o de um ponteiro antes de procurar NULL</a> , apesar do fato de o compilador ter sido informado de que o ponteiro n√£o podia ser NULL. <br><br>  Se houver tais problemas, √© dif√≠cil esperar que um programador entenda completamente como um programa C se traduz na arquitetura apropriada. <br><br><h2>  Introduzindo um processador n√£o para C </h2><br>  Os patches propostos para prote√ß√£o contra Spectre e Meltdown causam severa degrada√ß√£o do desempenho, anulando todas as conquistas da microarquitetura na √∫ltima d√©cada.  Talvez seja hora de parar de pensar em como tornar o c√≥digo C mais r√°pido e, em vez disso, pensar em novos modelos de programa√ß√£o em processadores projetados para aumentar a velocidade. <br><br>  Existem muitos exemplos de arquiteturas que n√£o se concentraram no c√≥digo C tradicional e para inspirar.  Por exemplo, processadores orientados a multithreading, como o Sun / Oracle UltraSPARC Tx, n√£o exigem muito cache para manter seus atuadores ocupados.  Os processadores de pesquisa expandiram esse conceito para um n√∫mero muito grande de threads planejados por hardware.  A ideia principal √© que, com threads suficientes, o processador possa pausar os threads que est√£o aguardando dados e preencher os atuadores com instru√ß√µes de outros threads.  O problema √© que os programas C geralmente t√™m muito poucos threads. <br><br>  O SVE da ARM (Extens√µes de vetores escalares, extens√µes de vetores escalares) √© outro trabalho semelhante de Berkeley, que oferece uma olhada na interface aprimorada entre o programa e o hardware.  Blocos de vetoriza√ß√£o regulares implementam opera√ß√µes com vetores de tamanho fixo e esperam que o compilador adapte o algoritmo ao tamanho especificado.  Por outro lado, a interface do SVE solicita ao programador que descreva independentemente o n√≠vel de paralelismo e espera que o hardware o adapte aos atuadores dispon√≠veis.  Usar isso em C √© dif√≠cil porque o auto-vetorizador precisa calcular o paralelismo com base nos loops do c√≥digo. <br><br>  Os caches s√£o grandes, mas esse n√£o √© o √∫nico motivo de sua complexidade.  O protocolo de suporte √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coer√™ncia de cache</a> √© um dos componentes mais complexos de um processador moderno.  A maior parte da dificuldade vem de ter que manter um idioma no qual os dados possam ser compartilhados e mut√°veis.  Como exemplo oposto, podemos usar uma m√°quina abstrata do estilo Erlang, onde cada objeto √© local ou imut√°vel.  O protocolo de coer√™ncia de cache para esse sistema teria apenas dois casos: dados mut√°veis ‚Äã‚Äãe dados compartilhados.  O cache do fluxo do programa que foi transferido para outro processador deve ser explicitamente desativado, mas essa √© uma opera√ß√£o relativamente rara. <br><br>  Objetos imut√°veis ‚Äã‚Äãpodem simplificar ainda mais os caches e tamb√©m tornar algumas opera√ß√µes mais baratas.  Em um projeto Maxwell do Sun Labs, observou-se que os objetos no cache e nos objetos criados recentemente s√£o quase sempre os mesmos.  Se os objetos morrerem antes de serem exclu√≠dos do cache, voc√™ n√£o poder√° grav√°-los na mem√≥ria principal e assim economizar o consumo de energia.  O projeto Maxwell prop√¥s um coletor de lixo que funcionava no cache e permitia reciclar rapidamente a mem√≥ria.  Com objetos imut√°veis ‚Äã‚Äãna pilha e pilha mut√°vel, o coletor de lixo se torna uma m√°quina de estado muito simples, que √© facilmente implementada no hardware e permite que voc√™ use eficientemente um cache relativamente pequeno. <br><br>  Um processador projetado exclusivamente para velocidade, e n√£o para a troca entre velocidade e suporte C, provavelmente deve suportar um grande n√∫mero de encadeamentos, ter grandes blocos de vetoriza√ß√£o e um modelo de mem√≥ria mais simples.  Ser√° dif√≠cil executar o c√≥digo C nesse processador; portanto, dado o volume do c√≥digo C antigo no mundo, √© improv√°vel que tenha sucesso comercial. <br><br>  No campo do desenvolvimento de software, existe um mito de que a programa√ß√£o paralela √© dif√≠cil.  Alan Kay ficaria muito surpreso ao ouvir isso: ele ensinou as crian√ßas a usar o modelo de ator, com o qual eles escreveram programas em mais de 200 transmiss√µes.  Isso tamb√©m √© desconhecido para os programadores Erlang, que costumam escrever programas com milhares de componentes paralelos.  √â mais correto dizer que a programa√ß√£o paralela √© dif√≠cil em uma linguagem com uma m√°quina abstrata como C. E se voc√™ prestar aten√ß√£o √† predomin√¢ncia de hardware paralelo (de processadores com v√°rios n√∫cleos a GPUs com v√°rios n√∫cleos), essa √© apenas outra maneira de dizer que C n√£o √© adequado para hardware moderno fornecendo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420407/">https://habr.com/ru/post/pt420407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420391/index.html">Sal√°rios de TI em meados de 2018</a></li>
<li><a href="../pt420393/index.html">PHP, YII2 e a forma√ß√£o de grandes arquivos Excel</a></li>
<li><a href="../pt420395/index.html">Tabuletas "gratuitas" para prisioneiros - nem um pouco gratuitas</a></li>
<li><a href="../pt420397/index.html">Os cientistas descobriram uma maneira de reverter o processo de envelhecimento das c√©lulas</a></li>
<li><a href="../pt420405/index.html">Pesquisando o processo de vendas de TI</a></li>
<li><a href="../pt420409/index.html">Aprenda o OpenGL. Li√ß√£o 5.7 - HDR</a></li>
<li><a href="../pt420413/index.html">SQLite e NW.js - instru√ß√µes passo a passo para criar amizades fortes</a></li>
<li><a href="../pt420415/index.html">Tudo o que voc√™ queria saber sobre o teste de adaptadores Wi-Fi, mas tinha medo de perguntar</a></li>
<li><a href="../pt420419/index.html">Corredores para quem gosta de humilha√ß√£o ou como mudamos e modificamos o PixJam</a></li>
<li><a href="../pt420423/index.html">Problemas na interface de travessia de terra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>