<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 🗓️ 🎃 Stage chez JetBrains et comment j'ai failli y arriver 🏇🏻 👩🏻‍🍳 🏇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comme beaucoup de jeunes développeurs, quand il y a un désir de trouver un emploi / stage, je regarde dans la direction des entreprises IT cool. 

 Ré...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stage chez JetBrains et comment j'ai failli y arriver</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454354/"><img src="https://habrastorage.org/getpro/habr/post_images/d42/5b8/da4/d425b8da4aec5f7359e39503e9f1d700.jpg" alt="image"><br><br>  Comme beaucoup de jeunes développeurs, quand il y a un désir de trouver un emploi / stage, je regarde dans la direction des entreprises IT cool. <br><br>  Récemment, j'ai essayé d'entrer dans les rangs de JetBrains et sous la coupe, je suis prêt à partager mon expérience. <br><a name="habracut"></a><br><h3>  Pourquoi «presque» a-t-il réussi? </h3><br>  Vous avez sûrement immédiatement une telle question. <br><br>  À mon avis, j'ai un bon curriculum vitae avec un tas de réalisations et une bonne compétence, que j'améliore jour après jour les 8-9 dernières années. <br><br>  J'ai terminé la tâche de test (et cela me semble bien), j'ai déjà visité le bureau de JB, qui est situé dans ma ville, parlé à HH et à certains développeurs de l'entreprise, et en conséquence, on m'a refusé un stage sans aucun commentaire. <br><br>  Très probablement, la raison réside dans le fait que JetBrains sélectionne exclusivement les étudiants pour le stage, et pour le moment je viens de terminer le 11 et de passer les examens les uns après les autres. <br><br>  Eh bien, c'est l'occasion pour une autre année entière de se relever et de postuler pour l'année suivante. <br><br><h3>  Analyse de la tâche de test </h3><br>  Les délais de soumission des demandes de stage et de test des devoirs de test sont dépassés, ce qui signifie que tous ceux qui les ont résolus, y compris moi, peuvent publier une analyse de ces missions afin que l'année prochaine tout étudiant intéressé puisse se familiariser avec le niveau approximatif des missions avant de commencer les stages JB, avec auquel il devra faire face et dans ce cas pour remonter ses connaissances. <br><br>  J'ai postulé pour un stage avec l'équipe de développement du débogueur Corotin pour Kotlin. <br><br>  La tâche de cette équipe lors d'un stage pour ceux qui l'ont touchée cette année sera de finaliser cette partie du débogueur et son intégration avec l'IDE. <br><br>  La tâche était un peu attendue - écrire un débogueur pour un petit PL. <br><br>  Je ne dirais pas que c'est complexe, bien au contraire.  Il ne nécessite aucune connaissance approfondie de la théorie de la construction de traducteurs et une compétence cool.  Mais néanmoins, ceux qui postulent pour un stage dans ce domaine devraient au moins avoir ces bases et faire face à cette tâche sans aucun problème.  J'ai été surpris lorsque j'ai décidé de rechercher sur github des mots-clés les solutions de mes "concurrents" et trouvé 1-2 solutions plus ou moins fonctionnelles contre environ 6-7 référentiels vides ou avec quelques morceaux de code après quoi les gens ont abandonné.  Peut-être que je regardais mal, mais néanmoins, les résultats ne m'ont pas plu.  Si ce post sera lu par des personnes qui ont abandonné cette tâche - pas besoin de le faire à l'avenir.  Dans un cas extrême, il suffisait de s'asseoir sur la tâche pendant quelques jours et je suis sûr que vous vous en occuperiez. <br><br><div class="spoiler">  <b class="spoiler_title">Le texte de la quête elle-même</b> <div class="spoiler_text">  Objectif: implémenter l'exécution de code étape par étape pour le langage de programmation trivial Guu. <br><br>  Attention: dans la description ci-dessous, certains points importants sont volontairement omis.  En règle générale, ils restent à votre discrétion.  Si c'est complètement incompréhensible, écrivez à (voici le mail que j'ai décidé de supprimer). <br><br>  Un programme Guu consiste en un ensemble de procédures.  Chaque procédure commence par la ligne sub (subname) et se termine par la déclaration d'une autre procédure (ou la fin du fichier si la procédure dans le fichier est la dernière).  L'exécution commence par le sous-principal. <br><br>  Le corps d'une procédure est un ensemble d'instructions, chacune étant sur une ligne distincte.  Des tabulations ou des espaces insignifiants peuvent apparaître au début d'une ligne.  Les lignes vides sont ignorées.  Il n'y a aucun commentaire sur Guu. <br><br>  Guu n'a que trois opérateurs: - set (varname) (nouvelle valeur) - définissant une nouvelle valeur entière pour la variable.  - call (subname) - appelle la procédure.  Les appels peuvent être récursifs.  - print (varname) - imprime la valeur de la variable à l'écran. <br><br>  Les variables de Guu ont une portée globale.  Le programme ci-dessous affichera la ligne a = 2. <br><br>  sous-principal <br>  définir un 1 <br>  appeler foo <br>  imprimer un <br><br>  sous foo <br>  définir un 2 <br><br>  Et voici le programme le plus simple avec une récursion infinie: <br><br>  sous-principal <br>  appel principal <br><br>  Vous devez écrire un interprète étape par étape pour Guu.  Lorsqu'il démarre, le débogueur doit s'arrêter sur la ligne avec la première instruction en sous-main et attendre les commandes de l'utilisateur.  Ensemble minimal requis de commandes de débogage: <br><br>  i - entrez, le débogueur entre dans l'appel (sous-nom). <br>  o - enjamber, le débogueur ne va pas à l'intérieur de l'appel. <br>  trace - impression de l'exécution de la trace de la pile avec des numéros de ligne à partir de ... <br>  var - affiche les valeurs de toutes les variables déclarées. <br><br>  Le format de communication de l'utilisateur avec le débogueur est laissé à la discrétion ci-dessus.  Vous pouvez choisir soit une interface minimaliste de type GDB, soit une console ou une interface graphique.  Les noms des commandes du débogueur peuvent être modifiés si vous le souhaitez. <br><br>  Pour résoudre ce problème, vous pouvez utiliser n'importe quel langage de programmation de TIOBE TOP 50 et un compilateur / interprète open-source. <br><br>  Lors de l'évaluation du travail sera évalué: <br><br>  La performance globale du programme; <br>  La qualité du code source et la disponibilité des tests; <br>  Fonctionnalité facile à étendre (par exemple, prise en charge de nouvelles instructions de langue ou instructions de débogage). <br>  Une solution avec des instructions pour la construire doit être publiée dans le référentiel Git (par exemple, sur GitHub ou BitBucket).  Dans la réponse, vous devez spécifier un lien vers le référentiel.  Un lien vers un référentiel GitHub privé convient également, vous seul devrez y ajouter. <br></div></div><br>  J'écris en C ++, Java et Object Pascal. <br><br>  Au début, il y avait des pensées pour tout écrire dans mon même MPS, mais je pensais que ce ne serait pas très pratique de vérifier pour un employé JB, et j'ai soumis la candidature 2 jours avant la clôture de la soumission (examens tout de même ...), et c'était déjà le soir devant la fenêtre - j'ai décidé d'écrire rapidement tout dans des langues plus connues. <br><br>  À mon avis, Pascal est le plus approprié pour résoudre le problème, au moins en raison de la mise en œuvre la plus pratique des chaînes ... <br><br>  Du moins pour moi.  De plus, il est dans TIOBE TOP 50, j'ai donc lancé hardiment l'IDE, à savoir Lazarus, car  il n'est pas commercial :) et se mit à résoudre le problème. <br><br>  Malgré le fait qu'ils donnent à JB jusqu'à 7 jours, cela m'a pris environ une heure pour terminer le projet, et le projet s'est avéré être environ 500 lignes de code. <br><br><h3>  Par où commencer? </h3><br>  Tout d'abord, vous devez imaginer comment le débogage de code fonctionnera à la fin. <br><br>  Nous devons implémenter l'exécution de code étape par étape - cela signifie que chaque instruction doit être présentée sous la forme d'une structure / classe et, en général, les instructions doivent ressembler à une liste de ces classes ou, comme dans mon implémentation, se référer les unes aux autres formant une séquence (je noterai pourquoi je l'ai fait plus tard). <br><br>  Pour obtenir cette séquence, notre débogueur doit traiter le code dans le langage proposé, ce qui signifie que nous devons également implémenter un petit analyseur, ainsi qu'une analyse syntaxique et sémantique du code. <br><br>  Commençons par l'implémentation de l'analyseur.  Parce que  Étant donné que la langue Guu se compose d'un ensemble de jetons, séparés par un espace, il est logique d'écrire d'abord un petit et simple tokenizer: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; tokenNum: word)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := Trim(s); s := StringReplace(s, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, [rfReplaceAll]); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> tokenNum &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, <span class="hljs-number"><span class="hljs-number">1</span></span>, p) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; dec(tokenNum); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, p, Length(s)); Result := s; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Ensuite, déclarez l'énumération des jetons: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuToken = (opSub, opSet, opCall, opPrint, opUnknown); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GuuToken: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[opSub..opPrint] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ( <span class="hljs-string"><span class="hljs-string">'sub'</span></span>, <span class="hljs-string"><span class="hljs-string">'set'</span></span>, <span class="hljs-string"><span class="hljs-string">'call'</span></span>, <span class="hljs-string"><span class="hljs-string">'print'</span></span> );</code> </pre><br>  Et la classe d'instruction elle-même, dans laquelle nous analyserons les lignes de code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpType : TGuuToken; OpArgs : TStringList; OpLine : Cardinal; OpUnChangedLine: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; NextOp : TGuuOp; OpReg : Pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dans OpType, l'instruction sera stockée, dans OpArgs - le reste de la construction. <br>  OpLine, OpUnChangedLine - informations pour le débogueur. <br><br>  NextOp est un pointeur vers l'instruction suivante.  S'il est égal à nil (null en Pascal), il n'y a pas d'autres instructions et vous devez compléter le code ou retourner via la pile de rappel. <br><br>  OpReg est un petit registre de pointeurs, qui sera utilisé plus tard pour une petite optimisation de l'exécution du code. <br><br>  Après la déclaration de classe a été écrite - j'ai décidé que la solution la plus compacte et la plus belle serait d'ajouter l'analyseur et un peu d'analyse dans son constructeur, ce que j'ai fait ensuite: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * That method parse code line. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; w: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; OpArgs := TStringList.Create; OpLine := LineNum; OpUnChangedLine := Line; NextOp := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; OpReg := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; s := GetToken(Line, <span class="hljs-number"><span class="hljs-number">1</span></span>); OpType := TGuuToken(AnsiIndexStr(s, GuuToken)); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub : <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// sub &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "sub" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opSet : begin // set &lt;var&gt; &lt;value&gt; OpArgs.Add(GetToken(Line, 2)); OpArgs.Add(GetToken(Line, 3)); w := 1; while w &lt; Length(OpArgs[1]) + 1 do begin if not (OpArgs[1][w] in ['0'..'9']) then begin writeln('[Syntax error]: Invalid variable assigment "', Line, '" at line ', OpLine, '.'); halt; end; inc(w); end; if (Length(OpArgs[0]) = 0) or (Length(OpArgs[1]) = 0) or (Length(GetToken(Line, 4)) &gt; 0) then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end end; opCall : begin // call &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "call" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opPrint: begin // print &lt;var&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "print" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; else begin writeln('[Syntax error]: Invalid token "', s, '" at line ', OpLine, '.'); halt; end; end; end; destructor TGuuOp.Destroy; begin FreeAndNil(OpArgs); inherited; end;</span></span></code> </pre><br>  Ici, nous vérifions essentiellement le début de la construction (c'est-à-dire le premier mot), puis regardons les jetons restants et leur nombre.  Si quelque chose ne va clairement pas avec le code, nous affichons une erreur. <br><br>  Dans le morceau de code principal, nous lisons simplement le code dans la TStringList du fichier, appelons les constructeurs TGuuOp ligne par ligne et enregistrons les pointeurs vers les instances de classe dans GuuOps: TList. <br><br>  Annonces: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LabelNames: TStringList; GuuOps, GuuVars: TList; SubMain: TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>;</code> </pre><br>  Avec l'analyse de code, il serait intéressant d'effectuer quelques actions supplémentaires: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Parsing code lines and define variables and labels. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; GV: TGuuVar; c: cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Trim(Line) &lt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp.Create(LineNum, Line); GuuOps.Add(Op); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Op.OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// define variable and/or optimisation var calling GV := nil; c := 0; while c &lt; GuuVars.Count do begin if TGuuVar(GuuVars[c]).gvName = Op.OpArgs[0] then begin GV := TGuuVar(GuuVars[c]); break; end; inc(c); end; if GV = nil then begin GV := TGuuVar.Create(Op.OpArgs[0]); GuuVars.Add(GV); end; Op.OpReg := GV; end; opSub: begin // Check for label dublicade declaration if Op.OpArgs[0] = 'main' then SubMain := Op; if LabelNames.IndexOf(Op.OpArgs[0]) &lt;&gt; -1 then begin writeln('[Error]: Dublicate sub "', Op.OpArgs[0], '" declaration at line ', Op.OpLine, '.'); halt; end else LabelNames.Add(Op.OpArgs[0]); end; end; end; end;</span></span></code> </pre><br>  À ce stade, vous pouvez vérifier les points d'entrée au moment de la redéfinition et penser à OpReg - je l'ai utilisé pour stocker un pointeur sur une variable Guu. <br><br>  En parlant de variables, j'ai pris ce petit morceau de code dans une unité distincte: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uVars; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuVar = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> gvName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; gvVal: variant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuVar</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; gvName := VarName; gvVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  Nous avons maintenant un code analysé qui semble être correct dans la syntaxe.  Il reste à l'analyser et vous pouvez commencer à effectuer la chose la plus importante - le débogage. <br><br>  Ensuite, vous devez implémenter une petite analyse sémantique et préparer simultanément tout pour l'exécution de code et le débogage: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSemantic</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Semantic analyse and calls optimisation. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c, x: cardinal; op: TGuuOp; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GuuOps.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpType &lt;&gt; opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Operation outside sub at line '</span></span>, TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; c := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> c &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TGuuOp(GuuOps[c]).OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub:; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; op := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpType = opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> op := TGuuOp(GuuOps[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> TGuuOp(GuuOps[c]).OpReg := op <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Calling to not exist sub "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuVars.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuVar(GuuVars[x]).gvName = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c]).OpReg := TGuuVar(GuuVars[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[c]).OpReg = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Variable "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" for print doesn''t exist at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(c); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dans TGuuOp.NextOp de chaque jeton, écrivez un pointeur sur le jeton suivant. <br>  Pour l'opcode call, nous le faisons délicat et simple - dans NextOp, nous écrivons un pointeur vers le point d'entrée appelé. <br><br>  Nous vérifions également les variables de sortie via l'instruction print ... <br><br>  Peut-être qu'ils n'ont pas été annoncés avant la conclusion? <br><br>  Vous devez maintenant implémenter l'exécution de code.  Revenez à la classe TGuuOp et implémentez la méthode Step: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-comment"><span class="hljs-comment">(* * That method execute instruction. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; CBSize: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Trace.Add(<span class="hljs-string"><span class="hljs-string">'-&gt; Sub "'</span></span> + OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StepInto <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NextOp &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallBacks.Add(NextOp); Result := TGuuOp(OpReg); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(OpReg); CBSize := CallBacks.Count; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((Op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (CallBacks.Count &gt; CBSize)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Op = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]); CallBacks.Delete(CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Trace.Delete(Trace.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Op := Op.Step(StepInto, CallBacks, Trace); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(TGuuVar(OpReg).gvName, <span class="hljs-string"><span class="hljs-string">' = '</span></span>, TGuuVar(OpReg).gvVal); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuVar(OpReg).gvVal := OpArgs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Pour éviter la violation d'accès en cas de boucle - il est préférable de limiter la pile, ce que j'ai fait. <br>  La constante STACK_SIZE = 2048, déclarée ci-dessus est juste responsable de cela. <br><br>  Il est maintenant temps d'écrire le code principal de notre débogueur: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code: TStringList; c: Cardinal; cmd: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; CallBacks: TList; Trace: TStringList; DebugMode: boolean = true; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ParamCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// Initialisation if not FileExists(ParamStr(1)) then begin writeln('[Error]: Can''t open file "', ParamStr(1), '".'); halt; end; if ParamCount &gt; 1 then if LowerCase(ParamStr(2)) = '/run' then DebugMode := false; code := TStringList.Create; code.LoadFromFile(ParamStr(1)); GuuOps := TList.Create; GuuVars := TList.Create; // Parsing and preparing LabelNames := TStringList.Create; c := 0; while c &lt; code.Count do begin ParseNext(c + 1, Trim(code[c])); inc(c); end; FreeAndNil(LabelNames); CheckSemantic; if SubMain = nil then begin writeln('[Error]: Sub "main" doesn''t exist!'); halt; end; // Start code execution CurrentOp := SubMain; CallBacks := TList.Create; Trace := TStringList.Create; if DebugMode then begin //Out code and features ClrScr; writeln('Code for debugging:'); writeln('.....'); c := 0; while c &lt; code.Count do begin writeln(FillSpaces(IntToStr(c + 1), 4), '| ', code[c]); inc(c); end; writeln('"""""'); FreeAndNil(code); writeln(sLineBreak, 'Features:', sLineBreak, '* i - step into.', sLineBreak, '* o - step over.', sLineBreak, '* trace - print stack trace.', sLineBreak, '* var - print variables list.', sLineBreak, '* x - exit.', sLineBreak); // Execution loop while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin write('Line ', CurrentOp.OpLine, ' ~&gt; '); readln(cmd); // Execute commands if cmd = 'i' then CurrentOp := CurrentOp.Step(true, CallBacks, Trace) else if cmd = 'o' then CurrentOp := CurrentOp.Step(false, CallBacks, Trace) else if cmd = 'trace' then begin writeln('| Trace:'); c := 0; while c &lt; Trace.Count do begin writeln('| ', Trace[c]); inc(c); end; writeln('| -&gt; Line ', CurrentOp.OpLine, ': "', CurrentOp.OpUnChangedLine, '".') end else if cmd = 'var' then begin writeln('| Variables list:'); c := 0; while c &lt; GuuVars.Count do begin writeln('| ', TGuuVar(GuuVars[c]).gvName, ' = ', TGuuVar(GuuVars[c]).gvVal); inc(c); end; end else if cmd = 'x' then halt; // Check for method end &amp; make callback if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end else begin // Only run mode (/run) FreeAndNil(code); while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin CurrentOp := CurrentOp.Step(false, CallBacks, Trace); if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end; if Trace.Count &gt;= STACK_SIZE then writeln('[Runtime error]: Stack overflow!'); FreeAndNil(CallBacks); FreeAndNil(Trace); end else writeln( 'Guu debugger v1.0.', sLineBreak, 'Author: Pavel Shiryaev (@RoPi0n).', sLineBreak, 'Run: svmc guu_debugger.vmc &lt;guu source file&gt; [arg]', sLineBreak, 'Args:', sLineBreak, ' /run - Run Guu code.' ); end.</span></span></code> </pre><br>  Selon l'état du travail, l'interface peut être implémentée comme vous le souhaitez. <br><br>  Il serait possible d'implémenter une interface utilisateur à part entière, visser SynEdit au projet, mais à mon avis, c'est un travail vide qui ne reflétera pas la compétence, et en plus il ne sera pas payé :) <br><br>  Je me suis donc limité à une petite interface utilisateur de console. <br><br>  Le code ci-dessus n'est pas compliqué, vous pouvez donc le laisser sans commentaire.  Dans ce document, nous prenons des TGuuOp prêts à l'emploi et les appelons Step. <br><br>  Captures d'écran du problème résolu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33e/ad0/efa/33ead0efa3a07d77d1a6c07010847035.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e1/7eb/41e/3e17eb41e99abece612f09b146464f67.jpg" alt="image"><br><br>  Sortie d'informations d'erreur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/1c5/ea4/6591c5ea44e67f5068bd7fb0e9c2341e.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a0/3f0/733/2a03f07336c5af1333f259d43e4a1396.jpg" alt="image"><br><br>  Lien vers le référentiel de ma solution: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cliquez sur</a> <br><br><h3>  Résumé </h3><br>  Il n'y a pas de résultats particuliers.  Je vais devoir consacrer la majeure partie de l’été à des vacances bien remplies et chercher une université (enfin, au cas où je réussirais bien l’examen, bien sûr), au lieu de deux mois de travail et de formation dans l’équipe JetBrains. <br><br>  Peut-être que l'année prochaine un nouveau billet apparaîtra sur Habré, décrivant déjà le processus de stage chez JB ou dans une autre entreprise qui m'intéresse :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454354/">https://habr.com/ru/post/fr454354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454336/index.html">Client: - Combien coûte une copie de Facebook?</a></li>
<li><a href="../fr454340/index.html">% tutnazvanievu% est la première université au monde où les jetpacks sont officiellement développés</a></li>
<li><a href="../fr454346/index.html">Algorithmes d'efficacité: examen de la caméra de surveillance Nobelic 2019</a></li>
<li><a href="../fr454348/index.html">Gestion de l'état avec React Hooks - Sans Redux et Context API</a></li>
<li><a href="../fr454352/index.html">Incertitudes mathématiques en Python</a></li>
<li><a href="../fr454356/index.html">Habr Weekly # 3 / Runet vs TV, ARM vs Intel, unification des données d'État, sans smartphone en 2019, rêves soviétiques d'avenir</a></li>
<li><a href="../fr454366/index.html">Victoire aux PHDays 9. Nous partageons les hacks de vie en trois parties. 2e partie</a></li>
<li><a href="../fr454368/index.html">Concours de développeurs de plugins TeamCity</a></li>
<li><a href="../fr454372/index.html">Nouvelles hebdomadaires: Huawei a toujours des problèmes, "téléphone quantique" dans la Fédération de Russie, ARM a de nouveaux processeurs</a></li>
<li><a href="../fr454374/index.html">L'imprimante 3D photo-polymère à partir d'un vidéoprojecteur à domicile crée des objets sans couches</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>