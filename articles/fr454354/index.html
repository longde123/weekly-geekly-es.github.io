<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìñ üóìÔ∏è üéÉ Stage chez JetBrains et comment j'ai failli y arriver üèáüèª üë©üèª‚Äçüç≥ üèáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comme beaucoup de jeunes d√©veloppeurs, quand il y a un d√©sir de trouver un emploi / stage, je regarde dans la direction des entreprises IT cool. 

 R√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stage chez JetBrains et comment j'ai failli y arriver</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454354/"><img src="https://habrastorage.org/getpro/habr/post_images/d42/5b8/da4/d425b8da4aec5f7359e39503e9f1d700.jpg" alt="image"><br><br>  Comme beaucoup de jeunes d√©veloppeurs, quand il y a un d√©sir de trouver un emploi / stage, je regarde dans la direction des entreprises IT cool. <br><br>  R√©cemment, j'ai essay√© d'entrer dans les rangs de JetBrains et sous la coupe, je suis pr√™t √† partager mon exp√©rience. <br><a name="habracut"></a><br><h3>  Pourquoi ¬´presque¬ª a-t-il r√©ussi? </h3><br>  Vous avez s√ªrement imm√©diatement une telle question. <br><br>  √Ä mon avis, j'ai un bon curriculum vitae avec un tas de r√©alisations et une bonne comp√©tence, que j'am√©liore jour apr√®s jour les 8-9 derni√®res ann√©es. <br><br>  J'ai termin√© la t√¢che de test (et cela me semble bien), j'ai d√©j√† visit√© le bureau de JB, qui est situ√© dans ma ville, parl√© √† HH et √† certains d√©veloppeurs de l'entreprise, et en cons√©quence, on m'a refus√© un stage sans aucun commentaire. <br><br>  Tr√®s probablement, la raison r√©side dans le fait que JetBrains s√©lectionne exclusivement les √©tudiants pour le stage, et pour le moment je viens de terminer le 11 et de passer les examens les uns apr√®s les autres. <br><br>  Eh bien, c'est l'occasion pour une autre ann√©e enti√®re de se relever et de postuler pour l'ann√©e suivante. <br><br><h3>  Analyse de la t√¢che de test </h3><br>  Les d√©lais de soumission des demandes de stage et de test des devoirs de test sont d√©pass√©s, ce qui signifie que tous ceux qui les ont r√©solus, y compris moi, peuvent publier une analyse de ces missions afin que l'ann√©e prochaine tout √©tudiant int√©ress√© puisse se familiariser avec le niveau approximatif des missions avant de commencer les stages JB, avec auquel il devra faire face et dans ce cas pour remonter ses connaissances. <br><br>  J'ai postul√© pour un stage avec l'√©quipe de d√©veloppement du d√©bogueur Corotin pour Kotlin. <br><br>  La t√¢che de cette √©quipe lors d'un stage pour ceux qui l'ont touch√©e cette ann√©e sera de finaliser cette partie du d√©bogueur et son int√©gration avec l'IDE. <br><br>  La t√¢che √©tait un peu attendue - √©crire un d√©bogueur pour un petit PL. <br><br>  Je ne dirais pas que c'est complexe, bien au contraire.  Il ne n√©cessite aucune connaissance approfondie de la th√©orie de la construction de traducteurs et une comp√©tence cool.  Mais n√©anmoins, ceux qui postulent pour un stage dans ce domaine devraient au moins avoir ces bases et faire face √† cette t√¢che sans aucun probl√®me.  J'ai √©t√© surpris lorsque j'ai d√©cid√© de rechercher sur github des mots-cl√©s les solutions de mes "concurrents" et trouv√© 1-2 solutions plus ou moins fonctionnelles contre environ 6-7 r√©f√©rentiels vides ou avec quelques morceaux de code apr√®s quoi les gens ont abandonn√©.  Peut-√™tre que je regardais mal, mais n√©anmoins, les r√©sultats ne m'ont pas plu.  Si ce post sera lu par des personnes qui ont abandonn√© cette t√¢che - pas besoin de le faire √† l'avenir.  Dans un cas extr√™me, il suffisait de s'asseoir sur la t√¢che pendant quelques jours et je suis s√ªr que vous vous en occuperiez. <br><br><div class="spoiler">  <b class="spoiler_title">Le texte de la qu√™te elle-m√™me</b> <div class="spoiler_text">  Objectif: impl√©menter l'ex√©cution de code √©tape par √©tape pour le langage de programmation trivial Guu. <br><br>  Attention: dans la description ci-dessous, certains points importants sont volontairement omis.  En r√®gle g√©n√©rale, ils restent √† votre discr√©tion.  Si c'est compl√®tement incompr√©hensible, √©crivez √† (voici le mail que j'ai d√©cid√© de supprimer). <br><br>  Un programme Guu consiste en un ensemble de proc√©dures.  Chaque proc√©dure commence par la ligne sub (subname) et se termine par la d√©claration d'une autre proc√©dure (ou la fin du fichier si la proc√©dure dans le fichier est la derni√®re).  L'ex√©cution commence par le sous-principal. <br><br>  Le corps d'une proc√©dure est un ensemble d'instructions, chacune √©tant sur une ligne distincte.  Des tabulations ou des espaces insignifiants peuvent appara√Ætre au d√©but d'une ligne.  Les lignes vides sont ignor√©es.  Il n'y a aucun commentaire sur Guu. <br><br>  Guu n'a que trois op√©rateurs: - set (varname) (nouvelle valeur) - d√©finissant une nouvelle valeur enti√®re pour la variable.  - call (subname) - appelle la proc√©dure.  Les appels peuvent √™tre r√©cursifs.  - print (varname) - imprime la valeur de la variable √† l'√©cran. <br><br>  Les variables de Guu ont une port√©e globale.  Le programme ci-dessous affichera la ligne a = 2. <br><br>  sous-principal <br>  d√©finir un 1 <br>  appeler foo <br>  imprimer un <br><br>  sous foo <br>  d√©finir un 2 <br><br>  Et voici le programme le plus simple avec une r√©cursion infinie: <br><br>  sous-principal <br>  appel principal <br><br>  Vous devez √©crire un interpr√®te √©tape par √©tape pour Guu.  Lorsqu'il d√©marre, le d√©bogueur doit s'arr√™ter sur la ligne avec la premi√®re instruction en sous-main et attendre les commandes de l'utilisateur.  Ensemble minimal requis de commandes de d√©bogage: <br><br>  i - entrez, le d√©bogueur entre dans l'appel (sous-nom). <br>  o - enjamber, le d√©bogueur ne va pas √† l'int√©rieur de l'appel. <br>  trace - impression de l'ex√©cution de la trace de la pile avec des num√©ros de ligne √† partir de ... <br>  var - affiche les valeurs de toutes les variables d√©clar√©es. <br><br>  Le format de communication de l'utilisateur avec le d√©bogueur est laiss√© √† la discr√©tion ci-dessus.  Vous pouvez choisir soit une interface minimaliste de type GDB, soit une console ou une interface graphique.  Les noms des commandes du d√©bogueur peuvent √™tre modifi√©s si vous le souhaitez. <br><br>  Pour r√©soudre ce probl√®me, vous pouvez utiliser n'importe quel langage de programmation de TIOBE TOP 50 et un compilateur / interpr√®te open-source. <br><br>  Lors de l'√©valuation du travail sera √©valu√©: <br><br>  La performance globale du programme; <br>  La qualit√© du code source et la disponibilit√© des tests; <br>  Fonctionnalit√© facile √† √©tendre (par exemple, prise en charge de nouvelles instructions de langue ou instructions de d√©bogage). <br>  Une solution avec des instructions pour la construire doit √™tre publi√©e dans le r√©f√©rentiel Git (par exemple, sur GitHub ou BitBucket).  Dans la r√©ponse, vous devez sp√©cifier un lien vers le r√©f√©rentiel.  Un lien vers un r√©f√©rentiel GitHub priv√© convient √©galement, vous seul devrez y ajouter. <br></div></div><br>  J'√©cris en C ++, Java et Object Pascal. <br><br>  Au d√©but, il y avait des pens√©es pour tout √©crire dans mon m√™me MPS, mais je pensais que ce ne serait pas tr√®s pratique de v√©rifier pour un employ√© JB, et j'ai soumis la candidature 2 jours avant la cl√¥ture de la soumission (examens tout de m√™me ...), et c'√©tait d√©j√† le soir devant la fen√™tre - j'ai d√©cid√© d'√©crire rapidement tout dans des langues plus connues. <br><br>  √Ä mon avis, Pascal est le plus appropri√© pour r√©soudre le probl√®me, au moins en raison de la mise en ≈ìuvre la plus pratique des cha√Ænes ... <br><br>  Du moins pour moi.  De plus, il est dans TIOBE TOP 50, j'ai donc lanc√© hardiment l'IDE, √† savoir Lazarus, car  il n'est pas commercial :) et se mit √† r√©soudre le probl√®me. <br><br>  Malgr√© le fait qu'ils donnent √† JB jusqu'√† 7 jours, cela m'a pris environ une heure pour terminer le projet, et le projet s'est av√©r√© √™tre environ 500 lignes de code. <br><br><h3>  Par o√π commencer? </h3><br>  Tout d'abord, vous devez imaginer comment le d√©bogage de code fonctionnera √† la fin. <br><br>  Nous devons impl√©menter l'ex√©cution de code √©tape par √©tape - cela signifie que chaque instruction doit √™tre pr√©sent√©e sous la forme d'une structure / classe et, en g√©n√©ral, les instructions doivent ressembler √† une liste de ces classes ou, comme dans mon impl√©mentation, se r√©f√©rer les unes aux autres formant une s√©quence (je noterai pourquoi je l'ai fait plus tard). <br><br>  Pour obtenir cette s√©quence, notre d√©bogueur doit traiter le code dans le langage propos√©, ce qui signifie que nous devons √©galement impl√©menter un petit analyseur, ainsi qu'une analyse syntaxique et s√©mantique du code. <br><br>  Commen√ßons par l'impl√©mentation de l'analyseur.  Parce que  √âtant donn√© que la langue Guu se compose d'un ensemble de jetons, s√©par√©s par un espace, il est logique d'√©crire d'abord un petit et simple tokenizer: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; tokenNum: word)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := Trim(s); s := StringReplace(s, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, [rfReplaceAll]); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> tokenNum &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, <span class="hljs-number"><span class="hljs-number">1</span></span>, p) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; dec(tokenNum); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, p, Length(s)); Result := s; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Ensuite, d√©clarez l'√©num√©ration des jetons: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuToken = (opSub, opSet, opCall, opPrint, opUnknown); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GuuToken: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[opSub..opPrint] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ( <span class="hljs-string"><span class="hljs-string">'sub'</span></span>, <span class="hljs-string"><span class="hljs-string">'set'</span></span>, <span class="hljs-string"><span class="hljs-string">'call'</span></span>, <span class="hljs-string"><span class="hljs-string">'print'</span></span> );</code> </pre><br>  Et la classe d'instruction elle-m√™me, dans laquelle nous analyserons les lignes de code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpType : TGuuToken; OpArgs : TStringList; OpLine : Cardinal; OpUnChangedLine: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; NextOp : TGuuOp; OpReg : Pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dans OpType, l'instruction sera stock√©e, dans OpArgs - le reste de la construction. <br>  OpLine, OpUnChangedLine - informations pour le d√©bogueur. <br><br>  NextOp est un pointeur vers l'instruction suivante.  S'il est √©gal √† nil (null en Pascal), il n'y a pas d'autres instructions et vous devez compl√©ter le code ou retourner via la pile de rappel. <br><br>  OpReg est un petit registre de pointeurs, qui sera utilis√© plus tard pour une petite optimisation de l'ex√©cution du code. <br><br>  Apr√®s la d√©claration de classe a √©t√© √©crite - j'ai d√©cid√© que la solution la plus compacte et la plus belle serait d'ajouter l'analyseur et un peu d'analyse dans son constructeur, ce que j'ai fait ensuite: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * That method parse code line. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; w: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; OpArgs := TStringList.Create; OpLine := LineNum; OpUnChangedLine := Line; NextOp := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; OpReg := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; s := GetToken(Line, <span class="hljs-number"><span class="hljs-number">1</span></span>); OpType := TGuuToken(AnsiIndexStr(s, GuuToken)); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub : <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// sub &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "sub" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opSet : begin // set &lt;var&gt; &lt;value&gt; OpArgs.Add(GetToken(Line, 2)); OpArgs.Add(GetToken(Line, 3)); w := 1; while w &lt; Length(OpArgs[1]) + 1 do begin if not (OpArgs[1][w] in ['0'..'9']) then begin writeln('[Syntax error]: Invalid variable assigment "', Line, '" at line ', OpLine, '.'); halt; end; inc(w); end; if (Length(OpArgs[0]) = 0) or (Length(OpArgs[1]) = 0) or (Length(GetToken(Line, 4)) &gt; 0) then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end end; opCall : begin // call &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "call" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opPrint: begin // print &lt;var&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "print" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; else begin writeln('[Syntax error]: Invalid token "', s, '" at line ', OpLine, '.'); halt; end; end; end; destructor TGuuOp.Destroy; begin FreeAndNil(OpArgs); inherited; end;</span></span></code> </pre><br>  Ici, nous v√©rifions essentiellement le d√©but de la construction (c'est-√†-dire le premier mot), puis regardons les jetons restants et leur nombre.  Si quelque chose ne va clairement pas avec le code, nous affichons une erreur. <br><br>  Dans le morceau de code principal, nous lisons simplement le code dans la TStringList du fichier, appelons les constructeurs TGuuOp ligne par ligne et enregistrons les pointeurs vers les instances de classe dans GuuOps: TList. <br><br>  Annonces: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LabelNames: TStringList; GuuOps, GuuVars: TList; SubMain: TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>;</code> </pre><br>  Avec l'analyse de code, il serait int√©ressant d'effectuer quelques actions suppl√©mentaires: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Parsing code lines and define variables and labels. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; GV: TGuuVar; c: cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Trim(Line) &lt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp.Create(LineNum, Line); GuuOps.Add(Op); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Op.OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// define variable and/or optimisation var calling GV := nil; c := 0; while c &lt; GuuVars.Count do begin if TGuuVar(GuuVars[c]).gvName = Op.OpArgs[0] then begin GV := TGuuVar(GuuVars[c]); break; end; inc(c); end; if GV = nil then begin GV := TGuuVar.Create(Op.OpArgs[0]); GuuVars.Add(GV); end; Op.OpReg := GV; end; opSub: begin // Check for label dublicade declaration if Op.OpArgs[0] = 'main' then SubMain := Op; if LabelNames.IndexOf(Op.OpArgs[0]) &lt;&gt; -1 then begin writeln('[Error]: Dublicate sub "', Op.OpArgs[0], '" declaration at line ', Op.OpLine, '.'); halt; end else LabelNames.Add(Op.OpArgs[0]); end; end; end; end;</span></span></code> </pre><br>  √Ä ce stade, vous pouvez v√©rifier les points d'entr√©e au moment de la red√©finition et penser √† OpReg - je l'ai utilis√© pour stocker un pointeur sur une variable Guu. <br><br>  En parlant de variables, j'ai pris ce petit morceau de code dans une unit√© distincte: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uVars; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuVar = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> gvName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; gvVal: variant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuVar</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; gvName := VarName; gvVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  Nous avons maintenant un code analys√© qui semble √™tre correct dans la syntaxe.  Il reste √† l'analyser et vous pouvez commencer √† effectuer la chose la plus importante - le d√©bogage. <br><br>  Ensuite, vous devez impl√©menter une petite analyse s√©mantique et pr√©parer simultan√©ment tout pour l'ex√©cution de code et le d√©bogage: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSemantic</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Semantic analyse and calls optimisation. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c, x: cardinal; op: TGuuOp; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GuuOps.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpType &lt;&gt; opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Operation outside sub at line '</span></span>, TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; c := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> c &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TGuuOp(GuuOps[c]).OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub:; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; op := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpType = opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> op := TGuuOp(GuuOps[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> TGuuOp(GuuOps[c]).OpReg := op <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Calling to not exist sub "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuVars.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuVar(GuuVars[x]).gvName = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c]).OpReg := TGuuVar(GuuVars[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[c]).OpReg = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Variable "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" for print doesn''t exist at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(c); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dans TGuuOp.NextOp de chaque jeton, √©crivez un pointeur sur le jeton suivant. <br>  Pour l'opcode call, nous le faisons d√©licat et simple - dans NextOp, nous √©crivons un pointeur vers le point d'entr√©e appel√©. <br><br>  Nous v√©rifions √©galement les variables de sortie via l'instruction print ... <br><br>  Peut-√™tre qu'ils n'ont pas √©t√© annonc√©s avant la conclusion? <br><br>  Vous devez maintenant impl√©menter l'ex√©cution de code.  Revenez √† la classe TGuuOp et impl√©mentez la m√©thode Step: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-comment"><span class="hljs-comment">(* * That method execute instruction. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; CBSize: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Trace.Add(<span class="hljs-string"><span class="hljs-string">'-&gt; Sub "'</span></span> + OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StepInto <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NextOp &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallBacks.Add(NextOp); Result := TGuuOp(OpReg); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(OpReg); CBSize := CallBacks.Count; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((Op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (CallBacks.Count &gt; CBSize)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Op = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]); CallBacks.Delete(CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Trace.Delete(Trace.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Op := Op.Step(StepInto, CallBacks, Trace); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(TGuuVar(OpReg).gvName, <span class="hljs-string"><span class="hljs-string">' = '</span></span>, TGuuVar(OpReg).gvVal); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuVar(OpReg).gvVal := OpArgs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Pour √©viter la violation d'acc√®s en cas de boucle - il est pr√©f√©rable de limiter la pile, ce que j'ai fait. <br>  La constante STACK_SIZE = 2048, d√©clar√©e ci-dessus est juste responsable de cela. <br><br>  Il est maintenant temps d'√©crire le code principal de notre d√©bogueur: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code: TStringList; c: Cardinal; cmd: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; CallBacks: TList; Trace: TStringList; DebugMode: boolean = true; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ParamCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// Initialisation if not FileExists(ParamStr(1)) then begin writeln('[Error]: Can''t open file "', ParamStr(1), '".'); halt; end; if ParamCount &gt; 1 then if LowerCase(ParamStr(2)) = '/run' then DebugMode := false; code := TStringList.Create; code.LoadFromFile(ParamStr(1)); GuuOps := TList.Create; GuuVars := TList.Create; // Parsing and preparing LabelNames := TStringList.Create; c := 0; while c &lt; code.Count do begin ParseNext(c + 1, Trim(code[c])); inc(c); end; FreeAndNil(LabelNames); CheckSemantic; if SubMain = nil then begin writeln('[Error]: Sub "main" doesn''t exist!'); halt; end; // Start code execution CurrentOp := SubMain; CallBacks := TList.Create; Trace := TStringList.Create; if DebugMode then begin //Out code and features ClrScr; writeln('Code for debugging:'); writeln('.....'); c := 0; while c &lt; code.Count do begin writeln(FillSpaces(IntToStr(c + 1), 4), '| ', code[c]); inc(c); end; writeln('"""""'); FreeAndNil(code); writeln(sLineBreak, 'Features:', sLineBreak, '* i - step into.', sLineBreak, '* o - step over.', sLineBreak, '* trace - print stack trace.', sLineBreak, '* var - print variables list.', sLineBreak, '* x - exit.', sLineBreak); // Execution loop while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin write('Line ', CurrentOp.OpLine, ' ~&gt; '); readln(cmd); // Execute commands if cmd = 'i' then CurrentOp := CurrentOp.Step(true, CallBacks, Trace) else if cmd = 'o' then CurrentOp := CurrentOp.Step(false, CallBacks, Trace) else if cmd = 'trace' then begin writeln('| Trace:'); c := 0; while c &lt; Trace.Count do begin writeln('| ', Trace[c]); inc(c); end; writeln('| -&gt; Line ', CurrentOp.OpLine, ': "', CurrentOp.OpUnChangedLine, '".') end else if cmd = 'var' then begin writeln('| Variables list:'); c := 0; while c &lt; GuuVars.Count do begin writeln('| ', TGuuVar(GuuVars[c]).gvName, ' = ', TGuuVar(GuuVars[c]).gvVal); inc(c); end; end else if cmd = 'x' then halt; // Check for method end &amp; make callback if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end else begin // Only run mode (/run) FreeAndNil(code); while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin CurrentOp := CurrentOp.Step(false, CallBacks, Trace); if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end; if Trace.Count &gt;= STACK_SIZE then writeln('[Runtime error]: Stack overflow!'); FreeAndNil(CallBacks); FreeAndNil(Trace); end else writeln( 'Guu debugger v1.0.', sLineBreak, 'Author: Pavel Shiryaev (@RoPi0n).', sLineBreak, 'Run: svmc guu_debugger.vmc &lt;guu source file&gt; [arg]', sLineBreak, 'Args:', sLineBreak, ' /run - Run Guu code.' ); end.</span></span></code> </pre><br>  Selon l'√©tat du travail, l'interface peut √™tre impl√©ment√©e comme vous le souhaitez. <br><br>  Il serait possible d'impl√©menter une interface utilisateur √† part enti√®re, visser SynEdit au projet, mais √† mon avis, c'est un travail vide qui ne refl√©tera pas la comp√©tence, et en plus il ne sera pas pay√© :) <br><br>  Je me suis donc limit√© √† une petite interface utilisateur de console. <br><br>  Le code ci-dessus n'est pas compliqu√©, vous pouvez donc le laisser sans commentaire.  Dans ce document, nous prenons des TGuuOp pr√™ts √† l'emploi et les appelons Step. <br><br>  Captures d'√©cran du probl√®me r√©solu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33e/ad0/efa/33ead0efa3a07d77d1a6c07010847035.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e1/7eb/41e/3e17eb41e99abece612f09b146464f67.jpg" alt="image"><br><br>  Sortie d'informations d'erreur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/1c5/ea4/6591c5ea44e67f5068bd7fb0e9c2341e.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a0/3f0/733/2a03f07336c5af1333f259d43e4a1396.jpg" alt="image"><br><br>  Lien vers le r√©f√©rentiel de ma solution: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cliquez sur</a> <br><br><h3>  R√©sum√© </h3><br>  Il n'y a pas de r√©sultats particuliers.  Je vais devoir consacrer la majeure partie de l‚Äô√©t√© √† des vacances bien remplies et chercher une universit√© (enfin, au cas o√π je r√©ussirais bien l‚Äôexamen, bien s√ªr), au lieu de deux mois de travail et de formation dans l‚Äô√©quipe JetBrains. <br><br>  Peut-√™tre que l'ann√©e prochaine un nouveau billet appara√Ætra sur Habr√©, d√©crivant d√©j√† le processus de stage chez JB ou dans une autre entreprise qui m'int√©resse :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454354/">https://habr.com/ru/post/fr454354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454336/index.html">Client: - Combien co√ªte une copie de Facebook?</a></li>
<li><a href="../fr454340/index.html">% tutnazvanievu% est la premi√®re universit√© au monde o√π les jetpacks sont officiellement d√©velopp√©s</a></li>
<li><a href="../fr454346/index.html">Algorithmes d'efficacit√©: examen de la cam√©ra de surveillance Nobelic 2019</a></li>
<li><a href="../fr454348/index.html">Gestion de l'√©tat avec React Hooks - Sans Redux et Context API</a></li>
<li><a href="../fr454352/index.html">Incertitudes math√©matiques en Python</a></li>
<li><a href="../fr454356/index.html">Habr Weekly # 3 / Runet vs TV, ARM vs Intel, unification des donn√©es d'√âtat, sans smartphone en 2019, r√™ves sovi√©tiques d'avenir</a></li>
<li><a href="../fr454366/index.html">Victoire aux PHDays 9. Nous partageons les hacks de vie en trois parties. 2e partie</a></li>
<li><a href="../fr454368/index.html">Concours de d√©veloppeurs de plugins TeamCity</a></li>
<li><a href="../fr454372/index.html">Nouvelles hebdomadaires: Huawei a toujours des probl√®mes, "t√©l√©phone quantique" dans la F√©d√©ration de Russie, ARM a de nouveaux processeurs</a></li>
<li><a href="../fr454374/index.html">L'imprimante 3D photo-polym√®re √† partir d'un vid√©oprojecteur √† domicile cr√©e des objets sans couches</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>