<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏼 🐔 🏂🏽 Révolution ou douleur? Rapport Yandex React Hooks ➕ 🎷 🥣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je m'appelle Artyom Berezin, je suis développeur de plusieurs services internes Yandex. Depuis six mois, je travaille activement avec React Hooks. Ce ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Révolution ou douleur? Rapport Yandex React Hooks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/464071/"> Je m'appelle Artyom Berezin, je suis développeur de plusieurs services internes Yandex.  Depuis six mois, je travaille activement avec React Hooks.  Ce faisant, il y a eu des difficultés à surmonter.  Maintenant, je veux partager cette expérience avec vous.  Dans le rapport, j'ai examiné l'API React Hook d'un point de vue pratique - pourquoi avons-nous besoin de hooks, vaut-il la peine de changer, ce qui est préférable de prendre en compte lors du portage.  Il est facile de faire des erreurs pendant la transition, mais les éviter n'est pas non plus si difficile. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/xm/xa/7n/xmxa7ngpjx3l902ndjcetpyhsp0.jpeg"></a> <br><br>  - Les crochets ne sont qu'une autre façon de décrire la logique de vos composants.  Il vous permet d'ajouter aux composants fonctionnels des fonctionnalités qui n'étaient auparavant inhérentes qu'aux composants des classes. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/hd/r8/4b/hdr84b-fmfibqz-gwcb0k8feny8.jpeg"><br><br>  Tout d'abord, c'est le soutien de l'état interne, puis - le soutien des effets secondaires.  Par exemple - demandes de réseau ou demandes à WebSocket: abonnement, désabonnement de certains canaux.  Ou, peut-être, nous parlons de demandes à d'autres API de navigateur asynchrones ou synchrones.  De plus, les crochets nous donnent accès au cycle de vie du composant, à son début de vie, c'est-à-dire au montage, à la mise à jour de ses accessoires et à sa mort. <br><br><img src="https://habrastorage.org/webt/9d/f4/lk/9df4lk5afueo28ftgmebxggxuw0.jpeg"><br><br>  Probablement la façon la plus simple d'illustrer en comparaison.  Voici le code le plus simple qui ne peut être qu'avec un composant dans les classes.  Le composant change quelque chose.  Il s'agit d'un compteur régulier qui peut être augmenté ou diminué, un seul champ en état.  En général, je pense que si vous êtes familier avec React, le code est complètement évident pour vous. <br><br><img src="https://habrastorage.org/webt/iy/ms/2_/iyms2_hexuxc_nx5cnxwux8crva.jpeg"><br><br>  Un composant similaire qui remplit exactement la même fonction, mais écrit dans des crochets, semble beaucoup plus compact.  Selon mes calculs, en moyenne, lors du portage de composants sur des classes vers des composants sur des crochets, le code diminue environ une fois et demie, et cela plaît. <br><br>  Quelques mots sur le fonctionnement des crochets.  Un hook est une fonction globale déclarée dans React et appelée à chaque fois qu'un composant est rendu.  React suit les appels à ces fonctions et peut changer son comportement ou décider ce qu'il doit retourner. <br><br><img src="https://habrastorage.org/webt/yy/wy/xf/yywyxfylah95eiqs8saijtqbf-a.jpeg"><br><br>  Il existe certaines restrictions sur l'utilisation des crochets qui les distinguent des fonctions ordinaires.  Tout d'abord, ils ne peuvent pas être utilisés dans des composants sur des classes, une telle restriction s'applique simplement car ils ne sont pas créés pour eux, mais pour des composants fonctionnels.  Les crochets ne peuvent pas être appelés à l'intérieur de fonctions internes, à l'intérieur de boucles, de conditions.  Uniquement au premier niveau d'imbrication, à l'intérieur des fonctions du composant.  Cette restriction est imposée par React lui-même afin de pouvoir suivre les hooks appelés.  Et il les empile dans un certain ordre dans son cerveau.  Ensuite, si cet ordre change soudainement ou si certains disparaissent, des erreurs complexes, insaisissables, difficiles à déboguer sont possibles. <br><br>  Mais si vous avez une logique assez compliquée et que vous souhaitez utiliser, par exemple, des crochets à l'intérieur des crochets, alors c'est très probablement un signe que vous devez faire un crochet.  Supposons que vous établissiez plusieurs crochets connectés les uns aux autres dans un crochet personnalisé séparé.  Et à l'intérieur, vous pouvez utiliser d'autres crochets personnalisés, créant ainsi une hiérarchie de crochets, mettant en évidence la logique générale. <br><br><img src="https://habrastorage.org/webt/wr/av/h_/wravh_lbocryqocrjlnwqs8rrr4.jpeg"><br><br>  Les crochets offrent certains avantages par rapport aux cours.  Tout d'abord, comme suit du précédent, en utilisant des crochets personnalisés, vous pouvez tâtonner beaucoup plus facilement la logique.  Auparavant, en utilisant l'approche avec des composants d'ordre supérieur, nous avons présenté une sorte de logique partagée, et c'était un wrapper sur le composant.  Maintenant, nous mettons cette logique à l'intérieur des crochets.  Ainsi, l'arborescence des composants est réduite: son imbrication est réduite et il devient plus facile pour React de suivre les modifications des composants, de recalculer l'arborescence, de recalculer le DOM virtuel, etc. Cela résout le problème de ce que l'on appelle l'enveloppeur-enfer.  Ceux qui travaillent avec Redux, je pense, le savent. <br><br>  Le code écrit à l'aide de crochets est beaucoup plus facile à minimiser avec des minimiseurs modernes comme Terser ou UglifyJS ancien.  Le fait est que nous n'avons pas besoin de sauvegarder les noms des méthodes, nous n'avons pas besoin de penser aux prototypes.  Après la transpilation, si la cible est ES3 ou ES5, nous obtenons généralement un tas de prototypes qui corrigent.  Ici, tout cela n'a pas besoin d'être fait, il est donc plus facile de le minimiser.  Et, comme nous n'utilisons pas de classes, nous n'avons pas besoin d'y penser.  Pour les débutants, c'est souvent un gros problème et, probablement, l'une des principales raisons des bugs: nous oublions que cela peut être une fenêtre, que nous devons lier une méthode, par exemple, dans le constructeur ou d'une autre manière. <br><br>  De plus, l'utilisation de crochets vous permet de mettre en évidence la logique qui contrôle tout effet secondaire.  Auparavant, cette logique, en particulier lorsque nous avions plusieurs effets secondaires pour un composant, devait être divisée en différentes méthodes du cycle de vie du composant.  Et, depuis l'apparition des crochets de minimisation, React.memo est apparu, maintenant les composants fonctionnels se prêtent à la mémorisation, c'est-à-dire que ce composant ne sera pas recréé ou mis à jour avec nous si ses accessoires n'ont pas changé.  Cela ne pouvait pas être fait avant, maintenant c'est possible.  Tous les composants fonctionnels peuvent être enveloppés dans un mémo.  Également à l'intérieur du crochet useMemo est apparu, que nous pouvons utiliser pour calculer certaines valeurs lourdes, ou instancier certaines classes utilitaires une seule fois. <br><br>  Le rapport sera incomplet si je ne parle pas de quelques crochets de base.  Tout d'abord, ce sont des crochets de gestion d'état. <br><br><img src="https://habrastorage.org/webt/ud/wg/vl/udwgvlovxonthzvnknxeewerxea.jpeg"><br><br>  Tout d'abord - useState. <br><br><img src="https://habrastorage.org/webt/0c/xb/pk/0cxbpky3iayxkvaxutbik_ohbcw.jpeg"><br><br>  Un exemple est similaire à celui du début du rapport.  useState est une fonction qui prend une valeur initiale et renvoie un tuple à partir de la valeur actuelle et de la fonction pour modifier cette valeur.  Toute magie est servie par React en interne.  Nous pouvons simplement lire cette valeur ou la modifier. <br><br>  Contrairement aux classes, nous pouvons utiliser autant d'objets d'état que nécessaire, divise l'état en éléments logiques afin de ne pas les mélanger dans un seul objet, comme dans les classes.  Et ces pièces seront complètement isolées les unes des autres: elles peuvent être changées indépendamment les unes des autres.  Le résultat, par exemple, de ce code: on change deux variables, on calcule le résultat et on affiche les boutons qui nous permettent de changer la première variable ici et là, et la deuxième variable ici et là.  Rappelez-vous cet exemple, car plus tard, nous ferons une chose similaire, mais beaucoup plus compliquée. <br><br><img src="https://habrastorage.org/webt/qh/cb/7r/qhcb7rezzu2hu5ymyqw8nw1bl9e.jpeg"><br><br>  Il existe un tel useState sur les stéroïdes pour les amateurs de Redux.  Il vous permet de changer l'état de manière plus cohérente à l'aide d'un réducteur.  Je pense que ceux qui connaissent Redux ne peuvent même pas expliquer, pour ceux qui ne sont pas familiers, je vais le dire. <br><br>  Un réducteur est une fonction qui accepte un état et un objet, généralement appelé action, qui décrit comment cet état doit changer.  Plus précisément, il passe certains paramètres, et à l'intérieur du réducteur, il décide déjà, en fonction de leurs paramètres, de la façon dont l'état va changer, et par conséquent, un nouvel état doit être renvoyé, mis à jour. <br><br><img src="https://habrastorage.org/webt/k6/5x/gd/k65xgdpidy6wnhmuxabw3sqqtk0.jpeg"><br><br>  De cette façon, il est utilisé dans le code du composant.  Nous avons un crochet useReducer, il prend une fonction de réducteur, et le deuxième paramètre est la valeur initiale de l'état.  Renvoie, comme useState, l'état actuel et la fonction pour le modifier est dispatch.  Si vous transmettez un objet action à envoyer, nous invoquerons un changement d'état. <br><br><img src="https://habrastorage.org/webt/un/sl/ng/unslngsedmksssjrthxjmzhn7bu.jpeg"><br><br>  Utilisation très importante Crochet effet.  Il vous permet d'ajouter des effets secondaires au composant, offrant une alternative au cycle de vie.  Dans cet exemple, nous utilisons une méthode simple avec useEffect: il s'agit simplement de demander des données au serveur, avec l'API, par exemple, et d'afficher ces données sur la page. <br><br><img src="https://habrastorage.org/webt/bb/tc/gf/bbtcgfyw89tgu_jarnwwaagxmnq.jpeg"><br><br>  UseEffect a un mode avancé, c'est lorsque la fonction passée à useEffect renvoie une autre fonction, alors cette fonction sera appelée dans le cycle suivant, lorsque cet useEffect sera appliqué. <br><br>  J'ai oublié de mentionner, useEffect est appelé de manière asynchrone, juste après que le changement soit appliqué au DOM.  Autrement dit, il garantit qu'il sera exécuté après le rendu du composant et peut conduire au rendu suivant si certaines valeurs changent. <br><br><img src="https://habrastorage.org/webt/gl/yd/cj/glydcjxiui-c60mgjzhnfobsqcm.jpeg"><br><br>  Nous rencontrons ici pour la première fois un concept tel que les dépendances.  Certains hooks - useEffect, useCallback, useMemo - prennent un tableau de valeurs comme deuxième argument, ce qui nous permettra de dire quoi suivre.  Les changements dans ce tableau conduisent à une sorte d'effets.  Par exemple, ici, hypothétiquement, nous avons une sorte de composant pour choisir un auteur dans une liste.  Et une assiette avec des livres de cet auteur.  Et lorsque l'auteur change, useEffect sera appelé.  Lorsque cet authorId est modifié, une demande sera appelée et les livres seront chargés. <br><br>  En outre, je mentionnerai en passant des crochets comme useRef, c'est une alternative à React.createRef, quelque chose de similaire à useState, mais les modifications apportées à ref ne conduisent pas au rendu.  Parfois pratique pour certains hacks.  useImperativeHandle nous permet de déclarer certaines «méthodes publiques» sur le composant.  Si vous utilisez useRef dans le composant parent, il peut extraire ces méthodes.  Pour être honnête, je l'ai essayé une fois à des fins éducatives, dans la pratique, ce n'était pas utile.  useContext est juste une bonne chose, il vous permet de prendre la valeur actuelle du contexte si le fournisseur a défini cette valeur quelque part plus haut dans le niveau de la hiérarchie. <br><br>  Il existe un moyen d'optimiser les applications React sur les hooks: la mémorisation.  La mémorisation peut être divisée en interne et externe.  D'abord à l'extérieur. <br><br><img src="https://habrastorage.org/webt/ao/wq/-e/aowq-evnbye1bnr6lspo9sthw9y.jpeg"><br><br>  Il s'agit de React.memo, pratiquement une alternative à la classe React.PureComponent, qui suivait les changements d'accessoires et les composants modifiés uniquement lorsque les accessoires ou l'état changeaient. <br><br>  Ici, une chose similaire, cependant, sans État.  Il surveille également les modifications des accessoires et si les accessoires ont changé, un rendu se produit.  Si les accessoires n'ont pas changé, le composant n'est pas mis à jour et nous économisons sur cela. <br><br><img src="https://habrastorage.org/webt/lk/0l/dn/lk0ldneyzriaeesmzxfnvvkl1h4.jpeg"><br><br>  Méthodes internes d'optimisation.  Tout d'abord, c'est une chose de bas niveau - useMemo, rarement utilisé.  Il vous permet de calculer une valeur et de la recalculer uniquement si les valeurs spécifiées dans les dépendances ont changé. <br><br><img src="https://habrastorage.org/webt/ve/fs/ml/vefsmlmbjqbg6-1lejt5_qofoow.jpeg"><br><br>  Il existe un cas particulier de useMemo pour une fonction appelée useCallback.  Il est principalement utilisé pour mémoriser la valeur des fonctions de gestionnaire d'événements qui seront transmises aux composants enfants afin que ces composants enfants ne puissent plus être rendus.  Il est utilisé simplement.  Nous décrivons une certaine fonction, l'enveloppons dans useCallback et indiquons de quelles variables elle dépend. <br><br>  Beaucoup de gens ont une question, mais en avons-nous besoin?  Avons-nous besoin de crochets?  Déménageons-nous ou restons-nous comme avant?  Il n'y a pas de réponse unique, tout dépend des préférences.  Tout d'abord, si vous êtes directement lié de manière rigide à la programmation orientée objet, si vos composants, vous y êtes habitué en tant que classe, ils ont des méthodes qui peuvent être extraites, alors, probablement, cette chose peut vous sembler superflue.  En principe, il m'a semblé, lorsque j'ai entendu parler des crochets pour la première fois, que c'était trop compliqué, une sorte de magie était ajoutée, et on ne savait pas pourquoi. <br><br>  Pour les amateurs de fonctionnalités, c'est, disons, un incontournable, car les hooks sont des fonctions, et des techniques de programmation fonctionnelle leur sont applicables.  Par exemple, vous pouvez les combiner ou faire n'importe quoi, en utilisant, par exemple, des bibliothèques telles que Ramda, etc. <br><br><img src="https://habrastorage.org/webt/du/k4/n7/duk4n7l_1_are_xjgrkf4vvbccy.jpeg"><br><br>  Depuis que nous nous sommes débarrassés des classes, nous n'avons plus besoin de lier ce contexte aux méthodes.  Si vous utilisez ces méthodes comme rappels.  Habituellement, c'était un problème, car vous deviez vous rappeler de les lier dans le constructeur, ou d'utiliser une extension non officielle de la syntaxe du langage, comme des fonctions fléchées comme propriété.  Pratique assez courante.  J'ai utilisé mon décorateur, qui est aussi, en principe, expérimental, sur les méthodes. <br><br><img src="https://habrastorage.org/webt/pn/ew/fi/pnewfifb1wwktxkbddh1zqqk-os.jpeg"><br><br>  Il y a une différence dans la façon dont le cycle de vie fonctionne, comment le gérer.  Les crochets associent presque toutes les actions du cycle de vie au crochet useEffect, qui vous permet de vous abonner à la naissance et à la mise à jour d'un composant et à sa mort.  Dans les classes, pour cela, nous avons dû redéfinir plusieurs méthodes, telles que componentDidMount, componentDidUpdate et componentWillUnmount.  De plus, la méthode shouldComponentUpdate peut désormais être remplacée par React.memo. <br><br><img src="https://habrastorage.org/webt/7d/ae/qy/7daeqyxv0yh0on4i1wcdsraoaws.jpeg"><br><br>  Il y a une assez petite différence dans la façon dont l'État est géré.  Tout d'abord, les classes ont un objet d'état.  Nous avons dû entasser n'importe quoi là-bas.  Dans les crochets, nous pouvons diviser l'état logique en quelques morceaux, qu'il serait pratique pour nous d'opérer séparément. <br><br>  setState () des composants sur les classes autorisés à spécifier un patch d'état, modifiant ainsi un ou plusieurs champs de l'état.  Dans les crochets, nous devons changer l'état entier dans son ensemble, et c'est même bien, car il est à la mode d'utiliser toutes sortes de choses immuables et de ne jamais s'attendre à ce que nos objets mutent.  Ils sont toujours nouveaux avec nous. <br><br>  La principale caractéristique des classes que les hooks n'ont pas: on pourrait s'abonner aux changements d'état.  Autrement dit, nous changeons l'état et souscrivons immédiatement à ses modifications, en traitant impérativement quelque chose immédiatement après l'application des modifications.  Dans les crochets, cela ne fonctionne tout simplement pas.  Cela doit être fait d'une manière très intéressante, je vous le dirai plus loin. <br><br>  Et un peu sur la façon fonctionnelle de mettre à jour.  Cela fonctionne à la fois là et là, lorsque les fonctions de changement d'état acceptent une autre fonction, que cet état ne doit pas changer, mais plutôt créer.  Et si dans le cas du composant class, il peut nous renvoyer une sorte de patch, alors dans les hooks, nous devons renvoyer la toute nouvelle valeur. <br><br>  En général, il est peu probable que vous obteniez une réponse, que vous déménagiez ou non.  Mais je conseille au moins d'essayer, au moins pour le nouveau code, de le ressentir.  Lorsque je viens de commencer à travailler avec des crochets, j'ai immédiatement identifié plusieurs crochets personnalisés qui me conviennent pour mon projet.  Fondamentalement, j'ai essayé de remplacer certaines des fonctionnalités que j'avais mises en œuvre via des composants d'ordre supérieur. <br><br><img src="https://habrastorage.org/webt/d6/cs/1-/d6cs1-ebiop8wbrdgnrr93wskqm.jpeg"><br><br>  useDismounted - pour ceux qui connaissent RxJS, il est possible de se désabonner massivement de tous les observables dans un seul composant ou dans une seule fonction, en abonnant chaque observable à un objet spécial, sujet, et lorsqu'il est fermé, tous les abonnements sont annulés.  C'est très pratique si le composant est complexe, s'il y a beaucoup d'opérations asynchrones à l'intérieur de l'Observable, il est pratique de se désinscrire de tout à la fois, et non de chacun séparément. <br><br>  useObservable renvoie une valeur d'Observable quand une nouvelle apparaît là.  Un hook useBehaviourSubject similaire revient de BehaviourSubject.  Sa différence avec Observable est qu'elle a initialement une signification. <br><br>  Le crochet personnalisé pratique useDebounceValue nous permet d'organiser, par exemple, une requête pour la chaîne de recherche, de sorte que chaque fois que vous n'appuyez pas sur une touche, n'envoyez pas quelque chose au serveur, mais attendez que l'utilisateur ait fini de taper. <br><br>  Deux crochets similaires.  useWindowResize renvoie les valeurs réelles actuelles des tailles de fenêtre.  Le crochet suivant pour la position de défilement est useWindowScroll.  Je les utilise pour raconter certaines fenêtres contextuelles ou fenêtres modales, s'il y a des choses compliquées qui ne peuvent tout simplement pas être faites avec CSS. <br><br>  Et un si petit crochet pour implémenter des touches de raccourci, dont le composant, lorsqu'il est présent sur la page, il est abonné à une touche de raccourci.  À sa mort, une désinscription automatique se produit. <br><br>  À quoi servent ces crochets personnalisés?  Que nous pouvons entasser un désabonnement à l'intérieur du crochet, et nous n'avons pas à penser à désinscrire manuellement quelque part dans le composant où ce crochet est utilisé. <br><br>  Il n'y a pas si longtemps, ils m'ont jeté un lien vers la bibliothèque React-Use, et il s'est avéré que la plupart de ces crochets personnalisés y étaient déjà implémentés.  Et j'ai écrit un vélo.  C'est parfois utile, mais à l'avenir, très probablement, je vais probablement les jeter et utiliser React-Use.  Et je vous conseille également de voir si vous comptez utiliser des crochets. <br><br><img src="https://habrastorage.org/webt/03/ls/_r/03ls_rryjcv9gax_wky56kv0hye.jpeg"><br><br>  En fait, l'objectif principal du rapport est de montrer comment écrire de manière incorrecte, quels problèmes peuvent être et comment les éviter.  La toute première chose, probablement ce que quiconque étudie ces crochets et essaie d'écrire quelque chose, est d'utiliser incorrectement useEffect.  Voici le code similaire à celui que 100% tout le monde a écrit s'il essayait des hooks.  Cela est dû au fait que useEffect est initialement perçu mentalement, comme une alternative à componentDidMount.  Mais, contrairement à componentDidMount, qui n'est appelé qu'une seule fois, useEffect est appelé sur chaque rendu.  Et l'erreur ici est qu'elle change, disons, la variable de données, et en même temps la changer conduit à un rendu de composant, par conséquent, l'effet sera redemandé.  Ainsi, nous obtenons une série sans fin de demandes AJAX au serveur, et le composant lui-même se met constamment à jour, met à jour, met à jour. <br><br><img src="https://habrastorage.org/webt/ds/jw/cl/dsjwclnhk6kvmnmkxjw04vdrqd8.jpeg"><br><br>  Le réparer est très simple.  Vous devez ajouter ici un tableau vide de ces dépendances dont il dépend, et les modifications qui redémarreront l'effet.  Si nous avons une liste vide de dépendances spécifiée ici, l'effet, en conséquence, ne sera pas redémarré.  Ce n'est pas une sorte de hack, c'est une fonctionnalité de base de l'utilisation de useEffect. <br><br><img src="https://habrastorage.org/webt/tx/bw/it/txbwitnnldk_y5r-bf0f4pss7eg.jpeg"><br><br>  Disons que nous l'avons corrigé.  Maintenant un peu compliqué.  Nous avons un composant qui rend quelque chose qui doit être retiré du serveur pour une sorte d'ID.  Dans ce cas, en principe, tout fonctionne bien jusqu'à ce que nous modifiions entityId dans le parent, ce n'est peut-être pas pertinent pour votre composant. <br><br><img src="https://habrastorage.org/webt/2e/pl/tx/2epltxjdup5yia7c6gsepl-o7xo.jpeg"><br><br>  Mais très probablement, s'il change ou s'il est nécessaire de le changer, et que vous avez un ancien composant sur votre page et qu'il s'avère qu'il ne se met pas à jour, il est préférable d'ajouter ici entityId, en tant que dépendance, provoquant la mise à jour, mettant à jour les données. <br><br><img src="https://habrastorage.org/webt/rd/lc/ep/rdlcepf4e8lzq8ersyffn8ydqgs.jpeg"><br><br>  Un exemple plus complexe avec useCallback.  Ici, à première vue, tout va bien.  Nous avons une certaine page qui a une sorte de compte à rebours, ou, inversement, une minuterie qui ne fait que cocher.  Et, par exemple, une liste d'hôtes, et en haut sont des filtres qui vous permettent de filtrer cette liste d'hôtes.  Eh bien, la maintenance a été ajoutée ici juste pour illustrer une valeur changeant fréquemment qui se traduit par un moteur de rendu. <br><br>    ,   ,    maintenance    ,   ,   ,      onChange.     onChange,        .  ,  HostFilters - , ,      dropdown,     .       ,    .  ,       . <br><br><img src="https://habrastorage.org/webt/bb/08/q1/bb08q1gwb5jzadcu0-bl1w0xsy0.jpeg"><br><br>     onChange    useCallback.         ,      . <br><br>    ,   . , ,  .      Facebook,   React.  , , ,  ,  '.     ,  ,  confusing . <br><br><img src="https://habrastorage.org/webt/xw/lv/et/xwlvetymaukrlaxd7t5cctegg-8.jpeg"><br><br>     ?        —     ,   -  , ,     ,      ,  ,         .         . <br><br> ,    ,          ,     ,      ,     , .  , Garbage Collector      ,    .  , ,     ,    ,    .   , , ,       reducer,     ,          . ,      . <br><br>    ,     ,   .     - , ,   setValue  - ,            ,   setState     .   -       useEffect. <br><br>   useEffect   -  ,   -  , ,   ,    useEffect.     useEffect     ,   .        ,    ,  Backbone,  : ,     ,  ,        -  .      ,    ,  -   ,  .    -   . ,  ,      ,    ,    -  . ,  ,  ,   , ,    ,  .     . <br><br>   ,   ,  . ,        ,     .           ,      .        ,     .  ,    , , dropdown  .   ,     .    dropdown  pop-up,     useWindowScroll, useWindowResize         ,  .         ,      , —  ,   . <br><br>        ,   ,  . ,       , ,   ,     ,       . , ,   ,      ,   ,         . <br><br><img src="https://habrastorage.org/webt/-r/tu/f_/-rtuf_bbscg5l9i4-oaeh-xpu80.jpeg"><br><br>   ,     «»,   . ,     ,   TypeScript    .      .    ,  reducer  Redux ,    action.  ,   action    ,     action.   ,   ,     ,  . <br><br>    .  ,        action.     ,     , IncrementA  0,  1, 2,   .         . ,    , ,  ,       .     action     action,   -     .   UnionType “Action”,         ,   ,    action.   . <br><br>   —     . ,   initialState,  .   ,       -  .       TypeScript.     . ,    typeState   ,   initialState. <br><br><img src="https://habrastorage.org/webt/_i/fg/79/_ifg793-qpfaiwittpdhffve_zw.jpeg"><br><br>       reducer.   State, Action,    :   switch  action.type.  TypeScript      UnionType:       case,      - ,    type.           action   . <br><br> ,  :  ,    ,     .  . <br><br><img src="https://habrastorage.org/webt/6r/8v/or/6r8vordbm6xpl9og288kzvrgewk.jpeg"><br><br>   ?  ,     .      .      ,   reducer. ,   action creator  ,   ,       dispatch. <br><br><img src="https://habrastorage.org/webt/vg/tg/aw/vgtgawewmkwgpr5su4c24n7hgo8.jpeg"><br><br>     extension   Dev Tools.            .    . <br><br>  ,  ,    .   ,     ,     .      useDebugValue ,        -    Dev Tool.        useConstants,       - , loaded,  ,     ,  . <br><br><img src="https://habrastorage.org/webt/rt/cc/sg/rtccsggw9kekwpt75gmvnwd_w2u.jpeg"><br><br>   —  .  ,     .     ,        .    ,   ,  ,    .     ,   ,          —   -       ,   —   . <br><br>   .  Facebook     ESLint,       .      ,  , .    ,   dependencies  .     ,    ,    ,     . <br><br>       ,  ,     ,  -   ,     .     ,   ,   ,       . .       ,    -   - . <br><br>    —       , ,  - .   ,    ,    .      ,   ,  -      . ,             .      .  : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«React hooks —   ?»</a> C     .       ,    ,    ,      ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   useEffect</a> .  ,   ,      ,   ,   ,     . . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«useReducer vs useState in React»</a> ,    useReducer,      useState. :     ,  ,    ,    useReducer.    - ,   useState   . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">React Hooks CheatSheets</a> c      . </li><li>   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Usehooks.com</a> —   , .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">react-use</a> — ,       ,     . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464071/">https://habr.com/ru/post/fr464071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464045/index.html">Comment je traine presque en temps réel en 1997</a></li>
<li><a href="../fr464053/index.html">Nota: Algorithme de sélection et de rotation des pistes</a></li>
<li><a href="../fr464055/index.html">Nous étudions les données collectées par Xiaomi Mi Band pour l'année</a></li>
<li><a href="../fr464057/index.html">Hilbert, Lebesgue ... et le vide</a></li>
<li><a href="../fr464063/index.html">Couper le câble en 2019</a></li>
<li><a href="../fr464075/index.html">Introduction à C. Message du siècle dernier</a></li>
<li><a href="../fr464077/index.html">Non, vous n'avez pas besoin de delta ve à 50 km / s. Vous avez besoin de technologies additives (partie 1)</a></li>
<li><a href="../fr464079/index.html">Comment faire un vaisseau spatial de décollage et d'atterrissage horizontal sans technologie miracle</a></li>
<li><a href="../fr464083/index.html">Comment ITSM va aider et qui applique cette méthodologie</a></li>
<li><a href="../fr464089/index.html">Automatiser les requêtes HTTP dans le contexte de Spring</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>