<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔬 😒 🐁 Binärmodule für Python 👲🏾 🥟 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python ist großartig. Wir sagen "pip install" und höchstwahrscheinlich wird die erforderliche Bibliothek geliefert. Aber manchmal lautet die Antwort: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Binärmodule für Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/418449/">  Python ist großartig.  Wir sagen "pip install" und höchstwahrscheinlich wird die erforderliche Bibliothek geliefert.  Aber manchmal lautet die Antwort: "Kompilierung fehlgeschlagen", weil es Binärmodule gibt.  Sie leiden in fast allen modernen Sprachen unter Schmerzen, weil es viele Architekturen gibt, etwas für eine bestimmte Maschine zusammengestellt werden muss, etwas mit anderen Bibliotheken verknüpft werden muss.  Im Allgemeinen eine interessante, aber wenig untersuchte Frage: Wie können sie gemacht werden und welche Probleme gibt es?  Dmitry Zhiltsov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">zaabjuda</a> ) hat letztes Jahr bei MoscowPython Conf versucht, diese Frage zu beantworten. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/P7ihyyIDtME" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Unter dem Schnitt befindet sich die Textversion von Dmitrys Bericht.  Lassen Sie uns kurz darauf eingehen, wann Binärmodule benötigt werden und wann es besser ist, sie aufzugeben.  Lassen Sie uns die Regeln diskutieren, die beim Schreiben befolgt werden sollten.  Betrachten Sie fünf mögliche Implementierungsoptionen: <br><br><ul><li>  Native C / C ++ - Erweiterung </li><li>  Swig </li><li>  Cython </li><li>  C-Typen </li><li>  Rost </li></ul><br>  <strong>Über den Sprecher</strong> : Dmitry Zhiltsov entwickelt sich seit mehr als 10 Jahren.  Er arbeitet bei CIAN als Systemarchitekt, dh er ist verantwortlich für technische Lösungen und Zeitsteuerung.  In meinem Leben habe ich es geschafft, Assembler, Haskell, C, auszuprobieren, und seit 5 Jahren programmiere ich aktiv in Python. <a name="habracut"></a><br><br><h2>  Über die Firma <br></h2><br>  Viele, die in Moskau leben und Wohnungen mieten, kennen CIAN wahrscheinlich.  CYAN ist 7 Millionen Käufer und Mieter pro Monat.  Alle diese Benutzer finden jeden Monat über unseren Service eine Unterkunft. <br><br>  Ungefähr 75% der Moskauer kennen unser Unternehmen, und das ist sehr cool.  In St. Petersburg und Moskau gelten wir praktisch als Monopolisten.  Im Moment versuchen wir, in die Regionen einzudringen, und daher ist die Entwicklung in den letzten 3 Jahren achtmal gewachsen.  Dies bedeutet, dass das Team um das Achtfache erhöht wurde, die Geschwindigkeit der Übermittlung von Werten an den Benutzer um das Achtfache erhöht wurde, d. H.  von einer Produktidee bis hin zur Einführung eines Builds durch einen Ingenieur in der Produktion.  Wir haben in unserem großen Team gelernt, uns sehr schnell zu entwickeln und sehr schnell zu verstehen, was gerade passiert, aber heute werden wir ein wenig über etwas anderes sprechen. <br><br>  Ich werde über Binärmodule sprechen.  Mittlerweile verfügen fast 50% der Python-Bibliotheken über Binärmodule.  Und wie sich herausstellte, sind viele Menschen mit ihnen nicht vertraut und glauben, dass dies etwas Transzendentales, etwas Dunkles und Unnötiges ist.  Und andere Leute schlagen vor, einen separaten Microservice besser zu schreiben und keine Binärmodule zu verwenden. <br><br>  Der Artikel besteht aus zwei Teilen. <br><br><ol><li> Meine Erfahrung: Warum sie gebraucht werden, wann sie am besten verwendet werden und wann nicht. <br></li><li>  Tools und Technologien, mit denen Sie ein Binärmodul für Python implementieren können. <br></li></ol><br><h2>  Warum werden Binärmodule benötigt? <br></h2><br>  Wir alle wissen genau, dass Python eine interpretierte Sprache ist.  Es ist fast die schnellste der interpretierten Sprachen, aber leider reicht seine <strong>Geschwindigkeit nicht immer</strong> für schwere mathematische Berechnungen aus.  Sofort entsteht der Gedanke, dass C schneller sein wird. <br><br>  Aber Python hat noch einen Schmerz - es ist <strong>GIL</strong> .  Es wurde eine große Anzahl von Artikeln über ihn geschrieben und es wurde berichtet, wie man um ihn herumkommt. <br><br>  Wir benötigen auch binäre Erweiterungen, <strong>um die Logik wiederzuverwenden</strong> .  Zum Beispiel haben wir eine Bibliothek gefunden, die alle Funktionen bietet, die wir benötigen, und warum nicht.  Das heißt, Sie müssen den Code nicht neu schreiben. Wir nehmen einfach den fertigen Code und verwenden ihn erneut. <br><br>  Viele Leute glauben, dass man mit binären Erweiterungen <strong>den Quellcode verbergen kann</strong> .  Die Frage ist natürlich sehr, sehr kontrovers, mit Hilfe einiger wilder Perversionen kann dies erreicht werden, aber es gibt keine 100% ige Garantie.  Das Maximum, das Sie erhalten können, besteht darin, den Client nicht dekompilieren zu lassen und zu sehen, was in dem von Ihnen übergebenen Code passiert. <br><br><h3>  Wann werden binäre Erweiterungen wirklich benötigt? <br></h3><br>  Über Geschwindigkeit und Python ist klar: Wenn eine Funktion sehr langsam arbeitet und 80% der Ausführungszeit des gesamten Codes einnimmt, beginnen wir über das Schreiben einer binären Erweiterung nachzudenken.  Aber um solche Entscheidungen zu treffen, müssen Sie, wie ein berühmter Redner sagte, mit Ihrem Gehirn denken. <br><br>  Um Erweiterungen zu schreiben, muss man berücksichtigen, dass dies erstens lang sein wird.  Zuerst müssen Sie Ihre Algorithmen "lecken", d. H.  Überprüfen Sie, ob Pfosten vorhanden sind. <br><br><blockquote>  In 90% der Fälle entfällt nach einer gründlichen Überprüfung des Algorithmus die Notwendigkeit, einige Erweiterungen zu schreiben. <br></blockquote><br>  Der zweite Fall, in dem binäre Erweiterungen wirklich benötigt werden, ist die <strong>Verwendung von Multithreading für einfache Operationen</strong> .  Nun, das ist nicht so relevant, aber es bleibt in einigen Systemintegratoren, in denen Python 2.6 noch geschrieben ist, immer noch im blutigen Unternehmen.  Es gibt keine Asynchronität, und selbst bei einfachen Dingen, z. B. beim Hochladen einer Reihe von Bildern, steigt das Multithreading.  Es scheint, dass dies anfangs keine Netzwerkkosten verursacht, aber wenn wir das Bild in den Puffer hochladen, kommt die unglückliche GIL und eine Art Bremse beginnt.  Wie die Praxis zeigt, lassen sich solche Dinge am besten mit Bibliotheken lösen, von denen Python nichts weiß. <br><br>  Wenn Sie ein bestimmtes Protokoll implementieren müssen, kann es praktisch sein, einfachen C / C ++ - Code zu erstellen und viel Schmerz loszuwerden.  Ich habe dies in meiner Zeit bei einem Telekommunikationsbetreiber getan, da es keine fertige Bibliothek gab - ich musste sie selbst schreiben.  Aber ich wiederhole, jetzt ist das nicht sehr relevant, weil es Asyncio gibt, und für die meisten Aufgaben ist dies genug. <br><br>  Über offensichtlich <strong>schwierige Operationen habe</strong> ich bereits im Voraus gesagt.  Wenn Sie Abstürze, große Matrizen und dergleichen haben, ist es sinnvoll, eine Erweiterung für C / C ++ vorzunehmen.  Ich möchte darauf hinweisen, dass einige Leute denken, dass wir hier keine binären Erweiterungen benötigen. Es ist besser, einen Microservice in einer „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">superschnellen Sprache</a> “ zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> und riesige Matrizen über das Netzwerk zu übertragen.  Nein, das ist besser nicht. <br><br>  Ein weiteres gutes Beispiel, wann sie überhaupt genommen werden können und sollten, ist, wenn Sie eine <strong>etablierte Logik des Moduls haben</strong> .  Wenn Sie eine Art Python-Modul in Ihrem Unternehmen haben oder eine Bibliothek bereits seit 3 ​​Jahren vorhanden ist, werden diese einmal im Jahr und dann in zwei Zeilen geändert. Warum nicht eine normale C-Bibliothek erstellen, wenn freie Ressourcen und Zeit zur Verfügung stehen?  Steigern Sie zumindest die Produktivität.  Und es wird auch ein Verständnis dafür bestehen, dass wenn einige grundlegende Änderungen in der Bibliothek erforderlich sind, dies nicht so einfach ist und es sich möglicherweise lohnt, erneut mit dem Gehirn nachzudenken und diese Bibliothek auf eine andere Weise zu verwenden. <br><br><h3>  5 goldene Regeln <br></h3><br>  Ich habe diese Regeln in meiner Praxis abgeleitet.  Sie betreffen nicht nur Python, sondern auch andere Sprachen, für die Sie binäre Erweiterungen verwenden können.  Sie können mit ihnen streiten, aber Sie können auch denken und Ihre eigenen mitbringen. <br><br><ol><li>  <strong>Nur Exportfunktionen</strong> .  Das Erstellen von Klassen in Python in Binärbibliotheken ist sehr zeitaufwändig: Sie müssen viele Schnittstellen beschreiben und die Referenzintegrität im Modul selbst überprüfen.  Es ist einfacher, eine kleine Schnittstelle für die Funktion zu schreiben. <br></li><li>  <strong>Verwenden Sie Wrapper-Klassen</strong> .  Einige lieben OOP sehr und wollen wirklich Unterricht.  Selbst wenn es sich nicht um Klassen handelt, ist es in jedem Fall besser, nur einen Python-Wrapper zu schreiben: Erstellen Sie eine Klasse, definieren Sie eine Klassenmethode oder eine reguläre Methode, rufen Sie native C / C ++ - Funktionen auf.  Dies trägt zumindest dazu bei, die Integrität der Datenarchitektur aufrechtzuerhalten.  Wenn Sie eine C / C ++ - Erweiterung eines Drittanbieters verwenden, die Sie nicht reparieren können, können Sie sie im Wrapper hacken, damit alles funktioniert. <br></li><li>  <strong>Sie können keine Argumente von Python an eine Erweiterung übergeben - dies</strong> ist nicht einmal eine Regel, sondern eine Anforderung.  In einigen Fällen kann dies funktionieren, aber es ist normalerweise eine schlechte Idee.  Daher müssen Sie in Ihrem Code zuerst einen Handler erstellen, der den Python-Typ in Typ C umwandelt. Rufen Sie erst danach eine native Funktion auf, die bereits mit Typ s funktioniert.  Derselbe Handler empfängt eine Antwort von einer ausführbaren Funktion, wandelt sie in Python-Datentypen um und wirft sie in Python-Code. <br></li><li>  <strong>Berücksichtigen Sie die Speicherbereinigung</strong> .  Python hat einen bekannten GC, den Sie nicht vergessen sollten.  Zum Beispiel übergeben wir einen großen Text als Referenz und versuchen, ein Wort in der Bibliothek zu finden.  Wir wollen dies parallelisieren, wir übergeben die Verknüpfung zu diesem Speicherbereich und zum Start mehrerer Threads.  Zu diesem Zeitpunkt nimmt der GC einfach und entscheidet, dass sich nichts anderes auf dieses Objekt bezieht, und entfernt es aus dem Speicherbereich.  Im selben Code erhalten wir nur eine Nullreferenz, und dies ist normalerweise ein Segmentierungsfehler.  Wir dürfen eine solche Funktion des Garbage Collector nicht vergessen und die einfachsten Datentypen an char-Bibliotheken übergeben: char, integer usw. <br><br>  Andererseits kann die Sprache, in der die Erweiterung geschrieben ist, einen eigenen Garbage Collector haben.  Die Kombination von Python und der C # -Bibliothek ist in diesem Sinne ein Schmerz. <br></li><li>  <strong>Definieren Sie explizit die Argumente der exportierten Funktion</strong> .  Damit möchte ich sagen, dass diese Funktionen qualitativ kommentiert werden müssen.  Wenn wir die PyObject-Funktion akzeptieren und sie auf jeden Fall in unserer Bibliothek akzeptieren, müssen wir explizit angeben, welche Argumente zu welchen Typen gehören.  Dies ist nützlich, da bei einer Übergabe des falschen Datentyps ein Fehler in der Bibliothek angezeigt wird.  Das heißt, Sie brauchen es für Ihre Bequemlichkeit. <br></li></ol><br><h3>  Binäre Erweiterungsarchitektur <br></h3><br><img src="https://habrastorage.org/webt/xq/q1/-0/xqq1-0l_omlmuok-v8yqryqkvku.png"><br><br>  Tatsächlich ist die Architektur von binären Erweiterungen nicht kompliziert.  Es gibt Python, es gibt eine aufrufende Funktion, die auf einem Wrapper landet, der den Code nativ aufruft.  Dieser Aufruf landet wiederum auf einer Funktion, die nach Python exportiert wird und die direkt aufgerufen werden kann.  In dieser Funktion müssen Sie Datentypen in Datentypen Ihrer Sprache umwandeln.  Und erst nachdem diese Funktion alles für uns übersetzt hat, rufen wir die native Funktion auf, die die Hauptlogik ausführt, das Ergebnis in die entgegengesetzte Richtung zurückgibt und es in Python wirft und die Datentypen zurück übersetzt. <br><br><h2>  Technologie und Werkzeuge <br></h2><br>  Die bekannteste Methode zum Schreiben von binären Erweiterungen ist die native C / C ++ - Erweiterung.  Nur weil es sich um Standard-Python-Technologie handelt. <br><br><h3>  Native C / C ++ - Erweiterung <br></h3><br>  Python selbst ist in C implementiert und die Methoden und Strukturen von python.h werden zum Schreiben von Erweiterungen verwendet.  Übrigens ist dieses Ding auch gut, weil es sehr einfach ist, es in ein bestehendes Projekt zu implementieren.  Es reicht aus, xt_modules in setup.py anzugeben und zu sagen, dass Sie zum Erstellen des Projekts solche Quellen mit solchen Kompilierungsflags kompilieren müssen.  Unten ist ein Beispiel. <br><br><pre><code class="cpp hljs">name = <span class="hljs-string"><span class="hljs-string">'DateTime.mxDateTime.mxDateTime'</span></span> src = <span class="hljs-string"><span class="hljs-string">'mxDateTime/mxDateTime.c'</span></span> extra_compile_args=[<span class="hljs-string"><span class="hljs-string">'-g3'</span></span>, <span class="hljs-string"><span class="hljs-string">'-o0'</span></span>, <span class="hljs-string"><span class="hljs-string">'-DDEBUG=2'</span></span>, <span class="hljs-string"><span class="hljs-string">'-UNDEBUG'</span></span>, <span class="hljs-string"><span class="hljs-string">'-std=c++11'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wall'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wextra'</span></span>] setup ( ... ext_modules = [(name, { <span class="hljs-string"><span class="hljs-string">'sources'</span></span>: [src], <span class="hljs-string"><span class="hljs-string">'include_dirs'</span></span>: [<span class="hljs-string"><span class="hljs-string">'mxDateTime'</span></span>] , extra_compile_args: extra_compile_args } )] )</code> </pre> <br>  Vorteile der nativen C / C ++ - Erweiterung <br><br><ul><li>  Native Technologie. </li><li>  Es lässt sich leicht in die Projektbaugruppe integrieren. </li><li>  Die größte Menge an Dokumentation. </li><li>  Ermöglicht das Erstellen eigener Datentypen. </li></ul><br>  Nachteile der nativen C / C ++ - Erweiterung <br><br><ul><li>  Hohe Eintrittsschwelle. </li><li>  Kenntnisse in C. sind erforderlich. </li><li>  Boost.Python. </li><li>  Segmentierungsfehler. </li><li>  Schwierigkeiten beim Debuggen. </li></ul><br>  Gemäß dieser Technologie wird eine große Menge an Dokumentation geschrieben, sowohl Standard- als auch Blog-Beiträge.  Ein großes Plus ist, dass wir unsere eigenen Python-Datentypen erstellen und unsere Klassen erstellen können. <br><br>  Dieser Ansatz hat große Nachteile.  Erstens ist es die Eintrittsschwelle - nicht jeder kennt C genug, um für die Produktion zu codieren.  Sie müssen verstehen, dass es dafür nicht ausreicht, das Buch zu lesen und auszuführen, um native Erweiterungen zu schreiben.  Wenn Sie dies tun möchten, dann: lernen Sie zuerst C;  Beginnen Sie dann mit dem Schreiben von Befehlsdienstprogrammen.  Erst danach schreiben Sie Erweiterungen. <br><br>  Boost.Python ist sehr gut für C ++, es ermöglicht Ihnen, fast vollständig von all diesen Wrappern zu abstrahieren, die wir in Python verwenden.  Aber das Minus, denke ich, ist, dass Sie viel schwitzen müssen, um einen Teil davon zu nehmen und es in das Projekt zu importieren, ohne den gesamten Boost herunterzuladen. <br><br>  Wenn ich die Schwierigkeiten beim Debuggen in den Minuspunkten aufführe, meine ich, dass jetzt jeder daran gewöhnt ist, einen grafischen Debugger zu verwenden, und mit Binärmodulen wird so etwas nicht funktionieren.  Höchstwahrscheinlich müssen Sie GDB mit einem Plugin für Python installieren. <br><br>  Schauen wir uns ein Beispiel an, wie wir dies erstellen. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Python.h&gt; static PyObject*addList_add(Pyobject* self, Pyobject* args){ PyObject * listObj; if (! PyARg_Parsetuple( args, "", &amp;listObj)) return NULL; long length = PyList_Size(listObj) int i, sum =0; //   return Py_BuildValue("i", sum); }</span></span></span></span></code> </pre><br>  Zu Beginn enthalten wir die Python-Header-Dateien.  Danach beschreiben wir die Funktion addList_add, die Python verwenden wird.  Das Wichtigste ist, die Funktion korrekt zu benennen. In diesem Fall ist addList der Name des Moduls, _add ist der Name der Funktion, die in Python verwendet wird.  Wir übergeben das PyObject-Modul selbst und übergeben die Argumente auch mit PyObject.  Danach führen wir Standardprüfungen durch.  In diesem Fall versuchen wir, das Tupelargument zu analysieren und zu sagen, dass es sich um ein Objekt handelt - das Literal "O" muss explizit angegeben werden.  Danach wissen wir, dass wir listObj als Objekt übergeben haben, und wir versuchen, seine Länge mit Standard-Python-Methoden herauszufinden: PyList_Size.  Beachten Sie, dass wir hier immer noch keine Aufrufe verwenden können, um die Länge dieses Vektors herauszufinden, sondern die Python-Funktionalität verwenden.  Wir lassen die Implementierung weg, wonach alle Werte an Python zurückgegeben werden müssen.  Rufen Sie dazu Py_BuildValue auf, geben Sie an, welchen Datentyp wir zurückgeben. In diesem Fall ist „i“ eine Ganzzahl und die Summenvariable selbst. <br><br>  In diesem Fall versteht jeder - wir finden die Summe aller Elemente der Liste.  Gehen wir noch etwas weiter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; length; i++){ <span class="hljs-comment"><span class="hljs-comment">//     //   Python- PyObject* temp = PyList_GetItem(listObj, i); //  ,      //     C long long elem= PyLong_AsLong(temp); sum += elem; }</span></span></code> </pre><br>  Dies ist das gleiche: Im Moment ist listObj ein Python-Objekt.  In diesem Fall versuchen wir, die Listenelemente zu übernehmen.  Python.h hat alles was Sie dazu brauchen. <br><br>  Nachdem wir Temp bekommen haben, versuchen wir es zu lange zu besetzen.  Und erst danach können Sie in C etwas tun. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  static char addList_docs[] = "add( ): add all elements of the list\n"; //    static PyMethodDef addList_funcs[] = { {"add", (PyCFunction)addList_add, METH_VARARGS, addList_docs}, {NULL, NULL, 0, NULL} };</span></span></code> </pre><br>  Nachdem wir die gesamte Funktion implementiert haben, ist es notwendig, Dokumentation zu schreiben.  <strong>Die Dokumentation ist immer gut</strong> und dieses Toolkit bietet alles für eine bequeme Wartung.  Gemäß der Namenskonvention benennen wir das Modul addList_docs und speichern dort die Beschreibung.  Jetzt müssen Sie das Modul registrieren, dafür gibt es eine spezielle PyMethodDef-Struktur.  Bei der Beschreibung der Eigenschaften sagen wir, dass die Funktion unter dem Namen "add" nach Python exportiert wird und diese Funktion PyCFunction aufruft.  METH_VARARGS bedeutet, dass eine Funktion möglicherweise eine beliebige Anzahl von Variablen annehmen kann.  Wir haben auch zusätzliche Zeilen aufgeschrieben und eine Standardprüfung beschrieben, falls wir das Modul gerade importiert haben, aber keine Methode verwendet haben, damit es nicht herunterfällt. <br><br>  Nachdem wir dies alles angekündigt haben, versuchen wir ein Modul zu erstellen.  Wir erstellen ein Moduledef und legen alles, was wir getan haben, dort ab. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PyModuleDef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">moduledef</span></span></span><span class="hljs-class"> = {</span></span> PyModuleDef_HEAD_INIT, <span class="hljs-string"><span class="hljs-string">"addList example module"</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, adList_funcs, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre><br>  PyModuleDef_HEAD_INIT ist eine Standard-Python-Konstante, die Sie immer verwenden sollten.  -1 gibt an, dass in der Importphase kein zusätzlicher Speicher zugewiesen werden muss. <br><br>  Wenn wir das Modul selbst erstellt haben, müssen wir es initialisieren.  Python sucht immer nach init. Erstellen Sie daher eine PyInit_addList für addList.  Aus der zusammengesetzten Struktur können Sie nun PyModule_Create aufrufen und schließlich das Modul selbst erstellen.  Fügen Sie als Nächstes die Metainformationen hinzu und geben Sie das Modul selbst zurück. <br><br><pre> <code class="cpp hljs">PyInit_addList(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>){ PyObject *<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = PyModule_Create(&amp;mdef); If (<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PyModule_AddStringConstant(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>, <span class="hljs-string"><span class="hljs-string">"__author__"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bruse Lee&lt;brus@kf.ch&gt;:"</span></span>); PyModule_addStringConstant (Module, <span class="hljs-string"><span class="hljs-string">"__version__"</span></span>, <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>; }</code> </pre><br>  Wie Sie bereits bemerkt haben, gibt es viele Dinge, die verändert werden müssen.  Sie sollten sich immer an Python erinnern, wenn wir in C / C ++ schreiben. <br><br>  Aus diesem Grund wurde vor etwa 15 Jahren die SWIG-Technologie eingeführt, um das Leben eines gewöhnlichen sterblichen Programmierers zu erleichtern. <br><br><h3>  Swig <br></h3><br>  Mit diesem Tool können Sie Python-Bindungen abstrahieren und nativen Code schreiben.  Es hat die gleichen Vor- und Nachteile wie Native C / C ++, aber es gibt Ausnahmen. <br><br>  SWIG-Profis: <br><br><ul><li>  Stabile Technologie. </li><li>  Eine große Menge an Dokumentation. </li><li>  Abstracts von der Bindung an Python. </li></ul><br>  Nachteile von SWIG: <br><br><ul><li>  Lange Einrichtung. </li><li>  Wissen C. </li><li>  Segmentierungsfehler. </li><li>  Schwierigkeiten beim Debuggen. </li><li>  Die Komplexität der Integration in die Montage des Projekts. </li></ul><br>  Das erste Minus ist, dass <strong>Sie beim Einrichten den Verstand verlieren</strong> .  Als ich es zum ersten Mal einrichtete, verbrachte ich anderthalb Tage damit, es überhaupt zu starten.  Dann ist es natürlich einfacher.  SWIG 3.x ist einfacher geworden. <br><br>  Um nicht mehr in den Code einzusteigen, betrachten Sie das allgemeine Schema von SWIG. <br><br><img src="https://habrastorage.org/webt/93/4h/ul/934huleqgml-qurdnxrw8k0gjes.png"><br><br>  example.c ist ein C-Modul, das überhaupt nichts über Python weiß.  Es gibt eine Schnittstellendatei example.i, die im SWIG-Format beschrieben wird.  Führen Sie danach das Dienstprogramm SWIG aus, mit dem example_wrap.c aus der Schnittstellendatei erstellt wird. Dies ist derselbe Wrapper, den wir früher mit unseren Händen verwendet haben.  Das heißt, SWIG erstellt für uns nur einen Datei-Wrapper, die sogenannte Brücke.  Danach kompilieren wir mit GCC zwei Dateien und erhalten zwei Objektdateien (example.o und example_wrap.o). Erst dann erstellen wir unsere Bibliothek.  Alles ist einfach und klar. <br><br><h3>  Cython <br></h3><br>  Andrey Svetlov hat auf der MoscowPython Conf einen hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> verfasst. Ich möchte nur sagen, dass dies eine beliebte Technologie mit guter Dokumentation ist. <br><br>  Cython-Vorteile: <br><br><ul><li>  Beliebte Technologie. </li><li>  Ziemlich stabil. </li><li>  Es lässt sich leicht in die Projektbaugruppe integrieren. </li><li>  Gute Dokumentation. </li></ul><br>  Nachteile von Cython: <br><br><ul><li>  Eigene Syntax. </li><li>  Wissen C. </li><li>  Segmentierungsfehler. </li><li>  Schwierigkeiten beim Debuggen. </li></ul><br>  Nachteile sind wie immer.  Die wichtigste ist die eigene Syntax, die C / C ++ und Python sehr ähnlich ist. <br><br>  Ich möchte jedoch darauf hinweisen, dass Python-Code mit Cython durch Schreiben von nativem Code beschleunigt werden kann. <br><br><img src="https://habrastorage.org/webt/tk/8t/sh/tk8tshw1gla6nevwcjda4c9iq20.png"><br><br>  Wie Sie sehen können, gibt es viele Dekorateure, und das ist nicht sehr gut.  Wenn Sie Cython verwenden möchten, lesen Sie den Bericht von Andrei Svetlov. <br><br><h3>  CTypes <br></h3><br>  CTypes ist die Standard-Python-Bibliothek, die mit der Fremdfunktionsschnittstelle zusammenarbeitet.  FFI ist eine Bibliothek auf niedriger Ebene.  Dies ist eine native Technologie, die sehr häufig im Code verwendet wird. Mit ihrer Hilfe ist es einfach, plattformübergreifend zu implementieren. <br><br>  FFI ist jedoch mit viel Aufwand verbunden, da alle Bridges und alle Handler zur Laufzeit dynamisch erstellt werden.  Das heißt, wir haben die dynamische Bibliothek geladen, und Python weiß derzeit nicht, was die Bibliothek ist.  Nur wenn eine Bibliothek im Speicher aufgerufen wird, werden diese Brücken dynamisch aufgebaut. <br><br>  Vorteile von CT-Typen: <br><br><ul><li>  Native Technologie. </li><li>  Einfach im Code zu verwenden. </li><li>  Einfach plattformübergreifend zu implementieren. </li><li>  Sie können fast jede Sprache verwenden. </li></ul><br>  Nachteile CT-Typen: <br><br><ul><li>  Trägt über Kopf. </li><li>  Schwierigkeiten beim Debuggen. </li></ul><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment">#load the shared object file Adder = CDLL('./adder.so') #Calculate factorial res_int = adder.fact(4) print("Fact of 4 = " + str(res_int))</span></span></code> </pre><br>  Sie nahmen adder.so und riefen es zur Laufzeit auf.  Wir können sogar native Python-Typen übergeben. <br><br>  Nach all dem lautet die Frage: "Es ist irgendwie kompliziert, überall C, was zu tun ist?". <br><br><h3>  Rost <br></h3><br>  Früher habe ich der Sprache nicht die richtige Aufmerksamkeit geschenkt, aber jetzt wende ich mich praktisch ihr zu. <br><br>  Vorteile von Rust: <br><br><ul><li>  Sichere Sprache. </li><li>  Leistungsstarke statische Garantien für korrektes Verhalten. </li><li>  Einfache Integration in Projektbuilds ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyO3</a> ). </li></ul><br>  Nachteile von Rost: <br><br><ul><li>  Hohe Eintrittsschwelle. </li><li>  Lange Einrichtung. </li><li>  Schwierigkeiten beim Debuggen. </li><li>  Es gibt wenig Dokumentation. </li><li>  In einigen Fällen Overhead. </li></ul><br>  Rust ist eine sichere Sprache mit automatischem Arbeitsnachweis.  Die Syntax selbst und der Sprachpräprozessor selbst lassen keinen expliziten Fehler zu.  Gleichzeitig konzentriert es sich auf die Variabilität, dh es muss jedes Ergebnis der Ausführung des Codezweigs verarbeiten. <br><br>  Dank des PyO3-Teams gibt es gute Python-Ordner für Rust und Tools zur Integration in das Projekt. <br><br>  Ich gehe davon aus, dass die Konfiguration für einen unvorbereiteten Programmierer sehr lange dauert.  Nur wenige Dokumentationen, aber anstelle von Nachteilen haben wir keinen Segmentierungsfehler.  In 99% der Fälle kann ein Programmierer in Rust in guter Weise nur dann einen Segmentierungsfehler erhalten, wenn er ausdrücklich das Auspacken angegeben und ihn nur bewertet hat. <br><br>  Ein kleines Beispiel für Code, dasselbe Modul, das wir zuvor untersucht haben. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(proc_macro)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> pyo3; Use pyo3::prelude::*; <span class="hljs-comment"><span class="hljs-comment">/// Module documentation string 1 #[py::modinit(_addList)] fn init(py: Python, m: PyModule) -&gt; PyResult &lt;()&gt;{ py_exception!(_addList, EmptyListError); /// Function documentation string 1 #[pufn(m, "run", args= "*", kwargs="**" )] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt; { run(args, kwargs) } #[pyfn(m, "run", args="*", kwatgs="**")] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt;{ run(args,kwargs) } #[pyfn(m,"add")] fn add(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;i32&gt;{ let mut sum : i32 = 0 match py_list.len() { /// Some code Ok(sum) } Ok(()) }</span></span></code> </pre><br>  Der Code hat eine bestimmte Syntax, aber Sie gewöhnen sich sehr schnell daran.  Tatsächlich ist hier alles gleich.  Mit Makros erstellen wir modinit, das für uns die zusätzliche Arbeit erledigt, alle Arten von Bindemitteln für Python zu generieren.  Denken Sie daran, ich sagte, Sie müssen einen Handler-Wrapper machen, hier ist es das gleiche.  run_py konvertiert Typen, dann rufen wir den nativen Code auf. <br><br>  Wie Sie sehen können, gibt es syntaktischen Zucker, um eine Funktion zu exportieren.  Wir sagen nur, dass wir die Funktion add benötigen und keine Schnittstellen beschreiben.  Wir akzeptieren eine Liste, die genau py_list und nicht Object ist, da Rust selbst zum Zeitpunkt der Kompilierung die erforderlichen Ordner einrichtet.  Wenn wir den falschen Datentyp übergeben, wie bei Erweiterungserweiterungen, tritt ein TypeError auf.  Nachdem wir die Liste erhalten haben, beginnen wir sie zu verarbeiten. <br><br>  Lassen Sie uns genauer sehen, was er anfängt zu tun. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[pyfn(m, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"add"</span></span></span><span class="hljs-meta">, py_list=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"*"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> py_list.len() { <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt;<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(EmptyListError::new(<span class="hljs-string"><span class="hljs-string">"List is empty"</span></span>)), _ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sum : <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> py_list.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp:<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> item.extract() { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(v) =&gt; v, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err_msg: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"List item {} is not int"</span></span>, item); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(ItemListError::new(err_msg)) } }; sum += temp; } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(sum) } } }</code> </pre><br>  Der gleiche Code wie in C / C ++ / Ctypes, jedoch nur in Rust.  Dort habe ich versucht, PyObject auf eine Art Long zu besetzen.  Was würde passieren, wenn wir auflisten müssten, außer Zahlen, würden wir eine Zeichenfolge bekommen?  Ja, wir würden einen Systemfehler bekommen.  In diesem Fall durch <strong>let mut</strong> sum <strong>: i32 =</strong> 0;  Wir versuchen auch, einen Wert aus der Liste zu erhalten und ihn in i32 umzuwandeln.  Das heißt, wir können diesen Code nicht ohne item.extract () unbewusst schreiben und in den gewünschten Typ umwandeln.  Wenn wir i32 geschrieben haben, heißt es im Falle eines Rust-Fehlers in der Kompilierungsphase: "Behandeln Sie den Fall, wenn nicht i32".  In diesem Fall geben wir, wenn wir i32 haben, einen Wert zurück. Wenn dies ein Fehler ist, lösen wir eine Ausnahme aus. <br><br><h2>  Was zu wählen <br></h2><br>  Nach dieser kurzen Tour werden wir uns überlegen, was wir am Ende auswählen sollen. <br><br>  Die Antwort liegt wirklich in Ihrem Geschmack und Ihrer Farbe. <br><br>  Ich werde keine bestimmte Technologie fördern. <br><br><img src="https://habrastorage.org/webt/hu/kt/bn/huktbnnsqfoydatdp7gzsisysjg.png"><br><br>  Fassen Sie einfach zusammen, was gesagt wurde: <br><br><ul><li>  Im Fall von SWIG und C / C ++ müssen Sie C / C ++ sehr gut kennen und verstehen, dass die Entwicklung dieses Moduls zusätzlichen Aufwand verursacht.  Es wird jedoch ein Minimum an Tools verwendet, und wir werden mit der nativen Python-Technologie arbeiten, die von den Entwicklern unterstützt wird. </li><li>  Im Fall von Cython haben wir eine kleine Eingabeschwelle, eine hohe Entwicklungsgeschwindigkeit und auch dies ist ein gewöhnlicher Codegenerator. </li><li>  Auf Kosten von CTypes möchte ich Sie vor dem relativ hohen Overhead warnen.  Das dynamische Laden von Bibliotheken kann zu großen Problemen führen, wenn wir nicht wissen, um welche Art von Bibliothek es sich handelt. </li><li>  Ich würde Rust raten, jemanden mitzunehmen, der C / C ++ nicht gut kennt.  Rost in der Produktion bringt wirklich die geringsten Probleme mit sich. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Nützliche Links</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/zaabjuda/moscowpythonconf2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.python.org/3/extending/building.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://cython.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.python.org/376/library/ctypes.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.swig.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.rust-land.org/en-US/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/PyO3</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=5-WoT4X17sk</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://packaging.python.org/tutorials/distributing-packages/#platformwheels</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/PushAMP/pamagent</a> (Kampfbeispiel für die gemeinsame Nutzung) </div></div><br><blockquote>  Ruf nach Papieren <br><br>  Wir akzeptieren Bewerbungen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moscow Python Conf ++</a> bis zum 7. September. Schreiben Sie in dieser einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Form,</a> dass Sie über Python Bescheid wissen, das Sie wirklich mit der Community teilen müssen. <br><br>  Für diejenigen, die mehr am Zuhören interessiert sind, kann ich über coole Berichte sprechen. <br><br><ul><li>  <strong>Donald Whyte</strong> spricht gerne über die Beschleunigung der Mathematik in Python und bereitet eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Geschichte</a> für uns vor: Wie man Mathematik mit gängigen Bibliotheken, Tricks und Hinterlist 10-mal schneller macht, und der Code ist klar und unterstützt. <br></li><li>  <strong>Artyom Malyshev hat</strong> all seine langjährigen Erfahrungen in der Entwicklung von Django gesammelt und präsentiert einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichtsleitfaden</a> zum Framework!  Alles, was zwischen dem Empfang einer HTTP-Anfrage und dem Senden einer fertigen Webseite passiert: Aufdecken von Magie, eine Karte der internen Mechanismen des Frameworks und viele nützliche Tipps für Ihre Projekte. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418449/">https://habr.com/ru/post/de418449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418439/index.html">Progressive Webanwendungsgrundlagen</a></li>
<li><a href="../de418441/index.html">Grundlagen der Windows-Berechtigungseskalation</a></li>
<li><a href="../de418443/index.html">GObject: Kapselung, Instanziierung, Selbstbeobachtung</a></li>
<li><a href="../de418445/index.html">Django Channels - die Antwort auf das moderne Web</a></li>
<li><a href="../de418447/index.html">Warum Moscow Python Conf jetzt ++ ist</a></li>
<li><a href="../de418451/index.html">3D-Druckunterricht. Effektive Unterstützung und Änderung der Schichthöhe in der Praxis von 3Dtool</a></li>
<li><a href="../de418453/index.html">GRAVITY-Beobachtungen bestätigen die allgemeine Relativitätstheorie weiter</a></li>
<li><a href="../de418455/index.html">Offenes Webinar „Spezialist am Ruder: Erste Erfahrungen und Fehler“</a></li>
<li><a href="../de418457/index.html">Danke Beitrag: Tag des Systemadministrators</a></li>
<li><a href="../de418459/index.html">Entwicklung eines LVDS-Skalierers mit zwei DisplayPort-Schnittstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>