<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüî¨ üòí üêÅ Bin√§rmodule f√ºr Python üë≤üèæ ü•ü üë®üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python ist gro√üartig. Wir sagen "pip install" und h√∂chstwahrscheinlich wird die erforderliche Bibliothek geliefert. Aber manchmal lautet die Antwort: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bin√§rmodule f√ºr Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/418449/">  Python ist gro√üartig.  Wir sagen "pip install" und h√∂chstwahrscheinlich wird die erforderliche Bibliothek geliefert.  Aber manchmal lautet die Antwort: "Kompilierung fehlgeschlagen", weil es Bin√§rmodule gibt.  Sie leiden in fast allen modernen Sprachen unter Schmerzen, weil es viele Architekturen gibt, etwas f√ºr eine bestimmte Maschine zusammengestellt werden muss, etwas mit anderen Bibliotheken verkn√ºpft werden muss.  Im Allgemeinen eine interessante, aber wenig untersuchte Frage: Wie k√∂nnen sie gemacht werden und welche Probleme gibt es?  Dmitry Zhiltsov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">zaabjuda</a> ) hat letztes Jahr bei MoscowPython Conf versucht, diese Frage zu beantworten. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/P7ihyyIDtME" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Unter dem Schnitt befindet sich die Textversion von Dmitrys Bericht.  Lassen Sie uns kurz darauf eingehen, wann Bin√§rmodule ben√∂tigt werden und wann es besser ist, sie aufzugeben.  Lassen Sie uns die Regeln diskutieren, die beim Schreiben befolgt werden sollten.  Betrachten Sie f√ºnf m√∂gliche Implementierungsoptionen: <br><br><ul><li>  Native C / C ++ - Erweiterung </li><li>  Swig </li><li>  Cython </li><li>  C-Typen </li><li>  Rost </li></ul><br>  <strong>√úber den Sprecher</strong> : Dmitry Zhiltsov entwickelt sich seit mehr als 10 Jahren.  Er arbeitet bei CIAN als Systemarchitekt, dh er ist verantwortlich f√ºr technische L√∂sungen und Zeitsteuerung.  In meinem Leben habe ich es geschafft, Assembler, Haskell, C, auszuprobieren, und seit 5 Jahren programmiere ich aktiv in Python. <a name="habracut"></a><br><br><h2>  √úber die Firma <br></h2><br>  Viele, die in Moskau leben und Wohnungen mieten, kennen CIAN wahrscheinlich.  CYAN ist 7 Millionen K√§ufer und Mieter pro Monat.  Alle diese Benutzer finden jeden Monat √ºber unseren Service eine Unterkunft. <br><br>  Ungef√§hr 75% der Moskauer kennen unser Unternehmen, und das ist sehr cool.  In St. Petersburg und Moskau gelten wir praktisch als Monopolisten.  Im Moment versuchen wir, in die Regionen einzudringen, und daher ist die Entwicklung in den letzten 3 Jahren achtmal gewachsen.  Dies bedeutet, dass das Team um das Achtfache erh√∂ht wurde, die Geschwindigkeit der √úbermittlung von Werten an den Benutzer um das Achtfache erh√∂ht wurde, d. H.  von einer Produktidee bis hin zur Einf√ºhrung eines Builds durch einen Ingenieur in der Produktion.  Wir haben in unserem gro√üen Team gelernt, uns sehr schnell zu entwickeln und sehr schnell zu verstehen, was gerade passiert, aber heute werden wir ein wenig √ºber etwas anderes sprechen. <br><br>  Ich werde √ºber Bin√§rmodule sprechen.  Mittlerweile verf√ºgen fast 50% der Python-Bibliotheken √ºber Bin√§rmodule.  Und wie sich herausstellte, sind viele Menschen mit ihnen nicht vertraut und glauben, dass dies etwas Transzendentales, etwas Dunkles und Unn√∂tiges ist.  Und andere Leute schlagen vor, einen separaten Microservice besser zu schreiben und keine Bin√§rmodule zu verwenden. <br><br>  Der Artikel besteht aus zwei Teilen. <br><br><ol><li> Meine Erfahrung: Warum sie gebraucht werden, wann sie am besten verwendet werden und wann nicht. <br></li><li>  Tools und Technologien, mit denen Sie ein Bin√§rmodul f√ºr Python implementieren k√∂nnen. <br></li></ol><br><h2>  Warum werden Bin√§rmodule ben√∂tigt? <br></h2><br>  Wir alle wissen genau, dass Python eine interpretierte Sprache ist.  Es ist fast die schnellste der interpretierten Sprachen, aber leider reicht seine <strong>Geschwindigkeit nicht immer</strong> f√ºr schwere mathematische Berechnungen aus.  Sofort entsteht der Gedanke, dass C schneller sein wird. <br><br>  Aber Python hat noch einen Schmerz - es ist <strong>GIL</strong> .  Es wurde eine gro√üe Anzahl von Artikeln √ºber ihn geschrieben und es wurde berichtet, wie man um ihn herumkommt. <br><br>  Wir ben√∂tigen auch bin√§re Erweiterungen, <strong>um die Logik wiederzuverwenden</strong> .  Zum Beispiel haben wir eine Bibliothek gefunden, die alle Funktionen bietet, die wir ben√∂tigen, und warum nicht.  Das hei√üt, Sie m√ºssen den Code nicht neu schreiben. Wir nehmen einfach den fertigen Code und verwenden ihn erneut. <br><br>  Viele Leute glauben, dass man mit bin√§ren Erweiterungen <strong>den Quellcode verbergen kann</strong> .  Die Frage ist nat√ºrlich sehr, sehr kontrovers, mit Hilfe einiger wilder Perversionen kann dies erreicht werden, aber es gibt keine 100% ige Garantie.  Das Maximum, das Sie erhalten k√∂nnen, besteht darin, den Client nicht dekompilieren zu lassen und zu sehen, was in dem von Ihnen √ºbergebenen Code passiert. <br><br><h3>  Wann werden bin√§re Erweiterungen wirklich ben√∂tigt? <br></h3><br>  √úber Geschwindigkeit und Python ist klar: Wenn eine Funktion sehr langsam arbeitet und 80% der Ausf√ºhrungszeit des gesamten Codes einnimmt, beginnen wir √ºber das Schreiben einer bin√§ren Erweiterung nachzudenken.  Aber um solche Entscheidungen zu treffen, m√ºssen Sie, wie ein ber√ºhmter Redner sagte, mit Ihrem Gehirn denken. <br><br>  Um Erweiterungen zu schreiben, muss man ber√ºcksichtigen, dass dies erstens lang sein wird.  Zuerst m√ºssen Sie Ihre Algorithmen "lecken", d. H.  √úberpr√ºfen Sie, ob Pfosten vorhanden sind. <br><br><blockquote>  In 90% der F√§lle entf√§llt nach einer gr√ºndlichen √úberpr√ºfung des Algorithmus die Notwendigkeit, einige Erweiterungen zu schreiben. <br></blockquote><br>  Der zweite Fall, in dem bin√§re Erweiterungen wirklich ben√∂tigt werden, ist die <strong>Verwendung von Multithreading f√ºr einfache Operationen</strong> .  Nun, das ist nicht so relevant, aber es bleibt in einigen Systemintegratoren, in denen Python 2.6 noch geschrieben ist, immer noch im blutigen Unternehmen.  Es gibt keine Asynchronit√§t, und selbst bei einfachen Dingen, z. B. beim Hochladen einer Reihe von Bildern, steigt das Multithreading.  Es scheint, dass dies anfangs keine Netzwerkkosten verursacht, aber wenn wir das Bild in den Puffer hochladen, kommt die ungl√ºckliche GIL und eine Art Bremse beginnt.  Wie die Praxis zeigt, lassen sich solche Dinge am besten mit Bibliotheken l√∂sen, von denen Python nichts wei√ü. <br><br>  Wenn Sie ein bestimmtes Protokoll implementieren m√ºssen, kann es praktisch sein, einfachen C / C ++ - Code zu erstellen und viel Schmerz loszuwerden.  Ich habe dies in meiner Zeit bei einem Telekommunikationsbetreiber getan, da es keine fertige Bibliothek gab - ich musste sie selbst schreiben.  Aber ich wiederhole, jetzt ist das nicht sehr relevant, weil es Asyncio gibt, und f√ºr die meisten Aufgaben ist dies genug. <br><br>  √úber offensichtlich <strong>schwierige Operationen habe</strong> ich bereits im Voraus gesagt.  Wenn Sie Abst√ºrze, gro√üe Matrizen und dergleichen haben, ist es sinnvoll, eine Erweiterung f√ºr C / C ++ vorzunehmen.  Ich m√∂chte darauf hinweisen, dass einige Leute denken, dass wir hier keine bin√§ren Erweiterungen ben√∂tigen. Es ist besser, einen Microservice in einer ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">superschnellen Sprache</a> ‚Äú zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> und riesige Matrizen √ºber das Netzwerk zu √ºbertragen.  Nein, das ist besser nicht. <br><br>  Ein weiteres gutes Beispiel, wann sie √ºberhaupt genommen werden k√∂nnen und sollten, ist, wenn Sie eine <strong>etablierte Logik des Moduls haben</strong> .  Wenn Sie eine Art Python-Modul in Ihrem Unternehmen haben oder eine Bibliothek bereits seit 3 ‚Äã‚ÄãJahren vorhanden ist, werden diese einmal im Jahr und dann in zwei Zeilen ge√§ndert. Warum nicht eine normale C-Bibliothek erstellen, wenn freie Ressourcen und Zeit zur Verf√ºgung stehen?  Steigern Sie zumindest die Produktivit√§t.  Und es wird auch ein Verst√§ndnis daf√ºr bestehen, dass wenn einige grundlegende √Ñnderungen in der Bibliothek erforderlich sind, dies nicht so einfach ist und es sich m√∂glicherweise lohnt, erneut mit dem Gehirn nachzudenken und diese Bibliothek auf eine andere Weise zu verwenden. <br><br><h3>  5 goldene Regeln <br></h3><br>  Ich habe diese Regeln in meiner Praxis abgeleitet.  Sie betreffen nicht nur Python, sondern auch andere Sprachen, f√ºr die Sie bin√§re Erweiterungen verwenden k√∂nnen.  Sie k√∂nnen mit ihnen streiten, aber Sie k√∂nnen auch denken und Ihre eigenen mitbringen. <br><br><ol><li>  <strong>Nur Exportfunktionen</strong> .  Das Erstellen von Klassen in Python in Bin√§rbibliotheken ist sehr zeitaufw√§ndig: Sie m√ºssen viele Schnittstellen beschreiben und die Referenzintegrit√§t im Modul selbst √ºberpr√ºfen.  Es ist einfacher, eine kleine Schnittstelle f√ºr die Funktion zu schreiben. <br></li><li>  <strong>Verwenden Sie Wrapper-Klassen</strong> .  Einige lieben OOP sehr und wollen wirklich Unterricht.  Selbst wenn es sich nicht um Klassen handelt, ist es in jedem Fall besser, nur einen Python-Wrapper zu schreiben: Erstellen Sie eine Klasse, definieren Sie eine Klassenmethode oder eine regul√§re Methode, rufen Sie native C / C ++ - Funktionen auf.  Dies tr√§gt zumindest dazu bei, die Integrit√§t der Datenarchitektur aufrechtzuerhalten.  Wenn Sie eine C / C ++ - Erweiterung eines Drittanbieters verwenden, die Sie nicht reparieren k√∂nnen, k√∂nnen Sie sie im Wrapper hacken, damit alles funktioniert. <br></li><li>  <strong>Sie k√∂nnen keine Argumente von Python an eine Erweiterung √ºbergeben - dies</strong> ist nicht einmal eine Regel, sondern eine Anforderung.  In einigen F√§llen kann dies funktionieren, aber es ist normalerweise eine schlechte Idee.  Daher m√ºssen Sie in Ihrem Code zuerst einen Handler erstellen, der den Python-Typ in Typ C umwandelt. Rufen Sie erst danach eine native Funktion auf, die bereits mit Typ s funktioniert.  Derselbe Handler empf√§ngt eine Antwort von einer ausf√ºhrbaren Funktion, wandelt sie in Python-Datentypen um und wirft sie in Python-Code. <br></li><li>  <strong>Ber√ºcksichtigen Sie die Speicherbereinigung</strong> .  Python hat einen bekannten GC, den Sie nicht vergessen sollten.  Zum Beispiel √ºbergeben wir einen gro√üen Text als Referenz und versuchen, ein Wort in der Bibliothek zu finden.  Wir wollen dies parallelisieren, wir √ºbergeben die Verkn√ºpfung zu diesem Speicherbereich und zum Start mehrerer Threads.  Zu diesem Zeitpunkt nimmt der GC einfach und entscheidet, dass sich nichts anderes auf dieses Objekt bezieht, und entfernt es aus dem Speicherbereich.  Im selben Code erhalten wir nur eine Nullreferenz, und dies ist normalerweise ein Segmentierungsfehler.  Wir d√ºrfen eine solche Funktion des Garbage Collector nicht vergessen und die einfachsten Datentypen an char-Bibliotheken √ºbergeben: char, integer usw. <br><br>  Andererseits kann die Sprache, in der die Erweiterung geschrieben ist, einen eigenen Garbage Collector haben.  Die Kombination von Python und der C # -Bibliothek ist in diesem Sinne ein Schmerz. <br></li><li>  <strong>Definieren Sie explizit die Argumente der exportierten Funktion</strong> .  Damit m√∂chte ich sagen, dass diese Funktionen qualitativ kommentiert werden m√ºssen.  Wenn wir die PyObject-Funktion akzeptieren und sie auf jeden Fall in unserer Bibliothek akzeptieren, m√ºssen wir explizit angeben, welche Argumente zu welchen Typen geh√∂ren.  Dies ist n√ºtzlich, da bei einer √úbergabe des falschen Datentyps ein Fehler in der Bibliothek angezeigt wird.  Das hei√üt, Sie brauchen es f√ºr Ihre Bequemlichkeit. <br></li></ol><br><h3>  Bin√§re Erweiterungsarchitektur <br></h3><br><img src="https://habrastorage.org/webt/xq/q1/-0/xqq1-0l_omlmuok-v8yqryqkvku.png"><br><br>  Tats√§chlich ist die Architektur von bin√§ren Erweiterungen nicht kompliziert.  Es gibt Python, es gibt eine aufrufende Funktion, die auf einem Wrapper landet, der den Code nativ aufruft.  Dieser Aufruf landet wiederum auf einer Funktion, die nach Python exportiert wird und die direkt aufgerufen werden kann.  In dieser Funktion m√ºssen Sie Datentypen in Datentypen Ihrer Sprache umwandeln.  Und erst nachdem diese Funktion alles f√ºr uns √ºbersetzt hat, rufen wir die native Funktion auf, die die Hauptlogik ausf√ºhrt, das Ergebnis in die entgegengesetzte Richtung zur√ºckgibt und es in Python wirft und die Datentypen zur√ºck √ºbersetzt. <br><br><h2>  Technologie und Werkzeuge <br></h2><br>  Die bekannteste Methode zum Schreiben von bin√§ren Erweiterungen ist die native C / C ++ - Erweiterung.  Nur weil es sich um Standard-Python-Technologie handelt. <br><br><h3>  Native C / C ++ - Erweiterung <br></h3><br>  Python selbst ist in C implementiert und die Methoden und Strukturen von python.h werden zum Schreiben von Erweiterungen verwendet.  √úbrigens ist dieses Ding auch gut, weil es sehr einfach ist, es in ein bestehendes Projekt zu implementieren.  Es reicht aus, xt_modules in setup.py anzugeben und zu sagen, dass Sie zum Erstellen des Projekts solche Quellen mit solchen Kompilierungsflags kompilieren m√ºssen.  Unten ist ein Beispiel. <br><br><pre><code class="cpp hljs">name = <span class="hljs-string"><span class="hljs-string">'DateTime.mxDateTime.mxDateTime'</span></span> src = <span class="hljs-string"><span class="hljs-string">'mxDateTime/mxDateTime.c'</span></span> extra_compile_args=[<span class="hljs-string"><span class="hljs-string">'-g3'</span></span>, <span class="hljs-string"><span class="hljs-string">'-o0'</span></span>, <span class="hljs-string"><span class="hljs-string">'-DDEBUG=2'</span></span>, <span class="hljs-string"><span class="hljs-string">'-UNDEBUG'</span></span>, <span class="hljs-string"><span class="hljs-string">'-std=c++11'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wall'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wextra'</span></span>] setup ( ... ext_modules = [(name, { <span class="hljs-string"><span class="hljs-string">'sources'</span></span>: [src], <span class="hljs-string"><span class="hljs-string">'include_dirs'</span></span>: [<span class="hljs-string"><span class="hljs-string">'mxDateTime'</span></span>] , extra_compile_args: extra_compile_args } )] )</code> </pre> <br>  Vorteile der nativen C / C ++ - Erweiterung <br><br><ul><li>  Native Technologie. </li><li>  Es l√§sst sich leicht in die Projektbaugruppe integrieren. </li><li>  Die gr√∂√üte Menge an Dokumentation. </li><li>  Erm√∂glicht das Erstellen eigener Datentypen. </li></ul><br>  Nachteile der nativen C / C ++ - Erweiterung <br><br><ul><li>  Hohe Eintrittsschwelle. </li><li>  Kenntnisse in C. sind erforderlich. </li><li>  Boost.Python. </li><li>  Segmentierungsfehler. </li><li>  Schwierigkeiten beim Debuggen. </li></ul><br>  Gem√§√ü dieser Technologie wird eine gro√üe Menge an Dokumentation geschrieben, sowohl Standard- als auch Blog-Beitr√§ge.  Ein gro√ües Plus ist, dass wir unsere eigenen Python-Datentypen erstellen und unsere Klassen erstellen k√∂nnen. <br><br>  Dieser Ansatz hat gro√üe Nachteile.  Erstens ist es die Eintrittsschwelle - nicht jeder kennt C genug, um f√ºr die Produktion zu codieren.  Sie m√ºssen verstehen, dass es daf√ºr nicht ausreicht, das Buch zu lesen und auszuf√ºhren, um native Erweiterungen zu schreiben.  Wenn Sie dies tun m√∂chten, dann: lernen Sie zuerst C;  Beginnen Sie dann mit dem Schreiben von Befehlsdienstprogrammen.  Erst danach schreiben Sie Erweiterungen. <br><br>  Boost.Python ist sehr gut f√ºr C ++, es erm√∂glicht Ihnen, fast vollst√§ndig von all diesen Wrappern zu abstrahieren, die wir in Python verwenden.  Aber das Minus, denke ich, ist, dass Sie viel schwitzen m√ºssen, um einen Teil davon zu nehmen und es in das Projekt zu importieren, ohne den gesamten Boost herunterzuladen. <br><br>  Wenn ich die Schwierigkeiten beim Debuggen in den Minuspunkten auff√ºhre, meine ich, dass jetzt jeder daran gew√∂hnt ist, einen grafischen Debugger zu verwenden, und mit Bin√§rmodulen wird so etwas nicht funktionieren.  H√∂chstwahrscheinlich m√ºssen Sie GDB mit einem Plugin f√ºr Python installieren. <br><br>  Schauen wir uns ein Beispiel an, wie wir dies erstellen. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Python.h&gt; static PyObject*addList_add(Pyobject* self, Pyobject* args){ PyObject * listObj; if (! PyARg_Parsetuple( args, "", &amp;listObj)) return NULL; long length = PyList_Size(listObj) int i, sum =0; //   return Py_BuildValue("i", sum); }</span></span></span></span></code> </pre><br>  Zu Beginn enthalten wir die Python-Header-Dateien.  Danach beschreiben wir die Funktion addList_add, die Python verwenden wird.  Das Wichtigste ist, die Funktion korrekt zu benennen. In diesem Fall ist addList der Name des Moduls, _add ist der Name der Funktion, die in Python verwendet wird.  Wir √ºbergeben das PyObject-Modul selbst und √ºbergeben die Argumente auch mit PyObject.  Danach f√ºhren wir Standardpr√ºfungen durch.  In diesem Fall versuchen wir, das Tupelargument zu analysieren und zu sagen, dass es sich um ein Objekt handelt - das Literal "O" muss explizit angegeben werden.  Danach wissen wir, dass wir listObj als Objekt √ºbergeben haben, und wir versuchen, seine L√§nge mit Standard-Python-Methoden herauszufinden: PyList_Size.  Beachten Sie, dass wir hier immer noch keine Aufrufe verwenden k√∂nnen, um die L√§nge dieses Vektors herauszufinden, sondern die Python-Funktionalit√§t verwenden.  Wir lassen die Implementierung weg, wonach alle Werte an Python zur√ºckgegeben werden m√ºssen.  Rufen Sie dazu Py_BuildValue auf, geben Sie an, welchen Datentyp wir zur√ºckgeben. In diesem Fall ist ‚Äûi‚Äú eine Ganzzahl und die Summenvariable selbst. <br><br>  In diesem Fall versteht jeder - wir finden die Summe aller Elemente der Liste.  Gehen wir noch etwas weiter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; length; i++){ <span class="hljs-comment"><span class="hljs-comment">//     //   Python- PyObject* temp = PyList_GetItem(listObj, i); //  ,      //     C long long elem= PyLong_AsLong(temp); sum += elem; }</span></span></code> </pre><br>  Dies ist das gleiche: Im Moment ist listObj ein Python-Objekt.  In diesem Fall versuchen wir, die Listenelemente zu √ºbernehmen.  Python.h hat alles was Sie dazu brauchen. <br><br>  Nachdem wir Temp bekommen haben, versuchen wir es zu lange zu besetzen.  Und erst danach k√∂nnen Sie in C etwas tun. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  static char addList_docs[] = "add( ): add all elements of the list\n"; //    static PyMethodDef addList_funcs[] = { {"add", (PyCFunction)addList_add, METH_VARARGS, addList_docs}, {NULL, NULL, 0, NULL} };</span></span></code> </pre><br>  Nachdem wir die gesamte Funktion implementiert haben, ist es notwendig, Dokumentation zu schreiben.  <strong>Die Dokumentation ist immer gut</strong> und dieses Toolkit bietet alles f√ºr eine bequeme Wartung.  Gem√§√ü der Namenskonvention benennen wir das Modul addList_docs und speichern dort die Beschreibung.  Jetzt m√ºssen Sie das Modul registrieren, daf√ºr gibt es eine spezielle PyMethodDef-Struktur.  Bei der Beschreibung der Eigenschaften sagen wir, dass die Funktion unter dem Namen "add" nach Python exportiert wird und diese Funktion PyCFunction aufruft.  METH_VARARGS bedeutet, dass eine Funktion m√∂glicherweise eine beliebige Anzahl von Variablen annehmen kann.  Wir haben auch zus√§tzliche Zeilen aufgeschrieben und eine Standardpr√ºfung beschrieben, falls wir das Modul gerade importiert haben, aber keine Methode verwendet haben, damit es nicht herunterf√§llt. <br><br>  Nachdem wir dies alles angek√ºndigt haben, versuchen wir ein Modul zu erstellen.  Wir erstellen ein Moduledef und legen alles, was wir getan haben, dort ab. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PyModuleDef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">moduledef</span></span></span><span class="hljs-class"> = {</span></span> PyModuleDef_HEAD_INIT, <span class="hljs-string"><span class="hljs-string">"addList example module"</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, adList_funcs, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre><br>  PyModuleDef_HEAD_INIT ist eine Standard-Python-Konstante, die Sie immer verwenden sollten.  -1 gibt an, dass in der Importphase kein zus√§tzlicher Speicher zugewiesen werden muss. <br><br>  Wenn wir das Modul selbst erstellt haben, m√ºssen wir es initialisieren.  Python sucht immer nach init. Erstellen Sie daher eine PyInit_addList f√ºr addList.  Aus der zusammengesetzten Struktur k√∂nnen Sie nun PyModule_Create aufrufen und schlie√ülich das Modul selbst erstellen.  F√ºgen Sie als N√§chstes die Metainformationen hinzu und geben Sie das Modul selbst zur√ºck. <br><br><pre> <code class="cpp hljs">PyInit_addList(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>){ PyObject *<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = PyModule_Create(&amp;mdef); If (<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PyModule_AddStringConstant(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>, <span class="hljs-string"><span class="hljs-string">"__author__"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bruse Lee&lt;brus@kf.ch&gt;:"</span></span>); PyModule_addStringConstant (Module, <span class="hljs-string"><span class="hljs-string">"__version__"</span></span>, <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>; }</code> </pre><br>  Wie Sie bereits bemerkt haben, gibt es viele Dinge, die ver√§ndert werden m√ºssen.  Sie sollten sich immer an Python erinnern, wenn wir in C / C ++ schreiben. <br><br>  Aus diesem Grund wurde vor etwa 15 Jahren die SWIG-Technologie eingef√ºhrt, um das Leben eines gew√∂hnlichen sterblichen Programmierers zu erleichtern. <br><br><h3>  Swig <br></h3><br>  Mit diesem Tool k√∂nnen Sie Python-Bindungen abstrahieren und nativen Code schreiben.  Es hat die gleichen Vor- und Nachteile wie Native C / C ++, aber es gibt Ausnahmen. <br><br>  SWIG-Profis: <br><br><ul><li>  Stabile Technologie. </li><li>  Eine gro√üe Menge an Dokumentation. </li><li>  Abstracts von der Bindung an Python. </li></ul><br>  Nachteile von SWIG: <br><br><ul><li>  Lange Einrichtung. </li><li>  Wissen C. </li><li>  Segmentierungsfehler. </li><li>  Schwierigkeiten beim Debuggen. </li><li>  Die Komplexit√§t der Integration in die Montage des Projekts. </li></ul><br>  Das erste Minus ist, dass <strong>Sie beim Einrichten den Verstand verlieren</strong> .  Als ich es zum ersten Mal einrichtete, verbrachte ich anderthalb Tage damit, es √ºberhaupt zu starten.  Dann ist es nat√ºrlich einfacher.  SWIG 3.x ist einfacher geworden. <br><br>  Um nicht mehr in den Code einzusteigen, betrachten Sie das allgemeine Schema von SWIG. <br><br><img src="https://habrastorage.org/webt/93/4h/ul/934huleqgml-qurdnxrw8k0gjes.png"><br><br>  example.c ist ein C-Modul, das √ºberhaupt nichts √ºber Python wei√ü.  Es gibt eine Schnittstellendatei example.i, die im SWIG-Format beschrieben wird.  F√ºhren Sie danach das Dienstprogramm SWIG aus, mit dem example_wrap.c aus der Schnittstellendatei erstellt wird. Dies ist derselbe Wrapper, den wir fr√ºher mit unseren H√§nden verwendet haben.  Das hei√üt, SWIG erstellt f√ºr uns nur einen Datei-Wrapper, die sogenannte Br√ºcke.  Danach kompilieren wir mit GCC zwei Dateien und erhalten zwei Objektdateien (example.o und example_wrap.o). Erst dann erstellen wir unsere Bibliothek.  Alles ist einfach und klar. <br><br><h3>  Cython <br></h3><br>  Andrey Svetlov hat auf der MoscowPython Conf einen hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> verfasst. Ich m√∂chte nur sagen, dass dies eine beliebte Technologie mit guter Dokumentation ist. <br><br>  Cython-Vorteile: <br><br><ul><li>  Beliebte Technologie. </li><li>  Ziemlich stabil. </li><li>  Es l√§sst sich leicht in die Projektbaugruppe integrieren. </li><li>  Gute Dokumentation. </li></ul><br>  Nachteile von Cython: <br><br><ul><li>  Eigene Syntax. </li><li>  Wissen C. </li><li>  Segmentierungsfehler. </li><li>  Schwierigkeiten beim Debuggen. </li></ul><br>  Nachteile sind wie immer.  Die wichtigste ist die eigene Syntax, die C / C ++ und Python sehr √§hnlich ist. <br><br>  Ich m√∂chte jedoch darauf hinweisen, dass Python-Code mit Cython durch Schreiben von nativem Code beschleunigt werden kann. <br><br><img src="https://habrastorage.org/webt/tk/8t/sh/tk8tshw1gla6nevwcjda4c9iq20.png"><br><br>  Wie Sie sehen k√∂nnen, gibt es viele Dekorateure, und das ist nicht sehr gut.  Wenn Sie Cython verwenden m√∂chten, lesen Sie den Bericht von Andrei Svetlov. <br><br><h3>  CTypes <br></h3><br>  CTypes ist die Standard-Python-Bibliothek, die mit der Fremdfunktionsschnittstelle zusammenarbeitet.  FFI ist eine Bibliothek auf niedriger Ebene.  Dies ist eine native Technologie, die sehr h√§ufig im Code verwendet wird. Mit ihrer Hilfe ist es einfach, plattform√ºbergreifend zu implementieren. <br><br>  FFI ist jedoch mit viel Aufwand verbunden, da alle Bridges und alle Handler zur Laufzeit dynamisch erstellt werden.  Das hei√üt, wir haben die dynamische Bibliothek geladen, und Python wei√ü derzeit nicht, was die Bibliothek ist.  Nur wenn eine Bibliothek im Speicher aufgerufen wird, werden diese Br√ºcken dynamisch aufgebaut. <br><br>  Vorteile von CT-Typen: <br><br><ul><li>  Native Technologie. </li><li>  Einfach im Code zu verwenden. </li><li>  Einfach plattform√ºbergreifend zu implementieren. </li><li>  Sie k√∂nnen fast jede Sprache verwenden. </li></ul><br>  Nachteile CT-Typen: <br><br><ul><li>  Tr√§gt √ºber Kopf. </li><li>  Schwierigkeiten beim Debuggen. </li></ul><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment">#load the shared object file Adder = CDLL('./adder.so') #Calculate factorial res_int = adder.fact(4) print("Fact of 4 = " + str(res_int))</span></span></code> </pre><br>  Sie nahmen adder.so und riefen es zur Laufzeit auf.  Wir k√∂nnen sogar native Python-Typen √ºbergeben. <br><br>  Nach all dem lautet die Frage: "Es ist irgendwie kompliziert, √ºberall C, was zu tun ist?". <br><br><h3>  Rost <br></h3><br>  Fr√ºher habe ich der Sprache nicht die richtige Aufmerksamkeit geschenkt, aber jetzt wende ich mich praktisch ihr zu. <br><br>  Vorteile von Rust: <br><br><ul><li>  Sichere Sprache. </li><li>  Leistungsstarke statische Garantien f√ºr korrektes Verhalten. </li><li>  Einfache Integration in Projektbuilds ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyO3</a> ). </li></ul><br>  Nachteile von Rost: <br><br><ul><li>  Hohe Eintrittsschwelle. </li><li>  Lange Einrichtung. </li><li>  Schwierigkeiten beim Debuggen. </li><li>  Es gibt wenig Dokumentation. </li><li>  In einigen F√§llen Overhead. </li></ul><br>  Rust ist eine sichere Sprache mit automatischem Arbeitsnachweis.  Die Syntax selbst und der Sprachpr√§prozessor selbst lassen keinen expliziten Fehler zu.  Gleichzeitig konzentriert es sich auf die Variabilit√§t, dh es muss jedes Ergebnis der Ausf√ºhrung des Codezweigs verarbeiten. <br><br>  Dank des PyO3-Teams gibt es gute Python-Ordner f√ºr Rust und Tools zur Integration in das Projekt. <br><br>  Ich gehe davon aus, dass die Konfiguration f√ºr einen unvorbereiteten Programmierer sehr lange dauert.  Nur wenige Dokumentationen, aber anstelle von Nachteilen haben wir keinen Segmentierungsfehler.  In 99% der F√§lle kann ein Programmierer in Rust in guter Weise nur dann einen Segmentierungsfehler erhalten, wenn er ausdr√ºcklich das Auspacken angegeben und ihn nur bewertet hat. <br><br>  Ein kleines Beispiel f√ºr Code, dasselbe Modul, das wir zuvor untersucht haben. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(proc_macro)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> pyo3; Use pyo3::prelude::*; <span class="hljs-comment"><span class="hljs-comment">/// Module documentation string 1 #[py::modinit(_addList)] fn init(py: Python, m: PyModule) -&gt; PyResult &lt;()&gt;{ py_exception!(_addList, EmptyListError); /// Function documentation string 1 #[pufn(m, "run", args= "*", kwargs="**" )] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt; { run(args, kwargs) } #[pyfn(m, "run", args="*", kwatgs="**")] fn run_py(_py: Python, args: &amp;PyTuple, kwargs: Option&lt;&amp;PyDict&gt;) -&gt; PyResult&lt;()&gt;{ run(args,kwargs) } #[pyfn(m,"add")] fn add(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;i32&gt;{ let mut sum : i32 = 0 match py_list.len() { /// Some code Ok(sum) } Ok(()) }</span></span></code> </pre><br>  Der Code hat eine bestimmte Syntax, aber Sie gew√∂hnen sich sehr schnell daran.  Tats√§chlich ist hier alles gleich.  Mit Makros erstellen wir modinit, das f√ºr uns die zus√§tzliche Arbeit erledigt, alle Arten von Bindemitteln f√ºr Python zu generieren.  Denken Sie daran, ich sagte, Sie m√ºssen einen Handler-Wrapper machen, hier ist es das gleiche.  run_py konvertiert Typen, dann rufen wir den nativen Code auf. <br><br>  Wie Sie sehen k√∂nnen, gibt es syntaktischen Zucker, um eine Funktion zu exportieren.  Wir sagen nur, dass wir die Funktion add ben√∂tigen und keine Schnittstellen beschreiben.  Wir akzeptieren eine Liste, die genau py_list und nicht Object ist, da Rust selbst zum Zeitpunkt der Kompilierung die erforderlichen Ordner einrichtet.  Wenn wir den falschen Datentyp √ºbergeben, wie bei Erweiterungserweiterungen, tritt ein TypeError auf.  Nachdem wir die Liste erhalten haben, beginnen wir sie zu verarbeiten. <br><br>  Lassen Sie uns genauer sehen, was er anf√§ngt zu tun. <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[pyfn(m, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"add"</span></span></span><span class="hljs-meta">, py_list=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"*"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(_py: Python, py_list: &amp;PyList) -&gt; PyResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> py_list.len() { <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt;<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(EmptyListError::new(<span class="hljs-string"><span class="hljs-string">"List is empty"</span></span>)), _ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sum : <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> py_list.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp:<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> item.extract() { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(v) =&gt; v, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err_msg: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"List item {} is not int"</span></span>, item); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(ItemListError::new(err_msg)) } }; sum += temp; } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(sum) } } }</code> </pre><br>  Der gleiche Code wie in C / C ++ / Ctypes, jedoch nur in Rust.  Dort habe ich versucht, PyObject auf eine Art Long zu besetzen.  Was w√ºrde passieren, wenn wir auflisten m√ºssten, au√üer Zahlen, w√ºrden wir eine Zeichenfolge bekommen?  Ja, wir w√ºrden einen Systemfehler bekommen.  In diesem Fall durch <strong>let mut</strong> sum <strong>: i32 =</strong> 0;  Wir versuchen auch, einen Wert aus der Liste zu erhalten und ihn in i32 umzuwandeln.  Das hei√üt, wir k√∂nnen diesen Code nicht ohne item.extract () unbewusst schreiben und in den gew√ºnschten Typ umwandeln.  Wenn wir i32 geschrieben haben, hei√üt es im Falle eines Rust-Fehlers in der Kompilierungsphase: "Behandeln Sie den Fall, wenn nicht i32".  In diesem Fall geben wir, wenn wir i32 haben, einen Wert zur√ºck. Wenn dies ein Fehler ist, l√∂sen wir eine Ausnahme aus. <br><br><h2>  Was zu w√§hlen <br></h2><br>  Nach dieser kurzen Tour werden wir uns √ºberlegen, was wir am Ende ausw√§hlen sollen. <br><br>  Die Antwort liegt wirklich in Ihrem Geschmack und Ihrer Farbe. <br><br>  Ich werde keine bestimmte Technologie f√∂rdern. <br><br><img src="https://habrastorage.org/webt/hu/kt/bn/huktbnnsqfoydatdp7gzsisysjg.png"><br><br>  Fassen Sie einfach zusammen, was gesagt wurde: <br><br><ul><li>  Im Fall von SWIG und C / C ++ m√ºssen Sie C / C ++ sehr gut kennen und verstehen, dass die Entwicklung dieses Moduls zus√§tzlichen Aufwand verursacht.  Es wird jedoch ein Minimum an Tools verwendet, und wir werden mit der nativen Python-Technologie arbeiten, die von den Entwicklern unterst√ºtzt wird. </li><li>  Im Fall von Cython haben wir eine kleine Eingabeschwelle, eine hohe Entwicklungsgeschwindigkeit und auch dies ist ein gew√∂hnlicher Codegenerator. </li><li>  Auf Kosten von CTypes m√∂chte ich Sie vor dem relativ hohen Overhead warnen.  Das dynamische Laden von Bibliotheken kann zu gro√üen Problemen f√ºhren, wenn wir nicht wissen, um welche Art von Bibliothek es sich handelt. </li><li>  Ich w√ºrde Rust raten, jemanden mitzunehmen, der C / C ++ nicht gut kennt.  Rost in der Produktion bringt wirklich die geringsten Probleme mit sich. </li></ul><br><div class="spoiler">  <b class="spoiler_title">N√ºtzliche Links</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/zaabjuda/moscowpythonconf2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.python.org/3/extending/building.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://cython.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.python.org/376/library/ctypes.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.swig.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.rust-land.org/en-US/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/PyO3</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=5-WoT4X17sk</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://packaging.python.org/tutorials/distributing-packages/#platformwheels</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/PushAMP/pamagent</a> (Kampfbeispiel f√ºr die gemeinsame Nutzung) </div></div><br><blockquote>  Ruf nach Papieren <br><br>  Wir akzeptieren Bewerbungen f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moscow Python Conf ++</a> bis zum 7. September. Schreiben Sie in dieser einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Form,</a> dass Sie √ºber Python Bescheid wissen, das Sie wirklich mit der Community teilen m√ºssen. <br><br>  F√ºr diejenigen, die mehr am Zuh√∂ren interessiert sind, kann ich √ºber coole Berichte sprechen. <br><br><ul><li>  <strong>Donald Whyte</strong> spricht gerne √ºber die Beschleunigung der Mathematik in Python und bereitet eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Geschichte</a> f√ºr uns vor: Wie man Mathematik mit g√§ngigen Bibliotheken, Tricks und Hinterlist 10-mal schneller macht, und der Code ist klar und unterst√ºtzt. <br></li><li>  <strong>Artyom Malyshev hat</strong> all seine langj√§hrigen Erfahrungen in der Entwicklung von Django gesammelt und pr√§sentiert einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichtsleitfaden</a> zum Framework!  Alles, was zwischen dem Empfang einer HTTP-Anfrage und dem Senden einer fertigen Webseite passiert: Aufdecken von Magie, eine Karte der internen Mechanismen des Frameworks und viele n√ºtzliche Tipps f√ºr Ihre Projekte. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418449/">https://habr.com/ru/post/de418449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418439/index.html">Progressive Webanwendungsgrundlagen</a></li>
<li><a href="../de418441/index.html">Grundlagen der Windows-Berechtigungseskalation</a></li>
<li><a href="../de418443/index.html">GObject: Kapselung, Instanziierung, Selbstbeobachtung</a></li>
<li><a href="../de418445/index.html">Django Channels - die Antwort auf das moderne Web</a></li>
<li><a href="../de418447/index.html">Warum Moscow Python Conf jetzt ++ ist</a></li>
<li><a href="../de418451/index.html">3D-Druckunterricht. Effektive Unterst√ºtzung und √Ñnderung der Schichth√∂he in der Praxis von 3Dtool</a></li>
<li><a href="../de418453/index.html">GRAVITY-Beobachtungen best√§tigen die allgemeine Relativit√§tstheorie weiter</a></li>
<li><a href="../de418455/index.html">Offenes Webinar ‚ÄûSpezialist am Ruder: Erste Erfahrungen und Fehler‚Äú</a></li>
<li><a href="../de418457/index.html">Danke Beitrag: Tag des Systemadministrators</a></li>
<li><a href="../de418459/index.html">Entwicklung eines LVDS-Skalierers mit zwei DisplayPort-Schnittstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>