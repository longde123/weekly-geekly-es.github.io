<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍💻 👮 🧜🏼 Apache Ignite + Apache Spark Data Frames: bersama-sama lebih menyenangkan 🚁 👨🏿‍⚕️ 👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Nikolai Izhikov, saya bekerja untuk Sberbank Technologies di Tim Pengembangan Solusi Sumber Terbuka. Di belakang 15 tahun pengem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Ignite + Apache Spark Data Frames: bersama-sama lebih menyenangkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/427297/">  Halo, Habr!  Nama saya Nikolai Izhikov, saya bekerja untuk Sberbank Technologies di Tim Pengembangan Solusi Sumber Terbuka.  Di belakang 15 tahun pengembangan komersial di Jawa.  Saya seorang komiter Apache Ignite dan kontributor Apache Kafka. <br><br>  Di bawah kucing, Anda akan menemukan versi video dan teks dari laporan saya tentang Apache Ignite Meetup tentang cara menggunakan Apache Ignite dengan Apache Spark dan fitur apa yang telah kami terapkan untuk ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/5f3/df5/f425f3df59ff99d03d4a3e6aff3b2655.png"><br><a name="habracut"></a><br><h2>  Apa yang bisa dilakukan Apache Spark </h2><br>  Apa itu Apache Spark?  Ini adalah produk yang memungkinkan Anda untuk dengan cepat melakukan komputasi terdistribusi dan pertanyaan analitis.  Pada dasarnya, Apache Spark ditulis dalam Scala. <br><br>  Apache Spark memiliki API yang kaya untuk menghubungkan ke berbagai sistem penyimpanan atau menerima data.  Salah satu fitur dari produk ini adalah mesin query universal seperti-SQL untuk data yang diterima dari berbagai sumber.  Jika Anda memiliki beberapa sumber informasi, Anda ingin menggabungkannya dan mendapatkan beberapa hasil, Apache Spark adalah yang Anda butuhkan. <br><br>  Salah satu abstraksi kunci yang disediakan Spark adalah Data Frame, DataSet.  Dalam hal database relasional, ini adalah tabel, sumber yang menyediakan data dengan cara terstruktur.  Struktur, jenis setiap kolom, namanya, dll., Diketahui.  Frame Data dapat dibuat dari berbagai sumber.  Contohnya termasuk file json, database relasional, berbagai sistem hadoop, dan Apache Ignite. <br><br>  Spark mendukung penggabungan dalam query SQL.  Anda dapat menggabungkan data dari berbagai sumber dan mendapatkan hasil, melakukan kueri analitik.  Selain itu, ada API untuk menyimpan data.  Ketika Anda telah menyelesaikan pertanyaan, melakukan penelitian, Spark menyediakan kemampuan untuk menyimpan hasil ke penerima yang mendukung fitur ini, dan, dengan demikian, menyelesaikan masalah pemrosesan data. <br><br><h2>  Fitur apa yang telah kami terapkan untuk mengintegrasikan Apache Spark dengan Apache Ignite </h2><br><ol><li>  Membaca data dari tabel Apache Ignite SQL. </li><li>  Menulis data ke Apache Ignite tabel SQL. </li><li>  IgniteCatalog di dalam IgniteSparkSession - kemampuan untuk menggunakan semua tabel SQL Ignite yang ada tanpa mendaftar "dengan tangan". </li><li>  Optimasi SQL - kemampuan untuk mengeksekusi pernyataan SQL di dalam Ignite. </li></ol><br>  Apache Spark dapat membaca data dari tabel Apache Ignite SQL dan menulisnya dalam bentuk tabel seperti itu.  DataFrame apa pun yang dibentuk di Spark dapat disimpan sebagai tabel SQL Ignite SQL. <br><br>  Apache Ignite memungkinkan Anda untuk menggunakan semua tabel SQL Ignite yang ada di Spark Session tanpa mendaftar "dengan tangan" - menggunakan IgniteCatalog di dalam ekstensi SparkSession standar - IgniteSparkSession. <br><br>  Di sini Anda perlu masuk lebih dalam ke perangkat Spark.  Dalam hal database reguler, direktori adalah tempat penyimpanan informasi meta: tabel mana yang tersedia, kolom mana di dalamnya, dll.  Ketika permintaan datang, informasi meta ditarik dari katalog dan mesin SQL melakukan sesuatu dengan tabel dan data.  Secara default, di Spark, semua tabel baca (tidak masalah, dari database relasional, Ignite, Hadoop) harus didaftarkan secara manual dalam sesi.  Sebagai hasilnya, Anda mendapatkan kesempatan untuk membuat kueri SQL pada tabel ini.  Spark mencari tahu tentang mereka. <br><br>  Untuk bekerja dengan data yang kami unggah ke Ignite, kami perlu mendaftarkan tabel.  Tetapi alih-alih mendaftarkan setiap tabel dengan tangan kami, kami menerapkan kemampuan untuk secara otomatis mengakses semua tabel Ignite. <br><br>  Apa fitur di sini?  Untuk beberapa alasan saya tidak tahu, direktori di Spark adalah API internal, mis.  orang luar tidak bisa datang dan membuat implementasi katalognya sendiri.  Dan, sejak Spark keluar dari Hadoop, itu hanya mendukung Hive.  Dan Anda harus mendaftarkan yang lainnya dengan tangan Anda.  Pengguna sering bertanya bagaimana Anda bisa menyiasatinya dan segera membuat pertanyaan SQL.  Saya menerapkan direktori yang memungkinkan Anda untuk menelusuri dan mengakses tabel Ignite tanpa mendaftar ~ dan sms ~, dan awalnya mengusulkan tambalan ini di komunitas Spark, yang saya terima jawabannya: tambalan semacam itu tidak menarik karena beberapa alasan internal.  Dan mereka tidak memberikan API internal. <br><br>  Sekarang katalog Ignite adalah fitur menarik yang diimplementasikan menggunakan API internal Spark.  Untuk menggunakan direktori ini, kami memiliki implementasi sesi kami sendiri. Ini adalah SparkSession biasa, di mana Anda dapat membuat permintaan, memproses data.  Perbedaannya adalah bahwa kami mengintegrasikan ExternalCatalog ke dalamnya untuk bekerja dengan tabel Ignite, serta IgniteOptimization, yang akan dijelaskan di bawah ini. <br><br>  <b>Optimasi SQL</b> - kemampuan untuk mengeksekusi pernyataan SQL di dalam Ignite.  Secara default, saat melakukan penggabungan, pengelompokan, penghitungan agregat, dan kueri SQL kompleks lainnya, Spark membaca data dalam mode baris demi baris.  Satu-satunya sumber data dapat lakukan adalah menyaring baris secara efisien. <br><br>  Jika Anda menggunakan bergabung atau mengelompokkan, Spark menarik semua data dari tabel ke dalam memorinya ke pekerja, menggunakan filter yang ditentukan, dan hanya kemudian mengelompokkan mereka atau melakukan operasi SQL lainnya.  Dalam kasus Ignite, ini tidak optimal, karena Ignite sendiri memiliki arsitektur terdistribusi dan memiliki pengetahuan tentang data yang disimpan di dalamnya.  Oleh karena itu, Ignite sendiri dapat secara efisien menghitung agregat dan melakukan pengelompokan.  Selain itu, mungkin ada banyak data, dan untuk mengelompokkannya, Anda perlu mengurangi segalanya, mengumpulkan semua data dalam Spark, yang cukup mahal. <br><br>  Spark menyediakan API yang dengannya Anda dapat mengubah rencana awal kueri SQL, melakukan optimasi, dan meneruskan bagian dari kueri SQL yang dapat dieksekusi di sana menjadi Ignite.  Ini akan efektif dalam hal kecepatan maupun konsumsi memori, karena kami tidak akan menggunakannya untuk mengeluarkan data yang akan segera dikelompokkan. <br><br><h2>  Bagaimana cara kerjanya </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b28/1df/0ef/b281df0ef5f2ea2a08f73267ef7f5edb.png"><br><br>  Kami memiliki gugus Ignite - ini adalah bagian bawah gambar.  Tidak ada Zookeeper, karena hanya ada lima node.  Ada pekerja percikan, di dalam setiap pekerja simpul klien Ignite dinaikkan.  Melalui itu, kita dapat membuat permintaan dan membaca data, berinteraksi dengan cluster.  Juga, simpul klien naik di dalam IgniteSparkSession agar direktori berfungsi. <br><br><h2>  Nyalakan bingkai data </h2><br>  Kita beralih ke kode: bagaimana membaca data dari tabel SQL?  Dalam kasus Spark, semuanya cukup sederhana dan baik: kami mengatakan bahwa kami ingin menghitung beberapa data, menunjukkan format - ini adalah konstanta tertentu.  Selanjutnya, kami memiliki beberapa opsi - jalur ke file konfigurasi untuk node klien, yang dimulai saat membaca data.  Kami menunjukkan tabel mana yang ingin kami baca dan beri tahu Spark untuk memuat.  Kami mendapatkan data dan kami dapat melakukan apa yang kami inginkan dengannya. <br><br><pre><code class="scala hljs">spark.read .format(<span class="hljs-type"><span class="hljs-type">FORMAT_IGNITE</span></span>) .option(<span class="hljs-type"><span class="hljs-type">OPTION_CONFIG_FILE</span></span>, <span class="hljs-type"><span class="hljs-type">TEST_CONFIG_FILE</span></span>) .option(<span class="hljs-type"><span class="hljs-type">OPTION_TABLE</span></span>, <span class="hljs-string"><span class="hljs-string">"person"</span></span>) .load()</code> </pre> <br>  Setelah kami menghasilkan data - opsional dari Ignite, dari sumber apa pun - kami dapat dengan mudah menyimpan semuanya dengan menentukan format dan tabel terkait.  Kami memerintahkan Spark untuk menulis, kami menentukan format.  Dalam konfigurasi, kami meresepkan kluster mana yang akan dihubungkan.  Tentukan tabel tempat kami ingin menyimpan.  Selain itu, kami dapat meresepkan opsi utilitas - tentukan kunci utama yang kami buat di tabel ini.  Jika data hanya mengecewakan tanpa membuat tabel, maka parameter ini tidak diperlukan.  Pada akhirnya, klik simpan dan data ditulis. <br><br><pre> <code class="scala hljs">tbl.write. format(<span class="hljs-type"><span class="hljs-type">FORMAT_IGNITE</span></span>). option(<span class="hljs-type"><span class="hljs-type">OPTION_CONFIG_FILE</span></span>, <span class="hljs-type"><span class="hljs-type">CFG_PATH</span></span>). option(<span class="hljs-type"><span class="hljs-type">OPTION_TABLE</span></span>, tableName). option(<span class="hljs-type"><span class="hljs-type">OPTION_CREATE_TABLE_PRIMARY_KEY_FIELDS</span></span>, pk). save</code> </pre><br>  Sekarang mari kita lihat bagaimana semuanya bekerja. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b35/41a/b86/b3541ab86eca15cd240765bf15907979.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LoadDataExample.scala</a> <br><br>  Aplikasi yang jelas ini pertama-tama akan menunjukkan kemampuan merekam.  Misalnya, saya memilih data pada pertandingan sepak bola, statistik yang diunduh dari sumber yang terkenal.  Ini berisi informasi tentang turnamen: liga, pertandingan, pemain, tim, atribut pemain, atribut tim - data yang menggambarkan pertandingan sepak bola di liga negara-negara Eropa (Inggris, Perancis, Spanyol, dll.). <br><br>  Saya ingin mengunggahnya ke Ignite.  Kami membuat sesi Spark, menentukan alamat wizard dan memanggil pemuatan tabel ini, melewati parameter.  Contohnya adalah dalam Scala, bukan Java, karena Scala kurang verbose dan jadi lebih baik misalnya. <br><br>  Kami mentransfer nama file, membacanya, menunjukkan bahwa itu multiline, ini adalah file json standar.  Kemudian kami menulis di Ignite.  Struktur file kita tidak dapat dijelaskan - Spark sendiri menentukan data apa yang kita miliki dan apa strukturnya.  Jika semuanya berjalan lancar, sebuah tabel dibuat dengan semua bidang yang diperlukan dari tipe data yang diperlukan.  Ini adalah bagaimana kita dapat memuat semua yang ada di dalam Ignite. <br><br>  Ketika data dimuat, kita bisa melihatnya di Ignite dan langsung menggunakannya.  Sebagai contoh sederhana, kueri yang memungkinkan Anda mengetahui tim mana yang paling banyak memainkan pertandingan.  Kami memiliki dua kolom: hometeam dan awayteam, host dan tamu.  Kami memilih, mengelompokkan, menghitung, menjumlahkan, dan bergabung dengan data pada perintah - untuk memasukkan nama perintah.  Ta-dam - dan data dari json-chiks kami dapatkan di Ignite.  Kami melihat Paris Saint-Germain, Toulouse - kami memiliki banyak data tentang tim-tim Prancis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/202/52b/8a420252be6fb8df3a9083d7411911a9.png"><br><br>  Kami meringkas.  Kami sekarang telah mengunggah data dari sumber, file json, ke Ignite, dan cukup cepat.  Mungkin, dari sudut pandang data besar, ini tidak terlalu besar, tetapi layak untuk komputer lokal.  Skema tabel diambil dari file json dalam bentuk aslinya.  Tabel dibuat, nama kolom disalin dari file sumber, kunci utama dibuat.  ID ada di mana-mana, dan kunci utama adalah ID.  Data ini masuk ke Ignite, kita bisa menggunakannya. <br><br><h2>  IgniteSparkSession dan IgniteCatalog </h2><br>  Mari kita lihat cara kerjanya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/654/24a/4ee/65424a4eeda4a4c2c6cce7038e13d1a9.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KatalogExample.scala</a> <br><br>  Dengan cara yang cukup sederhana, Anda dapat mengakses dan menanyakan semua data Anda.  Pada contoh terakhir, kami memulai sesi percikan standar.  Dan tidak ada spesifisitas Ignite di sana - kecuali bahwa Anda harus meletakkan jar dengan sumber data yang tepat - benar-benar pekerjaan standar melalui API publik.  Tetapi, jika Anda ingin mengakses tabel Ignite secara otomatis, Anda dapat menggunakan ekstensi kami.  Perbedaannya adalah bahwa alih-alih SparkSession kita menulis IgniteSparkSession. <br><br>  Segera setelah Anda membuat objek IgniteSparkSession, Anda melihat di direktori semua tabel yang baru saja dimuat ke dalam Ignite.  Anda dapat melihat diagram mereka dan semua informasi.  Spark sudah tahu tentang tabel yang dimiliki Ignite, dan Anda dapat dengan mudah mendapatkan semua data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dec/f1b/a0c/decf1ba0c5db2e0d84e50a0e88b6c192.png"><br><br><h2>  Optimalisasi penyalaan </h2><br>  Saat Anda membuat kueri kompleks di Ignite menggunakan JOIN, Spark menarik datanya terlebih dahulu, dan baru kemudian GABUNG mengelompokkannya.  Untuk mengoptimalkan proses, kami membuat fitur IgniteOptimization - ini mengoptimalkan rencana permintaan Spark dan memungkinkan Anda untuk meneruskan bagian-bagian dari permintaan yang dapat dieksekusi di dalam Ignite di dalam Ignite.  Kami menampilkan pengoptimalan berdasarkan permintaan tertentu. <br><br><pre> <code class="sql hljs">SQL Query: <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>   city_id,   <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>   person p <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> city_id <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Kami memenuhi permintaan itu.  Kami memiliki meja orang - beberapa karyawan, orang-orang.  Setiap karyawan tahu ID kota tempat dia tinggal.  Kami ingin tahu berapa banyak orang yang tinggal di setiap kota.  Kami memfilter - di kota mana lebih dari satu orang tinggal.  Berikut adalah rencana awal yang dibangun Spark: <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Analyzed</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == city_id: bigint, count(<span class="hljs-number"><span class="hljs-number">1</span></span>): bigint <span class="hljs-type"><span class="hljs-type">Project</span></span> [city_id#<span class="hljs-number"><span class="hljs-number">19</span></span>L, count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">52</span></span>L] +- <span class="hljs-type"><span class="hljs-type">Filter</span></span> (count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">54</span></span>L &gt; cast(<span class="hljs-number"><span class="hljs-number">1</span></span> as bigint))  +- <span class="hljs-type"><span class="hljs-type">Aggregate</span></span> [city_id#<span class="hljs-number"><span class="hljs-number">19</span></span>L], [city_id#<span class="hljs-number"><span class="hljs-number">19</span></span>L, count(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">AS</span></span> count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">52</span></span>L, count(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">AS</span></span> count(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">54</span></span>L] +- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> p    +- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> person       +- <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">NAME</span></span>#<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-type"><span class="hljs-type">BIRTH_DATE</span></span>#<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-type"><span class="hljs-type">IS_RESIDENT</span></span>#<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-type"><span class="hljs-type">SALARY</span></span>#<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-type"><span class="hljs-type">PENSION</span></span>#<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-type"><span class="hljs-type">ACCOUNT</span></span>#<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-type"><span class="hljs-type">AGE</span></span>#<span class="hljs-number"><span class="hljs-number">17</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">18</span></span>L,<span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>#<span class="hljs-number"><span class="hljs-number">19</span></span>L]         <span class="hljs-type"><span class="hljs-type">IgniteSQLRelation</span></span>[table=<span class="hljs-type"><span class="hljs-type">PERSON</span></span>]</code> </pre><br>  Relasi hanyalah tabel Ignite.  Tidak ada filter - kami hanya memompa semua data dari tabel Person melalui jaringan dari cluster.  Kemudian Spark mengumpulkan semua ini - sesuai dengan permintaan dan mengembalikan hasil permintaan. <br><br>  Sangat mudah untuk melihat bahwa semua subtree ini dengan filter dan agregasi dapat dieksekusi di dalam Ignite.  Ini akan jauh lebih efisien daripada menarik semua data dari tabel berpotensi besar di Spark - inilah yang dilakukan fitur IgniteOptimization kami.  Setelah menganalisis dan mengoptimalkan pohon, kami mendapatkan rencana berikut: <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Optimized</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>#<span class="hljs-number"><span class="hljs-number">19</span></span>L,<span class="hljs-type"><span class="hljs-type">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)#<span class="hljs-number"><span class="hljs-number">52</span></span>L]   <span class="hljs-type"><span class="hljs-type">IgniteSQLAccumulatorRelation</span></span>(     columns=[<span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>, <span class="hljs-type"><span class="hljs-type">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)], qry=<span class="hljs-type"><span class="hljs-type">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">CITY_ID</span></span>, <span class="hljs-type"><span class="hljs-type">COUNT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">FROM</span></span> <span class="hljs-type"><span class="hljs-type">PERSON</span></span> <span class="hljs-type"><span class="hljs-type">GROUP</span></span> <span class="hljs-type"><span class="hljs-type">BY</span></span> city_id <span class="hljs-type"><span class="hljs-type">HAVING</span></span> count(<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Akibatnya, kami hanya mendapatkan satu relasi, karena kami mengoptimalkan seluruh pohon.  Dan di dalam Anda sudah dapat melihat bahwa Ignite akan mengirim permintaan yang cukup dekat dengan permintaan asli. <br><br>  Misalkan kita bergabung dengan berbagai sumber data: misalnya, kita memiliki satu DataFrame dari Ignite, yang kedua dari json, yang ketiga lagi dari Ignite, dan yang keempat dari beberapa jenis database relasional.  Dalam hal ini, hanya subtree yang akan dioptimalkan dalam rencana.  Kami mengoptimalkan apa yang kami bisa, letakkan di Ignite, dan Spark akan melakukan sisanya.  Karena ini, kami mendapatkan keuntungan dalam kecepatan. <br><br>  Contoh lain dengan GABUNG: <br><br><pre> <code class="sql hljs">SQL Query - <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jt1.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> id1, jt1.val1, jt2.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> id2, jt2.val2 <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> jt1 <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> jt2 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> jt1.val1 = jt2.val2</code> </pre><br>  Kami punya dua meja.  Kami tetap bersama berdasarkan nilai dan memilih dari semuanya - ID, nilai.  Spark menawarkan rencana seperti itu: <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Analyzed</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == id1: bigint, val1: string, id2: bigint, val2: string <span class="hljs-type"><span class="hljs-type">Project</span></span> [id#<span class="hljs-number"><span class="hljs-number">4</span></span>L <span class="hljs-type"><span class="hljs-type">AS</span></span> id1#<span class="hljs-number"><span class="hljs-number">84</span></span>L, val1#<span class="hljs-number"><span class="hljs-number">3</span></span>, id#<span class="hljs-number"><span class="hljs-number">6</span></span>L <span class="hljs-type"><span class="hljs-type">AS</span></span> id2#<span class="hljs-number"><span class="hljs-number">85</span></span>L, val2#<span class="hljs-number"><span class="hljs-number">5</span></span>] +- <span class="hljs-type"><span class="hljs-type">Join</span></span> <span class="hljs-type"><span class="hljs-type">Inner</span></span>, (val1#<span class="hljs-number"><span class="hljs-number">3</span></span> = val2#<span class="hljs-number"><span class="hljs-number">5</span></span>) :- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> jt1 : +- <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">VAL1</span></span>#<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">4</span></span>L] <span class="hljs-type"><span class="hljs-type">IgniteSQLRelation</span></span>[table=<span class="hljs-type"><span class="hljs-type">JT1</span></span>] +- <span class="hljs-type"><span class="hljs-type">SubqueryAlias</span></span> jt2    +- <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">VAL2</span></span>#<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">6</span></span>L] <span class="hljs-type"><span class="hljs-type">IgniteSQLRelation</span></span>[table=<span class="hljs-type"><span class="hljs-type">JT2</span></span>]</code> </pre> <br>  Kita melihat bahwa dia akan mengeluarkan semua data dari satu tabel, semua data dari tabel kedua, bergabung dengan mereka di dalam dirinya sendiri dan memberikan hasilnya.  Setelah diproses dan dioptimalkan, kami mendapatkan permintaan yang sama persis dengan Ignite, yang dijalankan dengan relatif cepat. <br><br><pre> <code class="scala hljs">== <span class="hljs-type"><span class="hljs-type">Optimized</span></span> <span class="hljs-type"><span class="hljs-type">Logical</span></span> <span class="hljs-type"><span class="hljs-type">Plan</span></span> == <span class="hljs-type"><span class="hljs-type">Relation</span></span>[<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">84</span></span>L,<span class="hljs-type"><span class="hljs-type">VAL1</span></span>#<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-type"><span class="hljs-type">ID</span></span>#<span class="hljs-number"><span class="hljs-number">85</span></span>L,<span class="hljs-type"><span class="hljs-type">VAL2</span></span>#<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-type"><span class="hljs-type">IgniteSQLAccumulatorRelation</span></span>(columns=[<span class="hljs-type"><span class="hljs-type">ID</span></span>, <span class="hljs-type"><span class="hljs-type">VAL1</span></span>, <span class="hljs-type"><span class="hljs-type">ID</span></span>, <span class="hljs-type"><span class="hljs-type">VAL2</span></span>], qry= <span class="hljs-type"><span class="hljs-type">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> <span class="hljs-type"><span class="hljs-type">AS</span></span> id1, <span class="hljs-type"><span class="hljs-type">JT1</span></span>.<span class="hljs-type"><span class="hljs-type">VAL1</span></span>, <span class="hljs-type"><span class="hljs-type">JT2</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> <span class="hljs-type"><span class="hljs-type">AS</span></span> id2, <span class="hljs-type"><span class="hljs-type">JT2</span></span>.<span class="hljs-type"><span class="hljs-type">VAL2</span></span> <span class="hljs-type"><span class="hljs-type">FROM</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span> <span class="hljs-type"><span class="hljs-type">JOIN</span></span> <span class="hljs-type"><span class="hljs-type">JT2</span></span> <span class="hljs-type"><span class="hljs-type">ON</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span>.val1 = <span class="hljs-type"><span class="hljs-type">JT2</span></span>.val2 <span class="hljs-type"><span class="hljs-type">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">JT1</span></span>.val1 <span class="hljs-type"><span class="hljs-type">IS</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span> <span class="hljs-type"><span class="hljs-type">AND</span></span> <span class="hljs-type"><span class="hljs-type">JT2</span></span>.val2 <span class="hljs-type"><span class="hljs-type">IS</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> <span class="hljs-type"><span class="hljs-type">NULL</span></span>)</code> </pre> <br>  Saya akan tunjukkan contoh. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba4/39a/493/ba439a493e76dd573966cad413c07650.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OptimizationExample.scala</a> <br><br>  Kami membuat sesi IgniteSpark di mana semua kemampuan optimasi kami sudah termasuk secara otomatis.  Di sini permintaannya adalah ini: temukan para pemain dengan peringkat tertinggi dan tampilkan nama mereka.  Di tabel pemain, atribut dan datanya.  Kami bergabung, memfilter data sampah dan menampilkan pemain dengan peringkat tertinggi.  Mari kita lihat jenis rencana apa yang kita dapatkan setelah optimasi, dan tunjukkan hasil dari query ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/c51/9ab/c7dc519abdfa6b3b1d7a8396ef9725b3.png"><br><br>  Kita mulai.  Kami melihat nama keluarga yang akrab: Messi, Buffon, Ronaldo, dll.  Ngomong-ngomong, beberapa karena alasan tertentu bertemu dalam dua samaran - baik Messi dan Ronaldo.  Pecinta sepak bola mungkin merasa aneh bahwa pemain tak dikenal muncul di daftar.  Ini adalah kiper, pemain dengan karakteristik agak tinggi - dengan latar belakang pemain lain.  Sekarang kita melihat rencana permintaan yang dieksekusi.  Di Spark, hampir tidak ada yang dilakukan, yaitu, kami mengirim seluruh permintaan lagi ke Ignite. <br><br><h2>  Pengembangan Apache Apache </h2><br>  Proyek kami adalah produk open source, jadi kami selalu senang dengan tambalan dan umpan balik dari pengembang.  Bantuan, umpan balik, tambalan Anda sangat kami harapkan.  Kami sedang menunggu mereka.  90% komunitas Ignite berbahasa Rusia.  Sebagai contoh, bagi saya, sampai saya mulai bekerja di Apache Ignite, bukan pengetahuan bahasa Inggris terbaik adalah pencegah.  Hampir tidak layak menulis dalam bahasa Rusia di daftar dev, tetapi bahkan jika Anda menulis sesuatu yang salah, mereka akan menjawab dan membantu Anda. <br><br>  Apa yang dapat ditingkatkan pada integrasi ini?  Bagaimana saya dapat membantu jika Anda memiliki keinginan seperti itu?  Daftar di bawah ini.  Tanda bintang menunjukkan kompleksitas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de4/d43/ed0/de4d43ed01894ce6b02865ad9f6aef5d.png"><br>  Untuk menguji pengoptimalan, Anda perlu menulis tes dengan kueri yang kompleks.  Di atas, saya menunjukkan beberapa pertanyaan yang jelas.  Jelas bahwa jika Anda menulis banyak pengelompokan dan banyak bergabung, maka sesuatu dapat jatuh.  Ini adalah tugas yang sangat sederhana - datang dan lakukanlah.  Jika kami menemukan bug berdasarkan hasil tes, bug tersebut harus diperbaiki.  Akan lebih sulit di sana. <br><br>  Tugas lain yang jelas dan menarik adalah integrasi Spark dengan klien tipis.  Awalnya dapat menentukan beberapa set alamat IP, dan ini cukup untuk bergabung dengan cluster Ignite, yang nyaman dalam kasus integrasi dengan sistem eksternal.  Jika Anda tiba-tiba ingin bergabung dengan solusi untuk masalah ini, saya pribadi akan membantu dengannya. <br><br>  Jika Anda ingin bergabung dengan komunitas Apache Ignite, berikut adalah beberapa tautan bermanfaat: <br><br><ul><li>  <i>Mulai di sini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://yu">https://ignite.apache.org/community/resources.html</a></i> <br></li><li>  <i>Sumber di sini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/apache/ignite/</a></i> <br></li><li>  <i>Dermaga di sini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://apacheignite.readme.io/docs</a></i> <br></li><li>  <i>Bug di sini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://issues.apache.org/jira/browse/IGNITE</a></i> <br></li><li>  <i>Anda dapat menulis di sini - dev@ignite.apache.org, user@ignite.apache.org</i> <br></li></ul><br>  Kami memiliki daftar pengembang yang responsif, yang akan membantu Anda.  Ini masih jauh dari ideal, tetapi dibandingkan dengan proyek lain itu benar-benar hidup. <br><br>  <i>Jika Anda tahu Java atau C ++, Anda sedang mencari pekerjaan dan ingin mengembangkan Open Source (Apache Ignite, Apache Kafka, Tarantool, dll.) Tulis di sini: join-open-source@sberbank.ru.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CzbAweNKEVY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427297/">https://habr.com/ru/post/id427297/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427285/index.html">Sekolah di dasar-dasar sirkuit digital: Novosibirsk - Ok, Krasnoyarsk - bersiap-siap</a></li>
<li><a href="../id427289/index.html">Pemodelan Geologi 3D, Penebangan dan Technaton dari Aramco Innovations</a></li>
<li><a href="../id427291/index.html">Perkecil lalu lintas di Formulir Web ASP.NET, div yang dapat diklik, dan polling server berkala</a></li>
<li><a href="../id427293/index.html">Pola Desain JavaScript</a></li>
<li><a href="../id427295/index.html">Fungsi Karir JavaScript</a></li>
<li><a href="../id427299/index.html">Mari kita cari yang lain untuk dikoleksi? Konstruktor 3 in 1 "Armada Lunar"</a></li>
<li><a href="../id427301/index.html">GitHub menabrak basis data</a></li>
<li><a href="../id427303/index.html">Memperlambat Windows Bagian 2: Membuat Proses</a></li>
<li><a href="../id427307/index.html">Praktik pengujian backend Java + Diasuransikan</a></li>
<li><a href="../id427309/index.html">Bagaimana PVS-Studio ternyata lebih penuh perhatian daripada tiga setengah programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>