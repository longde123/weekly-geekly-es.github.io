<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧤 🚓 🛣️ Pemrograman Dinamis atau Divide and Conquer 🎅 👨🏼 🐴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas persamaan dan perbedaan antara dua pendekatan untuk menyelesaikan masalah algoritmik: pemrograman dinamis (pemrograman dinamis) d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman Dinamis atau Divide and Conquer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423939/"> Artikel ini membahas persamaan dan perbedaan antara dua pendekatan untuk menyelesaikan masalah algoritmik: <b>pemrograman</b> dinamis (pemrograman dinamis) dan prinsip <b>"divide and conquer"</b> (divide and conquer).  Kami akan membandingkan menggunakan dua algoritma sebagai contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian biner</a> (cara cepat menemukan angka dalam array yang diurutkan) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jarak Levenshtein</a> (cara mengkonversi satu baris ke yang lain dengan jumlah operasi minimum). <br><br>  <i>Saya ingin segera mencatat bahwa perbandingan dan penjelasan ini tidak mengklaim sangat benar.</i>  <i>Dan mungkin bahkan beberapa profesor universitas ingin mengeluarkan saya :) Artikel ini hanyalah upaya pribadi saya untuk menyelesaikan masalah dan memahami apa pemrograman dinamis dan bagaimana prinsip "membagi dan menaklukkan" dilibatkan.</i> <br><br>  Jadi, mari kita mulai ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/863/582/ca28635824478a8aa8e81bd43c78338e.png" alt="gambar"><br><a name="habracut"></a><br><h3>  Masalah </h3><br>  Ketika saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai mempelajari algoritma,</a> sulit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagi</a> saya untuk memahami ide dasar pemrograman dinamis (selanjutnya <b>DP</b> , dari Pemrograman Dinamis) dan bagaimana ia berbeda dari pendekatan "divide and conquer" (selanjutnya <b>DC</b> , dari divide-and-conquer).  Ketika datang untuk membandingkan kedua paradigma ini, biasanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak yang berhasil menggunakan fungsi Fibonacci</a> untuk menggambarkan.  Dan ini adalah ilustrasi yang bagus.  Tetapi bagi saya tampaknya ketika kita menggunakan tugas yang <b>sama</b> untuk menggambarkan DP dan DC, kita kehilangan satu detail penting yang dapat membantu kita menangkap perbedaan antara dua pendekatan lebih cepat.  Dan detail ini adalah bahwa kedua teknik ini paling dimanifestasikan dalam menyelesaikan <b>berbagai</b> jenis masalah. <br><br>  Saya masih dalam proses belajar DP dan DC dan saya tidak bisa mengatakan bahwa saya sepenuhnya memahami konsep-konsep ini.  Tetapi saya masih berharap bahwa artikel ini akan memberi tambahan cahaya dan membantu mengambil langkah selanjutnya dalam mempelajari pendekatan signifikan seperti pemrograman dinamis dan divide-and-conquer. <br><br><h3>  Kesamaan antara DP dan DC </h3><br>  Cara saya melihat kedua konsep ini sekarang, saya dapat menyimpulkan bahwa <b>DP adalah versi tambahan dari DC</b> . <br><br>  Saya <b>tidak</b> akan menganggap mereka sesuatu yang sama sekali berbeda.  Karena kedua konsep ini <b>secara rekursif membagi masalah menjadi dua atau lebih subproblem dari jenis yang sama</b> sampai subproblem ini cukup mudah untuk diselesaikan secara langsung.  Selanjutnya, semua solusi untuk subproblem digabungkan bersama untuk akhirnya memberikan jawaban atas masalah asli. <br><br>  Jadi, mengapa kita masih memiliki dua pendekatan berbeda (DP dan DC) dan mengapa saya menyebut pemrograman dinamis sebagai ekstensi.  Ini karena pemrograman dinamis dapat diterapkan pada tugas yang memiliki <b>karakteristik dan batasan</b> tertentu.  Dan hanya dalam hal ini DP memperluas DC melalui dua teknik: <b>memoisasi</b> dan <b>tabulasi</b> . <br><br>  Mari kita sedikit lebih dalam ke detail ... <br><br><h3>  Keterbatasan dan karakteristik yang diperlukan untuk pemrograman dinamis </h3><br>  Seperti yang baru saja kita ketahui, ada dua karakteristik utama yang harus dimiliki oleh suatu tugas / masalah agar kita dapat menyelesaikannya menggunakan pemrograman dinamis: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Substruktur optimal</a> - harus mungkin untuk menyusun solusi optimal untuk masalah dari solusi optimal ke subtugasnya. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Persimpangan subproblem</a> - masalahnya harus dipecah menjadi subproblem, yang pada gilirannya digunakan kembali berulang kali.  Dengan kata lain, pendekatan rekursif untuk memecahkan masalah akan menyiratkan solusi berganda ( <b>bukan</b> tunggal) untuk subproblem yang sama, alih-alih menghasilkan subproblem baru dan unik di setiap siklus rekursif. </li></ol><br>  Segera setelah kami dapat menemukan dua karakteristik ini dalam masalah yang kami pertimbangkan, kami dapat mengatakan bahwa itu dapat diselesaikan menggunakan pemrograman dinamis. <br><br><h3>  Pemrograman dinamis sebagai perpanjangan dari prinsip "divide and conquer" </h3><br>  DP memperluas DC dengan bantuan dua teknik ( <b>memoisasi</b> dan <b>tabulasi</b> ), yang tujuannya adalah untuk menyimpan solusi untuk submasalah untuk digunakan kembali di masa depan.  Dengan demikian, solusi di-cache oleh subproblem, yang mengarah ke peningkatan yang signifikan dalam kinerja algoritma.  Sebagai contoh, kompleksitas waktu dari implementasi rekursif "naif" dari fungsi Fibonacci adalah <code>O(2 <sup>n</sup> )</code> .  Pada saat yang sama, solusi berdasarkan pemrograman dinamis dieksekusi hanya dalam waktu <code>(n)</code> . <br><br>  <b>Memoisasi (mengisi cache dari atas ke bawah)</b> adalah teknik caching yang menggunakan solusi yang baru dihitung untuk subtugas.  Fungsi Fibonacci menggunakan teknik memoisasi akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">memFib(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem[n] is <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) result = n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = memFib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) + memFib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) mem[n] = result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre> <br>  <b>Tabulasi (mengisi cache dari bawah ke atas)</b> adalah teknik yang serupa, tetapi yang terutama difokuskan pada pengisian cache, dan bukan pada menemukan solusi untuk subproblem.  Perhitungan nilai-nilai yang perlu di-cache paling mudah dalam hal ini dilakukan secara iteratif, daripada secara rekursif.  Fungsi Fibonacci menggunakan teknik tabulasi akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">tabFib(n) { mem[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> mem[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2.</span></span>..n mem[i] = mem[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] + mem[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre><br>  Anda dapat membaca lebih lanjut tentang perbandingan memoisasi dan tabulasi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Gagasan utama yang perlu ditangkap dalam contoh-contoh ini adalah bahwa karena masalah DC kami memiliki subproblem yang tumpang tindih, kami dapat menggunakan caching solusi untuk subproblem menggunakan salah satu dari dua teknik caching: memoisasi dan tabulasi. <br><br><h3>  Jadi apa perbedaan antara DP dan DC pada akhirnya </h3><br>  Kami belajar tentang batasan dan prasyarat untuk menggunakan pemrograman dinamis, serta teknik caching yang digunakan dalam pendekatan DP.  Mari kita rangkum dan gambarkan pemikiran di atas dalam ilustrasi berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f1/8e4/8a1/8f18e48a15bcdbe1e3541540c8a76274.png" alt="gambar"><br><br>  Mari kita coba memecahkan beberapa masalah menggunakan DP dan DC untuk menunjukkan kedua pendekatan ini dalam tindakan. <br><br><h3>  Divide and Conquer Contoh: Pencarian Biner </h3><br>  Algoritma pencarian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biner</a> adalah algoritma pencarian yang menemukan posisi elemen yang diminta dalam array yang diurutkan.  Dalam pencarian biner, kami membandingkan nilai variabel dengan nilai elemen di tengah array.  Jika mereka tidak sama, maka setengah dari array di mana elemen yang diinginkan tidak dapat dikecualikan dari pencarian lebih lanjut.  Pencarian berlanjut di setengah dari array, di mana variabel yang diinginkan dapat ditemukan sampai ditemukan.  Jika setengah dari array tidak mengandung elemen, pencarian dianggap selesai dan kami menyimpulkan bahwa array tidak mengandung nilai yang diinginkan. <br><br>  <b>Contoh</b> <br><br>  Ilustrasi di bawah ini adalah contoh pencarian biner untuk angka 4 dalam array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/845/628/a3f8456289058a7401640fdf368e7c44.png" alt="gambar"><br><br>  Mari kita gambarkan logika pencarian yang sama, tetapi dalam bentuk "pohon keputusan". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/79d/904/a9f79d904494ff947b2d730de4e9fbba.png" alt="gambar"><br><br>  Anda dapat melihat dalam diagram ini prinsip yang jelas tentang "bagilah dan taklukkan", yang digunakan untuk menyelesaikan masalah ini.  Kami secara iteratif membagi array asli kami menjadi sub-sus dan mencoba menemukan elemen yang kami cari sudah ada di dalamnya. <br><br>  Bisakah kita mengatasi masalah ini menggunakan pemrograman dinamis?  <b>Tidak.</b>  Karena tugas <b>ini tidak mengandung subproblem berpotongan</b> .  Setiap kali kami membagi array menjadi beberapa bagian, kedua bagian tersebut sepenuhnya independen dan tidak tumpang tindih.  Dan sesuai dengan asumsi dan batasan pemrograman dinamis yang kita bahas di atas, subproblem entah bagaimana harus tumpang tindih, mereka <b>harus berulang</b> . <br><br>  Biasanya, setiap kali pohon keputusan terlihat persis seperti <b>pohon</b> (dan <b>tidak seperti grafik</b> ), ini kemungkinan besar berarti tidak ada subproblem yang tumpang tindih, <br><br>  <b>Implementasi algoritma</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat menemukan kode sumber lengkap dari algoritma pencarian biner dengan tes dan penjelasan. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binarySearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sortedArray, seekElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endIndex = sortedArray.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (startIndex &lt;= endIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleIndex = startIndex + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((endIndex - startIndex) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If we've found the element just return its position. if (sortedArray[middleIndex] === seekElement)) { return middleIndex; } // Decide which half to choose: left or right one. if (sortedArray[middleIndex] &lt; seekElement)) { // Go to the right half of the array. startIndex = middleIndex + 1; } else { // Go to the left half of the array. endIndex = middleIndex - 1; } } return -1; }</span></span></code> </pre><br><h3>  Contoh Pemrograman Dinamis: Mengedit Jarak </h3><br>  Biasanya, ketika datang untuk menjelaskan pemrograman dinamis, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi Fibonacci</a> digunakan sebagai contoh.  Tetapi dalam kasus kami, mari kita ambil contoh yang sedikit lebih kompleks.  Semakin banyak contoh, semakin mudah untuk memahami konsep. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jarak pengeditan</a> (atau jarak Levenshtein) antara dua baris adalah jumlah operasi minimum untuk menyisipkan satu karakter, menghapus satu karakter dan mengganti satu karakter dengan yang lain, yang diperlukan untuk mengubah satu baris menjadi yang lain. <br><br>  <b>Contoh</b> <br><br>  Misalnya, jarak pengeditan antara kata "kitten" dan "sitting" adalah 3, karena Anda perlu melakukan tiga operasi pengeditan (dua penggantian dan satu sisipan) untuk mengonversi satu baris ke yang lain.  Dan tidak mungkin menemukan opsi konversi yang lebih cepat dengan operasi yang lebih sedikit: <br><br><ol><li>  kitten → sitten (mengganti "k" dengan "s") </li><li>  sitten → sittin (mengganti “e” dengan “i”) </li><li>  duduk → duduk (masukkan "g" sepenuhnya). </li></ol><br>  <b>Aplikasi algoritma</b> <br><br>  Algoritme ini memiliki beragam aplikasi, misalnya untuk pemeriksaan ejaan, sistem koreksi pengenalan optik, pencarian string yang tidak akurat, dll. <br><br>  <b>Definisi matematika dari suatu masalah</b> <br><br>  Secara matematis, jarak Levenstein antara dua garis <code>a, b</code> (dengan panjang | a | dan <code>|b|</code> masing-masing) ditentukan oleh fungsi <code>function lev(|a|, |b|)</code> , di mana: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/242/84e/2f424284e297eab78f308d35eb27ed94.png" alt="gambar"><br><br>  Harap dicatat bahwa baris pertama dalam fungsi <code>min</code> sesuai dengan operasi <b>hapus</b> , baris kedua sesuai dengan operasi <b>sisipan</b> dan baris ketiga sesuai dengan operasi <b>penggantian</b> (jika huruf-hurufnya tidak sama). <br><br>  <b>Penjelasan</b> <br><br>  Mari kita coba mencari tahu apa yang dikatakan formula ini kepada kita.  Ambil contoh sederhana untuk menemukan jarak pengeditan minimum antara <b>ME</b> dan baris <b>MY</b> .  Secara intuitif, Anda sudah tahu bahwa jarak pengeditan minimum adalah satu ( <b>1</b> ) operasi penggantian (ganti "E" dengan "Y").  Tetapi mari kita meresmikan solusi kita dan mengubahnya menjadi bentuk algoritmik, agar dapat menyelesaikan versi yang lebih kompleks dari masalah ini, seperti mengubah kata <b>Saturday</b> menjadi <b>Sunday</b> . <br><br>  Untuk menerapkan rumus pada transformasi ME → MY, pertama-tama kita harus mengetahui jarak pengeditan minimum antara ME → M, M → MY dan M → M.  Selanjutnya, kita harus memilih minimal tiga jarak dan menambahkan padanya satu operasi (+1) dari transformasi E → Y. <br><br>  Jadi, kita sudah dapat melihat sifat rekursif dari solusi ini: jarak pengeditan minimum ME → MY dihitung berdasarkan tiga kemungkinan transformasi sebelumnya.  Jadi, kita sudah dapat mengatakan bahwa ini adalah algoritma divide and conquer. <br><br>  Untuk lebih menjelaskan algoritma, mari kita letakkan dua baris kita dalam sebuah matriks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/71e/646/b3d71e646f887852ecf0a579ff8c5957.png" alt="gambar"><br><br>  <b>Sel (0,1)</b> berisi angka merah 1. Ini berarti bahwa kita perlu melakukan 1 operasi untuk mengubah M menjadi string kosong - hapus M. Oleh karena itu, kami telah menandai angka ini dengan warna merah. <br><br>  <b>Sel (0,2)</b> berisi angka merah 2. Ini berarti bahwa kita perlu melakukan 2 operasi untuk mengubah string ME menjadi string kosong - hapus E, hapus M. <br><br>  <b>Sel (1,0)</b> berisi angka hijau 1. Ini berarti bahwa kita memerlukan 1 operasi untuk mengubah string kosong menjadi M - tempel M. Kami menandai operasi sisipan berwarna hijau. <br><br>  <b>Sel (2,0)</b> berisi angka hijau 2. Ini berarti bahwa kita perlu melakukan 2 operasi untuk mengubah string kosong menjadi string MY - masukkan Y, masukkan M. <br><br>  <b>Sel (1,1)</b> berisi angka 0. Ini berarti bahwa kita tidak perlu melakukan operasi apa pun untuk mengubah string M menjadi M. <br><br>  <b>Sel (1,2)</b> berisi angka merah 1. Ini berarti bahwa kita perlu melakukan 1 operasi untuk mengubah string ME menjadi M - hapus E. <br><br>  Dan seterusnya ... <br><br>  Itu tidak terlihat sulit untuk matriks kecil, seperti kita (hanya 3x3).  Tetapi bagaimana kita bisa menghitung nilai semua sel untuk matriks besar (misalnya, untuk matriks 9x7 dalam transformasi Sabtu → Minggu)? <br><br>  Berita baiknya adalah, sesuai dengan rumus, yang kita butuhkan untuk menghitung nilai sel apa pun dengan koordinat <code>(i,j)</code> hanyalah nilai dari 3 sel tetangga <code>(i-1,j)</code> , <code>(i-1,j-1)</code> , dan <code>(i,j-1)</code> .  Yang perlu kita lakukan adalah menemukan nilai minimum tiga sel tetangga dan menambahkan satu (+1) ke nilai ini jika kita memiliki huruf yang berbeda di baris ke-i dan kolom ke-j. <br><br>  Jadi sekali lagi, Anda dapat dengan jelas melihat sifat rekursif dari tugas ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c96/541/c96/c96541c96d184b5f7dee8b1465e5963e.png" alt="gambar"><br><br>  Kami juga melihat bahwa kami berhadapan dengan tugas membagi dan menaklukkan.  Tetapi, dapatkah kita menerapkan pemrograman dinamis untuk mengatasi masalah ini?  Apakah tugas ini memenuhi persyaratan " <b>masalah berpotongan</b> " dan " <b>substruktur optimal</b> " yang disebutkan di atas?  <b>Ya</b>  Mari kita membangun pohon keputusan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/d3d/aac/cfad3daaccada3e2bbfb66c85f93a9ef.png" alt="gambar"><br><br>  Pertama, Anda mungkin memperhatikan bahwa pohon keputusan kami lebih mirip <b>grafik keputusan</b> <b>daripada</b> <b>pohon</b> .  Anda juga dapat melihat <b>beberapa subtugas yang tumpang tindih</b> .  Terlihat juga bahwa tidak mungkin untuk mengurangi jumlah operasi dan membuatnya lebih kecil dari jumlah operasi dari ketiga sel tetangga (sub-masalah). <br><br>  Anda juga dapat memperhatikan bahwa nilai di setiap sel dihitung berdasarkan nilai sebelumnya.  Jadi, dalam hal ini, teknik <b>tabulasi</b> digunakan (mengisi cache dalam arah bottom-up).  Anda akan melihat ini dalam contoh kode di bawah ini. <br><br>  Dengan menerapkan semua prinsip ini, kita dapat memecahkan masalah yang lebih kompleks, misalnya, tugas transformasi Sabtu → Minggu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c60/843/ae9c6084303f344ab2d54fbeaeb7f9d3.png" alt="gambar"><br><br>  <b>Contoh kode</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat menemukan solusi lengkap untuk menemukan jarak pengeditan minimum dengan tes dan penjelasan: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceMatrix = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(b.length + <span class="hljs-number"><span class="hljs-number">1</span></span>) .fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(a.length + <span class="hljs-number"><span class="hljs-number">1</span></span>).fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[j][<span class="hljs-number"><span class="hljs-number">0</span></span>] = j; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indicator = a[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] === b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; distanceMatrix[j][i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( distanceMatrix[j][i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// deletion distanceMatrix[j - 1][i] + 1, // insertion distanceMatrix[j - 1][i - 1] + indicator, // substitution ); } } return distanceMatrix[b.length][a.length]; }</span></span></code> </pre><br><h3>  Kesimpulan </h3><br>  Dalam artikel ini, kami membandingkan dua pendekatan algoritmik ("pemrograman dinamis" dan "membagi dan menaklukkan") untuk memecahkan masalah.  Kami menemukan bahwa pemrograman dinamis menggunakan prinsip "divide and conquer" dan dapat diterapkan untuk menyelesaikan masalah jika masalah tersebut mengandung subproblem berpotongan dan substruktur optimal (seperti halnya dengan jarak Levenshtein).  Pemrograman dinamis lebih lanjut menggunakan teknik memoisasi dan tabulasi untuk mempertahankan sub-resolusi untuk digunakan kembali nanti. <br><br>  Saya harap artikel ini mengklarifikasi daripada mempersulit situasi bagi Anda yang mencoba untuk berurusan dengan konsep-konsep penting seperti pemrograman dinamis dan "membagi dan menaklukkan" :) <br><br>  Anda dapat menemukan lebih banyak contoh algoritmik menggunakan pemrograman dinamis, dengan tes dan penjelasan dalam repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma JavaScript dan Struktur Data</a> . <br><br>  Pengodean yang berhasil! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423939/">https://habr.com/ru/post/id423939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423927/index.html">10 mesin pencari yang menjanjikan untuk meningkatkan SEO</a></li>
<li><a href="../id423931/index.html">Bagaimana cara memotong otentikasi SMS saat menghubungkan ke jaringan Wi-Fi publik?</a></li>
<li><a href="../id423933/index.html">Keamanan Microsoft Office: Objek Tertanam</a></li>
<li><a href="../id423935/index.html">Embox menjawab pertanyaan populer dari festival IT TechTrain</a></li>
<li><a href="../id423937/index.html">Eskalasi hak istimewa Windows</a></li>
<li><a href="../id423941/index.html">Laporan dari iOS mitap Redmadrobot</a></li>
<li><a href="../id423943/index.html">Pengoptimalan harga eceran offline</a></li>
<li><a href="../id423945/index.html">Mahkamah Agung menetapkan prosedur untuk mempertimbangkan kasus-kasus dengan repost dan suka</a></li>
<li><a href="../id423947/index.html">Data pribadi kami tidak dikenakan biaya apa pun</a></li>
<li><a href="../id423949/index.html">Alam semesta yang konsisten dengan kepercayaan kita saat ini mungkin tidak dimungkinkan.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>