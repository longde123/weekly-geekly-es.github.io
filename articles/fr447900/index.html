<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔼 🚴🏻 🕥 Fermer les contacts ADL 🏻 👨🏽‍🎨 🎴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment écrire son nom dans l'histoire pour toujours? Le premier à voler vers la lune? Le premier à rencontrer un esprit étranger? Nous avons un moyen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fermer les contacts ADL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447900/"><p><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p>  Comment écrire son nom dans l'histoire pour toujours?  Le premier à voler vers la lune?  Le premier à rencontrer un esprit étranger?  Nous avons un moyen plus simple - vous pouvez vous adapter au standard du langage C ++. </p><br><p>  Eric Nibler, auteur de C ++ Ranges, en fournit un bon exemple.  «Souviens-toi de ça.  Le 19 février 2019 est le jour où le terme «nibloïde» a été prononcé pour la première fois lors de la réunion du WG21 », a-t-il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit</a> sur Twitter. </p><br><p>  En effet, si vous allez sur CppReference, dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la section cpp / algorithme / rangescpp / algorithme / plages</a> , vous y trouverez de nombreuses références (niebloid).  Pour cela, un modèle wiki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dsc_niebloid</a> distinct a même été créé. </p><br><p>  Malheureusement, je n'ai trouvé aucun article officiel complet sur ce sujet et j'ai décidé d'écrire le mien.  Il s'agit d'un petit mais fascinant voyage dans les abîmes de l'astronautique architecturale, dans lequel nous pouvons plonger dans l'abîme de la folie de l'ADL et nous familiariser avec les nibloïdes. </p><br><p>  Important: je ne suis pas un vrai soudeur, mais un javiste qui corrige parfois des erreurs dans le code C ++ si nécessaire.  Si vous prenez un peu de temps pour trouver des erreurs de raisonnement, ce serait bien.  "Aide Dasha le voyageur à collecter quelque chose de raisonnable." </p><a name="habracut"></a><br><h2 id="lookup">  Recherche </h2><br><p>  Vous devez d'abord décider des conditions.  Ce sont des choses bien connues, mais «l'explicite vaut mieux que l'implicite», nous en discuterons donc séparément.  Je n'utilise pas de véritable terminologie en russe, mais j'utilise plutôt l'anglais.  Cela est nécessaire car même le mot «restriction» dans le contexte de cet article peut être associé à au moins trois versions anglaises, dont la différence est importante pour la compréhension. </p><br><p>  Par exemple, en C ++, il y a le concept d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche de nom</a> ou, en d'autres termes, une recherche: lorsqu'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nom</a> est trouvé dans un programme, il compile avec sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déclaration</a> lors de la compilation. </p><br><p> Une recherche peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qualifiée</a> (si le nom est à droite de l'opérateur d'autorisation de la portée <code>::</code> :), et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">non qualifiée</a> dans d'autres cas.  Si la recherche est qualifiée, nous contournons les membres correspondants de la classe, de l'espace de noms ou de l'énumération.  On pourrait appeler cela la version «complète» de l'enregistrement (comme cela semble être fait dans la traduction de Straustrup), mais il vaut mieux laisser l'orthographe originale, car cela fait référence à un type d'exhaustivité très spécifique. </p><br><h2 id="adl">  ADL </h2><br><p>  Si la recherche n'est pas qualifiée, nous devons comprendre exactement où chercher le nom.  Et ici, une fonctionnalité spéciale appelée ADL est incluse: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche dépendante de l'argument</a> , ou bien - la recherche de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Koenig</a> (celui qui a inventé le terme «anti-modèle», qui est un peu symbolique à la lumière du texte suivant).  Nicolai Josuttis dans son livre "The C ++ Standard Library: A Tutorial and Reference" le décrit comme suit: "Le fait est que vous n'avez pas besoin de qualifier l'espace de noms de la fonction si au moins un des types d'arguments est défini dans l'espace de noms de cette fonction." </p><br><p>  À quoi devrait-il ressembler? </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl">  Descendez en enfer avec ADL </h2><br><p>  Cela semble simple.  Ou pas?  Tout d'abord, selon le type d'argument, ADL fonctionne de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">neuf manières différentes</a> , pour tuer avec un balai. </p><br><p>  Deuxièmement, purement pratique, imaginez que nous ayons une sorte de fonction d'échange.  Il s'avère que <code>std::swap(obj1,obj2);</code>  et en <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  peut se comporter complètement différemment.  Si ADL est activé, à partir de plusieurs swaps différents, celui dont vous avez besoin est déjà sélectionné en fonction des espaces de noms des arguments!  Selon le point de vue, cet idiome peut être considéré à la fois comme un exemple positif et négatif :-) </p><br><p>  S'il vous semble que cela ne suffit pas, vous pouvez déposer le bois de chauffage dans le four du chapeau.  Ceci a été récemment bien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit par Arthur O'Dwyer</a> .  J'espère qu'il ne me punira pas pour avoir utilisé son exemple. </p><br><p>  Imaginez que vous ayez un programme de ce type: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Bien sûr, il ne compile pas avec une erreur: </p><br><pre> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p>  Mais si vous y ajoutez une <strong>surcharge complètement inutilisée de la</strong> fonction <code>f</code> , alors tout fonctionnera! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Sur Visual Studio, il va encore se casser, mais tel est son sort, ne fonctionne pas. </p><br><p>  Comment est-ce arrivé?  Plongeons-nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la norme</a> (sans traduction, car une telle traduction serait un méli-mélo de mots à la mode exceptionnellement monstrueux): </p><br><blockquote>  Si l'argument est le nom ou l'adresse d'un ensemble de fonctions et / ou de modèles de fonctions surchargés, ses entités et espaces de noms associés sont l'union de ceux associés à chacun des membres de l'ensemble, c'est-à-dire les entités et espaces de noms associés à son paramètre types et type de retour.  [...] De plus, si l'ensemble susmentionné de fonctions surchargées est nommé avec un template-id, ses entités et espaces de noms associés incluent également ceux de son type template-arguments et son template template-arguments. </blockquote><p>  Maintenant, prenez un code comme celui-ci: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p>  Dans les deux cas, des arguments sont obtenus sans type.  <code>f</code> et <code>f&lt;B::B&gt;</code> sont les noms des ensembles de fonctions surchargées (de la définition ci-dessus), et un tel ensemble n'a pas de type.  Pour réduire une surcharge en une seule fonction, vous devez comprendre quel type de pointeur de fonction convient le mieux à la meilleure surcharge d' <code>call</code> .  Vous devez donc collecter un ensemble de candidats pour l' <code>call</code> , ce qui signifie exécuter un <code>call</code> recherche.  Et pour cela, ADL va commencer! </p><br><p>  Mais généralement pour ADL, nous devons connaître les types d'arguments!  Et ici, Clang, ICC et MSVC se cassent par erreur comme suit (mais GCC ne le fait pas): </p><br><pre> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p>  Même les créateurs de compilateurs avec ADL ont une relation un peu tendue. </p><br><p>  Eh bien, ADL semble-t-il toujours être une bonne idée?  D'une part, nous n'avons plus besoin d'écrire un tel code servile de manière polie: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p>  D'un autre côté, nous avons échangé par souci de brièveté le fait qu'il existe maintenant un système qui fonctionne de manière complètement inhumaine.  Une histoire tragique et majestueuse sur la façon dont la facilité d'écrire Halloworld peut affecter la langue entière sur une échelle de décennies. </p><br><h2 id="renzhi-i-koncepty">  Gammes et concepts </h2><br><p>  Si vous ouvrez la description de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque Nibler Rangers</a> , même avant la mention des nibloïdes, vous tomberez sur de nombreux autres marqueurs appelés <strong>(concept)</strong> .  C'est déjà un joli truc, mais juste au cas où (pour les vieux et les javistes) je vais vous rappeler ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que c'est</a> . </p><br><p>  Les concepts sont appelés ensembles nommés de contraintes qui s'appliquent aux arguments de modèle pour sélectionner les meilleures surcharges de fonction et les spécialisations de modèle les plus appropriées. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Ici, nous avons imposé une restriction selon laquelle l'argument doit avoir une fonction <code>to_string</code> qui renvoie une chaîne.  Si nous essayons de mettre un jeu dans l' <code>print</code> qui ne relève pas des restrictions, ce code ne sera tout simplement pas compilé. </p><br><p>  Cela simplifie considérablement le code.  Par exemple, voyez comment Nibler a fait le <a href="">tri dans les plages-v3</a> , qui fonctionne en C ++ 11/14/17.  Il y a un merveilleux code comme celui-ci: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p>  Pour que plus tard vous puissiez faire: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p>  J'espère que vous vouliez déjà voir tout cela et utiliser simplement des concepts préparés dans un nouveau compilateur. </p><br><h2 id="tochki-kastomizacii">  Points de personnalisation </h2><br><p>  La prochaine chose intéressante qui peut être trouvée dans la norme est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">customization.point.object</a> .  Ils sont activement utilisés dans la bibliothèque Nibler Ranges. </p><br><p>  Le point de personnalisation est une fonction utilisée par la bibliothèque standard afin qu'il puisse être surchargé pour les types d'utilisateurs dans l'espace de noms de l'utilisateur, et ces surcharges peuvent être trouvées à l'aide d'ADL. </p><br><p>  Les points de personnalisation sont conçus avec les principes architecturaux suivants à l' <code>cust</code> ( <code>cust</code> est le nom de certains points de personnalisation imaginaires): </p><br><ul><li>  Le code qui appelle <code>cust</code> écrit sous la forme qualifiée <code>std::cust(a)</code> ou non qualifié: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  Les deux entrées doivent se comporter de manière identique.  En particulier, ils doivent trouver toutes les surcharges utilisateur dans l'espace de noms associé aux arguments. </li><li>  Code qui utilise <code>cust</code> sous la forme d'une <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  ne devrait pas pouvoir contourner les restrictions imposées à <code>std::cust</code> . </li><li>  Les appels de points personnalisés devraient fonctionner efficacement et de manière optimale sur tout compilateur assez moderne. </li><li>  La décision ne devrait pas créer de nouvelles violations de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">règle de définition unique (RLL)</a> . </li></ul><br><p>  Pour comprendre de quoi il s'agit, vous pouvez jeter un œil au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">N4381</a> .  À première vue, ils ressemblent à un moyen d'écrire vos propres versions de <code>begin</code> , <code>swap</code> , <code>data</code> , etc., et la bibliothèque standard les récupère à l'aide d'ADL. </p><br><p>  La question est, en quoi cela diffère-t-il de l'ancienne pratique, lorsque l'utilisateur écrit une surcharge pour certains <code>begin</code> pour son propre type et espace de noms?  Et pourquoi sont-ils même des objets? </p><br><p>  En fait, ce sont des instances d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objets fonctionnels</a> dans l' <code>std</code> .  Leur objectif est de tirer d'abord des vérifications de type (conçues comme des concepts) sur tous les arguments d'affilée, puis d'envoyer l'appel à la fonction correcte dans l' <code>std</code> ou de le mettre en vente dans ADL. </p><br><p>  En fait, ce n'est pas le genre de chose que vous utiliseriez dans un programme normal sans bibliothèque.  C'est une fonctionnalité de la bibliothèque standard, qui vous permettra d'ajouter une vérification de concept aux futurs points d'extension, ce qui entraînera à son tour l'affichage d'erreurs plus belles et plus compréhensibles si vous avez gâché quelque chose dans les modèles. </p><br><p>  L'approche actuelle des points de personnalisation pose quelques problèmes.  Premièrement, il est très facile de tout casser.  Imaginez ce code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p>  Si nous appelons accidentellement <code>std::swap(t1, t2)</code> notre propre version de <code>swap</code> ne démarrera jamais, peu importe ce que nous y mettons.  Mais plus important encore, il n'y a aucun moyen d'attacher de manière centralisée des vérifications de concept à ces implémentations de fonctions personnalisées.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">N4381, ils</a> écrivent: </p><br><p>  «Imaginez qu'un jour à l'avenir, <code>std::begin</code> exigera que son argument soit modélisé comme un concept <code>Range</code> .  L'ajout d'une telle restriction n'aura tout simplement aucun effet sur le code en utilisant <code>std::begin</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p>  Après tout, si l'appel de <code>begin</code> est envoyé à la version surchargée créée par l'utilisateur, les restrictions sur <code>std::begin</code> simplement ignorées. » </p><br><p>  La solution décrite dans la proposition résout les deux problèmes, pour cela nous utilisons l'approche de cette implémentation spéculative de <code>std::begin</code> (vous pouvez regarder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">godbolt</a> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p>  Un appel qualifié de certains <code>my_std::begin(someObject)</code> passe toujours par <code>my_std::detail::begin_fn</code> - et c'est bien.  Qu'arrive-t-il à un appel sans réserve?  Relisons notre article: </p><br><p>  «Dans le cas où begin est appelé sans qualification immédiatement après l'apparition de <code>my_std::begin</code> dans la portée, la situation change quelque peu.  À la première étape de la recherche, le nom <code>begin</code> résolu en l'objet global <code>my_std::begin</code> .  Étant donné que la recherche a trouvé un objet et non une fonction, la deuxième phase de la recherche n'est pas effectuée.  En d'autres termes, si <code>my_std::begin</code> est un objet, alors utiliser la construction <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  simplement équivalent à <code>std::begin(a);</code>  "Et comme nous l'avons vu, cela lance ADL personnalisé." </p><br><p>  C'est pourquoi la validation de concept peut être effectuée dans un objet fonction dans l' <code>std</code> avant qu'ADL appelle la fonction fournie par l'utilisateur.  Il n'y a aucun moyen de tromper ce comportement. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii">  Comment les points de personnalisation se personnalisent-ils? </h2><br><p>  En fait, «objet de point de personnalisation» (CPO) n'est pas un bon nom.  Du nom, il n'est pas clair comment ils se développent, quels mécanismes sont sous le capot, quelles fonctions ils préfèrent ... </p><br><p>  Ce qui nous amène au terme «nibloïde».  Un nibloïde est un CPO qui appelle la fonction X s'il est défini dans la classe, sinon il appelle la fonction X s'il existe une fonction libre appropriée, sinon il essaie d'exécuter une solution de repli de la fonction X. </p><br><p>  Ainsi, par exemple, les <code>ranges::swap</code> nibloïdes <code>ranges::swap</code> lors de l'appel de <code>ranges::swap(a, b)</code> essaieront d'abord d'appeler <code>a.swap(b)</code> .  S'il n'y a pas une telle méthode, il essaiera d'appeler <code>swap(a, b)</code> utilisant ADL.  Si cela ne fonctionne pas, essayez <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi">  Résumé </h1><br><p>  Comme Matt a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plaisanté</a> sur Twitter, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dave</a> a suggéré une fois de faire fonctionner les objets fonctionnels avec ADL tout comme les fonctions normales, pour des raisons de cohérence.  L'ironie est que leur capacité à désactiver l'ADL et à être invisible pour lui est maintenant devenue leur principal avantage. </p><br><p>  Cet article entier était une préparation pour cela. </p><br><p>  " <i><b>Je viens de tout comprendre, c'est tout. Voulez-vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écouter</a> ?</b></i> </p><br><p>  <i><b>Avez-vous déjà regardé quelque chose, et cela semblait fou, puis sous un jour différent</b></i> <i><b><br></b></i>  <i><b>des choses folles les voyant normales?</b></i> </p><br><p><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p>  <i><b>N'ayez pas peur.</b></i>  <i><b>N'ayez pas peur.</b></i>  <i><b>Je me sens tellement bien dans l'âme.</b></i>  <i><b>Tout ira bien.</b></i>  <i><b>Je ne me sens pas si bien depuis de nombreuses années.</b></i>  <i><b>Tout ira bien.</b></i> </p><br><p><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote>  Minute de publicité.  Déjà <b>cette semaine</b> , du 19 au 20 avril, C ++ Russia 2019 aura lieu - une conférence remplie de présentations hardcore à la fois sur la langue elle-même et sur des questions pratiques comme le multithreading et la performance.  Soit dit en passant, la conférence est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ouverte par</a> Nicolai Josuttis, l'auteur de The C ++ Standard Library: A Tutorial and Reference <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> mentionné dans l'article.  Vous pouvez vous familiariser avec le programme et acheter des billets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site officiel</a> .  Il reste très peu de temps, c'est la dernière chance. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447900/">https://habr.com/ru/post/fr447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447890/index.html">Dieu merci, je ne suis pas manager</a></li>
<li><a href="../fr447892/index.html">Deux nouveaux concours PHDays: contournement IDS et piratage d'usine</a></li>
<li><a href="../fr447894/index.html">MODX Digest # 3 (25 mars - 8 avril 2019)</a></li>
<li><a href="../fr447896/index.html">Images d'esquisses: exactement comment fonctionne le réseau neuronal NVIDIA GAUGAN</a></li>
<li><a href="../fr447898/index.html">Des philosophes bien nourris ou une programmation .NET compétitive</a></li>
<li><a href="../fr447902/index.html">GitHub a complètement «supprimé» le référentiel de l'utilitaire de référentiel de verrouillage et l'intégralité du compte créateur</a></li>
<li><a href="../fr447904/index.html">Les experts de Positive Technologies identifient les tentatives d'exploitation massive d'une vulnérabilité critique dans Confluence</a></li>
<li><a href="../fr447906/index.html">Innovations réelles: qu'attendre du marché des datacenters en 2019?</a></li>
<li><a href="../fr447908/index.html">Deux façons de collecter des récompenses pour la publicité dans les jeux mobiles, ou les robots devraient fonctionner</a></li>
<li><a href="../fr447910/index.html">Le pétrole de l'économie moderne et la guerre du personnel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>