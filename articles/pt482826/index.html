<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüéì üëèüèø ‚ñ´Ô∏è Analisando uma demo de 128 bytes do arquivo de 1997 üçß ü•© üê≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√â muito agrad√°vel satisfazer meus desejos, especialmente do passado distante, t√£o distante que eu j√° esqueci que j√° o desejei. Sei pouco sobre o demos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisando uma demo de 128 bytes do arquivo de 1997</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/"> √â muito agrad√°vel satisfazer meus desejos, especialmente do passado distante, t√£o distante que eu j√° esqueci que j√° o desejei.  Sei pouco sobre o demosceno e certamente nunca acompanhei os autores ou o trabalho deles, apenas gostei de ver o que aconteceu.  √Äs vezes, eu queria descobrir, mas faltava conhecimento e experi√™ncia, perseveran√ßa posterior e perdi completamente o interesse por isso.  Mas recentemente, meu amigo, com quem estudamos na √©poca e que nos forneceu todos os novos produtos, incluindo demos, com BBS e Fidonet, porque quase todos tinham telefone e modem e computador ao mesmo tempo, visitou a <a href="https://cafeparty.org.ru/2019/" rel="nofollow">CAFePARTY</a> com seu trabalho que me fez abrir o arquivo do meu primeiro computador, selecione uma demonstra√ß√£o e descubra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br>  Avaliando objetivamente meus pontos fortes, fiz uma introdu√ß√£o de 128 bytes, de que gostei visualmente.  O arquivo <code>pentagra.com</code> √© assinado por <b>Mcm</b> , 128 bytes, modificado pela √∫ltima vez em 9/24/1996 18:10:14, hex dump: <br><br> <code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42 <br> 000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40 <br> 000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03 <br> 000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7 <br> 000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab <br> 000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88 <br> 000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c <br> 000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d <br></code> <a name="habracut"></a><br>  Do mesmo arquivo, retirei: <br><br><ul><li>  <b>Hiew 6.11</b> ( <a href="http://www.hiew.ru/" rel="nofollow">6.50</a> pode ser encontrado no site) - usei-o como desmontador </li><li>  Pacote <b>TASM</b> - com o qual coletei o c√≥digo recebido de volta para garantir que n√£o estragasse nada </li><li>  <b>Ajuda TECH da Flambeaux Software!</b>  <b>6.0</b> - refer√™ncia on-line moderadamente detalhada e abrangente para API do DOS, fun√ß√µes da BIOS, hardware e montador </li><li>  <b>Mayko G.V.</b>  <b>Assembler para IBM PC</b> - uma refer√™ncia de formato quase do tamanho de um bolso para todos os comandos b√°sicos do Intel 8086 e regras de formata√ß√£o de texto do programa.  Sem detalhes arquitet√¥nicos e com exemplos elementares, apenas as coisas mais b√°sicas.  H√° quase tudo o que voc√™ precisa aqui, mas voc√™ n√£o pode escrever no assembler al√©m do ambiente. </li><li>  Portanto, o segundo livro <b>Zubkov S.V.</b>  <b>Montador.</b>  <b>Para DOS, Windows e Unix</b> - Um guia para brechas de hardware e DOS </li></ul><br>  Da implementa√ß√£o m√≠nima extrema, deve-se esperar o uso de truques e abordagens fora do padr√£o, mas, al√©m de algumas suposi√ß√µes nas condi√ß√µes iniciais, n√£o vi nenhum truque t√©cnico, mas vi um truque algor√≠tmico.  E aqui algumas palavras devem ser ditas sobre a experi√™ncia.  Qual poderia ser a dificuldade?  Na implementa√ß√£o ou no algoritmo.  Por exemplo, no comando <code>mov di, 099d1h</code> , voc√™ pode ter medo de uma constante m√°gica.  Mas se voc√™ estiver no contexto de uso, fica claro que esse √© o endere√ßo para acesso nas coordenadas da tela X e Y, onde X = 17, Y = 123, 320 √© a resolu√ß√£o horizontal da tela em pixels.  Juntos, isso nos d√° 17 + 123 * 320, a convers√£o de coordenadas bidimensionais para unidimensionais. <br><br>  Agora, olhando o que est√° acontecendo na tela, posso facilmente imaginar como implementar isso, embora n√£o com 128 bytes, mesmo que n√£o seja 100% semelhante, mas sim.  E h√° 20 anos n√£o consegui, embora tenha retirado todas as ferramentas que usei de prateleiras empoeiradas e n√£o precisei navegar na Internet para entender como funciona.  Portanto, antes de tudo, este √© um contexto, uma compreens√£o do QUE est√° acontecendo e, portanto, a quest√£o dos truques e COMO FAZER isso est√° em segundo lugar. <br><br>  O que vemos: <br><br><ol><li>  5 linhas do pentagrama.  Estas n√£o s√£o necessariamente linhas inextric√°veis ‚Äã‚Äãdiretas de acordo com todos os c√¢nones.  Vemos apenas a figura geral, sem detalhes </li><li>  O efeito chama, que consiste em duas partes importantes: uma paleta selecionada corretamente e um algoritmo para alterar constantemente a cor dos pontos na tela com elementos de incerteza, mas mantendo uma sequ√™ncia cont√≠nua de paletas para os pontos vizinhos.  Por exemplo, voc√™ pode calcular a tela atual inteira calculando a m√©dia dos valores dos pixels vizinhos da tela anterior e adicionar mais pontos "brilhantes" em locais aleat√≥rios, ou n√£o em locais aleat√≥rios, mas em valor aleat√≥rio, ou n√£o por acaso, apenas se afastando da ordem linear.  Uma op√ß√£o √© <a href="https://habr.com/ru/post/435122/">como isso √© feito no DOOM</a> .  O resultado deve ser na forma de cores fluindo umas nas outras, desde √°reas brilhantes constantemente emergentes at√© desbotamento </li></ol><br>  Resta entender como isso foi feito.  Uma descri√ß√£o mais aprofundada n√£o substituir√° o conhecimento sobre a arquitetura do computador e as fun√ß√µes do DOS ou do assembler, mas ter esse conhecimento permitir√° que voc√™ entenda e se concentre na ess√™ncia do que est√° acontecendo.  Tendo come√ßado a escrever, percebi que tudo resulta em detalhes suficientes, mas n√£o podia recusar para n√£o perder no sentido da hist√≥ria. <br><br><h3>  DOS e carregamento de programas .COM </h3><br>  O programa no arquivo <code>.com</code> √© um c√≥digo limpo, sem cabe√ßalhos, voc√™ s√≥ precisa coloc√°-lo no lugar certo.  √â isso que o DOS faz, ou melhor, a chamada do sistema de 4Bh.  Muitas a√ß√µes est√£o ocorrendo, vamos nos concentrar no resultado: <br><br><ul><li>  Todos os segmentos registram CS, DS, ES, SS carregados com um √∫nico valor </li><li>  65536 bytes s√£o reservados para todo o programa, exatamente um segmento ao qual todos os registros de segmento indicam.  Os primeiros 256 bytes s√£o ocupados pelo cabe√ßalho do sistema - PSP (prefixo de segmento de programa).  No CS: 0, o primeiro campo do PSP, o comando INT 20h est√° localizado - para finalizar o programa atual e transferir o controle para o processo pai.  O programa em si come√ßa com o endere√ßo CS: 100h e ocupa os seguintes 128 bytes </li><li>  A palavra 0000h √© colocada na pilha, o registro SP √© FFFEh.  Isso significa que os dois √∫ltimos bytes deste segmento no endere√ßo SS: FFFEh s√£o redefinidos.  De fato, este √© o endere√ßo de retorno mais pr√≥ximo do procedimento, o que nos levar√° ao comando de conclus√£o no CS: 0 </li><li>  Os registradores AL e AH cont√™m um sinalizador de erro para determinar as letras de unidade do primeiro e do segundo argumento quando o programa √© chamado.  Se n√£o houver erros, eles ser√£o 0, se houver FFh </li></ul><br>  Eu sinceramente acreditava que, no caso geral, o status dos registros n√£o est√° definido.  Mas no c√≥digo analisado, na minha opini√£o, √© feita uma suposi√ß√£o muito ousada sobre seu estado inicial, em particular sobre os registros CX, SI e o sinalizador de dire√ß√£o DF.  N√£o encontrei confirma√ß√£o disso na lista de fontes que resultou acima, por isso fui examinar as fontes do <a href="" rel="nofollow">MS-DOS 2.0</a> : <br><br><ul><li>  Sobre o DF, podemos assumir que ele foi redefinido pelo comando <code>cld</code> , porque o √∫ltimo usa a dire√ß√£o de avan√ßo antes de transferir o controle para as <code>cld</code> linha; portanto, o DF √© redefinido.  Embora n√£o haja uso expl√≠cito de <code>cld</code> nesse local, o comando para limpar o sinalizador de dire√ß√£o √© encontrado com bastante frequ√™ncia antes de muitas outras transfer√™ncias </li><li>  O SI cont√©m 100h, porque √© usado para determinar o deslocamento que ser√° carregado no registro pelo contador de comandos IP </li><li>  CX √© igual a FFh, porque √© usado como um contador com um valor inicial de 80h para transferir o conte√∫do de toda a linha de comando e, consequentemente, ap√≥s a transfer√™ncia √© 0. E depois disso, CL, como uma vari√°vel tempor√°ria, carrega FFh e √© usado para definir o sinalizador de erro da letra da unidade em AL e AH </li></ul><br>  N√£o h√° fontes de vers√µes mais recentes, mas existem <a href="https://sourceforge.net/projects/dosbox/files/dosbox/" rel="nofollow">fontes do DOSBox</a> : <br><br><pre> <code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number"><span class="hljs-number">0</span></span>;reg_cx=<span class="hljs-number"><span class="hljs-number">0xff</span></span>; reg_dx=pspseg; reg_si=RealOff(csip); reg_di=RealOff(sssp);</code> </pre><br>  Ou seja, coincide com o que vi no c√≥digo-fonte do MS-DOS (segunda vers√£o!). Voc√™ pode ver os valores iniciais de outros registradores, aqui est√° uma inicializa√ß√£o expl√≠cita e especial.  Para o MS-DOS, os valores de registradores que n√£o sejam AX, segmento e pilha s√£o rudimentos de seu uso para outros fins; esse n√£o √© um dogma ou padr√£o; portanto, eles n√£o s√£o mencionados em nenhum lugar.  Mas, por outro lado, o ecossistema que se formou e toda a dor da Microsoft no suporte √† compatibilidade com vers√µes mais antigas, for√ßando a arrastar todos os valores gerados aleatoriamente para tr√°s, est√° se tornando um pouco compreens√≠vel, porque os programadores est√£o acostumados a eles. <br><br>  Finalmente, para n√≥s esse conhecimento √© suficiente, come√ßamos a restaurar o programa a partir dos cabe√ßalhos: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup</code> </pre><br>  Determinamos o tipo de processador 80186, porque usamos o comando <code>outsb</code> , que apareceu apenas neste modelo.  Um segmento de c√≥digo e um ponto de entrada para o programa, que, juntamente com a defini√ß√£o do modelo de mem√≥ria <code>tiny</code> , permitir√£o que o compilador calcule corretamente todos os deslocamentos de vari√°veis ‚Äã‚Äãe transi√ß√µes.  Ao criar o <code>tlink</code> , a op√ß√£o <code>/t</code> <code>tlink</code> usada; na sa√≠da, isso <code>tlink</code> um arquivo <code>.com</code> . <br><br><h3>  Gr√°ficos e paleta </h3><br>  Para alternar para o modo gr√°fico, voc√™ precisa ativar a fun√ß√£o BIOS, para a qual uma interrup√ß√£o de 10h, AH = 0 √© chamada, em AL, colocamos o identificador do modo desejado - 13h: <br><br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h ;b0 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Observe que n√£o tocamos no AH, assumindo que haja zero, de acordo com as condi√ß√µes de carregamento do programa.  O modo selecionado corresponde a uma resolu√ß√£o gr√°fica de 320 por 200 pixels com uma paleta de 256 cores.  Para exibir um ponto na tela, voc√™ precisa escrever na √°rea de mem√≥ria, que come√ßa com o endere√ßo A000h: 0, o byte correspondente √† cor.  Preencha os registros de dados do segmento com este valor: <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h ;<span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> a0 pop es ;<span class="hljs-number"><span class="hljs-number">07</span></span> push es ;<span class="hljs-number"><span class="hljs-number">06</span></span> pop ds ;<span class="hljs-number"><span class="hljs-number">1f</span></span></code> </pre><br>  Logicamente, a mem√≥ria √© organizada como uma matriz bidimensional na qual as coordenadas da tela s√£o exibidas, 0: 0 corresponde ao canto superior esquerdo.  Ap√≥s alternar o modo, ele √© preenchido com zeros - preto na paleta padr√£o.  A f√≥rmula para traduzir para deslocamento linear √© <b>X + Y * L</b> , onde L √© a resolu√ß√£o horizontal, no nosso caso 320. Neste formul√°rio, escreverei nos locais em que as constantes s√£o usadas, ao traduzir o texto do programa, elas s√£o calculadas automaticamente. <br><br>  Para mudar a paleta, acessamos diretamente o equipamento usando as portas de entrada / sa√≠da: <br><br><pre> <code class="cpp hljs">lodsb ;ac mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h ;ba c8 <span class="hljs-number"><span class="hljs-number">03</span></span> out dx, al ;ee</code> </pre><br>  O primeiro comando carrega no AL o byte de dados localizado em DS: SI.  No DS, carregamos o endere√ßo do segmento da mem√≥ria de v√≠deo e sabemos que ele √© preenchido com zeros, no SI - no caso geral, n√£o se sabe que pelo menos 0. N√£o √© quase importante para n√≥s, n√£o importa onde o SI indique, provavelmente entraremos na mem√≥ria de v√≠deo que com esta resolu√ß√£o 320 * 200 = 64000 bytes, quase todo o segmento.  Portanto, esperamos que ap√≥s este comando AL = 0.  Uma unidade √© adicionada ou subtra√≠da ao SI, depende da configura√ß√£o do sinalizador de dire√ß√£o DF.  Embora isso tamb√©m n√£o seja particularmente importante para n√≥s, n√£o importa para onde o SI se mova, ainda permanecemos na √°rea de mem√≥ria de v√≠deo cheia de zeros. <br><br>  Em seguida, carregue o DX com o n√∫mero da porta 03C8h, cuja sa√≠da determina qual cor de 256 ser√° substitu√≠da.  No nosso caso, √© 0 de AL. <br><br>  A cor √© codificada na paleta RGB e, para isso, voc√™ deve gravar na porta 03C9h (uma a mais que 3C8h) tr√™s vezes seguidas, uma vez para cada um dos componentes.  O brilho m√°ximo do componente √© 63, o m√≠nimo √© 0. <br><br><pre> <code class="cpp hljs">inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">64</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">40</span></span> PALETTE: out dx, al ;ee inc ax ;<span class="hljs-number"><span class="hljs-number">40</span></span> outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e loop PALETTE ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">,    6  </span></span></code> </pre><br>  Aumente o DX em um para que ele tenha o n√∫mero da porta desejado.  CL √© o nosso contador de ciclos de 64, e assumimos que CH = 0, conforme descrito anteriormente, com base nas condi√ß√µes iniciais de carregamento.  Em seguida, enviamos o primeiro componente para a porta - o vermelho, cujo brilho ser√° armazenado em AL, ser√° conosco que mudar√°, no primeiro passo 0. Em seguida, aumentamos seu brilho em um para exibir na pr√≥xima itera√ß√£o.  Em seguida, executamos dois comandos <code>outsb</code> gravam na porta, cujo n√∫mero est√° contido no DX, o byte da √°rea de mem√≥ria do DS: SI, lembre-se de que temos zeros l√°.  O SI muda sempre uma vez. <br><br>  Assim que deduzimos os tr√™s componentes, uma unidade √© automaticamente adicionada ao n√∫mero da cor.  Portanto, n√£o √© necess√°rio redefinir a cor, enviando para a porta 3C8h se as cores estiverem em uma linha, conforme necess√°rio.  O comando <code>loop</code> reduzir√° o CX em um, se um valor diferente de zero for obtido, ele ir√° para o in√≠cio do ciclo, se 0, e para o pr√≥ximo comando ap√≥s o ciclo. <br><br>  Um total de 64 repeti√ß√µes.  A cada repeti√ß√£o, determinamos para a cor, come√ßando de 0 a 63, o componente vermelho com brilho coincidindo com o n√∫mero da cor atual.  Redefinimos os componentes verde e azul para obter essa paleta do brilho m√≠nimo ao m√°ximo do vermelho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="paleta"></div><br><br><h3>  Linhas </h3><br>  Configure a cor inicial e os valores das coordenadas: <br><br><pre> <code class="cpp hljs">LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh ;b8 <span class="hljs-number"><span class="hljs-number">3f</span></span> <span class="hljs-number"><span class="hljs-number">3f</span></span> mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span></code> </pre><br>  Em AL e AH, carregamos a cor m√°xima poss√≠vel (mais brilhante) 63 (3Fh), respectivamente, o AX define dois pontos ao mesmo tempo.  BX - resolu√ß√£o horizontal m√°xima.  No futuro, isso ser√° usado para adicionar ou subtrair uma linha das coordenadas atuais.  Coordenadas DI 64: 4, salve-as na pilha. <br><br>  <b>Desenhe a primeira linha do canto superior esquerdo ao extremo direito</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE1: stosw ;ab add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE1 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Configure o contador - este ser√° o n√∫mero de linhas.  Em seguida, salve a palavra (dois bytes) do AX no endere√ßo ES: DI.  Esta a√ß√£o exibir√° dois pontos na tela com a cor m√°xima da nossa paleta, porque o ES est√° configurado para mem√≥ria de v√≠deo e coordenadas espec√≠ficas s√£o definidas em DI.  Ap√≥s essa a√ß√£o, 2 ser√£o adicionados √† DI, pois dois bytes foram gravados.  Obviamente, n√£o definimos o sinalizador de dire√ß√£o DF e confiamos no fato de que ele √© redefinido, novamente lembramos nossas condi√ß√µes iniciais para carregar o programa.  Caso contr√°rio, os dois seriam retirados, o que n√£o permitiria desenhar a linha desejada. <br><br>  Em seguida, DI = DI + BX, que √© equivalente a aumentar a coordenada Y em uma.  Assim, no corpo do ciclo, dois pontos s√£o desenhados em uma linha, a coordenada X √© aumentada em 2 e a coordenada Y em 1 e essa a√ß√£o √© repetida 120 vezes, a imagem com o resultado √© um pouco menor. <br><br>  <b>A segunda linha √© do canto superior esquerdo para o topo</b> : <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">60</span></span> LINE2: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE2 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Restauramos as coordenadas iniciais 64: 4 e ajustamos o contador para 96 ‚Äã‚Äãrepeti√ß√µes.  Imprimimos um ponto, mas uma linha abaixo das coordenadas atuais.  Como antes, isso √© conseguido adicionando um valor do BX, apenas sem salvar as novas coordenadas.  A constru√ß√£o <code>[bx+di]</code> ou <code>[bx][di]</code> √© chamada de endere√ßamento base com indexa√ß√£o e funciona no n√≠vel do processador, n√£o no tradutor.  O registro de segmento padr√£o com o BX √© DS.  Depois disso, exibimos o segundo ponto, mas j√° nas coordenadas atuais.  DI e, portanto, X aumenta em um, pois apenas um comando de transfer√™ncia de byte √© <code>stosb</code> - <code>stosb</code> .  Os dois √∫ltimos comandos do corpo do ciclo s√£o um aumento de Y em 2, para o qual usamos novamente o BX. <br><br>  Depois de desenhar duas linhas, a seguinte imagem √© obtida no canto superior esquerdo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="linha 1,2"></div><br><br>  Coordenadas esquerda e superior, √† direita do endere√ßo de deslocamento de linha na mem√≥ria de v√≠deo.  O ponto 64: 4 ser√° sorteado duas vezes. <br><br>  <b>A terceira linha √© do canto superior direito ao superior</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">61</span></span> LINE3: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb loop LINE3 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Como o DI j√° cont√©m o valor de coordenada desejado 160: 196, precisamos desenhar uma linha do topo onde a linha anterior terminou, subindo a tela enquanto mant√©m o mesmo √¢ngulo.  Consequentemente, o ciclo √© quase id√™ntico.  CX √© aumentado em 1, porque a coordenada Y atual √© 2 a mais (mais baixa) do que onde a linha anterior terminou, j√° foi calculada para a pr√≥xima itera√ß√£o.  Portanto, para chegar ao canto superior, √© necess√°rio dar um passo extra.  O movimento ao longo de X continua na mesma dire√ß√£o - mais um ap√≥s cada itera√ß√£o e, ao longo de Y, em vez de adicionar, subtra√≠mos os dois.  Os pontos s√£o exibidos na mesma ordem, primeiro mais baixo e mais alto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="linha 3"></div><br><br>  <b>A quarta linha √© do canto superior esquerdo para o canto superior direito:</b> <br><br><pre> <code class="cpp hljs">mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf d1 <span class="hljs-number"><span class="hljs-number">99</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE4: stosw ;ab sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb(<span class="hljs-number"><span class="hljs-number">-5</span></span>) loop LINE4</code> </pre><br>  Estamos novamente nas coordenadas necess√°rias, mas isso n√£o √© usado, aparentemente para n√£o alterar o sinalizador de dire√ß√£o DF.  Portanto, novas coordenadas s√£o colocadas na DI e armazenadas na pilha. <br><br>  Al√©m disso, tudo √© id√™ntico √† primeira linha, apenas a coordenada Y n√£o cresce, mas diminui, aumentamos. <br><br>  <b>A quinta linha √© horizontal:</b> <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">8f</span></span> rep stosw ;f3 ab</code> </pre><br>  Tudo √© simples aqui, o mecanismo de retransmiss√£o do microprocessador √© usado, uma vez que a linha horizontal corresponde a um simples aumento no endere√ßo de cada pr√≥ximo ponto.  Em DI, o endere√ßo correspondente √† coordenada do canto extremo esquerdo, armazenado na etapa anterior, √© restaurado.  O n√∫mero de repeti√ß√µes no CX √© definido e o prefixo de repeti√ß√£o √© aplicado com o comando de transfer√™ncia de palavras. <br><br>  Ap√≥s essa a√ß√£o, temos um pentagrama totalmente desenhado na cor mais brilhante.  80 bytes usados ‚Äã‚Äãe 48 em reserva. <br><br><h3>  Magia de fogo </h3><br>  <b>Definimos as condi√ß√µes de contorno para os c√°lculos:</b> <br><br><pre> <code class="cpp hljs">FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> ;<span class="hljs-number"><span class="hljs-number">81</span></span> fe <span class="hljs-number"><span class="hljs-number">00</span></span> fa jae NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> lodsb ;ac <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al ;<span class="hljs-number"><span class="hljs-number">0</span></span>a c0 jz NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>d</code> </pre><br>  No SI, haver√° a coordenada do ponto atual para os c√°lculos; se ultrapassarmos os limites da tela, n√£o realizaremos nenhum c√°lculo com esse ponto, procederemos ao c√°lculo do pr√≥ximo. <br><br>  <code>lodsb</code> carrega um byte da √°rea DS: SI no AL, ou seja, a cor do ponto nas coordenadas atuais.  Se for 0, tamb√©m n√£o fazemos nada e passamos ao pr√≥ximo ponto. <br><br>  <b>Novo c√°lculo de cores</b> <br><br>  Este √© o principal algoritmo para alterar os valores das cores na tela, isso n√£o √© uma chama, √© a base para isso.  Calculamos pontos vizinhos e alcan√ßamos a continuidade da cor: <br><br><pre> <code class="cpp hljs">dec ax ;<span class="hljs-number"><span class="hljs-number">48</span></span> mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> fe mov [si], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> ff mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> bf fe</code> </pre><br>  Subtraia do AX, de fato de AL, uma unidade que cont√©m um valor de cor diferente de zero obtido das coordenadas atuais.  Em seguida, anotamos o valor obtido em todos os pontos vizinhos, em rela√ß√£o √† coordenada atual, ou seja, um pouco deles, com base em nossa paleta. <br><br>  Como ap√≥s <code>lodsb</code> , o valor do SI aumentou um e n√£o corresponde mais ao ponto cuja cor lemos em AL, isso precisa ser ajustado.  Observe que os comandos <code>stosb</code> byte transfer n√£o s√£o mais usados; em vez disso, <code>mov</code> √© usado para identificar o endere√ßo onde o valor ser√° colocado.  Se aceitarmos que as coordenadas atuais s√£o X: Y, para elas SI-1, ent√£o: <br><br><ul><li>  <code>mov [si-2], al</code> - grave uma nova cor no ponto X-1: Y, √† esquerda da cor atual.  2 √© subtra√≠do do SI devido ao motivo descrito acima, uma vez que uma unidade extra j√° foi adicionada a ele </li><li>  <code>mov [si], al</code> - grave uma nova cor no ponto X + 1: Y, √† direita da cor atual.  SI j√° tem X + 1 </li><li>  <code>mov [bx+si-1], al</code> - escrevendo uma nova cor no ponto X: Y + 1, abaixo da atual.  Novamente use BX para Y + 1 </li><li>  <code>mov [si-1-1*320], al</code> - escrevendo uma nova cor no ponto X: Y-1, acima da atual.  N√£o poderemos usar o BX, pois precisamos tirar a coordenada, a arquitetura do processador n√£o nos permite fazer isso desta forma; portanto, uma constante √© usada de acordo com a f√≥rmula de redu√ß√£o de coordenadas </li></ul><br>  O registro de segmento √© DS, que √© usado por padr√£o com SI e BX. <br><br>  Em nenhum lugar a situa√ß√£o √© verificada quando o ponto atinge a borda da tela.  Isso n√£o pode levar a uma falha, pois sempre estaremos dentro dos limites do segmento de v√≠deo.  Um ponto vizinho pode cair em uma √°rea n√£o relatada com endere√ßos maiores que 64.000 ou em uma linha adjacente, o que n√£o causa danos a n√≥s e at√© ajuda um pouco, como ser√° visto na descri√ß√£o adicional. <br><br>  <b>A mesma m√°gica, o c√°lculo das coordenadas do pr√≥ximo ponto</b> <br><br><pre> <code class="cpp hljs">NEXT_PIXEL: add si, dx ;<span class="hljs-number"><span class="hljs-number">03</span></span> f2 inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> jnz FLAME ;<span class="hljs-number"><span class="hljs-number">75</span></span> e3(<span class="hljs-number"><span class="hljs-number">-29</span></span>)</code> </pre><br>  Vamos voltar um pouco, n√£o definimos especificamente o valor inicial do SI em nenhum lugar e, no DX, ainda temos o n√∫mero da porta de entrada de sa√≠da que usamos para a paleta.  Realizamos apenas tr√™s a√ß√µes simples SI = SI + DX; obviamente, isso definir√° novas coordenadas, quais?  DX = DX + 1 e se DX n√£o for igual a 0, volte ao algoritmo b√°sico para obter e calcular pontos vizinhos, ou seja, DX √© algum tipo de contador? <br><br>  Sabemos que precisamos contornar todos os pontos e calcular as mudan√ßas de brilho de seus vizinhos.  Se voc√™ fizer isso em uma linha, provavelmente obteremos um gradiente est√°tico, talvez n√£o exatamente, mas inalterado em torno de nossas linhas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sabemos o tamanho de nossa tela e quantos pontos precisamos contornar, mas aqui quase o negligenciamos, mais precisamente, escolhemos o valor pr√≥ximo 65536 em vez do exato 64000. DX √© realmente um contador, apenas 65536. Mas por que seu valor inicial n√£o √© importante e por que consideramos O valor final √© maior que o total de pontos na tela? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porque contornamos pontos n√£o seguidos e nem todos. Cada coordenada linear subsequente √© maior que a anterior pelo valor de DX. Ou seja, no SI, a soma dos elementos DX de uma progress√£o aritm√©tica simples: 0,1,2,3,4,5,6, ..., 362,363, ..., 65535. Isso j√° nos d√° n√£o linearidade, se voc√™ come√ßar com SI = 0 e DX = 0, ent√£o no SI obtemos: 0,1,3,4,6,10,15,21, ..., 65341,65703, ..., 2147450880.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso n√£o √© tudo, porque a dimens√£o SI √© de 16 bits, n√£o podemos obter um valor maior que 65535, o estouro ocorre e o restante no SI permanece o m√≥dulo 65536. A f√≥rmula de c√°lculo de coordenadas linear assume a forma SI = (SI + DX) MOD 65536, que quebra completamente a ordem cont√≠nua: 0,1,3,4,6,10,15,21, ..., 65341,167,530,894, ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora lembramos que o SI n√£o √© inicializado de nenhuma maneira, ou seja, na pr√≥xima vez que retornarmos a esse ciclo come√ßaremos da coordenada de onde paramos, e n√£o de 0 ou de uma determinada. Isso adicionar√° caos √† nossa sequ√™ncia - aumentar√° o n√∫mero de elementos que n√£o se repetem. Caso contr√°rio, a travessia dos pontos seria sempre a mesma, embora n√£o linear. Um efeito de chama estaria presente, mas n√£o t√£o claramente. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se falamos sobre o truque, √© exatamente isso.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sempre o DX, exceto o primeiro uso, inicia implicitamente em 0 como resultado de um estouro </font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E um pouco mais de caos √© adicionado aos nossos valores-limite, pois para SI&gt; = 64000 nenhum ponto ser√° desenhado e a sequ√™ncia de sa√≠da √© levemente confusa. E pular todos os pontos com um valor zero leva ao efeito de igni√ß√£o nos primeiros segundos do programa. Isso ocorre porque o ciclo completo termina mais r√°pido, pois a maioria dos pontos n√£o √© processada. Mas o mais importante √© que, como o brilho da maioria dos pontos s√≥ aumenta, eles n√£o podem ser obscurecidos pelas se√ß√µes mais escuras vizinhas - elas simplesmente ainda n√£o existem e os valores zero n√£o s√£o calculados. Depois que as √°reas completamente pretas desaparecem, o equil√≠brio √© estabelecido, algumas √°reas aumentam o brilho e outras diminuem.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, n√£o podemos mais falar sobre nenhuma ordem ou gradiente, os pontos n√£o s√£o dispensados, cada vez em uma nova sequ√™ncia, incluindo repetir v√°rias vezes ou pular completamente. </font><font style="vertical-align: inherit;">Isso leva √† forma√ß√£o de regi√µes de brilho diferente misturadas entre si, mudando a cada nova itera√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso n√£o √© tudo: se voc√™ n√£o adicionar novos pontos positivos, no final, todos ser√£o reembolsados. </font><font style="vertical-align: inherit;">Portanto, depois que o DX atinge seu valor m√°ximo, voltamos a desenhar cinco linhas brilhantes e contamos todos os pontos na tela:</font></font><br><br><pre> <code class="cpp hljs">in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h ;e4 <span class="hljs-number"><span class="hljs-number">60</span></span> cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h ;<span class="hljs-number"><span class="hljs-number">3</span></span>c <span class="hljs-number"><span class="hljs-number">01</span></span> jne LINES ;<span class="hljs-number"><span class="hljs-number">75</span></span> a5(<span class="hljs-number"><span class="hljs-number">-91</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas antes disso, lemos da porta 60h, este √© o teclado, o c√≥digo de verifica√ß√£o da √∫ltima tecla pressionada. </font><font style="vertical-align: inherit;">Para ESC, √© igual a 1. Nesse caso, a tecla ESC foi pressionada, avan√ßamos em dire√ß√£o √† sa√≠da.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclus√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale a pena prestar aten√ß√£o que, ao atualizar a tela atual, que leva algum tempo, voc√™ n√£o pode sair do programa, ou seja, a rea√ß√£o ao ESC ser√° atrasada. Se durante a espera e depois que ESC for pressionada alguma tecla, ainda permaneceremos no programa, apenas o √∫ltimo c√≥digo de leitura poder√° ser lido a partir da porta. Mais uma coisa, n√£o substitu√≠mos ou usamos as fun√ß√µes de sistema DOS e BIOS para isso, independentemente do que lemos da porta, a tecla pressionada √© colocada em um buffer circular e provavelmente ser√° lida a partir da√≠ pelo pr√≥ximo programa ap√≥s a conclus√£o da introdu√ß√£o, o arquivo mais prov√°vel gerente ou </font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso levar√° ao seu processamento, por exemplo, Volkov Commander no ESC ocultar√° seus pain√©is. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resta retornar ao modo de texto 3:</font></font><br><br><pre> <code class="cpp hljs">mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h ;b8 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sup√µe-se que est√°vamos nesse modo antes do lan√ßamento do programa, mas, no caso geral, isso pode n√£o ser o caso. </font><font style="vertical-align: inherit;">Aqui, atualizamos todo o AX, porque sabemos com certeza que o AH n√£o cont√©m 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ pode sair:</font></font><br><br><pre> <code class="cpp hljs">retn ;c3</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© um comando near exit de um procedimento que pega o valor da palavra colocada l√° (dois bytes) da pilha e o carrega no contador de comandos IP. </font><font style="vertical-align: inherit;">De acordo com as condi√ß√µes iniciais, temos zeros na pilha, isso nos levar√° ao endere√ßo CS: 0, onde, como sabemos, o c√≥digo de comando est√° localizado </font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- shutdown. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E 7 bytes para direitos autorais:</font></font><br><br><pre> <code class="cpp hljs">dd <span class="hljs-number"><span class="hljs-number">0</span></span>h ;<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> ;<span class="hljs-number"><span class="hljs-number">4</span></span>d <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>d end</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos dizer que ainda h√° um lugar que eu gastaria em uma inicializa√ß√£o mais rigorosa, mas como tudo funciona no moderno DOSBox, o autor provavelmente fez tudo certo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos passar mais uma vez:</font></font><br><br><ol><li>    ,        </li><li>  4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,          </li><li>       SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         ‚Äî <code>add si, dx</code>  <code>inc dx</code> ,            ,       </li><li>     ESC  ,           </li></ol><br><div class="spoiler"> <b class="spoiler_title">  .</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h pop es push es pop ds lodsb mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h out dx, al inc dx mov cl, <span class="hljs-number"><span class="hljs-number">040</span></span>h PALETTE: out dx, al inc ax outsb outsb loop PALETTE LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE1: stosw add di, bx loop LINE1 pop di mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> LINE2: mov [bx+di], al stosb add di, bx add di, bx loop LINE2 mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> LINE3: mov [bx+di], al stosb sub di, bx sub di, bx loop LINE3 mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE4: stosw sub di, bx loop LINE4 pop di mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> rep stosw FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> jae NEXT_PIXEL lodsb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al jz NEXT_PIXEL dec ax mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al mov [si], al mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al NEXT_PIXEL: add si, dx inc dx jnz FLAME in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h jne LINES mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h retn dd <span class="hljs-number"><span class="hljs-number">0</span></span>h db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> end</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para compilar, voc√™ deve fazer: </font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o sei se ficou claro para voc√™ o que e como foi implementado, mas parece-me que uma abordagem bonita e incomum foi usada para criar o efeito de chama. </font><font style="vertical-align: inherit;">Embora eu n√£o tenha nada com o que comparar, talvez todos tenham feito isso, e agora voc√™ pode fazer o mesmo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482826/">https://habr.com/ru/post/pt482826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482814/index.html">Vis√£o geral da √°rvore, implementa√ß√£o e n√£o apenas</a></li>
<li><a href="../pt482816/index.html">Arthur Khachuyan: Intelig√™ncia Artificial em Marketing</a></li>
<li><a href="../pt482818/index.html">Breves resultados da leitura do relat√≥rio no 1C DSS para Infostart 2019</a></li>
<li><a href="../pt482820/index.html">Otimiza√ß√£o de upload de imagem</a></li>
<li><a href="../pt482822/index.html">Como s√£o realizados os testes de arte para jogos</a></li>
<li><a href="../pt482834/index.html">A digita√ß√£o est√°tica n√£o requer necessariamente cerim√¥nias</a></li>
<li><a href="../pt482838/index.html">Revis√£o do ONYX BOOX Note 2 - um leitor de tela grande com capacidade m√°xima</a></li>
<li><a href="../pt482844/index.html">Bot ao vivo, parte 1</a></li>
<li><a href="../pt482846/index.html">AirPods Pro, Apple TV + e muito dinheiro: por que as a√ß√µes da Apple atingiram um pre√ßo recorde</a></li>
<li><a href="../pt482848/index.html">Bot ao vivo, parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>