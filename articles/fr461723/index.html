<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛵️ 🤦🏾 🕶️ Comprendre le package de contexte dans Golang 👨‍👨‍👧‍👦 🌞 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le package de contexte dans Go est utile pour les interactions avec les API et les processus lents, en particulier dans les systèmes de production qui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre le package de contexte dans Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/461723/"><p><img src="https://habrastorage.org/getpro/habr/post_images/2f4/49e/54b/2f449e54b5540578a8ead5599e9e7f0e.jpg" alt="image"></p><br><p>  Le package de contexte dans Go est utile pour les interactions avec les API et les processus lents, en particulier dans les systèmes de production qui traitent les demandes Web.  Avec son aide, les goroutines peuvent être informées de la nécessité de terminer leur travail. </p><br><p>  Vous trouverez ci-dessous un petit guide pour vous aider à utiliser ce package dans vos projets, ainsi que certaines des meilleures pratiques et écueils. </p><br><p>  <em>(Remarque: le contexte est utilisé dans de nombreux packages, par exemple pour travailler avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker</a> ).</em> </p><a name="habracut"></a><br><h2 id="pered-tem-kak-nachat">  Avant de commencer </h2><br><p>  Pour utiliser des contextes, vous devez comprendre ce que sont le goroutine et les canaux.  Je vais essayer de les considérer brièvement.  Si vous les connaissez déjà, allez directement à la section Contexte. </p><br><h3 id="gorutina">  Gorutin </h3><br><p>  La documentation officielle indique que «Gorutin est un flux d'exécution léger».  Les goroutines sont plus légères que les fils, leur gestion nécessite donc relativement moins de ressources. </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bac à sable</a> </p><br><pre><code class="plaintext hljs">package main import "fmt" // ,   Hello func printHello() { fmt.Println("Hello from printHello") } func main() { //   //       go func(){fmt.Println("Hello inline")}() //     go printHello() fmt.Println("Hello from main") }</code> </pre> <br><p>  Si vous exécutez ce programme, vous verrez que seul <code>Hello from main</code> imprimé.  En fait, les deux goroutines commencent, mais le <code>main</code> termine plus tôt.  Ainsi, les Goroutines ont besoin d'un moyen d'informer le <code>main</code> de la fin de leur exécution, et pour qu'elle attende cela.  Ici, les canaux viennent à notre secours. </p><br><h3 id="kanaly-channels">  Chaînes </h3><br><p>  Les canaux sont un moyen de communication entre les goroutins.  Ils sont utilisés lorsque vous souhaitez transférer des résultats, des erreurs ou d'autres informations d'un goroutine à un autre.  Les canaux sont de types différents, par exemple, un canal de type <code>int</code> reçoit des entiers, et un canal de type <code>error</code> reçoit des erreurs, etc. </p><br><p>  Disons que nous avons un canal <code>ch</code> de type <code>int</code> .  Si vous voulez envoyer quelque chose au canal, la syntaxe sera <code>ch &lt;- 1</code> .  Vous pouvez obtenir quelque chose du canal comme ceci: <code>var := &lt;- ch</code> , i.e.  prendre la valeur du canal et l'enregistrer dans la variable <code>var</code> . </p><br><p>  Le code suivant illustre comment utiliser les canaux pour confirmer que les goroutines ont terminé leur travail et retourné leurs valeurs à <code>main</code> . </p><br><p>  <em>Remarque: Les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupes d'attente</a> peuvent également être utilisés pour la synchronisation, mais dans cet article, j'ai sélectionné des canaux pour des exemples de code, car nous les utiliserons plus tard dans la section contextuelle.</em> </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bac à sable</a> </p><br><pre> <code class="plaintext hljs">package main import "fmt" //       int   func printHello(ch chan int) { fmt.Println("Hello from printHello") //     ch &lt;- 2 } func main() { //  .       make //       : // ch := make(chan int, 2),       . ch := make(chan int) //  .  ,    . //       go func(){ fmt.Println("Hello inline") //     ch &lt;- 1 }() //     go printHello(ch) fmt.Println("Hello from main") //      //     ,    i := &lt;- ch fmt.Println("Received ",i) //      //    ,      &lt;- ch }</code> </pre> <br><h2 id="kontekst-context">  Contexte </h2><br><p>  Le package de contexte dans go vous permet de transmettre des données à votre programme dans une sorte de «contexte».  Le contexte, comme un délai d'attente, une échéance ou un canal, signale un arrêt et le retour des appels. </p><br><p>  Par exemple, si vous effectuez une demande Web ou exécutez une commande système, ce serait une bonne idée d'utiliser un délai d'expiration pour les systèmes de production.  Parce que si l'API à laquelle vous accédez est lente, il est peu probable que vous souhaitiez accumuler des demandes dans votre système, car cela peut entraîner une charge accrue et une baisse des performances lors du traitement de vos propres demandes.  Le résultat est un effet en cascade. </p><br><p>  Et ici, le contexte de délai d'attente ou de délai peut être juste. </p><br><h3 id="sozdanie-konteksta">  Création de contexte </h3><br><p>  Le package de contexte vous permet de créer et d'hériter du contexte des manières suivantes: </p><br><p>  <strong>context.Background () Contexte ctx</strong> </p><br><p>  Cette fonction renvoie un contexte vide.  Il ne doit être utilisé qu'à un niveau élevé (dans le gestionnaire de requêtes principal ou le plus élevé).  Il peut être utilisé pour obtenir d'autres contextes, dont nous discuterons plus tard. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.Background()</code> </pre> <br><p>  <em>Remarque</em>  <em>trans.: Il y a une inexactitude dans l'article original, l'exemple correct d'utilisation du <code>context.Background</code> sera le suivant:</em> </p><br><pre> <code class="plaintext hljs">ctx := context.Background()</code> </pre> <br><p>  <strong>context.TODO () Contexte ctx</strong> </p><br><p>  Cette fonction crée également un contexte vide.  Et il doit également être utilisé uniquement à un niveau élevé, soit lorsque vous n'êtes pas sûr du contexte à utiliser, soit si la fonction ne reçoit pas encore le contexte souhaité.  Cela signifie que vous (ou quelqu'un qui prend en charge le code) prévoyez d'ajouter du contexte à la fonction ultérieurement. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.TODO()</code> </pre> <br><p>  <em>Remarque</em>  <em>trans.: Il y a une inexactitude dans l'article d'origine, l'exemple correct d'utilisation du <code>context.TODO</code> sera le suivant:</em> </p><br><pre> <code class="plaintext hljs">ctx := context.TODO()</code> </pre> <br><p>  Fait intéressant, jetez un œil au <a href="">code</a> , il est absolument identique à l'arrière-plan.  La seule différence est que dans ce cas, vous pouvez utiliser les outils d'analyse statique pour vérifier la validité du transfert de contexte, ce qui est un détail important, car ces outils aident à identifier les erreurs potentielles à un stade précoce et peuvent être inclus dans le pipeline CI / CD. </p><br><p>  <a href="">D'ici</a> : </p><br><pre> <code class="plaintext hljs">var ( background = new(emptyCtx) todo = new(emptyCtx) )</code> </pre> <br><p>  <strong>context.WithValue (Contexte parent, clé, interface val {}) (Contexte ctx, annuler CancelFunc)</strong> </p><br><p>  <em>Remarque</em>  <em>Lane: Il y a une inexactitude dans l'article d'origine, la signature correcte pour le <code>context.WithValue</code> sera la suivante:</em> </p><br><pre> <code class="plaintext hljs">context.WithValue(parent Context, key, val interface{}) Context</code> </pre> <br><p>  Cette fonction prend un contexte et retourne un contexte dérivé de celui-ci dans lequel la valeur <code>val</code> est associée à la <code>key</code> et traverse l'arborescence de contexte entière.  Autrement dit, dès que vous créez un contexte <code>WithValue</code> , tout contexte dérivé recevra cette valeur. </p><br><p>  Il n'est pas recommandé de passer des paramètres critiques à l'aide de valeurs de contexte; à la place, les fonctions doivent les prendre explicitement dans la signature. </p><br><pre> <code class="plaintext hljs">ctx := context.WithValue(context.Background(), key, "test")</code> </pre> <br><p>  <strong>context.WithCancel (Contexte parent) (Contexte ctx, annuler CancelFunc)</strong> </p><br><p>  Cela devient un peu plus intéressant ici.  Cette fonction crée un nouveau contexte à partir du parent qui lui a été transmis.  Le parent peut être le contexte d'arrière-plan ou le contexte passé en argument à la fonction. </p><br><p>  Le contexte dérivé et la fonction d'annulation sont retournés.  Seule la fonction qui la crée doit appeler la fonction pour annuler le contexte.  Vous pouvez passer la fonction d'annulation à d'autres fonctions si vous le souhaitez, mais cela est fortement déconseillé.  Habituellement, cette décision est prise à partir d'une mauvaise compréhension de l'annulation du contexte.  Pour cette raison, les contextes générés à partir de ce parent peuvent affecter le programme, ce qui entraînera un résultat inattendu.  Bref, il vaut mieux ne JAMAIS passer une fonction d'annulation. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <em>Remarque</em>  <em>Lane: Dans l'article d'origine, l'auteur, apparemment, par erreur pour <code>context.WithCancel</code> donné un exemple avec <code>context.WithDeadline</code> .</em>  <em>L'exemple correct pour <code>context.WithCancel</code> serait:</em> </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithCancel(context.Background())</code> </pre> <br><p>  <strong>context.WithDeadline (Contexte parent, d time.Time) (Contexte ctx, annuler CancelFunc)</strong> </p><br><p>  Cette fonction renvoie un contexte dérivé de son parent, qui est annulé après une échéance ou un appel à la fonction d'annulation.  Par exemple, vous pouvez créer un contexte qui est automatiquement annulé à un moment spécifique et le transmettre aux fonctions enfants.  Lorsque ce contexte est annulé après la date limite, toutes les fonctions qui ont ce contexte doivent être notifiées par notification. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <strong>context.WithTimeout (Contexte parent, timeout time.Duration) (Contexte ctx, annuler CancelFunc)</strong> </p><br><p>  Cette fonction est similaire à context.WithDeadline.  La différence est que la durée est utilisée comme entrée.  Cette fonction renvoie un contexte dérivé qui est annulé lorsque la fonction d'annulation est appelée ou après un certain temps. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <em>Remarque</em>  <em>Lane: Dans l'article d'origine, l'auteur, apparemment, par erreur pour <code>context.WithTimeout</code> donné un exemple avec <code>context.WithDeadline</code> .</em>  <em>L'exemple correct pour <code>context.WithTimeout</code> serait le suivant:</em> </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)</code> </pre> <br><h3 id="priyom-i-ispolzovanie-kontekstov-v-vashih-funkciyah">  Réception et utilisation des contextes dans vos fonctions </h3><br><p>  Maintenant que nous savons comment créer des contextes (Background et TODO) et comment générer des contextes (WithValue, WithCancel, Deadline et Timeout), voyons comment les utiliser. </p><br><p>  Dans l'exemple suivant, vous pouvez voir que la fonction qui prend le contexte lance le goroutine et s'attend à ce qu'il retourne ou annule le contexte.  L'instruction select nous aide à déterminer ce qui se passe en premier et à terminer la fonction. </p><br><p>  Après avoir fermé le canal Terminé <code>&lt;-ctx.Done()</code> , le cas de <code>case &lt;-ctx.Done():</code> est sélectionné.  Dès que cela se produit, la fonction doit interrompre le travail et préparer un retour.  Cela signifie que vous devez fermer toutes les connexions ouvertes, libérer des ressources et revenir de la fonction.  Il y a des moments où la libération des ressources peut retarder le retour, par exemple, le nettoyage se bloque.  Vous devez garder cela à l'esprit. </p><br><p>  L'exemple qui suit cette section est un programme go entièrement terminé qui illustre les délais d'expiration et les fonctions d'annulation. </p><br><pre> <code class="plaintext hljs">// ,  -      // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } }</code> </pre> <br><h3 id="primer">  Exemple </h3><br><p>  Comme nous l'avons vu, en utilisant des contextes, vous pouvez travailler avec des délais, des délais d'expiration et également appeler la fonction d'annulation, ce qui indique clairement à toutes les fonctions utilisant un contexte dérivé que vous devez terminer votre travail et exécuter le retour.  Prenons un exemple: </p><br><p>  fonction <code>main</code> : </p><br><ul><li>  Crée un contexte de fonction d'annulation </li><li>  Appelle la fonction d'annulation après un délai arbitraire </li></ul><br><p>  Fonction <code>doWorkContext</code> : </p><br><ul><li>  Crée un contexte dérivé avec un délai d'expiration </li><li>  Ce contexte est annulé lorsque la fonction principale appelle cancelFunction, le délai expire ou doWorkContext appelle son cancelFunction. </li><li>  Exécute goroutine pour effectuer une tâche lente, en passant le contexte résultant </li><li>  Attend que les goroutines se terminent ou que le contexte soit annulé du principal, selon la première éventualité </li></ul><br><p>  Fonction <code>sleepRandomContext</code> : </p><br><ul><li>  Lance goroutine pour effectuer une tâche lente </li><li>  Attend la fin du goroutine, ou </li><li>  Attend que le contexte soit annulé par la fonction principale, expire ou appelle sa propre fonction d'annulation </li></ul><br><p>  Fonction <code>sleepRandom</code> : </p><br><ul><li>  S'endort à un moment aléatoire </li></ul><br><p>  Cet exemple utilise le mode veille pour simuler un temps de traitement aléatoire, mais en réalité, vous pouvez utiliser des canaux pour signaler cette fonction sur le début du nettoyage et attendre la confirmation du canal que le nettoyage est terminé. </p><br><p>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sandbox</a> (Il semble que le temps aléatoire que j'utilise dans le sandbox soit pratiquement inchangé. Essayez ceci sur votre ordinateur local pour voir le caractère aléatoire)</em> </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> </p><br><pre> <code class="plaintext hljs">package main import ( "context" "fmt" "math/rand" "Time" ) //   func sleepRandom(fromFunction string, ch chan int) { //    defer func() { fmt.Println(fromFunction, "sleepRandom complete") }() //    //   , // «»      seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) randomNumber := r.Intn(100) sleeptime := randomNumber + 100 fmt.Println(fromFunction, "Starting sleep for", sleeptime, "ms") time.Sleep(time.Duration(sleeptime) * time.Millisecond) fmt.Println(fromFunction, "Waking up, slept for ", sleeptime, "ms") //   ,     if ch != nil { ch &lt;- sleeptime } } // ,       // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,    doWorkContext  // doWorkContext  main  cancelFunction //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("sleepRandomContext: Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } } //  ,         //       //   ,      main func doWorkContext(ctx context.Context) { //          - //  150  //  ,   ,   150  ctxWithTimeout, cancelFunction := context.WithTimeout(ctx, time.Duration(150)*time.Millisecond) //         defer func() { fmt.Println("doWorkContext complete") cancelFunction() }() //       //         , //      ,    ch := make(chan bool) go sleepRandomContext(ctxWithTimeout, ch) //  select      select { case &lt;-ctx.Done(): //   ,           //     ,   main   cancelFunction fmt.Println("doWorkContext: Time to return") case &lt;-ch: //   ,       fmt.Println("sleepRandomContext returned") } } func main() { //   background ctx := context.Background() //     ctxWithCancel, cancelFunction := context.WithCancel(ctx) //      //        defer func() { fmt.Println("Main Defer: canceling context") cancelFunction() }() //     - //   ,        go func() { sleepRandom("Main", nil) cancelFunction() fmt.Println("Main Sleep complete. canceling context") }() //   doWorkContext(ctxWithCancel) }</code> </pre> <br><h3 id="podvodnye-kamni">  Pièges </h3><br><p>  Si la fonction utilise le contexte, assurez-vous que les notifications d'annulation sont gérées correctement.  Par exemple, cet <code>exec.CommandContext</code> ne ferme pas le canal de lecture tant que la commande n'a pas terminé toutes les fourches créées par le processus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> ), c'est-à-dire que l'annulation du contexte ne revient pas immédiatement de la fonction si vous attendez avec cmd.Wait (), jusqu'à ce que toutes les fourches de la commande externe terminent le traitement. </p><br><p>  Si vous utilisez un délai d'expiration ou une échéance avec une durée d'exécution maximale, cela peut ne pas fonctionner comme prévu.  Dans de tels cas, il est préférable d'implémenter des délais d'attente en utilisant le <code>time.After</code> . </p><br><h3 id="luchshie-praktiki">  Meilleures pratiques </h3><br><ol><li>  context.Background ne doit être utilisé qu'au plus haut niveau, en tant que racine de tous les contextes dérivés. </li><li>  context.TODO doit être utilisé lorsque vous ne savez pas quoi utiliser, ou si la fonction actuelle utilisera le contexte à l'avenir. </li><li>  Les annulations de contexte sont recommandées, mais ces fonctions peuvent prendre un certain temps pour effacer et quitter. </li><li>  context.Value doit être utilisé avec parcimonie et ne doit pas être utilisé pour transmettre des paramètres facultatifs.  Cela rend l'API incompréhensible et peut entraîner des erreurs.  Ces valeurs doivent être transmises comme arguments. </li><li>  Ne stockez pas les contextes dans une structure; passez-les explicitement dans les fonctions, de préférence comme premier argument. </li><li>  Ne passez jamais un contexte nul comme argument.  En cas de doute, utilisez TODO. </li><li>  La structure de <code>Context</code> n'a pas de méthode d'annulation, car seule la fonction qui génère le contexte doit l'annuler. </li></ol><br><h3 id="ot-perevodchika">  Du traducteur </h3><br><p>  Dans notre entreprise, nous utilisons activement le package Context lors du développement d'applications serveur à usage interne.  Mais de telles applications pour un fonctionnement normal, en plus de Context, nécessitent des éléments supplémentaires, tels que: </p><br><ul><li>  Journalisation </li><li>  Traitement du signal pour la terminaison, le rechargement et la rotation de l'application </li><li>  Travailler avec des fichiers pid </li><li>  Travailler avec des fichiers de configuration </li><li>  Et autres </li></ul><br><p>  Par conséquent, à un moment donné, nous avons décidé de résumer toute l'expérience que nous avions accumulée et de créer des packages auxiliaires qui ont grandement simplifié la rédaction des applications (en particulier les applications qui ont des API).  Nous avons publié nos développements dans le domaine public et tout le monde peut les utiliser.  Voici quelques liens vers des packages utiles pour résoudre ces problèmes: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nxs-go-appctx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nxs-go-conf</a> </li></ul><br><p>  Lisez également d'autres articles sur notre blog: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trois astuces simples pour réduire les images de docker</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegardes avec état dans Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sauvegarde d'un grand nombre de projets Web hétérogènes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bot télégramme pour Redmine.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment simplifier la vie pour vous et les gens</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461723/">https://habr.com/ru/post/fr461723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461713/index.html">4 façons d'économiser sur les sauvegardes cloud</a></li>
<li><a href="../fr461715/index.html">Peur et dégoût en tant que Techdir</a></li>
<li><a href="../fr461717/index.html">Comment compacter jusqu'à 90% du stockage des sauvegardes dans le stockage d'objets</a></li>
<li><a href="../fr461719/index.html">Solution open source pour l'automatisation des rapports</a></li>
<li><a href="../fr461721/index.html">Nouvelle méthode d'analyse de cluster</a></li>
<li><a href="../fr461725/index.html">DataGrip 2019.2: Gestion des connexions, recherche de données, filtrage dans la navigation</a></li>
<li><a href="../fr461727/index.html">Solutions Cisco Small Business: un bon réseau n'est pas nécessairement coûteux</a></li>
<li><a href="../fr461729/index.html">Utiliser le jailbreak pour extraire des données: risques et conséquences</a></li>
<li><a href="../fr461731/index.html">DPKI: remédier aux inconvénients de l'ICP centralisée au moyen de la chaîne de blocs</a></li>
<li><a href="../fr461733/index.html">Apprendre l'anglais: 9 idiomes à l'américaine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>