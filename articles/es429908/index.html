<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî® ‚öúÔ∏è üôÜüèº C√≥mo usar corutinas en la comida y dormir tranquilo por la noche üëºüèª üòΩ üëêüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las rutinas son una herramienta poderosa para la ejecuci√≥n de c√≥digo as√≠ncrono. Trabajan en paralelo, se comunican entre s√≠ y consumen pocos recursos....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo usar corutinas en la comida y dormir tranquilo por la noche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/429908/">  Las rutinas son una herramienta poderosa para la ejecuci√≥n de c√≥digo as√≠ncrono.  Trabajan en paralelo, se comunican entre s√≠ y consumen pocos recursos.  Parecer√≠a que sin temor, las corutinas pueden introducirse en la producci√≥n.  Pero hay miedos e interfieren. <br><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de</a> <strong>Vladimir Ivanov</strong> sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> trata sobre el hecho de que el diablo no es tan terrible y que puedes usar corutinas en este momento: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por qu√© corutinas, no RxJava</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lo que temen obstaculizar a los desarrolladores</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo hacer un cach√© usando corutinas</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo manejar los errores correctamente</a> . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador</strong> : Vladimir Ivanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">dzigoro</a> ) es un desarrollador l√≠der de Android en <strong>EPAM</strong> con 7 a√±os de experiencia, es aficionado a la arquitectura de soluciones, el desarrollo de React Native y iOS, y tambi√©n tiene un certificado de <strong>Google Cloud Architect</strong> . <br><a name="habracut"></a><br><blockquote>  Todo lo que lees es un producto de producci√≥n de experiencia y varios estudios, as√≠ que t√≥malo como est√°, sin ninguna garant√≠a. <br></blockquote><h2><a name="coroutine"></a>  Coroutines, Kotlin y RxJava </h2><br>  Para informaci√≥n: el estado actual de la corutina se encuentra en el lanzamiento, dej√≥ Beta.  Se lanz√≥ <strong>Kotlin 1.3</strong> , las corutinas se declararon estables y hay paz en el mundo. <br><br><img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br>  Recientemente realic√© una encuesta en Twitter que dice que las personas que usan corutina: <br><br><ul><li>  13% de las corutinas en los alimentos.  Todo esta bien; </li><li>  El 25% los prueba en el proyecto de mascotas; </li><li>  24% - ¬øQu√© es Kotlin? </li><li>  La mayor parte del 38% de RxJava est√° en todas partes. </li></ul><br>  Las estad√≠sticas no son felices.  Creo que <strong>RxJava es una herramienta demasiado compleja</strong> para tareas en las que los desarrolladores la usan com√∫nmente.  Las rutinas son m√°s adecuadas para controlar la operaci√≥n asincr√≥nica. <br><br>  En mis informes anteriores, habl√© sobre c√≥mo refactorizar desde RxJava a corutinas en Kotlin, por lo que no me detendr√© en esto en detalle, sino que solo recordar√© los puntos principales. <br><br><h3>  ¬øPor qu√© usamos corutinas? </h3><br>  Porque si usamos RxJava, los ejemplos de implementaci√≥n habituales se ver√≠an as√≠: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br>  Tenemos una interfaz, por ejemplo, escribimos un cliente GitHub y queremos realizar un par de operaciones para √©l: <br><br><ol><li>  Usuario de inicio de sesi√≥n. <br></li><li>  Obtenga una lista de repositorios de GitHub. <br></li></ol><br>  En ambos casos, las funciones devolver√°n objetos comerciales individuales: GitHubUser o una lista de GitHubRepository. <br><br>  El c√≥digo de implementaci√≥n para esta interfaz es el siguiente: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  - Tomamos <strong>compositeDisposable</strong> para que no haya p√©rdida de memoria. <br>  - Agregar una llamada al primer m√©todo. <br>  - Utilizamos operadores convenientes para obtener el usuario, por ejemplo <strong>flatMap</strong> . <br>  - Obtenemos una lista de sus repositorios. <br>  - Escribimos un <strong>Boilerplate</strong> para que se <strong>ejecute</strong> en los hilos correctos. <br>  - Cuando todo est√© listo, mostramos la lista de repositorios para el usuario conectado. <br><br>  <strong>Dificultades del C√≥digo RxJava:</strong> <br><br><ul><li>  <strong>Complejidad</strong>  En mi opini√≥n, el c√≥digo es demasiado complicado para la simple tarea de dos llamadas de red y mostrar algo en la <strong>interfaz de usuario</strong> . </li><li>  <strong>Rastros de pila sin consolidar.</strong>  Los seguimientos de pila casi no est√°n relacionados con el c√≥digo que escribe. </li><li>  <strong>Recursos excesivos</strong> <strong>.</strong>  RxJava genera muchos objetos debajo del cap√≥ y el rendimiento puede disminuir. </li></ul><br>  <strong>¬øCu√°l ser√° el mismo c√≥digo con las rutinas hasta la versi√≥n 0.26?</strong> <br><br>  En 0.26, la API ha cambiado, y estamos hablando de producci√≥n.  Nadie ha logrado aplicar 0.26 en productos, pero estamos trabajando en ello. <br><br>  <strong>Con las rutinas, nuestra interfaz cambiar√° significativamente</strong> .  Las funciones dejar√°n de devolver los Singles y otros objetos auxiliares.  Inmediatamente devolver√°n objetos comerciales: GitHubUser y una lista de GitHubRepository.  Las funciones GitHubUser y GitHubRepository tendr√°n modificadores de <strong>suspensi√≥n</strong> .  Esto es bueno, porque suspender casi no nos obliga a nada: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br>  Si observa el c√≥digo que ya utiliza la implementaci√≥n de esta interfaz, cambiar√° significativamente en comparaci√≥n con RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  - La acci√≥n principal se lleva a cabo cuando llamamos <strong>al generador de coroutine async</strong> , esperamos una respuesta y obtenemos <strong>userlnfo</strong> . <br>  - Utilizamos datos de este objeto. <br>  - Realice otra llamada <strong>asincr√≥nica</strong> y la llamada en <strong>espera</strong> . <br><br>  Todo parece que no est√° sucediendo un trabajo asincr√≥nico, y simplemente escribimos los comandos en la columna y se ejecutan.  Al final, hacemos lo que hay que hacer en la interfaz de usuario. <br><br>  <strong>¬øPor qu√© son mejores las corutinas?</strong> <br><br><ul><li>  Este c√≥digo es m√°s f√°cil de leer.  Est√° escrito como si fuera consistente. </li><li>  Lo m√°s probable es que el rendimiento de este c√≥digo sea mejor que en RxJava. </li><li>  Es muy sencillo escribir pruebas, pero las veremos un poco m√°s tarde. </li></ul><br><h2>  2 pasos a un lado <br></h2><br>  Dig√°monos un poco, hay un par de cosas que a√∫n necesitan ser discutidas. <br><br><h3>  Paso 1. withContext vs launch / async <br></h3><br>  Adem√°s del <strong>generador de rutina as√≠ncrono,</strong> hay <strong>un generador de rutina con Contexto</strong> . <br><br>  <strong>Iniciar</strong> o <strong>as√≠ncrono</strong> crea un nuevo <strong>contexto de rutina</strong> , que no siempre es necesario.  Si tiene un contexto de rutina que desea utilizar en toda la aplicaci√≥n, no necesita volver a crearlo.  Simplemente puede reutilizar uno existente.  Para hacer esto, necesitar√° un generador de rutina con Contexto.  Simplemente reutiliza el contexto actual de Coroutine.  Ser√° 2-3 veces m√°s r√°pido, pero ahora es una pregunta sin principios.  Si los n√∫meros exactos son interesantes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ est√° la pregunta</a> sobre <strong>stackoverflow</strong> con puntos de referencia y detalles. <br><br><blockquote>  <strong>Regla general:</strong> Use withContext sin lugar a dudas donde encaja sem√°nticamente.  Pero si necesita una carga paralela, por ejemplo, varias im√°genes o datos, la opci√≥n as√≠ncrono / espera es su elecci√≥n. <br></blockquote><br><h3>  Paso 2. Refactorizaci√≥n <br></h3><br>  ¬øQu√© pasa si refactoriza una cadena RxJava realmente compleja?  Encontr√© esto en producci√≥n: <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br>  Ten√≠a una cadena complicada con un <strong>tema p√∫blico</strong> , con <strong>cremallera</strong> y <strong>efectos secundarios</strong> en cada <strong>cremallera</strong> que enviaba algo m√°s al autob√∫s del evento.  La tarea al menos era deshacerse del autob√∫s del evento.  Me sent√© por un d√≠a, pero no pude refactorizar el c√≥digo para resolver el problema.  <strong>La decisi√≥n correcta result√≥ arrojar todo y reescribir el c√≥digo en la rutina en 4 horas</strong> . <br><br>  El siguiente c√≥digo es muy similar a lo que obtuve: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  - Hacemos as√≠ncrono para una tarea, para la segunda y la tercera. <br>  - Estamos esperando el resultado y lo ponemos todo en un objeto. <br>  - Listo! <br><br>  Si tiene cadenas complejas y hay corutinas, simplemente refactorice.  Es realmente rapido. <br><br><h2><a name="fear"></a>  ¬øQu√© impide que los desarrolladores usen corutinas en productos? <br></h2><br>  En mi opini√≥n, a nosotros, como desarrolladores, actualmente se nos impide usar corutinas solo por temor a algo nuevo: <br><br><ul><li>  No sabemos qu√© hacer con el <strong>ciclo de vida</strong> , la <strong>actividad</strong> y el ciclo de vida fragmentado.  ¬øC√≥mo trabajar con corutinas en estos casos? </li><li>  No hay experiencia en la resoluci√≥n de tareas diarias complejas en la producci√≥n utilizando corutina. </li><li>  No hay suficientes herramientas.  Se han escrito un mont√≥n de bibliotecas y funciones para RxJava.  Por ejemplo <strong>RxFCM</strong> .  RxJava en s√≠ tiene muchos operadores, lo cual es bueno, pero ¬øqu√© pasa con la rutina? </li><li>  Realmente no entendemos c√≥mo probar las corutinas. </li></ul><br><blockquote>  Si nos deshacemos de estos cuatro miedos, podemos dormir tranquilos por la noche y usar corutinas en la producci√≥n. <br></blockquote><br>  Vamos punto por punto. <br><br><h3>  1. Gesti√≥n del ciclo de vida. <br></h3><br><ul><li>  Las rutinas pueden tener fugas como <strong>desechables</strong> o <strong>AsyncTask</strong> .  Este problema debe resolverse manualmente. </li><li>  Para evitar una <strong>excepci√≥n</strong> aleatoria de <strong>puntero nulo, se</strong> deben detener las corutinas. </li></ul><br><h4>  Para <br></h4><br>  ¬øEst√°s familiarizado con <strong>Thread.stop ()</strong> ?  Si lo usaste, no por mucho tiempo.  En <strong>JDK 1.1, el</strong> m√©todo se declar√≥ obsoleto de inmediato, ya que es imposible tomar y detener una determinada pieza de c√≥digo y no hay garant√≠as de que se complete correctamente.  Lo m√°s probable es que solo obtenga <strong>da√±os en la memoria</strong> . <br><br>  Por lo tanto, <strong>Thread.stop () no funciona</strong> .  Necesita que la cancelaci√≥n sea cooperativa, es decir, el c√≥digo del otro lado para saber que la est√° cancelando. <br><br>  C√≥mo aplicamos paradas con RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br>  En RxJava <strong>usamos CompositeDisposable</strong> . <br><br>  - Agregue la variable <strong>compositeDisposable</strong> a la actividad en el fragmento o en el presentador, donde usamos RxJava. <br>  - En <strong>onDestro,</strong> agregue <strong>Dispose</strong> y todas las excepciones desaparecen por s√≠ solas. <br><br>  Aproximadamente el mismo principio con las corutinas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() ‚Ä¶ } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br>  Considere un ejemplo de una <strong>tarea simple</strong> . <br><br>  Por lo general, los <strong>constructores de rutina</strong> devuelven un <strong>trabajo</strong> y, en algunos casos, <strong>difieren</strong> . <br><br>  - Podemos memorizar este trabajo. <br>  - Dar el comando <strong>"lanzar"</strong> <strong>generador de corutina</strong> .  El proceso comienza, algo sucede, se recuerda el resultado de la ejecuci√≥n. <br>  - Si no pasamos nada m√°s, "iniciar" inicia la funci√≥n y nos devuelve un enlace al trabajo. <br>  - Job es recordado, y en onDestroy decimos <strong>"cancelar"</strong> y todo funciona bien. <br><br>  <strong>¬øCu√°l es el problema del enfoque?</strong>  Cada trabajo necesita un campo.  Debe mantener una lista de trabajos para cancelarlos todos juntos.  El enfoque conduce a la duplicaci√≥n de c√≥digo, no lo haga. <br><br>  La buena noticia es que tenemos <strong>alternativas</strong> : <strong>CompositeJob</strong> y <strong>un trabajo consciente del ciclo de vida</strong> . <br><br>  CompositeJob es un an√°logo de compositeDisposable.  Se parece a esto <strong>:</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  - Para un fragmento, comenzamos un trabajo. <br>  - Ponemos todos los <strong>trabajos</strong> en CompositeJob y le damos el comando: <strong>"job.cancel () para todos".</strong>  . <br><br>  El enfoque se implementa f√°cilmente en 4 l√≠neas, sin contar la declaraci√≥n de clase: <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br>  Necesitar√°s: <br><br>  - <strong>mapa</strong> con una clave de cadena, <br>  - <strong>agregar</strong> m√©todo, en el que agregar√° trabajo, <br>  - par√°metro <strong>clave</strong> opcional. <br><br>  Si desea utilizar la misma clave para el mismo trabajo, por favor.  Si no, entonces <strong>hashCode</strong> resolver√° nuestro problema.  Agregue el trabajo al mapa, que pasamos, y cancele el anterior con la misma clave.  Si llenamos demasiado la tarea, entonces el resultado anterior no nos interesa.  Lo cancelamos y lo manejamos nuevamente. <br><br>  Cancelar es simple: obtenemos el trabajo por clave y cancelamos.  La segunda cancelaci√≥n para todo el mapa cancela todo.  Todo el c√≥digo est√° escrito en media hora en cuatro l√≠neas y funciona.  Si no desea escribir, tome el ejemplo anterior. <br><br><h4>  Trabajo consciente del ciclo de vida </h4><br>  ¬øHas utilizado <strong>Android Lifecycle</strong> , <strong>Lifecycle owner</strong> u <strong>observador</strong> ? <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br>  Nuestra <strong>actividad</strong> y <strong>fragmentos</strong> tienen ciertos estados.  Aspectos destacados: <strong>creado,</strong> <strong>iniciado</strong> y <strong>reanudado</strong> .  Hay diferentes transiciones entre estados.  <strong>LifecycleObserver le</strong> permite suscribirse a estas transiciones y hacer algo cuando ocurre una de las transiciones. <br><br>  Se ve bastante simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre><br>  Cuelga la anotaci√≥n con alg√∫n par√°metro en el m√©todo, y se llama con la transici√≥n correspondiente.  Simplemente use este enfoque para la rutina: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  - Puedes escribir la clase base <strong>AndroidJob</strong> . <br>  - Transferiremos <strong>Lifecycle a la</strong> clase. <br>  - La interfaz de <strong>LifecycleObserver</strong> implementar√° el trabajo. <br><br>  Todo lo que necesitamos: <br><br>  - En el constructor, agregue a Lifecycle como observador. <br>  - Suscr√≠base a <strong>ON_DESTROY</strong> o cualquier otra cosa que nos interese. <br>  - Hacer cancelar en ON_DESTROY. <br>  - <strong>Obtenga</strong> un <strong>parentJob</strong> en su fragmento. <br>  - Llame al constructor <strong>Joy jobs</strong> o al <strong>ciclo de vida de</strong> su fragmento de actividad.  No hay diferencia <br>  - Pase este <strong>parentJob</strong> como <strong>padre</strong> . <br><br>  El c√≥digo terminado se ve as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br>  Cuando cancela padre, todas las corutinas hijo se cancelan y ya no necesita escribir nada en el fragmento.  Todo sucede autom√°ticamente, no m√°s ON_DESTROY.  Lo principal no olvide pasar <strong>parent = parentJob</strong> . <br><br><blockquote>  Si lo usa, puede escribir una regla de pelusa simple que lo resaltar√°: "¬°Oh, olvid√≥ a sus padres!" <br></blockquote><br>  Con <strong>&nbsp;</strong>  Gesti√≥n del ciclo de vida resuelto.  Tenemos un par de herramientas que le permiten hacer todo esto de manera f√°cil y c√≥moda. <br><br>  ¬øQu√© pasa con los escenarios complejos y las tareas no triviales en la producci√≥n? <br><br><h3>  2. Casos de uso complejos <br></h3><br>  Los escenarios complejos y las tareas no triviales son: <br><br>  - <strong>Operadores</strong> - operadores complejos en RxJava: flatMap, debounce, etc. <br>  - <strong>Manejo de errores - manejo de</strong> errores complejos.  No solo <strong>try..catch</strong> , sino tambi√©n anidado, por ejemplo. <br>  - El <strong>almacenamiento en cach√©</strong> <strong>es una</strong> tarea no trivial.  En producci√≥n, nos encontramos con un cach√© y quer√≠amos obtener una herramienta para resolver f√°cilmente el problema de almacenamiento en cach√© con las rutinas. <br><br><h4>  Repetir </h4><br>  Cuando pensamos en los operadores para la rutina, la primera opci√≥n era <strong>repetirCuando ()</strong> . <br><br>  Si algo sali√≥ mal y Corutin no pudo alcanzar el servidor interno, entonces queremos intentarlo varias veces con alg√∫n tipo de respaldo exponencial.  Quiz√°s la raz√≥n sea una conexi√≥n deficiente y obtendremos el resultado deseado repitiendo la operaci√≥n varias veces. <br><br>  Con las rutinas, esta tarea se implementa f√°cilmente: <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br>  Implementaci√≥n del operador: <br><br>  - √âl toma <strong>diferido</strong> . <br>  - Deber√° llamar a <strong>async</strong> para obtener este objeto. <br>  - En lugar de <strong>diferido,</strong> puede pasar un bloque de suspensi√≥n y, en general, cualquier <strong>funci√≥n de suspensi√≥n.</strong> <br>  - El bucle <strong>for</strong> : est√° esperando el resultado de su rutina.  Si sucede algo y el contador de repetici√≥n no est√° agotado, intente nuevamente con <strong>Retraso</strong> .  Si no, entonces no. <br><br>  La funci√≥n se puede personalizar f√°cilmente: ponga un Retardo exponencial o pase una funci√≥n lambda que calcular√° el Retardo seg√∫n las circunstancias. <br><br>  ¬°√öselo, funciona! <br><br><h4>  Cremalleras </h4><br>  Tambi√©n a menudo los encontramos.  Aqu√≠ nuevamente, todo es simple: <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  - Use la <strong>cremallera</strong> y la llamada en espera en su diferido. <br>  - En lugar de diferido, puede usar la funci√≥n de suspensi√≥n y el generador de corutina con withContext.  Transmitir√° el contexto que necesita. <br><br>  Esto nuevamente funciona y espero haber eliminado este miedo. <br><br><a name="cache"></a><h3>  Cach√© </h3><br><br>  ¬øTiene una implementaci√≥n de cach√© en producci√≥n con RxJava?  Usamos RxCache. <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br>  En el diagrama de la izquierda: <strong>Ver</strong> y <strong>ViewModel</strong> .  A la derecha est√°n las fuentes de datos: llamadas de red y la base de datos. <br><br>  Si queremos que algo se almacene en cach√©, entonces el cach√© ser√° otra fuente de datos. <br><br>  Tipos de cach√©: <br><br><ul><li>  <strong>Fuente</strong> de red para llamadas de red. </li><li>  <strong>Cach√© en memoria</strong> . </li><li>  <strong>El cach√© persistente</strong> con caducidad se almacenar√° en el disco para que el cach√© sobreviva al reinicio de la aplicaci√≥n. </li></ul><br>  Escribamos un <strong>cach√©</strong> simple y primitivo para el tercer caso.  El constructor de rutinas con Contexto viene al rescate nuevamente. <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  - Ejecutas cada operaci√≥n con withContext y ves si hay datos. <br>  - Si los datos de <strong>persistencia</strong> no llegan, est√° intentando obtenerlos de <strong>memory.cache</strong> . <br>  - Si tampoco hay memoria.cach√©, p√≥ngase en contacto con la <strong>fuente de red</strong> y obtenga sus datos.  No olvide, por supuesto, poner en todos los cach√©s. <br><br>  Esta es una implementaci√≥n bastante primitiva y hay muchas preguntas, pero el m√©todo funciona si necesita un cach√© en un lugar.  Para tareas de producci√≥n, este cach√© no es suficiente.  Se necesita algo m√°s complicado. <br><br><h4>  Rx tiene RxCache </h4><br>  Para aquellos que todav√≠a usan RxJava, pueden usar RxCache.  Todav√≠a lo usamos tambi√©n.  <strong>RxCache</strong> es una biblioteca especial.  Le permite almacenar datos en cach√© y administrar su ciclo de vida. <br><br>  Por ejemplo, desea decir que estos datos caducar√°n despu√©s de 15 minutos: "Por favor, despu√©s de este per√≠odo de tiempo, no env√≠e datos desde el cach√©, sino env√≠eme datos nuevos". <br><br>  La biblioteca es maravillosa porque declarativamente apoya al equipo.  La declaraci√≥n es muy similar a lo que haces con <strong>Retrofit</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  - Dices que tienes un <strong>CacheProvider</strong> . <br>  - Inicie un m√©todo y diga que la vida √∫til de <strong>LifeCache es de</strong> 15 minutos.  La clave por la cual estar√° disponible es <strong>Caracter√≠sticas</strong> . <br>  - Devuelve <strong>Observable &lt;Reply</strong> , donde <strong>Reply</strong> es un objeto de biblioteca auxiliar para trabajar con cach√©. <br><br>  El uso es bastante simple: <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  - Desde el cach√© Rx, acceda a <strong>RestApi</strong> . <br>  - <strong>Dir√≠jase</strong> a <strong>CacheProvider</strong> . <br>  - Alim√©ntalo con un observable. <br>  - La biblioteca en s√≠ determinar√° qu√© hacer: ir al cach√© o no, si se agota el tiempo, recurrir a <strong>Observable</strong> y realizar otra operaci√≥n. <br><br>  Usar la biblioteca es muy conveniente y me gustar√≠a obtener uno similar para la rutina. <br><br><h4>  Cach√© de rutina en desarrollo </h4><br>  Dentro de EPAM, estamos escribiendo la biblioteca <strong>Coroutine Cache</strong> , que realizar√° todas las funciones de RxCache.  Escribimos la primera versi√≥n y la ejecutamos dentro de la empresa.  Tan pronto como salga el primer lanzamiento, estar√© encantado de publicarlo en mi Twitter.  Se ver√° as√≠: <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br>  Tendremos una funci√≥n de suspensi√≥n <strong>getFeatures</strong> .  Pasaremos la funci√≥n como un bloque a una funci√≥n especial de orden superior con <strong>Cache</strong> , que determinar√° lo que hay que hacer. <br><br>  Quiz√°s haremos la misma interfaz para admitir funciones declarativas. <br><br><a name="err"></a><h3>  Manejo de errores <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br>  Los desarrolladores a menudo encuentran un manejo simple de errores y generalmente se resuelve de manera bastante simple.  Si no tiene cosas complicadas, entonces en Captura, captura la <strong>excepci√≥n</strong> y mira lo que sucedi√≥ all√≠, escribe en el registro o muestra un error al usuario.  En la interfaz de usuario, puede hacer esto f√°cilmente. <br><br>  En casos simples, se espera que todo sea simple: el manejo de errores con corutinas se realiza a trav√©s de <strong>try-catch-finally</strong> . <br><br>  En producci√≥n, adem√°s de casos simples, hay: <br><br>  - Try <strong>-catch</strong> anidado, <br>  - Muchos tipos diferentes de <strong>excepciones</strong> , <br>  - Errores en la red o en la l√≥gica empresarial, <br>  - Errores de usuario.  Nuevamente hizo algo mal y tuvo la culpa de todo. <br><br>  Debemos estar preparados para esto. <br><br>  Hay 2 soluciones: <strong>CoroutineExceptionHandler</strong> y el enfoque con las <strong>clases de resultados</strong> . <br><br><h3>  Manejador de excepciones de rutina <br></h3><br>  Esta es una clase especial para manejar casos complejos de errores.  <strong>ExceptionHandler le</strong> permite tomar su <strong>Excepci√≥n</strong> como un argumento como un error y manejarlo. <br><br>  ¬øC√≥mo solemos manejar los errores complejos? <br><br>  El usuario presion√≥ algo, el bot√≥n no funcion√≥.  Necesita decir qu√© sali√≥ mal y dirigirlo a una acci√≥n espec√≠fica: verifique Internet, Wi-Fi, intente m√°s tarde o elimine la aplicaci√≥n y nunca la vuelva a usar.  Decirle esto al usuario puede ser bastante simple: <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  - Recibamos el mensaje predeterminado: "¬°Algo sali√≥ mal!"  y analizar la excepci√≥n. <br>  - Si se trata de una <strong>ConnectionException,</strong> tomamos un mensaje localizado de los recursos: ‚ÄúHombre, enciende el Wi-Fi y tus problemas desaparecer√°n.  Te lo garantizo. <br>  - Si el <strong>servidor dijo algo incorrecto</strong> , entonces debe decirle al cliente: ‚ÄúCierre sesi√≥n e inicie sesi√≥n nuevamente‚Äù, o ‚ÄúNo haga esto en Mosc√∫, haga esto en otro pa√≠s‚Äù, o ‚ÄúLo siento, camarada.  Todo lo que puedo hacer es decir que algo sali√≥ mal ". <br>  - Si este es un <strong>error</strong> completamente <strong>diferente</strong> , por ejemplo, <strong>sin memoria</strong> , decimos: "Algo sali√≥ mal, lo siento". <br>  - Se muestran todos los mensajes. <br><br>  Lo que escriba en <strong>CoroutineExceptionHandler</strong> se ejecutar√° en el mismo <strong>Dispatcher</strong> donde ejecuta la corutina.  Por lo tanto, si le da el comando de "inicio" a la interfaz de usuario, entonces todo sucede en la interfaz de usuario.  No necesita un <strong>env√≠o por</strong> separado <strong>, lo</strong> cual es muy conveniente. <br><br>  El uso es simple: <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br>  Hay un operador <strong>m√°s</strong> .  En el contexto de Coroutine, agregue un <strong>controlador</strong> y todo funciona, lo cual es muy conveniente.  Usamos esto por un tiempo. <br><br><h3>  Clases de resultados <br></h3><br>  M√°s tarde nos dimos cuenta de que podr√≠a faltar el CoroutineExceptionHandler.  El resultado, que est√° formado por el trabajo de la rutina, puede consistir en varios datos, de diferentes partes o procesar varias situaciones. <br><br>  El enfoque de las <strong>clases de resultados</strong> ayuda a hacer frente a este problema: <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  - En su l√≥gica de negocios, comienza una <strong>clase de resultados</strong> . <br>  - Marcar como <strong>sellado</strong> . <br>  - Hereda de la clase otras dos clases de datos: <strong>√âxito</strong> y <strong>Error</strong> . <br> ‚Äî  <strong>Success</strong>   ,     . <br> ‚Äî  <strong>Error</strong>  exception. <br><br>     -  : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br>  Coroutine context ‚Äî Coroutine builder withContex     . <br><br> ,  : <br><br> ‚Äî   ,   error.     . <br> ‚Äî   RestApi   -. <br> ‚Äî   ,   <strong>Result.Success</strong> . <br> ‚Äî   ,  <strong>Result.Error</strong> . <br><br>      - ,  ExceptionHandler   . <br><br> Result classes ,   .   Result classes,      ExceptionHandler  try-catch. <br><br><h3> 3.  <br></h3><br> ,       .    <strong>unit-</strong> ,   ,    .       unit-. <br><br> ,   .   ,   unit-,    2 : <br><br><ol><li> <strong>Replacing context</strong> .   ,    ; </li><li> <strong>Mocking coroutines</strong> .   . </li></ol><br><h4> Replacing context <br></h4><br>   presenter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { ‚Ä¶ } }</code> </pre><br> ,    <strong>login</strong>    ,     UI-.      ,        ,  <strong>         </strong> .    ,    ,   unit-. <br><br>   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br> ‚Äî   login   coroutineContext. ,            .  Kotlin   ,     UI  . <br> ‚Äî   Coroutine builder   Coroutine Contex,    . <br><br>  unit-   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br> ‚Äî    <strong>LoginPresenter</strong>   login   - , ,  Unconfined. <br> ‚Äî <strong>Unconfined</strong> ,      ,    .         . <br><br><h4> Mocking coroutines <br></h4><br>   ‚Äî  .    <strong>Mockk</strong>  unit-.     unit-    Kotlin,      .  suspend-        <strong>coEvery</strong>        -. <br><br>   login     <strong>githubUser</strong> : <br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br>    <strong>Mockito-kotlin</strong> ,     ‚Äî    . ,    ,     : <br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br>    <strong>runBlocking</strong> .  <strong>given-</strong>    ,    . <br><br>        <strong>Presenter</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br> ‚Äî   -, , <strong>GitHubUser</strong> . <br> ‚Äî  LoginPresenter      API,     .      . <br> ‚Äî   <strong>presenter.login</strong>  Unconfined   ,   Presenter    ,   . <br><br>  ¬°Y eso es todo!    . <br><br><h2>   <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  ‚Äî   ,   . </li><li> <strong>   .</strong>   ,       . Unit- ‚Äî       ,  ,     ,    .  ‚Äî welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3>  Enlaces utiles <br></h3><br><ul><li>      ,      Android GDE   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a>       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong> Medium</strong></a>     ¬´¬ª      Android,   async-   . </li></ul><br><blockquote>  <strong>Noticias</strong> <br><br> 30    Mail.ru   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>      .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ,   ,       ,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">youtube-</a>       AppsConf 2018 ‚Äî    :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429908/">https://habr.com/ru/post/es429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429892/index.html">xonsh - python como reemplazo de shell</a></li>
<li><a href="../es429894/index.html">Usando un ojo de pez en una Raspberry Pi 3 con ROS - Parte 2</a></li>
<li><a href="../es429898/index.html">DMS (Sistema de gesti√≥n de concesionarios): implementaci√≥n de los ecosistemas de informaci√≥n para la gesti√≥n de redes de concesionarios</a></li>
<li><a href="../es429902/index.html">Page Rank en la era de la Web 2.0 - Parte 1</a></li>
<li><a href="../es429904/index.html">Historias divertidas y tristes sobre el desarrollo de juegos de computadora</a></li>
<li><a href="../es429910/index.html">AppsConf Rises</a></li>
<li><a href="../es429912/index.html">Desarrollo de bibliotecas: de API a lanzamiento p√∫blico</a></li>
<li><a href="../es429914/index.html">OpenSceneGraph: Gr√°fico de escena y punteros inteligentes</a></li>
<li><a href="../es429916/index.html">C√≥mo construir y construir</a></li>
<li><a href="../es429918/index.html">Mundo virtual Intel. Parte 2: SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>