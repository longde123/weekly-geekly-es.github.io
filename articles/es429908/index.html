<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔨 ⚜️ 🙆🏼 Cómo usar corutinas en la comida y dormir tranquilo por la noche 👼🏻 😽 👐🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las rutinas son una herramienta poderosa para la ejecución de código asíncrono. Trabajan en paralelo, se comunican entre sí y consumen pocos recursos....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo usar corutinas en la comida y dormir tranquilo por la noche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/429908/">  Las rutinas son una herramienta poderosa para la ejecución de código asíncrono.  Trabajan en paralelo, se comunican entre sí y consumen pocos recursos.  Parecería que sin temor, las corutinas pueden introducirse en la producción.  Pero hay miedos e interfieren. <br><br>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe de</a> <strong>Vladimir Ivanov</strong> sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> trata sobre el hecho de que el diablo no es tan terrible y que puedes usar corutinas en este momento: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por qué corutinas, no RxJava</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lo que temen obstaculizar a los desarrolladores</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cómo hacer un caché usando corutinas</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo manejar los errores correctamente</a> . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador</strong> : Vladimir Ivanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">dzigoro</a> ) es un desarrollador líder de Android en <strong>EPAM</strong> con 7 años de experiencia, es aficionado a la arquitectura de soluciones, el desarrollo de React Native y iOS, y también tiene un certificado de <strong>Google Cloud Architect</strong> . <br><a name="habracut"></a><br><blockquote>  Todo lo que lees es un producto de producción de experiencia y varios estudios, así que tómalo como está, sin ninguna garantía. <br></blockquote><h2><a name="coroutine"></a>  Coroutines, Kotlin y RxJava </h2><br>  Para información: el estado actual de la corutina se encuentra en el lanzamiento, dejó Beta.  Se lanzó <strong>Kotlin 1.3</strong> , las corutinas se declararon estables y hay paz en el mundo. <br><br><img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br>  Recientemente realicé una encuesta en Twitter que dice que las personas que usan corutina: <br><br><ul><li>  13% de las corutinas en los alimentos.  Todo esta bien; </li><li>  El 25% los prueba en el proyecto de mascotas; </li><li>  24% - ¿Qué es Kotlin? </li><li>  La mayor parte del 38% de RxJava está en todas partes. </li></ul><br>  Las estadísticas no son felices.  Creo que <strong>RxJava es una herramienta demasiado compleja</strong> para tareas en las que los desarrolladores la usan comúnmente.  Las rutinas son más adecuadas para controlar la operación asincrónica. <br><br>  En mis informes anteriores, hablé sobre cómo refactorizar desde RxJava a corutinas en Kotlin, por lo que no me detendré en esto en detalle, sino que solo recordaré los puntos principales. <br><br><h3>  ¿Por qué usamos corutinas? </h3><br>  Porque si usamos RxJava, los ejemplos de implementación habituales se verían así: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br>  Tenemos una interfaz, por ejemplo, escribimos un cliente GitHub y queremos realizar un par de operaciones para él: <br><br><ol><li>  Usuario de inicio de sesión. <br></li><li>  Obtenga una lista de repositorios de GitHub. <br></li></ol><br>  En ambos casos, las funciones devolverán objetos comerciales individuales: GitHubUser o una lista de GitHubRepository. <br><br>  El código de implementación para esta interfaz es el siguiente: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  - Tomamos <strong>compositeDisposable</strong> para que no haya pérdida de memoria. <br>  - Agregar una llamada al primer método. <br>  - Utilizamos operadores convenientes para obtener el usuario, por ejemplo <strong>flatMap</strong> . <br>  - Obtenemos una lista de sus repositorios. <br>  - Escribimos un <strong>Boilerplate</strong> para que se <strong>ejecute</strong> en los hilos correctos. <br>  - Cuando todo esté listo, mostramos la lista de repositorios para el usuario conectado. <br><br>  <strong>Dificultades del Código RxJava:</strong> <br><br><ul><li>  <strong>Complejidad</strong>  En mi opinión, el código es demasiado complicado para la simple tarea de dos llamadas de red y mostrar algo en la <strong>interfaz de usuario</strong> . </li><li>  <strong>Rastros de pila sin consolidar.</strong>  Los seguimientos de pila casi no están relacionados con el código que escribe. </li><li>  <strong>Recursos excesivos</strong> <strong>.</strong>  RxJava genera muchos objetos debajo del capó y el rendimiento puede disminuir. </li></ul><br>  <strong>¿Cuál será el mismo código con las rutinas hasta la versión 0.26?</strong> <br><br>  En 0.26, la API ha cambiado, y estamos hablando de producción.  Nadie ha logrado aplicar 0.26 en productos, pero estamos trabajando en ello. <br><br>  <strong>Con las rutinas, nuestra interfaz cambiará significativamente</strong> .  Las funciones dejarán de devolver los Singles y otros objetos auxiliares.  Inmediatamente devolverán objetos comerciales: GitHubUser y una lista de GitHubRepository.  Las funciones GitHubUser y GitHubRepository tendrán modificadores de <strong>suspensión</strong> .  Esto es bueno, porque suspender casi no nos obliga a nada: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br>  Si observa el código que ya utiliza la implementación de esta interfaz, cambiará significativamente en comparación con RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  - La acción principal se lleva a cabo cuando llamamos <strong>al generador de coroutine async</strong> , esperamos una respuesta y obtenemos <strong>userlnfo</strong> . <br>  - Utilizamos datos de este objeto. <br>  - Realice otra llamada <strong>asincrónica</strong> y la llamada en <strong>espera</strong> . <br><br>  Todo parece que no está sucediendo un trabajo asincrónico, y simplemente escribimos los comandos en la columna y se ejecutan.  Al final, hacemos lo que hay que hacer en la interfaz de usuario. <br><br>  <strong>¿Por qué son mejores las corutinas?</strong> <br><br><ul><li>  Este código es más fácil de leer.  Está escrito como si fuera consistente. </li><li>  Lo más probable es que el rendimiento de este código sea mejor que en RxJava. </li><li>  Es muy sencillo escribir pruebas, pero las veremos un poco más tarde. </li></ul><br><h2>  2 pasos a un lado <br></h2><br>  Digámonos un poco, hay un par de cosas que aún necesitan ser discutidas. <br><br><h3>  Paso 1. withContext vs launch / async <br></h3><br>  Además del <strong>generador de rutina asíncrono,</strong> hay <strong>un generador de rutina con Contexto</strong> . <br><br>  <strong>Iniciar</strong> o <strong>asíncrono</strong> crea un nuevo <strong>contexto de rutina</strong> , que no siempre es necesario.  Si tiene un contexto de rutina que desea utilizar en toda la aplicación, no necesita volver a crearlo.  Simplemente puede reutilizar uno existente.  Para hacer esto, necesitará un generador de rutina con Contexto.  Simplemente reutiliza el contexto actual de Coroutine.  Será 2-3 veces más rápido, pero ahora es una pregunta sin principios.  Si los números exactos son interesantes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí está la pregunta</a> sobre <strong>stackoverflow</strong> con puntos de referencia y detalles. <br><br><blockquote>  <strong>Regla general:</strong> Use withContext sin lugar a dudas donde encaja semánticamente.  Pero si necesita una carga paralela, por ejemplo, varias imágenes o datos, la opción asíncrono / espera es su elección. <br></blockquote><br><h3>  Paso 2. Refactorización <br></h3><br>  ¿Qué pasa si refactoriza una cadena RxJava realmente compleja?  Encontré esto en producción: <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br>  Tenía una cadena complicada con un <strong>tema público</strong> , con <strong>cremallera</strong> y <strong>efectos secundarios</strong> en cada <strong>cremallera</strong> que enviaba algo más al autobús del evento.  La tarea al menos era deshacerse del autobús del evento.  Me senté por un día, pero no pude refactorizar el código para resolver el problema.  <strong>La decisión correcta resultó arrojar todo y reescribir el código en la rutina en 4 horas</strong> . <br><br>  El siguiente código es muy similar a lo que obtuve: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  - Hacemos asíncrono para una tarea, para la segunda y la tercera. <br>  - Estamos esperando el resultado y lo ponemos todo en un objeto. <br>  - Listo! <br><br>  Si tiene cadenas complejas y hay corutinas, simplemente refactorice.  Es realmente rapido. <br><br><h2><a name="fear"></a>  ¿Qué impide que los desarrolladores usen corutinas en productos? <br></h2><br>  En mi opinión, a nosotros, como desarrolladores, actualmente se nos impide usar corutinas solo por temor a algo nuevo: <br><br><ul><li>  No sabemos qué hacer con el <strong>ciclo de vida</strong> , la <strong>actividad</strong> y el ciclo de vida fragmentado.  ¿Cómo trabajar con corutinas en estos casos? </li><li>  No hay experiencia en la resolución de tareas diarias complejas en la producción utilizando corutina. </li><li>  No hay suficientes herramientas.  Se han escrito un montón de bibliotecas y funciones para RxJava.  Por ejemplo <strong>RxFCM</strong> .  RxJava en sí tiene muchos operadores, lo cual es bueno, pero ¿qué pasa con la rutina? </li><li>  Realmente no entendemos cómo probar las corutinas. </li></ul><br><blockquote>  Si nos deshacemos de estos cuatro miedos, podemos dormir tranquilos por la noche y usar corutinas en la producción. <br></blockquote><br>  Vamos punto por punto. <br><br><h3>  1. Gestión del ciclo de vida. <br></h3><br><ul><li>  Las rutinas pueden tener fugas como <strong>desechables</strong> o <strong>AsyncTask</strong> .  Este problema debe resolverse manualmente. </li><li>  Para evitar una <strong>excepción</strong> aleatoria de <strong>puntero nulo, se</strong> deben detener las corutinas. </li></ul><br><h4>  Para <br></h4><br>  ¿Estás familiarizado con <strong>Thread.stop ()</strong> ?  Si lo usaste, no por mucho tiempo.  En <strong>JDK 1.1, el</strong> método se declaró obsoleto de inmediato, ya que es imposible tomar y detener una determinada pieza de código y no hay garantías de que se complete correctamente.  Lo más probable es que solo obtenga <strong>daños en la memoria</strong> . <br><br>  Por lo tanto, <strong>Thread.stop () no funciona</strong> .  Necesita que la cancelación sea cooperativa, es decir, el código del otro lado para saber que la está cancelando. <br><br>  Cómo aplicamos paradas con RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br>  En RxJava <strong>usamos CompositeDisposable</strong> . <br><br>  - Agregue la variable <strong>compositeDisposable</strong> a la actividad en el fragmento o en el presentador, donde usamos RxJava. <br>  - En <strong>onDestro,</strong> agregue <strong>Dispose</strong> y todas las excepciones desaparecen por sí solas. <br><br>  Aproximadamente el mismo principio con las corutinas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() … } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br>  Considere un ejemplo de una <strong>tarea simple</strong> . <br><br>  Por lo general, los <strong>constructores de rutina</strong> devuelven un <strong>trabajo</strong> y, en algunos casos, <strong>difieren</strong> . <br><br>  - Podemos memorizar este trabajo. <br>  - Dar el comando <strong>"lanzar"</strong> <strong>generador de corutina</strong> .  El proceso comienza, algo sucede, se recuerda el resultado de la ejecución. <br>  - Si no pasamos nada más, "iniciar" inicia la función y nos devuelve un enlace al trabajo. <br>  - Job es recordado, y en onDestroy decimos <strong>"cancelar"</strong> y todo funciona bien. <br><br>  <strong>¿Cuál es el problema del enfoque?</strong>  Cada trabajo necesita un campo.  Debe mantener una lista de trabajos para cancelarlos todos juntos.  El enfoque conduce a la duplicación de código, no lo haga. <br><br>  La buena noticia es que tenemos <strong>alternativas</strong> : <strong>CompositeJob</strong> y <strong>un trabajo consciente del ciclo de vida</strong> . <br><br>  CompositeJob es un análogo de compositeDisposable.  Se parece a esto <strong>:</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  - Para un fragmento, comenzamos un trabajo. <br>  - Ponemos todos los <strong>trabajos</strong> en CompositeJob y le damos el comando: <strong>"job.cancel () para todos".</strong>  . <br><br>  El enfoque se implementa fácilmente en 4 líneas, sin contar la declaración de clase: <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br>  Necesitarás: <br><br>  - <strong>mapa</strong> con una clave de cadena, <br>  - <strong>agregar</strong> método, en el que agregará trabajo, <br>  - parámetro <strong>clave</strong> opcional. <br><br>  Si desea utilizar la misma clave para el mismo trabajo, por favor.  Si no, entonces <strong>hashCode</strong> resolverá nuestro problema.  Agregue el trabajo al mapa, que pasamos, y cancele el anterior con la misma clave.  Si llenamos demasiado la tarea, entonces el resultado anterior no nos interesa.  Lo cancelamos y lo manejamos nuevamente. <br><br>  Cancelar es simple: obtenemos el trabajo por clave y cancelamos.  La segunda cancelación para todo el mapa cancela todo.  Todo el código está escrito en media hora en cuatro líneas y funciona.  Si no desea escribir, tome el ejemplo anterior. <br><br><h4>  Trabajo consciente del ciclo de vida </h4><br>  ¿Has utilizado <strong>Android Lifecycle</strong> , <strong>Lifecycle owner</strong> u <strong>observador</strong> ? <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br>  Nuestra <strong>actividad</strong> y <strong>fragmentos</strong> tienen ciertos estados.  Aspectos destacados: <strong>creado,</strong> <strong>iniciado</strong> y <strong>reanudado</strong> .  Hay diferentes transiciones entre estados.  <strong>LifecycleObserver le</strong> permite suscribirse a estas transiciones y hacer algo cuando ocurre una de las transiciones. <br><br>  Se ve bastante simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ … } }</code> </pre><br>  Cuelga la anotación con algún parámetro en el método, y se llama con la transición correspondiente.  Simplemente use este enfoque para la rutina: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  - Puedes escribir la clase base <strong>AndroidJob</strong> . <br>  - Transferiremos <strong>Lifecycle a la</strong> clase. <br>  - La interfaz de <strong>LifecycleObserver</strong> implementará el trabajo. <br><br>  Todo lo que necesitamos: <br><br>  - En el constructor, agregue a Lifecycle como observador. <br>  - Suscríbase a <strong>ON_DESTROY</strong> o cualquier otra cosa que nos interese. <br>  - Hacer cancelar en ON_DESTROY. <br>  - <strong>Obtenga</strong> un <strong>parentJob</strong> en su fragmento. <br>  - Llame al constructor <strong>Joy jobs</strong> o al <strong>ciclo de vida de</strong> su fragmento de actividad.  No hay diferencia <br>  - Pase este <strong>parentJob</strong> como <strong>padre</strong> . <br><br>  El código terminado se ve así: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br>  Cuando cancela padre, todas las corutinas hijo se cancelan y ya no necesita escribir nada en el fragmento.  Todo sucede automáticamente, no más ON_DESTROY.  Lo principal no olvide pasar <strong>parent = parentJob</strong> . <br><br><blockquote>  Si lo usa, puede escribir una regla de pelusa simple que lo resaltará: "¡Oh, olvidó a sus padres!" <br></blockquote><br>  Con <strong>&nbsp;</strong>  Gestión del ciclo de vida resuelto.  Tenemos un par de herramientas que le permiten hacer todo esto de manera fácil y cómoda. <br><br>  ¿Qué pasa con los escenarios complejos y las tareas no triviales en la producción? <br><br><h3>  2. Casos de uso complejos <br></h3><br>  Los escenarios complejos y las tareas no triviales son: <br><br>  - <strong>Operadores</strong> - operadores complejos en RxJava: flatMap, debounce, etc. <br>  - <strong>Manejo de errores - manejo de</strong> errores complejos.  No solo <strong>try..catch</strong> , sino también anidado, por ejemplo. <br>  - El <strong>almacenamiento en caché</strong> <strong>es una</strong> tarea no trivial.  En producción, nos encontramos con un caché y queríamos obtener una herramienta para resolver fácilmente el problema de almacenamiento en caché con las rutinas. <br><br><h4>  Repetir </h4><br>  Cuando pensamos en los operadores para la rutina, la primera opción era <strong>repetirCuando ()</strong> . <br><br>  Si algo salió mal y Corutin no pudo alcanzar el servidor interno, entonces queremos intentarlo varias veces con algún tipo de respaldo exponencial.  Quizás la razón sea una conexión deficiente y obtendremos el resultado deseado repitiendo la operación varias veces. <br><br>  Con las rutinas, esta tarea se implementa fácilmente: <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br>  Implementación del operador: <br><br>  - Él toma <strong>diferido</strong> . <br>  - Deberá llamar a <strong>async</strong> para obtener este objeto. <br>  - En lugar de <strong>diferido,</strong> puede pasar un bloque de suspensión y, en general, cualquier <strong>función de suspensión.</strong> <br>  - El bucle <strong>for</strong> : está esperando el resultado de su rutina.  Si sucede algo y el contador de repetición no está agotado, intente nuevamente con <strong>Retraso</strong> .  Si no, entonces no. <br><br>  La función se puede personalizar fácilmente: ponga un Retardo exponencial o pase una función lambda que calculará el Retardo según las circunstancias. <br><br>  ¡Úselo, funciona! <br><br><h4>  Cremalleras </h4><br>  También a menudo los encontramos.  Aquí nuevamente, todo es simple: <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  - Use la <strong>cremallera</strong> y la llamada en espera en su diferido. <br>  - En lugar de diferido, puede usar la función de suspensión y el generador de corutina con withContext.  Transmitirá el contexto que necesita. <br><br>  Esto nuevamente funciona y espero haber eliminado este miedo. <br><br><a name="cache"></a><h3>  Caché </h3><br><br>  ¿Tiene una implementación de caché en producción con RxJava?  Usamos RxCache. <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br>  En el diagrama de la izquierda: <strong>Ver</strong> y <strong>ViewModel</strong> .  A la derecha están las fuentes de datos: llamadas de red y la base de datos. <br><br>  Si queremos que algo se almacene en caché, entonces el caché será otra fuente de datos. <br><br>  Tipos de caché: <br><br><ul><li>  <strong>Fuente</strong> de red para llamadas de red. </li><li>  <strong>Caché en memoria</strong> . </li><li>  <strong>El caché persistente</strong> con caducidad se almacenará en el disco para que el caché sobreviva al reinicio de la aplicación. </li></ul><br>  Escribamos un <strong>caché</strong> simple y primitivo para el tercer caso.  El constructor de rutinas con Contexto viene al rescate nuevamente. <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  - Ejecutas cada operación con withContext y ves si hay datos. <br>  - Si los datos de <strong>persistencia</strong> no llegan, está intentando obtenerlos de <strong>memory.cache</strong> . <br>  - Si tampoco hay memoria.caché, póngase en contacto con la <strong>fuente de red</strong> y obtenga sus datos.  No olvide, por supuesto, poner en todos los cachés. <br><br>  Esta es una implementación bastante primitiva y hay muchas preguntas, pero el método funciona si necesita un caché en un lugar.  Para tareas de producción, este caché no es suficiente.  Se necesita algo más complicado. <br><br><h4>  Rx tiene RxCache </h4><br>  Para aquellos que todavía usan RxJava, pueden usar RxCache.  Todavía lo usamos también.  <strong>RxCache</strong> es una biblioteca especial.  Le permite almacenar datos en caché y administrar su ciclo de vida. <br><br>  Por ejemplo, desea decir que estos datos caducarán después de 15 minutos: "Por favor, después de este período de tiempo, no envíe datos desde el caché, sino envíeme datos nuevos". <br><br>  La biblioteca es maravillosa porque declarativamente apoya al equipo.  La declaración es muy similar a lo que haces con <strong>Retrofit</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  - Dices que tienes un <strong>CacheProvider</strong> . <br>  - Inicie un método y diga que la vida útil de <strong>LifeCache es de</strong> 15 minutos.  La clave por la cual estará disponible es <strong>Características</strong> . <br>  - Devuelve <strong>Observable &lt;Reply</strong> , donde <strong>Reply</strong> es un objeto de biblioteca auxiliar para trabajar con caché. <br><br>  El uso es bastante simple: <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  - Desde el caché Rx, acceda a <strong>RestApi</strong> . <br>  - <strong>Diríjase</strong> a <strong>CacheProvider</strong> . <br>  - Aliméntalo con un observable. <br>  - La biblioteca en sí determinará qué hacer: ir al caché o no, si se agota el tiempo, recurrir a <strong>Observable</strong> y realizar otra operación. <br><br>  Usar la biblioteca es muy conveniente y me gustaría obtener uno similar para la rutina. <br><br><h4>  Caché de rutina en desarrollo </h4><br>  Dentro de EPAM, estamos escribiendo la biblioteca <strong>Coroutine Cache</strong> , que realizará todas las funciones de RxCache.  Escribimos la primera versión y la ejecutamos dentro de la empresa.  Tan pronto como salga el primer lanzamiento, estaré encantado de publicarlo en mi Twitter.  Se verá así: <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br>  Tendremos una función de suspensión <strong>getFeatures</strong> .  Pasaremos la función como un bloque a una función especial de orden superior con <strong>Cache</strong> , que determinará lo que hay que hacer. <br><br>  Quizás haremos la misma interfaz para admitir funciones declarativas. <br><br><a name="err"></a><h3>  Manejo de errores <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br>  Los desarrolladores a menudo encuentran un manejo simple de errores y generalmente se resuelve de manera bastante simple.  Si no tiene cosas complicadas, entonces en Captura, captura la <strong>excepción</strong> y mira lo que sucedió allí, escribe en el registro o muestra un error al usuario.  En la interfaz de usuario, puede hacer esto fácilmente. <br><br>  En casos simples, se espera que todo sea simple: el manejo de errores con corutinas se realiza a través de <strong>try-catch-finally</strong> . <br><br>  En producción, además de casos simples, hay: <br><br>  - Try <strong>-catch</strong> anidado, <br>  - Muchos tipos diferentes de <strong>excepciones</strong> , <br>  - Errores en la red o en la lógica empresarial, <br>  - Errores de usuario.  Nuevamente hizo algo mal y tuvo la culpa de todo. <br><br>  Debemos estar preparados para esto. <br><br>  Hay 2 soluciones: <strong>CoroutineExceptionHandler</strong> y el enfoque con las <strong>clases de resultados</strong> . <br><br><h3>  Manejador de excepciones de rutina <br></h3><br>  Esta es una clase especial para manejar casos complejos de errores.  <strong>ExceptionHandler le</strong> permite tomar su <strong>Excepción</strong> como un argumento como un error y manejarlo. <br><br>  ¿Cómo solemos manejar los errores complejos? <br><br>  El usuario presionó algo, el botón no funcionó.  Necesita decir qué salió mal y dirigirlo a una acción específica: verifique Internet, Wi-Fi, intente más tarde o elimine la aplicación y nunca la vuelva a usar.  Decirle esto al usuario puede ser bastante simple: <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  - Recibamos el mensaje predeterminado: "¡Algo salió mal!"  y analizar la excepción. <br>  - Si se trata de una <strong>ConnectionException,</strong> tomamos un mensaje localizado de los recursos: “Hombre, enciende el Wi-Fi y tus problemas desaparecerán.  Te lo garantizo. <br>  - Si el <strong>servidor dijo algo incorrecto</strong> , entonces debe decirle al cliente: “Cierre sesión e inicie sesión nuevamente”, o “No haga esto en Moscú, haga esto en otro país”, o “Lo siento, camarada.  Todo lo que puedo hacer es decir que algo salió mal ". <br>  - Si este es un <strong>error</strong> completamente <strong>diferente</strong> , por ejemplo, <strong>sin memoria</strong> , decimos: "Algo salió mal, lo siento". <br>  - Se muestran todos los mensajes. <br><br>  Lo que escriba en <strong>CoroutineExceptionHandler</strong> se ejecutará en el mismo <strong>Dispatcher</strong> donde ejecuta la corutina.  Por lo tanto, si le da el comando de "inicio" a la interfaz de usuario, entonces todo sucede en la interfaz de usuario.  No necesita un <strong>envío por</strong> separado <strong>, lo</strong> cual es muy conveniente. <br><br>  El uso es simple: <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br>  Hay un operador <strong>más</strong> .  En el contexto de Coroutine, agregue un <strong>controlador</strong> y todo funciona, lo cual es muy conveniente.  Usamos esto por un tiempo. <br><br><h3>  Clases de resultados <br></h3><br>  Más tarde nos dimos cuenta de que podría faltar el CoroutineExceptionHandler.  El resultado, que está formado por el trabajo de la rutina, puede consistir en varios datos, de diferentes partes o procesar varias situaciones. <br><br>  El enfoque de las <strong>clases de resultados</strong> ayuda a hacer frente a este problema: <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  - En su lógica de negocios, comienza una <strong>clase de resultados</strong> . <br>  - Marcar como <strong>sellado</strong> . <br>  - Hereda de la clase otras dos clases de datos: <strong>Éxito</strong> y <strong>Error</strong> . <br> —  <strong>Success</strong>   ,     . <br> —  <strong>Error</strong>  exception. <br><br>     -  : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } … <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br>  Coroutine context — Coroutine builder withContex     . <br><br> ,  : <br><br> —   ,   error.     . <br> —   RestApi   -. <br> —   ,   <strong>Result.Success</strong> . <br> —   ,  <strong>Result.Error</strong> . <br><br>      - ,  ExceptionHandler   . <br><br> Result classes ,   .   Result classes,      ExceptionHandler  try-catch. <br><br><h3> 3.  <br></h3><br> ,       .    <strong>unit-</strong> ,   ,    .       unit-. <br><br> ,   .   ,   unit-,    2 : <br><br><ol><li> <strong>Replacing context</strong> .   ,    ; </li><li> <strong>Mocking coroutines</strong> .   . </li></ol><br><h4> Replacing context <br></h4><br>   presenter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { … } }</code> </pre><br> ,    <strong>login</strong>    ,     UI-.      ,        ,  <strong>         </strong> .    ,    ,   unit-. <br><br>   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br> —   login   coroutineContext. ,            .  Kotlin   ,     UI  . <br> —   Coroutine builder   Coroutine Contex,    . <br><br>  unit-   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br> —    <strong>LoginPresenter</strong>   login   - , ,  Unconfined. <br> — <strong>Unconfined</strong> ,      ,    .         . <br><br><h4> Mocking coroutines <br></h4><br>   —  .    <strong>Mockk</strong>  unit-.     unit-    Kotlin,      .  suspend-        <strong>coEvery</strong>        -. <br><br>   login     <strong>githubUser</strong> : <br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br>    <strong>Mockito-kotlin</strong> ,     —    . ,    ,     : <br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br>    <strong>runBlocking</strong> .  <strong>given-</strong>    ,    . <br><br>        <strong>Presenter</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br> —   -, , <strong>GitHubUser</strong> . <br> —  LoginPresenter      API,     .      . <br> —   <strong>presenter.login</strong>  Unconfined   ,   Presenter    ,   . <br><br>  ¡Y eso es todo!    . <br><br><h2>   <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  —   ,   . </li><li> <strong>   .</strong>   ,       . Unit- —       ,  ,     ,    .  — welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3>  Enlaces utiles <br></h3><br><ul><li>      ,      Android GDE   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a>       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong> Medium</strong></a>     «»      Android,   async-   . </li></ul><br><blockquote>  <strong>Noticias</strong> <br><br> 30    Mail.ru   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>      .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ,   ,       ,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">youtube-</a>       AppsConf 2018 —    :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429908/">https://habr.com/ru/post/es429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429892/index.html">xonsh - python como reemplazo de shell</a></li>
<li><a href="../es429894/index.html">Usando un ojo de pez en una Raspberry Pi 3 con ROS - Parte 2</a></li>
<li><a href="../es429898/index.html">DMS (Sistema de gestión de concesionarios): implementación de los ecosistemas de información para la gestión de redes de concesionarios</a></li>
<li><a href="../es429902/index.html">Page Rank en la era de la Web 2.0 - Parte 1</a></li>
<li><a href="../es429904/index.html">Historias divertidas y tristes sobre el desarrollo de juegos de computadora</a></li>
<li><a href="../es429910/index.html">AppsConf Rises</a></li>
<li><a href="../es429912/index.html">Desarrollo de bibliotecas: de API a lanzamiento público</a></li>
<li><a href="../es429914/index.html">OpenSceneGraph: Gráfico de escena y punteros inteligentes</a></li>
<li><a href="../es429916/index.html">Cómo construir y construir</a></li>
<li><a href="../es429918/index.html">Mundo virtual Intel. Parte 2: SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>