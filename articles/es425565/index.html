<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèº üçë üê± Matem√°ticas r√°pidas de punto fijo para aplicaciones financieras en Java üï¥üèø üëΩ üññüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No es ning√∫n secreto que la informaci√≥n financiera (cuentas, contabilizaciones y otra contabilidad) no es muy amigable con los n√∫meros de coma flotant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matem√°ticas r√°pidas de punto fijo para aplicaciones financieras en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425565/"><p>  No es ning√∫n secreto que la informaci√≥n financiera (cuentas, contabilizaciones y otra contabilidad) no es muy amigable con los n√∫meros de coma flotante, y muchos art√≠culos recomiendan usar una aritm√©tica de punto fijo.  En Java, este formato est√°, de hecho, representado solo por la clase BigDecimal, que no siempre se puede usar por razones de rendimiento.  Tenemos que buscar alternativas.  Este art√≠culo describe una biblioteca Java autoescrita para realizar operaciones aritm√©ticas en n√∫meros de precisi√≥n fija.  La biblioteca fue creada para trabajar en aplicaciones financieras de alto rendimiento y le permite trabajar con una precisi√≥n de 9 decimales manteniendo un rendimiento aceptable.  Se proporciona un enlace a las fuentes y los puntos de referencia al final del art√≠culo. </p><a name="habracut"></a><br><h1 id="arifmetika-s-plavayuschey-tochkoy">  Aritm√©tica de punto flotante </h1><br><p>  Las computadoras modernas pueden realizar operaciones aritm√©ticas solo con precisi√≥n limitada.  Estos son dispositivos discretos que pueden no funcionar con todos los n√∫meros posibles, pero solo con algunos subconjuntos contables de ellos.  El formato m√°s com√∫n para trabajar con n√∫meros reales en la memoria de la computadora es un punto flotante (binario): un punto flotante (binario), cuando los n√∫meros se almacenan en la forma M * 2 ^ E, donde M y E son mantisa entera y el orden del n√∫mero.  Pero algunos n√∫meros, como 0.1, no se pueden representar con precisi√≥n en este formato.  Por lo tanto, en el curso de c√°lculos complejos, inevitablemente se acumula alg√∫n error.  Es decir, el resultado del c√°lculo de la m√°quina, digamos 0.1 + 0.1 + 0.1, no coincide con el matem√°ticamente correcto 0.3.  Dado lo anterior, al programar aritm√©tica compleja, puede seguir varias estrategias: </p><br><p>  Estrategia 1 - ignorar.  No preste atenci√≥n al error, considere todas las operaciones como matem√°ticas ideales y espere que la precisi√≥n disponible sea suficiente para obtener resultados aceptables.  La opci√≥n m√°s com√∫n. </p><br><p>  Estrategia 2: calcular meticulosamente.  Las f√≥rmulas para calcular errores de m√°quina se conocen desde hace d√©cadas.  Permiten estimar desde arriba el error relativo de cualquier operaci√≥n aritm√©tica.  Probablemente, esto es lo que tienes que hacer para una simulaci√≥n num√©rica seria.  El problema es que lleva mucho tiempo.  De hecho, cada car√°cter + - * / en el c√≥digo debe ir acompa√±ado de un c√°lculo de error.  Debe tener en cuenta todas las dependencias entre los c√°lculos y repetir el procedimiento cada vez que cambie el c√≥digo. </p><br><p>  Estrategia 3: use un punto decimal (punto decimal flotante) en lugar de binario.  Es decir, almacene los n√∫meros en la forma M * 10 ^ E.  Esto no resuelve los problemas de error (la mantisa todav√≠a se redondea a un n√∫mero finito de d√≠gitos significativos), pero al menos todos los n√∫meros "simples" para una persona (como 1.1) ahora est√°n representados con precisi√≥n en la memoria.  La recuperaci√≥n de la inversi√≥n ser√° el rendimiento.  Cualquier normalizaci√≥n de n√∫meros (es decir, una disminuci√≥n equivalente en la mantisa y un aumento en el orden) requiere una divisi√≥n por una potencia de 10, que no es muy r√°pida, a diferencia de una divisi√≥n por una potencia de 2. Y tiene que normalizar mucho, con cada suma o resta con diferentes √≥rdenes. </p><br><p>  Estrategia 4: use un punto fijo (punto decimal fijo).  Simplificaci√≥n de la estrategia 3, cuando fijamos el orden E. En este caso, la normalizaci√≥n no es necesaria para la suma / resta.  Adem√°s, todos los c√°lculos tendr√°n el mismo error absoluto.  Este art√≠culo est√° dedicado a esta estrategia. </p><br><h1 id="arifmetika-s-fiksirovannoy-tochkoy">  Aritm√©tica de punto fijo </h1><br><p>  A diferencia de la f√≠sica, donde el error relativo es importante, solo se necesita absoluto en las finanzas.  Si, despu√©s de una transacci√≥n financiera compleja, el cliente recibe una factura de $ 1,000,000.23 mientras espera $ 1,000,000,18, entonces pueden surgir algunas dificultades.  Explicaciones como "¬øpor qu√© necesita precisi√≥n en 8 d√≠gitos significativos?"  No puede montar.  Y el punto aqu√≠ no est√° en 5 centavos de p√©rdida (errar por el contrario, "a favor" del cliente no es mucho mejor), sino en inconsistencias en la contabilidad.  Por lo tanto, las reglas de c√°lculo y redondeo est√°n claramente especificadas entre las partes, y los artefactos del uso de variables dobles y flotantes a veces complican la vida. </p><br><p>  Java tiene una clase est√°ndar para aritm√©tica de punto fijo: BigDecimal.  Hay dos problemas con √©l: es lento (debido a su universalidad) y no es estable.  La no estabilidad significa que cualquier operaci√≥n asigna un objeto en el mont√≥n.  Seleccionar y liberar en t√©rminos de un objeto lleva un poco de tiempo, pero los c√°lculos intensivos en el c√≥digo "activo" crean una carga decente en el GC, que en algunos casos es inaceptable.  Puede confiar en el an√°lisis de escape y la escalarizaci√≥n, pero son muy inestables en el sentido de que incluso un ligero cambio en el c√≥digo o en el JIT (como la carga diferida de una nueva implementaci√≥n de interfaz) puede voltear toda la estructura en l√≠nea, y el m√©todo funcion√≥ bien hace un minuto, De repente comienza a asignar furiosamente la memoria. <br>  UPD debido a preguntas en los comentarios: <strong>La raz√≥n principal para</strong> abandonar BigDecimal y BigInteger no es el bajo rendimiento de los c√°lculos, sino la falta de estabilidad y la selecci√≥n de objetos. </p><br><p>  La biblioteca descrita es el resultado de estar cansado de reescribir la aritm√©tica sin memoria de punto fijo desde cero para cada nuevo empleador, y decid√≠ escribir mi propia biblioteca para su posterior contrataci√≥n. </p><br><p>  Enseguida mostrar√© un ejemplo de uso antes de pasar a los detalles de implementaci√≥n: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Decimal margin; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity contraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumContraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price priceWithMargin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price avgPrice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> marginBp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 + margin / 10000 this.margin = Decimal.create(marginBp).divRD(10000L).add(1); } public Price calculateAvgPrice(Quantity[] quantities, Price[] prices) { cumQuantity.set(0); contraQuantity.set(0); // avg = sum(q * p * margin) / sum(q) for (int i = 0; i &lt; quantities.length; i++) { cumQuantity.add(quantities[i]); priceWithMargin.set(prices[i]).mulRD(margin); contraQuantity.set(quantities[i]).mulRD(priceWithMargin); cumContraQuantity.add(contraQuantity); } return avgPrice.quotientRD(cumContraQuantity, cumQuantity); } public static void main(String[] args) throws ParseException { Price p1 = Price.create("1.5"); Price p2 = Price.create(1.6); Quantity q1 = Quantity.create("100"); Quantity q2 = Quantity.create(200); // apply 0.05% margin to the prices Sample sample = new Sample(5); System.out.println(sample.calculateAvgPrice(new Quantity[]{q1, q2}, new Price[]{p1, p2})); } }</span></span></code> </pre> <br><h1 id="ideya-realizacii">  Idea de implementaci√≥n </h1><br><p>  Por lo tanto, necesitamos una envoltura mutable de un primitivo entero, m√°s precisamente, un long'a, que nos dar√° casi 19 d√≠gitos significativos (suficiente para el entero y la parte fraccional).  En el largo, nos referimos a N decimales.  Por ejemplo, con N = 2, el n√∫mero 2.56 se almacena como 256 (binario 100000000).  Los n√∫meros negativos se almacenan como est√°ndar, en c√≥digo adicional: </p><br><p>  <em>-2,56</em> <br>  <strong>-256</strong> </p><br><p>  (En adelante, las <em>cursivas</em> indican n√∫meros y c√°lculos "matem√°ticos" y <strong>en negrita</strong> su representaci√≥n interna) </p><br><p>  Tambi√©n me pareci√≥ √∫til ingresar NaN como un valor separado, que se devuelve en caso de errores aritm√©ticos (en lugar de una excepci√≥n o basura).  <em>NaN</em> se representa internamente como <strong>Long.MIN_VALUE</strong> , "propagado" a trav√©s de todas las operaciones y permite determinar la inversi√≥n de signos para todos los n√∫meros restantes. </p><br><p>  Intentemos estimar los algoritmos de las operaciones aritm√©ticas para el caso cuando N = 2. </p><br><p>  La suma y la resta no requieren gestos adicionales, solo use los valores como son: </p><br><p>  <em>1.20 + 2.30 = 3.50</em> <br>  <strong>120 + 230 = 350</strong> </p><br><p>  La multiplicaci√≥n y la divisi√≥n requieren una normalizaci√≥n adicional, es decir, multiplicaci√≥n / divisi√≥n por 10 ^ N (por 100 en nuestro ejemplo) </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  <em>1.20 / 2.00 = 0.60</em> <br>  <strong>100 * 120/200 = 60</strong> </p><br><p>  La divisi√≥n adicional no es la operaci√≥n m√°s r√°pida.  Pero en este caso, esta es una divisi√≥n por una constante, porque previamente arreglamos N = 2 y 10 ^ N = 100.  La divisi√≥n por constante, especialmente por "hermosa" (tipo 10), se optimiza intensamente en la CPU y mucho m√°s r√°pido que la divisi√≥n por un n√∫mero aleatorio.  Hacemos muchas divisiones por 10 cada vez que convertimos cualquier n√∫mero en una cadena (por ejemplo, en los registros), y los fabricantes de CPU lo saben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para obtener m√°s detalles sobre la optimizaci√≥n,</a> consulte "Divisi√≥n por una constante"). </p><br><p>  Para consolidar la comprensi√≥n de lo que estamos haciendo, dar√© una operaci√≥n m√°s: inversi√≥n unaria de un n√∫mero, es decir, 1 / x.  Este es un caso especial de divisi√≥n, solo necesita enviar 1.00 en nuestro formato y no olvide normalizar: </p><br><p>  <em>1.00 / 2.00 = 0.50</em> <br>  <strong>100 * 100/200 = 50</strong> </p><br><p>  Bueno, si bien todo es bastante simple, tratemos de profundizar en los detalles. </p><br><h1 id="okruglenie">  Redondeo </h1><br><p>  Intentemos dibujar otro n√∫mero: </p><br><p>  <em>1.00 / 3.00 = 0.33</em> <br>  <strong>100 * 100/300 = 33</strong> </p><br><p>  Un resultado matem√°tico honesto se encuentra entre 0,33 y 0,34, pero no podemos imaginarlo exactamente.  ¬øQu√© forma de redondear?  Generalmente redondeado a 0, y esta es la forma m√°s r√°pida (compatible con hardware).  Pero, volviendo a los problemas financieros reales, este no es siempre el caso.  Normalmente, cuando se procesan transacciones con un cliente, el redondeo es "a favor del cliente".  Es decir, el precio se redondea hacia arriba si el cliente est√° vendiendo y hacia abajo si el cliente est√° comprando.  Pero se pueden requerir otras opciones, por ejemplo, redondeo aritm√©tico al n√∫mero m√°s cercano con subtipos (mitad arriba, mitad abajo, mitad par) para minimizar las inconsistencias contables.  O redondeando a ¬± infinito para precios negativos (para algunos instrumentos financieros).  Java BigDecimal ya contiene una lista de modos de redondeo est√°ndar, y la biblioteca descrita los admite a todos.  UNNECESSARY devuelve NaN si la operaci√≥n inesperadamente requiere redondeo. </p><br><p>  En el modo redondeado, nuestro c√°lculo debe dar: </p><br><p>  <em>1.00 / 3.00 = 0.34</em> <br>  <strong>100 * 100/300 + 1 = 34</strong> </p><br><p>  ¬øC√≥mo saber qu√© necesitas para agregar una unidad?  Necesita el resto de la divisi√≥n 10,000% 300 = 100. Que es tan lento como la divisi√≥n misma.  Afortunadamente, si escribe en una fila en el c√≥digo "a / b; a% b", entonces JIT se dar√° cuenta de que no se necesitan 2 divisiones, solo un comando div de ensamblador que devuelve 2 n√∫meros (cociente y resto). </p><br><p>  Otras opciones de redondeo son un poco m√°s complicadas, pero tambi√©n se pueden calcular en funci√≥n del resto y el divisor. </p><br><p>  En la API, hice una menci√≥n intencional de redondeo donde sea que ocurra, ya sea como un par√°metro o como un sufijo propio de <strong>R</strong> ound <strong>D</strong> en los m√©todos donde el valor predeterminado es cero. </p><br><h1 id="perepolnenie">  Desbordamiento </h1><br><p>  Llegamos a la parte m√°s dif√≠cil.  Recordemos nuevamente nuestra multiplicaci√≥n: </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  Ahora imagine que estamos en la d√©cada de 1980 y tenemos procesadores de 16 bits.  Es decir, solo el corto est√° disponible para nosotros con un valor m√°ximo de 65535. La primera multiplicaci√≥n se desbordar√° y ser√° igual a 240000 &amp; 0xFFFF = 44392 (si no est√° firmado, con un signo tambi√©n ser√° negativo), lo que romper√° el resultado para nosotros. </p><br><p>  No funcionar√°  Tenemos 2 argumentos normales (ajustados a nuestro rango de valores) y el mismo resultado normal esperado, pero nos desbordamos a la mitad.  La misma situaci√≥n es posible con una longitud de 64 bits, solo los n√∫meros necesitan m√°s. </p><br><p>  En la d√©cada de 1980, necesitar√≠amos una multiplicaci√≥n que d√© un resultado de 32 bits.  Hoy necesitamos una multiplicaci√≥n con un resultado de 128 bits.  Lo m√°s molesto es que ambas multiplicaciones est√°n disponibles en ensambladores 8086 y x86-64, respectivamente, ¬°pero no podemos usarlos desde Java!  JNI, incluso en el caso de un hack con JavaCritical r√°pido, proporciona una sobrecarga de decenas de nanosegundos, introduce dificultades con la implementaci√≥n y la compatibilidad, congela el GC durante la duraci√≥n de la llamada.  Adem√°s, de alguna manera tendr√≠amos que devolver un resultado de 128 bits del m√©todo nativo, y escribir por referencia a una matriz (en la memoria) es un retraso adicional. </p><br><p>  En general, tuve que escribir multiplicaci√≥n y divisi√≥n manual.  Columna  Necesitaba 2 operaciones auxiliares: </p><br><ol><li>  A (64) * B (64) = T (128);  T (128) / N (32) = Q (64), R (32) - como parte del punto fijo de multiplicaci√≥n A * B </li><li>  N (32) * A (64) = T (96);  T (96) / B (64) = Q (64), R (64) - como parte de la divisi√≥n de punto fijo A / B <br>  (entre par√©ntesis indica la dimensi√≥n de los datos en bits, T es una variable temporal que no debe desbordarse) </li></ol><br><p>  Ambas operaciones devuelven el cociente y el resto (uno como resultado del m√©todo, el segundo en el campo del objeto).  Tambi√©n pueden desbordarse, pero solo en el √∫ltimo paso, cuando esto es inevitable.  Aqu√≠ hay un ejemplo (de la d√©cada de 1980): </p><br><p>  <em>500.00 / 0.50 = 1000.00</em> <br>  <strong>100 * 50,000 / 50 = 100,000</strong> - ¬°desbordamiento! </p><br><p>  La divisi√≥n de columnas a la Knut no es el algoritmo m√°s f√°cil.  Adem√°s, tambi√©n deber√≠a ser relativamente r√°pido.  Por lo tanto, el c√≥digo de ambas operaciones es cientos de l√≠neas de magia de bits bastante severa, me llevar√° mucho tiempo recordar nuevamente qu√© est√° sucediendo exactamente all√≠.  Los met√≠ en una clase separada y coment√© en detalle como pude. </p><br><p>  El algoritmo de multiplicaci√≥n no se limita a invocar la operaci√≥n 1, sino que el c√≥digo restante no es tan complicado y solo agrega soporte para n√∫meros negativos, redondeo y NaN. </p><br><p>  Por lo general (excepto en casos especiales), ambas operaciones contienen 4 multiplicaciones y 2 divisiones.  La operaci√≥n 1 es significativamente m√°s r√°pida que la 2, ya que en ella estas divisiones son constantes. </p><br><p>  Por cierto, si alguien se dio cuenta, N (32) es nuestro 10 ^ N para la normalizaci√≥n.  Es de 32 bits, de lo que se deduce que N puede ser un m√°ximo de 9. En las aplicaciones reales que vi, se utilizaron 2, 4 u 8 decimales.  No he visto m√°s de 9, as√≠ que deber√≠a ser suficiente.  Si crea 10 ^ N de 64 bits, el c√≥digo se vuelve m√°s complicado (y se ralentiza) a√∫n m√°s. </p><br><h1 id="neskolko-raznyh-tochnostey">  Varios precisi√≥n diferente </h1><br><p>  A veces es necesario realizar una operaci√≥n en argumentos con un n√∫mero diferente de lugares decimales.  Como m√≠nimo, ingrese operaciones que involucren el largo habitual. </p><br><p>  Por ejemplo: </p><br><p>  <em>2.0000 (N = 4) + 3.00 (N = 2) = 5.0000 (N = 4)</em> <br>  <strong>20,000 + 300 * 100 = 50,000</strong> </p><br><p>  <em>3.00 (N = 2) + 2.0000 (N = 4) = 5.00 (N = 2)</em> <br>  <strong>300 + 20,000 / 100 = 500</strong> </p><br><p>  En este caso, se requiere una normalizaci√≥n adicional de uno de los argumentos.  Tenga en cuenta que matem√°ticamente ambas operaciones son equivalentes, pero debido a la precisi√≥n diferente del resultado, se calculan de manera diferente.  Tambi√©n vale la pena se√±alar que la segunda operaci√≥n generalmente requiere redondeo. </p><br><p>  El n√∫mero de lugares decimales NO se almacena en el objeto.  En cambio, se supone una subclase separada para cada precisi√≥n.  Los nombres de clase pueden estar orientados a los negocios, por ejemplo Precio (N = 8), Cantidad (N = 2).  Y se pueden generalizar: Decimal1, Decimal2, Decimal3, ... Cuanto mayor es la precisi√≥n, menor es el rango de valores almacenados, el rango m√≠nimo tiene Decimal9: ¬± 9223372036.  Se supone que una o dos clases ser√°n suficientes para cubrir la funcionalidad necesaria, en cuyo caso el m√©todo getScale abstracto probablemente se desvirtualizar√° y estar√° en l√≠nea.  Las subclases (en lugar de un campo adicional) le permiten tipificar estrictamente la precisi√≥n de los argumentos y el resultado, as√≠ como indicar una posible redondeo en la etapa de compilaci√≥n. </p><br><p>  La biblioteca permite operaciones con un m√°ximo de 2 (pero no 3) de precisi√≥n diferente.  Es decir, la precisi√≥n de los dos argumentos debe coincidir o la precisi√≥n de uno de los argumentos y el resultado.  Una vez m√°s, admitir 3 precisi√≥n diferente ralentizar√≠a enormemente el c√≥digo y complicar√≠a la API.  Como argumentos, puede pasar un largo regular, para el cual se supone una precisi√≥n de N = 0. </p><br><p>  <em>2.0000 / 3.0 = 0.6667</em> - ok (2 precisi√≥n diferente) <br>  <em>2/3 = 0.6667</em> - ok (argumentos largos, resultado decimal) <br>  <em>2 / 3.0 = 0.6667</em> - ¬°imposible!  (3 precisi√≥n diferente) </p><br><h1 id="dostoinstva-i-nedostatki">  Ventajas y desventajas. </h1><br><p>  Obviamente, la inform√°tica de alto bit realizada por la biblioteca es m√°s lenta que la soportada por hardware.  Sin embargo, la sobrecarga no es tan grande (ver puntos de referencia a continuaci√≥n). </p><br><p>  Adem√°s, debido a la falta de sobrecarga de operadores en Java, el uso de m√©todos en lugar de operadores aritm√©ticos complica la percepci√≥n del c√≥digo. </p><br><p>  En base a esto, la biblioteca generalmente se usa en lugares donde la p√©rdida de precisi√≥n absoluta es cr√≠tica.  Por ejemplo, calcular estad√≠sticas financieras precisas, teniendo en cuenta los indicadores financieros actuales (posiciones de negociaci√≥n, PnL, √≥rdenes ejecutadas).  En el intercambio de red de informaci√≥n financiera entre sistemas, tambi√©n es m√°s conveniente utilizar formatos con un punto decimal (en lugar de binario). </p><br><p>  Los algoritmos matem√°ticos complejos (modelado, estad√≠stica, pron√≥stico) son generalmente m√°s f√°ciles de llevar a cabo de manera est√°ndar en doble, ya que su resultado en cualquier caso no es absolutamente exacto. </p><br><h1 id="kod-i-benchmarki">  C√≥digo y puntos de referencia </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo</a> </p><br><table><tbody><tr><th>  Punto de referencia </th><th>  El modo </th><th>  Cnt </th><th>  Puntuaci√≥n </th><th>  Error </th><th>  Unidades <br></th></tr><tr><td>  DecimalBenchmark.control </td><td>  promedio </td><td>  200 </td><td>  10.072 </td><td>  ¬± 0.074 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyNative </td><td>  promedio </td><td>  200 </td><td>  10,625 </td><td>  ¬± 0.142 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyMyDecimal </td><td>  promedio </td><td>  200 </td><td>  35,840 </td><td>  ¬± 0,121 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyBigDecimal </td><td>  promedio </td><td>  200 </td><td>  126,098 </td><td>  ¬± 0,408 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientNative </td><td>  promedio </td><td>  200 </td><td>  70,728 </td><td>  ¬± 0.230 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientMyDecimal </td><td>  promedio </td><td>  200 </td><td>  138.581 </td><td>  ¬± 7.102 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientBigDecimal </td><td>  promedio </td><td>  200 </td><td>  179,650 </td><td>  ¬± 0.849 </td><td>  ns / op <br></td></tr></tbody></table><br><p>  En general, la multiplicaci√≥n es 4 veces m√°s r√°pida que BigDecimal, la divisi√≥n es 1.5.  La tasa de divisi√≥n depende en <em>gran</em> medida de los argumentos, de ah√≠ la dispersi√≥n de los valores. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425565/">https://habr.com/ru/post/es425565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425555/index.html">Charles Nutter sobre lenguajes din√°micos en la JVM en jug.msk.ru</a></li>
<li><a href="../es425557/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 10: Ejecuci√≥n simb√≥lica, parte 1</a></li>
<li><a href="../es425559/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 10: Ejecuci√≥n simb√≥lica, parte 3</a></li>
<li><a href="../es425561/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 10: Ejecuci√≥n simb√≥lica, parte 2</a></li>
<li><a href="../es425563/index.html">California proh√≠be la venta de dispositivos IoT con o sin contrase√±as simples</a></li>
<li><a href="../es425569/index.html">Pruebas funcionales de PCB</a></li>
<li><a href="../es425571/index.html">Asegurar un servidor web en Linux</a></li>
<li><a href="../es425575/index.html">Neuroinflamaci√≥n</a></li>
<li><a href="../es425581/index.html">Jetpack 11 de octubre de 1961: el presidente abre la boca ...</a></li>
<li><a href="../es425583/index.html">Todo lo que todav√≠a desconcierta a los robomobiles, comenzando con las gaviotas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>