<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱞游낖 游꼠 游냠 Matem치ticas r치pidas de punto fijo para aplicaciones financieras en Java 游돖游 游놓 游둤游낗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No es ning칰n secreto que la informaci칩n financiera (cuentas, contabilizaciones y otra contabilidad) no es muy amigable con los n칰meros de coma flotant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matem치ticas r치pidas de punto fijo para aplicaciones financieras en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425565/"><p>  No es ning칰n secreto que la informaci칩n financiera (cuentas, contabilizaciones y otra contabilidad) no es muy amigable con los n칰meros de coma flotante, y muchos art칤culos recomiendan usar una aritm칠tica de punto fijo.  En Java, este formato est치, de hecho, representado solo por la clase BigDecimal, que no siempre se puede usar por razones de rendimiento.  Tenemos que buscar alternativas.  Este art칤culo describe una biblioteca Java autoescrita para realizar operaciones aritm칠ticas en n칰meros de precisi칩n fija.  La biblioteca fue creada para trabajar en aplicaciones financieras de alto rendimiento y le permite trabajar con una precisi칩n de 9 decimales manteniendo un rendimiento aceptable.  Se proporciona un enlace a las fuentes y los puntos de referencia al final del art칤culo. </p><a name="habracut"></a><br><h1 id="arifmetika-s-plavayuschey-tochkoy">  Aritm칠tica de punto flotante </h1><br><p>  Las computadoras modernas pueden realizar operaciones aritm칠ticas solo con precisi칩n limitada.  Estos son dispositivos discretos que pueden no funcionar con todos los n칰meros posibles, pero solo con algunos subconjuntos contables de ellos.  El formato m치s com칰n para trabajar con n칰meros reales en la memoria de la computadora es un punto flotante (binario): un punto flotante (binario), cuando los n칰meros se almacenan en la forma M * 2 ^ E, donde M y E son mantisa entera y el orden del n칰mero.  Pero algunos n칰meros, como 0.1, no se pueden representar con precisi칩n en este formato.  Por lo tanto, en el curso de c치lculos complejos, inevitablemente se acumula alg칰n error.  Es decir, el resultado del c치lculo de la m치quina, digamos 0.1 + 0.1 + 0.1, no coincide con el matem치ticamente correcto 0.3.  Dado lo anterior, al programar aritm칠tica compleja, puede seguir varias estrategias: </p><br><p>  Estrategia 1 - ignorar.  No preste atenci칩n al error, considere todas las operaciones como matem치ticas ideales y espere que la precisi칩n disponible sea suficiente para obtener resultados aceptables.  La opci칩n m치s com칰n. </p><br><p>  Estrategia 2: calcular meticulosamente.  Las f칩rmulas para calcular errores de m치quina se conocen desde hace d칠cadas.  Permiten estimar desde arriba el error relativo de cualquier operaci칩n aritm칠tica.  Probablemente, esto es lo que tienes que hacer para una simulaci칩n num칠rica seria.  El problema es que lleva mucho tiempo.  De hecho, cada car치cter + - * / en el c칩digo debe ir acompa침ado de un c치lculo de error.  Debe tener en cuenta todas las dependencias entre los c치lculos y repetir el procedimiento cada vez que cambie el c칩digo. </p><br><p>  Estrategia 3: use un punto decimal (punto decimal flotante) en lugar de binario.  Es decir, almacene los n칰meros en la forma M * 10 ^ E.  Esto no resuelve los problemas de error (la mantisa todav칤a se redondea a un n칰mero finito de d칤gitos significativos), pero al menos todos los n칰meros "simples" para una persona (como 1.1) ahora est치n representados con precisi칩n en la memoria.  La recuperaci칩n de la inversi칩n ser치 el rendimiento.  Cualquier normalizaci칩n de n칰meros (es decir, una disminuci칩n equivalente en la mantisa y un aumento en el orden) requiere una divisi칩n por una potencia de 10, que no es muy r치pida, a diferencia de una divisi칩n por una potencia de 2. Y tiene que normalizar mucho, con cada suma o resta con diferentes 칩rdenes. </p><br><p>  Estrategia 4: use un punto fijo (punto decimal fijo).  Simplificaci칩n de la estrategia 3, cuando fijamos el orden E. En este caso, la normalizaci칩n no es necesaria para la suma / resta.  Adem치s, todos los c치lculos tendr치n el mismo error absoluto.  Este art칤culo est치 dedicado a esta estrategia. </p><br><h1 id="arifmetika-s-fiksirovannoy-tochkoy">  Aritm칠tica de punto fijo </h1><br><p>  A diferencia de la f칤sica, donde el error relativo es importante, solo se necesita absoluto en las finanzas.  Si, despu칠s de una transacci칩n financiera compleja, el cliente recibe una factura de $ 1,000,000.23 mientras espera $ 1,000,000,18, entonces pueden surgir algunas dificultades.  Explicaciones como "쯣or qu칠 necesita precisi칩n en 8 d칤gitos significativos?"  No puede montar.  Y el punto aqu칤 no est치 en 5 centavos de p칠rdida (errar por el contrario, "a favor" del cliente no es mucho mejor), sino en inconsistencias en la contabilidad.  Por lo tanto, las reglas de c치lculo y redondeo est치n claramente especificadas entre las partes, y los artefactos del uso de variables dobles y flotantes a veces complican la vida. </p><br><p>  Java tiene una clase est치ndar para aritm칠tica de punto fijo: BigDecimal.  Hay dos problemas con 칠l: es lento (debido a su universalidad) y no es estable.  La no estabilidad significa que cualquier operaci칩n asigna un objeto en el mont칩n.  Seleccionar y liberar en t칠rminos de un objeto lleva un poco de tiempo, pero los c치lculos intensivos en el c칩digo "activo" crean una carga decente en el GC, que en algunos casos es inaceptable.  Puede confiar en el an치lisis de escape y la escalarizaci칩n, pero son muy inestables en el sentido de que incluso un ligero cambio en el c칩digo o en el JIT (como la carga diferida de una nueva implementaci칩n de interfaz) puede voltear toda la estructura en l칤nea, y el m칠todo funcion칩 bien hace un minuto, De repente comienza a asignar furiosamente la memoria. <br>  UPD debido a preguntas en los comentarios: <strong>La raz칩n principal para</strong> abandonar BigDecimal y BigInteger no es el bajo rendimiento de los c치lculos, sino la falta de estabilidad y la selecci칩n de objetos. </p><br><p>  La biblioteca descrita es el resultado de estar cansado de reescribir la aritm칠tica sin memoria de punto fijo desde cero para cada nuevo empleador, y decid칤 escribir mi propia biblioteca para su posterior contrataci칩n. </p><br><p>  Enseguida mostrar칠 un ejemplo de uso antes de pasar a los detalles de implementaci칩n: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Decimal margin; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity contraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Quantity cumContraQuantity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Quantity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price priceWithMargin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Price avgPrice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Price(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> marginBp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 + margin / 10000 this.margin = Decimal.create(marginBp).divRD(10000L).add(1); } public Price calculateAvgPrice(Quantity[] quantities, Price[] prices) { cumQuantity.set(0); contraQuantity.set(0); // avg = sum(q * p * margin) / sum(q) for (int i = 0; i &lt; quantities.length; i++) { cumQuantity.add(quantities[i]); priceWithMargin.set(prices[i]).mulRD(margin); contraQuantity.set(quantities[i]).mulRD(priceWithMargin); cumContraQuantity.add(contraQuantity); } return avgPrice.quotientRD(cumContraQuantity, cumQuantity); } public static void main(String[] args) throws ParseException { Price p1 = Price.create("1.5"); Price p2 = Price.create(1.6); Quantity q1 = Quantity.create("100"); Quantity q2 = Quantity.create(200); // apply 0.05% margin to the prices Sample sample = new Sample(5); System.out.println(sample.calculateAvgPrice(new Quantity[]{q1, q2}, new Price[]{p1, p2})); } }</span></span></code> </pre> <br><h1 id="ideya-realizacii">  Idea de implementaci칩n </h1><br><p>  Por lo tanto, necesitamos una envoltura mutable de un primitivo entero, m치s precisamente, un long'a, que nos dar치 casi 19 d칤gitos significativos (suficiente para el entero y la parte fraccional).  En el largo, nos referimos a N decimales.  Por ejemplo, con N = 2, el n칰mero 2.56 se almacena como 256 (binario 100000000).  Los n칰meros negativos se almacenan como est치ndar, en c칩digo adicional: </p><br><p>  <em>-2,56</em> <br>  <strong>-256</strong> </p><br><p>  (En adelante, las <em>cursivas</em> indican n칰meros y c치lculos "matem치ticos" y <strong>en negrita</strong> su representaci칩n interna) </p><br><p>  Tambi칠n me pareci칩 칰til ingresar NaN como un valor separado, que se devuelve en caso de errores aritm칠ticos (en lugar de una excepci칩n o basura).  <em>NaN</em> se representa internamente como <strong>Long.MIN_VALUE</strong> , "propagado" a trav칠s de todas las operaciones y permite determinar la inversi칩n de signos para todos los n칰meros restantes. </p><br><p>  Intentemos estimar los algoritmos de las operaciones aritm칠ticas para el caso cuando N = 2. </p><br><p>  La suma y la resta no requieren gestos adicionales, solo use los valores como son: </p><br><p>  <em>1.20 + 2.30 = 3.50</em> <br>  <strong>120 + 230 = 350</strong> </p><br><p>  La multiplicaci칩n y la divisi칩n requieren una normalizaci칩n adicional, es decir, multiplicaci칩n / divisi칩n por 10 ^ N (por 100 en nuestro ejemplo) </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  <em>1.20 / 2.00 = 0.60</em> <br>  <strong>100 * 120/200 = 60</strong> </p><br><p>  La divisi칩n adicional no es la operaci칩n m치s r치pida.  Pero en este caso, esta es una divisi칩n por una constante, porque previamente arreglamos N = 2 y 10 ^ N = 100.  La divisi칩n por constante, especialmente por "hermosa" (tipo 10), se optimiza intensamente en la CPU y mucho m치s r치pido que la divisi칩n por un n칰mero aleatorio.  Hacemos muchas divisiones por 10 cada vez que convertimos cualquier n칰mero en una cadena (por ejemplo, en los registros), y los fabricantes de CPU lo saben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para obtener m치s detalles sobre la optimizaci칩n,</a> consulte "Divisi칩n por una constante"). </p><br><p>  Para consolidar la comprensi칩n de lo que estamos haciendo, dar칠 una operaci칩n m치s: inversi칩n unaria de un n칰mero, es decir, 1 / x.  Este es un caso especial de divisi칩n, solo necesita enviar 1.00 en nuestro formato y no olvide normalizar: </p><br><p>  <em>1.00 / 2.00 = 0.50</em> <br>  <strong>100 * 100/200 = 50</strong> </p><br><p>  Bueno, si bien todo es bastante simple, tratemos de profundizar en los detalles. </p><br><h1 id="okruglenie">  Redondeo </h1><br><p>  Intentemos dibujar otro n칰mero: </p><br><p>  <em>1.00 / 3.00 = 0.33</em> <br>  <strong>100 * 100/300 = 33</strong> </p><br><p>  Un resultado matem치tico honesto se encuentra entre 0,33 y 0,34, pero no podemos imaginarlo exactamente.  쯈u칠 forma de redondear?  Generalmente redondeado a 0, y esta es la forma m치s r치pida (compatible con hardware).  Pero, volviendo a los problemas financieros reales, este no es siempre el caso.  Normalmente, cuando se procesan transacciones con un cliente, el redondeo es "a favor del cliente".  Es decir, el precio se redondea hacia arriba si el cliente est치 vendiendo y hacia abajo si el cliente est치 comprando.  Pero se pueden requerir otras opciones, por ejemplo, redondeo aritm칠tico al n칰mero m치s cercano con subtipos (mitad arriba, mitad abajo, mitad par) para minimizar las inconsistencias contables.  O redondeando a 췀 infinito para precios negativos (para algunos instrumentos financieros).  Java BigDecimal ya contiene una lista de modos de redondeo est치ndar, y la biblioteca descrita los admite a todos.  UNNECESSARY devuelve NaN si la operaci칩n inesperadamente requiere redondeo. </p><br><p>  En el modo redondeado, nuestro c치lculo debe dar: </p><br><p>  <em>1.00 / 3.00 = 0.34</em> <br>  <strong>100 * 100/300 + 1 = 34</strong> </p><br><p>  쮺칩mo saber qu칠 necesitas para agregar una unidad?  Necesita el resto de la divisi칩n 10,000% 300 = 100. Que es tan lento como la divisi칩n misma.  Afortunadamente, si escribe en una fila en el c칩digo "a / b; a% b", entonces JIT se dar치 cuenta de que no se necesitan 2 divisiones, solo un comando div de ensamblador que devuelve 2 n칰meros (cociente y resto). </p><br><p>  Otras opciones de redondeo son un poco m치s complicadas, pero tambi칠n se pueden calcular en funci칩n del resto y el divisor. </p><br><p>  En la API, hice una menci칩n intencional de redondeo donde sea que ocurra, ya sea como un par치metro o como un sufijo propio de <strong>R</strong> ound <strong>D</strong> en los m칠todos donde el valor predeterminado es cero. </p><br><h1 id="perepolnenie">  Desbordamiento </h1><br><p>  Llegamos a la parte m치s dif칤cil.  Recordemos nuevamente nuestra multiplicaci칩n: </p><br><p>  <em>1.20 * 2.00 = 2.40</em> <br>  <strong>120 * 200/100 = 240</strong> </p><br><p>  Ahora imagine que estamos en la d칠cada de 1980 y tenemos procesadores de 16 bits.  Es decir, solo el corto est치 disponible para nosotros con un valor m치ximo de 65535. La primera multiplicaci칩n se desbordar치 y ser치 igual a 240000 &amp; 0xFFFF = 44392 (si no est치 firmado, con un signo tambi칠n ser치 negativo), lo que romper치 el resultado para nosotros. </p><br><p>  No funcionar치  Tenemos 2 argumentos normales (ajustados a nuestro rango de valores) y el mismo resultado normal esperado, pero nos desbordamos a la mitad.  La misma situaci칩n es posible con una longitud de 64 bits, solo los n칰meros necesitan m치s. </p><br><p>  En la d칠cada de 1980, necesitar칤amos una multiplicaci칩n que d칠 un resultado de 32 bits.  Hoy necesitamos una multiplicaci칩n con un resultado de 128 bits.  Lo m치s molesto es que ambas multiplicaciones est치n disponibles en ensambladores 8086 y x86-64, respectivamente, 춰pero no podemos usarlos desde Java!  JNI, incluso en el caso de un hack con JavaCritical r치pido, proporciona una sobrecarga de decenas de nanosegundos, introduce dificultades con la implementaci칩n y la compatibilidad, congela el GC durante la duraci칩n de la llamada.  Adem치s, de alguna manera tendr칤amos que devolver un resultado de 128 bits del m칠todo nativo, y escribir por referencia a una matriz (en la memoria) es un retraso adicional. </p><br><p>  En general, tuve que escribir multiplicaci칩n y divisi칩n manual.  Columna  Necesitaba 2 operaciones auxiliares: </p><br><ol><li>  A (64) * B (64) = T (128);  T (128) / N (32) = Q (64), R (32) - como parte del punto fijo de multiplicaci칩n A * B </li><li>  N (32) * A (64) = T (96);  T (96) / B (64) = Q (64), R (64) - como parte de la divisi칩n de punto fijo A / B <br>  (entre par칠ntesis indica la dimensi칩n de los datos en bits, T es una variable temporal que no debe desbordarse) </li></ol><br><p>  Ambas operaciones devuelven el cociente y el resto (uno como resultado del m칠todo, el segundo en el campo del objeto).  Tambi칠n pueden desbordarse, pero solo en el 칰ltimo paso, cuando esto es inevitable.  Aqu칤 hay un ejemplo (de la d칠cada de 1980): </p><br><p>  <em>500.00 / 0.50 = 1000.00</em> <br>  <strong>100 * 50,000 / 50 = 100,000</strong> - 춰desbordamiento! </p><br><p>  La divisi칩n de columnas a la Knut no es el algoritmo m치s f치cil.  Adem치s, tambi칠n deber칤a ser relativamente r치pido.  Por lo tanto, el c칩digo de ambas operaciones es cientos de l칤neas de magia de bits bastante severa, me llevar치 mucho tiempo recordar nuevamente qu칠 est치 sucediendo exactamente all칤.  Los met칤 en una clase separada y coment칠 en detalle como pude. </p><br><p>  El algoritmo de multiplicaci칩n no se limita a invocar la operaci칩n 1, sino que el c칩digo restante no es tan complicado y solo agrega soporte para n칰meros negativos, redondeo y NaN. </p><br><p>  Por lo general (excepto en casos especiales), ambas operaciones contienen 4 multiplicaciones y 2 divisiones.  La operaci칩n 1 es significativamente m치s r치pida que la 2, ya que en ella estas divisiones son constantes. </p><br><p>  Por cierto, si alguien se dio cuenta, N (32) es nuestro 10 ^ N para la normalizaci칩n.  Es de 32 bits, de lo que se deduce que N puede ser un m치ximo de 9. En las aplicaciones reales que vi, se utilizaron 2, 4 u 8 decimales.  No he visto m치s de 9, as칤 que deber칤a ser suficiente.  Si crea 10 ^ N de 64 bits, el c칩digo se vuelve m치s complicado (y se ralentiza) a칰n m치s. </p><br><h1 id="neskolko-raznyh-tochnostey">  Varios precisi칩n diferente </h1><br><p>  A veces es necesario realizar una operaci칩n en argumentos con un n칰mero diferente de lugares decimales.  Como m칤nimo, ingrese operaciones que involucren el largo habitual. </p><br><p>  Por ejemplo: </p><br><p>  <em>2.0000 (N = 4) + 3.00 (N = 2) = 5.0000 (N = 4)</em> <br>  <strong>20,000 + 300 * 100 = 50,000</strong> </p><br><p>  <em>3.00 (N = 2) + 2.0000 (N = 4) = 5.00 (N = 2)</em> <br>  <strong>300 + 20,000 / 100 = 500</strong> </p><br><p>  En este caso, se requiere una normalizaci칩n adicional de uno de los argumentos.  Tenga en cuenta que matem치ticamente ambas operaciones son equivalentes, pero debido a la precisi칩n diferente del resultado, se calculan de manera diferente.  Tambi칠n vale la pena se침alar que la segunda operaci칩n generalmente requiere redondeo. </p><br><p>  El n칰mero de lugares decimales NO se almacena en el objeto.  En cambio, se supone una subclase separada para cada precisi칩n.  Los nombres de clase pueden estar orientados a los negocios, por ejemplo Precio (N = 8), Cantidad (N = 2).  Y se pueden generalizar: Decimal1, Decimal2, Decimal3, ... Cuanto mayor es la precisi칩n, menor es el rango de valores almacenados, el rango m칤nimo tiene Decimal9: 췀 9223372036.  Se supone que una o dos clases ser치n suficientes para cubrir la funcionalidad necesaria, en cuyo caso el m칠todo getScale abstracto probablemente se desvirtualizar치 y estar치 en l칤nea.  Las subclases (en lugar de un campo adicional) le permiten tipificar estrictamente la precisi칩n de los argumentos y el resultado, as칤 como indicar una posible redondeo en la etapa de compilaci칩n. </p><br><p>  La biblioteca permite operaciones con un m치ximo de 2 (pero no 3) de precisi칩n diferente.  Es decir, la precisi칩n de los dos argumentos debe coincidir o la precisi칩n de uno de los argumentos y el resultado.  Una vez m치s, admitir 3 precisi칩n diferente ralentizar칤a enormemente el c칩digo y complicar칤a la API.  Como argumentos, puede pasar un largo regular, para el cual se supone una precisi칩n de N = 0. </p><br><p>  <em>2.0000 / 3.0 = 0.6667</em> - ok (2 precisi칩n diferente) <br>  <em>2/3 = 0.6667</em> - ok (argumentos largos, resultado decimal) <br>  <em>2 / 3.0 = 0.6667</em> - 춰imposible!  (3 precisi칩n diferente) </p><br><h1 id="dostoinstva-i-nedostatki">  Ventajas y desventajas. </h1><br><p>  Obviamente, la inform치tica de alto bit realizada por la biblioteca es m치s lenta que la soportada por hardware.  Sin embargo, la sobrecarga no es tan grande (ver puntos de referencia a continuaci칩n). </p><br><p>  Adem치s, debido a la falta de sobrecarga de operadores en Java, el uso de m칠todos en lugar de operadores aritm칠ticos complica la percepci칩n del c칩digo. </p><br><p>  En base a esto, la biblioteca generalmente se usa en lugares donde la p칠rdida de precisi칩n absoluta es cr칤tica.  Por ejemplo, calcular estad칤sticas financieras precisas, teniendo en cuenta los indicadores financieros actuales (posiciones de negociaci칩n, PnL, 칩rdenes ejecutadas).  En el intercambio de red de informaci칩n financiera entre sistemas, tambi칠n es m치s conveniente utilizar formatos con un punto decimal (en lugar de binario). </p><br><p>  Los algoritmos matem치ticos complejos (modelado, estad칤stica, pron칩stico) son generalmente m치s f치ciles de llevar a cabo de manera est치ndar en doble, ya que su resultado en cualquier caso no es absolutamente exacto. </p><br><h1 id="kod-i-benchmarki">  C칩digo y puntos de referencia </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C칩digo</a> </p><br><table><tbody><tr><th>  Punto de referencia </th><th>  El modo </th><th>  Cnt </th><th>  Puntuaci칩n </th><th>  Error </th><th>  Unidades <br></th></tr><tr><td>  DecimalBenchmark.control </td><td>  promedio </td><td>  200 </td><td>  10.072 </td><td>  췀 0.074 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyNative </td><td>  promedio </td><td>  200 </td><td>  10,625 </td><td>  췀 0.142 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyMyDecimal </td><td>  promedio </td><td>  200 </td><td>  35,840 </td><td>  췀 0,121 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.multiplyBigDecimal </td><td>  promedio </td><td>  200 </td><td>  126,098 </td><td>  췀 0,408 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientNative </td><td>  promedio </td><td>  200 </td><td>  70,728 </td><td>  췀 0.230 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientMyDecimal </td><td>  promedio </td><td>  200 </td><td>  138.581 </td><td>  췀 7.102 </td><td>  ns / op <br></td></tr><tr><td>  DecimalBenchmark.quotientBigDecimal </td><td>  promedio </td><td>  200 </td><td>  179,650 </td><td>  췀 0.849 </td><td>  ns / op <br></td></tr></tbody></table><br><p>  En general, la multiplicaci칩n es 4 veces m치s r치pida que BigDecimal, la divisi칩n es 1.5.  La tasa de divisi칩n depende en <em>gran</em> medida de los argumentos, de ah칤 la dispersi칩n de los valores. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425565/">https://habr.com/ru/post/es425565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425555/index.html">Charles Nutter sobre lenguajes din치micos en la JVM en jug.msk.ru</a></li>
<li><a href="../es425557/index.html">Curso MIT "Seguridad de sistemas inform치ticos". Lecci칩n 10: Ejecuci칩n simb칩lica, parte 1</a></li>
<li><a href="../es425559/index.html">Curso MIT "Seguridad de sistemas inform치ticos". Lecci칩n 10: Ejecuci칩n simb칩lica, parte 3</a></li>
<li><a href="../es425561/index.html">Curso MIT "Seguridad de sistemas inform치ticos". Lecci칩n 10: Ejecuci칩n simb칩lica, parte 2</a></li>
<li><a href="../es425563/index.html">California proh칤be la venta de dispositivos IoT con o sin contrase침as simples</a></li>
<li><a href="../es425569/index.html">Pruebas funcionales de PCB</a></li>
<li><a href="../es425571/index.html">Asegurar un servidor web en Linux</a></li>
<li><a href="../es425575/index.html">Neuroinflamaci칩n</a></li>
<li><a href="../es425581/index.html">Jetpack 11 de octubre de 1961: el presidente abre la boca ...</a></li>
<li><a href="../es425583/index.html">Todo lo que todav칤a desconcierta a los robomobiles, comenzando con las gaviotas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>