<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓 🌠 🌨️ Caching Handler Peristiwa dan Reaksi Peningkatan Kinerja Aplikasi 🛬 🎯 🌊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan terjemahan materi, yang penulisnya, setelah menganalisis fitur bekerja dengan objek dalam JavaScript, menawarkan pengembang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caching Handler Peristiwa dan Reaksi Peningkatan Kinerja Aplikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426053/">  Hari ini kami menerbitkan terjemahan materi, yang penulisnya, setelah menganalisis fitur bekerja dengan objek dalam JavaScript, menawarkan pengembang Bereaksi metodologi untuk mempercepat aplikasi.  Secara khusus, kita berbicara tentang fakta bahwa variabel, yang, seperti yang mereka katakan, "ditugaskan objek", dan yang sering disebut hanya "objek", pada kenyataannya, tidak menyimpan objek itu sendiri, tetapi tautan ke sana.  Fungsi dalam JavaScript juga objek, jadi hal di atas berlaku untuk mereka.  Dengan mengingat hal ini, merancang komponen Bereaksi dan menganalisis secara kritis kode mereka dapat meningkatkan mekanisme internal dan meningkatkan kinerja aplikasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54f/6b5/80a/54f6b580affe2d9741da8207f93b4746.png"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fitur bekerja dengan objek dalam JavaScript</font> </h2><br>  Jika Anda membuat beberapa fungsi yang terlihat persis sama dan mencoba membandingkannya, ternyata mereka, dari sudut pandang sistem, berbeda.  Untuk memverifikasi ini, Anda dapat menjalankan kode berikut: <br><br><pre><code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionOne = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionTwo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; functionOne === functionTwo; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Sekarang mari kita coba untuk menetapkan variabel ke fungsi yang sudah ada yang ditugaskan ke variabel lain, dan membandingkan dua variabel ini: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionThree = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionFour = functionThree; functionThree === functionFour; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Seperti yang Anda lihat, dengan pendekatan ini, operator kesetaraan yang ketat mengembalikan <code>true</code> . <br>  Objek secara alami berperilaku dengan cara yang sama: <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object1 === object2; // <span class="hljs-literal"><span class="hljs-literal">false</span></span> object1 === object3; // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Di sini kita berbicara tentang JavaScript, tetapi jika Anda memiliki pengalaman mengembangkan dalam bahasa lain, maka Anda mungkin akrab dengan konsep pointer.  Dalam kode di atas, setiap kali sebuah objek dibuat, sebagian dari memori sistem dialokasikan untuk itu.  Ketika kita menggunakan perintah form <code>object1 = {}</code> , ini mengarah ke mengisi dengan beberapa data sepotong memori yang dialokasikan khusus untuk <code>object1</code> . <br><br>  Sangat mungkin untuk membayangkan <code>object1</code> sebagai alamat di mana struktur data yang terkait dengan objek berada di memori.  Eksekusi perintah <code>object2 = {}</code> mengarah ke alokasi area memori lain, yang dirancang khusus untuk <code>object2</code> .  Apakah <code>obect1</code> dan <code>object2</code> di area memori yang sama?  Tidak, masing-masing memiliki plot sendiri.  Itulah sebabnya ketika kita mencoba membandingkan <code>object1</code> dan <code>object2</code> kita mendapatkan <code>false</code> .  Objek-objek ini mungkin memiliki struktur yang identik, tetapi alamat dalam memori tempat mereka berada berbeda, dan itu adalah alamat yang diperiksa selama perbandingan. <br><br>  Dengan mengeksekusi perintah <code>object3 = object1</code> , kita menulis alamat <code>object1</code> ke dalam <code>object1</code> konstan.  Ini bukan objek baru.  Konstanta ini diberikan alamat objek yang ada.  Anda dapat memverifikasi ini dengan: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { x: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object3.x = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; object1.x; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Dalam contoh ini, sebuah objek dibuat dalam memori dan alamatnya ditulis ke objek <code>object1</code> .  Kemudian alamat yang sama ditulis ke objek <code>object3</code> .  Mengubah <code>object3</code> mengubah objek dalam memori.  Ini berarti bahwa ketika mengakses objek menggunakan referensi lain untuk itu, misalnya, yang disimpan di <code>object1</code> , kita sudah akan bekerja dengan versi yang dimodifikasi. <br><br><h2>  <font color="#3AC1EF">Fungsi, Objek, dan Bereaksi</font> </h2><br>  Kesalahpahaman tentang mekanisme di atas oleh pengembang pemula sering menyebabkan kesalahan, dan, mungkin, pertimbangan fitur bekerja dengan objek layak untuk artikel yang terpisah.  Namun, topik kita hari ini adalah kinerja aplikasi Bereaksi.  Di bidang ini, kesalahan dapat dilakukan bahkan oleh pengembang yang cukup berpengalaman yang tidak memperhatikan bagaimana Bereaksi aplikasi dipengaruhi oleh fakta bahwa variabel JavaScript dan konstanta tidak disimpan dalam objek itu sendiri, tetapi hanya tautan ke mereka. <br><br>  Apa hubungannya ini dengan Bereaksi?  Bereaksi memiliki mekanisme cerdas untuk menghemat sumber daya sistem yang ditujukan untuk meningkatkan kinerja aplikasi: jika properti dan keadaan komponen tidak berubah, maka apa fungsi <code>render</code> tidak berubah.  Jelas, jika komponennya tetap sama, tidak perlu dirender lagi.  Jika tidak ada yang berubah, fungsi <code>render</code> akan kembali sama seperti sebelumnya, jadi tidak perlu untuk menjalankannya.  Mekanisme ini membuat Bereaksi cepat.  Sesuatu ditampilkan hanya jika perlu. <br><br>  React memeriksa properti dan status komponen untuk kesetaraan menggunakan fitur JavaScript standar, yaitu, ia hanya membandingkannya menggunakan operator <code>==</code> .  Bereaksi tidak melakukan perbandingan objek yang "dangkal" atau "dalam" untuk menentukan kesetaraannya.  "Perbandingan dangkal" adalah konsep yang digunakan untuk menggambarkan perbandingan dari setiap pasangan kunci-nilai suatu objek, yang bertentangan dengan perbandingan di mana hanya alamat objek dalam memori yang dibandingkan (referensi untuk mereka).  Perbandingan "dalam" objek bahkan lebih jauh, dan jika nilai-nilai properti yang dibandingkan dari objek juga objek, mereka juga membandingkan pasangan kunci-nilai dari objek-objek ini.  Proses ini diulangi untuk semua objek yang bersarang di objek lain.  Bereaksi tidak melakukan hal semacam itu, hanya memeriksa kesetaraan tautan. <br><br>  Jika, misalnya, Anda mengubah properti komponen yang diwakili oleh objek bentuk <code>{ x: 1 }</code> ke objek lain yang terlihat persis sama, Bereaksi akan merender ulang komponen, karena objek ini berada di area memori yang berbeda.  Jika Anda mengingat contoh di atas, maka, ketika mengubah properti komponen dari <code>object1</code> ke <code>object1</code> , Bereaksi tidak akan merender ulang komponen seperti itu, karena konstanta <code>object1</code> dan <code>object1</code> merujuk ke objek yang sama. <br><br>  Bekerja dengan fungsi-fungsi dalam JavaScript diatur dengan cara yang persis sama.  Jika Bereaksi bertemu dengan fitur yang sama yang alamatnya berbeda, itu akan merender ulang.  Jika "fungsi baru" hanyalah tautan ke fungsi yang telah digunakan, tidak akan ada rendering ulang. <br><br><h2>  <font color="#3AC1EF">Masalah khas saat bekerja dengan komponen</font> </h2><br>  Berikut adalah salah satu skenario bekerja dengan komponen, yang, sayangnya, terus menerus muncul ketika saya memeriksa kode orang lain: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert('!')} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Di depan kita adalah komponen yang sangat sederhana.  Ini adalah tombol, ketika diklik, pemberitahuan ditampilkan.  Di sebelah tombol ditampilkan instruksi untuk penggunaannya, memberi tahu pengguna apakah ia harus menekan tombol ini.  Kontrol instruksi mana yang akan ditampilkan dengan mengatur properti <code>do</code> ( <code>do={true}</code> atau <code>do={false}</code> ) <code>SomeComponent</code> . <br><br>  Setiap kali komponen <code>SomeComponent</code> -render ulang (ketika nilai properti <code>do</code> diubah dari <code>true</code> menjadi <code>false</code> dan sebaliknya), elemen <code>Button</code> juga dirender.  Handler <code>onClick</code> , meskipun selalu sama, dibuat kembali setiap kali fungsi <code>render</code> dipanggil.  Akibatnya, ternyata setiap kali komponen ditampilkan dalam memori, fungsi baru dibuat, karena pembuatannya dilakukan dalam fungsi <code>render</code> , tautan ke alamat baru di memori diteruskan ke <code>&lt;Button /&gt;</code> , dan komponen <code>Button</code> juga dirender lagi, meskipun faktanya dalam tidak ada yang berubah sama sekali. <br><br>  Mari kita bicara tentang cara memperbaikinya. <br><br><h2>  <font color="#3AC1EF">Pemecahan masalah</font> </h2><br>  Jika fungsi tidak tergantung pada komponen (konteks <code>this</code> ), maka Anda dapat mendefinisikannya di luar komponen.  Semua instance komponen akan menggunakan referensi fungsi yang sama, karena dalam semua kasus itu akan menjadi fungsi yang sama.  Begini tampilannya: <br><br><pre> <code class="hljs scala">const createAlertBox = () =&gt; alert('!'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Berbeda dengan contoh sebelumnya, <code>createAlertBox</code> , dengan setiap panggilan untuk <code>createAlertBox</code> , akan berisi tautan yang sama ke area yang sama dalam memori.  Akibatnya, output berulang <code>Button</code> tidak akan dieksekusi. <br><br>  Sementara komponen <code>Button</code> kecil dan cepat ditampilkan, masalah yang dijelaskan di atas terkait dengan deklarasi fungsi internal juga dapat ditemukan dalam komponen besar dan kompleks yang membutuhkan banyak waktu untuk merendernya.  Ini secara signifikan dapat memperlambat aplikasi Bereaksi.  Dalam hal ini, masuk akal untuk mengikuti rekomendasi, yang dengannya fungsi-fungsi tersebut tidak boleh dideklarasikan di dalam metode <code>render</code> . <br><br>  Jika fungsi tergantung pada komponen, yaitu, itu tidak dapat didefinisikan di luar itu, metode komponen dapat diteruskan sebagai pengendali peristiwa: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ createAlertBox = () =&gt; {   alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); }; get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Dalam hal ini, dalam setiap instance <code>SomeComponent</code> ketika Anda mengklik tombol, berbagai pesan akan ditampilkan.  Penangan event elemen <code>Button</code> harus unik untuk <code>SomeComponent</code> .  Saat melewati metode <code>cteateAlertBox</code> , tidak masalah jika <code>SomeComponent</code> -render ulang.  Tidak masalah jika properti <code>message</code> telah berubah.  Alamat fungsi <code>createAlertBox</code> tidak berubah, yang berarti bahwa elemen <code>Button</code> tidak boleh dirender lagi.  Berkat ini, Anda dapat menghemat sumber daya sistem dan meningkatkan kecepatan rendering aplikasi. <br><br>  Semua ini bagus.  Tetapi bagaimana jika fungsinya dinamis? <br><br><h2>  <font color="#3AC1EF">Memecahkan Masalah yang Lebih Kompleks</font> </h2><br>  <i>Penulis materi ini meminta Anda untuk memperhatikan fakta bahwa ia menyiapkan contoh-contoh di bagian ini, mengambil hal pertama yang muncul di benaknya, cocok untuk menggambarkan penggunaan kembali fungsi.</i>  <i>Contoh-contoh ini dimaksudkan untuk membantu pembaca memahami esensi gagasan.</i>  <i>Meskipun bagian ini direkomendasikan untuk membaca untuk memahami esensi dari apa yang terjadi, penulis menyarankan untuk memperhatikan komentar pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel asli</a> , karena beberapa pembaca telah menyarankan versi yang lebih baik dari mekanisme yang dibahas di sini, yang mempertimbangkan fitur-fitur pembatalan cache dan mekanisme manajemen memori yang dibangun dalam React.</i> <br><br>  Jadi, sangat umum bahwa dalam satu komponen ada banyak penangan acara yang unik dan dinamis, misalnya, sesuatu yang serupa dapat dilihat dalam kode, di mana metode array <code>map</code> digunakan dalam metode <code>render</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;ul&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</code> </pre> <br>  Di sini, sejumlah tombol yang berbeda akan ditampilkan dan sejumlah penangan acara yang berbeda akan dibuat, masing-masing diwakili oleh fungsi unik, dan, sebelumnya, ketika membuat <code>SomeComponent</code> , tidak diketahui apa fungsi-fungsi ini.  Bagaimana cara memecahkan teka-teki ini? <br><br>  Di sini memoisasi akan membantu kami, atau, lebih sederhana, caching.  Untuk setiap nilai unik, buat fungsi dan masukkan ke dalam cache.  Jika nilai unik ini terjadi lagi, itu akan cukup untuk mengambil dari cache fungsi yang sesuai dengannya, yang sebelumnya ditempatkan dalam cache. <br><br>  Beginilah implementasi dari ide ini: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    SomeComponent        //   . clickHandlers = {}; //       //    . getClickHandler(key) {   //       ,  .   if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) {     this.clickHandlers[key] = () =&gt; alert(key);   }   return this.clickHandlers[key]; } render() {   return (     &lt;ul&gt;       {this.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;Button onClick={this.getClickHandler(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</span></span></code> </pre> <br>  Setiap elemen array diproses oleh metode <code>getClickHandler</code> .  Metode ini, pertama kali dipanggil dengan nilai tertentu, akan membuat fungsi yang unik untuk nilai ini, memasukkannya ke dalam cache dan mengembalikannya.  Semua panggilan selanjutnya ke metode ini, dengan memberikan nilai yang sama dengannya, akan menyebabkannya mengembalikan tautan ke fungsi dari cache. <br><br>  Akibatnya, rendering ulang <code>SomeComponent</code> tidak akan merender kembali <code>Button</code> .  Demikian pula, menambahkan elemen ke properti <code>list</code> akan secara dinamis membuat pengendali acara untuk setiap tombol. <br><br>  Anda harus kreatif dalam membuat pengidentifikasi unik untuk penangan jika mereka didefinisikan oleh lebih dari satu variabel, tetapi ini tidak jauh lebih rumit daripada pembuatan properti <code>key</code> unik untuk setiap objek JSX yang diperoleh sebagai hasil dari metode <code>map</code> . <br><br>  Di sini saya ingin memperingatkan Anda tentang kemungkinan masalah menggunakan indeks array sebagai pengidentifikasi.  Faktanya adalah bahwa dengan pendekatan ini, Anda dapat menemukan kesalahan jika urutan elemen dalam array berubah atau beberapa elemennya dihapus.  Jadi, misalnya, jika pada awalnya array serupa tampak seperti <code>[ 'soda', 'pizza' ]</code> , dan kemudian berubah menjadi <code>[ 'pizza' ]</code> , dan Anda membuat cache event handler menggunakan perintah dari <code>listeners[0] = () =&gt; alert('soda')</code> form <code>listeners[0] = () =&gt; alert('soda')</code> , Anda akan menemukan bahwa ketika pengguna mengklik tombol di mana penangan dengan pengenal 0 ditugaskan dan yang, sesuai dengan isi array <code>[ 'pizza' ]</code> , harus menampilkan pesan <code>pizza</code> , pesan <code>soda</code> akan ditampilkan.  Untuk alasan yang sama, tidak disarankan untuk menggunakan indeks array sebagai properti utama. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kami memeriksa fitur mekanisme JavaScript internal, dengan mempertimbangkan mana Anda dapat mempercepat rendering aplikasi Bereaksi.  Kami berharap ide-ide yang disajikan di sini berguna. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda mengetahui cara menarik untuk mengoptimalkan Bereaksi aplikasi, silakan bagikan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426053/">https://habr.com/ru/post/id426053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426039/index.html">Peluncuran darurat "Soyuz MS-10" (kru diselamatkan, disiarkan)</a></li>
<li><a href="../id426041/index.html">Solusi simbolik dari persamaan diferensial linear dan sistem dengan metode transformasi Laplace menggunakan SymPy</a></li>
<li><a href="../id426045/index.html">Pengecualian khusus dalam .NET dan cara menyiapkannya</a></li>
<li><a href="../id426047/index.html">10 buku bagus untuk pemula dalam bahasa Inggris</a></li>
<li><a href="../id426051/index.html">Meningkatkan keterampilan debugging perangkat lunak - beberapa tips</a></li>
<li><a href="../id426055/index.html">TensorFlow.js dan clmtrackr.js: melacak arah pandangan pengguna di browser</a></li>
<li><a href="../id426059/index.html">Tutu PHP Meetup # 2: Pidato Video</a></li>
<li><a href="../id426061/index.html">Microsoft Bergabung dengan Jaringan Penemuan Terbuka dan Memberikan 60.000 Lisensi</a></li>
<li><a href="../id426063/index.html">Inovasi entry-level array HPE MSA: flash array yang lebih terjangkau dan integrasi solusi yang kaya</a></li>
<li><a href="../id426065/index.html">Smart TV, yang dengan sendirinya menentukan saluran yang paling menarik, atau solusi Sudoku yang tidak biasa untuk konten video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>