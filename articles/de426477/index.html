<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏽 👨‍🌾 ◼️ Die ganze Wahrheit über RTOS. Artikel Nr. 15. Speicherpartitionen: Dienste und Datenstrukturen 💱 🗳️ 🙅🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel überprüfen wir weiterhin die Speicherabschnitte des RTOS. 

 Nucleus RTOS verfügt über drei API-Aufrufe, die Dienstprogrammfunktione...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel Nr. 15. Speicherpartitionen: Dienste und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426477/"><img src="https://habrastorage.org/webt/3t/wd/au/3twdaubgcbrqlkg0al5lttnqs-y.jpeg"><br><br>  In diesem Artikel überprüfen wir weiterhin die Speicherabschnitte des RTOS. <br><br>  Nucleus RTOS verfügt über drei API-Aufrufe, die Dienstprogrammfunktionen für Speicherpartitionspools bereitstellen: Rückgabe von Informationen zu Partitionspools, Rückgabe der Anzahl der Partitionspools in einer Anwendung und Rückgabe von Zeigern auf alle Partitionspools in einer Anwendung.  Die ersten beiden Herausforderungen werden in Nucleus SE implementiert. <br><a name="habracut"></a><br>  Frühere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Abrufen von Partitionspoolinformationen </h2><br>  Dieser Serviceabruf enthält teilweise Informationen zum Partitionspool.  Die Implementierung von Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zurückgegeben werden, da die Benennung von Objekten und Pausenanforderungen nicht unterstützt werden und die Aufgabe nicht angehalten werden kann. <br><br><h3>  Aufrufen von Partitionspoolinformationen in Nucleus RTOS </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Partition_Pool_Information (NU_PARTITION_POOL * Pool, CHAR * Name, VOID ** Startadresse, UNSIGNED * Poolgröße, UNSIGNED * Partitionsgröße, UNSIGNED * verfügbar, UNSIGNED * zugewiesen, OPTION * Suspend_Type, UNSIGNED * Aufgaben zuerst;</b> <br><br>  Parameter: <br><br>  <b>pool</b> - ein Zeiger auf den Partitionspool, über den Informationen angefordert werden; <br>  <b>name</b> - Zeiger auf den 8-stelligen Zielbereich für den Namen des Partitionspools;  enthält einen Platz zum Beenden von Null; <br>  <b>start_address</b> - ein Zeiger auf eine Variable, die einen Zeiger auf den Anfang des Datenbereichs des Partitionspools empfängt; <br>  <b>pool_size</b> - ein Zeiger auf eine Variable, die die Größe des Partitionspools (in Bytes) empfängt; <br>  <b>partition_size</b> - Zeiger auf eine Variable, die die Größe von Partitionen in einem bestimmten Pool erhält; <br>  <b>verfügbar</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verfügbaren Partitionen in diesem Pool empfängt; <br>  <b>zugewiesen</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verwendeten Partitionen in einem bestimmten Pool empfängt; <br>  <b>suspend_type</b> - Zeiger auf eine Variable, um den Typ der Task-Suspendierung <b>abzurufen</b> ;  gültige Fahrwerkstypen: <b>NU_FIFO</b> und <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in einem bestimmten Partitionspool empfängt; <br>  <b>first_task</b> - Zeiger auf den Aufgabenzeiger, in dem sich der Zeiger der ersten angehaltenen Aufgabe befindet. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Aufruf erfolgreich abgeschlossen; <br>  <b>NU_INVALID_POOL</b> - ungültiger Zeiger auf Partitionspool. <br><br><h3>  Aufrufen von Partitionspoolinformationen in Nucleus SE </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NUSE_Partition_Pool_Information (NUSE_PARTITION_POOL-Pool, ADDR * Startadresse, U32 * Poolgröße, U16 * Partitionsgröße, U8 * verfügbar, U8 * zugewiesen, U8 * Aufgaben warten, NUSE_TASK * erste Aufgabe)</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - Der Index des Partitionspools, über den Informationen angefordert werden. <br>  <b>start_address</b> - ein Zeiger auf eine Variable, die einen Zeiger auf den Anfang des Datenbereichs des Partitionspools empfängt; <br>  <b>pool_size</b> - ein Zeiger auf eine Variable, die die Größe des Partitionspools (in Bytes) empfängt; <br>  <b>partition_size</b> - Zeiger auf eine Variable, die die Größe von Partitionen in einem bestimmten Pool erhält; <br>  <b>verfügbar</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verfügbaren Partitionen in diesem Pool empfängt; <br>  <b>zugewiesen</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verwendeten Partitionen in einem bestimmten Pool empfängt; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in diesem Partitionspool empfängt (wenn die Aufgabe angehalten ist, wird 0 zurückgegeben); <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK</b> , die den Index der ersten angehaltenen Aufgabe empfängt (wenn die Aufgabe angehalten ist, wird 0 zurückgegeben). <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Aufruf erfolgreich abgeschlossen; <br>  <b>NUSE_INVALID_POOL</b> - ungültiger Partitionspoolindex; <br>  <b>NUSE_INVALID_POINTER</b> - Einer oder mehrere der übergebenen Zeiger sind ungültig. <br><br><h3>  Implementieren von Information Retrieval und Partition Pooling in Nucleus SE </h3><br>  Die Implementierung eines solchen API-Aufrufs ist einfach auszuführen: <br><br><img src="https://habrastorage.org/webt/ia/82/sj/ia82sj807l4yuaio-mvf-ypjivm.jpeg"><br><br>  Die Funktion gibt den Status des Partitionspools zurück.  Wenn dann die API-Aufrufblockierung aktiviert ist, werden die Anzahl der ausstehenden Aufgaben und der Index der ersten zurückgegeben (andernfalls werden diese Parameter auf 0 gesetzt). <br><br><h2>  Abrufen der Anzahl der Partitionspools </h2><br>  Dieser Aufruf gibt Informationen über die Anzahl der in der Anwendung konfigurierten Partitionspools zurück.  Während sich in Nucleus RTOS diese Anzahl im Laufe der Zeit ändert und der Rückgabewert die aktuelle Anzahl von Pools darstellt, wird in Nucleus SE der Rückgabewert während der Montage festgelegt und bleibt unverändert. <br><br><h3>  Die Herausforderung, die Anzahl der Partitionspools in Nucleus RTOS zu ermitteln </h3><br>  Der Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>UNSIGNED NU_Established_Partition_Pools (VOID);</b> <br><br>  Parameter: <br><br>  Sind abwesend. <br><br>  Rückgabewert: <br><br>  Die Anzahl der in der Anwendung erstellten Partitionspools. <br><br><h3>  Die Herausforderung, die Anzahl der Partitionspools in Nucleus SE zu ermitteln </h3><br>  Dieser Dienstprogrammaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>U8 NUSE_Partition_Pool_Count (void);</b> <br><br>  Parameter: <br><br>  Sind abwesend <br><br>  Rückgabewert: <br><br>  Die Anzahl der in der Anwendung erstellten Partitionspools. <br><br><h3>  Implementierung </h3><br>  Die Implementierung dieses API-Aufrufs ist äußerst einfach: Der Wert <b>#define</b> des Symbols <b>NUSE_PARTITION_POOL_NUMBER</b> wird <b>zurückgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Wie alle anderen Nucleus SE-Objekte verwenden Partitionspools Strukturarrays sowohl im ROM als auch im RAM, deren Anzahl von der Anzahl der in den Einstellungen angegebenen Pools abhängt. <br><br>  Ich empfehle dringend, dass Anwendungscode über API-Funktionen und nicht direkt auf solche Datenstrukturen zugreift.  Dies vermeidet Inkompatibilität mit zukünftigen Versionen von Nucleus SE und unerwünschte Nebenwirkungen und vereinfacht auch die Portierung der Anwendung auf Nucleus RTOS.  Das Folgende ist eine detaillierte Beschreibung der Datenstrukturen, um das Verständnis des Serviceabrufcodes und des Debuggens zu erleichtern. <br><br><h3>  Struktur der im RAM abgelegten Kerneldaten </h3><br>  Diese Datenstrukturen umfassen: <br><br>  <b>NUSE_Partition_Pool_Partition_Used []</b> - ein Array vom Typ <b>U8</b> mit einem Eintrag für jeden konfigurierten Partitionspool, der einen Zähler der aktuell verwendeten Pools enthält; <br>  <b>NUSE_Partition_Pool_Blocking_Count []</b> - Ein Array vom Typ <b>U8,</b> das einen Zähler für blockierte Aufgaben in jedem Partitionspool enthält.  Dieses Array ist vorhanden, wenn das Blockieren des API-Aufrufs möglich ist. <br><br>  Solche Datenstrukturen werden beim Starten von Nucleus SE mit <b>NUSE_Init_ Partition_Pool ()</b> auf <b>Null</b> initialisiert.  Dies ist logisch, da dadurch jede Partition in jedem Pool unbenutzt (frei) wird.  Der folgende Artikel enthält eine vollständige Beschreibung der Startvorgänge in Nucleus SE. <br><br>  Im Folgenden finden Sie Beschreibungen der Datenstrukturen in der Datei <b>nuse_init.c</b> . <br><br><img src="https://habrastorage.org/webt/vi/3x/sx/vi3xsxmbwdzkwgfge9ws_dsvups.jpeg"><br><br><h3>  RAM-Benutzerdaten </h3><br>  Der Benutzer muss einen Bereich im RAM zuweisen, um Daten für jeden Partitionspool zu speichern.  Der Speicherplatz im RAM muss dem Volumen der konfigurierten Partitionen (siehe "Daten im ROM" unten) mit einem zusätzlichen Byte für jede Partition im Pool entsprechen.  Vor jedem Abschnitt des Datenbereichs steht ein Statusbyte. <br><br><h3>  ROM-Daten </h3><br>  Dazu gehören: <br><br>  <b>NUSE_Partition_Pool_Data_Address []</b> - Ein Array vom Typ <b>ADDR</b> mit einem Eintrag für jeden konfigurierten Partitionspool, der die Adresse des Beginns des Datenspeicherbereichs enthält. <br>  <b>NUSE_Partition_Pool_Partition_Number []</b> - ein Array vom Typ <b>U8</b> mit einem Eintrag für jeden konfigurierten Partitionspool, der Informationen zur Anzahl der Partitionen im Pool enthält; <br>  <b>NUSE_Partition_Pool_Partition_Size []</b> - Ein Array vom Typ <b>U16</b> mit einem Eintrag für jeden konfigurierten Partitionspool, der die Größe der Partitionen für die Pools enthält. <br><br>  Solche Datenstrukturen werden in <b>nuse_config.c</b> deklariert und (statisch) <b>initialisiert</b> : <br><br><img src="https://habrastorage.org/webt/zt/67/lq/zt67lqadvkdzmuvazbj0mmlhp8a.jpeg"><br><br><h3>  Daten-Footprint für den Partitionspool </h3><br>  Wie bei allen Kernobjekten in Nucleus SE ist die für Partitionspools erforderliche Speichermenge vorhersehbar. <br><br>  Die ROM-Größe (in Byte) für alle Anwendungspartitionspools kann wie folgt berechnet werden: <br><br>  <b>NUSE_PARTITION_POOL_NUMBER * (Größe von (ADDR) + 2)</b> <br><br>  Die Menge der Kerneldaten im RAM für alle Anwendungspartitionspools, wenn die Blockierung von API-Aufrufen aktiviert ist, beträgt nur 2 Byte pro Partitionspool, und wenn die Blockierung nicht aktiviert ist, dauert es 1 Byte. <br><br>  Die Speichermenge zum Speichern von Benutzerdaten im RAM variiert für jeden Partitionspool, obwohl sie, wie bereits erwähnt, für einen Pool mit dem Index n wie folgt berechnet werden kann: <br><br>  <b>NUSE_Partition_Pool_Partition_Number [n] *</b> <br>  <b>(NUSE_Partition_Pool_Partition_Size [n] + 1)</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Drei API-Aufrufe für in Nucleus RTOS implementierte Partitionspools werden in Nucleus SE nicht unterstützt. <br><br><h3>  Partitionspool erstellen </h3><br>  Dieser API-Aufruf erstellt einen Partitionspool.  Nucleus SE benötigt es nicht, da Aufgaben statisch erstellt werden. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Create_Partition_Pool (NU_PARTITION_POOL * -Pool, CHAR * -Name, VOID * -Startadresse, UNSIGNED-Poolgröße, UNSIGNED-Partitionsgröße, OPTION suspend_type);</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - ein Zeiger auf eine benutzerdefinierte Partitionspool <b>-</b> Steuereinheit;  wird als Handle für den Partitionspool in anderen API-Aufrufen verwendet; <br>  <b>name</b> - ein Zeiger auf den Namen des Partitionspools, eine 7-stellige Zeichenfolge mit einer abschließenden Null; <br>  <b>start_address</b> - <b>Legt</b> die Startadresse für den Speicherbereich des Partitionspools fest. <br>  <b>pool_size</b> - Gesamtmenge des Speichers in Bytes; <br>  <b>partition_size</b> - Die Speichermenge in Byte für jede Partition im Pool.  Darüber hinaus wird jedem Abschnitt eine zusätzliche kleine Speichermenge zugewiesen, die dank der beiden verwendeten Datenzeiger realisiert wird. <br>  <b>suspend_type</b> - legt fest, wie Aufgaben im Partitionspool angehalten werden.  Gültige Parameteroptionen sind <b>NU_FIFO</b> und <b>NU_PRIORITY</b> . <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - zeigt einen erfolgreichen Abschluss des Anrufs an; <br>  <b>NU_INVALID_POOL</b> - <b>Gibt</b> den Nullwert der Partitionspool-Steuereinheit ( <b>NULL</b> ) an. <br>  <b>NU_INVALID_MEMORY</b> - gibt den Nullwert des durch <b>start_ address</b> ( <b>NULL</b> ) definierten <b>Speicherbereichs an</b> ; <br>  <b>NU_INVALID_SIZE</b> - <b>Gibt</b> an, dass die Partitionsgröße entweder 0 oder größer als der für die Partition zugewiesene Speicher ist. <br>  <b>NU_INVALID_SUSPEND</b> - ungültiger <b>suspend_type-</b> Wert. <br><br><h3>  Partitionspool löschen </h3><br>  Dieser API-Aufruf löscht einen zuvor erstellten Partitionspool.  Nucleus SE benötigt es nicht, da Objekte statisch erstellt werden und nicht gelöscht werden können. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Delete_Partition_Pool (NU_PARTITION_POOL * -Pool);</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - Zeiger auf die Partitionspool-Steuereinheit; <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - zeigt einen erfolgreichen Abschluss des Anrufs an; <br>  <b>NU_INVALID_POOL</b> - <b>Gibt</b> einen ungültigen Wert für den Partitionspoolzeiger an. <br><br><h3>  Zeiger für Partitionspools </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Partitionspools im System.  Nucleus SE benötigt dies nicht, da Objekte durch einen Index und nicht durch einen Zeiger identifiziert werden. <br><br>  Prototyp aufrufen: <br><br>  <b>UNSIGNED NU_Partition_Pool_Pointers (NU_PARTITION_POOL ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_PARTITION_POOL</b> ;  Das Array ist mit Zeigern auf konfigurierte Pools im System gefüllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern, die im Array platziert werden können. <br><br>  Rückgabewert: <br><br>  Die Anzahl der im Array platzierten <b>NU_PARTITION_POOL-</b> Zeiger. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Bei der Entwicklung von Nucleus SE bestand eine der Hauptaufgaben darin, ein hohes Maß an Codekompatibilität mit Nucleus RTOS sicherzustellen.  Partitionspools waren keine Ausnahme und werden aus Entwicklersicht ähnlich wie in Nucleus RTOS implementiert.  Einige vorhandene Inkompatibilitätsbereiche sind akzeptabel, obwohl zu berücksichtigen ist, dass der endgültige Code leichter zu verstehen und speichereffizienter ist.  Nucleus RTOS-API-Aufrufe können jedoch fast direkt als Nucleus SE-Aufrufe verwendet werden.  In Zukunft ist ein Artikel mit Informationen zur Verwendung von Nucleus SE durch Benutzer von Nucleus RTOS geplant. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch Datenstrukturen (Steuereinheiten) eines bestimmten Typs beschrieben.  Ein Zeiger auf diesen Steuerblock wird als Bezeichner für den Partitionspool verwendet.  Ich entschied, dass Nucleus SE einen anderen Ansatz für eine effizientere Nutzung des Speichers erfordert.  Alle Kernelobjekte werden durch mehrere Tabellen im RAM und / oder ROM beschrieben.  Die Größe dieser Tabellen wird durch die Anzahl der konfigurierbaren Typen aller Objekte bestimmt.  Die Kennung für ein bestimmtes Objekt ist der Index in diesen Tabellen.  Daher habe ich festgestellt, dass <b>NUSE_PARTITION_POOL</b> <b>U8</b> entspricht. <b>Danach</b> dient eine Variable (kein Zeiger) dieses Typs als Kennung der Aufgabe.  Diese leichte Inkompatibilität lässt sich leicht feststellen, wenn der Code von oder nach Nucleus RTOS portiert wird.  Objektkennungen werden normalerweise unverändert gespeichert und übertragen. <br><br>  Nucleus RTOS unterstützt auch das Benennen von Partitionspools.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Anzahl der Abschnitte und deren Volumen </h3><br>  In Nucleus RTOS wird der Partitionspool basierend auf dem Gesamtvolumen des Pools und dem Volumen der Partitionen (die 2 weitere Zeiger enthalten) konfiguriert.  Diese Parameter sind als UNSIGNED (ca. 32 Bit) definiert.  In Nucleus SE wird der Partitionspool basierend auf der Größe der Partition (für die ein zusätzliches Byte hinzugefügt wurde) und der Gesamtzahl der Partitionen konfiguriert.  Diese Parameter sind als U16 bzw. U8 definiert. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterstützt 7 Aufrufe für die Arbeit mit Partitionspools, von denen 3 nicht in Nucleus SE implementiert sind.  Weitere Einzelheiten zu diesen Herausforderungen und den Gründen für ihren Ausschluss sind oben aufgeführt. <br><br>  Der nächste Artikel befasst sich mit Signalen. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426477/">https://habr.com/ru/post/de426477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426465/index.html">„Wir verändern das Terrain“ - IT geht auf eine große Baustelle</a></li>
<li><a href="../de426469/index.html">Telegramm als Unternehmensstandard</a></li>
<li><a href="../de426471/index.html">Wie Spyware-Daten auslaufen</a></li>
<li><a href="../de426473/index.html">Redux-Architektur. Ja oder Nein?</a></li>
<li><a href="../de426475/index.html">Miya - Assistent vom Smartphone</a></li>
<li><a href="../de426479/index.html">Selbst gemachter Prüfstand für Motherboards</a></li>
<li><a href="../de426481/index.html">Hexagon Maps in Unity: Pfadfinder, Spielertrupps, Animationen</a></li>
<li><a href="../de426483/index.html">Einer, der Tesla überholt. Für profitabler</a></li>
<li><a href="../de426485/index.html">Dritter Qt 5 Test mit PVS-Studio</a></li>
<li><a href="../de426487/index.html">Testen Sie die Automatisierung von Grund auf neu. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>