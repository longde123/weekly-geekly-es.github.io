<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèΩ üë®‚Äçüåæ ‚óºÔ∏è Die ganze Wahrheit √ºber RTOS. Artikel Nr. 15. Speicherpartitionen: Dienste und Datenstrukturen üí± üó≥Ô∏è üôÖüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel √ºberpr√ºfen wir weiterhin die Speicherabschnitte des RTOS. 

 Nucleus RTOS verf√ºgt √ºber drei API-Aufrufe, die Dienstprogrammfunktione...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel Nr. 15. Speicherpartitionen: Dienste und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426477/"><img src="https://habrastorage.org/webt/3t/wd/au/3twdaubgcbrqlkg0al5lttnqs-y.jpeg"><br><br>  In diesem Artikel √ºberpr√ºfen wir weiterhin die Speicherabschnitte des RTOS. <br><br>  Nucleus RTOS verf√ºgt √ºber drei API-Aufrufe, die Dienstprogrammfunktionen f√ºr Speicherpartitionspools bereitstellen: R√ºckgabe von Informationen zu Partitionspools, R√ºckgabe der Anzahl der Partitionspools in einer Anwendung und R√ºckgabe von Zeigern auf alle Partitionspools in einer Anwendung.  Die ersten beiden Herausforderungen werden in Nucleus SE implementiert. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Abrufen von Partitionspoolinformationen </h2><br>  Dieser Serviceabruf enth√§lt teilweise Informationen zum Partitionspool.  Die Implementierung von Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zur√ºckgegeben werden, da die Benennung von Objekten und Pausenanforderungen nicht unterst√ºtzt werden und die Aufgabe nicht angehalten werden kann. <br><br><h3>  Aufrufen von Partitionspoolinformationen in Nucleus RTOS </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Partition_Pool_Information (NU_PARTITION_POOL * Pool, CHAR * Name, VOID ** Startadresse, UNSIGNED * Poolgr√∂√üe, UNSIGNED * Partitionsgr√∂√üe, UNSIGNED * verf√ºgbar, UNSIGNED * zugewiesen, OPTION * Suspend_Type, UNSIGNED * Aufgaben zuerst;</b> <br><br>  Parameter: <br><br>  <b>pool</b> - ein Zeiger auf den Partitionspool, √ºber den Informationen angefordert werden; <br>  <b>name</b> - Zeiger auf den 8-stelligen Zielbereich f√ºr den Namen des Partitionspools;  enth√§lt einen Platz zum Beenden von Null; <br>  <b>start_address</b> - ein Zeiger auf eine Variable, die einen Zeiger auf den Anfang des Datenbereichs des Partitionspools empf√§ngt; <br>  <b>pool_size</b> - ein Zeiger auf eine Variable, die die Gr√∂√üe des Partitionspools (in Bytes) empf√§ngt; <br>  <b>partition_size</b> - Zeiger auf eine Variable, die die Gr√∂√üe von Partitionen in einem bestimmten Pool erh√§lt; <br>  <b>verf√ºgbar</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verf√ºgbaren Partitionen in diesem Pool empf√§ngt; <br>  <b>zugewiesen</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verwendeten Partitionen in einem bestimmten Pool empf√§ngt; <br>  <b>suspend_type</b> - Zeiger auf eine Variable, um den Typ der Task-Suspendierung <b>abzurufen</b> ;  g√ºltige Fahrwerkstypen: <b>NU_FIFO</b> und <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in einem bestimmten Partitionspool empf√§ngt; <br>  <b>first_task</b> - Zeiger auf den Aufgabenzeiger, in dem sich der Zeiger der ersten angehaltenen Aufgabe befindet. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Aufruf erfolgreich abgeschlossen; <br>  <b>NU_INVALID_POOL</b> - ung√ºltiger Zeiger auf Partitionspool. <br><br><h3>  Aufrufen von Partitionspoolinformationen in Nucleus SE </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NUSE_Partition_Pool_Information (NUSE_PARTITION_POOL-Pool, ADDR * Startadresse, U32 * Poolgr√∂√üe, U16 * Partitionsgr√∂√üe, U8 * verf√ºgbar, U8 * zugewiesen, U8 * Aufgaben warten, NUSE_TASK * erste Aufgabe)</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - Der Index des Partitionspools, √ºber den Informationen angefordert werden. <br>  <b>start_address</b> - ein Zeiger auf eine Variable, die einen Zeiger auf den Anfang des Datenbereichs des Partitionspools empf√§ngt; <br>  <b>pool_size</b> - ein Zeiger auf eine Variable, die die Gr√∂√üe des Partitionspools (in Bytes) empf√§ngt; <br>  <b>partition_size</b> - Zeiger auf eine Variable, die die Gr√∂√üe von Partitionen in einem bestimmten Pool erh√§lt; <br>  <b>verf√ºgbar</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verf√ºgbaren Partitionen in diesem Pool empf√§ngt; <br>  <b>zugewiesen</b> - ein Zeiger auf eine Variable, die die Anzahl der aktuell verwendeten Partitionen in einem bestimmten Pool empf√§ngt; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in diesem Partitionspool empf√§ngt (wenn die Aufgabe angehalten ist, wird 0 zur√ºckgegeben); <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK</b> , die den Index der ersten angehaltenen Aufgabe empf√§ngt (wenn die Aufgabe angehalten ist, wird 0 zur√ºckgegeben). <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Aufruf erfolgreich abgeschlossen; <br>  <b>NUSE_INVALID_POOL</b> - ung√ºltiger Partitionspoolindex; <br>  <b>NUSE_INVALID_POINTER</b> - Einer oder mehrere der √ºbergebenen Zeiger sind ung√ºltig. <br><br><h3>  Implementieren von Information Retrieval und Partition Pooling in Nucleus SE </h3><br>  Die Implementierung eines solchen API-Aufrufs ist einfach auszuf√ºhren: <br><br><img src="https://habrastorage.org/webt/ia/82/sj/ia82sj807l4yuaio-mvf-ypjivm.jpeg"><br><br>  Die Funktion gibt den Status des Partitionspools zur√ºck.  Wenn dann die API-Aufrufblockierung aktiviert ist, werden die Anzahl der ausstehenden Aufgaben und der Index der ersten zur√ºckgegeben (andernfalls werden diese Parameter auf 0 gesetzt). <br><br><h2>  Abrufen der Anzahl der Partitionspools </h2><br>  Dieser Aufruf gibt Informationen √ºber die Anzahl der in der Anwendung konfigurierten Partitionspools zur√ºck.  W√§hrend sich in Nucleus RTOS diese Anzahl im Laufe der Zeit √§ndert und der R√ºckgabewert die aktuelle Anzahl von Pools darstellt, wird in Nucleus SE der R√ºckgabewert w√§hrend der Montage festgelegt und bleibt unver√§ndert. <br><br><h3>  Die Herausforderung, die Anzahl der Partitionspools in Nucleus RTOS zu ermitteln </h3><br>  Der Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>UNSIGNED NU_Established_Partition_Pools (VOID);</b> <br><br>  Parameter: <br><br>  Sind abwesend. <br><br>  R√ºckgabewert: <br><br>  Die Anzahl der in der Anwendung erstellten Partitionspools. <br><br><h3>  Die Herausforderung, die Anzahl der Partitionspools in Nucleus SE zu ermitteln </h3><br>  Dieser Dienstprogrammaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>U8 NUSE_Partition_Pool_Count (void);</b> <br><br>  Parameter: <br><br>  Sind abwesend <br><br>  R√ºckgabewert: <br><br>  Die Anzahl der in der Anwendung erstellten Partitionspools. <br><br><h3>  Implementierung </h3><br>  Die Implementierung dieses API-Aufrufs ist √§u√üerst einfach: Der Wert <b>#define</b> des Symbols <b>NUSE_PARTITION_POOL_NUMBER</b> wird <b>zur√ºckgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Wie alle anderen Nucleus SE-Objekte verwenden Partitionspools Strukturarrays sowohl im ROM als auch im RAM, deren Anzahl von der Anzahl der in den Einstellungen angegebenen Pools abh√§ngt. <br><br>  Ich empfehle dringend, dass Anwendungscode √ºber API-Funktionen und nicht direkt auf solche Datenstrukturen zugreift.  Dies vermeidet Inkompatibilit√§t mit zuk√ºnftigen Versionen von Nucleus SE und unerw√ºnschte Nebenwirkungen und vereinfacht auch die Portierung der Anwendung auf Nucleus RTOS.  Das Folgende ist eine detaillierte Beschreibung der Datenstrukturen, um das Verst√§ndnis des Serviceabrufcodes und des Debuggens zu erleichtern. <br><br><h3>  Struktur der im RAM abgelegten Kerneldaten </h3><br>  Diese Datenstrukturen umfassen: <br><br>  <b>NUSE_Partition_Pool_Partition_Used []</b> - ein Array vom Typ <b>U8</b> mit einem Eintrag f√ºr jeden konfigurierten Partitionspool, der einen Z√§hler der aktuell verwendeten Pools enth√§lt; <br>  <b>NUSE_Partition_Pool_Blocking_Count []</b> - Ein Array vom Typ <b>U8,</b> das einen Z√§hler f√ºr blockierte Aufgaben in jedem Partitionspool enth√§lt.  Dieses Array ist vorhanden, wenn das Blockieren des API-Aufrufs m√∂glich ist. <br><br>  Solche Datenstrukturen werden beim Starten von Nucleus SE mit <b>NUSE_Init_ Partition_Pool ()</b> auf <b>Null</b> initialisiert.  Dies ist logisch, da dadurch jede Partition in jedem Pool unbenutzt (frei) wird.  Der folgende Artikel enth√§lt eine vollst√§ndige Beschreibung der Startvorg√§nge in Nucleus SE. <br><br>  Im Folgenden finden Sie Beschreibungen der Datenstrukturen in der Datei <b>nuse_init.c</b> . <br><br><img src="https://habrastorage.org/webt/vi/3x/sx/vi3xsxmbwdzkwgfge9ws_dsvups.jpeg"><br><br><h3>  RAM-Benutzerdaten </h3><br>  Der Benutzer muss einen Bereich im RAM zuweisen, um Daten f√ºr jeden Partitionspool zu speichern.  Der Speicherplatz im RAM muss dem Volumen der konfigurierten Partitionen (siehe "Daten im ROM" unten) mit einem zus√§tzlichen Byte f√ºr jede Partition im Pool entsprechen.  Vor jedem Abschnitt des Datenbereichs steht ein Statusbyte. <br><br><h3>  ROM-Daten </h3><br>  Dazu geh√∂ren: <br><br>  <b>NUSE_Partition_Pool_Data_Address []</b> - Ein Array vom Typ <b>ADDR</b> mit einem Eintrag f√ºr jeden konfigurierten Partitionspool, der die Adresse des Beginns des Datenspeicherbereichs enth√§lt. <br>  <b>NUSE_Partition_Pool_Partition_Number []</b> - ein Array vom Typ <b>U8</b> mit einem Eintrag f√ºr jeden konfigurierten Partitionspool, der Informationen zur Anzahl der Partitionen im Pool enth√§lt; <br>  <b>NUSE_Partition_Pool_Partition_Size []</b> - Ein Array vom Typ <b>U16</b> mit einem Eintrag f√ºr jeden konfigurierten Partitionspool, der die Gr√∂√üe der Partitionen f√ºr die Pools enth√§lt. <br><br>  Solche Datenstrukturen werden in <b>nuse_config.c</b> deklariert und (statisch) <b>initialisiert</b> : <br><br><img src="https://habrastorage.org/webt/zt/67/lq/zt67lqadvkdzmuvazbj0mmlhp8a.jpeg"><br><br><h3>  Daten-Footprint f√ºr den Partitionspool </h3><br>  Wie bei allen Kernobjekten in Nucleus SE ist die f√ºr Partitionspools erforderliche Speichermenge vorhersehbar. <br><br>  Die ROM-Gr√∂√üe (in Byte) f√ºr alle Anwendungspartitionspools kann wie folgt berechnet werden: <br><br>  <b>NUSE_PARTITION_POOL_NUMBER * (Gr√∂√üe von (ADDR) + 2)</b> <br><br>  Die Menge der Kerneldaten im RAM f√ºr alle Anwendungspartitionspools, wenn die Blockierung von API-Aufrufen aktiviert ist, betr√§gt nur 2 Byte pro Partitionspool, und wenn die Blockierung nicht aktiviert ist, dauert es 1 Byte. <br><br>  Die Speichermenge zum Speichern von Benutzerdaten im RAM variiert f√ºr jeden Partitionspool, obwohl sie, wie bereits erw√§hnt, f√ºr einen Pool mit dem Index n wie folgt berechnet werden kann: <br><br>  <b>NUSE_Partition_Pool_Partition_Number [n] *</b> <br>  <b>(NUSE_Partition_Pool_Partition_Size [n] + 1)</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Drei API-Aufrufe f√ºr in Nucleus RTOS implementierte Partitionspools werden in Nucleus SE nicht unterst√ºtzt. <br><br><h3>  Partitionspool erstellen </h3><br>  Dieser API-Aufruf erstellt einen Partitionspool.  Nucleus SE ben√∂tigt es nicht, da Aufgaben statisch erstellt werden. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Create_Partition_Pool (NU_PARTITION_POOL * -Pool, CHAR * -Name, VOID * -Startadresse, UNSIGNED-Poolgr√∂√üe, UNSIGNED-Partitionsgr√∂√üe, OPTION suspend_type);</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - ein Zeiger auf eine benutzerdefinierte Partitionspool <b>-</b> Steuereinheit;  wird als Handle f√ºr den Partitionspool in anderen API-Aufrufen verwendet; <br>  <b>name</b> - ein Zeiger auf den Namen des Partitionspools, eine 7-stellige Zeichenfolge mit einer abschlie√üenden Null; <br>  <b>start_address</b> - <b>Legt</b> die Startadresse f√ºr den Speicherbereich des Partitionspools fest. <br>  <b>pool_size</b> - Gesamtmenge des Speichers in Bytes; <br>  <b>partition_size</b> - Die Speichermenge in Byte f√ºr jede Partition im Pool.  Dar√ºber hinaus wird jedem Abschnitt eine zus√§tzliche kleine Speichermenge zugewiesen, die dank der beiden verwendeten Datenzeiger realisiert wird. <br>  <b>suspend_type</b> - legt fest, wie Aufgaben im Partitionspool angehalten werden.  G√ºltige Parameteroptionen sind <b>NU_FIFO</b> und <b>NU_PRIORITY</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - zeigt einen erfolgreichen Abschluss des Anrufs an; <br>  <b>NU_INVALID_POOL</b> - <b>Gibt</b> den Nullwert der Partitionspool-Steuereinheit ( <b>NULL</b> ) an. <br>  <b>NU_INVALID_MEMORY</b> - gibt den Nullwert des durch <b>start_ address</b> ( <b>NULL</b> ) definierten <b>Speicherbereichs an</b> ; <br>  <b>NU_INVALID_SIZE</b> - <b>Gibt</b> an, dass die Partitionsgr√∂√üe entweder 0 oder gr√∂√üer als der f√ºr die Partition zugewiesene Speicher ist. <br>  <b>NU_INVALID_SUSPEND</b> - ung√ºltiger <b>suspend_type-</b> Wert. <br><br><h3>  Partitionspool l√∂schen </h3><br>  Dieser API-Aufruf l√∂scht einen zuvor erstellten Partitionspool.  Nucleus SE ben√∂tigt es nicht, da Objekte statisch erstellt werden und nicht gel√∂scht werden k√∂nnen. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Delete_Partition_Pool (NU_PARTITION_POOL * -Pool);</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - Zeiger auf die Partitionspool-Steuereinheit; <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - zeigt einen erfolgreichen Abschluss des Anrufs an; <br>  <b>NU_INVALID_POOL</b> - <b>Gibt</b> einen ung√ºltigen Wert f√ºr den Partitionspoolzeiger an. <br><br><h3>  Zeiger f√ºr Partitionspools </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Partitionspools im System.  Nucleus SE ben√∂tigt dies nicht, da Objekte durch einen Index und nicht durch einen Zeiger identifiziert werden. <br><br>  Prototyp aufrufen: <br><br>  <b>UNSIGNED NU_Partition_Pool_Pointers (NU_PARTITION_POOL ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_PARTITION_POOL</b> ;  Das Array ist mit Zeigern auf konfigurierte Pools im System gef√ºllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern, die im Array platziert werden k√∂nnen. <br><br>  R√ºckgabewert: <br><br>  Die Anzahl der im Array platzierten <b>NU_PARTITION_POOL-</b> Zeiger. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Bei der Entwicklung von Nucleus SE bestand eine der Hauptaufgaben darin, ein hohes Ma√ü an Codekompatibilit√§t mit Nucleus RTOS sicherzustellen.  Partitionspools waren keine Ausnahme und werden aus Entwicklersicht √§hnlich wie in Nucleus RTOS implementiert.  Einige vorhandene Inkompatibilit√§tsbereiche sind akzeptabel, obwohl zu ber√ºcksichtigen ist, dass der endg√ºltige Code leichter zu verstehen und speichereffizienter ist.  Nucleus RTOS-API-Aufrufe k√∂nnen jedoch fast direkt als Nucleus SE-Aufrufe verwendet werden.  In Zukunft ist ein Artikel mit Informationen zur Verwendung von Nucleus SE durch Benutzer von Nucleus RTOS geplant. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch Datenstrukturen (Steuereinheiten) eines bestimmten Typs beschrieben.  Ein Zeiger auf diesen Steuerblock wird als Bezeichner f√ºr den Partitionspool verwendet.  Ich entschied, dass Nucleus SE einen anderen Ansatz f√ºr eine effizientere Nutzung des Speichers erfordert.  Alle Kernelobjekte werden durch mehrere Tabellen im RAM und / oder ROM beschrieben.  Die Gr√∂√üe dieser Tabellen wird durch die Anzahl der konfigurierbaren Typen aller Objekte bestimmt.  Die Kennung f√ºr ein bestimmtes Objekt ist der Index in diesen Tabellen.  Daher habe ich festgestellt, dass <b>NUSE_PARTITION_POOL</b> <b>U8</b> entspricht. <b>Danach</b> dient eine Variable (kein Zeiger) dieses Typs als Kennung der Aufgabe.  Diese leichte Inkompatibilit√§t l√§sst sich leicht feststellen, wenn der Code von oder nach Nucleus RTOS portiert wird.  Objektkennungen werden normalerweise unver√§ndert gespeichert und √ºbertragen. <br><br>  Nucleus RTOS unterst√ºtzt auch das Benennen von Partitionspools.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Anzahl der Abschnitte und deren Volumen </h3><br>  In Nucleus RTOS wird der Partitionspool basierend auf dem Gesamtvolumen des Pools und dem Volumen der Partitionen (die 2 weitere Zeiger enthalten) konfiguriert.  Diese Parameter sind als UNSIGNED (ca. 32 Bit) definiert.  In Nucleus SE wird der Partitionspool basierend auf der Gr√∂√üe der Partition (f√ºr die ein zus√§tzliches Byte hinzugef√ºgt wurde) und der Gesamtzahl der Partitionen konfiguriert.  Diese Parameter sind als U16 bzw. U8 definiert. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterst√ºtzt 7 Aufrufe f√ºr die Arbeit mit Partitionspools, von denen 3 nicht in Nucleus SE implementiert sind.  Weitere Einzelheiten zu diesen Herausforderungen und den Gr√ºnden f√ºr ihren Ausschluss sind oben aufgef√ºhrt. <br><br>  Der n√§chste Artikel befasst sich mit Signalen. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426477/">https://habr.com/ru/post/de426477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426465/index.html">‚ÄûWir ver√§ndern das Terrain‚Äú - IT geht auf eine gro√üe Baustelle</a></li>
<li><a href="../de426469/index.html">Telegramm als Unternehmensstandard</a></li>
<li><a href="../de426471/index.html">Wie Spyware-Daten auslaufen</a></li>
<li><a href="../de426473/index.html">Redux-Architektur. Ja oder Nein?</a></li>
<li><a href="../de426475/index.html">Miya - Assistent vom Smartphone</a></li>
<li><a href="../de426479/index.html">Selbst gemachter Pr√ºfstand f√ºr Motherboards</a></li>
<li><a href="../de426481/index.html">Hexagon Maps in Unity: Pfadfinder, Spielertrupps, Animationen</a></li>
<li><a href="../de426483/index.html">Einer, der Tesla √ºberholt. F√ºr profitabler</a></li>
<li><a href="../de426485/index.html">Dritter Qt 5 Test mit PVS-Studio</a></li>
<li><a href="../de426487/index.html">Testen Sie die Automatisierung von Grund auf neu. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>