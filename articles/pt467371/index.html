<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèª üîÄ üéÉ An√°lise de entrevista de emprego no Google: como encontrar relacionamentos üë®üèø‚Äçüåæ üññüèº üë©‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bem-vindo ao pr√≥ximo artigo de uma s√©rie de quebra-cabe√ßas que perguntei nas entrevistas do Google antes de serem banidos ap√≥s o vazamento. Desde ent√£...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise de entrevista de emprego no Google: como encontrar relacionamentos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br><br>  Bem-vindo ao pr√≥ximo artigo de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie de</a> quebra-cabe√ßas que perguntei nas entrevistas do Google antes de serem banidos ap√≥s o vazamento.  Desde ent√£o, parei de trabalhar como engenheiro de software no Google e passei para o cargo de gerente de desenvolvimento no Reddit, mas ainda tenho alguns √≥timos t√≥picos.  At√© o momento, examinamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a programa√ß√£o din√¢mica</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">elevando as matrizes ao poder</a> e √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sinon√≠mia das consultas</a> .  Desta vez, uma pergunta completamente nova. <br><a name="habracut"></a><br>  Mas primeiro, dois pontos.  Primeiro, o trabalho no Reddit foi incr√≠vel.  Nos √∫ltimos oito meses, constru√≠ e liderei a nova equipe de Relev√¢ncia dos an√∫ncios e montei um novo escrit√≥rio de desenvolvimento em Nova York.  Por mais divertido que seja, infelizmente, descobri que at√© recentemente n√£o havia tempo ou energia sobrando para um blog.  Receio ter abandonado um pouco esta s√©rie.  Desculpe pelo atraso. <br><br>  Em segundo lugar, se voc√™ seguiu os artigos, depois da √∫ltima edi√ß√£o, talvez pensasse que eu come√ßaria a procurar nas op√ß√µes sin√¥nimas das consultas.  Embora eu queira voltar a isso em algum momento, devo admitir que perdi o devido interesse por esse problema devido a uma mudan√ßa de trabalho e, at√© agora, decidi adi√°-lo.  No entanto, mantenha contato!  Eu me devo, e pretendo devolv√™-lo.  S√≥ um pouco mais tarde ... <br><br>  <i>Isen√ß√£o de responsabilidade r√°pida: Embora entrevistar candidatos seja um dos meus deveres profissionais, este blog apresenta minhas observa√ß√µes pessoais, hist√≥rias pessoais e opini√µes pessoais.</i>  <i>N√£o aceite isso para nenhuma declara√ß√£o oficial do Google, Alphabet, Reddit ou qualquer outra pessoa ou organiza√ß√£o.</i> <br><br><h2>  Procure uma nova pergunta </h2><br>  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior,</a> descrevi uma das minhas perguntas favoritas que usei por muito tempo, antes do vazamento inevit√°vel.  As perguntas anteriores eram fascinantes do ponto de vista te√≥rico, mas eu queria escolher um problema um pouco mais relevante para o Google como empresa.  Quando essa pergunta foi banida, eu queria encontrar uma substitui√ß√£o levando em conta a nova restri√ß√£o: para tornar a pergunta <i>mais simples</i> . <br><br>  Agora, isso pode parecer um pouco surpreendente, dado o infame processo de entrevista no Google.  Mas naquela √©poca um problema mais simples fazia sentido.  Meu racioc√≠nio consistia em duas partes.  A primeira √© pragm√°tica: os candidatos geralmente n√£o lidavam muito bem com as perguntas anteriores, apesar de in√∫meras sugest√µes e simplifica√ß√µes, e nem sempre eu tinha certeza do motivo.  A segunda teoria: o processo de entrevista deve dividir os candidatos nas categorias ‚Äúvale a pena contratar‚Äù e ‚Äún√£o vale a pena contratar‚Äù, e fiquei curioso para saber se isso poderia ser um pouco mais f√°cil com a pergunta. <br><br>  Antes de esclarecer esses dois pontos, quero destacar o que eles <i>n√£o</i> significam.  "Nem sempre sei por que uma pessoa tem problemas" n√£o significa a inutilidade das perguntas e que eu queria simplificar a entrevista por esse motivo.  Mesmo a pergunta mais dif√≠cil, muitos lidaram bem.  Quero dizer, quando os candidatos tinham problemas, era dif√≠cil para mim entender o que estavam perdendo. <br><br>  Boas entrevistas d√£o uma vis√£o ampla dos pontos fortes e fracos do candidato.  N√£o basta que o comit√™ de contrata√ß√£o simplesmente diga que "falhou": o comit√™ determina se o candidato possui as qualidades espec√≠ficas da empresa que est√° procurando.  Da mesma forma, as palavras ‚Äúele √© legal‚Äù n√£o ajudam o comit√™ a decidir sobre um candidato forte em algumas √°reas, mas duvidoso em outras.  Descobri que quest√µes mais complexas freq√ºentemente separam os candidatos nessas duas categorias.  Sob esse prisma, "nem sempre tenho certeza do porqu√™ de uma pessoa ter problemas" significa que "a incapacidade de avan√ßar nessa quest√£o n√£o √©, por si s√≥, um retrato das habilidades desse candidato". <br><br>  A classifica√ß√£o dos candidatos como ‚Äúvale a pena contratar‚Äù e ‚Äún√£o vale a pena contratar‚Äù <i>n√£o</i> significa que o processo de entrevista deva separar candidatos est√∫pidos de espertos.  N√£o me lembro de um √∫nico candidato que n√£o fosse inteligente, talentoso e motivado.  Muitos vieram de excelentes universidades e o restante estava claramente extremamente motivado.  Passar por entrevistas telef√¥nicas j√° √© uma boa peneira, e at√© recusar nesta fase n√£o √© um sinal de falta de habilidade. <br><br>  No entanto, lembro-me de muitos que n√£o estavam preparados o suficiente para a entrevista ou trabalharam muito devagar, ou exigiram muita supervis√£o para resolver o problema, ou se comunicaram de uma maneira pouco clara, ou n√£o conseguiram traduzir suas id√©ias em c√≥digo, ou mantiveram uma posi√ß√£o que simplesmente n√£o levaria seu sucesso a longo prazo etc. A defini√ß√£o de ‚Äúvale a pena contratar‚Äù √© vaga e varia de acordo com a empresa, e o processo de entrevista √© determinar se cada candidato atende aos requisitos de uma empresa em particular. <br><br>  Eu li muitos coment√°rios no reddit reclamando de perguntas de entrevistas excessivamente complexas.  Fiquei curioso para saber se ainda era poss√≠vel fazer uma recomenda√ß√£o digna / indigna para uma tarefa mais simples.  Suspeitei que isso daria um sinal √∫til sem gritar desnecessariamente os nervos do candidato.  Vou falar sobre minhas conclus√µes no final do artigo ... <br><br>  Com esses pensamentos, eu estava procurando uma nova pergunta.  Em um mundo ideal, essa √© uma pergunta bastante simples para ser resolvida em 45 minutos, mas com perguntas adicionais para que os candidatos mais poderosos mostrem suas habilidades.  A implementa√ß√£o tamb√©m deve ser compacta, porque muitos candidatos ainda escrevem no quadro.  Uma grande vantagem se o t√≥pico estiver de alguma forma relacionado aos produtos do Google. <br><br>  Finalmente, decidi por uma pergunta que algum maravilhoso pesquisador descreveu cuidadosamente e inseriu em nosso banco de dados de perguntas.  Agora, consultei ex-colegas e certifiquei-me de que a pergunta ainda seja proibida, para que voc√™ definitivamente n√£o seja perguntado na entrevista.  Apresento da forma que me parece mais eficaz, com um pedido de desculpas ao autor original. <br><br><h2>  Pergunta </h2><br>  Fale sobre como medir dist√¢ncias.  <i>A m√£o</i> √© uma unidade de medida de dez polegadas comumente usada em pa√≠ses de l√≠ngua inglesa para medir a altura dos cavalos.  <i>Um ano-luz</i> √© outra unidade de medida igual √† dist√¢ncia que uma part√≠cula (ou onda?) De luz viaja em um determinado n√∫mero de segundos, aproximadamente igual a um ano terrestre.  √Ä primeira vista, eles t√™m pouco em comum um com o outro, exceto pelo fato de serem usados ‚Äã‚Äãpara medir a dist√¢ncia.  Mas acontece que o Google pode convert√™-los facilmente: <br><br><img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br><br>  Isso pode parecer √≥bvio: no final, os dois medem a dist√¢ncia, ent√£o fica claro que h√° uma transforma√ß√£o.  Mas se voc√™ pensar bem, √© um pouco estranho: como eles calcularam essa taxa de convers√£o?  Claramente, ningu√©m contou realmente o n√∫mero de m√£os em um ano-luz.  Na verdade, voc√™ n√£o precisa levar isso diretamente.  Voc√™ pode simplesmente usar convers√µes conhecidas: <br><br><ul><li>  <i>1 m√£o</i> = <i>4 polegadas</i> <br></li><li>  <i>4 polegadas</i> = <i>0.33333 p√©s</i> <br></li><li>  <i>0.33333 ft</i> = <i>6.3125e - 5 milhas</i> <br></li><li>  <i>6.3125e - 5 milhas</i> = <i>1.0737e - 17 anos-luz</i> </li></ul><br>  O objetivo da tarefa √© desenvolver um sistema que realize essa transforma√ß√£o.  Em particular: <br><br><blockquote>  Na entrada, voc√™ tem uma lista de fatores de convers√£o (formatados no idioma escolhido) na forma de um conjunto de unidades de medida iniciais, unidades e fatores finais, por exemplo: <br><br><pre>  ft 12
 jardas para p√©s 0.3333333
 etc. </pre><br>  Portanto, ORIGIN * MULTIPLIER = DESTINATION.  Desenvolva um algoritmo que use dois valores de unidade arbitr√°rios e retorne o fator de convers√£o entre eles. </blockquote><br><h2>  A discuss√£o </h2><br>  Eu gosto desse problema porque ele tem uma resposta intuitiva e √≥bvia: basta converter de uma unidade para outra e depois para a pr√≥xima, at√© encontrar o alvo!  N√£o me lembro de um √∫nico candidato que se deparou com esse problema e ficou completamente intrigado em como resolv√™-lo.  Isso se encaixa bem com a exig√™ncia de um problema "mais simples", uma vez que os anteriores normalmente exigiam um longo estudo e reflex√£o antes que pelo menos uma abordagem b√°sica da solu√ß√£o fosse encontrada. <br><br>  No entanto, muitos candidatos n√£o conseguiram perceber sua intui√ß√£o como uma solu√ß√£o funcional, sem sugest√µes √≥bvias.  Uma das vantagens desta pergunta √© que ela testa a capacidade do candidato de formular o problema (para fazer o enquadramento), de modo a se prestar √† an√°lise e codifica√ß√£o.  Como veremos, h√° uma extens√£o muito interessante aqui que requer um novo salto conceitual. <br><br>  Por contexto, o enquadramento √© o ato de traduzir um problema com uma solu√ß√£o n√£o √≥bvia em um problema equivalente, onde a solu√ß√£o √© deduzida de maneira natural.  Se isso soa completamente abstrato e inexpugn√°vel, me desculpe, mas √©.  Vou explicar o que quero dizer quando apresentar a solu√ß√£o inicial para esse problema.  A primeira parte da solu√ß√£o ser√° um exerc√≠cio de desenvolvimento e aplica√ß√£o de conhecimento algor√≠tmico.  A segunda parte ser√° um exerc√≠cio de manipula√ß√£o desse conhecimento para chegar a uma otimiza√ß√£o nova e n√£o √≥bvia. <br><br><h2>  Parte 0. Intui√ß√£o </h2><br>  Antes de aprofundar, vamos explorar completamente a solu√ß√£o "√≥bvia".  A maioria das convers√µes necess√°rias √© simples e direta.  Qualquer americano que viajou para fora dos Estados Unidos sabe que a maior parte do mundo usa a unidade misteriosa "quil√¥metro" para medir dist√¢ncias.  Para converter, basta multiplicar o n√∫mero de milhas por cerca de 1,6. <br><br>  N√≥s encontramos essas coisas na maior parte de nossas vidas.  Para a maioria das unidades, j√° existe uma convers√£o pr√©-calculada, portanto, basta analis√°-la na tabela correspondente.  Mas se n√£o houver convers√£o direta (por exemplo, de m√£os para anos-luz), faz sentido criar um caminho de convers√£o, conforme indicado acima: <br><br><ul><li>  <i>1 m√£o</i> = <i>4 polegadas</i> <br></li><li>  <i>4 polegadas</i> = <i>0.33333 p√©s</i> <br></li><li>  <i>0.33333 ft</i> = <i>6.3125e - 5 milhas</i> <br></li><li>  <i>6.3125e - 5 milhas</i> = <i>1.0737e - 17 anos-luz</i> </li></ul><br>  Era muito simples, eu apenas tive essa transforma√ß√£o usando minha imagina√ß√£o e uma tabela de transforma√ß√£o padr√£o!  No entanto, algumas perguntas permanecem.  Existe um caminho mais curto?  Qual √© a precis√£o do coeficiente?  A convers√£o √© sempre poss√≠vel?  √â poss√≠vel automatiz√°-lo?  Infelizmente, aqui a abordagem ing√™nua se desmorona. <br><br><h2>  Parte 1. Decis√£o ing√™nua </h2><br>  √â bom que o problema tenha uma solu√ß√£o intuitiva, mas, de fato, essa simplicidade √© um obst√°culo para resolv√™-lo.  N√£o h√° nada mais dif√≠cil do que tentar entender de uma nova maneira o que voc√™ j√° entende - principalmente porque voc√™ sabe menos do que pensa.  Para ilustrar, imagine que voc√™ veio para uma entrevista - e voc√™ tem esse m√©todo intuitivo em sua cabe√ßa.  Mas isso n√£o permite resolver uma s√©rie de problemas importantes. <br><br>  Por exemplo, e se <i>n√£o houver convers√£o</i> ?  A abordagem √≥bvia n√£o diz nada, √© realmente poss√≠vel converter de uma unidade para outra.  Se eles me derem mil taxas de convers√£o, ser√° muito dif√≠cil determinar se √© poss√≠vel em princ√≠pio.  Se me pedem para fazer uma convers√£o entre unidades desconhecidas (ou inventadas) de um <i>ponteiro</i> e um <i>jab</i> , n√£o fa√ßo ideia por onde come√ßar.  Como uma abordagem intuitiva ajuda aqui? <br><br>  Devo admitir que este √© um tipo de cen√°rio artificial, mas tamb√©m existe um cen√°rio mais realista.  Voc√™ v√™ que minha declara√ß√£o do problema inclui apenas unidades de dist√¢ncia.  Isso √© feito de prop√≥sito.  E se eu pedir ao sistema para converter de polegadas para quilogramas?  Voc√™ e eu sabemos que isso n√£o √© poss√≠vel porque eles medem tipos diferentes, mas a entrada n√£o diz nada sobre o ‚Äútipo‚Äù que cada unidade mede. <br><br>  √â aqui que uma formula√ß√£o cuidadosa da quest√£o permite que candidatos fortes se provem.  <i>Antes de</i> desenvolver o algoritmo, eles pensam nos casos extremos do sistema.  E essa afirma√ß√£o do problema propositadamente lhes d√° a oportunidade de me perguntar se traduziremos unidades diferentes.  Este n√£o √© um problema t√£o grande se ocorrer em um est√°gio inicial, mas √© sempre um bom sinal quando algu√©m me pergunta com anteced√™ncia: "O que o programa deve retornar se a convers√£o n√£o for poss√≠vel?"  Colocar a pergunta dessa maneira me d√° uma id√©ia das habilidades do candidato antes que ele escreva pelo menos uma linha de c√≥digo. <br><br>  <i>Visualiza√ß√£o de gr√°fico</i> <br><br>  Obviamente, a abordagem ing√™nua n√£o √© adequada, por isso precisamos pensar em como fazer essa convers√£o?  A resposta √© considerar as unidades como um gr√°fico.  Este √© o primeiro salto de entendimento necess√°rio para resolver esse problema. <br><br>  Em particular, imagine que cada unidade seja um n√≥ em um gr√°fico e haja uma aresta do n√≥ <code>A</code> para o n√≥ <code>B</code> se <code>A</code> puder ser convertido em <code>B</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br><br>  As arestas s√£o rotuladas com uma taxa de convers√£o pela qual voc√™ deve multiplicar <code>A</code> para obter <code>B</code> <br><br>  Eu quase sempre esperava que o candidato apresentasse esse tipo de estrutura e raramente dava dicas s√©rias a ele.  Posso perdoar o candidato que n√£o percebe a solu√ß√£o para o problema de usar conjuntos disjuntos ou n√£o est√° muito familiarizado com a √°lgebra linear para encontrar uma solu√ß√£o que reduza a aumentar novamente o poder da matriz de adjac√™ncia, mas os gr√°ficos s√£o ensinados em qualquer curr√≠culo ou curso de programa√ß√£o.  Se o candidato n√£o tiver o conhecimento adequado, este √© um sinal de "n√£o contrata√ß√£o". <br><br>  <i>Enfim</i> <br><br>  Uma representa√ß√£o gr√°fica reduz a solu√ß√£o para o problema cl√°ssico de pesquisa gr√°fica.  Em particular, dois algoritmos s√£o √∫teis aqui: pesquisa ampla (BFS) e pesquisa profunda (DFS).  Ao pesquisar em largura, examinamos os n√≥s de acordo com a dist√¢ncia da origem: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>  <i><font color="gray">Azuis mais escuros significam gera√ß√µes posteriores</font></i> <br><br>  E, ao pesquisar em profundidade, examinamos os n√≥s na ordem em que eles ocorrem: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br><br>  <i><font color="gray">Azuis mais escuros tamb√©m significam gera√ß√µes posteriores.</font></i>  <i><font color="gray">Observe que na verdade n√£o visitamos todos os sites</font></i> <br><br>  Qualquer um dos algoritmos determina facilmente se h√° uma convers√£o de uma unidade para outra; basta apenas pesquisar no gr√°fico.  Come√ßamos a partir da unidade de origem e procuramos at√© encontrar a unidade de destino.  Se voc√™ n√£o encontrar o seu destino (como se estivesse tentando converter polegadas em quilogramas), sabemos que n√£o h√° como. <br><br>  Mas espere, algo est√° faltando.  N√£o queremos procurar uma maneira, queremos encontrar uma taxa de convers√£o!  √â aqui que o candidato deve saltar: acontece que voc√™ pode modificar qualquer algoritmo de pesquisa para calcular a taxa de convers√£o, simplesmente salvando o estado adicional √† medida que avan√ßa.  √â a√≠ que as ilustra√ß√µes n√£o fazem mais sentido, ent√£o vamos nos aprofundar no c√≥digo. <br><br>  Primeiro, voc√™ precisa determinar a estrutura de dados do gr√°fico, portanto, usamos isso: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateGraph</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rates)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span></span> self.graph = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> orig, dest, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rates: self.add_conversion(orig, dest, rate) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph[node].items() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph.keys()</code> </pre> <br>  Ent√£o vamos come√ßar no DFS.  Existem v√°rias maneiras de implement√°-lo, mas de longe o mais comum √© uma solu√ß√£o recursiva.  Vamos come√ßar com isso: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__dfs_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end, rate_from_origin, visited)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __dfs_helper(rate_graph, node, end, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, set())</code> </pre> <br>  Em poucas palavras, esse algoritmo come√ßa com um n√≥, itera sobre seus vizinhos e visita-os imediatamente, fazendo uma chamada recursiva √† fun√ß√£o.  Cada chamada de fun√ß√£o na pilha salva o estado de sua pr√≥pria itera√ß√£o, portanto, quando uma visita recursiva √© retornada, seu pai imediatamente continua a itera√ß√£o.  Evitamos visitar o mesmo site novamente, mantendo um conjunto de sites visitados em todas as chamadas.  Tamb√©m calculamos o coeficiente atribuindo um fator de convers√£o entre cada n√≥ e a fonte.  Assim, quando encontramos o n√≥ / bloco de destino, j√° criamos o coeficiente de convers√£o a partir do n√≥ de origem e podemos simplesmente devolv√™-lo. <br><br>  Esta √© uma √≥tima implementa√ß√£o, mas sofre de duas falhas principais.  Em primeiro lugar, √© recursivo.  Se o caminho desejado consistir em mais de mil saltos, sairemos voando com uma falha.  Obviamente, isso √© improv√°vel, mas se h√° algo inaceit√°vel para um servi√ßo de longo prazo, √© um fracasso.  Em segundo lugar, mesmo se concluirmos com √™xito, a resposta tem algumas propriedades indesej√°veis. <br><br>  Na verdade, eu j√° dei uma dica no in√≠cio do post.  Voc√™ j√° reparou como o Google mostra a taxa de convers√£o de <code>1.0739e-17</code> , mas meu c√°lculo manual fornece <code>1.0737e-17</code> ?  Acontece que todas essas multiplica√ß√µes de ponto flutuante j√° fazem pensar em espalhar o erro.  Existem muitas nuances para este artigo, mas a conclus√£o √© que voc√™ precisa minimizar a multiplica√ß√£o de ponto flutuante para evitar erros que se acumulam e causam problemas. <br><br>  DFS √© um √≥timo algoritmo de pesquisa.  Se existir uma solu√ß√£o, ela a encontrar√°.  Mas ele n√£o possui uma propriedade-chave: ele n√£o encontra necessariamente o caminho mais curto.  Isso √© importante para n√≥s, porque um caminho mais curto significa menos saltos e menos erros devido √†s multiplica√ß√µes de ponto flutuante.  Para resolver o problema, recorremos ao BFS. <br><br><h2>  Parte 2. Solu√ß√£o BFS </h2><br>  Nesta fase, se um candidato implementa com √™xito uma solu√ß√£o DFS recursiva e a interrompe, geralmente dou pelo menos uma recomenda√ß√£o fraca sobre a contrata√ß√£o desse candidato.  Ele entendeu o problema, escolheu o enquadramento apropriado e implementou uma solu√ß√£o de trabalho.  Esta √© uma decis√£o ing√™nua, por isso n√£o insisto em contrat√°-lo, mas se ele lidou bem com outras entrevistas, n√£o recomendarei recusar. <br><br>  Vale a pena repetir: em caso de d√∫vida, escreva uma solu√ß√£o ing√™nua!  Mesmo que n√£o seja completamente ideal, a presen√ßa de c√≥digo no quadro j√° √© uma conquista, e muitas vezes a solu√ß√£o certa pode ser encontrada em sua base.  Vou dizer de forma diferente: nunca trabalhe por nada.  Provavelmente, voc√™ pensou em uma solu√ß√£o ing√™nua, mas n√£o quis oferec√™-la, porque sabe que ela n√£o √© √≥tima.  Se voc√™ est√° pronto para encontrar a melhor solu√ß√£o no momento, tudo bem, mas se n√£o, registre o progresso feito antes de passar para coisas mais complexas. <br><br>  A partir de agora, vamos falar sobre as melhorias no algoritmo.  As principais desvantagens de uma solu√ß√£o DFS recursiva s√£o que s√£o recursivas e n√£o minimizam o n√∫mero de multiplica√ß√µes.  Como veremos em breve, o BFS minimiza o n√∫mero de multiplica√ß√µes e tamb√©m √© muito dif√≠cil implement√°-lo recursivamente.  Infelizmente, teremos que abandonar a solu√ß√£o recursiva do DFA, porque para melhor√°-la, precisaremos reescrever completamente o c√≥digo. <br><br>  Sem mais delongas, apresento uma abordagem iterativa baseada no BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Essa implementa√ß√£o √© funcionalmente muito diferente da anterior, mas se voc√™ observar de perto, faz a mesma coisa, com uma altera√ß√£o significativa: enquanto o DFS recursivo salva o estado da rota adicional na pilha de chamadas, implementando efetivamente a pilha LIFO, a solu√ß√£o iterativa a armazena na fila FIFO <br><br>  Isso implica na propriedade ‚Äúcaminho mais curto / menor n√∫mero de multiplica√ß√µes‚Äù.  Visitamos n√≥s na ordem em que eles ocorrem e, dessa maneira, obtemos gera√ß√µes de n√≥s.  O primeiro n√≥ insere seus vizinhos e, em seguida, os visitamos em ordem, mantendo os vizinhos o tempo todo e assim por diante.  A propriedade de caminho mais curto decorre do fato de os n√≥s serem visitados na ordem de sua dist√¢ncia da origem.  Portanto, quando encontramos um destino, sabemos que n√£o h√° gera√ß√£o anterior que possa levar a ele. <br><br>  Neste momento, estamos <i>quase</i> terminando.  Primeiro, voc√™ precisa responder a algumas perguntas, e elas s√£o for√ßadas a retornar √† formula√ß√£o original do problema. <br><br>  Primeiro, a coisa mais trivial a fazer se a unidade original n√£o existir?  Ou seja, n√£o podemos encontrar o n√≥ com o nome fornecido.  Na pr√°tica, voc√™ precisa fazer alguma normaliza√ß√£o das seq√º√™ncias de caracteres para que a libra, a libra e a libra aponte para o mesmo n√≥ "libra" (ou alguma outra representa√ß√£o can√¥nica), mas isso est√° al√©m do escopo de nossa pergunta. <br><br>  Em segundo lugar, e se n√£o houver convers√£o entre as duas unidades?  Lembre-se de que, nos dados iniciais, existem apenas convers√µes entre unidades e isso n√£o indica se √© poss√≠vel obter outro de uma unidade espec√≠fica.  Isso se resume ao fato de que transforma√ß√µes e caminhos s√£o diretamente equivalentes; portanto, se n√£o houver caminho entre dois n√≥s, n√£o haver√° transforma√ß√£o.  Na pr√°tica, voc√™ acaba com ilhas de unidades n√£o relacionadas: uma para dist√¢ncias, uma para pesos, uma para moedas etc. <br><br>  Por fim, se voc√™ observar atentamente o gr√°fico acima, verifica-se que n√£o √© poss√≠vel converter entre m√£os e anos-luz com esta solu√ß√£o.  A dire√ß√£o das conex√µes entre os n√≥s significa que n√£o h√° como passar da m√£o aos anos-luz.  No entanto, isso √© bastante f√°cil de corrigir, porque as transforma√ß√µes podem ser revertidas.  Podemos alterar nosso c√≥digo de inicializa√ß√£o do gr√°fico da seguinte maneira: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[dest] = {} self.graph[dest][orig] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / rate</code> </pre> <br><h2>  Parte 3. Avalia√ß√£o </h2><br>  Feito!  Se o candidato chegou a esse ponto, provavelmente o recomendarei para contratar.  Se voc√™ estudou ci√™ncia da computa√ß√£o ou fez um curso de algoritmos, pode perguntar: ‚ÄúIsso √© realmente suficiente para obter uma entrevista com esse cara?‚Äù, Ao qual responderei: ‚ÄúEssencialmente, sim‚Äù. <br><br>  Antes de decidir que a pergunta √© simples demais, vejamos o que um candidato deve fazer para chegar a esse ponto: <br><br><ul><li>  Compreenda a pergunta <br></li><li>  Construir uma rede de transforma√ß√µes na forma de um gr√°fico <br></li><li>  Entenda que os coeficientes podem ser comparados com as arestas do gr√°fico <br></li><li>  Veja a possibilidade de usar algoritmos de pesquisa para conseguir isso. <br></li><li>  Escolha seu algoritmo favorito e altere-o para rastrear probabilidades <br></li><li>  Se ele implementou o DFS como uma solu√ß√£o ing√™nua, reconhe√ßa suas fraquezas. <br></li><li>  Implementar BFS <br></li><li>  Para voltar atr√°s e estudar casos extremos: <br><ul><li>  E se nos perguntarem sobre um n√≥ que n√£o existe? <br></li><li>  E se o fator de convers√£o n√£o existir? </li></ul></li><li>  Reconhecer que transforma√ß√µes inversas s√£o poss√≠veis e provavelmente necess√°rias </li></ul><br>  Esta pergunta √© mais f√°cil do que as anteriores, mas tamb√©m √© dif√≠cil.  Como em todas as perguntas anteriores, o candidato deve dar um salto mental de uma pergunta formulada abstratamente para um algoritmo ou estrutura de dados que abra o caminho para uma solu√ß√£o.  A √∫nica coisa √© que o algoritmo final √© menos avan√ßado do que em outras quest√µes.  Fora deste material algor√≠tmico, os mesmos requisitos se aplicam, especialmente com rela√ß√£o a casos extremos e corre√ß√£o. <br><br>  "Mas espere!" Voc√™ pode perguntar.  - O Google n√£o √© obcecado pela complexidade do tempo de execu√ß√£o?  Voc√™ nem perguntou sobre a complexidade temporal ou espacial desse problema.  Oh bem!  Voc√™ tamb√©m pode perguntar: ‚ÄúEspere um minuto, voc√™ deu a classifica√ß√£o‚Äú altamente recomend√°vel para contratar ‚Äù?  Como conseguir isso?  Muito boas perguntas, ambas.  Isso nos leva √† nossa rodada final de b√¥nus extra ... <br><br><h2>  Parte 4. √â poss√≠vel fazer melhor? </h2><br>  Neste ponto, gostaria de felicitar o candidato com uma boa resposta e deixar claro que tudo o mais √© apenas um b√¥nus.  Quando a press√£o desaparece, podemos come√ßar a criar. <br><br>  Ent√£o, qual √© a dificuldade de executar o BFS?  Na pior das hip√≥teses, devemos considerar cada n√≥ e borda individual, o que fornece complexidade linear <code>O(N+E)</code> .  Isso est√° al√©m da mesma complexidade da constru√ß√£o do gr√°fico <code>O(N+E)</code> .  Para um mecanismo de pesquisa, isso provavelmente √© bom: mil unidades de medida s√£o suficientes para a maioria dos aplicativos razo√°veis, e fazer uma pesquisa na mem√≥ria para cada consulta n√£o √© uma sobrecarga. <br><br>  No entanto, pode-se fazer melhor.  Para motivar, considere como esse c√≥digo √© inserido na string de pesquisa.  Convers√µes de algumas unidades n√£o padr√£o s√£o um pouco mais comuns, portanto, as calcularemos novamente.  Cada vez que uma pesquisa √© realizada, valores intermedi√°rios s√£o calculados e assim por diante. <br><br>  Muitas vezes, √© sugerido simplesmente armazenar em cache os resultados do c√°lculo.  Sempre que uma convers√£o de unidade √© calculada, sempre podemos adicionar uma margem entre as duas convers√µes.  Como b√¥nus, obtemos a transforma√ß√£o inversa e de gra√ßa!  Voc√™ terminou? <br><br>  De fato, isso nos dar√° um tempo de pesquisa assintoticamente constante, mas custar√° o armazenamento de arestas adicionais.  Na verdade, isso se torna bastante caro: com o tempo, procuraremos um gr√°fico completo, pois todos os pares de transforma√ß√µes s√£o gradualmente calculados e armazenados.  O n√∫mero de arestas poss√≠veis no gr√°fico √© metade do quadrado do n√∫mero de n√≥s; portanto, para mil n√≥s, precisamos de meio milh√£o de arestas.  Para dez mil n√≥s, cerca de cinquenta milh√µes, etc. <br><br>  Indo al√©m do escopo do mecanismo de pesquisa, para um gr√°fico de um milh√£o de n√≥s, lutamos por meio trilh√£o de arestas.  Esse valor √© simplesmente irracional para armazenar, al√©m de gastarmos tempo inserindo arestas no gr√°fico.  N√≥s devemos fazer melhor. <br><br>  Felizmente, existe uma maneira de obter tempo constante para buscar coeficientes, sem crescimento quadr√°tico do espa√ßo.  De fato, quase tudo o que precisamos est√° bem debaixo do nosso nariz. <br><br><h2>  Parte 4. Tempo constante </h2><br>  Portanto, o cache total est√° realmente pr√≥ximo da solu√ß√£o ideal.  Nesta abordagem, (em √∫ltima an√°lise), obtemos arestas entre todos os n√≥s, ou seja, nossa transforma√ß√£o √© reduzida para encontrar uma aresta.  Mas √© realmente necess√°rio armazenar convers√µes de cada n√≥ para cada n√≥?  E se apenas salvarmos os fatores de convers√£o de <i>um</i> n√≥ para todos os outros? <br><br>  D√™ uma outra olhada na solu√ß√£o BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Vamos ver o que acontece aqui: come√ßamos a partir do n√≥ de origem e, para cada n√≥ que encontramos, calculamos o coeficiente de convers√£o da fonte para esse n√≥.  Ent√£o, assim que chegamos ao destino, retornamos o coeficiente entre os pontos inicial e final e descartamos os coeficientes intermedi√°rios. <br><br>  Essas taxas intermedi√°rias s√£o fundamentais.  Mas e se n√≥s n√£o os jogarmos fora?  E se n√≥s os escrevermos?  Todas as pesquisas mais complexas e incompreens√≠veis tornam-se simples: para encontrar a propor√ß√£o de A para B, primeiro encontre a propor√ß√£o de X para B, depois divida-a pela propor√ß√£o de X para A e pronto!  Visualmente, fica assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>  <i><font color="gray">Observe que entre dois n√≥s n√£o mais que duas arestas</font></i> <br><br>  Acontece que, para calcular esta tabela, quase n√£o precisamos alterar a solu√ß√£o BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_conversions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conversions_bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, conversions)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() conversions[node] = (start, rate_from_origin) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: to_visit.append((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions conversions = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.get_nodes(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: conversions_bfs(graph, node, conversions) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions</code> </pre> <br>  A estrutura de transforma√ß√£o √© representada por um dicion√°rio da unidade A em dois valores: a raiz do componente associado da unidade A e o coeficiente de convers√£o entre a unidade raiz e a unidade A. Como inserimos uma unidade nesse dicion√°rio a cada visita, podemos usar o espa√ßo de chave desse dicion√°rio como um conjunto de visitas em vez de usar um conjunto dedicado de visitas.  Observe que n√£o temos um n√≥ final e, em vez disso, iteramos pelos n√≥s at√© terminarmos. <br><br>  Fora desse BFS, h√° uma fun√ß√£o auxiliar que itera sobre os n√≥s em um gr√°fico.  Sempre que encontra um n√≥ fora do dicion√°rio de tradu√ß√£o, inicia o BFS a partir desse n√≥.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, temos a garantia de recolher todos os n√≥s em seus componentes relacionados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando voc√™ precisa encontrar o relacionamento entre as unidades, simplesmente usamos a estrutura de transforma√ß√£o que acabamos de calcular:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conversions, start, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: start_root, start_rate = conversions[start] end_root, end_rate = conversions[end] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_root != end_root: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end_rate / start_rate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A situa√ß√£o ‚Äún√£o existe tal unidade‚Äù √© tratada ouvindo uma exce√ß√£o ao acessar a estrutura de transforma√ß√µes. </font><font style="vertical-align: inherit;">A situa√ß√£o ‚Äún√£o existem tais transforma√ß√µes‚Äù √© tratada comparando as ra√≠zes de duas quantidades: se elas t√™m ra√≠zes diferentes, s√£o detectadas por meio de duas chamadas BFS diferentes, ou seja, elas est√£o em dois componentes conectados diferentes e, portanto, n√£o h√° caminho entre elas. </font><font style="vertical-align: inherit;">Finalmente, realizamos a convers√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√° vai voc√™! </font><font style="vertical-align: inherit;">A solu√ß√£o atual possui complexidade de pr√©-processamento</font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(n√£o √© pior que as solu√ß√µes anteriores), mas ela tamb√©m pesquisa com tempo constante. Teoricamente, dobramos os requisitos de espa√ßo, mas na maioria das vezes n√£o precisamos mais do gr√°fico original, portanto podemos exclu√≠-lo e usar apenas este. Al√©m disso, a complexidade espacial √© na verdade menor que o gr√°fico original: requer </font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque precisa armazenar todas as arestas e v√©rtices, e essa estrutura exige apenas </font></font><code>O(V)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque n√£o precisamos mais de arestas.</font></font><br><br><h2>  Resultados </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ foi t√£o longe, lembre-se de que uma das perguntas era inicialmente verificar se um problema mais simples ainda poderia ser √∫til na escolha de candidatos dignos e se poderia dar uma imagem melhor das habilidades. Gostaria de dar uma resposta cient√≠fica definitiva, mas s√≥ tenho hist√≥rias de experi√™ncia pessoal. No entanto, notei alguns resultados positivos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se dividirmos a solu√ß√£o desse problema em quatro obst√°culos (discuss√£o do enquadramento, escolha do algoritmo, implementa√ß√£o, discuss√£o da execu√ß√£o por um tempo constante), no final da entrevista quase todos os candidatos alcan√ßaram a ‚Äúescolha do algoritmo‚Äù. Como eu suspeitava, a discuss√£o sobre o enquadramento era um bom filtro: os candidatos exibiam imediatamente um gr√°fico ou n√£o podiam chegar a ele de forma alguma, apesar das dicas significativas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© um sinal √∫til imediatamente. Eu posso entender quando uma pessoa n√£o conhece estruturas de dados avan√ßadas ou obscuras, porque, para sermos honestos, voc√™ raramente precisa implementar conjuntos disjuntos. Mas os gr√°ficos s√£o uma estrutura de dados fundamental e s√£o ensinados como parte de quase qualquer curso introdut√≥rio sobre esse t√≥pico. Se o candidato se esfor√ßar para entend√™-los ou n√£o puder aplic√°-los facilmente, provavelmente ser√° dif√≠cil para ele ter sucesso no Google (pelo menos no meu tempo l√°, n√£o sei como hoje).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por outro lado, a escolha do algoritmo n√£o foi uma fonte de sinal particularmente √∫til. As pessoas que passaram pelo est√°gio de enquadramento geralmente acessavam o algoritmo sem problemas. Suspeito que isso se deva ao fato de que os algoritmos de pesquisa quase sempre s√£o ensinados junto com os pr√≥prios gr√°ficos; portanto, se algu√©m est√° familiarizado com um, ent√£o conhece o outro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A implementa√ß√£o n√£o foi f√°cil. Muitas pessoas n√£o tiveram problemas com a implementa√ß√£o recursiva do DFS, mas, como mencionei acima, essa implementa√ß√£o n√£o √© adequada para produ√ß√£o. Para minha surpresa, as implementa√ß√µes iterativas do BFS e DFS n√£o parecem muito familiares para as pessoas e, mesmo depois de dicas √≥bvias, elas frequentemente flutuam no assunto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na minha opini√£o, qualquer pessoa que passou pela fase de implementa√ß√£o j√° me recebeu a recomenda√ß√£o "Contratar", e a discuss√£o do lead time constante √© simplesmente um b√¥nus. </font><font style="vertical-align: inherit;">Embora tenhamos analisado a solu√ß√£o em detalhes no artigo, na pr√°tica, uma discuss√£o oral em vez de escrever c√≥digo √© geralmente mais produtiva. </font><font style="vertical-align: inherit;">Muito poucos candidatos poderiam tomar uma decis√£o imediatamente. </font><font style="vertical-align: inherit;">Muitas vezes tive que dar pistas substanciais e mesmo assim muitas pessoas n√£o o encontraram. </font><font style="vertical-align: inherit;">Isso √© normal: como esperado, √© dif√≠cil obter uma classifica√ß√£o altamente recomendada.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas espere, isso n√£o √© tudo! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basicamente, examinamos todo o problema, mas se voc√™ estiver interessado em estud√°-lo mais, existem v√°rias extens√µes nas quais n√£o vou mergulhar. Deixo os seguintes exerc√≠cios para o leitor: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, o aquecimento: na solu√ß√£o pelo tempo constante que expus, escolhi arbitrariamente o n√≥ raiz de cada componente conectado. Em particular, eu uso o primeiro n√≥ componente que encontramos. Isso n√£o √© ideal, porque para todos os valores conhecidos escolhemos algum n√≥, embora outro possa estar mais pr√≥ximo do centro, com caminhos mais curtos para todos os outros n√≥s. Sua tarefa √© substituir essa op√ß√£o arbitr√°ria por uma que minimize o n√∫mero de multiplica√ß√µes necess√°rias e minimize a propaga√ß√£o do erro de ponto flutuante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, em todos os argumentos, assumiu-se que todos os caminhos iguais no gr√°fico s√£o iguais inicialmente, o que nem sempre √© o caso. Uma das op√ß√µes interessantes para esse problema √© a convers√£o de moedas: os n√≥s s√£o moedas e as bordas de A a B e vice-versa s√£o os pre√ßos de oferta / demanda de cada par de moedas. Podemos reformular a quest√£o da convers√£o de unidades como uma quest√£o de arbitragem de moeda: implemente um algoritmo que, dado o gr√°fico de convers√£o de moeda, calcule um ciclo no gr√°fico que dar√° ao trader mais dinheiro do que o valor inicial. N√£o inclua nenhuma taxa de transa√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, uma verdadeira j√≥ia: algumas unidades s√£o expressas como uma combina√ß√£o de diferentes unidades base. Por exemplo, um watt √© definido no sistema SI como kg ‚Ä¢ m¬≤ / s¬≥. A tarefa final √© expandir esse sistema para suportar a convers√£o entre essas unidades, levando em considera√ß√£o apenas as defini√ß√µes das unidades b√°sicas de SI. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ tiver alguma d√∫vida, n√£o hesite </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em entrar em contato comigo no reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando comecei a fazer essa tarefa nas entrevistas, esperava que fosse um pouco mais f√°cil do que as anteriores. O experimento teve grande √™xito: se o candidato viu a solu√ß√£o imediatamente, ele geralmente lidava com a tarefa rapidamente, ent√£o t√≠nhamos muito tempo para conversar sobre uma solu√ß√£o avan√ßada com tempo constante. As pessoas que experimentavam dificuldades, via de regra, trope√ßavam em outros lugares al√©m do salto conceitual algor√≠tmico: o candidato n√£o conseguia formular completamente o problema de maneira apropriada ou esbo√ßou uma boa solu√ß√£o, mas n√£o conseguiu traduzi-lo em c√≥digo funcional. N√£o importa onde ou quando eles tenham dificuldades, descobri que poderia obter informa√ß√µes significativas sobre os pontos fortes e fracos dos candidatos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que voc√™ tenha achado este artigo √∫til. </font><font style="vertical-align: inherit;">Entendo que pode n√£o haver tantas aventuras com algoritmos quanto em alguns artigos anteriores. </font><font style="vertical-align: inherit;">Nas entrevistas dos desenvolvedores, √© costume discutir bastante os algoritmos. </font><font style="vertical-align: inherit;">Mas a verdade √© que surgem dificuldades significativas ao usar at√© um m√©todo simples e bem conhecido. </font><font style="vertical-align: inherit;">Todo o c√≥digo est√° no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reposit√≥rio desta s√©rie de artigos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467371/">https://habr.com/ru/post/pt467371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467359/index.html">O PVS-Studio vai para as nuvens: Azure DevOps</a></li>
<li><a href="../pt467361/index.html">Esquecemos a delega√ß√£o em JavaScript. Delega√ß√£o de evento em reagir</a></li>
<li><a href="../pt467363/index.html">Usando fun√ß√µes personalizadas de perda e aprendendo m√©tricas de qualidade no Keras</a></li>
<li><a href="../pt467365/index.html">Rel√©s de monitoramento de tens√£o residencial</a></li>
<li><a href="../pt467369/index.html">RubyRussia 2019. Mikhail Pronyakin: Ruby √© seguro?</a></li>
<li><a href="../pt467375/index.html">Gerenciamento da experi√™ncia do cliente - o que √©?</a></li>
<li><a href="../pt467377/index.html">Tr√™s em linha: os 10 principais relat√≥rios do Mobius 2019 Piter</a></li>
<li><a href="../pt467381/index.html">LEDs de v√°rios andares, luzes inteligentes e l√¢mpadas por 18 rublos</a></li>
<li><a href="../pt467383/index.html">‚ÄúO gerente precisa continuar codificando‚Äù: entrevista com Stephen Chin</a></li>
<li><a href="../pt467385/index.html">Uma sele√ß√£o de perguntas t√©cnicas psicol√≥gicas e at√≠picas em entrevistas com desenvolvedores Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>