<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆗 🏺 🤶🏼 Wie man sich in C und C ++ in den Fuß schießt. Haiku OS Rezeptsammlung 👸 🤜🏽 💂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte des Treffens des statischen Analysators PVS-Studio mit dem Haiku-Betriebssystemcode geht auf das Jahr 2015 zurück. Es war ein interessa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man sich in C und C ++ in den Fuß schießt. Haiku OS Rezeptsammlung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461255/">  Die Geschichte des Treffens des statischen Analysators PVS-Studio mit dem Haiku-Betriebssystemcode geht auf das Jahr 2015 zurück.  Es war ein interessantes Experiment und eine nützliche Erfahrung für die Teams beider Projekte.  Warum ein Experiment?  Damals gab es keinen Analysator für Linux und es wird keine weiteren anderthalb Jahre geben.  Die Arbeit der Enthusiasten unseres Teams wurde jedoch belohnt: Wir haben uns mit den Haiku-Entwicklern getroffen und die Qualität des Codes verbessert, die Datenbank mit seltenen Programmierfehlern aufgefüllt und den Analysator verfeinert.  Das Überprüfen des Haiku-Codes auf Fehler ist jetzt schnell und einfach. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/3b6/925/3a83b6925fff10cf8924920b96996e8d.png" alt="Bild 3"></div><br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Die Helden unserer Geschichte sind das Open-Source-Betriebssystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haiku</a> und der statische Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> für C, C ++, C # und Java.  Als wir vor 4,5 Jahren mit der Analyse des Projekts begannen, mussten wir nur mit der kompilierten ausführbaren Datei des Analysators arbeiten.  Die gesamte Infrastruktur zum Parsen von Kompilierungsparametern, Starten eines Präprozessors, Parallelisieren der Analyse usw.  wurde aus dem Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler Monitoring UI</a> in C # übernommen, das teilweise auf die Mono-Plattform portiert wurde, um unter Linux ausgeführt zu werden.  Das Haiku-Projekt selbst wird mit einem Cross-Compiler unter verschiedenen Betriebssystemen außer Windows erstellt.  Ich möchte noch einmal auf die Bequemlichkeit und Vollständigkeit der Haiku-Baugruppendokumentation hinweisen und mich auch bei den Haiku-Entwicklern für ihre Hilfe beim Aufbau des Projekts bedanken. <br><br>  Jetzt ist die Analyse viel einfacher.  Die Liste aller Befehle zum Erstellen und Analysieren des Projekts sieht folgendermaßen aus: <br><br><pre><code class="cpp hljs">cd /opt git clone https:<span class="hljs-comment"><span class="hljs-comment">//review.haiku-os.org/buildtools git clone https://review.haiku-os.org/haiku cd ./haiku mkdir generated.x86_64; cd generated.x86_64 ../configure --distro-compatibility official -j12 \ --build-cross-tools x86_64 ../../buildtools cd ../../buildtools/jam make all cd /opt/haiku/generated.x86_64 pvs-studio-analyzer trace -- /opt/buildtools/jam/bin.linuxx86/jam \ -q -j1 @nightly-anyboot pvs-studio-analyzer analyze -l /mnt/svn/PVS-Studio.lic -r /opt/haiku \ -C x86_64-unknown-haiku-gcc -o /opt/haiku/haiku.log -j12</span></span></code> </pre> <br>  Die Analyse des Projekts wurde übrigens im Docker-Container durchgeführt.  Kürzlich haben wir eine neue Dokumentation zu diesem Thema vorbereitet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausführen von PVS-Studio in Docker</a> .  Dies kann die Verwendung statischer Projektanalysetechniken für einige Unternehmen erheblich vereinfachen. <br><br><h2>  Nicht initialisierte Variablen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V614</a> Nicht initialisierte Variable 'rval' verwendet.  fetch.c 1727 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auto_fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argpos; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval; <span class="hljs-comment"><span class="hljs-comment">// &lt;= argpos = 0; if (sigsetjmp(toplevel, 1)) { if (connected) disconnect(0, NULL); if (rval &gt; 0) // &lt;= rval = argpos + 1; return (rval); } .... }</span></span></code> </pre> <br>  Die Variable <i>rval wurde</i> beim Deklarieren nicht initialisiert. Wenn Sie sie also mit einem Nullwert vergleichen, erhalten Sie ein undefiniertes Ergebnis.  Wenn die Umstände fehlschlagen, wird der undefinierte Wert der Variablen <i>rval</i> möglicherweise zum Rückgabewert der Funktion <i>auto_fetch</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V614</a> Nicht initialisierter Zeiger 'res' verwendet.  Befehle.c 2873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_family; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_socktype; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_protocol; <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> ai_addrlen; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ai_canonname; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_next</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sourceroute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct addrinfo *ai, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **cpp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *protop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *optp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span> + ALIGNBYTES]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, *cp2, *lsrp, *ep; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> *_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sin</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> INET6 struct sockaddr_in6 *sin6; struct ip6_rthdr *rth; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> struct addrinfo hints, *res; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= int error; char c; if (cpp == NULL || lenp == NULL) return -1; if (*cpp != NULL) { switch (res-&gt;ai_family) { // &lt;= case AF_INET: if (*lenp &lt; 7) return -1; break; .... } } .... }</span></span></span></span></code> </pre> <br>  Ein ähnlicher Fall der Verwendung einer nicht initialisierten Variablen, nur hier ist der nicht initialisierte Zeiger <i>res</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V506 Der</a> Zeiger auf die lokale Variable 'normalisiert' wird außerhalb des Bereichs dieser Variablen gespeichert.  Ein solcher Zeiger wird ungültig.  TextView.cpp 5596 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BTextView::_ApplyStyleRange(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BFont* font, ....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (font != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { BFont normalized = *font; _NormalizeFont(&amp;normalized); font = &amp;normalized; } .... fStyles-&gt;SetStyleRange(fromOffset, toOffset, fText-&gt;Length(), mode, font, color); }</code> </pre> <br>  Wahrscheinlich musste der Programmierer das Objekt durch eine Zwischenvariable normalisieren.  Jetzt wurde im <i>Schriftzeiger</i> der Zeiger auf das <i>normalisierte</i> temporäre Objekt <i>gespeichert</i> , der zerstört wird, nachdem der Bereich verlassen wurde, in dem dieses temporäre Objekt erstellt wurde. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V603</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 27 <br><br><pre> <code class="cpp hljs">int8 BUnicodeChar::Type(uint32 c) { BUnicodeChar(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u_charType(c); }</code> </pre> <br>  Ein sehr häufiger Fehler unter C ++ - Programmierern besteht darin, den Konstruktoraufruf zu verwenden, um angeblich die Klassenfelder zu initialisieren / auf Null zu setzen.  In diesem Fall werden die Felder der Klasse nicht geändert, es wird jedoch ein neues unbenanntes Objekt dieser Klasse erstellt, das sofort zerstört wird.  Leider gibt es viele solcher Orte: <br><br><ul><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 37 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 49 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 58 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 67 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 77 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 89 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 103 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 115 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 126 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 142 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 152 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 163 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 186 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 196 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 206 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 214 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 222 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V670</a> Das nicht initialisierte Klassenmitglied 'fPatternHandler' wird verwendet, um das 'fInternal'-Mitglied zu initialisieren.  Denken Sie daran, dass Mitglieder in der Reihenfolge ihrer Deklarationen innerhalb einer Klasse initialisiert werden.  Painter.cpp 184 <br><br><pre> <code class="cpp hljs">Painter::Painter() : fInternal(fPatternHandler), .... fPatternHandler(), .... { .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Painter</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> PainterAggInterface fInternal; <span class="hljs-comment"><span class="hljs-comment">// line 336 bool fSubpixelPrecise : 1; bool fValidClipping : 1; bool fDrawingText : 1; bool fAttached : 1; bool fIdentityTransform : 1; Transformable fTransform; float fPenSize; const BRegion* fClippingRegion; drawing_mode fDrawingMode; source_alpha fAlphaSrcMode; alpha_function fAlphaFncMode; cap_mode fLineCapMode; join_mode fLineJoinMode; float fMiterLimit; PatternHandler fPatternHandler; // line 355 mutable AGGTextRenderer fTextRenderer; };</span></span></code> </pre> <br>  Ein weiteres Beispiel für eine falsche Initialisierung.  Klassenfelder werden in der Reihenfolge initialisiert, in der sie in der Klasse selbst deklariert sind.  In diesem Beispiel wird das <i>interne</i> Feld zuerst mit dem nicht initialisierten Wert <i>fPatternHandler</i> initialisiert. <br><br><h2>  Verdächtig #define </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V523</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  subr_gtaskqueue.c 191 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_LOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_lock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_lock(&amp;(tq)-&gt;tq_mutex); \ } while (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_ASSERT_LOCKED(tq) mtx_assert(&amp;(tq)-&gt;tq_mutex, MA_OWNED) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_UNLOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_unlock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_unlock(&amp;(tq)-&gt;tq_mutex); \ } while (0) void grouptask_block(struct grouptask *grouptask) { .... TQ_LOCK(queue); gtask-&gt;ta_flags |= TASK_NOENQUEUE; gtaskqueue_drain_locked(queue, gtask); TQ_UNLOCK(queue); }</span></span></code> </pre> <br>  Das Code-Snippet sieht erst dann verdächtig aus, wenn Sie sich das Ergebnis des Präprozessors ansehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grouptask_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct grouptask *grouptask)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); gtask-&gt;ta_flags |= <span class="hljs-number"><span class="hljs-number">0x4</span></span>; gtaskqueue_drain_locked(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>, gtask); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Der Analysator hat wirklich Recht - die <i>if-</i> und <i>else-</i> Zweige sind identisch.  Aber wohin gingen die Funktionen <i>mtx_lock_spin</i> und <i>mtx_unlock_spin</i> ?  Die Makros <i>TQ_LOCK</i> , <i>TQ_UNLOCK</i> und die Funktion <i>grouptask_block werden</i> in derselben Datei deklariert und fast nebeneinander, es gab jedoch irgendwo eine Ersetzung. <br><br>  Eine Suche nach dem Inhalt der Dateien ergab nur <i>mutex.h</i> mit folgendem Inhalt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* on FreeBSD these are different functions */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_lock_spin(x) mtx_lock(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_unlock_spin(x) mtx_unlock(x)</span></span></code> </pre> <br>  Ob eine solche Ersetzung korrekt ist oder nicht, sollte für die Projektentwickler überprüft werden.  Ich habe das Projekt unter Linux überprüft, und eine solche Ersetzung schien mir verdächtig. <br><br><h2>  Fehler mit der freien Funktion </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> Der Nullzeiger wird an die Funktion 'frei' übergeben.  Überprüfen Sie das erste Argument.  setmime.cpp 727 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MimeType::_PurgeProperties() { fShort.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fLong.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefApp.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefAppSig.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fSniffRule.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fSmallIcon; fSmallIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fBigIcon; fBigIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; fVectorIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(fVectorIcon); // &lt;= fExtensions.clear(); fAttributes.clear(); }</span></span></code> </pre> <br>  Sie können einen Nullzeiger an die <i>freie</i> Funktion übergeben, aber ein solcher Eintrag ist eindeutig verdächtig.  Der Analysator fand also die verwirrten Codezeilen.  Zuerst mussten Sie den Speicher mit dem Zeiger <i>fVectorIcon freigeben</i> und erst dann auf <i>NULL setzen</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> Der Nullzeiger wird an die Funktion 'frei' übergeben.  Überprüfen Sie das erste Argument.  driver_settings.cpp 461 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> settings_handle * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_driver_settings_from_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *driverName)</span></span></span><span class="hljs-function"> </span></span>{ .... handle = new_settings(text, driverName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// everything went fine! return handle; } free(handle); // &lt;= .... }</span></span></code> </pre> <br>  Ein weiteres Beispiel für die explizite Übergabe eines Nullzeigers an die <i>freie</i> Funktion.  Diese Zeile kann gelöscht werden, weil  Nach erfolgreichem Empfang des Zeigers wird die Funktion beendet. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> Der Nullzeiger wird an die Funktion 'frei' übergeben.  Überprüfen Sie das erste Argument.  PackageFileHeapWriter.cpp 166 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _GetBuffer() { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(fBufferSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; !fBuffers.AddItem(buffer)) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; }</code> </pre> <br>  Hier ist ein Fehler.  Anstelle des Operators &amp;&amp; muss der Operator || verwendet werden.  Nur in diesem Fall wird eine Ausnahme <i>std :: bad_alloc () ausgelöst,</i> wenn es nicht möglich war, Speicher mit der Funktion <i>malloc</i> zuzuweisen. <br><br><h2>  Fehler mit Löschoperator </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V611</a> Der Speicher wurde mit dem Operator 'new T []' zugewiesen, aber mit dem Operator 'delete' freigegeben.  Überprüfen Sie diesen Code.  Es ist wahrscheinlich besser, 'delete [] fMsg;' zu verwenden.  Err.cpp 65 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Err</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fMsg; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> fPos; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Err::Unset() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fMsg; <span class="hljs-comment"><span class="hljs-comment">// &lt;= fMsg = __null; fPos = -1; } void Err::SetMsg(const char *msg) { if (fMsg) { delete fMsg; // &lt;= fMsg = __null; } if (msg) { fMsg = new(std::nothrow) char[strlen(msg)+1]; // &lt;= if (fMsg) strcpy(fMsg, msg); } }</span></span></code> </pre> <br>  Der <i>fMsg-</i> Zeiger <i>wird</i> verwendet, um Speicher zum Speichern eines Array von Zeichen zuzuweisen, und der <i>Löschoperator</i> wird verwendet, um Speicher <i>freizugeben</i> , anstatt <i>delete []</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V611</a> Der Speicher wurde mit dem Operator 'new' zugewiesen, aber mit der Funktion 'free' freigegeben.  Überprüfen Sie die Operationslogik hinter der Variablen 'wrapperPool'.  vm_page.cpp 3080 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> vm_page_write_modified_page_range(....) { .... PageWriteWrapper* wrapperPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper[maxPages + <span class="hljs-number"><span class="hljs-number">1</span></span>]; PageWriteWrapper** wrappers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper*[maxPages]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapperPool == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || wrappers == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(wrapperPool); <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(wrappers); // &lt;= wrapperPool = stackWrappersPool; wrappers = stackWrappers; maxPages = 1; } .... }</span></span></code> </pre> <br>  Hier ist <i>malloc_flags</i> die Funktion, die <i>malloc</i> macht.  Und dann konstruiert <i>Placement-New</i> das Objekt hier.  Und da die <i>PageWriteWrapper-</i> Klasse wie folgt implementiert ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageWriteWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PageWriteWrapper(); ~PageWriteWrapper(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm_page* page)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">status_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> result)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: vm_page* fPage; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VMCache</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fCache</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsActive; }; PageWriteWrapper::PageWriteWrapper() : fIsActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } PageWriteWrapper::~PageWriteWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsActive) panic(<span class="hljs-string"><span class="hljs-string">"page write wrapper going out of scope but isn't completed"</span></span>); }</code> </pre> <br>  dann werden Objektdestruktoren dieser Klasse aufgrund der Verwendung der <i>freien</i> Funktion zum Freigeben von Speicher nicht aufgerufen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V611</a> Der Speicher wurde mit dem Operator 'new T []' zugewiesen, aber mit dem Operator 'delete' freigegeben.  Überprüfen Sie diesen Code.  Es ist wahrscheinlich besser, 'delete [] fOutBuffer;' zu verwenden.  Überprüfen Sie die Zeilen: 26, 45. PCL6Rasterizer.h 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PCL6Rasterizer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... ~PCL6Rasterizer() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fOutBuffer; fOutBuffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fOutBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uchar[fOutBufferSize]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: uchar* fOutBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fOutBufferSize; };</code> </pre> <br>  Die Verwendung des <i>Löschoperators</i> anstelle von <i>delete []</i> ist ein sehr häufiger Fehler.  Der einfachste Weg, beim Schreiben einer Klasse einen Fehler zu machen, ist  Der Destruktorcode befindet sich häufig weit entfernt von den Speicherzuordnungsorten.  Hier gibt der Programmierer durch den Zeiger <i>fOutBuffer</i> fälschlicherweise Speicher im Destruktor <i>frei</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V772 Das</a> Aufrufen eines Löschoperators für einen ungültigen Zeiger führt zu undefiniertem Verhalten.  Hashtable.cpp 207 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hashtable::MakeEmpty(int8 keyMode,int8 valueMode) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (entry = fTable[index]; entry; entry = next) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (keyMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HASH_EMPTY_DELETE: <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete (void*)entry-&gt;key; break; case HASH_EMPTY_FREE: free((void*)entry-&gt;key); break; } switch (valueMode) { case HASH_EMPTY_DELETE: // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete entry-&gt;value; break; case HASH_EMPTY_FREE: free(entry-&gt;value); break; } next = entry-&gt;next; delete entry; } .... }</span></span></code> </pre> <br>  Zusätzlich zur falschen Wahl zwischen <i>delete</i> / <i>delete []</i> und <i>free</i> können Sie dem Programm auf andere Weise undefiniertes Verhalten hinzufügen - versuchen Sie, den Speicher durch einen Zeiger auf einen undefinierten Typ <i>(void *)</i> zu löschen. <br><br><h2>  Funktionen ohne Rückgabewert </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V591</a> Non-void-Funktion sollte einen Wert zurückgeben.  Referenceable.h 228 <br><br><pre> <code class="cpp hljs">BReference&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BReference&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type&gt;&amp; other) { fReference = other.fReference; }</code> </pre> <br>  Der überschriebene Zuweisungsoperator hat nicht genügend Rückgabewert.  In diesem Fall gibt der Bediener einen zufälligen Wert zurück, was zu seltsamen Fehlern führen kann. <br><br>  Ähnliche Probleme in anderen Codefragmenten dieser Klasse: <br><br><ul><li>  V591 Non-void-Funktion sollte einen Wert zurückgeben.  Referenceable.h 233 </li><li>  V591 Non-void-Funktion sollte einen Wert zurückgeben.  Referenceable.h 239 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V591</a> Non-void-Funktion sollte einen Wert zurückgeben.  main.c 1010 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, ...)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getoptionvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with NULL name"</span></span>); c = getoption(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c-&gt;value); errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with unknown option '%s'"</span></span>, name); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> }</code> </pre> <br>  Ein NOTREACHED-Benutzerkommentar bedeutet hier nichts.  Um Code für solche Szenarien korrekt zu schreiben, müssen Sie Funktionen wie noreturn markieren.  Hierfür gibt es noreturn-Attribute: standard- und compilerspezifisch.  Zuallererst werden solche Attribute von Compilern für die korrekte Codegenerierung oder Benachrichtigung über einige Arten von Fehlern mithilfe von Warings berücksichtigt.  Verschiedene statische Analysewerkzeuge berücksichtigen auch Attribute, um die Analysequalität zu verbessern. <br><br><h2>  Ausnahmebehandlung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V596</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schlüsselwort 'throw' könnte fehlen: throw ParseException (FOO);  Response.cpp 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Response::ExtractNumber(BDataIO&amp; stream) { BString <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = ExtractString(stream); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* end; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> number = strtoul(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.String(), (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>**)&amp;end, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || end[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) ParseException(<span class="hljs-string"><span class="hljs-string">"Invalid number!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number; }</code> </pre> <br>  Hier wird das Schlüsselwort <i>throw</i> versehentlich vergessen.  Daher wird eine <i>ParseException</i> nicht <i>ausgelöst</i> , und ein Objekt dieser Klasse wird einfach zerstört, wenn es den Bereich verlässt.  Danach setzt die Funktion ihre Arbeit fort, als wäre nichts passiert, als wäre die richtige Nummer eingegeben worden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1022</a> Eine Ausnahme wurde vom Zeiger ausgelöst.  Ziehen Sie es stattdessen nach Wert.  gensyscallinfos.cpp 316 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Main().Run(argc, argv); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception&amp; exception) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= fprintf(stderr, "%s\n", exception.what()); return 1; } } int Run(int argc, char** argv) { .... _ParseSyscalls(argv[1]); .... } void _ParseSyscalls(const char* filename) { ifstream file(filename, ifstream::in); if (!file.is_open()) throw new IOException(string("Failed to open '") + filename + "'."); // &lt;= .... }</span></span></code> </pre> <br>  Der Analysator hat eine vom Zeiger ausgelöste <i>IOException</i> erkannt.  Wenn Sie einen Zeiger werfen, wird die Ausnahme nicht abgefangen, sodass die Ausnahme schließlich als Referenz abgefangen wird.  Die Verwendung eines Zeigers zwingt den Interceptor außerdem, den <i>Löschoperator</i> aufzurufen, um das erstellte Objekt zu zerstören, was ebenfalls nicht erfolgt. <br><br>  Zwei weitere Problembereiche des Codes: <br><br><ul><li>  V1022 Eine Ausnahme wurde vom Zeiger ausgelöst.  Ziehen Sie es stattdessen nach Wert.  gensyscallinfos.cpp 347 </li><li>  V1022 Eine Ausnahme wurde vom Zeiger ausgelöst.  Ziehen Sie es stattdessen nach Wert.  gensyscallinfos.cpp 413 </li></ul><br><h2>  Formale Sicherheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'f_key' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SAFE_FREE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAFE_FREE(a) \ do{</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(a != NULL){memset(a,0, sizeof(*a)); free(a); a=NULL;}} while (0) .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DST_KEY * dst_free_key(DST_KEY *f_key) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key == NULL) return (f_key); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_func &amp;&amp; f_key-&gt;dk_func-&gt;destroy) f_key-&gt;dk_KEY_struct = f_key-&gt;dk_func-&gt;destroy(f_key-&gt;dk_KEY_struct); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { EREPORT((</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dst_free_key(): Unknown key alg %d\n"</span></span></span><span class="hljs-meta">, f_key-&gt;dk_alg)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_KEY_struct) { free(f_key-&gt;dk_KEY_struct); f_key-&gt;dk_KEY_struct = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_key_name) SAFE_FREE(f_key-&gt;dk_key_name); SAFE_FREE(f_key); return (NULL); }</span></span></code> </pre> <br>  Der Analysator hat verdächtigen Code erkannt, mit dem private Daten sicher bereinigt werden können.  Leider macht das <i>SAFE_FREE-</i> Makro, das zu <i>Memset</i> , <i>kostenlosen</i> Aufrufen und <i>NULL-</i> Zuweisung erweitert wurde, den Code nicht sicherer, weil  All dies wird vom Compiler während der <i>O2-</i> Optimierung entfernt. <br><br>  Dies ist übrigens nichts anderes als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-14</a> : Compiler-Entfernung von Code zum Löschen von Puffern. <br><br>  Die gesamte Liste der Stellen, an denen Puffer nicht gelöscht werden: <br><br><ul><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'encoded_block' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 446 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'key_st' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 685 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'in_buff' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 916 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ce' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  fs_cache.c 1078 </li></ul><br><h2>  Vorzeichenlose Vergleiche </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547 Der</a> Ausdruck 'verbleibend &lt;0' ist immer falsch.  Der vorzeichenlose Typwert ist niemals &lt;0. DwarfFile.cpp 1947 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> DwarfFile::_UnwindCallFrame(....) { .... uint64 remaining = lengthOffset + length - dataReader.Offset(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_BAD_DATA; .... }</code> </pre> <br>  Der Analysator fand einen expliziten Vergleich einer vorzeichenlosen Variablen mit negativen Werten.  Vielleicht sollten Sie die <i>verbleibende</i> Variable <i>mit</i> nur Null vergleichen oder eine Überlaufprüfung durchführen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547 Der</a> Ausdruck 'sleep ((unsigned) secs) &lt;0' ist immer falsch.  Der vorzeichenlose Typwert ist niemals &lt;0. Misc.cpp 56 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> snooze(<span class="hljs-keyword"><span class="hljs-keyword">bigtime_t</span></span> amount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_OK; int64 secs = amount / <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; int64 usecs = amount % <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (secs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sleep((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)secs) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return errno; } if (usecs &gt; 0) { if (usleep((useconds_t)usecs) &lt; 0) return errno; } return B_OK; }</span></span></code> </pre> <br>  Um zu verstehen, was der Fehler ist, wenden wir uns den Signaturen der <i>Schlaf-</i> und <i>Schlaffunktionen zu</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __seconds)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">__useconds_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __useconds)</span></span></span></span>;</code> </pre> <br>  Wie wir sehen können, gibt die <i>Sleep-</i> Funktion einen Wert eines vorzeichenlosen Typs zurück und seine Verwendung im Code ist falsch. <br><br><h2>  Gefährliche Hinweise </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V774</a> Der Zeiger 'Gerät' wurde verwendet, nachdem der Speicher freigegeben wurde.  xhci.cpp 1572 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> XHCI::FreeDevice(Device *device) { uint8 slot = fPortSlots[device-&gt;HubPort()]; TRACE(<span class="hljs-string"><span class="hljs-string">"FreeDevice() port %d slot %d\n"</span></span>, device-&gt;HubPort(), slot); <span class="hljs-comment"><span class="hljs-comment">// Delete the device first, so it cleans up its pipes and tells us // what we need to destroy before we tear down our internal state. delete device; DisableSlot(slot); fDcba-&gt;baseAddress[slot] = 0; fPortSlots[device-&gt;HubPort()] = 0; // &lt;= delete_area(fDevices[slot].trb_area); delete_area(fDevices[slot].input_ctx_area); delete_area(fDevices[slot].device_ctx_area); memset(&amp;fDevices[slot], 0, sizeof(xhci_device)); fDevices[slot].state = XHCI_STATE_DISABLED; }</span></span></code> </pre> <br>  Ein <i>Geräteobjekt</i> wird vom <i>Löschoperator gelöscht</i> .  Dies ist eine logische Aktion für eine Funktion namens <i>FreeDevice</i> .  Um jedoch aus irgendeinem Grund andere Ressourcen im Code freizugeben, wird erneut ein bereits gelöschtes Objekt angesprochen. <br><br>  Ein solcher Code ist äußerst gefährlich und kommt an mehreren anderen Stellen vor: <br><br><ul><li>  V774 Der 'Selbst'-Zeiger wurde verwendet, nachdem der Speicher freigegeben wurde.  TranslatorRoster.cpp 884 </li><li>  V774 Der 'String'-Zeiger wurde verwendet, nachdem der Speicher freigegeben wurde.  RemoteView.cpp 1269 </li><li>  V774 Der Zeiger 'bs' wurde verwendet, nachdem der Speicher freigegeben wurde.  mkntfs.c 4291 </li><li>  V774 Der Zeiger 'bs' wurde verwendet, nachdem der Speicher freigegeben wurde.  mkntfs.c 4308 </li><li>  V774 Der 'al'-Zeiger wurde verwendet, nachdem der Speicher neu zugewiesen wurde.  inode.c 1155 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V522 Eine</a> Dereferenzierung des Nullzeigers 'Daten' kann stattfinden.  Der Nullzeiger wird an die Funktion 'malo_hal_send_helper' übergeben.  Untersuchen Sie das dritte Argument.  Überprüfen Sie die Zeilen: 350, 394. if_malohal.c 350 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malo_hal_fwload_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct malo_hal *mh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *helper)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* tell the card we're done and... */</span></span> error = malo_hal_send_helper(mh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, MALO_NOWAIT); <span class="hljs-comment"><span class="hljs-comment">// &lt;= NULL .... } static int malo_hal_send_helper(struct malo_hal *mh, int bsize, const void *data, size_t dsize, int waitfor) { mh-&gt;mh_cmdbuf[0] = htole16(MALO_HOSTCMD_CODE_DNLD); mh-&gt;mh_cmdbuf[1] = htole16(bsize); memcpy(&amp;mh-&gt;mh_cmdbuf[4], data , dsize); // &lt;= data .... }</span></span></code> </pre> <br>  Die interprozedurale Analyse ergab eine Situation, in der <i>NULL</i> an die Funktion übergeben wird und der Datenzeiger mit diesem Wert anschließend in der <i>memcpy-</i> Funktion dereferenziert wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773</a> Die Funktion wurde beendet, ohne den Zeiger 'inputFileFile' freizugeben.  Ein Speicherverlust ist möglich.  command_recompress.cpp 119 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command_recompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv)</span></span></span><span class="hljs-function"> </span></span>{ .... BFile* inputFileFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BFile; error = inputFileFile-&gt;SetTo(inputPackageFileName, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != B_OK) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: Failed to open input file \"%s\": %s\n"</span></span>, inputPackageFileName, strerror(error)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } inputFile = inputFileFile; .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio kann Speicherlecks erkennen</a> .  Hier wird im Falle eines Fehlers kein Speicher für <i>inputFileFile</i> freigegeben.  Jemand glaubt, dass Sie sich im Fehlerfall nicht darum kümmern können, Speicher freizugeben - das Programm endet trotzdem.  Dies ist jedoch nicht immer der Fall.  Behandeln Sie Fehler richtig und arbeiten Sie weiter - eine Voraussetzung für so viele Programme. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> Der Zeiger 'fReply' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 49, 52. ReplyBuilder.cpp 49 <br><br><pre> <code class="cpp hljs">RPC::CallbackReply* ReplyBuilder::Reply() { fReply-&gt;Stream().InsertUInt(fStatusPosition, _HaikuErrorToNFS4(fStatus)); fReply-&gt;Stream().InsertUInt(fOpCountPosition, fOpCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fReply == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || fReply-&gt;Stream().Error() == B_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fReply; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Wie oft dereferenzieren Entwickler Zeiger, bevor sie sie überprüfen.  Diagnostics <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595 ist</a> fast immer führend in der Anzahl der Warnungen in einem Projekt.  Die gefährliche Verwendung des <i>fReply-</i> Zeigers in diesem Code. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> Der Zeiger 'mq' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 782, 786. oce_queue.c 782 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oce_mq_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct oce_mq *mq)</span></span></span><span class="hljs-function"> </span></span>{ POCE_SOFTC sc = (POCE_SOFTC) mq-&gt;parent; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oce_mbx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx_destroy_common_mq</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fwcmd</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mq) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Ein ähnliches Beispiel.  Der <i>mg-</i> Zeiger wird einige Zeilen früher dereferenziert, als er auf einen Nullwert überprüft wird.  Es gibt viele ähnliche Stellen im Projekt.  An einigen Stellen ist die Verwendung und Überprüfung von Zeigern weit voneinander entfernt, sodass der Artikel zwei Beispiele enthält.  Der Rest kann die Entwickler im vollständigen Analysebericht sehen. <br><br><h2>  Verschiedene Fehler </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V645</a> Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_acpi_namespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acpi_ns_device_info *device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indenting)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> output[<span class="hljs-number"><span class="hljs-number">320</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tabs[<span class="hljs-number"><span class="hljs-number">255</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... strlcat(tabs, <span class="hljs-string"><span class="hljs-string">"|--- "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tabs)); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { uint32 type = device-&gt;acpi-&gt;get_object_type(result); <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(output, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output), <span class="hljs-string"><span class="hljs-string">"%s%s"</span></span>, tabs, result + depth); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_INTEGER: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" INTEGER"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_STRING: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" STRING"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... } .... }</code> </pre> <br>  Der Unterschied zwischen den <i>Funktionen</i> <i>strlcat</i> und <i>strncat ist</i> für eine Person, die mit der Beschreibung dieser Funktionen noch nicht <i>vertraut ist,</i> nicht ganz offensichtlich.  Die Funktion <i>strlcat</i> verwendet die <b>Größe des gesamten Puffers</b> als drittes Argument, und die Funktion <i>strncat</i> verwendet <i>die</i> <b>Größe des freien Speicherplatzes im Puffer</b> , für den vor dem Aufruf der Funktion der gewünschte Wert berechnet werden muss.  Aber Entwickler vergessen es oft oder wissen es nicht.  Das Übergeben der <i>strncat-</i> Funktion <i>an die</i> Größe des gesamten Puffers kann zu einem Pufferüberlauf führen, weil  Die Funktion betrachtet diesen Wert als die Anzahl der Zeichen, die zum Kopieren zugelassen sind.  Die <i>strlcat-</i> Funktion <i>hat</i> dieses Problem nicht, aber damit es richtig funktioniert, müssen Zeichenfolgen übergeben werden, die mit Terminal Null enden. <br><br>  Die ganze Liste gefährlicher Orte mit Linien: <br><br><ul><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 104 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 107 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 110 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 113 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 118 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 119 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 120 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 123 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 126 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 129 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 132 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 135 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 138 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 141 </li><li> V645 The 'strncat' function call could lead to the 'output' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. NamespaceDump.cpp 144 </li><li> V645 The 'strncat' function call could lead to the 'features_string' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. VirtioDevice.cpp 283 </li><li> V645 The 'strncat' function call could lead to the 'features_string' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold. VirtioDevice.cpp 284 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'features_string' führen. </font><font style="vertical-align: inherit;">Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann. </font><font style="vertical-align: inherit;">VirtioDevice.cpp 285</font></font></li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V792</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Funktion 'SetDecoratorSettings' befindet sich rechts vom Operator '|' </font><font style="vertical-align: inherit;">wird unabhängig vom Wert des linken Operanden aufgerufen. </font><font style="vertical-align: inherit;">Vielleicht ist es besser, '||' zu verwenden. </font><font style="vertical-align: inherit;">DesktopListener.cpp 324</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DesktopListener</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DoublyLinkedListLinkImpl&lt;DesktopListener&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDecoratorSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Window* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BMessage&amp; settings)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DesktopObservable::SetDecoratorSettings(Window* window, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BMessage&amp; settings) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fWeAreInvoking) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">InvokeGuard </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeGuard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fWeAreInvoking)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (DesktopListener* listener = fDesktopListenerList.First(); listener != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; listener = fDesktopListenerList.GetNext(listener)) changed = changed | listener-&gt;SetDecoratorSettings(window, settings); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> changed; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Höchstwahrscheinlich sind die Operatoren '|' </font><font style="vertical-align: inherit;">und '||'. </font><font style="vertical-align: inherit;">Ein solcher Fehler führt zu unnötigen Aufrufen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetDecoratorSettings-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V627</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Überprüfen Sie den Ausdruck. </font><font style="vertical-align: inherit;">Das Argument von sizeof () ist das Makro, das zu einer Zahl erweitert wird. </font><font style="vertical-align: inherit;">device.c 72</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCI_line_size 0x0c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* (1 byte) cache line size in 32 bit words */</span></span></span><span class="hljs-meta"> static status_t wb840_open(const char* name, uint32 flags, void** cookie) { .... data-&gt;wb_cachesize = gPci-&gt;read_pci_config(data-&gt;pciInfo-&gt;bus, data-&gt;pciInfo-&gt;device, data-&gt;pciInfo-&gt;function, PCI_line_size, sizeof(PCI_line_size)) &amp; 0xff; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfer des Betreibers </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sizeof</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sieht verdächtig. </font><font style="vertical-align: inherit;">Vielleicht sollten Sie die Größe eines Objekts berechnen, z. B. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist seltsam, einen Wert vom Typ Bool mit einem Wert von 18 zu vergleichen: 0x12 == IsProfessionalSpdif (). </font><font style="vertical-align: inherit;">CEchoGals_mixer.cpp 533</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BOOL; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsProfessionalSpdif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ECHOSTATUS_DSP_DEAD 0x12 ECHOSTATUS CEchoGals::ProcessMixerFunction(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( ECHOSTATUS_DSP_DEAD == IsProfessionalSpdif() ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= { Status = ECHOSTATUS_DSP_DEAD; } else { pMixerFunction-&gt;Data.bProfSpdif = IsProfessionalSpdif(); } .... }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsProfessionalSpdif-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">gibt einen Wert vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool zurück</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , während unter der Bedingung das Ergebnis der Funktion mit der Zahl </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x12</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verglichen </font><i><font style="vertical-align: inherit;">wird</font></i><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Veröffentlichung der ersten Haiku Beta im letzten Herbst verpasst waren damit beschäftigt, PVS-Studio für die Java-Sprache freizugeben. Die Art der Programmiererfehler ist jedoch so, dass sie nur dann auftreten, wenn Sie nach ihnen suchen und die Qualität des Codes überhaupt nicht beachten. Die Entwickler haben versucht, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coverity Scan zu verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber der letzte Durchlauf der Analyse war vor fast zwei Jahren. Dies sollte Haiku-Benutzer verärgern. Obwohl die Analyse mit Coverity im Jahr 2014 konfiguriert wurde, hat uns dies nicht davon abgehalten, 2015 zwei große Artikel mit Fehlerprüfungen zu schreiben ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diejenigen, die bis zum Ende gelesen haben, warten auf eine weitere Überprüfung des Haiku-Codes von nicht weniger Volumen mit neuen Arten von Fehlern. </font><font style="vertical-align: inherit;">Vor dem Veröffentlichen von Codeüberprüfungen wird ein vollständiger Analysebericht an die Entwickler gesendet, sodass einige Fehler behoben werden können. </font><font style="vertical-align: inherit;">Um die Zeit zwischen den Veröffentlichungen zu vertreiben, empfehle ich, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für Ihr Projekt </font><font style="vertical-align: inherit;">herunterzuladen und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">auszuprobieren</font></a><font style="vertical-align: inherit;"> .</font></font><br><br>  Möchten Sie Haiku ausprobieren und haben Sie Fragen?  Haiku-Entwickler laden Sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal ein</a> . <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man sich in C und C ++ in den Fuß schießt.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haiku OS Kochbuch</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461255/">https://habr.com/ru/post/de461255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461243/index.html">Gehen Sie nicht nach Afrika spazieren: Wie ist die Situation mit der Internet-Zensur auf dem schwarzen Kontinent?</a></li>
<li><a href="../de461247/index.html">50 beste Quellen zum Produktmanagement zum Lesen, Hören und Anschauen</a></li>
<li><a href="../de461249/index.html">Schreiben einer Android App für Filmfans - Teil 2 (Design)</a></li>
<li><a href="../de461251/index.html">Eine Auswahl nützlicher Folien von Julia Evans</a></li>
<li><a href="../de461253/index.html">Wie man sich in C und C ++ in den Fuß schießt. Haiku OS Kochbuch</a></li>
<li><a href="../de461257/index.html">Wie berechnet man den ROI aus der Testautomatisierung mit Selen?</a></li>
<li><a href="../de461259/index.html">Lagerparty, 8. August, Moskau</a></li>
<li><a href="../de461261/index.html">Checkliste nützlicher RRC-Webinare zu RRC-Produkten</a></li>
<li><a href="../de461265/index.html">Über den Missbrauch der Verwendung des Betriebssystems in Projekten für Mikrocontroller</a></li>
<li><a href="../de461267/index.html">Neue Intel-Technologien für Chip-Verpackungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>