<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜 📙 👨🏾‍🔬 Berjongkok di bayang-bayang atau mencari dunia berikutnya 🔎 👟 🙏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Assembler adalah bahasa favorit saya ... tetapi hidup ini sangat singkat. 
 Saya melanjutkan siklus penelitian saya pada bayangan yang cocok untuk beb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berjongkok di bayang-bayang atau mencari dunia berikutnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446986/"><img src="https://habrastorage.org/webt/d-/wj/wu/d-wjwubdpihumypc3b7tv43ihzy.png"><br><blockquote>  Assembler adalah bahasa favorit saya ... tetapi hidup ini sangat singkat. </blockquote><br>  Saya melanjutkan siklus penelitian saya pada bayangan yang cocok untuk beberapa bagel.  Setelah publikasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya</a> mendinginkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekali</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua kali</a> untuk topik ini, tetapi efek dari tindakan tidak lengkap mendorong saya untuk kembali ke puing-puing piksel, dan menyelesaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gestalt</a> . <br><br>  Mengenali diri saya, saya yakin bahwa gim ini tidak akan mendapatkan perwujudannya, tetapi mungkin beberapa publik akan tertarik pada pencapaian saya di jalur yang sulit ini.  Jadi mari kita mulai. <br><a name="habracut"></a><br>  Pada akhir siklus terakhir, saya sampai pada pemahaman bahwa menghitung grafik pada CPU sudah merupakan abad terakhir, tetapi kegigihan alami bersikeras: tidak semua kemungkinan digunakan, masih ada pilihan untuk solusi menarik. <br><br>  Pelacakan ray tetap tidak diterapkan.  Lebih tepatnya, jenisnya, di mana untuk setiap piksel gambar (blok piksel) sebuah sinar tersebar dan tingkat iluminasi dari titik saat ini ditentukan.  Algoritme itu sendiri dijelaskan dalam artikel sebelumnya dan tidak ada gunanya mengembalikannya.  Untuk penelusuran sinar balik, kode ini bahkan lebih disederhanakan, semua trigonometri sepenuhnya dihapus, yang di masa depan bisa memberikan hasil yang dapat diterima. <br><br><div class="spoiler">  <b class="spoiler_title">Pascal</b> <div class="spoiler_text"><pre><code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tile_size = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   tile_size1 : single = 0.03125; // 1/32 -    block_size = 4; // /    Size_X:Byte = 32; //    X Size_Y:Byte = 24; //    Y //--------------------------------- function is_no_empty(x,y:Integer):Integer; begin if (x&gt;=0) AND (x&lt;Size_X) AND (y&gt;=0) AND (y&lt;Size_Y) then begin if map[x,y]=1 then begin is_no_empty:=1; end else if map[x,y]=2 then begin is_no_empty:=2; end else is_no_empty:=0; end else is_no_empty:=-1; end; //--------------------------------- function crossing(r_view, x,y:Single; xi,yj, i,j:Integer):Byte; var di,dj,ddi,ddj :Shortint; //   k,i2,j2 :integer; //    key:Boolean; last_k, transp_key :Byte; sum_lenX,sum_lenY, Dx,Dy,Dx1,DY1, l :Single; //  sec1,cosec1, temp_x,temp_y, dx0,dy0 :Single; //   i0,j0 :Integer; //       begin temp_x := i*block_size; temp_y := j*block_size; i0 := trunc(temp_x * tile_size1); j0 := trunc(temp_y * tile_size1); l := sqrt(sqr(temp_y-y) + sqr(temp_x-x)) + 0.0000001; transp_key := 0; //     if is_no_empty(xi,yj)&gt;0 then inc(transp_key); if (xi=i0) and (yj=j0) then begin crossing := min(255,transp_key*64+ l * r_view); exit; end; dx0 := (temp_x-x)/l+0.0000001; dy0 := (temp_y-y)/l+0.0000001; key := False; last_k :=0; //   if dx0&lt;0 then begin di :=-1; ddi:= 0; end else begin di := 1; ddi:= 1; end; if dy0&lt;0 then begin dj :=-1; ddj:= 0; end else begin dj := 1; ddj:= 1; end; sum_lenX := 0; sum_lenY := 0; sec1 := 1/dx0; cosec1 := 1/dy0; //       Y temp_x := x-(xi+ddi) * tile_size ; temp_y := y-(yj+ddj) * tile_size ; Dx := sqrt(sqr(temp_x) + sqr(temp_x * sec1 * dy0)); DY := sqrt(sqr(temp_y) + sqr(temp_y * cosec1 * dx0)); //      Y Dx1 := abs(tile_size * sec1); Dy1 := abs(tile_size * cosec1); repeat if sum_lenX+DX &lt; sum_lenY+DY then begin xi += di; k := is_no_empty(xi,yj); sum_lenX += DX; if DX&lt;&gt;Dx1 then DX := Dx1; end else begin yj += dj; k := is_no_empty(xi,yj); sum_lenY += DY; if DY&lt;&gt;Dy1 then DY := Dy1; end; if key Then begin if (xi&lt;&gt;i2) Or (yj&lt;&gt;j2) then begin //  (  ) if last_k=1 then begin crossing := 255; exit; end; //   (  ) if transp_key&gt;2 then begin crossing := 255; exit; end; inc(transp_key); key:= false; end; end; if k&gt;0 then begin i2:=xi; j2:=yj; key:=true; last_k:=k; end; //    if (xi=i0) and (yj=j0) then begin crossing := min(255, transp_key*64+ l * r_view); exit; end; until k=-1; //     end; //--------------------------------- .................. x0:= mouse_x; y0:= mouse_y; //       x1 := x0 div tile_size; y1 := y0 div tile_size; koef := tile_size div block_size; //      (     ) for j:=0 to Size_Y * koef do for i:=0 to Size_X * koef do picture_mask.SetPixel(i, j, BGRA(0,0,0,crossing(x0, y0, x1, y1, i, j))); ..................</span></span></code> </pre> <br></div></div><br>  Sayangnya, hasilnya jauh lebih buruk dari yang diharapkan, layak menyebarkan gambar ke layar penuh, FPS mencari unit. <br><br><img src="https://habrastorage.org/webt/to/b_/sa/tob_sau5axwf2lhnxxfswnfuuv8.png"><br><br>  Pengelompokan piksel ke blok makro untuk mengurangi perhitungan dan menerapkan penghalusan berikutnya tidak banyak meningkatkan kinerja.  Efeknya terus terang tidak menyukai kata itu sama sekali. <br><br><img src="https://habrastorage.org/webt/hj/s5/sr/hjs5srli3gslf1yuerzb8b2kjq4.png"><br><br>  Algoritma itu paralel sempurna, tetapi tidak masuk akal untuk menggunakan banyak aliran, efeknya tampak jauh lebih buruk daripada di artikel sebelumnya, bahkan dengan kualitas gambar yang lebih baik. <br>  Ternyata jalan buntu.  Harus saya akui, CPU dalam perhitungan grafik di mata saya telah habis sendiri.  Tirai. <br><br><div class="spoiler">  <b class="spoiler_title">Digresi 1</b> <div class="spoiler_text">  Selama dekade terakhir, hampir tidak ada kemajuan dalam pengembangan prosesor tujuan umum.  Jika didekati oleh pengguna, maka peningkatan kinerja maksimum yang terlihat tidak lebih dari 30% per inti.  Kemajuan, secara halus, tidak signifikan.  Jika kita menghilangkan ekstensi panjang instruksi vektor, dan beberapa percepatan blok konveyor, ini merupakan peningkatan jumlah core yang bekerja.  Pekerjaan aman dengan utas masih menyenangkan, dan tidak semua tugas dapat diparalelkan dengan sukses.  Saya ingin memiliki inti yang berfungsi, meskipun satu, tetapi jika demikian, itu 5-10 lebih cepat, tetapi sayangnya dan oh, seperti kata mereka. <br>  Di sini, di Habré ada serangkaian artikel yang sangat baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Kehidupan di era silikon" gelap ",</a> yang menjelaskan beberapa prasyarat untuk keadaan saat ini, tetapi juga kembali dari surga ke bumi.  Dalam dekade berikutnya, Anda tidak dapat mengharapkan peningkatan yang signifikan dalam komputasi per inti.  Tetapi kita bisa mengharapkan pengembangan lebih lanjut dari jumlah core GPU dan akselerasi keseluruhannya.  Bahkan di laptop lama saya, perkiraan total kinerja GPU adalah 20 kali lebih tinggi dari satu thread CPU.  Bahkan jika Anda secara efektif memuat semua 4 inti prosesor, itu jauh lebih sedikit daripada yang kita inginkan. <br>  Saya memberi penghormatan kepada para pengembang grafis masa lalu, yang membuat karya agung mereka tanpa akselerator perangkat keras, master sejati. <br></div></div><br>  Jadi, kami berurusan dengan GPU.  Ternyata agak tak terduga bagi saya bahwa dalam praktik nyata, hanya sedikit orang yang menyebarkan poligon.  Semua hal menarik dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader</a> .  Setelah membuang mesin 3D yang sudah jadi, saya mencoba mempelajari jeroan teknologi karena berada pada level yang dalam.  Prosesor yang sama adalah assembler yang sama, hanya beberapa set instruksi terpotong dan spesifik pekerjaan mereka sendiri.  Untuk tes, saya berhenti di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLSL</a> , sebuah sintaksis seperti C, kesederhanaan, banyak pelajaran dan contoh pelatihan, termasuk Habr. <br>  Karena saya kebanyakan terbiasa menulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pascal</a> , tugasnya adalah bagaimana menghubungkan OpenGL <br>  ke proyek.  Saya berhasil menemukan dua cara untuk terhubung: perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLFW</a> dan file header <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dglOpenGL</a> .  Satu-satunya hal yang pertama kali saya tidak dapat menghubungkan shader, tetapi tampaknya ini adalah dari kelengkungan tangan saya. <br><br><div class="spoiler">  <b class="spoiler_title">Digresi 2</b> <div class="spoiler_text">  Banyak teman bertanya kepada saya mengapa saya menulis dalam Pascal?  Jelas, ini adalah bahasa yang terancam punah, komunitasnya terus berjatuhan, hampir tidak ada perkembangan.  Insinyur sistem tingkat rendah lebih suka C, dan Java, Python, Ruby, atau apa pun yang ada di puncaknya sekarang. <br>  Bagi saya, Pascal mirip dengan cinta pertama.  Dua dekade yang lalu, pada zaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Turbo Pascal 5.5</a> , ia tenggelam dalam jiwa saya dan telah berjalan bersama saya sejak saat itu, baik itu Delphi atau dalam beberapa tahun terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lazarus</a> .  Saya suka prediktabilitas bahasa, level relatif rendah (assembler menyisipkan dan melihat instruksi prosesor), kompatibilitas dengan C. Yang utama adalah bahwa kode dirakit dan dieksekusi tanpa masalah, tetapi tidak modis, ketinggalan jaman, dan ada beberapa fitur, ini omong kosong.  Rumor mengatakan, ada orang yang masih menulis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LISP</a> , tetapi kepadanya secara umum selama setengah abad. <br></div></div><br>  Jadi, mari selami perkembangannya.  Untuk langkah uji, kami tidak akan mengambil model bayangan realistis yang akurat, tetapi mencoba menerapkan apa yang sudah kami coba sebelumnya, tetapi dengan kinerja GPU, jadi untuk perbandingan yang jelas. <br><br>  Awalnya, saya berpikir untuk mendapatkan bayangan sekitar bentuk ini, menggunakan segitiga untuk objek. <br><br><img src="https://habrastorage.org/webt/up/ps/la/uppslarm4raiqopjfumiogecono.png"><br><br>  Untuk membuat efek lingkaran halus, Anda membutuhkan banyak poligon.  Tapi bagaimana jika Anda menggunakan segitiga seminimal mungkin, menggunakan pixel shader untuk membuat lubang pada bentuknya.  Ide itu muncul di benak saya setelah membaca sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh seorang</a> master yang disegani, di mana kesempatan dibuka untuk menciptakan sebuah bola dengan shader. <br><br><img src="https://habrastorage.org/webt/ph/hu/tg/phhutg9hwan_hlukufz4twdjp7i.png"><br><br>  Jika Anda memperpanjang segitiga di luar batas layar, maka hasilnya adalah ini: <br><br><img src="https://habrastorage.org/webt/80/tm/wy/80tmwydb6qratckw2hzzqpdanxk.png"><br><br>  Perbatasan bayangan ternyata sangat kaku dan juga melangkah.  Tetapi ada cara bagaimana mendapatkan hasil yang dapat diterima tanpa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">supersampling</a> , ini menggunakan batas yang dihaluskan.  Untuk melakukan ini, ubah skema sedikit.  Sudut poligon di persimpangan garis singgung ke lingkaran akan menjadi transparan. <br><br><img src="https://habrastorage.org/webt/r7/er/bg/r7erbgdvqlaxcwrtp7im6m6j97u.png"><br><br>  Hasilnya lebih baik, tetapi masih terlihat tidak alami. <br><br><img src="https://habrastorage.org/webt/k9/r8/qw/k9r8qw-kcrabolq1vqyqgvr5b8o.png"><br><br>  Tambahkan sedikit penghalusan lingkaran untuk memberikan kelembutan, dan juga ubah bentuk gradien dari linier menjadi daya. <br><br><img src="https://habrastorage.org/webt/s9/mo/a2/s9moa2rhsslrktn808o2cwoxiwy.png"><br><br>  Ini adalah hasil yang dapat diterima. <br>  Dan pada akhirnya kita akan menambahkan objek meniru rintangan ke formulir. <br><br><img src="https://habrastorage.org/webt/fo/f8/4c/fof84cbrg5n_kea_4k9js5tiqi4.png"><br><br><div class="spoiler">  <b class="spoiler_title">Kode shader</b> <div class="spoiler_text"> <code>//   <br> <br> #version 330 core <br> layout (location = 0) in vec2 aVertexPosition; <br> void main(void) { <br> gl_Position = vec4(aVertexPosition.xy, 0, 1.0); <br> } <br> <br> //   <br> <br> #version 330 core <br> layout (points) in; <br> layout (triangle_strip, max_vertices = 5) out; <br> uniform mat4 uModelViewMatrix; <br> uniform float uRadius; <br> uniform vec2 uHeroPoint; <br> out float fTransparency; <br> out vec2 vCenter; <br> void main(){ <br> vCenter = gl_in[0].gl_Position.xy; <br> vec2 d = uHeroPoint - vCenter; <br> float l = length(d); <br> float i = uRadius / l; <br> float ii = i*i; <br> float ij = i * sqrt(1 - ii); <br> vec2 p1 = vec2(vCenter.x + dx*ii - dy*ij , vCenter.y + dx*ij + dy*ii); <br> vec2 p2 = vec2(vCenter.x + dx*ii + dy*ij , vCenter.y - dx*ij + dy*ii); <br> d = uHeroPoint - p1; <br> vec2 p3 = vec2(p1 - d/length(d)*1000000); <br> d = uHeroPoint - p2; <br> vec2 p4 = vec2(p2 - d/length(d)*1000000); <br> fTransparency = 0; <br> gl_Position = uModelViewMatrix * vec4(p1, 0, 1); <br> EmitVertex(); <br> fTransparency = 1; <br> gl_Position = uModelViewMatrix * vec4(p3, 0, 1); <br> EmitVertex(); <br> gl_Position = uModelViewMatrix * vec4(vCenter, 0, 1); <br> EmitVertex(); <br> gl_Position = uModelViewMatrix * vec4(p4, 0, 1); <br> EmitVertex(); <br> fTransparency = 0; <br> gl_Position = uModelViewMatrix * vec4(p2, 0, 1); <br> EmitVertex(); <br> EndPrimitive(); <br> } <br> <br> //   <br> <br> #version 330 core <br> precision mediump float; <br> varying float fTransparency; <br> varying vec2 vCenter; <br> uniform float uRadius; <br> uniform vec2 uScreenHalfSize; <br> uniform float uShadowTransparency; <br> uniform float uShadowSmoothness; <br> out vec4 FragColor; <br> void main(){ <br> float l = distance(vec2((gl_FragCoord.xy - uScreenHalfSize.xy)/uScreenHalfSize.y), vCenter.xy); <br> if (l&lt;uRadius) {discard;} <br> else {FragColor = vec4(0, 0, 0, min(pow(fTransparency, uShadowSmoothness), (l-uRadius)/uRadius*10)*uShadowTransparency);} <br> } <br></code> <br></div></div><br>  Saya harap ini informatif <br><br>  Hamba rendah hati Anda, penyiksa piksel, Pembangun Ulang. <br><br>  Saya melampirkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> kecil.  (EXE Windows) <br><br>  PS Judul artikel berisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telur Paskah</a> , referensi ke trilogi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Siala Chronicle</a> .  Sebuah karya luar biasa dalam gaya fantasi, tentang kemalangan tanduk, dari Alexei Pekhov. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446986/">https://habr.com/ru/post/id446986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446976/index.html">Paradoks Kompresi Data</a></li>
<li><a href="../id446978/index.html">Game seperti breakuot di PIC12F1572</a></li>
<li><a href="../id446980/index.html">Cara menerbitkan game seluler dan tidak melakukan kesalahan</a></li>
<li><a href="../id446982/index.html">Lulusan pusat CS kembali untuk mengajar</a></li>
<li><a href="../id446984/index.html">Peras analog Space Invaders menjadi 1 kilobyte (asli 1978 membutuhkan 8)</a></li>
<li><a href="../id446988/index.html">Bagaimana saya mengajar Scala</a></li>
<li><a href="../id446990/index.html">Input Delay pada Konsol Retro dan Emulator</a></li>
<li><a href="../id446992/index.html">John Maeda: "Sebenarnya, desain tidak begitu penting"</a></li>
<li><a href="../id446994/index.html">Ruang sebagai memori yang tidak jelas</a></li>
<li><a href="../id446996/index.html">Metode Pomodoro tidak sekeren mungkin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>