<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ô üöå üêá Entwicklung visueller Tests basierend auf Gemini und Storybook ‚èØÔ∏è üïµüèº üòØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! In diesem Artikel m√∂chte ich die Erfahrungen mit der Entwicklung visueller Tests in unserem Team teilen. 

 So kam es, dass wir nicht sofo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung visueller Tests basierend auf Gemini und Storybook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454464/">  Hallo Habr!  In diesem Artikel m√∂chte ich die Erfahrungen mit der Entwicklung visueller Tests in unserem Team teilen. <br><br>  So kam es, dass wir nicht sofort √ºber Layout-Tests nachdachten.  Nun, ein Frame bewegt sich f√ºr ein paar Pixel nach au√üen.  Am Ende gibt es Tester - die Fliege fliegt nicht an ihnen vorbei.  Der menschliche Faktor l√§sst sich jedoch immer noch nicht t√§uschen - das Erkennen geringf√ºgiger √Ñnderungen in der Benutzeroberfl√§che ist selbst f√ºr einen Tester bei weitem nicht immer physisch m√∂glich.  Die Frage stellte sich, als mit einer ernsthaften Optimierung des Layouts und dem √úbergang zu BEM begonnen wurde.  Hier w√§re es sicherlich nicht verlustfrei gewesen, und wir brauchten dringend eine automatisierte Methode, um Situationen zu erkennen, in denen sich aufgrund von √Ñnderungen etwas in der Benutzeroberfl√§che nicht wie beabsichtigt oder nicht dort √§ndert, wo es beabsichtigt war. <br><a name="habracut"></a><br>  Jeder Entwickler kennt sich mit Unit-Code-Tests aus.  Unit-Tests geben die Gewissheit, dass √Ñnderungen im Code nichts kaputt gemacht haben.  Nun, zumindest haben sie den Teil, f√ºr den es Tests gibt, nicht gebrochen.  Das gleiche Prinzip kann auf die Benutzeroberfl√§che angewendet werden.  So wie Unit-Tests Testklassen testen, testen visuelle Tests die visuellen Komponenten, aus denen die Benutzeroberfl√§che einer Anwendung besteht. <br><br>  F√ºr visuelle Komponenten k√∂nnen Sie ‚Äûklassische‚Äú Komponententests schreiben, die beispielsweise das Rendern von Komponenten mit unterschiedlichen Werten von Eingabeparametern initiieren und den erwarteten Status des DOM-Baums mithilfe von assert-Anweisungen √ºberpr√ºfen, indem Sie entweder einzelne Elemente oder eine Momentaufnahme des DOM-Baums der Komponente mit der Referenz vergleichen im Allgemeinen.  Visuelle Tests basieren ebenfalls auf Schnappsch√ºssen, jedoch bereits auf Schnappsch√ºssen der visuellen Anzeige der Komponente (Screenshots).  Der Kern des visuellen Tests besteht darin, das w√§hrend des Tests aufgenommene Bild mit dem Referenzbild zu vergleichen und, wenn Unterschiede festgestellt werden, entweder das neue Bild als Referenzbild zu akzeptieren oder den Fehler zu beheben, der diese Unterschiede verursacht hat. <br><br>  Nat√ºrlich ist das ‚ÄûScreening‚Äú einzelner visueller Komponenten nicht sehr effektiv.  Die Komponenten leben nicht in einem Vakuum und ihre Anzeige kann entweder von den Komponenten der obersten Ebene oder von benachbarten Komponenten abh√§ngen.  Unabh√§ngig davon, wie wir einzelne Komponenten testen, kann das gesamte Bild M√§ngel aufweisen.  Wenn Sie dagegen Bilder des gesamten Anwendungsfensters aufnehmen, enthalten viele der Bilder dieselben Komponenten. Wenn Sie also eine Komponente √§ndern, m√ºssen wir alle Bilder aktualisieren, in denen diese Komponente vorhanden ist. <br><br>  Die Wahrheit liegt wie √ºblich irgendwo in der Mitte - Sie k√∂nnen die gesamte Seite der Anwendung zeichnen, aber nur einen Bereich fotografieren, unter dem der Test erstellt wird. In dem speziellen Fall kann dieser Bereich mit dem Bereich einer bestimmten Komponente √ºbereinstimmen, dies ist jedoch keine Komponente in Vakuum, aber in einer sehr realen Umgebung.  Und dies wird bereits einem visuellen Einheitentest √§hneln, obwohl √ºber Modularit√§t kaum etwas gesagt werden kann, wenn die ‚ÄûEinheit‚Äú etwas √ºber die Umgebung wei√ü.  Okay, es ist nicht so wichtig, ob die Kategorie der Tests visuelle Tests umfasst - modular oder integriert.  Wie das Sprichwort sagt: "Sie √ºberpr√ºfen oder gehen?" <br><br><h2>  Werkzeugauswahl </h2><br>  Um die Ausf√ºhrung von Tests zu beschleunigen, kann das Rendern von Seiten in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kopflosen Browser durchgef√ºhrt werden</a> , der die gesamte Arbeit im Speicher erledigt, ohne auf dem Bildschirm angezeigt zu werden, und maximale Leistung bietet.  In unserem Fall war es jedoch wichtig sicherzustellen, dass die Anwendung in Internet Explorer (IE) funktioniert, das keinen Headless-Modus hat, und wir brauchten ein Tool zum programmgesteuerten Verwalten von Browsern.  Gl√ºcklicherweise wurde bereits alles vor uns erfunden und es gibt ein solches Instrument - es hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selen</a> .  Im Rahmen des Selenium-Projekts werden Treiber f√ºr die Verwaltung verschiedener Browser entwickelt, einschlie√ülich eines Treibers f√ºr den Internet Explorer.  Selenium Server k√∂nnen Browser nicht nur lokal, sondern auch remote verwalten und bilden einen Cluster von Selenium Servern, das sogenannte Selenium Grid. <br><br>  Selen ist ein m√§chtiges Werkzeug, aber die Schwelle f√ºr den Eintritt ist ziemlich hoch.  Wir haben uns entschlossen, nach vorgefertigten Werkzeugen f√ºr visuelle Tests auf der Basis von Selen zu suchen, und sind auf ein wunderbares Produkt von Yandex namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gemini gesto√üen</a> .  Zwillinge k√∂nnen Bilder aufnehmen, einschlie√ülich Bilder eines bestimmten Bereichs der Seite, Bilder mit Referenzbildern vergleichen, den Unterschied visualisieren und Momente wie Anti-Aliasing oder einen blinkenden Cursor ber√ºcksichtigen.  Dar√ºber hinaus kann Gemini gefallene Tests wiederholen, die Ausf√ºhrung von Tests parallelisieren und viele andere Extras.  Im Allgemeinen haben wir beschlossen, es zu versuchen. <br><br>  Zwillingstests sind einfach zu schreiben.  Zuerst m√ºssen Sie die Infrastruktur vorbereiten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selenium-Standalone</a> installieren und den Selenium-Server starten.  Konfigurieren Sie anschlie√üend gemini, geben Sie die Adresse der zu testenden Anwendung (rootUrl), die Adresse des Selenservers (gridUrl), die Zusammensetzung und Konfiguration der Browser sowie die erforderlichen Plugins zum Generieren von Berichten an und optimieren Sie die Bildkomprimierung.  Konfigurationsbeispiel: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//.gemini.js module.exports = { rootUrl: 'http://my-app.ru', gridUrl: 'http://127.0.0.1:4444/wd/hub', browsers: { chrome: { windowSize: '1920x1080', screenshotsDir:'gemini/screens/1920x1080' desiredCapabilities: { browserName: 'chrome' } } }, system: { projectRoot: '', plugins: { 'html-reporter/gemini': { enabled: true, path: './report' }, 'gemini-optipng': true }, exclude: [ '**/report/*' ], diffColor: '#EC041E' } };</span></span></code> </pre> <br>  Die Tests selbst sind eine Sammlung von Suiten, in denen jeweils ein oder mehrere Bilder (Zust√§nde) aufgenommen werden.  Bevor Sie einen Snapshot (Capture () -Methode) erstellen, k√∂nnen Sie den Bereich der zu fotografierenden Seite mit der setCaptureElements () -Methode festlegen und gegebenenfalls im Browserkontext einige vorbereitende Aktionen ausf√ºhren, indem Sie entweder die Methoden des Aktionsobjekts oder beliebigen JavaScript-Code verwenden - f√ºr Dies in Aktionen hat eine executeJS () -Methode. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'login-dialog'</span></span>, suite =&gt; { suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.login__form'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'default'</span></span>); .capture(<span class="hljs-string"><span class="hljs-string">'focused'</span></span>, actions =&gt; actions.focus(<span class="hljs-string"><span class="hljs-string">'.login__editor'</span></span>)); });</code> </pre> <br><h2>  Testdaten </h2><br>  Ein Testwerkzeug wurde ausgew√§hlt, aber es war noch ein langer Weg bis zur endg√ºltigen L√∂sung.  Es war notwendig zu verstehen, was mit den auf den Bildern angezeigten Daten zu tun ist.  Ich m√∂chte Sie daran erinnern, dass wir uns bei den Tests entschieden haben, nicht einzelne Komponenten, sondern die gesamte Seite der Anwendung zu zeichnen, um die visuellen Komponenten nicht im Vakuum, sondern in der realen Umgebung anderer Komponenten zu testen.  Wenn Sie die erforderlichen Testdaten an ee- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Requisiten √ºbertragen m√ºssen</a> (ich spreche von Reaktionskomponenten), um eine einzelne Komponente zu rendern, ist viel mehr erforderlich, um die gesamte Seite der Anwendung zu rendern, und die Vorbereitung der Umgebung f√ºr einen solchen Test kann Kopfschmerzen bereiten. <br><br>  Nat√ºrlich k√∂nnen Sie die Anwendung selbst verlassen, um die Daten zu empfangen, sodass sie w√§hrend des Tests Anforderungen an das Backend ausf√ºhrt, die wiederum Daten aus einer Art Referenzdatenbank empfangen w√ºrden, aber was ist mit der Versionierung?  Sie k√∂nnen keine Datenbank in ein Git-Repository stellen.  Nein, nat√ºrlich k√∂nnen Sie, aber es gibt einige Anstand. <br><br>  Um Tests auszuf√ºhren, k√∂nnen Sie alternativ den realen Backend-Server durch einen gef√§lschten ersetzen, wodurch die Webanwendung keine Daten aus der Datenbank erh√§lt, sondern statische Daten, die beispielsweise im JSON-Format bereits mit den Quellen gespeichert sind.  Die Aufbereitung solcher Daten ist jedoch auch nicht zu trivial.  Wir haben uns f√ºr den einfacheren Weg entschieden - nicht die Daten vom Server abzurufen, sondern einfach den Status der Anwendung (in unserem Fall den Status des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux-Speichers</a> ) wiederherzustellen, der sich zum Zeitpunkt der Aufnahme des Referenzbilds in der Anwendung befand, bevor der Test ausgef√ºhrt wurde. <br><br>  Um den aktuellen Status des Redux-Speichers zu serialisieren, wurde dem Fensterobjekt die Methode snapshot () hinzugef√ºgt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snapshotStore = (store: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">fileName</span></span>: string): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = store.getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob( [ <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(state, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } ); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); a.href = URL.createObjectURL(file); a.download = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${fileName}</span></span></span><span class="hljs-string">.testdata.json`</span></span>; a.click(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`State downloaded to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a.download}</span></span></span><span class="hljs-string">`</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.snapshot = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> snapshotStore(store, fileName); };</code> </pre><br>  Mit dieser Methode k√∂nnen Sie √ºber die Befehlszeile der Browserkonsole den aktuellen Status des Redux-Speichers in einer Datei speichern: <br><br><img src="https://habrastorage.org/webt/qf/t0/yq/qft0yqppzfe_issnjy74jon-vbs.png" alt="Bild"><br><br>  Als Infrastruktur f√ºr visuelle Tests wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Storybook</a> ausgew√§hlt - ein Tool f√ºr die interaktive Entwicklung von Bibliotheken visueller Komponenten.  Die Hauptidee war, anstelle der verschiedenen Zust√§nde der Komponenten im Storys-Baum die verschiedenen Zust√§nde unserer Anwendung zu korrigieren und diese Zust√§nde zum Erstellen von Screenshots zu verwenden.  Letztendlich gibt es keinen grundlegenden Unterschied zwischen einfachen und komplexen Komponenten, au√üer bei der Vorbereitung der Umgebung. <br><br>  Jeder visuelle Test ist also eine Geschichte, vor deren Rendern der Status des zuvor in der Datei gespeicherten Redux-Speichers wiederhergestellt wird.  Dies erfolgt mithilfe der Provider-Komponente aus der React-Redux-Bibliothek, an deren Store-Eigenschaft der aus der zuvor gespeicherten Datei wiederhergestellte deserialisierte Status √ºbergeben wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preloadedState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./incoming-letter.testdata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(rootReducer, preloadedState); storiesOf(<span class="hljs-string"><span class="hljs-string">'regression/Cards'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) .add(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContextContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...dummyProps</span></span></span></span><span class="xml"><span class="hljs-tag">}/&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); });</span></span></code> </pre><br>  Im obigen Beispiel ist ContextContainer eine Komponente, die das "Grundger√ºst" der Anwendung enth√§lt - den Navigationsbaum, den Header und den Inhaltsbereich.  Im Inhaltsbereich k√∂nnen je nach aktuellem Status des Redux-Speichers verschiedene Komponenten gerendert werden (Liste, Karte, Dialog usw.).  Damit die Komponente keine unn√∂tigen Anforderungen an das Backend zur Eingabe erf√ºllt, werden entsprechende Stub-Eigenschaften an sie √ºbergeben. <br><br>  Im Kontext eines Storybooks sieht es ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/jx/0m/ux/jx0muxytucrqrwzpvtnskjuqs1a.png" alt="Bild"><br><br><h2>  Zwillinge + M√§rchenbuch </h2><br>  Also haben wir die Daten f√ºr die Tests herausgefunden.  Die n√§chste Aufgabe ist es, sich mit Gemini und Storybook anzufreunden.  Auf den ersten Blick ist alles einfach - in der Gemini-Konfiguration geben wir die Adresse der zu testenden Anwendung an.  In unserem Fall ist dies die Adresse des Storybook-Servers.  Sie m√ºssen nur den Storybook-Server hochfahren, bevor Sie mit den Gemini-Tests beginnen.  Sie k√∂nnen dies direkt aus dem Code heraus mit dem Gemini-Ereignisabonnement START_RUNNER und END_RUNNER tun: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">6006</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cofiguration = { <span class="hljs-attr"><span class="hljs-attr">rootUrl</span></span>:<span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">gridUrl</span></span>: seleniumGridHubUrl, <span class="hljs-attr"><span class="hljs-attr">browsers</span></span>: { <span class="hljs-string"><span class="hljs-string">'chrome'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">screenshotsDir</span></span>:<span class="hljs-string"><span class="hljs-string">'gemini/screens'</span></span>, <span class="hljs-attr"><span class="hljs-attr">desiredCapabilities</span></span>: chromeCapabilities } } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Gemini = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HttpServer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http-server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> runner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gemini(cofiguration); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = HttpServer.createServer({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: <span class="hljs-string"><span class="hljs-string">'./storybook-static'</span></span>}); runner.on(runner.events.START_RUNNER, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`storybook server is listening on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">...`</span></span>); server.listen(port); }); runner.on(runner.events.END_RUNNER, () =&gt; { server.close(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'storybook server is closed'</span></span>); }); runner .readTests(path) .done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests));</code> </pre> <br>  Als Server f√ºr Tests haben wir den http-Server verwendet, der den Inhalt des Ordners mit dem statisch zusammengestellten Storybook zur√ºckgibt (um das statische Storybook zu erstellen, verwenden Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehl build-storybook</a> ). <br><br>  Bisher lief alles reibungslos, aber die Probleme haben sich nicht warten lassen.  Tatsache ist, dass das Bilderbuch die Geschichte innerhalb des Rahmens anzeigt.  Urspr√ºnglich wollten wir den selektiven Bereich des Bildes mit setCaptureElements () festlegen k√∂nnen. Dies ist jedoch nur m√∂glich, wenn Sie die Frame-Adresse als Adresse f√ºr die Suite angeben. <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'http://localhost:6006/iframe.html?selectedKind=regression%2Fcards&amp;selectedStory=IncomingLetter'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.some-component'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>) );</code> </pre><br>  Aber dann stellt sich heraus, dass wir f√ºr jede Aufnahme unsere eigene Suite erstellen m√ºssen, weil  Die URL kann f√ºr die gesamte Suite festgelegt werden, jedoch nicht f√ºr einen einzelnen Snapshot innerhalb der Suite.  Es versteht sich, dass jede Suite in einer separaten Browsersitzung ausgef√ºhrt wird.  Dies ist im Prinzip richtig - die Tests sollten nicht voneinander abh√§ngen, aber das √ñffnen einer separaten Browsersitzung und das anschlie√üende Laden des Storybooks nimmt viel Zeit in Anspruch, viel mehr als nur das Durchlaufen von Storys im Rahmen des bereits ge√∂ffneten Storybooks.  Daher ist bei einer gro√üen Anzahl von Suiten die Testausf√ºhrungszeit sehr langsam.  Ein Teil des Problems kann durch Parallelisierung der Testausf√ºhrung gel√∂st werden, die Parallelisierung verbraucht jedoch viele Ressourcen (Speicher, Prozessor).  Nachdem wir uns entschlossen hatten, Ressourcen zu sparen und gleichzeitig w√§hrend des Testlaufs nicht zu viel zu verlieren, lehnten wir es ab, den Frame in einem separaten Browserfenster zu √∂ffnen.  Tests werden in einer einzelnen Browsersitzung durchgef√ºhrt, aber vor jeder Aufnahme wird die n√§chste Story in den Frame geladen, als h√§tten wir gerade das Storybook ge√∂ffnet und auf einzelne Knoten im Storys-Baum geklickt.  Bildbereich - gesamter Rahmen: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'ProjectDocument'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'ProjectDocumentAccess'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>, actions =&gt; { openStory(actions, <span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>); hover(actions, <span class="hljs-string"><span class="hljs-string">'.related-documents-tree-item__title'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }) );</code> </pre> <br>  Leider haben wir bei dieser Option neben der M√∂glichkeit, den Bildbereich auszuw√§hlen, auch die M√∂glichkeit verloren, Standardaktionen der Gemini-Engine f√ºr die Arbeit mit Elementen des DOM-Baums (mouseDown (), mouseMove (), focus () usw.) usw. zu verwenden. zu.  Elemente innerhalb des Gemini-Rahmens sehen nicht.  Wir haben aber weiterhin die M√∂glichkeit, die Funktion executeJS () zu verwenden, mit der Sie JavaScript-Code in einem Browserkontext ausf√ºhren k√∂nnen.  Basierend auf dieser Funktion haben wir die Analoga der von uns ben√∂tigten Standardaktionen implementiert, die bereits im Kontext des Storybook-Frames funktionieren.  Hier mussten wir ein wenig ‚Äûzaubern‚Äú, um Parameterwerte aus dem Testkontext in den Browserkontext zu √ºbertragen - executeJS () bietet leider keine solche M√∂glichkeit.  Daher sieht der Code auf den ersten Blick etwas seltsam aus - die Funktion wird in eine Zeichenfolge √ºbersetzt, ein Teil des Codes wird durch Parameterwerte ersetzt und in ExecuteJs () wird die Funktion mit eval () aus der Zeichenfolge wiederhergestellt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openStory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, storyName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> storyNameLowered = storyName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickTo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).filter( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.textContent.toLowerCase() === <span class="hljs-string"><span class="hljs-string">'storyNameLowered'</span></span>; })[<span class="hljs-number"><span class="hljs-number">0</span></span>].click(); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clickTo.toString().replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'storyNameLowered'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, storyNameLowered)}</span></span></span><span class="hljs-string">)`</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, targets, index, events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelector(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>).contentWindow.document; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'targets'</span></span>)[index || <span class="hljs-number"><span class="hljs-number">0</span></span>]; events.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickEvent = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent(<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>); clickEvent.initEvent(event, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); target.dispatchEvent(clickEvent); }); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dispatch.toString() .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'targets'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, targets) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'index'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, index) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'events'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`["</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${events.join(</span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'","'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">)}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"]`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">)`</span></span> )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hover</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, selectors, index</span></span></span><span class="hljs-function">) </span></span>{ dispatchEvents(actions, selectors, index, [ <span class="hljs-string"><span class="hljs-string">'mouseenter'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseover'</span></span> ]); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">openStory</span></span>: openStory, <span class="hljs-attr"><span class="hljs-attr">hover</span></span>: hover };</code> </pre><br><h2>  Wiederholungen der Ausf√ºhrung </h2><br>  Nachdem die visuellen Tests geschrieben wurden und zu arbeiten begannen, stellte sich heraus, dass einige der Tests nicht sehr stabil waren.  Irgendwo hat das Symbol keine Zeit zum Zeichnen, irgendwo wird die Auswahl nicht entfernt und wir erhalten eine Nicht√ºbereinstimmung mit dem Referenzbild.  Daher wurde beschlossen, Wiederholungstests der Testausf√ºhrung aufzunehmen.  In Gemini funktionieren Wiederholungsversuche jedoch f√ºr die gesamte Suite. Wie oben erw√§hnt, haben wir versucht, Situationen zu vermeiden, in denen f√ºr jede Aufnahme eine Suite erstellt wird. Dies verlangsamt die Ausf√ºhrung von Tests zu sehr.  Auf der anderen Seite ist die Wahrscheinlichkeit, dass die wiederholte Ausf√ºhrung der Suite ebenso wie die vorherige abf√§llt, umso gr√∂√üer, je mehr Aufnahmen im Rahmen einer Suite gemacht werden.  Daher war es notwendig, Wiederholungsversuche durchzuf√ºhren.  In unserem Schema wird die Ausf√ºhrung nicht f√ºr die gesamte Suite wiederholt, sondern nur f√ºr die Bilder, die den vorherigen fehlgeschlagenen Lauf nicht weitergegeben haben.  Zu diesem Zweck analysieren wir im TEST_RESULT-Ereignishandler das Ergebnis des Vergleichs des Snapshots mit dem Standard. F√ºr die Snapshots, die den Vergleich nicht bestanden haben, erstellen wir nur f√ºr sie eine neue Suite: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SuiteCollection = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite-collection'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Suite = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retrySuiteCollection; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; runner.on(runner.events.BEGIN, () =&gt; { retrySuiteCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuiteCollection(); }); runner.on(runner.events.TEST_RESULT, args =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testId = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.state.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.suite.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.browserId}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.equal) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.yellow(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suite = retrySuiteCollection.topLevelSuites().find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.suite.name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite) { suite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Suite(args.suite.name); suite.url = args.suite.url; suite.file = args.suite.file; suite.path = args.suite.path; suite.captureSelectors = [ ...args.suite.captureSelectors ]; suite.browsers = [ ...args.suite.browsers ]; suite.skipped = [ ...args.suite.skipped ]; suite.beforeActions = [ ...args.suite.beforeActions ]; retrySuiteCollection.add(suite); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite.states.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.state.name)) { suite.addState(args.state.clone()); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(<span class="hljs-string"><span class="hljs-string">`passed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); });</code> </pre> <br>  Das TEST_RESULT-Ereignis war √ºbrigens auch n√ºtzlich, um den Fortschritt der bestandenen Tests zu visualisieren.  Jetzt muss der Entwickler nicht mehr warten, bis alle Tests abgeschlossen sind. Er kann die Ausf√ºhrung unterbrechen, wenn er feststellt, dass ein Fehler aufgetreten ist.  Wenn die Testausf√ºhrung unterbrochen wird, schlie√üt Gemini die vom Selenserver ge√∂ffneten Browsersitzungen korrekt. <br><br>  Wenn die neue Suite nach Abschluss des Testlaufs nicht leer ist, f√ºhren Sie sie aus, bis die maximale Anzahl von Wiederholungen ersch√∂pft ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((retryCount--) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; result.failed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; retrySuiteCollection.topLevelSuites().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { runner.test(retrySuiteCollection, {}).done(onComplete); } } runner.readTests(path).done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests).done(onComplete));</code> </pre> <br><h2>  Zusammenfassung </h2><br>  Heute haben wir ungef√§hr f√ºnfzig visuelle Tests, die die wichtigsten visuellen Zust√§nde unserer Anwendung abdecken.  Nat√ºrlich besteht keine Notwendigkeit, √ºber die vollst√§ndige Abdeckung von UI-Tests zu sprechen, aber wir haben uns ein solches Ziel noch nicht gesetzt.  Tests funktionieren sowohl auf den Workstations der Entwickler als auch auf den Build-Agenten erfolgreich.  W√§hrend Tests nur im Kontext von Chrome und Internet Explorer durchgef√ºhrt werden, ist es in Zukunft m√∂glich, andere Browser zu verbinden.  All diese Wirtschaftlichkeit dient dem Selemium-Grid mit zwei Knoten, die auf virtuellen Maschinen bereitgestellt werden. <br><br>  Von Zeit zu Zeit sehen wir uns mit der Tatsache konfrontiert, dass nach der Ver√∂ffentlichung der neuen Version von Chrome die Referenzbilder aktualisiert werden m√ºssen, da einige Elemente etwas anders angezeigt wurden (z. B. Scroller), aber es gibt nichts zu tun.  Es ist selten, aber es kommt vor, dass Sie beim √Ñndern der Struktur eines Redux-Speichers die gespeicherten Zust√§nde f√ºr die Tests erneut abrufen m√ºssen.  Es ist nat√ºrlich nicht einfach, genau den Zustand wiederherzustellen, der sich zum Zeitpunkt seiner Erstellung im Test befand.  In der Regel merkt sich noch niemand, in welcher Datenbank diese Bilder aufgenommen wurden und Sie m√ºssen mit anderen Daten ein neues Bild aufnehmen.  Dies ist ein Problem, aber kein gro√ües.  Um dies zu l√∂sen, k√∂nnen Sie Bilder auf einer Demobasis aufnehmen, da wir Skripte f√ºr die Erstellung haben und auf dem neuesten Stand gehalten werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454464/">https://habr.com/ru/post/de454464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454452/index.html">Wir zeigen Inhalte auf dem erkannten Bild nach bestimmten Regeln an</a></li>
<li><a href="../de454456/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 7. FAQ</a></li>
<li><a href="../de454458/index.html">Metamorphe Tests: Warum wei√ü fast niemand etwas √ºber diese vielversprechende Technik?</a></li>
<li><a href="../de454460/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 300 (27. Mai - 2. Juni)</a></li>
<li><a href="../de454462/index.html">Fotogramm ohne Fotopapier</a></li>
<li><a href="../de454470/index.html">Leben vor der Laufzeit. Yandex-Bericht</a></li>
<li><a href="../de454472/index.html">Was Sie √ºber den neuesten Router-Patch von Cisco wissen m√ºssen</a></li>
<li><a href="../de454474/index.html">Digitale Veranstaltungen in Moskau vom 3. bis 9. Juni</a></li>
<li><a href="../de454476/index.html">Best Practices Node.js - Tipps zur Projektstruktur</a></li>
<li><a href="../de454478/index.html">Azure IoT Edge Tools (Vorschau) -Erweiterung angek√ºndigt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>