<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙 🚌 🐇 Entwicklung visueller Tests basierend auf Gemini und Storybook ⏯️ 🕵🏼 😯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! In diesem Artikel möchte ich die Erfahrungen mit der Entwicklung visueller Tests in unserem Team teilen. 

 So kam es, dass wir nicht sofo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung visueller Tests basierend auf Gemini und Storybook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454464/">  Hallo Habr!  In diesem Artikel möchte ich die Erfahrungen mit der Entwicklung visueller Tests in unserem Team teilen. <br><br>  So kam es, dass wir nicht sofort über Layout-Tests nachdachten.  Nun, ein Frame bewegt sich für ein paar Pixel nach außen.  Am Ende gibt es Tester - die Fliege fliegt nicht an ihnen vorbei.  Der menschliche Faktor lässt sich jedoch immer noch nicht täuschen - das Erkennen geringfügiger Änderungen in der Benutzeroberfläche ist selbst für einen Tester bei weitem nicht immer physisch möglich.  Die Frage stellte sich, als mit einer ernsthaften Optimierung des Layouts und dem Übergang zu BEM begonnen wurde.  Hier wäre es sicherlich nicht verlustfrei gewesen, und wir brauchten dringend eine automatisierte Methode, um Situationen zu erkennen, in denen sich aufgrund von Änderungen etwas in der Benutzeroberfläche nicht wie beabsichtigt oder nicht dort ändert, wo es beabsichtigt war. <br><a name="habracut"></a><br>  Jeder Entwickler kennt sich mit Unit-Code-Tests aus.  Unit-Tests geben die Gewissheit, dass Änderungen im Code nichts kaputt gemacht haben.  Nun, zumindest haben sie den Teil, für den es Tests gibt, nicht gebrochen.  Das gleiche Prinzip kann auf die Benutzeroberfläche angewendet werden.  So wie Unit-Tests Testklassen testen, testen visuelle Tests die visuellen Komponenten, aus denen die Benutzeroberfläche einer Anwendung besteht. <br><br>  Für visuelle Komponenten können Sie „klassische“ Komponententests schreiben, die beispielsweise das Rendern von Komponenten mit unterschiedlichen Werten von Eingabeparametern initiieren und den erwarteten Status des DOM-Baums mithilfe von assert-Anweisungen überprüfen, indem Sie entweder einzelne Elemente oder eine Momentaufnahme des DOM-Baums der Komponente mit der Referenz vergleichen im Allgemeinen.  Visuelle Tests basieren ebenfalls auf Schnappschüssen, jedoch bereits auf Schnappschüssen der visuellen Anzeige der Komponente (Screenshots).  Der Kern des visuellen Tests besteht darin, das während des Tests aufgenommene Bild mit dem Referenzbild zu vergleichen und, wenn Unterschiede festgestellt werden, entweder das neue Bild als Referenzbild zu akzeptieren oder den Fehler zu beheben, der diese Unterschiede verursacht hat. <br><br>  Natürlich ist das „Screening“ einzelner visueller Komponenten nicht sehr effektiv.  Die Komponenten leben nicht in einem Vakuum und ihre Anzeige kann entweder von den Komponenten der obersten Ebene oder von benachbarten Komponenten abhängen.  Unabhängig davon, wie wir einzelne Komponenten testen, kann das gesamte Bild Mängel aufweisen.  Wenn Sie dagegen Bilder des gesamten Anwendungsfensters aufnehmen, enthalten viele der Bilder dieselben Komponenten. Wenn Sie also eine Komponente ändern, müssen wir alle Bilder aktualisieren, in denen diese Komponente vorhanden ist. <br><br>  Die Wahrheit liegt wie üblich irgendwo in der Mitte - Sie können die gesamte Seite der Anwendung zeichnen, aber nur einen Bereich fotografieren, unter dem der Test erstellt wird. In dem speziellen Fall kann dieser Bereich mit dem Bereich einer bestimmten Komponente übereinstimmen, dies ist jedoch keine Komponente in Vakuum, aber in einer sehr realen Umgebung.  Und dies wird bereits einem visuellen Einheitentest ähneln, obwohl über Modularität kaum etwas gesagt werden kann, wenn die „Einheit“ etwas über die Umgebung weiß.  Okay, es ist nicht so wichtig, ob die Kategorie der Tests visuelle Tests umfasst - modular oder integriert.  Wie das Sprichwort sagt: "Sie überprüfen oder gehen?" <br><br><h2>  Werkzeugauswahl </h2><br>  Um die Ausführung von Tests zu beschleunigen, kann das Rendern von Seiten in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kopflosen Browser durchgeführt werden</a> , der die gesamte Arbeit im Speicher erledigt, ohne auf dem Bildschirm angezeigt zu werden, und maximale Leistung bietet.  In unserem Fall war es jedoch wichtig sicherzustellen, dass die Anwendung in Internet Explorer (IE) funktioniert, das keinen Headless-Modus hat, und wir brauchten ein Tool zum programmgesteuerten Verwalten von Browsern.  Glücklicherweise wurde bereits alles vor uns erfunden und es gibt ein solches Instrument - es heißt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selen</a> .  Im Rahmen des Selenium-Projekts werden Treiber für die Verwaltung verschiedener Browser entwickelt, einschließlich eines Treibers für den Internet Explorer.  Selenium Server können Browser nicht nur lokal, sondern auch remote verwalten und bilden einen Cluster von Selenium Servern, das sogenannte Selenium Grid. <br><br>  Selen ist ein mächtiges Werkzeug, aber die Schwelle für den Eintritt ist ziemlich hoch.  Wir haben uns entschlossen, nach vorgefertigten Werkzeugen für visuelle Tests auf der Basis von Selen zu suchen, und sind auf ein wunderbares Produkt von Yandex namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gemini gestoßen</a> .  Zwillinge können Bilder aufnehmen, einschließlich Bilder eines bestimmten Bereichs der Seite, Bilder mit Referenzbildern vergleichen, den Unterschied visualisieren und Momente wie Anti-Aliasing oder einen blinkenden Cursor berücksichtigen.  Darüber hinaus kann Gemini gefallene Tests wiederholen, die Ausführung von Tests parallelisieren und viele andere Extras.  Im Allgemeinen haben wir beschlossen, es zu versuchen. <br><br>  Zwillingstests sind einfach zu schreiben.  Zuerst müssen Sie die Infrastruktur vorbereiten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selenium-Standalone</a> installieren und den Selenium-Server starten.  Konfigurieren Sie anschließend gemini, geben Sie die Adresse der zu testenden Anwendung (rootUrl), die Adresse des Selenservers (gridUrl), die Zusammensetzung und Konfiguration der Browser sowie die erforderlichen Plugins zum Generieren von Berichten an und optimieren Sie die Bildkomprimierung.  Konfigurationsbeispiel: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//.gemini.js module.exports = { rootUrl: 'http://my-app.ru', gridUrl: 'http://127.0.0.1:4444/wd/hub', browsers: { chrome: { windowSize: '1920x1080', screenshotsDir:'gemini/screens/1920x1080' desiredCapabilities: { browserName: 'chrome' } } }, system: { projectRoot: '', plugins: { 'html-reporter/gemini': { enabled: true, path: './report' }, 'gemini-optipng': true }, exclude: [ '**/report/*' ], diffColor: '#EC041E' } };</span></span></code> </pre> <br>  Die Tests selbst sind eine Sammlung von Suiten, in denen jeweils ein oder mehrere Bilder (Zustände) aufgenommen werden.  Bevor Sie einen Snapshot (Capture () -Methode) erstellen, können Sie den Bereich der zu fotografierenden Seite mit der setCaptureElements () -Methode festlegen und gegebenenfalls im Browserkontext einige vorbereitende Aktionen ausführen, indem Sie entweder die Methoden des Aktionsobjekts oder beliebigen JavaScript-Code verwenden - für Dies in Aktionen hat eine executeJS () -Methode. <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'login-dialog'</span></span>, suite =&gt; { suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.login__form'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'default'</span></span>); .capture(<span class="hljs-string"><span class="hljs-string">'focused'</span></span>, actions =&gt; actions.focus(<span class="hljs-string"><span class="hljs-string">'.login__editor'</span></span>)); });</code> </pre> <br><h2>  Testdaten </h2><br>  Ein Testwerkzeug wurde ausgewählt, aber es war noch ein langer Weg bis zur endgültigen Lösung.  Es war notwendig zu verstehen, was mit den auf den Bildern angezeigten Daten zu tun ist.  Ich möchte Sie daran erinnern, dass wir uns bei den Tests entschieden haben, nicht einzelne Komponenten, sondern die gesamte Seite der Anwendung zu zeichnen, um die visuellen Komponenten nicht im Vakuum, sondern in der realen Umgebung anderer Komponenten zu testen.  Wenn Sie die erforderlichen Testdaten an ee- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Requisiten übertragen müssen</a> (ich spreche von Reaktionskomponenten), um eine einzelne Komponente zu rendern, ist viel mehr erforderlich, um die gesamte Seite der Anwendung zu rendern, und die Vorbereitung der Umgebung für einen solchen Test kann Kopfschmerzen bereiten. <br><br>  Natürlich können Sie die Anwendung selbst verlassen, um die Daten zu empfangen, sodass sie während des Tests Anforderungen an das Backend ausführt, die wiederum Daten aus einer Art Referenzdatenbank empfangen würden, aber was ist mit der Versionierung?  Sie können keine Datenbank in ein Git-Repository stellen.  Nein, natürlich können Sie, aber es gibt einige Anstand. <br><br>  Um Tests auszuführen, können Sie alternativ den realen Backend-Server durch einen gefälschten ersetzen, wodurch die Webanwendung keine Daten aus der Datenbank erhält, sondern statische Daten, die beispielsweise im JSON-Format bereits mit den Quellen gespeichert sind.  Die Aufbereitung solcher Daten ist jedoch auch nicht zu trivial.  Wir haben uns für den einfacheren Weg entschieden - nicht die Daten vom Server abzurufen, sondern einfach den Status der Anwendung (in unserem Fall den Status des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux-Speichers</a> ) wiederherzustellen, der sich zum Zeitpunkt der Aufnahme des Referenzbilds in der Anwendung befand, bevor der Test ausgeführt wurde. <br><br>  Um den aktuellen Status des Redux-Speichers zu serialisieren, wurde dem Fensterobjekt die Methode snapshot () hinzugefügt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snapshotStore = (store: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">fileName</span></span>: string): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = store.getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob( [ <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(state, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } ); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); a.href = URL.createObjectURL(file); a.download = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${fileName}</span></span></span><span class="hljs-string">.testdata.json`</span></span>; a.click(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`State downloaded to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a.download}</span></span></span><span class="hljs-string">`</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.snapshot = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> snapshotStore(store, fileName); };</code> </pre><br>  Mit dieser Methode können Sie über die Befehlszeile der Browserkonsole den aktuellen Status des Redux-Speichers in einer Datei speichern: <br><br><img src="https://habrastorage.org/webt/qf/t0/yq/qft0yqppzfe_issnjy74jon-vbs.png" alt="Bild"><br><br>  Als Infrastruktur für visuelle Tests wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Storybook</a> ausgewählt - ein Tool für die interaktive Entwicklung von Bibliotheken visueller Komponenten.  Die Hauptidee war, anstelle der verschiedenen Zustände der Komponenten im Storys-Baum die verschiedenen Zustände unserer Anwendung zu korrigieren und diese Zustände zum Erstellen von Screenshots zu verwenden.  Letztendlich gibt es keinen grundlegenden Unterschied zwischen einfachen und komplexen Komponenten, außer bei der Vorbereitung der Umgebung. <br><br>  Jeder visuelle Test ist also eine Geschichte, vor deren Rendern der Status des zuvor in der Datei gespeicherten Redux-Speichers wiederhergestellt wird.  Dies erfolgt mithilfe der Provider-Komponente aus der React-Redux-Bibliothek, an deren Store-Eigenschaft der aus der zuvor gespeicherten Datei wiederhergestellte deserialisierte Status übergeben wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preloadedState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./incoming-letter.testdata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(rootReducer, preloadedState); storiesOf(<span class="hljs-string"><span class="hljs-string">'regression/Cards'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) .add(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContextContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...dummyProps</span></span></span></span><span class="xml"><span class="hljs-tag">}/&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); });</span></span></code> </pre><br>  Im obigen Beispiel ist ContextContainer eine Komponente, die das "Grundgerüst" der Anwendung enthält - den Navigationsbaum, den Header und den Inhaltsbereich.  Im Inhaltsbereich können je nach aktuellem Status des Redux-Speichers verschiedene Komponenten gerendert werden (Liste, Karte, Dialog usw.).  Damit die Komponente keine unnötigen Anforderungen an das Backend zur Eingabe erfüllt, werden entsprechende Stub-Eigenschaften an sie übergeben. <br><br>  Im Kontext eines Storybooks sieht es ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/jx/0m/ux/jx0muxytucrqrwzpvtnskjuqs1a.png" alt="Bild"><br><br><h2>  Zwillinge + Märchenbuch </h2><br>  Also haben wir die Daten für die Tests herausgefunden.  Die nächste Aufgabe ist es, sich mit Gemini und Storybook anzufreunden.  Auf den ersten Blick ist alles einfach - in der Gemini-Konfiguration geben wir die Adresse der zu testenden Anwendung an.  In unserem Fall ist dies die Adresse des Storybook-Servers.  Sie müssen nur den Storybook-Server hochfahren, bevor Sie mit den Gemini-Tests beginnen.  Sie können dies direkt aus dem Code heraus mit dem Gemini-Ereignisabonnement START_RUNNER und END_RUNNER tun: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">6006</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cofiguration = { <span class="hljs-attr"><span class="hljs-attr">rootUrl</span></span>:<span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">gridUrl</span></span>: seleniumGridHubUrl, <span class="hljs-attr"><span class="hljs-attr">browsers</span></span>: { <span class="hljs-string"><span class="hljs-string">'chrome'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">screenshotsDir</span></span>:<span class="hljs-string"><span class="hljs-string">'gemini/screens'</span></span>, <span class="hljs-attr"><span class="hljs-attr">desiredCapabilities</span></span>: chromeCapabilities } } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Gemini = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HttpServer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http-server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> runner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gemini(cofiguration); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = HttpServer.createServer({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: <span class="hljs-string"><span class="hljs-string">'./storybook-static'</span></span>}); runner.on(runner.events.START_RUNNER, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`storybook server is listening on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">...`</span></span>); server.listen(port); }); runner.on(runner.events.END_RUNNER, () =&gt; { server.close(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'storybook server is closed'</span></span>); }); runner .readTests(path) .done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests));</code> </pre> <br>  Als Server für Tests haben wir den http-Server verwendet, der den Inhalt des Ordners mit dem statisch zusammengestellten Storybook zurückgibt (um das statische Storybook zu erstellen, verwenden Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehl build-storybook</a> ). <br><br>  Bisher lief alles reibungslos, aber die Probleme haben sich nicht warten lassen.  Tatsache ist, dass das Bilderbuch die Geschichte innerhalb des Rahmens anzeigt.  Ursprünglich wollten wir den selektiven Bereich des Bildes mit setCaptureElements () festlegen können. Dies ist jedoch nur möglich, wenn Sie die Frame-Adresse als Adresse für die Suite angeben. <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'http://localhost:6006/iframe.html?selectedKind=regression%2Fcards&amp;selectedStory=IncomingLetter'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.some-component'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>) );</code> </pre><br>  Aber dann stellt sich heraus, dass wir für jede Aufnahme unsere eigene Suite erstellen müssen, weil  Die URL kann für die gesamte Suite festgelegt werden, jedoch nicht für einen einzelnen Snapshot innerhalb der Suite.  Es versteht sich, dass jede Suite in einer separaten Browsersitzung ausgeführt wird.  Dies ist im Prinzip richtig - die Tests sollten nicht voneinander abhängen, aber das Öffnen einer separaten Browsersitzung und das anschließende Laden des Storybooks nimmt viel Zeit in Anspruch, viel mehr als nur das Durchlaufen von Storys im Rahmen des bereits geöffneten Storybooks.  Daher ist bei einer großen Anzahl von Suiten die Testausführungszeit sehr langsam.  Ein Teil des Problems kann durch Parallelisierung der Testausführung gelöst werden, die Parallelisierung verbraucht jedoch viele Ressourcen (Speicher, Prozessor).  Nachdem wir uns entschlossen hatten, Ressourcen zu sparen und gleichzeitig während des Testlaufs nicht zu viel zu verlieren, lehnten wir es ab, den Frame in einem separaten Browserfenster zu öffnen.  Tests werden in einer einzelnen Browsersitzung durchgeführt, aber vor jeder Aufnahme wird die nächste Story in den Frame geladen, als hätten wir gerade das Storybook geöffnet und auf einzelne Knoten im Storys-Baum geklickt.  Bildbereich - gesamter Rahmen: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'ProjectDocument'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'ProjectDocumentAccess'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>, actions =&gt; { openStory(actions, <span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>); hover(actions, <span class="hljs-string"><span class="hljs-string">'.related-documents-tree-item__title'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }) );</code> </pre> <br>  Leider haben wir bei dieser Option neben der Möglichkeit, den Bildbereich auszuwählen, auch die Möglichkeit verloren, Standardaktionen der Gemini-Engine für die Arbeit mit Elementen des DOM-Baums (mouseDown (), mouseMove (), focus () usw.) usw. zu verwenden. zu.  Elemente innerhalb des Gemini-Rahmens sehen nicht.  Wir haben aber weiterhin die Möglichkeit, die Funktion executeJS () zu verwenden, mit der Sie JavaScript-Code in einem Browserkontext ausführen können.  Basierend auf dieser Funktion haben wir die Analoga der von uns benötigten Standardaktionen implementiert, die bereits im Kontext des Storybook-Frames funktionieren.  Hier mussten wir ein wenig „zaubern“, um Parameterwerte aus dem Testkontext in den Browserkontext zu übertragen - executeJS () bietet leider keine solche Möglichkeit.  Daher sieht der Code auf den ersten Blick etwas seltsam aus - die Funktion wird in eine Zeichenfolge übersetzt, ein Teil des Codes wird durch Parameterwerte ersetzt und in ExecuteJs () wird die Funktion mit eval () aus der Zeichenfolge wiederhergestellt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openStory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, storyName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> storyNameLowered = storyName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickTo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).filter( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.textContent.toLowerCase() === <span class="hljs-string"><span class="hljs-string">'storyNameLowered'</span></span>; })[<span class="hljs-number"><span class="hljs-number">0</span></span>].click(); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clickTo.toString().replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'storyNameLowered'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, storyNameLowered)}</span></span></span><span class="hljs-string">)`</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, targets, index, events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelector(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>).contentWindow.document; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'targets'</span></span>)[index || <span class="hljs-number"><span class="hljs-number">0</span></span>]; events.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickEvent = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent(<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>); clickEvent.initEvent(event, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); target.dispatchEvent(clickEvent); }); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dispatch.toString() .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'targets'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, targets) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'index'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, index) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'events'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`["</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${events.join(</span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'","'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">)}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"]`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">)`</span></span> )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hover</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, selectors, index</span></span></span><span class="hljs-function">) </span></span>{ dispatchEvents(actions, selectors, index, [ <span class="hljs-string"><span class="hljs-string">'mouseenter'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseover'</span></span> ]); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">openStory</span></span>: openStory, <span class="hljs-attr"><span class="hljs-attr">hover</span></span>: hover };</code> </pre><br><h2>  Wiederholungen der Ausführung </h2><br>  Nachdem die visuellen Tests geschrieben wurden und zu arbeiten begannen, stellte sich heraus, dass einige der Tests nicht sehr stabil waren.  Irgendwo hat das Symbol keine Zeit zum Zeichnen, irgendwo wird die Auswahl nicht entfernt und wir erhalten eine Nichtübereinstimmung mit dem Referenzbild.  Daher wurde beschlossen, Wiederholungstests der Testausführung aufzunehmen.  In Gemini funktionieren Wiederholungsversuche jedoch für die gesamte Suite. Wie oben erwähnt, haben wir versucht, Situationen zu vermeiden, in denen für jede Aufnahme eine Suite erstellt wird. Dies verlangsamt die Ausführung von Tests zu sehr.  Auf der anderen Seite ist die Wahrscheinlichkeit, dass die wiederholte Ausführung der Suite ebenso wie die vorherige abfällt, umso größer, je mehr Aufnahmen im Rahmen einer Suite gemacht werden.  Daher war es notwendig, Wiederholungsversuche durchzuführen.  In unserem Schema wird die Ausführung nicht für die gesamte Suite wiederholt, sondern nur für die Bilder, die den vorherigen fehlgeschlagenen Lauf nicht weitergegeben haben.  Zu diesem Zweck analysieren wir im TEST_RESULT-Ereignishandler das Ergebnis des Vergleichs des Snapshots mit dem Standard. Für die Snapshots, die den Vergleich nicht bestanden haben, erstellen wir nur für sie eine neue Suite: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SuiteCollection = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite-collection'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Suite = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retrySuiteCollection; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; runner.on(runner.events.BEGIN, () =&gt; { retrySuiteCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuiteCollection(); }); runner.on(runner.events.TEST_RESULT, args =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testId = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.state.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.suite.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.browserId}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.equal) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.yellow(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suite = retrySuiteCollection.topLevelSuites().find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.suite.name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite) { suite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Suite(args.suite.name); suite.url = args.suite.url; suite.file = args.suite.file; suite.path = args.suite.path; suite.captureSelectors = [ ...args.suite.captureSelectors ]; suite.browsers = [ ...args.suite.browsers ]; suite.skipped = [ ...args.suite.skipped ]; suite.beforeActions = [ ...args.suite.beforeActions ]; retrySuiteCollection.add(suite); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite.states.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.state.name)) { suite.addState(args.state.clone()); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(<span class="hljs-string"><span class="hljs-string">`passed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); });</code> </pre> <br>  Das TEST_RESULT-Ereignis war übrigens auch nützlich, um den Fortschritt der bestandenen Tests zu visualisieren.  Jetzt muss der Entwickler nicht mehr warten, bis alle Tests abgeschlossen sind. Er kann die Ausführung unterbrechen, wenn er feststellt, dass ein Fehler aufgetreten ist.  Wenn die Testausführung unterbrochen wird, schließt Gemini die vom Selenserver geöffneten Browsersitzungen korrekt. <br><br>  Wenn die neue Suite nach Abschluss des Testlaufs nicht leer ist, führen Sie sie aus, bis die maximale Anzahl von Wiederholungen erschöpft ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((retryCount--) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; result.failed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; retrySuiteCollection.topLevelSuites().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { runner.test(retrySuiteCollection, {}).done(onComplete); } } runner.readTests(path).done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests).done(onComplete));</code> </pre> <br><h2>  Zusammenfassung </h2><br>  Heute haben wir ungefähr fünfzig visuelle Tests, die die wichtigsten visuellen Zustände unserer Anwendung abdecken.  Natürlich besteht keine Notwendigkeit, über die vollständige Abdeckung von UI-Tests zu sprechen, aber wir haben uns ein solches Ziel noch nicht gesetzt.  Tests funktionieren sowohl auf den Workstations der Entwickler als auch auf den Build-Agenten erfolgreich.  Während Tests nur im Kontext von Chrome und Internet Explorer durchgeführt werden, ist es in Zukunft möglich, andere Browser zu verbinden.  All diese Wirtschaftlichkeit dient dem Selemium-Grid mit zwei Knoten, die auf virtuellen Maschinen bereitgestellt werden. <br><br>  Von Zeit zu Zeit sehen wir uns mit der Tatsache konfrontiert, dass nach der Veröffentlichung der neuen Version von Chrome die Referenzbilder aktualisiert werden müssen, da einige Elemente etwas anders angezeigt wurden (z. B. Scroller), aber es gibt nichts zu tun.  Es ist selten, aber es kommt vor, dass Sie beim Ändern der Struktur eines Redux-Speichers die gespeicherten Zustände für die Tests erneut abrufen müssen.  Es ist natürlich nicht einfach, genau den Zustand wiederherzustellen, der sich zum Zeitpunkt seiner Erstellung im Test befand.  In der Regel merkt sich noch niemand, in welcher Datenbank diese Bilder aufgenommen wurden und Sie müssen mit anderen Daten ein neues Bild aufnehmen.  Dies ist ein Problem, aber kein großes.  Um dies zu lösen, können Sie Bilder auf einer Demobasis aufnehmen, da wir Skripte für die Erstellung haben und auf dem neuesten Stand gehalten werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454464/">https://habr.com/ru/post/de454464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454452/index.html">Wir zeigen Inhalte auf dem erkannten Bild nach bestimmten Regeln an</a></li>
<li><a href="../de454456/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 7. FAQ</a></li>
<li><a href="../de454458/index.html">Metamorphe Tests: Warum weiß fast niemand etwas über diese vielversprechende Technik?</a></li>
<li><a href="../de454460/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 300 (27. Mai - 2. Juni)</a></li>
<li><a href="../de454462/index.html">Fotogramm ohne Fotopapier</a></li>
<li><a href="../de454470/index.html">Leben vor der Laufzeit. Yandex-Bericht</a></li>
<li><a href="../de454472/index.html">Was Sie über den neuesten Router-Patch von Cisco wissen müssen</a></li>
<li><a href="../de454474/index.html">Digitale Veranstaltungen in Moskau vom 3. bis 9. Juni</a></li>
<li><a href="../de454476/index.html">Best Practices Node.js - Tipps zur Projektstruktur</a></li>
<li><a href="../de454478/index.html">Azure IoT Edge Tools (Vorschau) -Erweiterung angekündigt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>