<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêë üêøÔ∏è ‚ôÇÔ∏è DMA: Mythen und Realit√§t üëâüèΩ üë¥üèæ üë©üèø‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 In einem fr√ºheren Artikel ( ‚ÄûTeil 2: Verwenden der PSoC-UDB-Bl√∂cke von Cypress zur Reduzierung der Anzahl von Interrupts in einem 3D-Druc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DMA: Mythen und Realit√§t</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437112/"><img src="https://habrastorage.org/webt/m4/12/q3/m412q3b8zbug620xzvv0the7ix0.jpeg"><br><br><h2>  Einf√ºhrung </h2><br>  In einem fr√ºheren Artikel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûTeil 2: Verwenden der PSoC-UDB-Bl√∂cke von Cypress zur Reduzierung der Anzahl von Interrupts in einem 3D-Drucker‚Äú</a> ) habe ich eine sehr interessante Tatsache festgestellt: Wenn ein Computer in UDB Daten zu schnell aus dem FIFO entfernte, konnte er feststellen, dass es neue gibt Es gibt keine Daten im FIFO, danach geht es in einen falschen Zustand <b>Leerlauf</b> .  Das hat mich nat√ºrlich interessiert.  Ich habe die ge√∂ffneten Ergebnisse einer Gruppe von Bekannten gezeigt.  Eine Person antwortete, dass dies alles ganz offensichtlich sei, und nannte sogar die Gr√ºnde.  Der Rest war nicht weniger √ºberrascht als ich zu Beginn der Forschung.  Einige Experten werden hier also nichts Neues finden, aber es w√§re sch√∂n, diese Informationen der √ñffentlichkeit zug√§nglich zu machen, damit alle Programmierer f√ºr Mikrocontroller dies ber√ºcksichtigen. <br><a name="habracut"></a><br>  Nicht, dass es sich um eine Art Deckung handelte.  Es stellte sich heraus, dass dies alles gut dokumentiert ist, aber das Problem ist, dass nicht in der Hauptsache, sondern in zus√§tzlichen Dokumenten.  Und ich pers√∂nlich war in gl√ºcklicher Unwissenheit und glaubte, dass DMA ein sehr flinkes Subsystem ist, das die Effizienz von Programmen dramatisch steigern kann, da es eine systematische Daten√ºbertragung gibt, ohne das Registerinkrement abzulenken und den Zyklus auf dieselben Befehle zu organisieren.  Was die Verbesserung der Effizienz betrifft - alles ist wahr, aber aufgrund etwas anderer Dinge. <br><br>  Aber das Wichtigste zuerst. <br><br><h2>  Experimente mit Cypress PSoC </h2><br>  Machen wir eine einfache Maschine.  Es wird bedingt zwei Zust√§nde haben: den Ruhezustand und den Zustand, in den es f√§llt, wenn mindestens ein Datenbyte im FIFO vorhanden ist.  Wenn er in diesen Zustand eintritt, nimmt er einfach diese Daten und versagt dann erneut in einem Ruhezustand.  Das Wort "bedingt" habe ich nicht versehentlich zitiert.  Wir haben zwei FIFOs, daher werde ich zwei solche Zust√§nde festlegen, einen f√ºr jeden FIFO, um sicherzustellen, dass sie sich im Verhalten vollst√§ndig identifizieren.  Das √úbergangsdiagramm f√ºr die Maschine sah folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/pv/cu/1q/pvcu1qmbxk9zkbgxk8u51unthpe.png"><br><br>  Die Flags zum Verlassen des Ruhezustands sind wie folgt definiert: <br><br><img src="https://habrastorage.org/webt/h8/re/rp/h8rerphupbsfvawmjiwgwqr_thw.png"><br><br>  Vergessen Sie nicht, die Bits der Statusnummer an die Datenpfadeing√§nge zu senden: <br><br><img src="https://habrastorage.org/webt/ze/dz/ab/zedzab8iuaoxnu0esg32xwwga3g.png"><br><br>  Nach au√üen geben wir zwei Gruppen von Signalen aus: ein Signalpaar, f√ºr das der FIFO freien Speicherplatz hat (damit DMA mit dem Hochladen von Daten beginnen kann), und ein paar Signale, f√ºr die der FIFO leer ist (um diese Tatsache auf einem Oszilloskop anzuzeigen). <br><br><img src="https://habrastorage.org/webt/ts/bm/dn/tsbmdn-puyugsmixnsipf81pboa.png"><br><br>  ALU nimmt einfach fiktiv Daten vom FIFO entgegen: <br><br><img src="https://habrastorage.org/webt/px/5s/_w/px5s_wj1zqwjedrk0h7ty7tbu_4.png"><br><br>  Lassen Sie mich Ihnen die Details f√ºr den Status "0001" zeigen: <br><br><img src="https://habrastorage.org/webt/mb/-s/j0/mb-sj05-chkdijmqn3mue8hmjnk.png"><br><br>  Ich habe auch die Busbreite, die sich in dem Projekt befand, bei dem ich diesen Effekt bemerkt habe, auf 16 Bit eingestellt: <br><br><img src="https://habrastorage.org/webt/sa/hc/br/sahcbrgearj6wnw5-4lykaew1qy.png"><br><br>  Wir gehen zum Schema des Projekts selbst √ºber.  √Ñu√üerlich gebe ich nicht nur Signale aus, dass der FIFO leer ist, sondern auch Taktimpulse.  Dadurch kann ich auf Cursormessungen auf einem Oszilloskop verzichten.  Ich kann einfach mit dem Finger Ma√ünahmen ergreifen. <br><br><img src="https://habrastorage.org/webt/b-/8v/iq/b-8viqzbm1isamdkiljvmwevwme.png"><br><br>  Anscheinend habe ich 24 Megahertz Taktrate gemacht.  Die Prozessorkernfrequenz ist genau gleich.  Je niedriger die Frequenz, desto weniger Interferenzen treten bei einem chinesischen Oszilloskop auf (offiziell hat es ein Band von 250 MHz, dann aber chinesisches Megahertz), und alle Messungen werden in Bezug auf Taktimpulse durchgef√ºhrt.  Unabh√§ngig von der Frequenz funktioniert das System in Bezug auf diese weiterhin.  Ich h√§tte einen Megahertz eingestellt, aber die Entwicklungsumgebung verbot mir, einen Prozessorkernfrequenzwert von weniger als 24 MHz einzugeben. <br><br>  Nun das Testmaterial.  Um in FIFO0 zu schreiben, habe ich folgende Funktion ausgef√ºhrt: <br><br><pre><code class="plaintext hljs">void WriteTo0FromROM() { static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_0_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(JustReadFromFIFO_1_Datapath_1_F0_PTR)); CyDmaChRoundRobin (channel,1); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR / TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)JustReadFromFIFO_1_Datapath_1_F0_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre> <br>  Das Wort ROM im Funktionsnamen ist darauf zur√ºckzuf√ºhren, dass das zu sendende Array im ROM-Bereich gespeichert ist und der Cortex M3 √ºber eine Harvard-Architektur verf√ºgt.  Die Zugriffsgeschwindigkeit auf den RAM-Bus und den ROM-Bus kann variieren. Ich wollte dies √ºberpr√ºfen, daher habe ich eine √§hnliche Funktion zum Senden eines Arrays aus dem RAM (das <b>Step-</b> Array enth√§lt keinen <b>statischen Const-</b> Modifikator in seinem Hauptteil).  Nun, es gibt das gleiche Funktionspaar zum Senden an FIFO1, das Empf√§ngerregister ist dort unterschiedlich: nicht F0, sondern F1.  Ansonsten sind alle Funktionen identisch.  Da ich keinen gro√üen Unterschied in den Ergebnissen festgestellt habe, werde ich die Ergebnisse des Aufrufs genau der obigen Funktion ber√ºcksichtigen.  Ein gelber Strahl - Taktimpulse, blauer Ausgang <b>FIFO0empty</b> . <br><br><img src="https://habrastorage.org/webt/ko/65/0j/ko650jp1nj58h1nm5dzal4bzdhw.png"><br><br>  √úberpr√ºfen Sie zun√§chst die Plausibilit√§t, warum der FIFO √ºber zwei Taktzyklen gef√ºllt ist.  Sehen wir uns diese Seite genauer an: <br><br><img src="https://habrastorage.org/webt/ox/fi/x_/oxfix_l8jpspyxgbiumrlagm9ma.png"><br><br>  An Kante 1 fallen die Daten in den FIFO, das <b>FIFO0-Leerzeichen</b> f√§llt ab.  An Kante 2 wechselt der Automat in den <b>Status GetDataFromFifo1</b> .  An Kante 3 werden in diesem Zustand Daten vom FIFO in das ALU-Register kopiert, FIFO wird geleert, das Flag <b>FIFO0empty</b> wird erneut <b>ausgel√∂st</b> .  Das hei√üt, die Wellenform verh√§lt sich plausibel, Sie k√∂nnen sich auf den Taktzyklus verlassen.  Wir bekommen 9 St√ºck. <br><br><img src="https://habrastorage.org/webt/fc/mq/bj/fcmqbjhfee7mf7u7_xnkgyspq18.png"><br><br>  <b>Insgesamt dauert es im inspizierten Bereich 9 Taktzyklen, um ein Datenwort mit DMA aus dem RAM in die UDB zu kopieren.</b> <br><br>  Und jetzt das Gleiche, aber mit Hilfe des Prozessorkerns.  Erstens ein idealer Code, der im wirklichen Leben kaum erreichbar ist: <br><br><pre> <code class="plaintext hljs"> volatile uint16_t* ptr = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; ptr[0] = 0; ptr[0] = 0;</code> </pre><br>  Was wird zum Assembler-Code? <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #8] ; (90 &lt;main+0xc&gt;) movs r2, #0 strh r2, [r3, #0] strh r2, [r3, #0] bn 8e &lt;main+0xa&gt; .word 0x40006898</code> </pre><br>  Keine Pausen, keine zus√§tzlichen Zyklen.  Zwei Taktpaare hintereinander ... <br><br><img src="https://habrastorage.org/webt/ms/po/gq/mspogqifm21mt0o34s0ltbh1fyu.png"><br><br>  Lassen Sie uns den Code etwas realer gestalten (mit dem Aufwand, den Zyklus zu organisieren, Daten abzurufen und Zeiger zu erh√∂hen): <br><br><pre> <code class="plaintext hljs">void SoftWriteTo0FromROM() { //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; uint16_t* src = steps; volatile uint16_t* dest = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; for (int i=sizeof(steps)/sizeof(steps[0]);i&gt;0;i--) { *dest = *src++; } }</code> </pre><br>  Assembler-Code erhalten: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #14] ; (9c &lt;CYDEV_CACHE_SIZE&gt;) ldr r0, [pc, #14] ; (a0 &lt;CYDEV_CACHE_SIZE+0x4&gt;) add.w r1, r3, #28 ; 0x28 ldrh.w r2, [r3], #2 cmp r3, r1 strh r2, [r0, #0] bne.n 8e &lt;main+0xa&gt;</code> </pre><br>  Auf dem Oszillogramm sehen wir nur 7 Zyklen pro Zyklus gegen√ºber neun im Fall von DMA: <br><br><img src="https://habrastorage.org/webt/h5/5k/y0/h55ky0f4pfsfaco90dvfgahwwki.png"><br><br><h2>  Ein bisschen √ºber Mythos </h2><br>  Um ehrlich zu sein, war es f√ºr mich urspr√ºnglich ein Schock.  Ich bin es irgendwie gewohnt zu glauben, dass der DMA-Mechanismus es Ihnen erm√∂glicht, Daten schnell und effizient zu √ºbertragen.  1/9 der Busfrequenz ist nicht so schnell.  Aber es stellte sich heraus, dass niemand es versteckte.  Das TRM-Dokument f√ºr PSoC 5LP enth√§lt sogar eine Reihe theoretischer √úberlegungen, und das Dokument ‚ÄûAN84810 - Erweiterte DMA-Themen f√ºr PSoC 3 und PSoC 5LP‚Äú beschreibt ausf√ºhrlich den Zugriff auf DMA.  Latenz ist schuld.  Der Austauschzyklus mit dem Bus dauert eine bestimmte Anzahl von Ticks.  Tats√§chlich spielen diese Ma√ünahmen beim Auftreten einer Verz√∂gerung eine entscheidende Rolle.  Im Allgemeinen versteckt niemand etwas, aber Sie m√ºssen dies wissen. <br><br>  <b>Wenn das ber√ºhmte GPIF, das in FX2LP (einer anderen von Cypress hergestellten Architektur) verwendet wird, nichts einschr√§nkt, ist das Tempolimit auf Latenzen zur√ºckzuf√ºhren, die beim Zugriff auf den Bus auftreten.</b> <br><br><h2>  DMA-Pr√ºfung auf STM32 </h2><br>  Ich war so beeindruckt, dass ich mich entschied, ein Experiment mit STM32 durchzuf√ºhren.  Ein STM32F103 mit dem gleichen Cortex M3-Prozessorkern wurde als experimentelles Kaninchen genommen.  Es gibt keine UDB, aus der Dienstsignale abgeleitet werden k√∂nnten, aber es ist durchaus m√∂glich, DMA zu √ºberpr√ºfen.  Was ist ein GPIO?  Dies ist ein Satz von Registern in einem gemeinsamen Adressraum.  Das ist in Ordnung.  Wir konfigurieren DMA im Kopiermodus ‚ÄûSpeicher-Speicher‚Äú, indem wir den realen Speicher (ROM oder RAM) als Quelle und das GPIO-Datenregister ohne das Adressinkrement als Empf√§nger angeben.  Wir werden abwechselnd entweder 0 oder 1 dorthin senden und das Ergebnis mit einem Oszilloskop fixieren.  Zu Beginn habe ich Port B gew√§hlt, es war einfacher, eine Verbindung √ºber das Steckbrett herzustellen. <br><br><img src="https://habrastorage.org/webt/od/u2/es/odu2esatrpusmpi8od4ecfaftk8.png"><br><br>  Ich habe es wirklich genossen, Ma√ünahmen mit einem Finger zu z√§hlen, nicht mit Cursorn.  Ist es m√∂glich, dasselbe auf diesem Controller zu tun?  Ganz!  Nehmen Sie die Referenztaktfrequenz f√ºr das Oszilloskop vom MCO-Zweig, der an den PA8-Anschluss des STM32F10C8T6 angeschlossen ist.  Die Auswahl der Quellen f√ºr diesen billigen Kristall ist nicht gro√üartig (der gleiche STM32F103, aber beeindruckender, er bietet viel mehr Optionen). Wir werden das SYSCLK-Signal an diesen Ausgang senden.  Da die Frequenz auf dem MCO nicht h√∂her als 50 MHz sein kann, reduzieren wir die Taktrate des Gesamtsystems auf 48 MHz.  Wir werden die Frequenz von Quarz 8 MHz nicht mit 9, sondern mit 6 multiplizieren (da 6 * 8 = 48): <br><br><img src="https://habrastorage.org/webt/0x/de/1a/0xde1acpu3rpgslyseaw2kcysc4.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInit; /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; // RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }</code> </pre><br></div></div><br>  Wir werden das MCO mit der <b>mcucpp-</b> Bibliothek von Konstantin Chizhov programmieren (von nun an werde ich alle Anrufe an die Ausr√ºstung √ºber diese wunderbare Bibliothek durchf√ºhren): <br><br><pre> <code class="plaintext hljs"> //  MCO Mcucpp::Clock::McoBitField::Set (0x4); //   MCO    Mcucpp::IO::Pa8::SetConfiguration (Mcucpp::IO::Pa8::Port::AltFunc); //     Mcucpp::IO::Pa8::SetSpeed (Mcucpp::IO::Pa8::Port::Fastest);</code> </pre><br>  Nun stellen wir die Ausgabe des Datenarrays im GPIOB ein: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::IO::Pb0 dmaTest0; typedef Mcucpp::IO::Pb1 dmaTest1; ... //  GPIOB      dmaTest0::ConfigPort::Enable(); dmaTest0::SetDirWrite(); dmaTest1::ConfigPort::Enable(); dmaTest1::SetDirWrite(); uint16_t dataForDma[]={0x0000,0x8001,0x0000,0x8001,0x0000, 0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001}; typedef Mcucpp::Dma1Channel1 channel; //    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set(); // ,    DMA channel::Init (channel::Mem2Mem|channel::MSize16Bits|channel::PSize16Bits|channel::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); while (1) { } }</code> </pre><br>  Die resultierende Wellenform ist der auf dem PSoC sehr √§hnlich. <br><br><img src="https://habrastorage.org/webt/ee/nl/2i/eenl2ix0_9zgzgaaxxeffbjzwjk.png"><br><br>  In der Mitte befindet sich ein gro√üer blauer Buckel.  Dies ist der DMA-Initialisierungsprozess.  Die blauen Impulse links wurden rein per Software auf PB1 empfangen.  Dehnen Sie sie weiter: <br><br><img src="https://habrastorage.org/webt/9l/y8/tp/9ly8tp_8hj1vohrh6jcnyktfa_a.png"><br><br>  2 Ma√ünahmen pro Puls.  Der Betrieb des Systems ist wie erwartet.  Aber jetzt schauen wir uns den gr√∂√üeren Bereich an, der auf der Hauptwellenform mit einem dunkelblauen Hintergrund markiert ist.  Zu diesem Zeitpunkt wird der DMA-Block bereits ausgef√ºhrt. <br><br><img src="https://habrastorage.org/webt/jw/fu/ds/jwfudsdqtgwfunc3htoczgrw5eg.png"><br><br>  10 Zyklen pro GPIO-Leitungswechsel.  Tats√§chlich geht die Arbeit mit RAM, und das Programm wird in einem konstanten Zyklus wiederholt.  Es gibt keine RAM-Aufrufe vom Prozessorkern.  Der Bus steht der DMA-Einheit vollst√§ndig zur Verf√ºgung, jedoch 10 Zyklen.  Tats√§chlich unterscheiden sich die Ergebnisse jedoch nicht wesentlich von denen auf der PSoC. Suchen Sie daher einfach nach Anwendungshinweisen zu DMA auf STM32.  Es gab mehrere von ihnen.  Es gibt AN2548 auf F0 / F1, es gibt AN3117 auf L0 / L1 / L3, es gibt AN4031 auf F2 / F4 / F77.  Vielleicht gibt es noch mehr ... <br><br>  Trotzdem sehen wir bei ihnen, dass auch hier die Latenz schuld ist.  Dar√ºber hinaus ist der Batch-Zugriff des F103 auf den Bus mit DMA nicht m√∂glich.  Sie sind f√ºr F4 m√∂glich, jedoch nicht mehr als f√ºr vier W√∂rter.  Andererseits tritt das Latenzproblem auf. <br><br>  Versuchen wir, die gleichen Aktionen auszuf√ºhren, jedoch mithilfe eines Programmdatensatzes.  Oben haben wir gesehen, dass die direkte Aufzeichnung an Ports sofort erfolgt.  Aber es gab ziemlich eine perfekte Aufzeichnung.  Zeilen: <br><br><pre> <code class="plaintext hljs">//    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set();</code> </pre><br>  vorbehaltlich solcher Optimierungseinstellungen (Sie m√ºssen die Optimierung f√ºr die Zeit angeben): <br><br><img src="https://habrastorage.org/webt/zz/cs/vt/zzcsvtte2m06u7tzhkfefvfa8wg.png"><br><br>  wurde in den folgenden Assembler-Code umgewandelt: <br><br><pre> <code class="plaintext hljs"> STR r6,[r2,#0x00] MOV r0,#0x20000 STR r0,[r2,#0x00] STR r6,[r2,#0x00]</code> </pre><br>  Beim realen Kopieren wird die Quelle, der Empf√§nger aufgerufen, die Schleifenvariable ge√§ndert, verzweigt ... Im Allgemeinen viel Overhead (der, wie angenommen wird, nur den DMA eliminiert).  Wie schnell werden sich die √Ñnderungen im Hafen √§ndern?  Also schreiben wir: <br><br><pre> <code class="plaintext hljs">uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Dieser C ++ - Code wird zu einem solchen Assemblycode: <br><br><pre> <code class="plaintext hljs"> MOVS r1,#0x0E LDRH r3,[r0],#0x02 STRH r3,[r2,#0x00] LDRH r3,[r0],#0x02 SUBS r1,r1,#2 STRH r3,[r2,#0x00] CMP r1,#0x00 BGT 0x080032A8</code> </pre><br>  Und wir bekommen: <br><br><img src="https://habrastorage.org/webt/oj/m5/1d/ojm51d2qjhkz_rii2zfb4zvzdos.png"><br><br>  8 Takte in der oberen H√§lfte und 6 in der unteren H√§lfte (ich habe √ºberpr√ºft, das Ergebnis wird f√ºr alle Halbperioden wiederholt).  Der Unterschied ergab sich, weil der Optimierer 2 Kopien pro Iteration erstellt hat.  Daher werden dem Zweigbetrieb 2 Takte in einer der Halbperioden hinzugef√ºgt. <br><br>  <b>Grob gesagt werden beim Kopieren von Software 14 Takte f√ºr das Kopieren von zwei W√∂rtern gegen 20 Takte auf demselben ausgegeben, jedoch von DMA.</b>  <b>Das Ergebnis ist ziemlich dokumentiert, aber f√ºr diejenigen, die die erweiterte Literatur noch nicht gelesen haben, sehr unerwartet.</b> <br><br>  Gut.  Aber was passiert, wenn Sie Daten gleichzeitig in zwei DMA-Streams schreiben?  Wie viel Geschwindigkeit wird fallen?  Schlie√üen Sie den blauen Strahl an PA0 an und schreiben Sie das Programm wie folgt neu: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Lassen Sie uns zun√§chst die Art der Impulse untersuchen: <br><br><img src="https://habrastorage.org/webt/vu/ki/pg/vukipghxkaqqtxdnvz4a2qjp1wu.png"><br><br>  W√§hrend der zweite Kanal eingestellt wird, ist die Kopiergeschwindigkeit f√ºr den ersten h√∂her.  Wenn Sie dann paarweise kopieren, sinkt die Geschwindigkeit.  Wenn der erste Kanal fertig ist, beginnt der zweite schneller zu arbeiten.  Alles ist logisch, es bleibt nur herauszufinden, um wie viel die Geschwindigkeit sinkt. <br><br>  W√§hrend es nur einen Kanal gibt, dauert die Aufnahme 10 bis 12 Takte (Ziffern schweben). <br><br><img src="https://habrastorage.org/webt/iw/1l/lk/iw1llkwh0nki1yczmva7gzxgrgk.png"><br><br>  W√§hrend der Zusammenarbeit erhalten wir 16 Zyklen pro Datensatz in jedem Port: <br><br><img src="https://habrastorage.org/webt/f6/vf/o3/f6vfo3mgv4mpos2kdrrwmo9dzsm.png"><br><br>  Das hei√üt, die Geschwindigkeit wird nicht halbiert.  Aber was ist, wenn Sie anfangen, in drei Threads gleichzeitig zu schreiben?  Wir f√ºgen Arbeit mit PC15 hinzu, da PC0 nicht ausgegeben wird (deshalb werden nicht 0, 1, 0, 1 ..., sondern 0x0000,0x8001, 0x0000, 0x8001 ... im Array ausgegeben). <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; typedef Mcucpp::Dma1Channel3 channel3; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Hier ist das Ergebnis so unerwartet, dass ich den Strahl ausschalte, der die Taktfrequenz anzeigt.  Wir haben keine Zeit f√ºr Messungen.  Wir betrachten die Logik der Arbeit. <br><br><img src="https://habrastorage.org/webt/zo/u3/5s/zou35sqtetrlryln8lxe04tdkwy.png"><br><br>  Bis der erste Kanal die Arbeit beendet hatte, begann der dritte nicht mit der Arbeit.  Drei Kan√§le gleichzeitig funktionieren nicht!  Etwas zu diesem Thema kann aus AppNote zu DMA abgeleitet werden. Es hei√üt, dass F103 nur zwei Engines in einem Block hat (und wir kopieren mit einem Block von DMA, der zweite ist jetzt inaktiv und das Volumen des Artikels ist bereits so, dass ich es verwenden kann Ich werde nicht).  Wir schreiben das Beispielprogramm so um, dass der dritte Kanal fr√ºher startet als alle anderen: <br><br><img src="https://habrastorage.org/webt/bs/ld/kc/bsldkce9ztqrbk15x7e1omcharg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  Das Bild √§ndert sich wie folgt: <br><br><img src="https://habrastorage.org/webt/jg/wr/_2/jgwr_2kidbaoxg_-17muiyvo3n4.png"><br><br>  Der dritte Kanal wurde gestartet, er arbeitete sogar mit dem ersten zusammen, aber als der zweite ins Gesch√§ft kam, wurde der dritte ersetzt, bis der erste Kanal fertiggestellt war. <br><br><h2>  Ein bisschen √ºber Priorit√§ten </h2><br>  Tats√§chlich bezieht sich das vorherige Bild auf die Priorit√§ten von DMA, es gibt einige.  Wenn alle Arbeitskan√§le die gleiche Priorit√§t haben, kommen ihre Nummern ins Spiel.  Innerhalb einer bestimmten Priorit√§t hat derjenige, der eine kleinere Anzahl hat, die Priorit√§t.  Versuchen wir, auf dem dritten Kanal eine andere globale Priorit√§t anzugeben und diese vor allen anderen zu erh√∂hen (auf dem Weg werden wir auch die Priorit√§t des zweiten Kanals erh√∂hen): <br><br><img src="https://habrastorage.org/webt/40/qo/c5/40qoc5ngwnq2tenzpmcc2ornd4w.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">channel3::Init (channel3::PriorityVeryHigh|channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel1::PriorityVeryHigh|channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  Jetzt wird der erste, der fr√ºher am coolsten war, benachteiligt. <br><br><img src="https://habrastorage.org/webt/te/mq/_7/temq_7wguw109a0t-oi_rsi3jju.png"><br><br>  Insgesamt sehen wir, dass STM32F103 selbst bei Priorit√§ten nicht mehr als zwei Threads auf einem DMA-Block starten kann.  Grunds√§tzlich kann der dritte Thread auf dem Prozessorkern ausgef√ºhrt werden.  Auf diese Weise k√∂nnen wir die Leistung vergleichen. <br><br><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Zun√§chst das allgemeine Bild, das zeigt, dass alles parallel funktioniert und der Prozessorkern die h√∂chste Kopiergeschwindigkeit aufweist: <br><br><img src="https://habrastorage.org/webt/yq/bc/ah/yqbcahagnawdxrr70dh7zvbetmo.png"><br><br>  Und jetzt gebe ich jedem die M√∂glichkeit, die Ma√ünahmen zu einem Zeitpunkt zu z√§hlen, an dem alle Kopierstr√∂me aktiv sind: <br><br> <a href=""><img src="https://habrastorage.org/webt/_m/m9/2b/_mm92b5yfgjltz6cizilmdtg4d4.png"></a> <br><br><h2>  Der Prozessorkern priorisiert alle </h2><br>  Kommen wir nun zu der Tatsache zur√ºck, dass w√§hrend des Zweithread-Betriebs, w√§hrend der zweite Kanal abgestimmt war, der erste Daten f√ºr eine andere Anzahl von Taktzyklen ausgegeben hat.  Diese Tatsache ist auch in AppNote on DMA gut dokumentiert.  Tatsache ist, dass w√§hrend des Aufbaus des zweiten Kanals regelm√§√üig Anforderungen an den RAM gesendet wurden und der Prozessorkern beim Zugriff auf den RAM eine h√∂here Priorit√§t hat als der DMA-Kern.  Wenn der Prozessor einige Daten anforderte, nahm DMA Taktzyklen weg, empfing Daten mit einer Verz√∂gerung und kopierte daher langsamer.  Lassen Sie uns das letzte Experiment f√ºr heute machen.  Lassen Sie uns die Arbeit realer gestalten.  Nach dem Starten von DMA gehen wir nicht in einen leeren Zyklus (wenn definitiv kein Zugriff auf RAM besteht), sondern f√ºhren eine Kopieroperation von RAM zu RAM durch, aber diese Operation bezieht sich nicht auf die Operation von DMA-Kernen: <br><br><pre> <code class="plaintext hljs">channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint32_t src1[0x200]; uint32_t dest1 [0x200]; while (1) { uint32_t* src = src1; uint32_t* dest = dest1; for (int i=sizeof(src1)/sizeof(src1[0]);i&gt;0;i--) { *dest++ = *src++; } }</code> </pre><br> <a href=""><img src="https://habrastorage.org/webt/ks/k-/c6/ksk-c6feobygy2krzseq0nlka78.png"></a> <br><br>  An einigen Stellen erstreckte sich der Zyklus von 16 auf 17 Ma√ünahmen.  Ich hatte Angst, dass es schlimmer werden w√ºrde. <br><br><h2>  Fangen Sie an, Schlussfolgerungen zu ziehen </h2><br>  Eigentlich wenden wir uns dem zu, was ich sagen wollte. <br><br>  Ich werde von weitem anfangen.  Vor einigen Jahren, als ich anfing, STM32 zu studieren, studierte ich die damals existierenden Versionen von MiddleWare f√ºr USB und fragte mich, warum die Entwickler die Daten√ºbertragung √ºber DMA entfernt hatten.  Es war offensichtlich, dass zun√§chst eine solche Option in Sicht war, dann wurde sie in die Hinterh√∂fe verlegt, und am Ende gab es nur noch Grundlagen.  Jetzt fange ich an zu vermuten, dass ich die Entwickler verstehe. <br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel √ºber UDB habe</a> ich gesagt, dass UDB zwar mit parallelen Daten arbeiten kann, es jedoch unwahrscheinlich ist, dass es GPIF durch sich selbst ersetzen kann, da der PSoC-USB-Bus f√ºr FX2LP mit voller Geschwindigkeit im Vergleich zu hoher Geschwindigkeit l√§uft.  Es stellt sich heraus, dass es einen schwerwiegenderen begrenzenden Faktor gibt.  DMA hat einfach keine Zeit, Daten mit der gleichen Geschwindigkeit wie das GPIF zu liefern, selbst innerhalb des Controllers, ohne den USB-Bus zu ber√ºcksichtigen. <br><br>  Wie Sie sehen k√∂nnen, gibt es keine einzelne Entit√§ts-DMA.  Erstens macht jeder Hersteller seinen eigenen Weg.  Nicht nur das, auch ein Hersteller f√ºr verschiedene Familien kann den Ansatz zum Aufbau von DMA variieren.  Wenn Sie dieses Ger√§t ernsthaft laden m√∂chten, sollten Sie sorgf√§ltig pr√ºfen, ob die Anforderungen erf√ºllt werden. <br><br>  Wahrscheinlich ist es notwendig, den pessimistischen Fluss mit einer optimistischen Bemerkung zu verd√ºnnen.  Ich werde sie sogar hervorheben. <br><br>  <b>Mit DMA von Cortex M-Controllern k√∂nnen Sie die Systemleistung nach dem Prinzip der ber√ºhmten Javelins steigern: "Starten und vergessen".</b>  <b>Ja, das Kopieren von Daten durch Software ist etwas schneller.</b>  <b>Wenn Sie jedoch mehrere Threads kopieren m√ºssen, kann kein Optimierer den Prozessor dazu bringen, alle Threads zu steuern, ohne dass der Aufwand f√ºr das Neuladen von Registern und das Drehen von Schleifen anf√§llt.</b>  <b>Au√üerdem muss der Prozessor bei langsamen Ports noch auf die Verf√ºgbarkeit warten, und DMA tut dies auf Hardwareebene.</b> <br><br>  Aber auch hier sind verschiedene Nuancen m√∂glich.  Wenn der Port nur relativ langsam ist ... Angenommen, ein SPI arbeitet mit der h√∂chstm√∂glichen Frequenz, dann gibt es theoretisch m√∂gliche Situationen, in denen der DMA keine Zeit hat, Daten aus dem Puffer zu sammeln, und ein √úberlauf auftritt.  Oder umgekehrt - legen Sie die Daten in das Pufferregister.  Wenn der Datenstrom einzeln ist, ist dies unwahrscheinlich, aber wenn es viele davon gibt, haben wir gesehen, welche erstaunlichen √úberlagerungen auftreten k√∂nnen.  Um dies zu bew√§ltigen, sollten Sie Aufgaben nicht separat, sondern in Kombination entwickeln.  Und Tester versuchen, solche Probleme zu provozieren (solch eine zerst√∂rerische Arbeit f√ºr Tester). <br><br>  Wieder versteckt niemand diese Daten.  Aus irgendeinem Grund ist all dies normalerweise nicht im Hauptdokument enthalten, sondern in den Anwendungshinweisen.  Meine Aufgabe war es daher, die Programmierer darauf aufmerksam zu machen, dass DMA kein Allheilmittel, sondern nur ein praktisches Werkzeug ist. <br><br>  Aber nat√ºrlich nicht nur Programmierer, sondern auch Hardwareentwickler.  Angenommen, in unserer Organisation wird ein gro√üer Software- und Hardwarekomplex f√ºr das Remote-Debugging eingebetteter Systeme entwickelt.  Die Idee ist, dass jemand ein Ger√§t entwickelt, aber die "Firmware" nebenbei bestellen m√∂chte.  Und aus irgendeinem Grund kann keine Ausr√ºstung zur Seite gestellt werden.  Es kann sperrig sein, es kann teuer sein, es kann einzigartig sein und ‚Äûes selbst brauchen‚Äú, verschiedene Gruppen k√∂nnen in verschiedenen Zeitzonen damit arbeiten, eine Art Mehrschichtarbeit bieten, es kann st√§ndig in Erinnerung gerufen werden ... Im Allgemeinen k√∂nnen Sie Gr√ºnde finden Sehr viel, unsere Gruppe hat diese Aufgabe einfach f√ºr selbstverst√§ndlich gehalten. <br><br>  Dementsprechend sollte der Debugging-Komplex in der Lage sein, so viele externe Ger√§te wie m√∂glich zu simulieren, von der trivialen Simulation von Tastendr√ºcken bis zu verschiedenen Protokollen SPI, I2C, CAN, 4-20 mA und anderen, anderen Dingen, damit Emulatoren durch sie unterschiedliche Verhaltensweisen externer Ger√§te wiederherstellen k√∂nnen Bl√∂cke, die mit der zu entwickelnden Ausr√ºstung verbunden sind (ich pers√∂nlich habe einmal viele Simulatoren f√ºr das Boden-Debugging von Anbauger√§ten f√ºr Hubschrauber erstellt, auf unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website werden die entsprechenden F√§lle mit dem Wort Cassel Aero gesucht</a> ). <br><br>  Und so in den technischen Anforderungen f√ºr die Entwicklung bestimmter Anforderungen.  So viel SPI, so viel I2C, so viel GPIO.  Sie m√ºssen bei solchen und solchen extremen Frequenzen arbeiten.  Alles scheint klar zu sein.  Wir haben STM32F4 und ULPI f√ºr die Arbeit mit USB in den HS-Modus versetzt.  Die Technologie ist bew√§hrt.  Aber hier kommt ein langes Wochenende mit den Novemberferien, die ich mit UDB herausgefunden habe.  Als ich sah, dass etwas nicht stimmte, bekam ich abends die praktischen Ergebnisse, die am Anfang dieses Artikels angegeben sind.  Und mir wurde klar, dass nat√ºrlich alles gro√üartig ist, aber nicht f√ºr dieses Projekt.  Wie bereits erw√§hnt, sollte, wenn sich die m√∂gliche maximale Systemleistung der Obergrenze n√§hert, alles nicht separat, sondern in einem Komplex entworfen werden. <br><br>  Aber hier kann eine integrierte Gestaltung von Aufgaben grunds√§tzlich nicht sein.       ,  ‚Äî   .           .    ,         FTDI.    --      ,       USB . .        DMA. , , ,    ,      ‚Äì  ,   . <br><br>   .        DMA   (,    10:    1    , ,    1 ,  10  )     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437112/">https://habr.com/ru/post/de437112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437102/index.html">Neues Lego-Champion-Treffen: Lego Boost</a></li>
<li><a href="../de437104/index.html">Introskop: Nun, sehr fauler Unit-Test</a></li>
<li><a href="../de437106/index.html">IT in der Zone .it</a></li>
<li><a href="../de437108/index.html">Die meisten Texte im Internet werden von Verr√ºckten geschrieben.</a></li>
<li><a href="../de437110/index.html">Nanomaterialien ver√§ndern unsere Welt, und wir haben immer noch keine Verfahren zur √úberpr√ºfung ihrer Sicherheit</a></li>
<li><a href="../de437114/index.html">Offenes Webinar: ‚ÄûSSH / NC / Socat: Tipps und Tricks‚Äú</a></li>
<li><a href="../de437116/index.html">AWS, MongoDB und die wirtschaftlichen Realit√§ten von Open Source</a></li>
<li><a href="../de437118/index.html">AI und 2048. Teil 1: Monte-Carlo-Methode</a></li>
<li><a href="../de437120/index.html">Koreanischer B√ºrostuhl: Harachair Miracle Sensations</a></li>
<li><a href="../de437122/index.html">Dinge benennen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>