<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó°Ô∏è üñ®Ô∏è üöî Sin embargo, C es un lenguaje de bajo nivel. üëå üÜó üßõüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante la √∫ltima d√©cada desde la llegada del lenguaje C, se han creado muchos lenguajes de programaci√≥n interesantes. Algunos de ellos todav√≠a se usa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sin embargo, C es un lenguaje de bajo nivel.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/465429/"><p><img src="https://habrastorage.org/webt/0w/1l/ey/0w1leycdhljvvpoqezgzueoho8a.jpeg"></p><br><p>  Durante la √∫ltima d√©cada desde la llegada del lenguaje C, se han creado muchos lenguajes de programaci√≥n interesantes.  Algunos de ellos todav√≠a se usan, otros han influido en la pr√≥xima generaci√≥n de idiomas, la popularidad del tercero se ha desvanecido en silencio.  Mientras tanto, arcaico, controvertido, primitivo, hecho en las peores tradiciones de su generaci√≥n de lenguajes C (y sus herederos) m√°s vivos que todos los seres vivos. </p><br><p>  La cr√≠tica C es un g√©nero epistolar cl√°sico para nuestra industria.  Suena m√°s fuerte, luego m√°s tranquilo, pero √∫ltimamente ha sido literalmente impresionante.  Un ejemplo es una traducci√≥n del art√≠culo de David Ciswell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C no es un lenguaje de bajo nivel",</a> publicado en nuestro blog hace alg√∫n tiempo.  Puedes decir cosas diferentes sobre C, realmente hay muchos errores desagradables en el dise√±o del lenguaje, ¬°pero rechazar C en "nivel bajo" es demasiado! </p><br><p>  Para no tolerar tal injusticia, tom√© coraje e intent√© decidir qu√© era un lenguaje de programaci√≥n de bajo nivel y qu√© pr√°cticas quer√≠an de √©l, despu√©s de lo cual repas√© los argumentos de los cr√≠ticos C. As√≠ es como result√≥ este art√≠culo. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Argumentos de cr√≠tica C</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lenguaje de programaci√≥n de bajo nivel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No se trata solo de PDP-11</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optimizando compiladores y lenguaje de bajo nivel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Est√°ndar como un bien absoluto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitecturas alternativas - inform√°tica especial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C vivir√°</a> </li></ul><br><h1 id="argumenty-kritikov-c">  Argumentos de cr√≠tica C </h1><br><p>  Estos son algunos de los argumentos de los cr√≠ticos de C, incluidos los del art√≠culo de David Chiznell: </p><br><ol><li>  La m√°quina abstracta del lenguaje C es demasiado similar a la arquitectura PDP-11 obsoleta, que ha dejado de corresponder durante mucho tiempo al dispositivo de los procesadores modernos populares. </li><li> La falta de coincidencia entre una m√°quina abstracta y el dispositivo de m√°quinas reales complica el desarrollo de la optimizaci√≥n de compiladores de lenguaje. </li><li>  La incompletitud y complejidad del lenguaje est√°ndar lleva a discrepancias en las implementaciones est√°ndar. </li><li>  El dominio de los lenguajes tipo C no permite explorar arquitecturas de procesador alternativas. </li></ol><br><p>  Primero determinemos los requisitos para un lenguaje de bajo nivel, despu√©s de lo cual volveremos a los argumentos dados. </p><br><h1 id="yazyk-programmirovaniya-nizkogo-urovnya">  Lenguaje de programaci√≥n de bajo nivel </h1><br><p>  No existe una definici√≥n universalmente aceptada de lenguaje de bajo nivel.  Pero antes de discutir temas controvertidos, es deseable tener al menos algunos requisitos iniciales para el tema de la disputa. </p><br><p>  Nadie discutir√° que el lenguaje ensamblador est√° en el nivel m√°s bajo.  Pero en cada plataforma es √∫nico, por lo que el c√≥digo en dicho lenguaje no puede ser port√°til.  Incluso en una plataforma compatible con versiones anteriores, es posible que deba usar algunas instrucciones nuevas. </p><br><p>  A partir de aqu√≠ sigue el primer requisito para un lenguaje de bajo nivel: debe conservar <em>caracter√≠sticas comunes para plataformas populares</em> .  En pocas palabras, el compilador debe ser port√°til.  La portabilidad del compilador simplifica el desarrollo de compiladores de lenguaje para nuevas plataformas, y la variedad de plataformas soportadas por los compiladores elimina la necesidad de que los desarrolladores reescriban programas de aplicaci√≥n para cada nueva m√°quina. </p><br><p>  El primer requisito entra en conflicto con los deseos de los desarrolladores de programas especiales: lenguajes de programaci√≥n, controladores, sistemas operativos y bases de datos de alto rendimiento.  Los programadores que escriben estos programas quieren poder optimizar manualmente, trabajar directamente con la memoria, etc.  En una palabra, un lenguaje de bajo nivel <em>deber√≠a permitir trabajar con los detalles de la implementaci√≥n de la plataforma</em> . </p><br><p>  Encontrar un equilibrio entre estos dos requisitos (identificar aspectos comunes a las plataformas y acceder a tantos detalles como sea posible) es una raz√≥n fundamental de la dificultad de desarrollar un lenguaje de bajo nivel. </p><br><p>  Tenga en cuenta que las abstracciones de alto nivel no son tan importantes para ese lenguaje; es m√°s importante que sirva como un contrato entre la plataforma, el compilador y el desarrollador.  Y si hay un contrato, entonces se necesita un <em>lenguaje independiente del est√°ndar de implementaci√≥n particular</em> . </p><br><p>  Nuestro primer requisito, caracter√≠sticas comunes a las plataformas de destino, se expresa en una m√°quina de lenguaje abstracto, por lo que comenzaremos la discusi√≥n con C. </p><br><h1 id="delo-ne-tolko-v-pdp-11">  No se trata solo de PDP-11 </h1><br><p>  La plataforma en la que apareci√≥ el lenguaje C es PDP-11.  Se basa en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arquitectura</a> tradicional de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">von Neumann</a> , en la cual los programas son ejecutados secuencialmente por el procesador central, y la memoria es una cinta plana, donde se almacenan tanto los datos como los programas.  Dicha arquitectura se implementa f√°cilmente en hardware, y con el tiempo, todas las computadoras de uso general comenzaron a usarla. </p><br><p>  Las mejoras modernas a la arquitectura de von Neumann tienen como objetivo eliminar su principal cuello de botella: retrasos en el intercambio de datos entre el procesador y la memoria ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuello de botella de von Neuman en</a> ingl√©s).  La diferencia en el rendimiento de la memoria y la CPU condujo a la aparici√≥n de subsistemas de procesadores de almacenamiento en cach√© (de un solo nivel y m√°s tarde de varios niveles). </p><br><p>  Pero incluso los cach√©s en estos d√≠as no son suficientes.  Los procesadores modernos se han convertido en superescalares.  Los retrasos cuando las instrucciones reciben datos de la memoria son parcialmente compensados ‚Äã‚Äãpor la ejecuci√≥n extraordinaria ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralelismo a nivel</a> de instrucci√≥n) de las instrucciones, junto con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">predictor de rama</a> . </p><br><p>  La m√°quina abstracta secuencial C (y muchos otros lenguajes) imita el trabajo no tanto espec√≠ficamente de PDP-11, sino de cualquier computadora dispuesta de acuerdo con el principio de la arquitectura von Neumann.  Incluye arquitecturas construidas alrededor de procesadores con un solo n√∫cleo: escritorio y servidor x86, ARM m√≥vil, proveniente de la escena de Sun / Oracle SPARC e IBM POWER. </p><br><p>  Con el tiempo, varios n√∫cleos de procesamiento comenzaron a integrarse en un procesador, como resultado de lo cual se hizo necesario mantener la coherencia de las memorias cach√© de cada n√∫cleo y los protocolos de interacci√≥n internuclear requeridos.  La arquitectura de von Neumann se escal√≥ a varios n√∫cleos. </p><br><p>  La versi√≥n original de la m√°quina abstracta C era secuencial, no reflejaba la presencia de hilos de ejecuci√≥n del programa que interactuaban a trav√©s de la memoria.  La aparici√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo de memoria</a> en el est√°ndar expandi√≥ las capacidades de la m√°quina abstracta al paralelo. </p><br><p>  Por lo tanto, la afirmaci√≥n de que la m√°quina C abstracta ha sido inconsistente durante mucho tiempo con la estructura de los procesadores modernos no se refiere tanto a un lenguaje espec√≠fico, sino a las computadoras que usan la arquitectura von Neumann, incluso en ejecuci√≥n paralela. </p><br><p>  Pero como profesional, quiero se√±alar lo siguiente: podemos suponer que el enfoque de Fonneimann est√° desactualizado, podemos suponer que es relevante, pero esto no cancela el hecho de que las arquitecturas populares de uso general de hoy en d√≠a usan derivados de los enfoques tradicionales. </p><br><p>  La realizaci√≥n estandarizada y port√°til de la arquitectura von Neumann, la m√°quina abstracta C, se implementa convenientemente en todas las plataformas principales y, por lo tanto, goza de su popularidad como ensamblador port√°til. </p><br><h1 id="optimiziruyuschie-kompilyatory-i-yazyk-nizkogo-urovnya">  Optimizando compiladores y lenguaje de bajo nivel </h1><br><p>  Nuestro segundo requisito para un lenguaje de bajo nivel es el acceso a los detalles de implementaci√≥n de bajo nivel de cada una de las plataformas populares.  En el caso de C, este es un trabajo directo con memoria y objetos como una matriz de bytes, la capacidad de trabajar directamente con direcciones de bytes y aritm√©tica avanzada de puntero. </p><br><p>  Los cr√≠ticos de C se√±alan que el est√°ndar de lenguaje ofrece demasiadas garant√≠as con respecto, por ejemplo, a la ubicaci√≥n de campos individuales en estructuras y asociaciones.  Junto con punteros y mecanismos primitivos de bucles, esto complica el trabajo del optimizador. </p><br><p>  De hecho, un enfoque m√°s declarativo permitir√≠a al compilador resolver de forma independiente los problemas de alineaci√≥n de datos en la memoria o el orden √≥ptimo de los campos en las estructuras;  y los ciclos de nivel superior le dan la libertad que necesita al vectorizar. </p><br><p>  La posici√≥n de los desarrolladores de C en este caso es la siguiente: un lenguaje de bajo nivel deber√≠a permitirle trabajar a un nivel lo suficientemente bajo como para que el programador resuelva de forma independiente los problemas de optimizaci√≥n.  Dentro de C, es posible trabajar como compilador, eligiendo, por ejemplo, instrucciones SIMD y colocando correctamente los datos en la memoria. </p><br><p>  En otras palabras, nuestro requisito de acceso a los detalles de implementaci√≥n de cada plataforma entra en conflicto con los deseos de los desarrolladores de optimizar los compiladores precisamente debido a la presencia de herramientas de bajo nivel. </p><br><p>  Curiosamente, Chiznell en un art√≠culo titulado "C no es un lenguaje de bajo nivel" parad√≥jicamente afirma que C es de <em>muy</em> bajo nivel, lo que indica la ausencia de herramientas de alto nivel.  Pero los profesionales necesitan exactamente herramientas de bajo nivel; de lo contrario, el lenguaje no puede usarse para desarrollar sistemas operativos y otros programas de bajo nivel, es decir, no satisfar√° el segundo de nuestros requisitos. </p><br><p>  Distrayendo de la descripci√≥n de los problemas de optimizaci√≥n, es decir, C, quiero se√±alar que en este momento no se invierte menos esfuerzo en optimizar los compiladores de lenguajes de alto nivel (el mismo C # y Java) que en GCC o Clang.  Los lenguajes funcionales tambi√©n tienen suficientes compiladores efectivos: MLTon, OCaml y otros.  Pero los desarrolladores del mismo OCaml todav√≠a pueden presumir de rendimiento en el mejor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de los</a> casos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a la mitad de la velocidad del c√≥digo C</a> ... </p><br><h1 id="standart-kak-bezuslovnoe-blago">  Est√°ndar como un bien absoluto </h1><br><p>  En su art√≠culo, Chiznell cita los resultados de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encuesta</a> realizada en 2015: muchos programadores cometieron errores al resolver problemas de comprensi√≥n de los est√°ndares C. </p><br><p>  Supongo que uno de los lectores estaba tratando con el est√°ndar C. Tengo una versi√≥n en papel de C99, una especie de 900 p√°ginas. Esta no es una especificaci√≥n de esquema lac√≥nico con un volumen de menos de 100 p√°ginas y no un ML est√°ndar lamido, que consta de 300. Diversi√≥n desde el trabajo nadie obtiene el est√°ndar C: ni los desarrolladores de compiladores, ni los desarrolladores de documentos, ni los programadores. </p><br><p>  Pero debemos entender que el est√°ndar C se desarroll√≥ despu√©s del hecho, despu√©s de la aparici√≥n de muchos dialectos compatibles de "casi lugares".  Los autores de ANSI C han hecho un gran trabajo resumiendo las implementaciones existentes y cubri√©ndolas con innumerables "muletas" de no ortogonalidad en el dise√±o del lenguaje. </p><br><p>  Puede parecer extra√±o que alguien se haya comprometido a implementar dicho documento.  Pero C ha sido implementado por muchos compiladores.  No volver√© a contar las historias de otros sobre el zool√≥gico del mundo UNIX de finales de los 80, especialmente porque en ese momento yo mismo no lo consideraba con mucha confianza y solo hasta las cinco.  Pero, obviamente, todos en la industria realmente necesitaban un est√°ndar. </p><br><p>  Lo bueno es que existe y est√° implementado por al menos tres compiladores grandes y muchos compiladores m√°s peque√±os, que en conjunto son compatibles con cientos de plataformas.  Ninguno de los idiomas de la competencia C, que reclama la corona del rey de los idiomas de bajo nivel, puede presumir de tanta diversidad y versatilidad. </p><br><p>  En realidad, el est√°ndar C actual no es tan malo.  Un programador m√°s o menos experimentado puede desarrollar un compilador de C no optimizador en un tiempo razonable, lo que se confirma por la existencia de muchas implementaciones semi-amateur (el mismo TCC, LCC y 8cc). </p><br><p>  Tener un est√°ndar generalmente aceptado significa que C satisface el √∫ltimo de nuestros requisitos para un lenguaje de bajo nivel: este lenguaje se basa en una especificaci√≥n, no en una implementaci√≥n espec√≠fica. </p><br><h1 id="alternativnye-arhitektury---udel-specialnyh-vychisleniy">  Arquitecturas alternativas - inform√°tica especial </h1><br><p>  Pero Lifewell cita otro argumento, volviendo al dispositivo de los procesadores modernos de uso general que implementan las opciones de arquitectura von Neumann.  Afirma que tiene sentido cambiar los principios del procesador central.  Una vez m√°s, esta cr√≠tica no es espec√≠fica de C, sino del modelo m√°s b√°sico de programaci√≥n imperativa. </p><br><p>  De hecho, hay muchas alternativas al enfoque tradicional con ejecuci√≥n secuencial de programas: modelos SIMD en el estilo GPU, modelos en el estilo de una m√°quina Erlang abstracta, y otros.  Pero cada uno de estos enfoques tiene una aplicabilidad limitada cuando se usa en un procesador central. </p><br><p>  Las GPU, por ejemplo, multiplican notablemente las matrices en los juegos y el aprendizaje autom√°tico, pero son dif√≠ciles de usar para el trazado de rayos.  En otras palabras, este modelo es adecuado para aceleradores especializados, pero no funciona para procesadores de prop√≥sito general. </p><br><p>  Erlang funciona muy bien en un cl√∫ster, pero es dif√≠cil hacer una clasificaci√≥n r√°pida eficiente o una tabla hash r√°pida.  El modelo de actores independientes se usa mejor en un nivel superior, en un grupo grande, donde cada nodo sigue siendo la misma m√°quina de alto rendimiento con un procesador tradicional. </p><br><p>  Mientras tanto, los procesadores modernos compatibles con x86 han incluido durante mucho tiempo un conjunto de instrucciones vectoriales similares a la GPU en cuanto a prop√≥sito y principios operativos, pero conservando el circuito del procesador general en el estilo de von Neumann en su conjunto.  No tengo dudas de que cualquier enfoque bastante general de la inform√°tica se incluir√° en los procesadores populares. </p><br><p>  Existe una opini√≥n tan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autorizada</a> : el futuro reside en aceleradores programables especializados.  Bajo piezas de hierro tan extraordinarias, realmente tiene sentido desarrollar lenguajes con sem√°ntica especial.  Pero una computadora de uso general era y sigue siendo similar a la PDP-11 para la cual los lenguajes imperativos tipo C son muy adecuados. </p><br><h1 id="s-budet-zhit">  C vivir√° </h1><br><p>  Hay una contradicci√≥n fundamental en el art√≠culo de Chiznell.  √âl escribe que para garantizar la velocidad de los programas en C, los procesadores imitan la m√°quina C abstracta (y el PDP-11 olvidado hace mucho tiempo), despu√©s de lo cual se√±ala las limitaciones de dicha m√°quina.  Pero no entiendo por qu√© esto significa que "C no es un lenguaje de bajo nivel". </p><br><p>  En general, no se trata de los defectos de C como lenguaje, sino de la cr√≠tica de las arquitecturas comunes de estilo von Neumann y el modelo de programaci√≥n que se deriva de ellas.  Pero hasta ahora no parece que la industria est√© lista para abandonar la arquitectura familiar (al menos no en los procesadores de uso general). </p><br><p>  A pesar de la disponibilidad de muchos procesadores especializados como GPU y TPU, la arquitectura von Neumann est√° actualmente en control y la industria necesita un lenguaje que le permita operar al nivel m√°s bajo posible dentro del marco de la arquitectura m√°s popular.  Un lenguaje bastante simple, portado a docenas de plataformas y programaci√≥n estandarizada es C (y su familia inmediata). </p><br><p>  Por todo eso, C tiene suficientes deficiencias: una biblioteca arcaica de funciones, un est√°ndar intrincado e inconsistente y errores de dise√±o groseros.  Pero, aparentemente, los creadores del lenguaje todav√≠a hicieron algo bien. </p><br><p>  De una forma u otra, todav√≠a necesitamos un lenguaje de bajo nivel, y fue construido espec√≠ficamente para computadoras Fonneimann populares.  Y dejemos que C est√© desactualizado, pero aparentemente, cualquier sucesor tendr√° que basarse en los mismos principios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465429/">https://habr.com/ru/post/465429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465417/index.html">Complementos de volumen de almacenamiento de Kubernetes: Flexvolume a CSI</a></li>
<li><a href="../465419/index.html">Ma√±ana en la Universidad ITMO: el proceso educativo, las competiciones y la educaci√≥n en el extranjero: una selecci√≥n de los pr√≥ximos eventos</a></li>
<li><a href="../465423/index.html">Fabricaci√≥n inteligente e industria 4.0: tres tendencias tecnol√≥gicas principales</a></li>
<li><a href="../465425/index.html">Vepp: el nuevo servidor de ISPsystem y el panel de control del sitio web</a></li>
<li><a href="../465427/index.html">An√°lisis del marco Apache Dubbo RPC por el analizador de c√≥digo est√°tico PVS-Studio</a></li>
<li><a href="../465431/index.html">An√°lisis del c√≥digo fuente RPC del framework Apache Dubbo con el analizador est√°tico PVS-Studio</a></li>
<li><a href="../465433/index.html">Robots de trabajo - hombre feliz</a></li>
<li><a href="../465435/index.html">¬øQu√© distribuci√≥n es mejor para su sistema integrado?</a></li>
<li><a href="../465437/index.html">Por qu√© me negu√© a trabajar en AWS</a></li>
<li><a href="../465441/index.html">LuaVela: implementaci√≥n de Lua 5.1 basada en LuaJIT 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>