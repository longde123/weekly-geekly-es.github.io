<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¨Ô∏è üë®üèæ‚Äçüé§ üë©üèæ‚Äçüç≥ Temporizadores de JavaScript: todo lo que necesitas saber üöÉ üë®üèø‚Äçüöí üë®üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola colegas Hab√≠a una vez en Habr√© un art√≠culo escrito bajo la autor√≠a de John Rezig solo sobre este tema. Han pasado 10 a√±os y el tema a√∫n requiere ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Temporizadores de JavaScript: todo lo que necesitas saber</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/426709/">  Hola colegas  Hab√≠a una vez en Habr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo</a> escrito bajo la autor√≠a de John Rezig solo sobre este tema.  Han pasado 10 a√±os y el tema a√∫n requiere aclaraci√≥n.  Por lo tanto, ofrecemos a los interesados ‚Äã‚Äãleer el art√≠culo de Samer Buna, que ofrece no solo una descripci√≥n te√≥rica de los temporizadores en JavaScript (en el contexto de Node.js), sino tambi√©n tareas sobre ellos. <br><br><img src="https://habrastorage.org/webt/zs/0c/vx/zs0cvxfhr8yi-cnds0y27thmg0u.png"><br><a name="habracut"></a><br><br>  Hace unas semanas tuite√© la siguiente pregunta de una sola entrevista: <br><br><blockquote>  ‚Äú¬øD√≥nde est√° el c√≥digo fuente para las funciones setTimeout y setInterval?  ¬øD√≥nde lo buscar√≠as?  No puedes googlearlo :) " <br></blockquote><br>  *** Responde por ti mismo y luego sigue leyendo *** <br><br><hr><br>  Alrededor de la mitad de las respuestas a este tweet fueron incorrectas.  ¬°No, el caso NO EST√Å RELACIONADO con V8 (u otras m√°quinas virtuales)!  Funciones como <code>setTimeout</code> y <code>setInterval</code> , orgullosamente llamados JavaScript JavaScript Timers, no son parte de ninguna especificaci√≥n ECMAScript o implementaci√≥n de motor JavaScript.  Las funciones del temporizador se implementan a nivel del navegador, por lo que su implementaci√≥n difiere en los diferentes navegadores.  Los temporizadores tambi√©n se implementan de forma nativa en el tiempo de ejecuci√≥n de Node.js. <br><br>  En los navegadores, las funciones principales del temporizador se refieren a la interfaz de <code>Window</code> , que tambi√©n est√° asociada con algunas otras funciones y objetos.  Esta interfaz proporciona acceso global a todos sus elementos en el √°mbito principal de JavaScript.  Es por eso que la funci√≥n <code>setTimeout</code> se puede ejecutar directamente en la consola del navegador. <br><br>  En Node, los temporizadores son parte del objeto <code>global</code> , que est√° dise√±ado como la interfaz del navegador de <code>Window</code> .  El c√≥digo fuente de los temporizadores en Node se muestra <a href="">aqu√≠</a> . <br><br>  Puede parecerle a alguien que esta es solo una mala pregunta de la entrevista: ¬øde qu√© sirve saber esto?  Yo, como desarrollador de JavaScript, pienso de esta manera: se supone que debe saber esto, ya que lo contrario puede indicar que no comprende del todo c√≥mo V8 (y otras m√°quinas virtuales) interact√∫an con los navegadores y Node. <br><br>  Veamos algunos ejemplos y resuelva un par de tareas de temporizador, ¬øvamos? <br><br>  <i>Puede usar el comando de nodo para ejecutar los ejemplos en este art√≠culo.</i>  <i>La mayor√≠a de los ejemplos discutidos aqu√≠ aparecen en mi curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducci√≥n a Node.js</a> en Pluralsight.</i> <br><br>  <b>Ejecuci√≥n diferida de funciones</b> <br><br>  Los temporizadores son funciones de orden superior con las que puede retrasar o repetir la ejecuci√≥n de otras funciones (el temporizador recibe una funci√≥n como el primer argumento). <br><br>  Aqu√≠ hay un ejemplo de ejecuci√≥n diferida: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example1.js setTimeout( () =&gt; { console.log('Hello after 4 seconds'); }, 4 * 1000 );</span></span></code> </pre> <br>  En este ejemplo, usando <code>setTimeout</code> el mensaje de saludo se retrasa 4 segundos.  El segundo argumento para <code>setTimeout</code> es el retraso (en ms).  Multiplico 4 por 1000 para obtener 4 segundos. <br><br>  El primer argumento para <code>setTimeout</code> es una funci√≥n cuya ejecuci√≥n se retrasar√°. <br>  Si ejecuta el archivo <code>example1.js</code> con el comando de nodo, Node har√° una pausa durante 4 segundos y luego mostrar√° un mensaje de bienvenida (seguido de una salida). <br><br>  Tenga en cuenta: el primer argumento para <code>setTimeout</code> es solo una <b>referencia de funci√≥n</b> .  No deber√≠a ser una funci√≥n incorporada, como <code>example1.js</code> .  Aqu√≠ est√° el mismo ejemplo sin usar la funci√≥n incorporada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> func = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello after 4 seconds'</span></span>); }; setTimeout(func, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  <b>Pasando argumentos</b> <br><br>  Si la funci√≥n para la cual se usa <code>setTimeout</code> para retrasar acepta cualquier argumento, entonces puede usar los argumentos restantes de la funci√≥n <code>setTimeout</code> s√≠ (despu√©s de los 2 que ya hemos estudiado) para transferir los valores de los argumentos a la funci√≥n diferida. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : func(arg1, arg2, arg3, ...) //  : setTimeout(func, delay, arg1, arg2, arg3, ...)</span></span></code> </pre> <br>  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example2.js const rocks = who =&gt; { console.log(who + ' rocks'); }; setTimeout(rocks, 2 * 1000, 'Node.js');</span></span></code> </pre> <br>  La funci√≥n de <code>rocks</code> anterior, retrasada por 2 segundos, toma el argumento <code>who</code> , y al llamar a <code>setTimeout</code> pasa el valor "Node.js" como tal argumento <code>who</code> . <br><br>  Al ejecutar <code>example2.js</code> con el comando de <code>node</code> , se mostrar√° la frase "Node.js rocks" despu√©s de 2 segundos. <br><br>  <b>Temporizadores Tarea # 1</b> <br><br>  Entonces, seg√∫n el material ya estudiado sobre <code>setTimeout</code> , <code>setTimeout</code> los 2 mensajes siguientes despu√©s de los retrasos correspondientes. <br><br><ul><li>  El mensaje "Hola despu√©s de 4 segundos" se muestra despu√©s de 4 segundos. </li><li>  El mensaje "Hola despu√©s de 8 segundos" se muestra despu√©s de 8 segundos. </li></ul><br>  <i>Limitaci√≥n</i> <br><br>  En su soluci√≥n, puede definir solo una funci√≥n que contenga funciones integradas.  Esto significa que muchas llamadas <code>setTimeout</code> tendr√°n que usar la misma funci√≥n. <br><br>  <i>Soluci√≥n</i> <br><br>  As√≠ es como resolver√≠a este problema: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// solution1.js const theOneFunc = delay =&gt; { console.log('Hello after ' + delay + ' seconds'); }; setTimeout(theOneFunc, 4 * 1000, 4); setTimeout(theOneFunc, 8 * 1000, 8);</span></span></code> </pre> <br>  Para m√≠, <code>theOneFunc</code> recibe el argumento de <code>delay</code> y usa el valor de este argumento de <code>delay</code> en el mensaje que se muestra en la pantalla.  Por lo tanto, la funci√≥n puede mostrar diferentes mensajes dependiendo de qu√© valor de retraso le informaremos. <br><br>  Luego utilic√© el <code>theOneFunc</code> en dos llamadas <code>setTimeout</code> , la primera llamada se <code>setTimeout</code> despu√©s de 4 segundos y la segunda despu√©s de 8 segundos.  Ambas llamadas <code>setTimeout</code> tambi√©n reciben un tercer argumento, que representa el argumento de <code>delay</code> para el <code>theOneFunc</code> . <br><br>  Al ejecutar el archivo <code>solution1.js</code> con el comando de nodo, mostraremos los requisitos de la tarea, y el primer mensaje aparecer√° despu√©s de 4 segundos y el segundo despu√©s de 8 segundos. <br><br>  <b>Repite la funci√≥n</b> <br><br>  Pero, ¬øqu√© pasa si le pido que muestre un mensaje cada 4 segundos, por tiempo ilimitado? <br>  Por supuesto, puede <code>setTimeout</code> en un bucle, pero la API del temporizador tambi√©n ofrece la funci√≥n <code>setInterval</code> , con la que puede programar la ejecuci√≥n "eterna" de cualquier operaci√≥n. <br><br>  Aqu√≠ hay un ejemplo de <code>setInterval</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example3.js setInterval( () =&gt; console.log('Hello every 3 seconds'), 3000 );</span></span></code> </pre> <br>  Este c√≥digo mostrar√° un mensaje cada 3 segundos.  Si ejecuta <code>example3.js</code> con el comando de <code>node</code> , Node generar√° este comando hasta que fuerce el final del proceso (CTRL + C). <br><br>  <b>Cancelar temporizadores</b> <br><br>  Como se asigna una acci√≥n cuando se llama a la funci√≥n del temporizador, esta acci√≥n tambi√©n se puede deshacer antes de ejecutarse. <br><br>  La llamada <code>setTimeout</code> devuelve una ID de temporizador, y puede usar esta ID de temporizador cuando llame a <code>clearTimeout</code> para cancelar el temporizador.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example4.js const timerId = setTimeout( () =&gt; console.log('You will not see this one!'), 0 ); clearTimeout(timerId);</span></span></code> </pre> <br>  Este temporizador simple deber√≠a activarse despu√©s de 0 ms (es decir, inmediatamente), pero esto no suceder√°, ya que capturamos el valor de <code>timerId</code> y cancelamos inmediatamente este temporizador llamando a <code>clearTimeout</code> . <br><br>  Al ejecutar <code>example4.js</code> con el comando de <code>node</code> , Node no imprimir√° nada; el proceso simplemente finalizar√° de inmediato. <br><br>  Por cierto, Node.js tambi√©n proporciona otra forma de establecer <code>setTimeout</code> con un valor de 0 ms.  Hay otra funci√≥n en la API del temporizador Node.js llamada <code>setImmediate</code> , y b√°sicamente hace lo mismo que <code>setTimeout</code> con un valor de 0 ms, pero en este caso puede omitir el retraso: <br><br><pre> <code class="javascript hljs">setImmediate( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I am equivalent to setTimeout with 0 ms'</span></span>), );</code> </pre><br>  La funci√≥n <code>setImmediate</code> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compatible con todos los navegadores</a> .  No lo use en el c√≥digo del cliente. <br><br>  Junto con <code>clearTimeout</code> hay una funci√≥n <code>clearInterval</code> que hace lo mismo, pero con llamadas <code>setInerval</code> , y tambi√©n hay una llamada <code>clearImmediate</code> . <br><br>  <b>Retardo del temporizador: algo no garantizado</b> <br><br>  ¬øHa notado que en el ejemplo anterior, al realizar una operaci√≥n con <code>setTimeout</code> despu√©s de 0 ms, esta operaci√≥n no ocurre inmediatamente (despu√©s de <code>setTimeout</code> ), sino solo despu√©s de que todo el c√≥digo del script se haya ejecutado por completo (incluida la llamada <code>clearTimeout</code> )? <br><br>  Perm√≠tanme aclarar este punto con un ejemplo.  Aqu√≠ hay una llamada simple <code>setTimeout</code> que deber√≠a funcionar en medio segundo, pero esto no sucede: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// example5.js setTimeout( () =&gt; console.log('Hello after 0.5 seconds. MAYBE!'), 500, ); for (let i = 0; i &lt; 1e10; i++) { //    }</span></span></code> </pre><br>  Inmediatamente despu√©s de definir el temporizador en este ejemplo, bloqueamos sincr√≥nicamente el entorno de tiempo de ejecuci√≥n con un bucle <code>for</code> grande.  El valor de <code>1e10</code> es 1 con 10 ceros, por lo que el ciclo dura 10 mil millones de ciclos de procesador (en principio, esto simula un procesador sobrecargado).  El nodo no puede hacer nada hasta que este ciclo se complete. <br><br>  Por supuesto, en la pr√°ctica esto es muy malo, pero este ejemplo ayuda a comprender que el retraso <code>setTimeout</code> no est√° garantizado, sino el <b>valor m√≠nimo</b> .  Un valor de 500 ms significa que el retraso durar√° al menos 500 ms.  De hecho, el script tardar√° mucho m√°s en mostrar la l√≠nea de bienvenida en la pantalla.  Primero, tendr√° que esperar hasta que se complete el ciclo de bloqueo. <br><br>  <b>Temporizadores Problema # 2</b> <br><br>  Escriba un script que muestre el mensaje "Hola mundo" una vez por segundo, pero solo 5 veces.  Despu√©s de 5 iteraciones, el script debe mostrar un mensaje "Listo", despu√©s del cual se completar√° el proceso Nodo. <br><br>  <i>Limitaci√≥n</i> : al resolver este problema, no puede llamar a <code>setTimeout</code> . <br><br>  <i>Sugerencia</i> : necesita un contador. <br><br>  <i>Soluci√≥n</i> <br><br>  As√≠ es como resolver√≠a este problema: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>); clearInterval(intervalId); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Establec√≠ 0 como el valor inicial del <code>counter</code> , y luego llam√© a <code>setInterval</code> , que toma su id. <br><br>  Una funci√≥n diferida mostrar√° un mensaje y cada vez aumentar√° el contador en uno.  Dentro de la funci√≥n diferida, tenemos una instrucci√≥n if, que verificar√° si ya han pasado 5 iteraciones.  Despu√©s de 5 iteraciones, el programa muestra "Listo" y borra el valor del intervalo utilizando la constante del <code>intervalId</code> . Del <code>intervalId</code> capturado.  El intervalo de retraso es de 1000 ms. <br><br>  <b>¬øQui√©n llama exactamente a las funciones diferidas?</b> <br><br>  Al usar JavaScript, <code>this</code> dentro de una funci√≥n regular, como esta, por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whoCalledMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  el valor en <code>this</code> coincidir√° con la <b>persona que llama</b> .  Si define la funci√≥n anterior dentro del Node REPL, entonces el objeto <code>global</code> llamar√°.  Si define una funci√≥n en la consola del navegador, el objeto de la <code>window</code> llamar√°. <br><br>  Definamos una funci√≥n como una propiedad de un objeto para hacerlo un poco m√°s claro: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'42'</span></span>, whoCalledMe() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Caller is'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }; <span class="hljs-comment"><span class="hljs-comment">//     : obj.whoCallMe</span></span></code> </pre> <br>  Ahora, cuando usaremos directamente el enlace cuando <code>obj.whoCallMe</code> con la funci√≥n <code>obj.whoCallMe</code> , el objeto <code>obj</code> (identificado por su <code>id</code> ) actuar√° como la persona que llama: <br><br><img src="https://habrastorage.org/webt/-p/ws/xl/-pwsxloqfbioi6rnk02prkje_wg.png"><br><br>  Ahora la pregunta es: ¬øqui√©n ser√° la persona que llama si pasa el enlace a <code>obj.whoCallMe</code> a <code>setTimetout</code> ? <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ?? setTimeout(obj.whoCalledMe, 0);</span></span></code> </pre> <br>  <b>¬øQui√©n es la persona que llama en este caso?</b> <br><br>  La respuesta diferir√° seg√∫n d√≥nde se ejecute la funci√≥n del temporizador.  En este caso, la dependencia de qui√©n es la persona que llama es simplemente inaceptable.  Perder√° el control sobre la persona que llama, porque depender√° de la implementaci√≥n del temporizador que en este caso llama a su funci√≥n.  Si prueba este c√≥digo en un Node REPL, el objeto <code>Timeout</code> ser√° el que llama: <br><br><img src="https://habrastorage.org/webt/hx/bb/t5/hxbbt5rhcmm4l6e2hns0ph8icho.png"><br><br>  Tenga en cuenta: esto es importante solo cuando el JavaScript <code>this</code> utiliza dentro de las funciones regulares.  Al usar las funciones de flecha, la persona que llama no deber√≠a molestarte en absoluto. <br><br>  <b>Temporizadores Problema # 3</b> <br><br>  Escriba un script que muestre continuamente un mensaje de "Hola mundo" con diferentes demoras.  Comience con un retraso de un segundo y luego aumente en un segundo en cada iteraci√≥n.  En la segunda iteraci√≥n, el retraso ser√° de 2 segundos.  En el tercero, tres, y as√≠ sucesivamente. <br><br>  Incluya un retraso en el mensaje que se muestra.  Deber√≠as obtener algo como esto: <br><br> <code>Hello World. 1 <br> Hello World. 2 <br> Hello World. 3 <br> ...</code> <br> <br>  <i>Limitaciones</i> : las variables solo se pueden definir usando const.  Usar let o var no lo es. <br><br>  <i>Soluci√≥n</i> <br><br>  Dado que la duraci√≥n de la demora en esta tarea es variable, no puede usar <code>setInterval</code> aqu√≠, pero puede configurar manualmente la ejecuci√≥n de intervalos usando <code>setTimeout</code> dentro de una llamada recursiva.  La primera funci√≥n ejecutada con <code>setTimeout</code> crear√° el siguiente temporizador, y as√≠ sucesivamente. <br><br>  Adem√°s, dado que no puede usar <code>let</code> / <code>var</code> , no podemos tener un contador para aumentar el retraso de cada llamada recursiva;  en su lugar, puede usar los argumentos de una funci√≥n recursiva para realizar un incremento durante una llamada recursiva. <br><br>  Aqu√≠ se explica c√≥mo resolver este problema: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span> + delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, delay * <span class="hljs-number"><span class="hljs-number">1000</span></span>); greeting(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  <b>Temporizadores Tarea # 4</b> <br><br>  Escriba una secuencia de comandos que muestre el mensaje "Hola mundo" con la misma estructura de retraso que en la tarea n.¬∫ 3, pero esta vez en grupos de 5 mensajes, y el grupo tendr√° un intervalo de retraso principal.  Para el primer grupo de 5 mensajes, seleccionamos el retraso inicial de 100 ms, para el siguiente - 200 ms, para el tercero - 300 ms y as√≠ sucesivamente. <br><br>  As√≠ es como deber√≠a funcionar este script: <br><br><ul><li>  A 100 ms, el script muestra "Hola Mundo" por primera vez, y lo hace 5 veces con un intervalo que aumenta en 100 ms.  El primer mensaje aparecer√° despu√©s de 100 ms, el segundo despu√©s de 200 ms, etc. </li><li>  Despu√©s de los primeros 5 mensajes, el script deber√≠a aumentar el retraso principal en 200 ms.  Por lo tanto, el sexto mensaje se mostrar√° despu√©s de 500 ms + 200 ms (700 ms), s√©ptimo - 900 ms, octavo mensaje - despu√©s de 1100 ms, y as√≠ sucesivamente. </li><li>  Despu√©s de 10 mensajes, el script deber√≠a aumentar el intervalo de retraso principal en 300 ms.  El und√©cimo mensaje debe mostrarse despu√©s de 500 ms + 1000 ms + 300 ms (18000 ms).  El mensaje 12 debe mostrarse despu√©s de 2100 ms, etc. </li></ul><br>  De acuerdo con este principio, el programa deber√≠a funcionar indefinidamente. <br><br>  Incluya un retraso en el mensaje que se muestra.  Deber√≠as obtener algo como esto (sin comentarios): <br><br> <code>Hello World. 100 //  100  <br> Hello World. 100 //  200  <br> Hello World. 100 //  300  <br> Hello World. 100 //  400  <br> Hello World. 100 //  500  <br> Hello World. 200 //  700  <br> Hello World. 200 //  900  <br> Hello World. 200 //  1100  <br> ...</code> <br> <br>  <i>Limitaciones</i> : puede usar solo llamadas para establecer <code>setInterval</code> (y no para establecer <code>setTimeout</code> ) y solo UNA <code>if</code> . <br><br>  <i>Soluci√≥n</i> <br><br>  Como solo podemos trabajar con llamadas <code>setInterval</code> , aqu√≠ debemos usar la recursividad y tambi√©n aumentar el retraso de la pr√≥xima llamada <code>setInterval</code> .  Adem√°s, necesitamos la <code>if</code> para que esto suceda solo despu√©s de 5 llamadas a esta funci√≥n recursiva. <br><br>  Aqu√≠ hay una posible soluci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastIntervalId, counter = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delay</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">5</span></span>) { clearInterval(lastIntervalId); lastIntervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello World. '</span></span>, delay); greeting(delay + <span class="hljs-number"><span class="hljs-number">100</span></span>); }, delay); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; }; greeting(<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Gracias a todos los que lo leyeron. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426709/">https://habr.com/ru/post/es426709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426699/index.html">Prueba de Python con pytest. Simple, r√°pido, eficiente y escalable. Pr√≥logo e Introducci√≥n</a></li>
<li><a href="../es426701/index.html">Flutter: una nueva mirada al desarrollo multiplataforma</a></li>
<li><a href="../es426703/index.html">Lo que fue interesante en DataVizDay en Minsk</a></li>
<li><a href="../es426705/index.html">Hyperledger Fabric Desarrollo y prueba de contratos inteligentes</a></li>
<li><a href="../es426707/index.html">Sistema de aprobaci√≥n. Como inventamos la bicicleta</a></li>
<li><a href="../es426713/index.html">Intel Xeon W-3175X: 28 n√∫cleos para el hogar</a></li>
<li><a href="../es426717/index.html">La ilusi√≥n del enga√±o: una ilusi√≥n √≥ptica visual basada en pron√≥sticos retro</a></li>
<li><a href="../es426719/index.html">Hackathon sobre Data Science en SIBUR: c√≥mo fue</a></li>
<li><a href="../es426721/index.html">Evitar fallas durante el desarrollo del producto: 10 consejos de Rookee</a></li>
<li><a href="../es426723/index.html">Microsoft y sus socios esperan crear una c√°psula del tiempo en la luna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>