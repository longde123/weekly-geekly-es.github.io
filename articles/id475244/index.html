<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒº ğŸ›ƒ ğŸ† Fitur JavaScript Baru yang Diharapkan Harus Anda Ketahui ğŸ³ï¸â€ğŸŒˆ ğŸ‘ ğŸ‘¨ğŸ¾â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak rilis standar ECMAScript 2015 (juga disebut ES6), JavaScript telah berubah dan meningkat secara serius. Ini adalah berita yang sangat bagus untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur JavaScript Baru yang Diharapkan Harus Anda Ketahui</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/475244/">  Sejak rilis standar ECMAScript 2015 (juga disebut ES6), JavaScript telah berubah dan meningkat secara serius.  Ini adalah berita yang sangat bagus untuk semua pengembang JS.  Apalagi sekarang versi ECMAScript baru dirilis setiap tahun.  Mungkin Anda tidak terlalu memperhatikan apa yang muncul dalam versi standar terbaru, yang dirilis pada Juni 2019.  Penulis artikel ini, terjemahan yang kami terbitkan hari ini, ingin menceritakan secara singkat tentang inovasi JavaScript, dan tentang apa yang dapat diharapkan dalam versi standar ECMAScript berikutnya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/fi/vc/hd/fivchddl8mlzwem95dlmcvypba4.png"></a> <br><br>  Peluang yang usulannya berada di tahap ketiga persetujuan (Tahap 3) akan disebutkan di sini.  Ini berarti bahwa mereka cenderung muncul dalam versi standar ECMAScript berikutnya, tetapi ini tidak dapat dikonfirmasi dengan kepastian absolut.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> repositori tempat Anda dapat menemukan informasi tentang proposal yang berada pada tahap persetujuan yang berbeda. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fitur ECMAScript 2019 (ES10)</font> </h2><br>  Standar ES10 memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak</a> fitur baru.  Di sini kita akan mempertimbangkan hanya beberapa dari mereka.  Yaitu, beberapa metode array baru. <br><br><h3>  <font color="#3AC1EF">â– Metode Array.prototype.flat</font> </h3><br>  Metode ini memungkinkan Anda untuk membuat array, yang mencakup array lainnya, lebih "datar", "mengompresi" mereka ke level kedalaman tertentu. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]]; array.flat(); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4];</span></span></code> </pre> <br>  Ini adalah fitur yang sangat berguna, terutama dalam kasus di mana Anda perlu bekerja dengan array bersarang.  Jika kedalaman susunan array dalam struktur data melebihi 1, maka satu panggilan ke metode <code>flat</code> tidak dapat membuat array sepenuhnya "flat".  Metode ini menerima <code>depth</code> parameter opsional, yang memungkinkan Anda menentukan berapa banyak level bersarang dimensi array yang diproses harus dikurangi. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const crazyArray = [1, 2, [3, 4], [[5], [6, [7,8]]]]; crazyArray.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8]; // ,  flat,    </span></span></code> </pre> <br>  Semakin dalam array, semakin banyak sumber daya komputasi akan dibutuhkan untuk memprosesnya.  Harap dicatat bahwa IE dan Edge tidak mendukung fitur ini. <br><br><h3>  <font color="#3AC1EF">â– Metode Array.prototype.flatMap</font> </h3><br>  Metode ini pertama-tama memproses elemen-elemen array menggunakan fungsi yang diteruskan ke sana, dan kemudian mengubah array menjadi struktur datar. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"it's Sunny in"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"California"</span></span>]; arr.flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ["it's","Sunny","in", "", "California"]</span></span></code> </pre> <br>  Perbedaan antara <code>flat</code> dan <code>flatMap</code> adalah Anda dapat meneruskan fungsi Anda sendiri ke metode <code>flatMap</code> yang mengubah elemen-elemen array asli.  Selain itu, <code>flatMap</code> , tidak seperti <code>flat</code> , "memunculkan" elemen array hanya 1 level.  Metode ini mengembalikan array baru.  Ini dapat berguna dalam kasus-kasus tersebut ketika, sebelum Anda membuat array "flat" tertentu, Anda perlu memproses elemen-elemennya. <br><br><h2>  <font color="#3AC1EF">Fitur JS Baru pada Persetujuan Tahap 3</font> </h2><br>  Pada tahap ketiga koordinasi ada banyak proposal baru yang menarik untuk memperluas dan meningkatkan bahasa.  Mari kita pertimbangkan beberapa di antaranya. <br><br><h3>  <font color="#3AC1EF">â– Pemisah angka digit</font> </h3><br>  Itu terjadi pada Anda: menulis angka panjang dalam variabel dan meragukan ejaan yang benar?  Kalimat tersebut memungkinkan kita untuk memisahkan bit angka dengan garis bawah.  Ini membuatnya mudah untuk bekerja dengan angka. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>_000_000_000      <span class="hljs-comment"><span class="hljs-comment">// ,   101_475_938.38     //     -     let fee = 123_00;    // $123 (, , 12300 ) let fee = 12_300;    // $12,300 (  !) let amount = 12345_00; // 12,345 (,  , 1234500 ) let amount = 123_45.00; // 12345 (, -  ) let amount = 1_234_500; // 1,234,500 let budget = 1_000_000_000_000; //   `budget`?  - 1 ! // // : console.log(budget === 10 ** 12); // true</span></span></code> </pre> <br>  Setiap pengembang, setelah menerima fitur ini, akan memutuskan sendiri apakah akan menggunakan pemisah pembuangan atau tidak.  Tapi satu hal yang pasti: fitur ini dapat mengurangi ketidaknyamanan yang terkait dengan penghitungan angka dalam jumlah besar. <br><br><h3>  <font color="#3AC1EF">â–Menggunakan menunggu di tingkat atas kode</font> </h3><br>  Menggunakan kata kunci yang <code>await</code> di tingkat atas kode memungkinkan modul untuk bertindak sebagai fungsi asinkron besar.  Karena fitur ini, modul ECMAScript dapat mengharapkan beberapa sumber muncul.  Ini mengarah pada fakta bahwa modul lain yang mengimpornya akan menunggu sampai tubuh modul yang diimpor siap untuk bekerja. <br><br>  Alasan untuk fitur ini adalah ketika modul diimpor yang memiliki fungsi yang dideklarasikan dengan <code>async</code> , output dari fungsi ini akan tidak <code>undefined</code> . <br><br>  Contoh berikut menunjukkan dua file.  Mungkin akan <code>undefined</code> dalam <code>output</code> jika fungsi dipanggil sebelum tugas yang diwakili oleh janji selesai. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// awaiting.mjs import { process } from "./some-module.mjs"; const dynamic = import(computedModuleSpecifier); const data = fetch(url); export const output = process((await dynamic).default, await data); // usage.mjs import { output } from "./awaiting.mjs"; export function outputPlusValue(value) { return output + value } console.log(outputPlusValue(100)); setTimeout(() =&gt; console.log(outputPlusValue(100), 1000);</span></span></code> </pre> <br>  Semuanya akan berhenti di <code>awaiting.js</code> sampai <code>awaiting.js</code> terselesaikan di awaiting.js. <br><br><h3>  <font color="#3AC1EF">â–Operator ??</font>  <font color="#3AC1EF">dan memeriksa nilai hanya pada null dan undefined</font> </h3><br>  Mungkin, di antara semua penawaran Tahap 3, ini adalah yang paling berguna.  Kita sering harus menulis sesuatu seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {  <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'James'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = obj.name || <span class="hljs-string"><span class="hljs-string">'Jane'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// James</span></span></code> </pre> <br>  Jika <code>obj.name</code> diwakili oleh beberapa nilai palsu, maka string <code>Jane</code> menjadi <code>name</code> .  Akibatnya, <code>name</code> tidak akan menjadi sesuatu yang <code>undefined</code> .  Tetapi masalahnya adalah string kosong dalam kasus ini akan dianggap sebagai nilai yang salah.  Jika ini diperhitungkan, kode ini harus ditulis ulang sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = (obj.name &amp;&amp; obj.name !== <span class="hljs-string"><span class="hljs-string">''</span></span>) || <span class="hljs-string"><span class="hljs-string">'Jane'</span></span>;</code> </pre> <br>  Tidak nyaman menulis seperti itu sepanjang waktu.  Operator <code>??</code>  (dua tanda tanya) hanya memungkinkan memeriksa nilai <code>null</code> dan <code>undefined</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = {  <span class="hljs-attr"><span class="hljs-attr">settings</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">nullValue</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    <span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>,    <span class="hljs-attr"><span class="hljs-attr">animationDuration</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="hljs-attr"><span class="hljs-attr">headerText</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>,    <span class="hljs-attr"><span class="hljs-attr">showSplashScreen</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>  } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> undefinedValue = response.settings.undefinedValue ?? <span class="hljs-string"><span class="hljs-string">'some other default'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 'some other default' const nullValue = response.settings.nullValue ?? 'some other default'; // : 'some other default' const headerText = response.settings.headerText ?? 'Hello, world!'; // : '' const animationDuration = response.settings.animationDuration ?? 300; // : 0 const showSplashScreen = response.settings.showSplashScreen ?? true; // : false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">â–Operator ?.</font>  <font color="#3AC1EF">dan rantai opsional</font> </h3><br>  Saran ini dekat dengan yang baru saja ditinjau, menggabungkan cek <code>null</code> dan <code>undefined</code> .  Diketahui bahwa pengguna TypeScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tertarik</a> pada fitur ini. <br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> city = country &amp;&amp; country.city; <span class="hljs-comment"><span class="hljs-comment">// undefined  city  </span></span></code> </pre> <br>  Untuk sampai ke properti <code>city</code> dari objek <code>country</code> , Anda perlu memeriksa keberadaan objek <code>country</code> dan keberadaan properti <code>city</code> di dalamnya. <br><br>  Dengan menggunakan operator <code>?.</code>  (tanda tanya dan titik) kode ini dapat dikonversi seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> city = country?.city; <span class="hljs-comment"><span class="hljs-comment">// undefined  city  </span></span></code> </pre> <br>  Fitur ini tampaknya berguna dalam situasi seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { fetch } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../yourFetch.js'</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch();  <span class="hljs-comment"><span class="hljs-comment">// res &amp;&amp; res.data &amp;&amp; res.data.cities || undefined  const cities = res?.data?.cities; })();</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">â– Metode Janji</font> </h3><br>  Metode <code>Promise.any</code> menerima objek <code>Promise.any</code> berisi objek janji, dan mengembalikan janji yang berhasil diselesaikan ketika setidaknya satu dari objek janji yang diteruskan ke itu berhasil diselesaikan.  Jika semua objek janji ditolak, ia akan mengembalikan array yang berisi informasi tentang alasan penolakannya. <br><br>  Beginilah cara menggunakan <code>Promise.any</code> dengan konstruk async / menunggu seperti: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.any(promises);  <span class="hljs-comment"><span class="hljs-comment">//      . } catch (error) {  //    . }</span></span></code> </pre> <br>  Inilah hal yang sama diimplementasikan menggunakan janji-janji: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.any(promises).then(  <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//      .  },  (error) =&gt; {    //    .  } );</span></span></code> </pre> <br>  JavaScript sudah memiliki <code>.race</code> , <code>.race</code> , <code>.race</code> , tetapi metode serupa.  <code>any</code> , tidak.  Sebagai hasilnya, kami memiliki peluang baru yang melengkapi yang sudah ada dan mungkin bermanfaat dalam situasi tertentu.  Terlepas dari kenyataan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proposal ini</a> sudah pada tahap ketiga persetujuan, itu mungkin tidak dimasukkan dalam edisi berikutnya dari standar ECMAScript karena perlu pengujian tambahan. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Ada banyak saran menarik untuk mengembangkan JavaScript yang berada di tahap ketiga persetujuan.  Akan menarik untuk melihatnya dalam standar ES11 dan ES12.  Tentu saja, tidak mungkin ada orang yang akan menggunakan semuanya, tetapi beberapa dari mereka pasti akan menemukan aplikasi yang luas dan akan berkontribusi pada pertumbuhan kualitas kode JS. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda sudah menggunakan fitur JavaScript yang hampir siap untuk disertakan dalam versi standar berikutnya? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475244/">https://habr.com/ru/post/id475244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475228/index.html">Garpu penggajian. Anda adalah seorang programmer untuk ibu</a></li>
<li><a href="../id475236/index.html">Jangan pernah mengabaikan pelatihan penguatan lagi.</a></li>
<li><a href="../id475238/index.html">Timeline Blade Runner - November 2019. Apakah ramalan itu menjadi kenyataan?</a></li>
<li><a href="../id475240/index.html">Menggunakan modul ketat dalam proyek Python skala besar: pengalaman Instagram. Bagian 1</a></li>
<li><a href="../id475242/index.html">Menggunakan modul ketat dalam proyek Python skala besar: pengalaman Instagram. Bagian 2</a></li>
<li><a href="../id475246/index.html">Pemrograman Asinkron Python: Tinjauan Singkat</a></li>
<li><a href="../id475248/index.html">Penggunaan polyfill saat menulis aplikasi lintas-browser</a></li>
<li><a href="../id475250/index.html">Sebagai Redash memperhatikan dan memperbaiki masalah yang menyebabkan penurunan kinerja kode Python</a></li>
<li><a href="../id475252/index.html">Cara mengkritik Microsoft</a></li>
<li><a href="../id475254/index.html">AERODISK vAIR arsitektur atau fitur bangunan cluster nasional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>