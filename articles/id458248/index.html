<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‹ğŸ¼ âš”ï¸ â›¹ğŸ» Sederhanakan Kode Anda Dengan Ilmu Roket: Operator Pesawat Luar Angkasa C ++ 20 ğŸ––ğŸ¼ ğŸ‘§ğŸ¿ â˜ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 menambahkan operator baru, dijuluki sayang "operator pesawat ruang angkasa": <=> . Ada posting sementara kembali oleh Simon Merek kami sendiri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sederhanakan Kode Anda Dengan Ilmu Roket: Operator Pesawat Luar Angkasa C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20 menambahkan operator baru, dijuluki sayang "operator pesawat ruang angkasa": <code>&lt;=&gt;</code> .  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> sementara kembali oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simon Merek</a> kami sendiri merinci beberapa informasi mengenai operator baru ini bersama dengan beberapa informasi konseptual tentang apa itu dan apa.  Tujuan dari posting ini adalah untuk mengeksplorasi beberapa aplikasi konkret dari operator baru yang aneh ini dan rekanan yang terkait, <code>operator==</code> (ya sudah diubah, menjadi lebih baik!), Semua sambil memberikan beberapa pedoman untuk penggunaannya dalam kode sehari-hari. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Perbandingan </h2><br>  Bukan hal yang aneh untuk melihat kode seperti berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Catatan: pembaca yang bermata elang akan melihat bahwa ini sebenarnya lebih sedikit verbose daripada yang seharusnya dalam kode pra-C ++ 20 karena fungsi-fungsi ini sebenarnya semua adalah teman yang bukan anggota, lebih banyak tentang itu nanti.</i> <br><br>  Itu banyak kode boilerplate untuk ditulis hanya untuk memastikan bahwa tipe saya sebanding dengan sesuatu dari tipe yang sama.  Baiklah, kita berurusan sebentar.  Kemudian datang seseorang yang menulis ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Hal pertama yang Anda perhatikan adalah bahwa program ini tidak dapat dikompilasi. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  Masalahnya adalah kita lupa <code>constexpr</code> pada fungsi perbandingan kita, teman!  Jadi kita pergi dan menambahkan <code>constexpr</code> ke semua operator perbandingan.  Beberapa hari kemudian seseorang pergi dan menambahkan penolong <code>is_gt</code> tetapi pemberitahuan semua operator pembanding tidak memiliki spesifikasi pengecualian dan melalui proses yang sama untuk menambahkan <code>noexcept</code> untuk masing-masing dari 5 kelebihan beban. <br><br>  Di sinilah operator ruang angkasa baru C ++ 20 melangkah untuk membantu kami.  Mari kita lihat bagaimana <code>IntWrapper</code> asli dapat ditulis dalam dunia C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Perbedaan pertama yang mungkin Anda perhatikan adalah penyertaan baru <code>&lt;compare&gt;</code> .  Header <code>&lt;compare&gt;</code> bertanggung jawab untuk mengisi kompilator dengan semua jenis kategori perbandingan yang diperlukan bagi operator pesawat ruang angkasa untuk mengembalikan tipe yang sesuai dengan fungsi default kami.  Dalam cuplikan di atas, tipe pengembalian <code>auto</code> akan disimpulkan menjadi <code>std::strong_ordering</code> . <br><br>  Kita tidak hanya menghapus 5 baris berlebihan, tetapi kita bahkan tidak perlu mendefinisikan apa pun, kompilator melakukannya untuk kita!  <code>is_lt</code> kami tetap tidak berubah dan hanya berfungsi sementara masih menjadi <code>constexpr</code> meskipun kami tidak secara eksplisit menentukannya di <code>operator&lt;=&gt;</code> default kami <code>operator&lt;=&gt;</code> .  Itu bagus dan bagus, tetapi beberapa orang mungkin menggaruk-garuk kepala mengapa <code>is_lt</code> diizinkan untuk tetap mengkompilasi meskipun tidak menggunakan operator pesawat ruang angkasa sama sekali.  Mari kita jelajahi jawaban untuk pertanyaan ini. <br><br><h2>  Menulis ulang ungkapan </h2><br>  Dalam C ++ 20, kompiler diperkenalkan dengan konsep baru yang disebut ekspresi "ditulis ulang".  Operator pesawat ruang angkasa, bersama dengan <code>operator==</code> , adalah di antara dua kandidat pertama yang dikenakan ekspresi ulang.  Untuk contoh yang lebih konkret dari penulisan ulang ekspresi, mari kita <code>is_lt</code> contoh yang disediakan di <code>is_lt</code> . <br><br>  Selama resolusi kelebihan beban, kompiler akan memilih dari sekumpulan kandidat yang layak, yang semuanya cocok dengan operator yang kami cari.  Proses pengumpulan kandidat diubah sedikit untuk kasus operasi relasional dan kesetaraan di mana kompiler juga harus mengumpulkan kandidat yang ditulis ulang dan disintesis khusus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Untuk ungkapan kami <code>a &lt; b</code> , standar menyatakan bahwa kita dapat mencari tipe <code>operator&lt;=&gt;</code> atau <code>operator&lt;=&gt;</code> fungsi lingkup namespace <code>operator&lt;=&gt;</code> yang menerima tipenya.  Jadi kompiler melakukan dan menemukan bahwa, pada kenyataannya, tipe a memang <code>IntWrapper::operator&lt;=&gt;</code> .  Kompiler kemudian diizinkan untuk menggunakan operator itu dan menulis ulang ekspresi <code>a &lt; b</code> as <code>(a &lt;=&gt; b) &lt; 0</code> .  Ekspresi yang ditulis ulang itu kemudian digunakan sebagai kandidat untuk resolusi overload normal. <br><br>  Anda mungkin bertanya pada diri sendiri mengapa ungkapan yang ditulis ulang ini valid dan benar.  Ketepatan ekspresi sebenarnya berasal dari semantik yang disediakan oleh operator pesawat ruang angkasa.  <code>&lt;=&gt;</code> adalah perbandingan tiga arah yang menyiratkan bahwa Anda tidak hanya mendapatkan hasil biner, tetapi juga pemesanan (dalam kebanyakan kasus) dan jika Anda memiliki pemesanan, Anda dapat menyatakan pemesanan itu dalam hal operasi relasional apa pun.  Contoh singkat, ekspresi 4 &lt;=&gt; 5 dalam C ++ 20 akan mengembalikan hasil Anda <code>std::strong_ordering::less</code> .  Hasil <code>std::strong_ordering::less</code> menyiratkan bahwa <code>4</code> tidak hanya berbeda dari <code>5</code> tetapi juga sangat kurang dari nilai itu, ini membuat penerapan operasi <code>(4 &lt;=&gt; 5) &lt; 0</code> benar dan tepat akurat untuk menggambarkan hasil kami. <br><br>  Menggunakan informasi di atas kompiler dapat mengambil operator relasional umum (yaitu <code>&lt;</code> , <code>&gt;</code> , dll.) Dan menulis ulang dalam hal operator ruang angkasa.  Dalam standar, ungkapan yang ditulis ulang sering disebut sebagai <code>(a &lt;=&gt; b) @ 0</code> mana <code>@</code> mewakili operasi relasional apa pun. <br><br><h2>  Mensintesis ekspresi </h2><br>  Pembaca mungkin telah memperhatikan penyebutan halus ekspresi "disintesis" di atas dan mereka juga berperan dalam proses penulisan ulang operator ini.  Pertimbangkan fungsi predikat yang berbeda: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Jika kami menggunakan definisi asli kami untuk <code>IntWrapper</code> kode ini tidak akan dikompilasi. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Ini masuk akal di lahan pra-C ++ 20, dan cara untuk mengatasi masalah ini adalah dengan menambahkan beberapa fungsi <code>friend</code> tambahan ke <code>IntWrapper</code> yang mengambil sisi kiri <code>int</code> .  Jika Anda mencoba membuat sampel dengan kompiler C ++ 20 dan definisi <code>IntWrapper</code> C ++ 20 Anda, Anda mungkin memperhatikan bahwa itu, sekali lagi, â€œhanya berfungsiâ€ â€”penggaruk kepala lainnya.  Mari kita periksa mengapa kode di atas masih diizinkan untuk dikompilasi di C ++ 20. <br><br>  Selama resolusi kelebihan beban, kompiler juga akan mengumpulkan apa yang disebut standar sebagai "disintesis" kandidat, atau ekspresi ditulis ulang dengan urutan parameter dibalik.  Pada contoh di atas kompiler akan mencoba menggunakan ekspresi yang ditulis ulang <code>(42 &lt;=&gt; a) &lt; 0</code> tetapi ia akan menemukan bahwa tidak ada konversi dari <code>IntWrapper</code> ke <code>int</code> untuk memuaskan sisi kiri sehingga ekspresi yang ditulis ulang dibuang.  Kompiler juga memunculkan ekspresi â€œdisintesisâ€ <code>0 &lt; (a &lt;=&gt; 42)</code> dan menemukan bahwa ada konversi dari <code>int</code> ke <code>IntWrapper</code> melalui konstruktor <code>IntWrapper</code> sehingga kandidat ini digunakan. <br><br>  Tujuan dari ekspresi yang disintesis adalah untuk menghindari kekacauan dari kebutuhan untuk menulis lapisan fungsi <code>friend</code> untuk mengisi celah di mana objek Anda dapat dikonversi dari tipe lain.  Ekspresi yang disintesis digeneralisasi ke <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Jenis yang lebih kompleks </h2><br>  Operator pesawat ruang angkasa yang dihasilkan oleh compiler tidak berhenti di satu anggota kelas, ia akan menghasilkan kumpulan perbandingan yang benar untuk semua sub-objek dalam tipe Anda: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Kompiler tahu bagaimana memperluas anggota kelas yang array ke daftar sub-objek dan membandingkannya secara rekursif.  Tentu saja, jika Anda ingin menulis sendiri fungsi-fungsi ini, Anda masih mendapatkan manfaat dari ekspresi penulisan ulang kompiler untuk Anda. <br><br><h2>  Terlihat Seperti Bebek, Berenang Seperti Bebek, dan Operator Dukun Suka <code>operator==</code> </h2><br>  Beberapa orang yang sangat pintar dalam komite standardisasi memperhatikan bahwa operator pesawat ruang angkasa akan selalu melakukan perbandingan leksikografis elemen apa pun yang terjadi.  Perbandingan leksikografis tanpa syarat dapat menyebabkan kode yang dihasilkan tidak efisien dengan operator kesetaraan pada khususnya. <br><br>  Contoh kanonik membandingkan dua string.  Jika Anda memiliki string <code>"foobar"</code> dan Anda membandingkannya dengan string <code>"foo"</code> menggunakan == orang akan mengharapkan operasi yang hampir konstan.  Algoritma perbandingan string yang efisien adalah sebagai berikut: <br><br><ul><li>  Pertama membandingkan ukuran dari dua string, jika ukurannya berbeda <code>false</code> , sebaliknya </li><li>  melangkah melalui setiap elemen dari dua string secara bersamaan dan membandingkan sampai satu berbeda atau akhir tercapai, kembalikan hasilnya. </li></ul><br>  Di bawah aturan operator pesawat ruang angkasa kita harus mulai dengan perbandingan mendalam pada setiap elemen terlebih dahulu sampai kita menemukan yang berbeda.  Dalam contoh kita tentang <code>"foobar"</code> dan <code>"foo"</code> hanya ketika membandingkan <code>'b'</code> ke <code>'\0'</code> akhirnya Anda mengembalikan <code>false</code> . <br><br>  Untuk mengatasi ini ada makalah, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1185R2</a> yang merinci cara bagi kompiler untuk menulis ulang dan menghasilkan <code>operator==</code> secara independen dari operator pesawat ruang angkasa.  <code>IntWrapper</code> kami dapat ditulis sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Hanya satu langkah lagi ... namun, ada kabar baik;  Anda sebenarnya tidak perlu menulis kode di atas, karena cukup menulis <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> sudah cukup bagi kompiler untuk secara implisit menghasilkan <code>operator==</code> terpisah - dan lebih efisien - <code>operator==</code> untuk Anda! <br><br>  Kompiler menerapkan aturan "penulisan ulang" yang sedikit diubah khusus untuk <code>==</code> dan <code>!=</code> Di mana dalam operator ini ditulis ulang dalam hal <code>operator==</code> dan bukan <code>operator&lt;=&gt;</code> .  Ini artinya <code>!=</code> Juga mendapat manfaat dari pengoptimalan. <br><br><h2>  Kode Lama Tidak Akan Hancurkan </h2><br>  Pada titik ini Anda mungkin berpikir, OK jika kompiler diizinkan untuk melakukan bisnis penulisan ulang operator ini apa yang terjadi ketika saya mencoba mengakali kompiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  Jawabannya di sini adalah, Anda tidak.  Model resolusi kelebihan di C ++ memiliki arena ini di mana semua kandidat melakukan pertempuran, dan dalam pertempuran khusus ini kami memiliki 3 kandidat: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (ditulis ulang) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (disintesis) <br><br>  Jika kami menerima aturan resolusi kelebihan di C ++ 17 hasil panggilan itu akan menjadi ambigu, tetapi aturan resolusi kelebihan C ++ 20 diubah untuk memungkinkan kompilator menyelesaikan situasi ini ke beban berlebih yang paling logis. <br><br>  Ada fase resolusi kelebihan dimana compiler harus melakukan serangkaian tiebreak.  Dalam C ++ 20, ada tiebreak baru yang menyatakan kita harus lebih suka overload yang tidak ditulis ulang atau disintesis, ini membuat <code>IntWrapper::operator&lt;</code> kelebihan kami <code>IntWrapper::operator&lt;</code> kandidat terbaik dan menyelesaikan ambiguitas.  Mesin yang sama ini mencegah kandidat yang disintesis untuk menginjak ekspresi yang ditulis ulang secara teratur. <br><br><h2>  Pikiran penutup </h2><br>  Operator pesawat ruang angkasa adalah tambahan yang disambut baik untuk C ++ dan itu adalah salah satu fitur yang akan menyederhanakan dan membantu Anda untuk menulis <i>lebih sedikit</i> kode, dan, kadang-kadang, lebih sedikit lebih banyak.  Jadi kencangkan dengan operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesawat ruang angkasa</a> C ++ 20! <br><br>  Kami mendorong Anda untuk keluar dan mencoba operator pesawat ruang angkasa, ini tersedia sekarang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visual Studio 2019 di</a> bawah <code>/std:c++latest</code> !  Sebagai catatan, perubahan yang diperkenalkan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1185R2</a> akan tersedia di Visual Studio 2019 versi 16.2.  Harap diingat bahwa operator pesawat ruang angkasa adalah bagian dari C ++ 20 dan dapat mengalami beberapa perubahan hingga waktu penyelesaian C ++ 20 selesai. <br><br>  Seperti biasa, kami menyambut umpan balik Anda.  Jangan ragu untuk mengirim komentar melalui email di <a href="">visualcpp@microsoft.com</a> , melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter @visualc</a> , atau Facebook di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Visual Cpp</a> .  Juga, silakan ikuti saya di Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@starfreakclone</a> . <br><br>  Jika Anda mengalami masalah lain dengan MSVC di VS 2019, beri tahu kami melalui opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporkan Masalah</a> , baik dari penginstal atau Visual Studio IDE itu sendiri.  Untuk saran atau laporan bug, beri tahu kami melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458248/">https://habr.com/ru/post/id458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458228/index.html">Mengapa kita membutuhkan fungsi virtual</a></li>
<li><a href="../id458240/index.html">Bagaimana kecerdasan buatan, drone, dan kamera memastikan keamanan jalan dan jembatan</a></li>
<li><a href="../id458242/index.html">Operator pesawat ruang angkasa baru di C ++ 20</a></li>
<li><a href="../id458244/index.html">Daftar tak berujung dan konyol tentang apa yang perlu Anda ketahui agar dapat menggunakan jaringan Wi-Fi publik dengan aman</a></li>
<li><a href="../id458246/index.html">Kebetulan kebetulan dalam hidup, atau ternyata Anda dihadiahi kue di pabrik traktor</a></li>
<li><a href="../id458250/index.html">BTRFS untuk yang terkecil</a></li>
<li><a href="../id458252/index.html">Model matematika teleskop radio super panjang</a></li>
<li><a href="../id458256/index.html">Bukankah sudah waktunya untuk cuci otak?</a></li>
<li><a href="../id458260/index.html">Cara lain untuk mengoptimalkan gambar buruh pelabuhan untuk aplikasi Java</a></li>
<li><a href="../id458262/index.html">Perancang ruang pertemuan online - pemilihan solusi optimal untuk konferensi video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>