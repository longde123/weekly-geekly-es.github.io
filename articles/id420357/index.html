<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📧 🤷🏻 🚫 Vuex: menyusun proyek-proyek besar dan bekerja dengan modul 🏆 🔽 💃🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vuex adalah perpustakaan manajemen negara aplikasi resmi dan terdokumentasi dengan baik yang dirancang khusus untuk Vue.js. Penulis bahan, terjemahan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vuex: menyusun proyek-proyek besar dan bekerja dengan modul</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420357/">  Vuex adalah perpustakaan manajemen negara aplikasi resmi dan terdokumentasi dengan baik yang dirancang khusus untuk Vue.js.  Penulis bahan, terjemahan yang kami terbitkan hari ini, percaya bahwa menggunakan perpustakaan ini jauh lebih menyenangkan daripada Redux, karena, pertama, Vuex membutuhkan lebih sedikit kode boilerplate, dan kedua, karena fakta bahwa ia berfungsi dengan mekanisme asinkron, tidak ada perpustakaan tambahan yang diperlukan di sini.  Selain itu, karena perpustakaan Vuex dibuat oleh tim yang sama yang sedang mengerjakan Vue, perpustakaan ini terintegrasi dengan sangat baik dengan kerangka kerja ini.  Sayangnya, dalam bekerja dengan Vuex Anda masih dapat menemukan satu kesulitan, yang terdiri dari mempersiapkan dengan benar struktur proyek di mana Anda berencana untuk menggunakan pustaka ini. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/lh/pj/o0/lhpjo0basq6-ilsaqqoua0ajpbi.jpeg"></a> <br><br>  Pada artikel ini Anda akan menemukan deskripsi metodologi untuk menyusun proyek besar menggunakan Vuex, dan skrip yang dirancang untuk mengotomatisasi proses pembuatan modul Vuex. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pola Vue-enterprise-boilerplate dan masalah struktur proyek</font> </h2><br>  Salah satu pengembang Vue, Chris Fritz, menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat yang</a> sangat baik untuk Vue, struktur proyek yang disajikan yang dirancang untuk menggunakan Vuex.  Secara khusus, template ini memungkinkan Vuex untuk secara otomatis mendaftarkan modul berdasarkan file dalam folder <code>modules</code> .  Struktur folder proyek mungkin terlihat seperti gambar berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ce/603/64f/8ce60364f855dbf775de3171ca2cf981.png"></div><br>  <i><font color="#999999">Struktur proyek dan penempatan kode yang tidak nyaman</font></i> <br><br>  Saat menggunakan templat ini, perlu bahwa status, getter, aksi, dan mutasi berada dalam file yang sama.  Secara pribadi, saya lebih suka menyimpannya dalam file terpisah, yang memungkinkan, mengingat fakta bahwa modul Vuex kadang-kadang cukup besar, lebih mudah untuk menavigasi program, tanpa harus menggulir melalui potongan kode yang besar.  Mengikuti ide ini, kami akan mengubah kode dari template sehingga yang terkait dengan modul individual dapat diurutkan ke dalam folder yang ditujukan untuk modul-modul ini.  Artinya, struktur proyek akan berubah dan akan mirip dengan yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cc/366/02b/3cc36602bdf8225aa8bf20db963973d9.png"></div><br>  <i><font color="#999999">Struktur proyek dengan rincian materi modul menjadi file terpisah yang ada di folder modul</font></i> <br><br><h2>  <font color="#3AC1EF">Pengembangan templat yang mendukung struktur proyek yang nyaman</font> </h2><br>  Jadi, kita akan mengatur kerja dengan Vuex sehingga kita dapat menggunakan folder dan struktur file yang mirip dengan yang ditunjukkan pada gambar sebelumnya di proyek-proyek kita.  Untuk melakukan ini, pertama buat proyek baru menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vue CLI 3</a> . <br><br>  Setelah Anda memiliki templat proyek yang siap untuk dikerjakan lebih lanjut, instal Vuex dan Lodash dengan menjalankan <code>npm install vuex lodash -save</code> di terminal.  Untuk bekerja dengan modul, kita membutuhkan fungsi camelCase dari Lodash, yang dirancang untuk mengubah string menjadi gaya unta. <br><br>  Sekarang buat folder dan struktur file yang mirip dengan yang ditunjukkan pada gambar sebelumnya. <br><br>  Mari kita mulai dengan file <code>store.js</code> .  Ini kodenya: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vuex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vuex'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> modules <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules'</span></span> Vue.use(Vuex) const store = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vuex.Store({ modules, <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>: process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span> }) //    `init`     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const moduleName <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(modules)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modules[moduleName].actions.init) {   store.dispatch(`${moduleName}/init`) } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> store</code> </pre> <br>  Vue dan Vuex diimpor di sini, karena kita tidak dapat melakukannya tanpa mereka.  Selain itu, kami mengimpor modul dari <code>/modules/index.js</code> .  Selanjutnya, kami menginisialisasi penyimpanan dan loop melalui semua modul.  Jika modul memiliki aksi <code>init</code> , kami menginisialisasi modul.  Ini ternyata sangat berguna untuk modul-modul yang perlu diinisialisasi ketika aplikasi dimulai.  Akibatnya, tentu saja, kami mengekspor <code>store</code> , setelah itu, biasanya, diimpor ke file <code>main.js</code> dan ditambahkan ke instance Vue. <br><br>  Sekarang saatnya untuk bekerja dengan file <code>index.js</code> , yang terletak di folder <code>/store/modules</code> . <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Vuex     ,    . <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> camelCase <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/camelCase'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    const requireModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.context( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   index.js,    ,    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-string"><span class="hljs-string">'mutations'</span></span>,  <span class="hljs-string"><span class="hljs-string">'getters'</span></span> . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      .js <span class="hljs-regexp"><span class="hljs-regexp">/^(?!.*(actions|mutations|getters|index)).*\.js$/</span></span> ); const modules = {}; requireModule.keys().forEach(fileName =&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/\.unit\.js$/</span></span>.test(fileName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            modules[camelCase(fileName.split(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].replace(<span class="hljs-regexp"><span class="hljs-regexp">/(\.\/|\.js)/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>))] = {   namespaced: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   ...requireModule(fileName).<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> }; }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> modules;</code> </pre> <br>  Dalam kode ini, pertama-tama kita mengimpor fungsi camelCase dari Lodash.  Kemudian kami menggunakan metode <code>require.context</code> untuk menghubungkan modul.  Sebagai parameter ketiga, kami memberikan ekspresi reguler yang akan memfilter file <code>index.js</code> , serta file yang namanya berisi <code>actions</code> baris, <code>mutations</code> , dan <code>getters</code> .  Mereka akan diimpor ke file status, misalnya, di <code>auth.js</code> , dan kemudian diekspor.  Sebagai contoh, berikut adalah bagaimana file <code>auth.js</code> dari folder <code>src/store/modules/auth/</code> terlihat seperti pada awal pekerjaan: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = {   <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {   state,   mutations,   getters,   actions };</code> </pre> <br>  Sekarang tinggal memeriksa semua modul dan membentuk satu objek dengan semuanya.  Di sini Anda perlu mengecualikan semua file atas nama yang ada <code>unit</code> garis, karena mereka diperlukan hanya untuk pengujian, dan bukan untuk pengembangan atau untuk menyebarkan proyek dalam produksi.  Setelah itu, kami menambahkan properti baru ke objek <code>modules</code> , yang akan memiliki nama file status, misalnya, <code>auth</code> atau <code>users</code> .  Selain itu, kami menggunakan fungsi <code>camelCase</code> untuk membuat nama properti terlihat konsisten.  Kemudian kita mengisi objek <code>modules</code> , <code>requireModule</code> melalui <code>requireModule</code> dan menggunakan <code>...requireModule(fileName).default</code> , dan kemudian mengekspor <code>modules</code> . <br><br>  Sebagai soal fakta, ini adalah bagaimana sebuah proyek dapat disusun di mana negara, pengambil, tindakan dan mutasi disimpan secara terpisah dan diatur dengan mudah.  Sekarang mari kita bicara tentang cara menulis skrip untuk secara otomatis membuat modul Vuex. <br><br><h2>  <font color="#3AC1EF">Script untuk membuat modul Vuex secara otomatis</font> </h2><br>  Buat folder baru di folder proyek dengan <code>scripts</code> nama, di dalamnya buat file <code>generateVuexModule.js</code> .  Untuk proyek ini kita akan memerlukan Node.js, oleh karena itu, jika Anda belum menginstal platform ini, sekarang saatnya untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperbaikinya</a> .  Skrip kami hanya memiliki satu ketergantungan - paket <code>chalk</code> , yang digunakan untuk merancang materi yang ditampilkan di konsol.  Anda dapat menginstal paket ini dengan <code>npm install -save-dev chalk</code> . <br><br><h3>  <font color="#3AC1EF">▍Langkah 1</font> </h3><br>  Dalam file <code>generateVuexModule.js</code> , Anda perlu menghubungkan tiga modul: <code>fs</code> , <code>path</code> dan <code>chalk</code> .  Juga di sini Anda memerlukan konstanta dengan path ke folder modules ( <code>src/store/modules</code> ) dan konstanta - <code>args</code> , yang akan membuat argumen diteruskan ke skrip ketika dijalankan. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chalk = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chalk'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modulesPath = <span class="hljs-string"><span class="hljs-string">'src/store/modules'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> success = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.length) { error(<span class="hljs-string"><span class="hljs-string">'You must provide a name for the module!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Seperti yang Anda lihat, kami menulis semua argumen ke <code>args</code> kecuali dua argumen pertama, karena argumen tersebut mewakili path ke <code>node.exe</code> dan file skrip, dan kami tidak memerlukan informasi ini.  Kami hanya tertarik pada parameter ketiga - nama modul baru.  Selain itu, ada beberapa fungsi, <code>error</code> dan <code>success</code> , yang menggunakan paket <code>chalk</code> disebutkan di atas untuk menampilkan pesan dengan teks dengan warna berbeda. <br><br>  Di sini Anda perlu memeriksa panjang array <code>args</code> untuk mengetahui apakah nama modul diteruskan ke skrip kami, dan jika tidak, berikan pesan kesalahan.  Oleh karena itu, jika Anda mencoba menjalankan skrip ini menggunakan perintah <code>node generateVuexModule.js</code> , tanpa meneruskannya, Anda akan melihat pesan kesalahan di terminal. <br><br><h3>  <font color="#3AC1EF">▍Langkah 2</font> </h3><br>  Pada titik ini, kita memiliki nama untuk module dan path yang diberikan oleh konstanta <code>modulesPath</code> .  Namun, kami masih harus bekerja dengan data ini.  Yaitu, ekstrak nama dari array <code>args</code> dan kumpulkan path lengkap ke modul, belum lagi pembentukan isinya. <br><br><pre> <code class="hljs pgsql">const moduleName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const modulePath = <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(__dirname, <span class="hljs-string"><span class="hljs-string">'../'</span></span>, modulesPath, moduleName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fs.existsSync(modulePath)) { error(`${moduleName} directory already <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>!`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } const stateContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; const state = {}; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { state, getters, actions, mutations }; `; const exportFileContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@/store/types'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { }; `;</code> </pre> <br>  Nama modul akan berada di elemen array <code>args</code> dengan indeks 0. Pada tahap program ini, kita dapat mengandalkan keberadaan elemen ini, seperti yang sebelumnya kita coba untuk mengekstraknya dari <code>process.argv</code> , dan kemudian memeriksa panjang array <code>args</code> .  Selain itu, kami menyiapkan path lengkap menggunakan modul <code>path</code> dan metode <code>join</code> .  Kami mendapat direktori saat ini menggunakan <code>__dirname</code> construct, naik satu tingkat ke atas, karena file <code>generateVuexModule.js</code> terletak di folder proyek <code>scripts</code> .  Kemudian kita tambahkan saja hasilnya, isi dari <code>modulesPath</code> dan nama module.  Pada titik ini, konstanta <code>modulePath</code> harus berisi sesuatu seperti <code>pathToYourProject/project/src/store/modules/moduleName</code> .  Di sinilah modul akan dibuat.  Sekarang, karena kita memiliki path lengkap, kita dapat memeriksa apakah direktori ini ada.  Kami tidak ingin secara tidak sengaja menimpa file dari modul yang ada.  Akibatnya, jika direktori tempat Anda berencana membuat modul baru ada, kami akan menampilkan pesan kesalahan dalam huruf merah, berkat <code>chalk</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92c/7e1/bc7/92c7e1bc7826ddc9f300393109b247f4.png"></div><br>  <i><font color="#999999">Contoh pesan kesalahan</font></i> <br><br>  Selanjutnya, Anda perlu membuat konstanta di mana akan ada data untuk file.  Seperti yang dapat Anda bayangkan, <code>stateContent</code> digunakan untuk file state, yaitu, misalnya, untuk <code>auth.js</code> , dan <code>exportFileContent</code> digunakan untuk <code>getters.js</code> , <code>getters.js</code> , dan <code>mutations.js</code> .  Jika perlu, Anda dapat menambahkan ke daftar ini semua yang diperlukan dalam proyek Anda. <br><br><h3>  <font color="#3AC1EF">▍Langkah 3</font> </h3><br>  Sekarang kita hanya perlu membuat path untuk file modul dan membuatnya. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> statePath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${moduleName}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">.js`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gettersPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'getters.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'actions.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutationsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'mutations.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> fs.mkdirSync(modulePath); fs.appendFileSync(statePath, stateContent); fs.appendFileSync(gettersPath, exportFileContent); fs.appendFileSync(actionsPath, exportFileContent); fs.appendFileSync(mutationsPath, exportFileContent); success(<span class="hljs-string"><span class="hljs-string">'Module'</span></span>, moduleName, <span class="hljs-string"><span class="hljs-string">'generated!'</span></span>);</code> </pre> <br>  Pertama kita mendeklarasikan empat konstanta, yang masing-masing berisi path untuk file yang sesuai.  Selanjutnya, kita perlu membuat folder untuk modul.  Kami sudah memeriksa apakah folder tersebut ada dan memberikan kesalahan jika memang demikian.  Karena itu, seharusnya tidak ada masalah dengan membuat folder.  Dan akhirnya, kita menggunakan <code>fs.appendFileSync</code> , menempatkan file baru dengan konten yang ditentukan dalam proses pembuatannya di direktori yang baru dibuat.  Pada akhirnya, skrip menampilkan pesan tentang keberhasilan penyelesaian operasi. <br><br>  Untuk menggunakan skrip ini, cukup buka folder <code>scripts</code> proyek Anda di terminal dan jalankan perintah dari <code>node generateVuexModule.js yourModuleName</code> formulir <code>node generateVuexModule.js yourModuleName</code> .  Setelah berhasil menyelesaikan skrip, Anda akan melihat pesan tentang membuat modul. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Setelah meninjau materi ini, Anda belajar tentang templat untuk menyusun proyek-proyek besar di mana Anda berencana untuk menggunakan Vuex, dan skrip yang menyederhanakan pembuatan modul Vuex.  Kami harap pengetahuan ini bermanfaat bagi Anda.  Kode proyek, contoh-contoh yang kami periksa, dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda menyusun aplikasi Vue besar yang menggunakan Vuex? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420357/">https://habr.com/ru/post/id420357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420347/index.html">Pelajari cara membuat perintah bash Anda sendiri dalam waktu kurang dari 4 menit</a></li>
<li><a href="../id420349/index.html">Daftar periksa outsourcing IT: bekerja tanpa risiko</a></li>
<li><a href="../id420351/index.html">Cara melakukan pencarian pengguna di GitHub menggunakan Vue</a></li>
<li><a href="../id420353/index.html">Kami menjadikan Shrimp lebih bermanfaat: menambahkan transcoding gambar ke format lain</a></li>
<li><a href="../id420355/index.html">Smart watch Pebble: bagaimana menjadi langka dalam semalam</a></li>
<li><a href="../id420359/index.html">Var, biarkan atau const? Masalah Lingkup Variabel dan ES6</a></li>
<li><a href="../id420361/index.html">Bug saat menjalankan TextBox.GetLineText di .NET WPF</a></li>
<li><a href="../id420363/index.html">Webinar HPE pada Agustus-Oktober: topik baru (+ SHD, praktik AI, penyimpanan turnkey petabyte)</a></li>
<li><a href="../id420367/index.html">Kiamat ber-AC: skenario smart grid blackout</a></li>
<li><a href="../id420369/index.html">Extreme Extended Edge, atau Switching IEEE 802.1BR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>