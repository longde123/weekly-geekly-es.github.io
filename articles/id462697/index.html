<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜® â– ğŸ‘©ğŸ¿â€ğŸš€ uWSGI untuk membantu metrik. Laporan Yandex ğŸ“ ğŸŒ¦ï¸ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu hari, Moscow Python Meetup # 66 diadakan - komunitas terus mendiskusikan alat yang relevan yang meningkatkan bahasa dan menyesuaikannya dengan l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>uWSGI untuk membantu metrik. Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/462697/"> Suatu hari, Moscow Python Meetup # 66 diadakan - komunitas terus mendiskusikan alat yang relevan yang meningkatkan bahasa dan menyesuaikannya dengan lingkungan yang berbeda.  Termasuk di pertemuan itu, laporan saya dibuat.  Nama saya Nail, saya sedang melakukan Yandex.Connect. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/oh/bd/zt/ohbdztka-hxtbhnhb8gz2g1ohmc.jpeg"></a> <br><br>  Cerita yang saya siapkan adalah tentang uWSGI.  Ini adalah server aplikasi web multifungsi, dan setiap aplikasi modern disertai dengan metrik.  Saya mencoba menunjukkan bagaimana kemampuan uWSGI dapat membantu dalam mengumpulkan metrik. <br><br><a name="habracut"></a>  - Halo semuanya, saya senang menyambut Anda semua di dinding Yandex.  Sangat menyenangkan bahwa begitu banyak orang datang untuk melihat laporan saya dan lainnya, bahwa begitu banyak orang tertarik dan tinggal di Python.  Tentang apa laporan saya?  Ini disebut "uWSGI untuk membantu metrik."  Saya akan menceritakan sedikit tentang diri saya.  Saya telah terlibat dalam Python selama enam tahun terakhir, saya telah bekerja di tim Yandex.Connect, kami sedang menulis platform bisnis yang menyediakan layanan Yandex yang dikembangkan secara internal untuk pengguna pihak ketiga, yaitu, untuk semua orang.  Setiap orang atau organisasi dapat menggunakan produk yang dikembangkan oleh Yandex untuk diri mereka sendiri, untuk tujuan mereka sendiri. <br><br>  Kami akan berbicara tentang metrik, cara mendapatkan metrik ini, bagaimana kami gunakan di tim kami uWSGI sebagai alat untuk mendapatkan metrik, bagaimana metrik membantu kami.  Lalu saya akan menceritakan sedikit cerita optimasi. <br><br>  Beberapa kata tentang metrik.  Seperti yang Anda ketahui, pengembangan aplikasi modern tidak mungkin dilakukan tanpa tes.  Sungguh aneh jika seseorang mengembangkan aplikasi mereka tanpa tes.  Pada saat yang sama, menurut saya pengoperasian aplikasi modern tidak mungkin tanpa metrik.  Aplikasi kita adalah organisme hidup.  Seseorang dapat mengambil beberapa metrik, seperti tekanan, detak jantung, - aplikasi juga memiliki indikator yang kami tertarik dan ingin mengamati.  Tidak seperti orang yang biasanya mengambil metrik vital ini ketika merasa buruk, dalam hal aplikasi, kita selalu dapat menggunakannya. <br><br><img src="https://habrastorage.org/webt/gm/3s/oi/gm3soikaaai-tmfoi6mf7_u3waq.jpeg"><br><br>  Mengapa kami menggunakan metrik?  Ngomong-ngomong, siapa yang menggunakan metrik?  Saya berharap bahwa setelah laporan saya, akan ada lebih banyak tangan, dan orang-orang akan tertarik dan mulai mengumpulkan metrik, mereka akan memahami bahwa ini perlu dan bermanfaat. <br><br>  Jadi mengapa kita perlu metrik?  Pertama-tama, kita melihat apa yang terjadi dengan sistem, kita menyoroti beberapa indikator normatif untuk sistem kita dan memahami apakah kita melampaui indikator-indikator ini selama proses aplikasi atau tidak.  Anda dapat melihat beberapa perilaku abnormal sistem, misalnya, peningkatan jumlah kesalahan, pahami apa yang salah dengan sistem, sebelum pengguna kami dan menerima pesan tentang insiden bukan dari pengguna, tetapi dari sistem pemantauan.  Berdasarkan metrik, kami dapat mengatur lansiran dan menerima sms, surat, panggilan, sesuka Anda. <br><br><img src="https://habrastorage.org/webt/sw/1a/ru/sw1arunikx2d6u7ngqaiofuqfvo.jpeg"><br><br>  Apa itu aturan?  Ini adalah beberapa angka, mungkin penghitung yang tumbuh secara monoton.  Misalnya, jumlah permintaan.  Beberapa nilai unit yang berubah dalam waktu meningkat atau menurun.  Contohnya adalah jumlah tugas dalam antrian.  Atau histogram - nilai yang termasuk dalam beberapa interval, yang disebut keranjang.  Sebagai aturan, akan lebih mudah untuk membaca data terkait waktu ini dan mencari tahu dalam interval waktu berapa banyak nilai yang sesuai. <br><br><img src="https://habrastorage.org/webt/ba/in/dk/baindkmahmhfz9-wq20ahlm4oyg.jpeg"><br><br>  Metrik macam apa yang bisa kita ambil?  Saya akan fokus pada pengembangan aplikasi web, karena lebih dekat dengan saya.  Misalnya, kita dapat memotret jumlah permintaan, titik akhir kita, waktu respons titik akhir kita, kode respons layanan terkait, jika kita pergi ke sana dan kita memiliki arsitektur layanan-mikro.  Jika kita menggunakan cache, kita dapat memahami seberapa efektif cache miss atau hit, memahami distribusi waktu respons dari kedua server pihak ketiga, dan, misalnya, database.  Tetapi untuk melihat metrik, Anda harus mengumpulkannya. <br><br><img src="https://habrastorage.org/webt/4f/x3/9a/4fx39auteviuwx9dfiefacsjz_q.jpeg"><br><br>  Bagaimana kita mengumpulkannya?  Ada beberapa opsi.  Saya ingin memberi tahu Anda tentang opsi pertama - skema push.  Terdiri dari apa itu? <br><br>  Misalkan kita menerima permintaan dari pengguna.  Secara lokal, dengan aplikasi kami, kami memasang beberapa jenis, biasanya agen pendorong.  Katakanlah kita memiliki Docker, ada aplikasi di dalamnya, dan agen push masih berdiri paralel.  Agen pendorong menerima nilai metrik dari kami secara lokal, entah bagaimana buffer, membuat batch dan mengirimkannya ke sistem penyimpanan metrik. <br><br>  Apa keuntungan menggunakan skema push?  Kami dapat mengirim beberapa metrik langsung ke sistem metrik dari aplikasi, tetapi pada saat yang sama kami mendapatkan semacam interaksi jaringan, latensi, overhead untuk mengumpulkan metrik.  Dalam kasus klien push lokal, ini diratakan. <br><br><img src="https://habrastorage.org/webt/n5/ff/o7/n5ffo732rxl3styovoxwmjnffim.jpeg"><br><br>  Opsi lain adalah skema tarikan.  Dengan skema tarikan, kami memiliki skenario yang sama.  Permintaan dari pengguna datang kepada kami, kami entah bagaimana menyimpannya di rumah.  Dan kemudian dengan frekuensi tertentu - satu detik, satu menit, sesuai keinginan Anda - sistem pengumpulan metrik sampai pada titik akhir khusus aplikasi kami dan mengambil indikator ini. <br><br><img src="https://habrastorage.org/webt/ob/xy/88/obxy88kzj0owhgydp-kr02gisx0.jpeg"><br><br>  Pilihan lain adalah log.  Kita semua menulis log dan mengirimnya ke suatu tempat.  Tidak ada yang mencegah kami mengambil log ini, entah bagaimana memprosesnya dan mendapatkan metrik berdasarkan log. <br><br>  Misalnya, kami menulis fakta permintaan pengguna di log, lalu kami mengambil log, hop-hop, dihitung.  Contoh khas adalah ELK (Elasticsearch, Logstash, Kibana). <br><br><img src="https://habrastorage.org/webt/qb/r1/ji/qbr1ji36v03ahocy3_hj5wy7ihs.jpeg"><br><br>  Bagaimana cara kerjanya dengan kita?  Yandex memiliki infrastruktur sendiri, sistem pengumpulan metrik sendiri.  Dia mengharapkan respons standar untuk pegangan yang menerapkan skema tarikan.  Plus kami memiliki cloud internal tempat kami meluncurkan aplikasi kami.  Dan semua ini terintegrasi ke dalam satu sistem.  Mengunggah ke cloud, kami cukup menunjukkan: "Buka pena ini dan dapatkan metriknya." <br><br><img src="https://habrastorage.org/webt/p7/ug/ls/p7uglskaraaguno_ngqnemhmbgc.jpeg"><br><br>  Berikut adalah contoh respons untuk skema penarikan yang diharapkan oleh sistem pengumpulan metrik kami. <br><br>  Bagi kami sendiri dalam tim, kami memutuskan untuk memilih cara yang lebih cocok bagi kami, untuk menyoroti beberapa kriteria yang dengannya kami akan memilih opsi terbaik untuk kami.  Efisiensi adalah seberapa cepat kita bisa mendapatkan dalam sistem metrik tampilan fakta tindakan apa pun.  Ketergantungan - apakah kita perlu menginstal alat tambahan atau entah bagaimana mengkonfigurasi infrastruktur untuk mendapatkan metrik.  Dan fleksibilitas - cara metode ini cocok untuk berbagai jenis aplikasi. <br><br><img src="https://habrastorage.org/webt/h2/ao/s4/h2aos4jq6iboqpi9ze3254om0rs.jpeg"><br><br>  Itulah yang akhirnya kami dapatkan.  Meskipun, sesuai dengan kriteria efisiensi dan fleksibilitas, skema push akan menang.  Tetapi kami sedang mengembangkan aplikasi web, dan cloud kami sudah memiliki infrastruktur siap pakai untuk bekerja dengan tugas ini, jadi kami memutuskan untuk memilih skema penarik untuk diri kami sendiri.  Kami akan membicarakannya. <br><br>  Untuk memberikan sesuatu pada skema penarik, kita perlu melakukan pra-agregat di suatu tempat, menyimpannya.  Sistem pemantauan kami beroperasi ke pegangan setiap lima detik.  Di mana kita bisa menabung?  Secara lokal di memori Anda atau di penyimpanan pihak ketiga. <br><br><img src="https://habrastorage.org/webt/pa/ft/sb/paftsbyryl5ojm43di6mhwrxge4.jpeg"><br><br>  Jika kita menyimpan secara lokal, maka sebagai aturan, ini cocok untuk kasus dengan satu proses.  Dan kami, di uWSGI kami, menjalankan beberapa proses secara paralel.  Atau kita dapat menggunakan beberapa jenis penyimpanan bersama.  Apa yang terlintas dalam pikiran kita dengan kata "penyimpanan bersama"?  Ini adalah semacam database Redis, Memcached, relasional atau non-relasional, atau bahkan file. <br><br><img src="https://habrastorage.org/webt/ms/um/fb/msumfb5j3za1j6b7qxrklpnvww8.jpeg"><br><br>  Tentang uWSGI.  Biarkan saya mengingatkan Anda tentang mereka yang jarang menggunakannya: uWSGI adalah server aplikasi web yang memungkinkan Anda menjalankan aplikasi Python di bawah Anda.  Ini mengimplementasikan antarmuka, protokol uWSGI.  Protokol ini dijelaskan dalam PEP 333, yang tertarik, Anda dapat membaca. <br><br><img src="https://habrastorage.org/webt/vg/ke/yy/vgkeyyiamyh4dfcbclpg-rhi17m.jpeg"><br><br>  Ini juga akan membantu kita untuk memilih solusi Yandex.Tank terbaik.  Ini adalah alat pengujian beban, memungkinkan Anda untuk menggunakan aplikasi kami dengan berbagai profil beban dan membuat grafik yang indah.  Atau berfungsi di konsol, sesuka Anda. <br><br><img src="https://habrastorage.org/webt/vl/79/jq/vl79jqtqnv8hgqvjeqhetqdzhpi.jpeg"><br><br>  Eksperimennya.  Kami akan membuat aplikasi sintetis untuk pengujian sintetis kami, kami akan menggantinya dengan tangki.  Aplikasi uWSGI akan memiliki konflik sederhana dengan 10 pekerja. <br><br><img src="https://habrastorage.org/webt/nk/ui/s4/nkuis4s4fgzpkj7tmvlchyn0dr4.jpeg"><br><br>  Ini adalah aplikasi Flask kami.  Payload yang dilakukan oleh aplikasi kita, kita akan meniru loop kosong. <br><br><img src="https://habrastorage.org/webt/sc/d5/qt/scd5qtepls29c1u46xknxbcwfxm.jpeg"><br><br>  Kami memecat, dan Yandex.Tank memberi kami salah satu dari grafik ini.  Apa yang dia perlihatkan?  Persentase waktu respons.  Garis miring adalah RPS yang tumbuh, dan histogram adalah apa persentil server web kami muat di bawah beban seperti itu. <br><br>  Kami akan mengambil opsi ini sebagai referensi dan melihat bagaimana berbagai opsi untuk menyimpan metrik memengaruhi kinerja. <br><br><img src="https://habrastorage.org/webt/9d/j2/x_/9dj2x_mwlyb7ovl-e9y24nkey1c.jpeg"><br><br>  Opsi paling sederhana adalah menggunakan PostgreSQL.  Karena kami bekerja dengan PostgreSQL, kami memilikinya.  Mari kita gunakan apa yang sudah siap. <br><br>  Katakanlah kita memiliki label di PostgreSQL di mana kita cukup menambah penghitungnya. <br><br><img src="https://habrastorage.org/webt/_7/zx/ja/_7zxjarhpil1cwhzw2q-b1j48rg.jpeg"><br><br>  Sudah pada sejumlah kecil RPS kami melihat penurunan kinerja yang kuat.  Bisa dikatakan besar sekali. <br><br><img src="https://habrastorage.org/webt/ox/c7/tm/oxc7tm1_kizqnqdli6rkzunqeau.jpeg"><br><br>  Opsi selanjutnya adalah Redis.  Tapi di sini kita melakukan lebih pintar: kita menginstalnya secara lokal dan pergi bukan melalui jaringan, tetapi melalui soket Unix.  Tingkatkan juga counter. <br><br><img src="https://habrastorage.org/webt/6k/zv/wv/6kzvwvil-aitqzp2rdys3ggjz5e.jpeg"><br><br>  Kami mendapatkan histogram waktu respons di output.  Kita melihat bahwa segala sesuatunya lebih baik di sini, tetapi pada titik tertentu kita mengalami rak, dan kemudian produktivitas tidak lagi tumbuh.  Opsi ini tampaknya lebih optimal, tetapi kami ingin melakukan yang lebih baik lagi. <br><br><img src="https://habrastorage.org/webt/ts/xs/m7/tsxsm7cnr7qsk0-aydibqnsmobg.jpeg"><br><br>  Di sini uWSGI, gabungan nyata, datang untuk membantu kami.  Ada banyak modul berbeda.  Bagal untuk menjalankan subproses, kerangka kerja cache, cron, subsistem metrik, dan sistem peringatan.  â€œSistem metrik subsistemâ€ - terdengar menjanjikan. <br><br><img src="https://habrastorage.org/webt/xt/rd/ip/xtrdipfn_v0kmanjjipkuc2fd_w.jpeg"><br><br>  Dia tahu cara menambahkan semacam metrik, menambah penghitung, mengurangi penghitung, mengalikan, membagi - apa pun yang diinginkan hati Anda. <br><br>  Satu-satunya subsistem metrik tidak dapat memberikan dengan tepat metrik yang ada di dalamnya. <br><br>  Mengapa ini penting bagi kami?  Seperti yang Anda lihat sebelumnya, kami memiliki pegangan untuk memberikan statistik dalam format tertentu, dan beberapa pekerja berjalan.  Kami tidak tahu pekerja mana yang akan menerima permintaan, tetapi untuk mengembalikan semua metrik, kami perlu membuat semacam daftar nama dan entah bagaimana mengacaknya di antara proses.  Ini masalah besar, saya ingin menghindari ini.  Apa lagi yang kita miliki? <br><br><img src="https://habrastorage.org/webt/tu/st/ir/tustir9lyytiuq5noxzeosk7uyq.jpeg"><br><br>  Tentu saja, subsistem cache.  Dan di sini kita melihat: dia dapat melakukan hal yang hampir sama, dan juga dapat memberikan nama-nama kunci yang disimpan dalam cache.  Ini yang kamu butuhkan. <br><br><img src="https://habrastorage.org/webt/4l/le/um/4lleum60xf9n635wiue31dvaptk.jpeg"><br><br>  Subsistem cache adalah cache yang dibangun ke dalam uWSGI.  Modul cepat dan aman, yang merupakan penyimpanan nilai kunci biasa. <br><br><img src="https://habrastorage.org/webt/gf/a3/w4/gfa3w4hje0atgnlctpzdr6n1hcg.jpeg"><br><br>  Tetapi karena ini adalah cache, ada masalah kedua yang terkenal: bagaimana memberi nama variabel dan cara membatalkan cache?  Dalam kasus kami, mari kita lihat apa pengaturan cache default.  Ini memiliki batasan pada panjang kunci.  Dalam kasus kami, ini adalah nama metrik.  Standarnya adalah 2048 byte.  Dan Anda dapat menambah konfigurasi jika perlu.  Jumlah elemen yang disimpan secara default adalah 65.536. Tampaknya nilai ini harus cukup untuk semua orang.  Tidak mungkin ada orang yang akan mengumpulkan sejumlah metrik dari aplikasi mereka. <br><br>  Dan ttl secara default adalah 0. Artinya, nilai dari cache yang disimpan tidak cacat waktu.  Jadi, kita bisa mendapatkannya dari cache dan mengirimkannya ke sistem metrik. <br><br><img src="https://habrastorage.org/webt/nb/q8/zu/nbq8zuosdcqk0rss824oiweqifc.jpeg"><br><br>  Sekali lagi, opsinya adalah aplikasi yang menggunakan kotak uWSGI. <br><br><img src="https://habrastorage.org/webt/v6/ri/fb/v6rifbjrax-igqz5bfpn2m5powu.jpeg"><br><br>  Berikut adalah hasil penembakan aplikasi ini. <br><br><img src="https://habrastorage.org/webt/qs/dg/0-/qsdg0-_dj_bqttsbdoewg5rcps8.jpeg"><br><br>  Hasilnya tanpa metrik, jika dengan uWSGI, dengan peregangan terlihat hampir sama. <br><br><img src="https://habrastorage.org/webt/lw/xp/xz/lwxpxzc2jf-hyfnx4fcysnfmrfi.jpeg"><br><br>  Seperti yang Anda lihat, dalam kasus uWSGI, kami hanya kehilangan 5% kinerja relatif terhadap versi "vanilla" tanpa metrik.  Opsi lain memiliki drawdown yang cukup signifikan, dan karena itu, sebagai hasil voting penonton, uWSGI menang. <br><br><img src="https://habrastorage.org/webt/xw/sg/hf/xwsghfrlb5z8kwt_kzv4mgvxjhe.jpeg"><br><br>  Bagaimana kami menerapkan ini?  Kami menulis perpustakaan kecil, pembungkus di sekitar uWSGI.  Misalnya, kami memasang turunan perpustakaan kami dan di sini kami menambahkan metrik "Waktu permintaan basis data" sebagai contoh. <br><br><img src="https://habrastorage.org/webt/jh/k2/qa/jhk2qajtaazyhqvckbyi63r8iiy.jpeg"><br><br>  Kami juga tertarik melacak cara kerja cache.  Kami cukup mendefinisikan kembali metode memca klien, menghemat waktu untuk menerima data, waktu untuk mengunduh dan jumlah cache hit dan cache miss. <br><br><img src="https://habrastorage.org/webt/6r/cy/v7/6rcyv7zh51cjphtabkfhwwgjui4.jpeg"><br><br>  Bagaimana kita melakukan ini di dalam perpustakaan?  Untuk mengirimkan nilai, kami mendapatkan nama-nama kunci yang disimpan dalam cache, menjalankannya dan memberikannya dalam format yang diinginkan ke titik akhir. <br><br><img src="https://habrastorage.org/webt/3g/ts/y-/3gtsy-g-qfq9ro1h71j_pjkhtk0.jpeg"><br><br>  Sebagai hasilnya, kami mendapatkan grafik, dalam hal ini adalah persentil ke-99 dari waktu akses cache, membaca dan menulis. <br><br><img src="https://habrastorage.org/webt/ho/fg/td/hofgtdq1ewg1qoqabjpid3ukpds.jpeg"><br><br>  Atau, sebagai opsi, jumlah permintaan layanan pihak ketiga ke API kami. <br><br><img src="https://habrastorage.org/webt/dk/ba/zw/dkbazwujnh0sq9uf2uyj6wmgy_o.jpeg"><br><br>  Kami memiliki kisah kegagalan dan kesuksesan.  Kami mulai menambahkan lebih banyak metrik dan melihat penurunan kinerja.  Metrik itu sendiri membantu kami.  Jika Anda mengumpulkan metrik, maka Anda dapat melihat ada sesuatu yang salah.  Oleh karena itu, saya juga menyarankan Anda untuk melihat secara metrik metrik yang telah Anda kumpulkan selama seminggu, sebulan, enam bulan.  Dan lihat tren apa yang ditampilkan aplikasi Anda di indikator mana.  Kami menyadari bahwa kami mulai bersandar pada perhitungan metrik. <br><br><img src="https://habrastorage.org/webt/if/k_/uc/ifk_ucasa_eegw5jangcb-oudwm.jpeg"><br><br>  Pembuatan profil membantu kami.  Di sini Anda melihat flamegraph, secara visual menunjukkan kepada kita berapa banyak panggilan dari berbagai fungsi yang diambil selama proses, yang panggilan memberikan kontribusi terbesar dalam waktu.  Kami menyadari bahwa kami tidak melakukannya dengan baik di versi pertama menggunakan acar.  Di dalam perpustakaan kami, dia menghabiskan banyak waktu mengasinkan. <br><br><img src="https://habrastorage.org/webt/kd/xn/nm/kdxnnm1oaklpbbsdoiw48yljkc8.jpeg"><br><br>  Kami menolak pengawetan, ditransfer ke cashe inc, mengukur segalanya, itu menjadi lebih cepat. <br><br><img src="https://habrastorage.org/webt/fp/v_/qe/fpv_qetjlbsj1dcgt4wo2z3xr2q.jpeg"><br><br>  Dalam implementasi baru, kami menghabiskan sebagian besar waktu kami bekerja dengan cache, bukan acar. <br><br><img src="https://habrastorage.org/webt/ju/x2/cs/jux2cs4k52ekeeqalcaeltpawkc.jpeg"><br><br>  Kenapa aku memberitahumu ini?  Saya mendorong Anda untuk mulai mengumpulkan metrik, menonton metrik, dan fokus pada metrik.  Saat memilih opsi pengumpulan metrik yang mungkin, bandingkan opsi, lihat mana yang terbaik untuk Anda.  Dan, tentu saja, membuat profil itu bagus.  Jika Anda melihat ada sesuatu yang salah, ada yang melambat - profil. <br><br>  Terima kasih semuanya!  Seperti yang saya janjikan, referensi: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yandex</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terima kasih</a> , </li><li>  Utilitas pembuatan profil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mata-mata</a> yang ditulis dalam Rust, </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lapor oleh</a> Alexander Koshelev tentang penggunaan uWSGI. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462697/">https://habr.com/ru/post/id462697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462687/index.html">Panel kontrol hosting baru dari ISPsystem: cara melihatnya</a></li>
<li><a href="../id462689/index.html">DISKOBALL: Kompetisi melempar HDD, 23 Agustus, Moskow</a></li>
<li><a href="../id462691/index.html">Cara bermigrasi dari AD ke LDAP saat menggunakan Zimbra</a></li>
<li><a href="../id462693/index.html">Dalam perjalanan ke aplikasi tahan lama dengan generator situs statis PSKOV sebagai contoh</a></li>
<li><a href="../id462695/index.html">Materi sebagai WebComponents</a></li>
<li><a href="../id462699/index.html">Service mesh, "Data plane" dan "Control plane" (Layanan data mesh vs bidang kendali)</a></li>
<li><a href="../id462701/index.html">Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 2</a></li>
<li><a href="../id462703/index.html">Pintu putar "termurah" di Rusia dikendalikan dari smartphone</a></li>
<li><a href="../id462705/index.html">5 bug teratas dalam aplikasi ReactJS saya</a></li>
<li><a href="../id462707/index.html">Kubernetes Meluncurkan Alat Pengembang Aplikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>