<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♟️ 👐🏽 🤾 Otomasi Untuk Yang Terkecil. Bagian 1.1. Dasar-dasar Virtualisasi 👨🏿‍🚒 🌤️ 🤖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel sebelumnya membahas arsitektur jaringan tervirtualisasi, overlay-overlay, jalur paket antara VM dan banyak lagi. 
 Roman Gorge terinspirasi ol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomasi Untuk Yang Terkecil. Bagian 1.1. Dasar-dasar Virtualisasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467801/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel sebelumnya membahas</a> arsitektur jaringan tervirtualisasi, overlay-overlay, jalur paket antara VM dan banyak lagi. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Roman Gorge</a> terinspirasi olehnya dan memutuskan untuk menulis masalah ulasan tentang virtualisasi secara umum. <br><br>  Pada artikel ini kita akan menyentuh (atau mencoba menyentuh) pertanyaan: bagaimana virtualisasi fungsi jaringan benar-benar terjadi, bagaimana backend produk utama untuk meluncurkan dan mengelola VM diterapkan, dan bagaimana switching virtual bekerja (OVS dan Linux bridge). <br><br>  Topik virtualisasi sangat luas dan mendalam, tidak mungkin menjelaskan semua detail kerja hypervisor (dan itu tidak perlu).  Kami akan membatasi diri pada set minimum pengetahuan yang diperlukan untuk memahami operasi solusi virtual apa pun, belum tentu Telco. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8ec/aa6/6a78ecaa6f26c867f0a37f010511ef7a.png" width="800"></a> <br><br><h1>  Isi </h1><br><ul><li>  <b>Pengantar dan sejarah singkat virtualisasi</b> </li><li>  <b>Jenis sumber daya virtual - komputasi, penyimpanan, jaringan</b> </li><li>  <b>Peralihan virtual</b> </li><li>  <b>Alat virtualisasi - libvirt, virsh dan banyak lagi</b> </li><li>  <b>Kesimpulan</b> </li></ul><br><hr><br><br><a name="habracut"></a><br><br><h1>  Pengantar dan sejarah singkat virtualisasi </h1><br><br>  Sejarah teknologi virtualisasi modern berasal dari tahun 1999, ketika perusahaan muda VMware merilis produk yang disebut VMware Workstation.  Ini adalah produk virtualisasi untuk aplikasi desktop / klien.  Virtualisasi sisi server datang sedikit kemudian dalam bentuk produk ESX Server, yang kemudian berkembang menjadi ESXi (i berarti terintegrasi) - ini adalah produk yang sama yang digunakan secara universal di TI dan Telco sebagai hypervisor aplikasi server. <br><br>  Di sisi opensource, dua proyek besar telah membawa virtualisasi ke Linux: <br><ul><li>  KVM (Kernel Virtual Machine) adalah modul kernel Linux yang memungkinkan kernel berfungsi sebagai hypervisor (menciptakan infrastruktur yang diperlukan untuk memulai dan mengelola VM).  Itu ditambahkan dalam versi kernel 2.6.20 pada 2007. </li><li>  QEMU (Quick Emulator) - secara langsung mengemulasi perangkat keras untuk mesin virtual (CPU, Disk, RAM, apa pun termasuk port USB) dan digunakan bersama dengan KVM untuk mencapai kinerja yang hampir "asli". </li></ul><br><br><blockquote>  Faktanya, saat ini, semua fungsionalitas KVM tersedia di QEMU, tetapi ini tidak penting, karena sebagian besar pengguna virtualisasi Linux tidak secara langsung menggunakan KVM / QEMU, tetapi mengaksesnya melalui setidaknya satu level abstraksi, tetapi lebih pada nanti. <br></blockquote><br><br>  Saat ini, VMware ESXi dan Linux QEMU / KVM adalah dua hypervisor utama yang mendominasi pasar.  Mereka juga merupakan perwakilan dari dua jenis hypervisor yang berbeda: <br><ul><li>  Tipe 1 - hypervisor berjalan langsung pada perangkat keras (bare-metal).  Ini adalah VMware ESXi, Linux KVM, Hyper-V </li><li>  Tipe 2 - hypervisor diluncurkan di dalam Host OS (sistem operasi).  Ini adalah VMware Workstation atau Oracle VirtualBox. </li></ul><br><br>  Diskusi tentang apa yang lebih baik dan apa yang lebih buruk berada di luar cakupan artikel ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/dfe/fa6/d74dfefa6a9c07a43bca6f4a07db1a3d.gif" width="600"><br><br>  Produsen besi juga harus melakukan bagian mereka untuk memastikan kinerja yang dapat diterima. <br><br>  Mungkin yang paling penting dan paling banyak digunakan adalah Intel VT (Teknologi Virtualisasi) - satu set ekstensi yang dikembangkan oleh Intel untuk prosesor x86 yang digunakan untuk operasi hypervisor yang efektif (dan dalam beberapa kasus diperlukan, misalnya, KVM tidak akan bekerja tanpa VT dihidupkan) -x dan tanpa itu, hypervisor dipaksa untuk terlibat dalam persaingan perangkat lunak murni, tanpa akselerasi perangkat keras). <br>  Dua dari ekstensi ini paling dikenal - VT-x dan VT-d.  Yang pertama adalah penting untuk meningkatkan kinerja CPU selama virtualisasi, karena menyediakan dukungan perangkat keras untuk beberapa fungsinya (dengan VT-x 99,9% kode OS Guest dieksekusi langsung pada prosesor fisik, membuat output untuk emulasi hanya dalam kasus yang paling diperlukan), yang kedua adalah untuk menghubungkan perangkat fisik secara langsung ke mesin virtual (untuk meneruskan fungsi virtual (VF) SRIOV, misalnya, VT-d <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harus diaktifkan</a> ). <br><br>  Konsep penting berikutnya adalah perbedaan antara virtualisasi penuh dan para-virtualisasi. <br>  Virtualisasi penuh bagus, memungkinkan Anda untuk menjalankan sistem operasi apa pun pada prosesor apa pun, namun, itu sangat tidak efisien dan sama sekali tidak cocok untuk sistem yang sarat muatan. <br>  Singkatnya, para-virtualisasi adalah ketika Guest OS memahami bahwa itu berjalan di lingkungan virtual dan bekerja sama dengan hypervisor untuk mencapai efisiensi yang lebih besar.  Yaitu, antarmuka tamu-hypervisor muncul. <br>  Sebagian besar sistem operasi yang digunakan saat ini memiliki dukungan untuk para-virtualisasi - di kernel Linux, ini telah muncul sejak kernel versi 2.6.20. <br><br>  Agar mesin virtual berfungsi, tidak hanya prosesor virtual (vCPU) dan memori virtual (RAM) yang diperlukan, emulasi perangkat PCI juga diperlukan.  Faktanya, seperangkat driver diperlukan untuk mengelola antarmuka jaringan virtual, disk, dan sebagainya. <br>  Dalam hypervisor KVM Linux, tugas ini diselesaikan dengan menerapkan <b>virtio</b> , kerangka kerja untuk mengembangkan dan menggunakan perangkat I / O tervirtualisasi. <br>  Virtio adalah level tambahan abstraksi, yang memungkinkan Anda untuk meniru berbagai perangkat I / O dalam hypervisor para-virtual, menyediakan antarmuka yang seragam dan standar ke sisi mesin virtual.  Ini memungkinkan Anda untuk menggunakan kembali kode driver virtio untuk berbagai perangkat yang inheren.  Virtio terdiri dari: <br><ul><li>  Driver front-end - apa yang ada di mesin virtual </li><li>  Driver back-end - apa yang ada di hypervisor </li><li>  Pengemudi transportasi - apa yang menghubungkan backend dan frontend </li></ul><br>  Modularitas ini memungkinkan Anda untuk mengubah teknologi yang digunakan dalam hypervisor tanpa mempengaruhi driver di mesin virtual (titik ini sangat penting untuk teknologi akselerasi jaringan dan solusi Cloud secara umum, tetapi lebih lanjut tentang itu nanti). <br>  Yaitu, ada koneksi tamu-hypervisor ketika OS Guest "tahu" bahwa itu berjalan di lingkungan virtual. <br><blockquote>  Jika Anda pernah menulis pertanyaan dalam RFP atau menjawab pertanyaan dalam RFP "Apakah virtio didukung dalam produk Anda?"  Itu hanya tentang mendukung driver virtio front-end. <br></blockquote><br><br><h1>  Jenis sumber daya virtual - komputasi, penyimpanan, jaringan </h1><br>  Terdiri dari apa mesin virtual itu? <br>  Ada tiga jenis utama sumber daya virtual: <br><br><ul><li>  compute - prosesor dan RAM </li><li>  storage - disk sistem mesin virtual dan penyimpanan blok </li><li>  jaringan - kartu jaringan dan perangkat input / output </li></ul><br><br><hr><br><br><h1>  Hitung </h1><br><br><h2>  CPU </h2><br>  Secara teoritis, QEMU mampu mengemulasi segala jenis prosesor dan flag serta fungsionalitasnya yang sesuai; dalam praktiknya, mereka menggunakan salah satu model host dan mematikan flag secara langsung sebelum memindahkannya ke OS Guest, atau mereka mengambil model-nama dan mengaktifkan / menonaktifkan flag secara searah. <br><br>  Secara default, QEMU akan mengemulasi prosesor yang OS Tamu akan kenal sebagai QEMU Virtual CPU.  Ini bukan tipe prosesor yang paling optimal, terutama jika aplikasi yang berjalan di mesin virtual menggunakan flag CPU untuk pekerjaannya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelajari lebih lanjut tentang berbagai model CPU di QEMU</a> . <br><br>  QEMU / KVM juga memungkinkan Anda untuk mengontrol topologi prosesor, jumlah utas, ukuran cache, ikat vCPU ke inti fisik dan banyak lagi. <br><br>  Apakah ini diperlukan untuk mesin virtual atau tidak tergantung pada jenis aplikasi yang berjalan pada OS Guest.  Sebagai contoh, itu adalah fakta yang terkenal bahwa untuk aplikasi yang memproses paket dengan PPS tinggi, penting untuk melakukan <b>pinning CPU</b> , yaitu, tidak memungkinkan prosesor fisik untuk ditransfer ke mesin virtual lainnya. <br><br><h2>  Memori </h2><br>  Baris berikutnya adalah RAM.  Dari sudut pandang Host OS, mesin virtual yang diluncurkan menggunakan QEMU / KVM tidak berbeda dari proses lain yang berjalan di ruang pengguna sistem operasi.  Karenanya, proses mengalokasikan memori ke mesin virtual dilakukan oleh panggilan yang sama di kernel Host OS, seolah-olah Anda meluncurkan, misalnya, browser Chrome. <br><br><blockquote>  Sebelum melanjutkan kisah RAM di mesin virtual, Anda perlu menyimpang dan menjelaskan istilah <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUMA</a></b> - Non-Uniform Memory Access. <br>  Arsitektur server fisik modern melibatkan kehadiran dua prosesor atau lebih (CPU) dan terkait dengannya memori akses acak (RAM).  Seperti sekelompok prosesor + memori disebut node atau node.  Komunikasi antara berbagai NUMA node dilakukan melalui bus khusus - <b>QPI</b> (QuickPath Interconnect) <br><br>  NUMA node lokal dialokasikan - ketika proses yang berjalan di sistem operasi menggunakan prosesor dan RAM yang terletak di NUMA node yang sama, dan NUMA node jarak jauh - ketika proses yang berjalan di sistem operasi menggunakan prosesor dan RAM yang terletak di NUMA node yang berbeda, yaitu, untuk interaksi prosesor dan memori, diperlukan transfer data melalui bus QPI. <br></blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/360/7e9/ea33607e91282db8bda346d7f63cf9fd.png" width="600"><br><br>  Dari sudut pandang mesin virtual, memori sudah dialokasikan untuk itu pada saat peluncurannya, tetapi pada kenyataannya tidak demikian, dan kernel Host OS mengalokasikan bagian memori baru untuk proses QEMU / KVM karena aplikasi di OS Guest meminta memori tambahan (walaupun mungkin juga ada pengecualian jika Anda secara langsung menentukan QEMU / KVM untuk mengalokasikan semua memori ke mesin virtual langsung saat startup). <br><br>  Memori dialokasikan bukan byte demi byte, tetapi oleh <b>halaman</b> ukuran tertentu.  Ukuran halaman dapat dikonfigurasi dan secara teoritis dapat berupa apa saja, tetapi dalam praktiknya ukurannya adalah 4kB (default), 2MB dan 1GB.  Dua ukuran terakhir disebut <b>HugePages</b> dan sering digunakan untuk mengalokasikan memori untuk mesin virtual intensif memori.  Alasan untuk menggunakan HugePages dalam proses menemukan kecocokan antara alamat virtual halaman dan memori fisik dalam <b>Translation Lookaside Buffer</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TLB</a></b> ), yang pada gilirannya terbatas dan menyimpan informasi hanya tentang halaman yang terakhir digunakan.  Jika tidak ada informasi tentang halaman yang diinginkan di TLB, proses yang disebut <b>miss TLB</b> terjadi, dan Anda perlu menggunakan prosesor Host OS untuk menemukan sel memori fisik yang sesuai dengan halaman yang diinginkan. <br><br>  Proses ini tidak efisien dan lambat, sehingga lebih sedikit halaman dengan ukuran yang lebih besar digunakan. <br>  QEMU / KVM juga memungkinkan Anda untuk meniru berbagai topologi NUMA untuk OS Guest, mengambil memori untuk mesin virtual hanya dari NUMA node Host OS tertentu, dan sebagainya.  Praktik yang paling umum adalah mengambil memori untuk mesin virtual dari NUMA node lokal ke prosesor yang dialokasikan ke mesin virtual.  Alasannya adalah keinginan untuk menghindari beban yang tidak perlu pada bus <b>QPI yang</b> menghubungkan soket CPU dari server fisik (tentu saja, ini logis jika server Anda memiliki 2 soket atau lebih). <br><br><hr><br><br><h1>  Penyimpanan </h1><br>  Seperti yang Anda ketahui, RAM disebut memori operasional karena isinya menghilang ketika daya dimatikan atau sistem operasi dinyalakan kembali.  Untuk menyimpan informasi, Anda memerlukan perangkat penyimpanan persisten (ROM) atau <b>penyimpanan persisten</b> . <br>  Ada dua jenis penyimpanan persisten: <br><ul><li>  Block storage - blok ruang disk yang dapat digunakan untuk menginstal sistem file dan membuat partisi.  Jika tidak sopan, maka Anda dapat menganggapnya sebagai disk biasa. </li><li>  Penyimpanan objek - informasi hanya dapat disimpan sebagai objek (file), dapat diakses melalui HTTP / HTTPS.  Contoh umum penyimpanan objek adalah AWS S3 atau Dropbox. </li></ul><br><br>  Mesin virtual membutuhkan <b>penyimpanan persisten</b> , bagaimana cara melakukan ini jika mesin virtual "hidup" dalam RAM OS host?  Singkatnya, setiap panggilan OS tamu ke pengontrol disk virtual dicegat oleh QEMU / KVM dan diubah menjadi catatan pada disk fisik OS host.  Metode ini tidak efisien, dan karenanya, di sini, serta untuk perangkat jaringan, driver virtio digunakan alih-alih sepenuhnya meniru perangkat IDE atau iSCSI.  Baca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dengan demikian, mesin virtual mengakses disk virtualnya melalui driver virtio, dan kemudian QEMU / KVM membuat informasi yang ditransfer ditulis ke disk fisik.  Penting untuk dipahami bahwa di OS Host, backend disk dapat diimplementasikan sebagai rak CEPH, NFS, atau iSCSI. <br><br>  Cara termudah untuk meniru penyimpanan persisten adalah dengan menggunakan file di beberapa direktori Host OS sebagai ruang disk mesin virtual.  QEMU / KVM mendukung berbagai format file jenis ini - raw, vdi, vmdk dan lainnya.  Namun, format yang paling banyak digunakan adalah <b>qcow2</b> (QEMU copy-on-write versi 2).  Secara umum, qcow2 adalah file terstruktur dengan cara tertentu tanpa sistem operasi apa pun.  Sejumlah besar mesin virtual didistribusikan dalam bentuk qcow2-images (images) dan merupakan salinan dari disk sistem mesin virtual, dikemas dalam format qcow2.  Ini memiliki beberapa keuntungan - pengkodean qcow2 memakan banyak ruang lebih sedikit daripada salinan mentah dari byte ke byte disk, QEMU / KVM dapat mengubah ukuran file qcow2, yang berarti dimungkinkan untuk mengubah ukuran disk mesin virtual, enkripsi AES qcow2 juga didukung (Ini masuk akal, karena gambar mesin virtual mungkin mengandung kekayaan intelektual). <br><br>  Lebih lanjut, ketika mesin virtual dimulai, QEMU / KVM menggunakan file qcow2 sebagai disk sistem (saya menghilangkan proses memuat mesin virtual di sini, meskipun ini juga merupakan tugas yang menarik), dan mesin virtual memiliki kemampuan untuk membaca / menulis data ke file qcow2 melalui virtio pengemudi.  Dengan demikian, proses pengambilan gambar dari mesin virtual bekerja, karena kapan saja file qcow2 berisi salinan lengkap dari disk sistem mesin virtual, dan gambar dapat digunakan untuk cadangan, transfer ke host lain, dll. <br><br>  Secara umum, file qcow2 ini akan didefinisikan dalam OS Guest sebagai perangkat <i>/ dev / vda</i> , dan OS Guest akan mempartisi ruang disk menjadi partisi dan menginstal sistem file.  Demikian pula, file qcow2 berikut yang dihubungkan oleh QEMU / KVM sebagai perangkat <i>/ dev / vdX</i> dapat digunakan sebagai <b>penyimpanan blok</b> dalam mesin virtual untuk menyimpan informasi (ini persis seperti komponen Openstack Cinder bekerja). <br><hr><br><br><h1>  Jaringan </h1><br>  Terakhir di daftar sumber daya virtual kami adalah kartu jaringan dan perangkat I / O.  Mesin virtual, seperti host fisik, membutuhkan <b>bus PCI / PCIe</b> untuk menghubungkan perangkat I / O.  QEMU / KVM mampu mengemulasi berbagai jenis chipset - q35 atau i440fx (yang pertama mendukung PCIe, yang kedua mendukung legacy PCI), serta berbagai topologi PCI, misalnya, membuat bus PCI yang terpisah (bus PCI expander) untuk NUMA node Guest OS. <br><br>  Setelah membuat bus PCI / PCIe, Anda harus menghubungkan perangkat I / O ke sana.  Secara umum, dapat berupa apa saja dari kartu jaringan hingga GPU fisik.  Dan, tentu saja, kartu jaringan, baik sepenuhnya tervirtualisasi (sepenuhnya antarmuka virtual e1000, misalnya), dan para-tervirtualisasi (virtio, misalnya) atau NIC fisik.  Opsi terakhir digunakan untuk mesin virtual data-plane di mana Anda perlu mendapatkan tarif paket tingkat garis - router, firewall, dll. <br><br>  Ada dua pendekatan utama di sini - <b>PCI passthrough</b> dan <b>SR-IOV</b> .  Perbedaan utama di antara mereka adalah bahwa untuk PCI-PT, driver hanya digunakan di dalam OS Guest, dan untuk SRIOV, driver OS Host (untuk membuat <b>VF - Fungsi Virtual</b> ) dan driver OS Guest digunakan untuk mengontrol SR-IOV VF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Juniper menulis</a> detail yang sangat baik tentang PCI-PT dan SRIOV. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/380/fb7/ff1380fb7061d5294514b79b4a368cfb.png" width="600"><br><br><blockquote>  Untuk klarifikasi, perlu dicatat bahwa PCI passthrough dan SR-IOV adalah teknologi yang saling melengkapi.  SR-IOV mengiris fungsi fisik menjadi fungsi virtual.  Ini dilakukan pada level OS host.  Pada saat yang sama, Host OS melihat fungsi virtual sebagai perangkat PCI / PCIe lainnya.  Apa yang dia lakukan selanjutnya dengan mereka tidak penting. <br><br>  Dan PCI-PT adalah mekanisme untuk meneruskan perangkat PCI OS Host di OS Guest, termasuk fungsi virtual yang dibuat oleh perangkat SR-IOV <br></blockquote><br><br>  Jadi, kami memeriksa jenis utama sumber daya virtual dan langkah selanjutnya adalah memahami bagaimana mesin virtual berkomunikasi dengan dunia luar melalui jaringan. <br><hr><br><br><h1>  Peralihan virtual </h1><br><br>  Jika ada mesin virtual, dan ada antarmuka virtual di dalamnya, maka, jelas, muncul masalah mentransfer paket dari satu VM ke yang lain.  Dalam hypervisor berbasis Linux (KVM, misalnya), masalah ini dapat diselesaikan menggunakan jembatan Linux, namun, proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Open vSwitch</a> (OVS) telah mendapatkan penerimaan luas. <br>  Ada beberapa fungsi inti yang memungkinkan OVS untuk menyebar luas dan menjadi metode packet switching primer yang digunakan dalam banyak platform komputasi awan (seperti Openstack) dan solusi tervirtualisasi. <br><ul><li>  Transfer status jaringan - saat memigrasi VM di antara hypervisor, tugas muncul saat mentransfer ACL, QoS, tabel penerusan L2 / L3, dan banyak lagi.  Dan OVS dapat melakukannya. </li><li>  Implementasi mekanisme transfer paket (datapath) di kedua kernel dan ruang pengguna </li><li>  Arsitektur CUPS (Control / User-plane separation) - memungkinkan Anda untuk mentransfer fungsionalitas pemrosesan paket ke chipset khusus (chipset Broadcom dan Marvell, misalnya, dapat melakukan ini), mengendalikannya melalui OVS pesawat kontrol. </li><li>  Dukungan untuk metode kontrol lalu lintas jarak jauh - Protokol OpenFlow (hai, SDN). </li></ul><br><br>  Arsitektur OVS pada pandangan pertama terlihat cukup menakutkan, tetapi hanya pada pandangan pertama. <br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/18f/4fa/e1e18f4fa99d66a99a4da3c06e1df33a.png" width="600"><br><br>  Untuk bekerja dengan OVS, Anda perlu memahami yang berikut: <br><ul><li>  <b>Datapath</b> - paket diproses di sini.  Analogi ini adalah switch-fabric dari saklar besi.  Datapath termasuk menerima paket, header pemrosesan, pencocokan yang cocok di tabel aliran, yang sudah diprogram dalam Datapath.  Jika OVS berjalan dalam kernel, itu diimplementasikan sebagai modul kernel.  Jika OVS berjalan di ruang pengguna, maka ini adalah proses di ruang pengguna Linux. </li><li>  <b>vswitchd</b> dan <b>ovsdb</b> adalah daemon di ruang pengguna, yang secara langsung mengimplementasikan fungsi switch, menyimpan konfigurasi, mengatur aliran ke datapath dan memprogramnya. </li><li>  Penyiapan OVS dan memecahkan masalah toolkit - <b>ovs-vsctl, ovs-dpctl, ovs-ofctl, ovs-appctl</b> .  Semua yang diperlukan untuk mendaftarkan konfigurasi port di ovsdb, mendaftar aliran mana yang harus dialihkan, mengumpulkan statistik dan sebagainya.  Orang baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis artikel</a> tentang ini. </li></ul><br><br>  <b>Bagaimana perangkat jaringan mesin virtual berakhir di OVS?</b> <br><br>  Untuk mengatasi masalah ini, kita perlu entah bagaimana menghubungkan antarmuka virtual yang terletak di ruang pengguna sistem operasi dengan OVS datapath yang terletak di kernel. <br><br>  Dalam sistem operasi Linux, paket ditransfer antara kernel dan proses ruang pengguna melalui dua antarmuka khusus.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kedua antarmuka menggunakan menulis / membaca paket ke / dari file khusus untuk mentransfer paket dari proses ruang pengguna ke kernel dan sebaliknya - file descriptor (FD) (ini adalah salah satu alasan untuk kinerja switching virtual yang buruk jika datapath OVS di kernel - setiap paket perlu menulis / membaca FD) </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TUN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (tunnel) - perangkat yang bekerja dalam mode L3 dan memungkinkan Anda untuk menulis / membaca hanya paket IP ke / dari FD.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ketuk jaringan) - sama dengan antarmuka tun + dapat melakukan operasi dengan frame Ethernet, mis. </font><font style="vertical-align: inherit;">bekerja dalam mode L2.</font></font></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a2/3fc/fc8/5a23fcfc86e0c6cbfdf8dc80cc562bbf.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itulah sebabnya ketika mesin virtual berjalan di Host OS, Anda dapat melihat antarmuka TAP yang dibuat dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan ip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font><font style="vertical-align: inherit;">perintah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ifconfig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ini adalah bagian "respons" dari virtio, yang "terlihat" di kernel Host OS. </font><font style="vertical-align: inherit;">Perlu juga dicatat bahwa antarmuka TAP memiliki alamat MAC yang sama dengan antarmuka virtio di mesin virtual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka TAP dapat ditambahkan ke OVS menggunakan perintah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ovs-vsctl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - maka setiap paket yang diubah oleh OVS ke antarmuka TAP akan ditransfer ke mesin virtual melalui deskriptor file.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prosedur sebenarnya untuk membuat mesin virtual mungkin berbeda, mis. </font><font style="vertical-align: inherit;">Pertama, Anda dapat membuat jembatan OVS, kemudian memberi tahu mesin virtual untuk membuat antarmuka yang terhubung ke OVS ini, atau sebaliknya.</font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, jika kita harus dapat mentransfer paket antara dua atau lebih mesin virtual yang berjalan pada hypervisor yang sama, kita hanya perlu membuat jembatan OVS dan menambahkan antarmuka TAP ke dalamnya menggunakan perintah ovs-vsctl. Tim mana yang dibutuhkan untuk ini mudah dicari di Google. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin ada beberapa jembatan OVS pada hypervisor, misalnya, ini adalah cara kerja Openstack Neutron, atau mesin virtual dapat berada dalam ruang nama yang berbeda untuk mengimplementasikan multi-tenancy. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan jika mesin virtual berada di jembatan OVS yang berbeda?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk mengatasi masalah ini, ada alat lain - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasangan veth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pasangan Veth dapat direpresentasikan sebagai sepasang antarmuka jaringan yang dihubungkan oleh kabel - semua yang “terbang” menjadi satu antarmuka, “terbang” dari yang lain. </font><font style="vertical-align: inherit;">Pasangan Veth digunakan untuk menghubungkan beberapa jembatan OVS atau jembatan Linux satu sama lain. </font><font style="vertical-align: inherit;">Poin penting lainnya adalah bahwa bagian-bagian dari pasangan veth dapat berada dalam namespace Linux OS yang berbeda, yaitu pasangan veth juga dapat digunakan untuk berkomunikasi namespace satu sama lain di tingkat jaringan.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alat virtualisasi - libvirt, virsh dan banyak lagi </font></font></h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam bab-bab sebelumnya kami memeriksa landasan teoritis virtualisasi, dalam bab ini kita akan berbicara tentang alat yang tersedia untuk pengguna secara langsung untuk memulai dan mengubah mesin virtual pada hypervisor KVM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita bahas tiga komponen utama yang mencakup 90 persen dari semua jenis operasi dengan mesin virtual:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> libvirt </font></font></li><li> virsh CLI </li><li> virt-install </li></ul><br><br><blockquote> ,      CLI-,    , ,     qemu_system_x86_64    virt manager,    .      Cloud-, Openstack, ,    libvirt. <br></blockquote><br><br><h2> libvirt </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt adalah proyek open-source skala besar yang mengembangkan seperangkat alat dan driver untuk mengelola hypervisor. Ini mendukung tidak hanya QEMU / KVM, tetapi juga ESXi, LXC dan banyak lagi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan utama popularitasnya adalah antarmuka yang terstruktur dan dapat dipahami untuk berinteraksi melalui satu set file XML, ditambah kemampuan untuk mengotomatisasi melalui API. Perlu dicatat bahwa libvirt tidak menggambarkan semua fungsi yang mungkin dari hypervisor, itu hanya menyediakan antarmuka yang nyaman untuk menggunakan fungsi hypervisor yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berguna</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dari sudut pandang peserta proyek. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan ya, libvirt adalah standar de facto di dunia virtualisasi saat ini. Hanya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melihat daftar aplikasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menggunakan libvirt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/115/f2f/b6f115f2f06f3fe06ee4727ec121c865.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kabar baiknya tentang libvirt adalah bahwa semua paket yang diperlukan sudah diinstal sebelumnya di semua OS Host yang paling sering digunakan - Ubuntu, CentOS dan RHEL, jadi kemungkinan besar Anda tidak perlu mengkompilasi paket yang diperlukan dan mengkompilasi libvirt. </font><font style="vertical-align: inherit;">Dalam kasus terburuk, Anda harus menggunakan pemasang batch yang sesuai (apt, yum dan sejenisnya). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah instalasi awal dan startup, libvirt membuat Linux bridge virbr0 dan konfigurasi minimalnya secara default.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itu sebabnya ketika menginstal Ubuntu Server, misalnya, Anda akan melihat di output dari perintah ifconfig Linux bridge virbr0 - ini adalah hasil dari menjalankan daemon libvirtd </font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jembatan Linux ini tidak akan terhubung ke antarmuka fisik apa pun, namun, dapat digunakan untuk berkomunikasi mesin virtual dalam satu hypervisor tunggal. </font><font style="vertical-align: inherit;">Libvirt tentu dapat digunakan bersama dengan OVS, namun, untuk ini, pengguna harus secara independen membuat jembatan OVS menggunakan perintah OVS yang sesuai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber daya virtual apa pun yang diperlukan untuk membuat mesin virtual (komputasi, jaringan, penyimpanan) direpresentasikan sebagai objek di libvirt. </font><font style="vertical-align: inherit;">Satu set file XML yang berbeda bertanggung jawab untuk proses menggambarkan dan membuat objek-objek ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak masuk akal untuk menggambarkan proses pembuatan jaringan virtual dan penyimpanan virtual secara terperinci, karena aplikasi ini dijelaskan dengan baik dalam dokumentasi libvirt:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaringan</font></font></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyimpanan</a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin virtual itu sendiri dengan semua perangkat PCI yang terhubung disebut domain dalam terminologi libvirt. Ini juga </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merupakan objek di dalam libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dijelaskan oleh file XML terpisah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File XML ini, sebenarnya, adalah mesin virtual dengan semua sumber daya virtual - RAM, prosesor, perangkat jaringan, disk, dan banyak lagi. Seringkali file XML ini disebut libvirt XML atau dump XML. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak mungkin bahwa akan ada orang yang memahami semua parameter libvirt XML, namun, ini tidak diperlukan ketika ada dokumentasi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, libvirt XML untuk Ubuntu Desktop Guest OS akan sangat sederhana - 40-50 baris. </font><font style="vertical-align: inherit;">Karena semua optimasi kinerja juga dijelaskan dalam libvirt XML (topologi NUMA, topologi CPU, pinning CPU, dll.), Untuk fungsi jaringan, libvirt XML bisa sangat kompleks dan berisi beberapa ratus baris. </font><font style="vertical-align: inherit;">Setiap produsen perangkat jaringan yang mengirimkan perangkat lunak mereka sebagai mesin virtual telah merekomendasikan contoh-contoh XML libvirt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virsh CLI </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilitas virsh adalah baris perintah "asli" untuk mengelola libvirt. </font><font style="vertical-align: inherit;">Tujuan utamanya adalah untuk mengelola objek libvirt yang digambarkan sebagai file XML. </font><font style="vertical-align: inherit;">Contoh khasnya adalah mulai, berhenti, mendefinisikan, menghancurkan, dan sebagainya. </font><font style="vertical-align: inherit;">Yaitu, siklus hidup objek - manajemen siklus hidup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi semua perintah dan flag virsh juga tersedia dalam dokumentasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virt-instal </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilitas lain yang digunakan untuk berinteraksi dengan libvirt. Salah satu keuntungan utama adalah Anda tidak harus berurusan dengan format XML, tetapi bertahan dengan bendera yang tersedia di Inggris. Poin penting kedua adalah lautan contoh dan informasi di Web. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, tidak masalah utilitas apa yang Anda gunakan, pada akhirnya akan menjadi libvirt yang akan mengendalikan hypervisor, sehingga penting untuk memahami arsitektur dan prinsip-prinsip operasinya.</font></font><br><hr><br><br><h1>  Kesimpulan </h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel ini, kami menguji set minimum pengetahuan teoritis yang diperlukan untuk bekerja dengan mesin virtual. </font><font style="vertical-align: inherit;">Saya sengaja tidak memberikan contoh dan kesimpulan praktis dari tim, karena contoh seperti itu dapat ditemukan sebanyak yang Anda suka di Web, dan saya tidak menetapkan diri saya tugas untuk menulis "panduan langkah demi langkah". </font><font style="vertical-align: inherit;">Jika Anda tertarik pada topik atau teknologi tertentu, tinggalkan komentar Anda dan tulis pertanyaan.</font></font><br><hr><br><br><h1>  Tautan yang bermanfaat </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memahami Perangkat QEMU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVM / SR-IOV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terima kasih </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Shalimov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kolega dan pakar saya dalam pengembangan jaringan virtual. </font><font style="vertical-align: inherit;">Untuk komentar dan pengeditan.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yevgeny Yakovlev, kolega dan pakar saya di bidang virtualisasi, untuk komentar dan koreksi. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467801/">https://habr.com/ru/post/id467801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467789/index.html">Java 13 baru saja tiba. ZGC telah mulai berbagi memori, CDS sendiri mengingat kelas, dan keajaiban teknis lainnya</a></li>
<li><a href="../id467791/index.html">Analisis pengguliran halaman di Google Data Studio</a></li>
<li><a href="../id467793/index.html">Tumpukan teknologi yang membosankan dari perusahaan internet satu orang</a></li>
<li><a href="../id467795/index.html">Catatan tentang cryptocurrency dan regulasi negara</a></li>
<li><a href="../id467797/index.html">"Tertawa demi": mengapa Anda membutuhkan alat perangkat lunak yang tidak memiliki aplikasi "perang"</a></li>
<li><a href="../id467803/index.html">Simulasi dasar interaksi fisik khusus dalam python + matplotlib</a></li>
<li><a href="../id467807/index.html">Membeli dan menjual cryptocurrency di Rusia: metode, legalisasi, risiko</a></li>
<li><a href="../id467811/index.html">Arsitektur dan pemrograman Fairchild Channel F</a></li>
<li><a href="../id467813/index.html">Tinjau perubahan dalam urutan 17 FSTEC</a></li>
<li><a href="../id467815/index.html">Media menimbulkan kepanikan bahwa "alamat IP kehabisan di Rusia." Bagaimana bisa?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>