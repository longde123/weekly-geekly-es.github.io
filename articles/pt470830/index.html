<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèª ü§´ ‚è±Ô∏è Ass√≠ncrono / aguardar em C #: conceito, design interno, truques √∫teis üèüÔ∏è üôÖüèº üßóüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia Desta vez, falaremos sobre um t√≥pico que todo aderente que se preze da linguagem C # come√ßou a entender - programa√ß√£o ass√≠ncrona usando Task o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ass√≠ncrono / aguardar em C #: conceito, design interno, truques √∫teis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470830/">  Bom dia  Desta vez, falaremos sobre um t√≥pico que todo aderente que se preze da linguagem C # come√ßou a entender - programa√ß√£o ass√≠ncrona usando Task ou, em pessoas comuns, ass√≠ncrona / aguardada.  A Microsoft fez um bom trabalho - para usar a assincronia na maioria dos casos, voc√™ s√≥ precisa conhecer a sintaxe e nenhum outro detalhe.  Mas se voc√™ se aprofundar, o t√≥pico √© bastante volumoso e complexo.  Foi afirmado por muitos, cada um em seu pr√≥prio estilo.  Existem muitos artigos interessantes sobre esse t√≥pico, mas ainda existem muitos conceitos errados.  Vamos tentar corrigir a situa√ß√£o e mastigar o material o m√°ximo poss√≠vel, sem sacrificar a profundidade ou a compreens√£o. <br><br><img src="https://habrastorage.org/webt/zn/or/r1/znorr1o7rsk1tzudgdrmgchrss4.jpeg"><br><a name="habracut"></a><br>  T√≥picos / cap√≠tulos cobertos: <br><br><ol><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O conceito de assincronia</a></b> - os benef√≠cios da assincronia e dos mitos sobre um fio "bloqueado" </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TAP.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sintaxe e condi√ß√µes de compila√ß√£o</a></b> - pr√©-requisitos para escrever um m√©todo de compila√ß√£o </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhar com o uso da TAP</a></b> - a mec√¢nica e o comportamento do programa em c√≥digo ass√≠ncrono (liberando threads, iniciando tarefas e aguardando a conclus√£o) </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nos bastidores: a m√°quina de estados</a></b> - uma vis√£o geral das transforma√ß√µes do compilador e as classes que gera </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As origens da assincronia.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O dispositivo de m√©todos ass√≠ncronos padr√£o</a></b> - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√©todos</a></b> ass√≠ncronos para trabalhar com arquivos e a rede por dentro </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classes e truques TAP</a></b> s√£o <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">truques</a></b> √∫teis que podem ajud√°-lo a gerenciar e acelerar um programa usando o TAP </li></ol><a name="conception"></a><br><h2>  Conceito ass√≠ncrono </h2><br>  A assincronia por si s√≥ est√° longe de ser nova.  A assincronia geralmente implica em executar uma opera√ß√£o em um estilo que n√£o implique em bloquear o encadeamento de chamada, ou seja, iniciar a opera√ß√£o sem aguardar sua conclus√£o.  O bloqueio n√£o √© t√£o mau como √© descrito.  Pode-se encontrar afirma√ß√µes de que threads bloqueados perdem tempo de CPU, trabalham mais lentamente e causam chuva.  Parece este √∫ltimo improv√°vel?  De fato, os 2 pontos anteriores s√£o os mesmos. <br><br>  No n√≠vel do planejador do SO, quando um encadeamento est√° em um estado "bloqueado", um tempo precioso do processador n√£o ser√° alocado a ele.  As chamadas do agendador, em regra, recaem sobre opera√ß√µes que causam bloqueio, interrup√ß√µes no cron√¥metro e outras interrup√ß√µes.  Ou seja, quando, por exemplo, o controlador de disco conclui a opera√ß√£o de leitura e inicia uma interrup√ß√£o apropriada, o agendador inicia.  Ele decidir√° se deve iniciar um encadeamento que foi bloqueado por esta opera√ß√£o ou outro com prioridade mais alta. <br><br>  O trabalho lento parece ainda mais absurdo.  De fato, o trabalho √© o mesmo.  Somente a opera√ß√£o ass√≠ncrona adicionar√° um pouco mais de sobrecarga. <br><br>  O desafio da chuva geralmente n√£o √© algo desta √°rea. <br><br>  O principal problema de bloqueio √© o consumo n√£o razo√°vel de recursos do computador.  Mesmo se esquecermos o tempo para criar um encadeamento e trabalhar com um conjunto de encadeamentos, cada encadeamento bloqueado consumir√° espa√ßo extra.  Bem, h√° cen√°rios em que apenas um thread pode executar determinado trabalho (por exemplo, um thread da interface do usu√°rio).  Consequentemente, eu n√£o gostaria que ele estivesse ocupado com uma tarefa que outro encadeamento possa executar, sacrificando o desempenho de opera√ß√µes exclusivas a ele. <br><br>  A assincronia √© um conceito muito amplo e pode ser alcan√ßado de v√°rias maneiras. <br>  <b>O seguinte pode ser diferenciado no hist√≥rico do .NET</b> : <br><br><ol><li>  EAP (padr√£o ass√≠ncrono baseado em evento) - como o nome indica, a caminhada √© baseada em eventos que s√£o acionados quando a opera√ß√£o √© conclu√≠da e no m√©todo usual que chama essa opera√ß√£o </li><li>  APM (Modelo de Programa√ß√£o Ass√≠ncrona) - baseado em 2 m√©todos.  O m√©todo BeginSmth retorna a interface IAsyncResult.  O m√©todo EndSmth aceita IAsyncResult (se a opera√ß√£o n√£o for conclu√≠da no momento em que EndSmth for chamado, o encadeamento ser√° bloqueado) </li><li>  TAP (padr√£o ass√≠ncrono baseado em tarefas) √© o mesmo ass√≠ncrono / espera (estritamente falando, essas palavras apareceram ap√≥s a abordagem e os tipos tarefa e tarefa &lt;TResult&gt; apareceram, mas async / wait melhorou significativamente esse conceito) </li></ol><br>  A √∫ltima abordagem foi t√£o bem-sucedida que todos se esqueceram das anteriores.  Ent√£o, ser√° sobre ele. <br><a name="tap_syntax"></a><br><h2>  Padr√£o ass√≠ncrono baseado em tarefas.  Condi√ß√µes de sintaxe e compila√ß√£o </h2><br>  O m√©todo ass√≠ncrono padr√£o do estilo TAP √© muito f√°cil de escrever. <br><br>  <b>Para fazer isso, voc√™ precisa</b> : <br><br><ol><li>  Para que o valor de retorno seja Tarefa, Tarefa &lt;T&gt; ou nula (n√£o recomendado, discutido posteriormente).  No C # 7, surgiram os tipos de tarefas (discutidos no cap√≠tulo anterior).  No C # 8, IAsyncEnumerable &lt;T&gt; e IAsyncEnumerator &lt;T&gt; s√£o adicionados a esta lista. </li><li>  Para que o m√©todo seja marcado com a palavra-chave ass√≠ncrona e contenha aguardar dentro.  Essas palavras-chave est√£o emparelhadas.  Al√©m disso, se o m√©todo contiver aguardar, marque-o como ass√≠ncrono, o contr√°rio n√£o √© verdadeiro, mas √© in√∫til </li><li>  Por dec√™ncia, respeite a conven√ß√£o de sufixo Async.  Obviamente, o compilador n√£o considerar√° isso um erro.  Se voc√™ √© um desenvolvedor decente, pode adicionar sobrecargas com um CancellationToken (discutido no cap√≠tulo anterior) </li></ol><br>  Para esses m√©todos, o compilador faz um trabalho s√©rio.  E eles se tornam completamente irreconhec√≠veis nos bastidores, mas mais sobre isso mais tarde. <br><br>  Foi mencionado que o m√©todo deve conter a palavra-chave wait.  Ele (a palavra) indica a necessidade de espera ass√≠ncrona para a tarefa ser executada, que √© o objeto da tarefa ao qual √© aplicada. <br><br>  <b>O objeto de tarefa tamb√©m possui determinadas condi√ß√µes para que o aguardar possa ser aplicado a ele:</b> <br><br><ol><li>  O tipo esperado deve ter um m√©todo p√∫blico (ou interno) GetAwaiter (), tamb√©m pode ser um m√©todo de extens√£o.  Este m√©todo retorna um objeto de espera. </li><li>  O objeto de espera deve implementar a interface INotifyCompletion, que requer a implementa√ß√£o do m√©todo nulo OnCompleted (continua√ß√£o da a√ß√£o).  Tamb√©m deve ter a propriedade da inst√¢ncia bool IsCompleted, o m√©todo GetResult () nulo.  Pode ser uma estrutura ou uma classe. </li></ol><br>  O exemplo abaixo mostra como fazer um int esperado, e mesmo nunca executado. <br><br><div class="spoiler">  <b class="spoiler_title">Extens√£o int</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WeirdExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnyTypeAwaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAwaiter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnyTypeAwaiter(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnyTypeAwaiter</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyCompletion</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCompleted =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action continuation</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } }</code> </pre> <br></div></div><br><a name="tap_progr"></a><br><h2>  Trabalhar com TAP </h2><br>  √â dif√≠cil entrar na selva sem entender como algo deve funcionar.  Considere a TAP em termos de comportamento do programa. <br><br>  Em terminologia: o m√©todo ass√≠ncrono em quest√£o, cujo c√≥digo ser√° considerado, chamarei o <b>m√©todo ass√≠ncrono</b> e os m√©todos ass√≠ncronos chamados dentro dele, chamarei a <b>opera√ß√£o ass√≠ncrona</b> . <br><br>  Vamos dar o exemplo mais simples: como opera√ß√£o ass√≠ncrona, usamos Task.Delay, que atrasa o tempo especificado sem bloquear o fluxo. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayOperationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { BeforeCall(); Task task = Task.Delay(1000); //  AfterCall(); await task; AfterAwait(); }</span></span></span></span></code> </pre><br>  A execu√ß√£o do m√©todo em termos de comportamento √© a seguinte. <br><br><ol><li>  Todo o c√≥digo que precede a chamada da opera√ß√£o ass√≠ncrona √© executado.  Nesse caso, esse √© o m√©todo <i>BeforeCall</i> </li><li>  Uma chamada de opera√ß√£o ass√≠ncrona est√° em andamento.  Nesta fase, o encadeamento n√£o √© liberado ou bloqueado.  Esta opera√ß√£o retorna o resultado - o objeto de tarefa mencionado (geralmente Tarefa), que √© armazenado em uma vari√°vel local </li><li>  O c√≥digo √© executado depois de chamar a opera√ß√£o ass√≠ncrona, mas antes de esperar (aguardar).  No exemplo - <i>AfterCall</i> </li><li>  Aguardando conclus√£o no objeto de tarefa (que √© armazenado em uma vari√°vel local) - aguarda tarefa. <br><br>  Se a opera√ß√£o ass√≠ncrona for conclu√≠da neste momento, a execu√ß√£o continuar√° sincronizada, no mesmo encadeamento. <br><br>  Se a opera√ß√£o ass√≠ncrona n√£o for conclu√≠da, ser√° salvo o c√≥digo que deve ser chamado ap√≥s a conclus√£o da opera√ß√£o ass√≠ncrona (a chamada continua√ß√£o) e o fluxo retornar√° ao conjunto de encadeamentos e ficar√° dispon√≠vel para uso. </li><li>  A execu√ß√£o das opera√ß√µes ap√≥s a espera - <i>AfterAwait</i> - √© executada imediatamente, no mesmo encadeamento, quando a opera√ß√£o no momento da espera foi conclu√≠da ou, ap√≥s a conclus√£o da opera√ß√£o, √© realizado um novo encadeamento que continuar√° (salvo na etapa anterior) </li></ol><br><a name="internals"></a><br><h2>  Nos bastidores.  M√°quina de estado </h2><br>  De fato, nosso m√©todo √© transformado pelo compilador em um m√©todo stub no qual a classe gerada - a m√°quina de estado - √© inicializada.  Em seguida, ele (a m√°quina) inicia e o objeto Task usado na etapa 2 √© retornado do m√©todo. <br><br>  De particular interesse √© o m√©todo <i>MoveNext</i> da m√°quina de estado.  Este m√©todo faz o que era antes da convers√£o no m√©todo ass√≠ncrono.  Ele quebra o c√≥digo entre cada chamada em espera.  Cada pe√ßa √© realizada em uma determinada condi√ß√£o da m√°quina.  O pr√≥prio m√©todo <i>MoveNext</i> √© anexado ao objeto de espera como uma continua√ß√£o.  A preserva√ß√£o do estado garante a execu√ß√£o precisamente daquela parte que seguiu logicamente a expectativa. <br><br>  Como se costuma dizer, √© melhor ver 1 vez do que ouvir 100 vezes, por isso recomendo que voc√™ se familiarize com o exemplo abaixo.  Reescrevi o c√≥digo um pouco, aprimorei a nomea√ß√£o de vari√°veis ‚Äã‚Äãe comentei generosamente. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fonte</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">M√©todo de esbo√ßo</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AsyncStateMachine(typeof(DelaysStateMachine))</span></span>] [DebuggerStepThrough] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DelaysStateMachine stateMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelaysStateMachine(); stateMachine.taskMethodBuilder = AsyncTaskMethodBuilder.Create(); stateMachine.currentState = <span class="hljs-number"><span class="hljs-number">-1</span></span>; AsyncTaskMethodBuilder builder = stateMachine.taskMethodBuilder; taskMethodBuilder.Start(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> stateMachine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateMachine.taskMethodBuilder.Task; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">M√°quina de estado</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DelaysStateMachine</span></span> : <span class="hljs-title"><span class="hljs-title">IAsyncStateMachine</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     await   //       await'a public int currentState; public AsyncTaskMethodBuilder taskMethodBuilder; //   private TaskAwaiter taskAwaiter; //  ,             ""  public int paramInt; private int localInt; private void MoveNext() { int num = currentState; try { TaskAwaiter awaiter5; TaskAwaiter awaiter4; TaskAwaiter awaiter3; TaskAwaiter awaiter2; TaskAwaiter awaiter; switch (num) { default: localInt = paramInt; //  await Console.WriteLine(1); //  await awaiter5 = Task.Delay(1000).GetAwaiter(); //  await if (!awaiter5.IsCompleted) //  await. ,    { num = (currentState = 0); // ,      taskAwaiter = awaiter5; //    ,        DelaysStateMachine stateMachine = this; //    taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter5, ref stateMachine); //                 return; } goto Il_AfterFirstAwait; //  ,   ,    case 0: //            ,        .   ,          awaiter5 = taskAwaiter; //   taskAwaiter = default(TaskAwaiter); //   num = (currentState = -1); //  goto Il_AfterFirstAwait; //       case 1: //  ,      ,    ,     . awaiter4 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterSecondAwait; case 2: // ,     . awaiter3 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterThirdAwait; case 3: //    awaiter2 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterFourthAwait; case 4: //    { awaiter = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); break; } Il_AfterFourthAwait: awaiter2.GetResult(); Console.WriteLine(5); //     awaiter = Task.Delay(1000).GetAwaiter(); //   if (!awaiter.IsCompleted) { num = (currentState = 4); taskAwaiter = awaiter; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); return; } break; Il_AfterFirstAwait: //  ,        awaiter5.GetResult(); //       Console.WriteLine(2); //  ,     await awaiter4 = Task.Delay(1000).GetAwaiter(); //    if (!awaiter4.IsCompleted) { num = (currentState = 1); taskAwaiter = awaiter4; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter4, ref stateMachine); return; } goto Il_AfterSecondAwait; Il_AfterThirdAwait: awaiter3.GetResult(); Console.WriteLine(4); //     awaiter2 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter2.IsCompleted) { num = (currentState = 3); taskAwaiter = awaiter2; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine); return; } goto Il_AfterFourthAwait; Il_AfterSecondAwait: awaiter4.GetResult(); Console.WriteLine(3); //     awaiter3 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter3.IsCompleted) { num = (currentState = 2); taskAwaiter = awaiter3; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter3, ref stateMachine); return; } goto Il_AfterThirdAwait; } awaiter.GetResult(); } catch (Exception exception) { currentState = -2; taskMethodBuilder.SetException(exception); return; } currentState = -2; taskMethodBuilder.SetResult(); //    ,   ,       } void IAsyncStateMachine.MoveNext() {...} [DebuggerHidden] private void SetStateMachine(IAsyncStateMachine stateMachine) {...} void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine) {...} }</span></span></code> </pre><br></div></div><br>  Eu me concentro na frase "neste momento n√£o foi executado de forma s√≠ncrona".  Uma opera√ß√£o ass√≠ncrona tamb√©m pode seguir um caminho de execu√ß√£o s√≠ncrona.  A principal condi√ß√£o para o atual m√©todo ass√≠ncrono a ser executado de forma s√≠ncrona, ou seja, sem alterar o encadeamento, √© a conclus√£o da opera√ß√£o ass√≠ncrona no momento da verifica√ß√£o <i>IsCompleted</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Este exemplo demonstra claramente esse comportamento.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment"><span class="hljs-comment">//1 Task task = Task.Delay(1000); Thread.Sleep(1700); await task; Console.WriteLine(Thread.CurrentThread.ManagedThreadId); //1 }</span></span></code> </pre><br></div></div><br>  Sobre o contexto de sincroniza√ß√£o.  O m√©todo <i>AwaitUnsafeOnCompleted</i> usado na m√°quina resulta em uma chamada para o m√©todo <i>Task.SetContinuationForAwait</i> .  Nesse m√©todo, o contexto de sincroniza√ß√£o atual <i>SynchronizationContext.Current</i> √© recuperado.  O contexto de sincroniza√ß√£o pode ser interpretado como um tipo de fluxo.  Se tamb√©m for espec√≠fico (por exemplo, o contexto do encadeamento da interface do usu√°rio), uma continua√ß√£o ser√° criada usando a classe <i>SynchronizationContextAwaitTaskContinuation</i> .  Essa classe para iniciar a continua√ß√£o chama o m√©todo Post no contexto salvo, o que garante que a continua√ß√£o seja executada no contexto exato em que o m√©todo foi executado.  A l√≥gica espec√≠fica para executar a continua√ß√£o depende do m√©todo <i>Post</i> em um contexto que, para dizer o m√≠nimo, n√£o √© conhecido pela velocidade.  Se n√£o houve contexto de sincroniza√ß√£o (ou foi indicado que n√£o nos importa em que contexto a execu√ß√£o continuar√° usando o ConfigureAwait (false), que ser√° discutido no cap√≠tulo anterior), a continua√ß√£o ser√° realizada pelo encadeamento do pool. <br><a name="libs"></a><br><h2>  As origens da assincronia.  Os m√©todos ass√≠ncronos padr√£o do dispositivo </h2><br>  Vimos como um m√©todo usando ass√≠ncrono e aguarda a apar√™ncia e o que acontece nos bastidores.  Esta informa√ß√£o n√£o √© incomum.  Mas √© importante entender a natureza das opera√ß√µes ass√≠ncronas.  Porque, como vimos na m√°quina de estado, opera√ß√µes ass√≠ncronas s√£o chamadas no c√≥digo, a menos que o resultado seja processado de maneira mais esperta.  No entanto, o que acontece dentro das pr√≥prias opera√ß√µes ass√≠ncronas?  Provavelmente o mesmo, mas isso n√£o pode acontecer ad infinitum. <br><br>  Uma tarefa importante √© entender a natureza da assincronia.  Ao tentar entender a assincronia, h√° uma altern√¢ncia de estados "agora claros" e "agora novamente incompreens√≠veis".  E essa altern√¢ncia ocorrer√° at√© que a fonte da assincronia seja entendida. <br><br>  Ao trabalhar com assincronia, operamos em tarefas.  Isso n√£o √© o mesmo que um fluxo.  Uma tarefa pode ser executada por v√°rios threads, e um thread pode executar muitas tarefas. <br><br>  A assincronia geralmente come√ßa com um m√©todo que retorna a tarefa (por exemplo), mas n√£o √© marcada com async e, portanto, n√£o usa aguardar por dentro.  Este m√©todo n√£o tolera nenhuma altera√ß√£o do compilador, √© executado como est√°. <br><br>  <b>Ent√£o, vamos olhar para algumas das ra√≠zes da assincronia.</b> <br><br><ol><li>  Task.Run, new Task (..). Start (), Factory.StartNew e similares.  A maneira mais f√°cil de iniciar a execu√ß√£o ass√≠ncrona.  Esses m√©todos simplesmente criam um novo objeto de tarefa, passando um delegado como um dos par√¢metros.  A tarefa √© transferida para o planejador, o que permite que ela seja executada por um dos encadeamentos no conjunto.  A tarefa finalizada que pode ser esperada √© retornada.  Normalmente, essa abordagem √© usada para iniciar a computa√ß√£o (ligada √† CPU) em um encadeamento separado. </li><li>  TaskCompletionSource.  Uma classe auxiliar que ajuda a controlar o objeto da tarefa.  Projetado para aqueles que n√£o podem alocar um delegado para implementa√ß√£o e usa mecanismos mais sofisticados para controlar a conclus√£o.  Possui uma API muito simples - SetResult, SetError, etc., que atualiza a tarefa de acordo.  Esta tarefa est√° dispon√≠vel atrav√©s da propriedade Task.  Talvez por dentro voc√™ crie threads, tenha uma l√≥gica complexa para sua intera√ß√£o ou conclus√£o por evento.  Um pouco mais de detalhes sobre essa classe estar√£o na √∫ltima se√ß√£o. </li></ol><br>  Em um par√°grafo adicional, voc√™ pode criar os m√©todos de bibliotecas padr√£o.  Isso inclui arquivos de leitura / grava√ß√£o, trabalho com uma rede e similares.  Como regra, esses m√©todos populares e comuns usam chamadas de sistema que variam em plataformas diferentes, e seu dispositivo √© extremamente divertido.  Considere trabalhar com arquivos e a rede. <br><br><h3>  Arquivos </h3><br>  Uma observa√ß√£o importante - se voc√™ quiser trabalhar com arquivos, dever√° especificar useAsync = true ao criar o FileStream. <br><br>  Tudo √© organizado em arquivos de maneira n√£o trivial e confusa.  A classe FileStream √© declarada como parcial.  Al√©m disso, existem mais 6 complementos espec√≠ficos da plataforma.  Portanto, no Unix, o acesso ass√≠ncrono a um arquivo arbitr√°rio, como regra, usa uma opera√ß√£o s√≠ncrona em um encadeamento separado.  No Windows, h√° chamadas de sistema para opera√ß√£o ass√≠ncrona, as quais, √© claro, s√£o usadas.  Isso leva a diferen√ßas no trabalho em diferentes plataformas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes</a> . <br><br>  <b>Unix</b> <br><br>  O comportamento padr√£o ao escrever ou ler √© executar a opera√ß√£o de forma s√≠ncrona, se o buffer permitir e o fluxo n√£o estiver ocupado com outra opera√ß√£o: <br><br>  1. O fluxo n√£o est√° ocupado com outra opera√ß√£o <br><br>  A classe Filestream possui um objeto herdado de SemaphoreSlim com os par√¢metros (1, 1) - ou seja, uma se√ß√£o cr√≠tica - o fragmento de c√≥digo protegido por esse sem√°foro pode ser executado por apenas um encadeamento por vez.  Esse sem√°foro √© usado tanto para leitura quanto para escrita.  Ou seja, √© imposs√≠vel produzir simultaneamente leitura e escrita.  Nesse caso, o bloqueio no sem√°foro n√£o ocorre.  O m√©todo this._asyncState.WaitAsync () √© chamado nele, que retorna o objeto da tarefa (n√£o h√° bloqueio ou espera, seria se a palavra-chave wait for aplicada ao resultado do m√©todo).  Se esse objeto de tarefa n√£o for conclu√≠do - ou seja, o sem√°foro for capturado, a continua√ß√£o (Task.ContinueWith) na qual a opera√ß√£o √© executada ser√° anexada ao objeto de espera retornado.  Se o objeto estiver livre, voc√™ precisar√° verificar o seguinte <br><br>  2. O buffer permite <br><br>  Aqui o comportamento j√° depende da natureza da opera√ß√£o. <br><br>  Para grava√ß√£o - verifica-se que o tamanho dos dados para escrever + posi√ß√£o no arquivo √© menor que o tamanho do buffer, que por padr√£o √© 4096 bytes.  Ou seja, devemos escrever 4096 bytes desde o in√≠cio, 2048 bytes com um deslocamento de 2048 e assim por diante.  Se for esse o caso, a opera√ß√£o √© realizada de forma s√≠ncrona, caso contr√°rio, a continua√ß√£o √© anexada (Task.ContinueWith).  A sequela usa uma chamada s√≠ncrona regular do sistema.  Quando o buffer est√° cheio, ele √© gravado no disco de forma s√≠ncrona. <br>  Para leitura - √© verificado se h√° dados suficientes no buffer para retornar todos os dados necess√°rios.  Caso contr√°rio, novamente, uma continua√ß√£o (Task.ContinueWith) com uma chamada de sistema s√≠ncrona. <br><br>  A prop√≥sito, h√° um detalhe interessante.  Se um dado ocupar o buffer inteiro, eles ser√£o gravados diretamente no arquivo, sem a participa√ß√£o do buffer.  Ao mesmo tempo, h√° uma situa√ß√£o em que haver√° mais dados do que o tamanho do buffer, mas todos passar√£o por ele.  Isso acontece se j√° houver algo no buffer.  Em seguida, nossos dados ser√£o divididos em 2 partes, uma preencher√° o buffer at√© o final e os dados ser√£o gravados no arquivo, o segundo ser√° gravado no buffer se ele entrar nele ou diretamente no arquivo se n√£o o fizer.  Portanto, se criarmos um fluxo e gravar 4097 bytes nele, eles aparecer√£o imediatamente no arquivo, sem chamar Dispose.  Se escrevermos 4095, nada estar√° no arquivo. <br><br>  <b>Windows</b> <br><br>  No Windows, o algoritmo para usar o buffer e gravar diretamente √© muito semelhante.  Mas uma diferen√ßa significativa √© observada diretamente nas chamadas de grava√ß√£o e leitura do sistema ass√≠ncrono.  Falando sem se aprofundar nas chamadas do sistema, existe uma estrutura sobreposta.  Ele tem um campo importante para n√≥s - HANDLE hEvent.  Este √© um evento de redefini√ß√£o manual que entra em estado de alarme ap√≥s a conclus√£o de uma opera√ß√£o.  Voltar para a implementa√ß√£o.  Gravando diretamente, assim como gravando no buffer, use chamadas ass√≠ncronas do sistema, que usam a estrutura acima como par√¢metro.  Ao gravar, um objeto FileStreamCompletionSource √© criado - um herdeiro de TaskCompletionSource, no qual IOCallback √© especificado.  √â chamado por encadeamento livre do pool quando a opera√ß√£o √© conclu√≠da.  No retorno de chamada, a estrutura Sobreposta √© analisada e o objeto Tarefa √© atualizado de acordo.  Isso √© tudo m√°gico. <br><br><h3>  Rede </h3><br>  √â dif√≠cil descrever tudo o que vi entendendo a fonte.  Meu caminho estava de HttpClient para Socket e SocketAsyncContext for Unix.  O esquema geral √© o mesmo que com os arquivos.  Para Windows, a estrutura Sobreposta mencionada √© usada e a opera√ß√£o √© executada de forma ass√≠ncrona.  No Unix, as opera√ß√µes de rede tamb√©m usam fun√ß√µes de retorno de chamada. <br><br>  E uma pequena explica√ß√£o.  Um leitor atento perceber√° que, ao usar chamadas ass√≠ncronas entre uma chamada e um retorno de chamada, existe um certo vazio que, de alguma forma, funciona com os dados.  Aqui vale a pena esclarecer a integridade.  No exemplo de arquivos, o controlador de disco realiza opera√ß√µes diretas com o disco pelo controlador de disco, √© ele quem d√° os sinais sobre como mover as cabe√ßas para o setor desejado, etc.  O processador est√° livre no momento.  A comunica√ß√£o com o disco ocorre atrav√©s das portas de entrada / sa√≠da.  Eles indicam o tipo de opera√ß√£o, a localiza√ß√£o dos dados no disco, etc.  Em seguida, o controlador e o disco est√£o envolvidos nessa opera√ß√£o e, ap√≥s a conclus√£o do trabalho, geram uma interrup√ß√£o.  Por conseguinte, uma chamada de sistema ass√≠ncrona apenas contribui com informa√ß√µes para as portas de entrada / sa√≠da, enquanto a chamada s√≠ncrona tamb√©m espera pelos resultados, colocando o fluxo em um estado de bloqueio.  Esse esquema n√£o pretende ser absolutamente preciso (n√£o sobre este artigo), mas fornece uma compreens√£o conceitual do trabalho. <br><br>  Agora a natureza do processo est√° clara.  Mas algu√©m pode perguntar, o que fazer com a assincronia?  √â imposs√≠vel escrever de forma ass√≠ncrona sobre um m√©todo para sempre. <br><br>  Primeiro de tudo.  Um aplicativo pode ser feito como um servi√ßo.  Nesse caso, o ponto de entrada - Principal - √© gravado do zero por voc√™.  At√© recentemente, o Main n√£o podia ser ass√≠ncrono; na vers√£o 7 do idioma, esse recurso foi adicionado.  Mas isso n√£o muda nada radicalmente, apenas o compilador gera o Main comum e, a partir do ass√≠ncrono, apenas um m√©todo est√°tico √© feito, chamado Main e sua conclus√£o √© esperada de forma s√≠ncrona.  Ent√£o, provavelmente voc√™ tem algumas a√ß√µes duradouras.  Por alguma raz√£o, neste momento, muitas pessoas come√ßam a pensar em como criar threads para esse neg√≥cio: por meio de Task, ThreadPool ou Thread em geral manualmente, porque deve haver uma diferen√ßa em alguma coisa.  A resposta √© simples - √© claro Tarefa.  Se voc√™ usar a abordagem TAP, n√£o interfira na cria√ß√£o manual de threads.  Isso √© semelhante ao uso do HttpClient para quase todas as solicita√ß√µes, e o POST √© feito de forma independente por meio do Socket. <br><br>  Em segundo lugar.  Aplica√ß√µes web.  Cada solicita√ß√£o de entrada faz com que um novo thread seja extra√≠do do ThreadPool para processamento.  A piscina, √© claro, √© grande, mas n√£o infinita.  No caso de haver muitas solicita√ß√µes, talvez n√£o haja threads suficientes e todas as novas solicita√ß√µes ser√£o colocadas em fila para processamento.  Essa situa√ß√£o √© chamada de fome.  Mas, no caso de usar controladores ass√≠ncronos, conforme discutido anteriormente, o fluxo retorna ao pool e pode ser usado para processar novas solicita√ß√µes.  Assim, a taxa de transfer√™ncia do servidor √© significativamente aumentada. <br><br>  Observamos o processo ass√≠ncrono desde o in√≠cio at√© o fim.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E armados com uma compreens√£o de toda essa assincronia, que contradiz a natureza humana, consideraremos alguns truques √∫teis ao trabalhar com c√≥digo ass√≠ncrono. </font></font><br><a name="api"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes e truques √∫teis ao trabalhar com a TAP </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A diversidade est√°tica da classe Task. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A classe Task possui v√°rios m√©todos est√°ticos √∫teis. </font><font style="vertical-align: inherit;">Abaixo est√£o os principais.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAny (..) - combinator, aceita IEnumerable / params de objetos de tarefa e retorna um objeto de tarefa que ser√° conclu√≠do quando a primeira tarefa conclu√≠da. </font><font style="vertical-align: inherit;">Ou seja, permite aguardar uma das v√°rias tarefas em execu√ß√£o</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task.WhenAll (..) - combinador, aceita IEnumerable / params de objetos de tarefa e retorna um objeto de tarefa, que ser√° conclu√≠do ap√≥s a conclus√£o de todas as tarefas transferidas </font></font></li><li> Task.FromResult&lt;T&gt;(T value) ‚Äî    ,    .          </li><li> Task.Delay(..) ‚Äî     </li><li> Task.Yield() ‚Äî  .   ,      .  ,    ,      </li></ol><br><h3> ConfigureAwait </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturalmente, o recurso "avan√ßado" mais popular. Este m√©todo pertence √† classe Task e permite especificar se precisamos continuar no mesmo contexto em que a opera√ß√£o ass√≠ncrona foi chamada. Por padr√£o, sem usar esse m√©todo, o contexto √© lembrado e continuado nele, usando o m√©todo Post mencionado. No entanto, como dissemos, o Post √© um prazer muito caro. Portanto, se o desempenho estiver em primeiro lugar e vermos que a continua√ß√£o n√£o atualizar√°, por exemplo, a interface do usu√°rio, voc√™ poder√° especific√°-la no objeto de espera </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.ConfigureAwait (false)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso significa que n√£o importa para n√≥s onde a continua√ß√£o ser√° realizada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora sobre o problema. Como se costuma dizer, assustador n√£o √© ignor√¢ncia, mas conhecimento falso.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De alguma forma, observei o c√≥digo de um aplicativo da Web, onde cada chamada ass√≠ncrona era decorada com esse acelerador. </font><font style="vertical-align: inherit;">Isso n√£o tem outro efeito sen√£o nojo visual. </font><font style="vertical-align: inherit;">O aplicativo Web padr√£o do ASP.NET Core n√£o possui contextos exclusivos (a menos que voc√™ os escreva, √© claro). </font><font style="vertical-align: inherit;">Portanto, o m√©todo Post n√£o √© chamado l√° de qualquer maneira.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskCompletionSource &lt;T&gt; </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma classe que facilita o gerenciamento de um objeto Tarefa. </font><font style="vertical-align: inherit;">Uma classe tem amplas oportunidades, mas √© mais √∫til quando queremos agrupar uma tarefa com uma a√ß√£o, cujo final ocorre em um evento. </font><font style="vertical-align: inherit;">Em geral, a classe foi criada para adaptar m√©todos ass√≠ncronos antigos √† TAP, mas, como vimos, ela √© usada n√£o apenas para isso. </font><font style="vertical-align: inherit;">Um pequeno exemplo de trabalho com esta classe:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Exemplo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); FileSystemWatcher watcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemWatcher { Path = Directory.GetCurrentDirectory(), NotifyFilter = NotifyFilters.LastAccess, EnableRaisingEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; watcher.Changed += (o, e) =&gt; tcs.SetResult(e.FullPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tcs.Task; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa classe cria um wrapper ass√≠ncrono para obter o nome do arquivo que foi acessado na pasta atual. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CancellationTokenSource </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permite cancelar uma opera√ß√£o ass√≠ncrona. </font><font style="vertical-align: inherit;">O esquema geral se assemelha ao uso de um TaskCompletionSource. </font><font style="vertical-align: inherit;">Primeiro, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© criado var cts = new CancellationTokenSource ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que, a prop√≥sito, √© IDisposable, depois </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© passado para opera√ß√µes ass√≠ncronas </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al√©m disso, seguindo alguma l√≥gica sua, sob certas condi√ß√µes, o m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Cancel ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© </font><i><font style="vertical-align: inherit;">chamado</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tamb√©m pode se inscrever em um evento ou qualquer outra coisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma boa pr√°tica. </font><font style="vertical-align: inherit;">Ao escrever seu m√©todo ass√≠ncrono que funciona em segundo plano, digamos que em um tempo infinito, voc√™ pode simplesmente inserir uma linha no corpo do loop: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancelellationToken.ThrowIfCancellationRequested ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que gerar√° uma exce√ß√£o</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Essa exce√ß√£o √© tratada como um cancelamento da opera√ß√£o e n√£o √© salva como uma exce√ß√£o dentro do objeto de tarefa. </font><font style="vertical-align: inherit;">Al√©m disso, a propriedade </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCanceled</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no objeto Task se tornar√° verdadeira.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longrunning </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitas vezes, existem situa√ß√µes, especialmente ao escrever servi√ßos, quando voc√™ cria v√°rias tarefas que funcionam durante toda a vida √∫til do servi√ßo ou apenas por um per√≠odo muito longo. </font><font style="vertical-align: inherit;">Como lembramos, o uso de um conjunto de encadeamentos √© justamente a sobrecarga da cria√ß√£o de um encadeamento. </font><font style="vertical-align: inherit;">No entanto, se um fluxo raramente for criado (mesmo uma vez por hora), esses custos ser√£o nivelados e voc√™ poder√° criar fluxos separados com seguran√ßa. </font><font style="vertical-align: inherit;">Para fazer isso, ao criar uma tarefa, voc√™ pode especificar uma op√ß√£o especial: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Factory.StartNew (action, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCreationOptions.LongRunning</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De qualquer forma, recomendo que voc√™ analise toda a sobrecarga de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task.Factory.StartNew</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , existem v√°rias maneiras de configurar a tarefa de maneira flex√≠vel para atender a necessidades espec√≠ficas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exce√ß√µes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido √† natureza n√£o determin√≠stica da execu√ß√£o ass√≠ncrona de c√≥digo, a quest√£o das exce√ß√µes √© muito relevante. Seria uma pena se voc√™ n√£o pudesse capturar a exce√ß√£o e ela foi lan√ßada no segmento esquerdo, interrompendo o processo. Uma classe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> foi criada para capturar uma exce√ß√£o em um thread e lan√ß√°-lo nele </font><font style="vertical-align: inherit;">. Para capturar a exce√ß√£o, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© usado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o m√©todo est√°tico </font><i><font style="vertical-align: inherit;">ExceptionDispatchInfo.Capture (ex), que</font></i><font style="vertical-align: inherit;"> retorna </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um link para esse objeto pode ser passado para qualquer thread, que chama o m√©todo Throw () para jog√°-lo fora. </font><font style="vertical-align: inherit;">O lan√ßamento em si N√ÉO ocorre no local da chamada de opera√ß√£o ass√≠ncrona, mas no local de uso do operador aguardar. </font><font style="vertical-align: inherit;">E como voc√™ sabe, aguardar n√£o pode ser aplicado ao vazio. </font><font style="vertical-align: inherit;">Assim, se o contexto existir, ele ser√° passado pelo m√©todo Post. </font><font style="vertical-align: inherit;">Caso contr√°rio, ele ficar√° animado no fluxo da piscina. </font><font style="vertical-align: inherit;">E isso √© quase 100% ol√° ao colapso do aplicativo. </font><font style="vertical-align: inherit;">E aqui chegamos √† pr√°tica do fato de que dever√≠amos usar a Tarefa ou a Tarefa &lt;T&gt;, mas n√£o nulas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E mais uma coisa. </font><font style="vertical-align: inherit;">O planejador possui um evento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler.UnobservedTaskException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que √© acionado quando uma </font><i><font style="vertical-align: inherit;">UnobservedTaskException √©</font></i><font style="vertical-align: inherit;"> lan√ßada</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essa exce√ß√£o √© lan√ßada durante a coleta de lixo quando o GC tenta coletar um objeto de tarefa que possui uma exce√ß√£o n√£o tratada.</font></font><br><br><h3> IAsyncEnumerable </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes do C # 8 e do .NET Core 3.0, n√£o era poss√≠vel usar um iterador de rendimento em um m√©todo ass√≠ncrono, o que complicava a vida e fazia com que ele retornasse a tarefa &lt;IEnumerable &lt;T&gt;&gt; desse m√©todo, ou seja, n√£o havia como iterar a cole√ß√£o at√© que ela fosse totalmente recebida. Agora existe uma oportunidade. Saiba mais </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para isso, o tipo de retorno deve ser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerator &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Para percorrer essa cole√ß√£o, voc√™ deve usar o loop foreach com a palavra-chave wait. Al√©m disso, os m√©todos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithCancellation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podem ser chamados no resultado da opera√ß√£o </font><font style="vertical-align: inherit;">, indicando o CancelationToken usado e a necessidade de continuar no mesmo contexto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esperado, tudo √© feito o mais pregui√ßosamente poss√≠vel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abaixo est√° um exemplo e a conclus√£o que ele d√°.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Exemplo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); IAsyncEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerable = AsyncYielding(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time after calling: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerable.WithCancellation(..).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"element: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> IAsyncEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncYielding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uselessElement <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) { Task task = Task.Delay(TimeSpan.FromSeconds(uselessElement)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Task run: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{uselessElement}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uselessElement; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo ap√≥s a chamada: 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execu√ß√£o da tarefa: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo: 1033 Execu√ß√£o da </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarefa: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo: 3034 Execu√ß√£o da </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tarefa: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempo: 6035</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Threadpool </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta classe √© usada ativamente ao programar com TAP. Portanto, darei os detalhes m√≠nimos de sua implementa√ß√£o. Por dentro, o ThreadPool tem uma matriz de filas: uma para cada thread + uma global. Ao adicionar um novo trabalho ao pool, o encadeamento que iniciou a adi√ß√£o √© levado em considera√ß√£o. Se for um encadeamento do pool, o trabalho ser√° colocado em sua pr√≥pria fila para esse encadeamento, se houver outro encadeamento - no global. Quando um segmento √© selecionado para funcionar, sua fila local √© exibida pela primeira vez. Se estiver vazio, o encadeamento recebe trabalhos do global. Se estiver vazio, come√ßa a roubar dos outros. Al√©m disso, voc√™ nunca deve confiar na ordem do trabalho, porque, de fato, n√£o h√° ordem. O n√∫mero padr√£o de threads em um pool depende de muitos fatores, incluindo o tamanho do espa√ßo de endere√ßo. Se houver mais pedidos de execu√ß√£o,al√©m do n√∫mero de threads dispon√≠veis, os pedidos s√£o enfileirados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os encadeamentos em um conjunto de encadeamentos s√£o encadeamentos em segundo plano (propriedade isBackground = true). </font><font style="vertical-align: inherit;">Esse tipo de encadeamento n√£o suporta a vida √∫til do processo se todos os encadeamentos em primeiro plano foram conclu√≠dos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O encadeamento do sistema monitora o status da al√ßa de espera. </font><font style="vertical-align: inherit;">Quando a opera√ß√£o de espera termina, o retorno de chamada transferido √© executado pelo encadeamento do pool (lembre-se dos arquivos no Windows).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipo de tarefa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencionado anteriormente, esse tipo (estrutura ou classe) pode ser usado como o valor de retorno do m√©todo ass√≠ncrono. </font><font style="vertical-align: inherit;">Um tipo de construtor deve ser associado a esse tipo usando o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo [AsyncMethodBuilder (..)]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esse tipo deve ter as caracter√≠sticas mencionadas acima para poder aplicar a palavra-chave wait. </font><font style="vertical-align: inherit;">Pode ser parametrizado para m√©todos que n√£o retornam um valor e parametrizado para aqueles que retornam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pr√≥prio construtor √© uma classe ou estrutura cuja estrutura √© mostrada no exemplo abaixo. </font><font style="vertical-align: inherit;">O m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possui um par√¢metro do tipo T para um tipo de tarefa parametrizado por T. Para tipos n√£o parametrizados, o m√©todo n√£o possui par√¢metros.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface do Construtor Necess√°ria</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTaskMethodBuilder</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyTaskMethodBuilder&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStateMachine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncStateMachine stateMachine</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T result</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : INotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : ICriticalNotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyTask&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O princ√≠pio do trabalho do ponto de vista da escrita do seu tipo Tarefa ser√° descrito abaixo. A maior parte disso j√° foi descrita ao analisar o c√≥digo gerado pelo compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O compilador usa todos esses tipos para gerar uma m√°quina de estado. O compilador sabe quais construtores usar para os tipos que conhece, aqui especificamos o que ser√° usado durante a gera√ß√£o do c√≥digo. Se a m√°quina de estado for uma estrutura, ela ser√° compactada ao chamar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetStateMachine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o construtor poder√° armazenar em cache a c√≥pia compactada, se necess√°rio. O construtor deve chamar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou depois de ser chamado para iniciar a execu√ß√£o e avan√ßar a m√°quina de estado. Ap√≥s chamar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a propriedade Task ser√° retornada do m√©todo Eu recomendo que voc√™ retorne ao m√©todo stub e veja essas etapas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a m√°quina de estados for conclu√≠da com √™xito, o m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√° </font><i><font style="vertical-align: inherit;">chamado</font></i><font style="vertical-align: inherit;"> , caso contr√°rio, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se a m√°quina de estado chegar em espera, o m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetAwaiter ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">tipo tarefa </font><font style="vertical-align: inherit;">√© executado </font><font style="vertical-align: inherit;">. Se o objeto wait implementar a interface </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICriticalNotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e IsCompleted = false, a m√°quina de estado utilizar√° o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitUnsafeOnCompleted (ref wait, ref stateMachine)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve chamar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waititer.OnCompleted (action)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a a√ß√£o deve chamar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando o objeto de espera for conclu√≠do. </font><font style="vertical-align: inherit;">Da mesma forma, para a interface </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o m√©todo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como usar isso √© com voc√™. </font><font style="vertical-align: inherit;">Mas eu aconselho voc√™ a pensar 514 vezes antes de aplicar isso na produ√ß√£o, e n√£o para mimar. </font><font style="vertical-align: inherit;">A seguir, √© apresentado um exemplo de uso. </font><font style="vertical-align: inherit;">Esbocei apenas um proxy para um construtor padr√£o que exibe no console qual m√©todo foi chamado e a que horas. </font><font style="vertical-align: inherit;">A prop√≥sito, o Main () ass√≠ncrono n√£o deseja oferecer suporte a um tipo de espera personalizado (acredito que mais de um projeto de produ√ß√£o foi irremediavelmente corrompido devido a essa falha da Microsoft). </font><font style="vertical-align: inherit;">Se desejar, voc√™ pode modificar o logger proxy usando um logger normal e registrando mais informa√ß√µes.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarefa de proxy de log</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Start"</span></span>); JustMethod().Task.Wait(); <span class="hljs-comment"><span class="hljs-comment">//   Console.WriteLine("Stop"); } public static async LogTask JustMethod() { await DelayWrapper(1000); } public static LogTask DelayWrapper(int milliseconds) =&gt; new LogTask { Task = Task.Delay(milliseconds)}; } [AsyncMethodBuilder(typeof(LogMethodBuilder))] public class LogTask { public Task Task { get; set; } public TaskAwaiter GetAwaiter() =&gt; Task.GetAwaiter(); } public class LogMethodBuilder { private AsyncTaskMethodBuilder _methodBuilder = AsyncTaskMethodBuilder.Create(); private LogTask _task; public static LogMethodBuilder Create() { Console.WriteLine($"Method: Create; {DateTime.Now :O}"); return new LogMethodBuilder(); } public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: Start; {DateTime.Now :O}"); _methodBuilder.Start(ref stateMachine); } public void SetStateMachine(IAsyncStateMachine stateMachine) { Console.WriteLine($"Method: SetStateMachine; {DateTime.Now :O}"); _methodBuilder.SetStateMachine(stateMachine); } public void SetException(Exception exception) { Console.WriteLine($"Method: SetException; {DateTime.Now :O}"); _methodBuilder.SetException(exception); } public void SetResult() { Console.WriteLine($"Method: SetResult; {DateTime.Now :O}"); _methodBuilder.SetResult(); } public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine); } public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitUnsafeOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); } public LogTask Task { get { Console.WriteLine($"Property: Task; {DateTime.Now :O}"); return _task ??= new LogTask {Task = _methodBuilder.Task}; } set =&gt; _task = value; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iniciar </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo: Criar; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7152733 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo: Iniciar; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7262226 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo: AwaitUnsafeOnCompleted; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7275206 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade: tarefa; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7292005 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo: SetResult; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 14.7297967 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stop</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √â tudo, obrigado a todos.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470830/">https://habr.com/ru/post/pt470830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470820/index.html">Um teste r√°pido de dezenas de hip√≥teses: como sa√≠mos da rotina e discutimos em outra cidade</a></li>
<li><a href="../pt470822/index.html">Monitoramento de temperatura na empresa</a></li>
<li><a href="../pt470824/index.html">Di√°logos Prometidos</a></li>
<li><a href="../pt470826/index.html">Mineiros, diversificadores e cobalto: como fornecemos aos clientes acesso seguro √† Internet</a></li>
<li><a href="../pt470828/index.html">Lista vinculada do Python: Gatos em caixas</a></li>
<li><a href="../pt470834/index.html">Modelos de superinfec√ß√£o, antibi√≥ticos e apocalipse zumbi</a></li>
<li><a href="../pt470838/index.html">Seguran√ßa de cont√™iner no CI / CD</a></li>
<li><a href="../pt470844/index.html">O novo projeto dos irm√£os Durov: Telegram Open Network</a></li>
<li><a href="../pt470852/index.html">Processando 40 TB de c√≥digo de 10 milh√µes de projetos em um servidor dedicado com Go por US $ 100</a></li>
<li><a href="../pt470856/index.html">Telegram GRAM Wallet: termos de servi√ßo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>