<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎺 🧔🏽 🌔 Tetapi esensinya adalah sesuatu, atau Meminimalkan kode sumber lebih mudah daripada kedengarannya. 🤚🏻 🛃 👨‍❤️‍💋‍👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam hari-hari Januari yang indah ini, kita semua, tentu saja, prihatin dengan masalah meminimalkan kode sumber sambil mempertahankan yang lain. Maks...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tetapi esensinya adalah sesuatu, atau Meminimalkan kode sumber lebih mudah daripada kedengarannya.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482634/"><img src="https://habrastorage.org/webt/ls/g9/gy/lsg9gy2nbzs5m0redadf6s3sqjc.png"><br><p>  Dalam hari-hari Januari yang indah ini, kita semua, tentu saja, prihatin dengan masalah meminimalkan kode sumber sambil mempertahankan yang lain.  Maksud saya, tidak peduli?!?  Sia-sia ... Di sini kompiler jatuh, dan programnya raksasa - entah bagaimana merepotkan pengembang untuk mengirim hal seperti itu.  Dan kemudian kesenangan dimulai: bagaimana jika Anda membuangnya?  Oh, tidak jatuh - oke, kita pergi, tetapi bagaimana jika itu?  - Masih crash, dan ini, dan ini, dan itu ... Oh, saya mulai kompilator pada sumber-sumber lama. </p><br><p>  Pada saat yang sama, mengotomatiskan pencarian bug adalah sesuatu yang vital: git bisect, llvm-bugpoint, creduce, ... Dalam artikel ini saya akan menjelaskan cara lain untuk memecahkan masalah penyederhanaan test case, kurang lebih universal sehubungan dengan bahasa pemrograman, dan menunjukkan beberapa contoh penggunaan. </p><a name="habracut"></a><br><p>  Universal, katakanlah ... Mungkin, tentu saja, ini telah diterapkan sepuluh kali, tetapi apakah ini akan menghentikan seorang pengendara sepeda berpengalaman.  <em>Dan ketika di tangan mikroskop, semua masalah tampak seperti paku.</em>  Dalam peran mikroskop - <a href="https://pmd.github.io/" rel="nofollow">PMD</a> . </p><br><p>  Secara umum, ada bahasa seperti itu untuk model penulisan yang dijelaskan oleh persamaan diferensial - Modelica.  Ini cukup canggih, ada implementasi terbuka yang sangat keren dan secara umum.  Tetapi ada masalah kecil: kadang-kadang kesalahan kompiler internal terjadi di kompiler.  Dalam <a href="https://habr.com/ru/post/474920/">artikel sebelumnya,</a> saya sudah menunjukkan cara menambahkan dukungan Modela ke penganalisa statis PMD (omong-omong, beberapa kesalahan saya muncul selama proses peninjauan) di samping sepuluh modul bahasa yang ada.  Jadi sekarang saya memutuskan - apa gunanya menghilang - dan mengirim alat proof-of-concept Source Code Minimizer, menggunakan kembali modul bahasa PMD yang ada.  Sayangnya, saya dikirim, meskipun tidak jauh, ke repositori tetangga: menter mengatakan bahwa dia masih belum memutuskan untuk mendukung ini sampai akhir abad ini, dan itu hilang dalam basis kode umum, jadi saya segera menemukan undangan untuk berkolaborasi di inbox saya Baru dibuat <a href="https://github.com/pmd/pmd-scm" rel="nofollow">pmd / pmd-scm</a> . </p><br><p>  Pertama, apa pernyataan masalahnya?  Diperlukan untuk mengurangi ukuran kode sumber, menjaga sebagian propertinya.  Lebih spesifik, saya mau </p><br><ul><li>  kode yang dihasilkan dapat diprediksi <br><ul><li>  tidak harus <strong>seminimal mungkin</strong> , "penyelesaian file" diizinkan, tetapi seharusnya tidak berubah menjadi siksaan </li><li>  kebingungan otomatis tidak dipertimbangkan </li></ul></li><li>  program yang diminimalkan dapat dibagi menjadi beberapa file dengan kode sumber <br><ul><li> misalnya, di Jawa, setiap kelas <code>public</code> harus dalam file terpisah dengan nama yang benar, dll. </li><li>  Saya ingin setiap file tetap terlihat pada akhirnya </li></ul></li><li>  dalam proses transformasi, invarian yang ditunjukkan harus dipertahankan </li></ul><br><h2 id="vnutrennee-ustroystvo">  Perangkat internal </h2><br><p>  Pada bagian ini, saya akan secara kasar menggambarkan implementasinya.  Untuk mulai dengan, saya perhatikan lagi bahwa ide ini, secara halus, bukanlah hal baru.  Dan jika saya mengutip git bisect hanya sebagai contoh dari "mekanisme debug otomatis," maka saya menemukan <a href="https://github.com/csmith-project/creduce" rel="nofollow">kredibilitas</a> atau sesuatu yang serupa untuk beberapa waktu (meskipun saya tidak menggunakannya).  Tetapi saya harus menggunakan <a href="https://llvm.org/docs/Bugpoint.html" rel="nofollow">llvm-bugpoint</a> - sangat mengesankan: Anda duduk, men-debug LLVM Pass Anda, dan - infeksi semacam itu - lumpuh pada beberapa sistem file.  Jadi, Anda dapat mengkompilasi file ini dalam bitcode LLVM, jalankan <code>opt</code> pada file .bc dengan plugin Anda dan pastikan itu crash.  Dan kemudian, secara kasar, saya baru saja mengganti <code>opt</code> dengan <code>llvm-bugpoint</code> , dan setelah satu menit saya mendapatkan "kerangka" yang kuat dari salah satu fungsi, yang terdiri dari awan balok dasar dan transisi di antara mereka;  semuanya kecuali cabang-cabang berhasil dibuang.  Ngomong-ngomong, seperti dalam pernyataan masalah saya, setelah selusin menit penyederhanaan manual, semuanya berujung pada fakta bahwa saya salah memproses jenis cabang, dan yang lainnya hanya pemandangan.  Secara umum, idenya bukanlah hal baru. </p><br><p>  Dan sekarang untuk implementasinya.  Karena itu seharusnya menjadi alat yang kurang lebih universal, saya ingin membuat semacam kerangka kerja di mana kita bisa menjejalkan implementasi yang dioptimalkan untuk berbagai bahasa.  Akibatnya, dua konsep yang agak ortogonal menonjol: </p><br><ul><li>  invarian yang didukung </li><li>  strategi minimisasi </li></ul><br><h2 id="invariant">  Invarian </h2><br><p>  Salah satu opsi untuk properti yang mungkin ingin Anda simpan, saya telah jelaskan: "kompiler mencetak frasa ke konsol" ("Kesalahan kompiler internal", misalnya).  Juga, ide dapat diperoleh dari berbagai fuzzer: <a href="https://github.com/google/AFL" rel="nofollow">AFL</a> , <a href="https://github.com/grimm-co/killerbeez" rel="nofollow">Killerbeez</a> dan lainnya: </p><br><ul><li>  proses berakhir dengan beberapa kode kembali (khususnya, "crash on signal" di Linux) </li><li>  prosesnya memakan waktu lebih dari T milidetik.  Di sini, sayangnya, ketidakstabilan dapat terjadi karena beban mengambang sistem.  Untuk lebih akurat, Anda dapat menggunakan waktu CPU, meskipun, idealnya, penghitung kinerja berguna </li><li>  kompiler dapat (tidak) menghasilkan beberapa file output </li><li>  ... </li></ul><br><p>  Saya sudah menerapkan beberapa dari mereka (kode pengembalian, garis tercetak), beberapa tidak, beberapa mungkin khusus untuk masing-masing bahasa.  Secara umum, ini adalah bagian dari tugas yang cukup otonom, seringkali sepenuhnya independen dari bahasa tertentu. </p><br><h2 id="strategiya-minimizacii">  Strategi minimalisasi </h2><br><p>  Sekilas, semuanya di sini murni tergantung pada bahasa.  Di suatu tempat Anda perlu membuang variabel bersama dengan kasus penggunaan, di suatu tempat - untuk mempertahankan jumlah persamaan dan tidak diketahui yang sama.  Yang lebih penting adalah mengabstraksi bagian kode ini.  Tapi sesuatu yang mendasar dapat dibuat umum untuk semua orang: misalnya, dengan menggerakkan pergelangan tangan, mesin aturan XPath berubah ... ternyata ... ... oh, untuk XPath versi 1.0 tidak.  Maaf, sedikit masalah teknis - menjadi alat universal untuk memangkas pohon sintaks <del>  untuk musim dingin </del>  .  Secara umum, strategi minimalisasi API cukup sederhana: pada umumnya, fungsi tersebut memiliki fungsi langkah (diberikan daftar simpul akar dari pohon sintaks), yang dapat menanyakan "tetapi mencoba membuang cabang-cabang ini" melalui antarmuka operasi.  Jika invarian dilanggar, fungsi mengembalikan kontrol, jika tidak, ia memutar stack dengan melemparkan pengecualian khusus, dan versi yang dihasilkan diambil sebagai perkiraan berikutnya.  Suatu proses dianggap selesai jika fungsi langkah mengembalikan kontrol tidak melalui pengecualian.  Anda mungkin mengatakan bahwa ini sangat tidak efektif - mungkin begitu, <del>  NYAMAN NYAMAN !! 111 </del>  , tapi apa masalahnya, jika seharusnya memulai proses kompiler eksternal secara teratur ratusan kali dalam satu siklus. </p><br><p>  Ini menimbulkan pertanyaan: bagaimana cara mendapatkan sumber kembali dari AST yang menipis?  Tentu saja, Anda dapat mencoba menulis kode khusus untuk setiap bahasa yang menghasilkan file teks.  Tapi, seperti yang Anda tahu, seorang programmer harus malas.  Jadi itu tidak akan berhasil - sudah jelas bukan dari seri "mengambil implementasi yang ada dan pergi."  Untungnya, di simpul pohon terdapat informasi tentang awal dan akhir baris dan kolom untuk simpul ini - itu artinya, jika modul bahasa menunjukkan informasi ini dengan benar, Anda dapat mengambil teks sumber dan dengan hati-hati memotongnya (karenanya, omong-omong, dan beberapa kesulitan dengan kebingungan: tidak cukup untuk membuang sesuatu, tetapi Anda harus menggantinya: pengidentifikasi, misalnya).  Ngomong-ngomong, dalam basis kode PMD, kami bahkan menemukan kelas untuk mengedit file menggunakan operasi pemotongan teks yang tidak memotong (juga menambahkan, tetapi ini tidak begitu menarik untuk tugas khusus ini). </p><br><h2 id="teoriya-itog">  Teori: Ringkasan </h2><br><p>  Saat ini saya telah menerapkan dua strategi.  Salah satunya adalah pemangkasan XPath, yang dalam arti tertentu, merupakan kasus yang merosot, karena ia secara paksa menulis hasilnya, bahkan jika itu bukan lagi sumber yang benar secara sintaksis.  Yang kedua sudah "jujur" berulang dan interaktif (dalam arti bahwa itu benar-benar berinteraksi dengan kompiler dan memeriksa yang lain): ia hanya mencoba untuk melemparkan cabang satu per satu dalam satu lingkaran.  Ini sedikit tentang itu: </p><br><ul><li>  pada prinsipnya, memeriksa invarian untuk sumber, yang tidak diuraikan, tidak masuk akal untuk strategi "jujur": bahkan jika kompiler bertahan ini, minimizer harus memulai ulang sumber.  Oleh karena itu, masuk akal untuk membuang file "rusak" terlebih dahulu: parsing dalam proses Anda lebih cepat daripada menjalankan seluruh kompiler </li><li>  dalam kasus umum, mungkin akan lebih mudah untuk menggunakan coroutine di sini (baik, atau mengubah aliran kontrol dalam ke luar), tetapi karena ini jauh dari bagian pekerjaan yang paling sulit secara komputasi, pada setiap langkah dalam fungsi langkah saya hanya berjalan di sekitar pohon, menghitung jarak. puncak.  Saya hanya ingat konter.  Jadi, pada awalnya saya berpikir bahwa bagian atas lebih besar, bagian atas lebih sedikit - bedanya apa, heuristik!  Ternyata kesalahan per unit dapat mengubah tingkat "konvergensi" di kali.  Intinya, ini logis: membuang seluruh fungsi dari kelas agar sering menjadi strategi yang efektif.  Tetapi untuk melompati sedikit, dan setiap kali <strong>masuk ke dalam</strong> fungsi, dalam kebanyakan kasus tidak ada hubungannya dengan masalah, sepertinya ide yang begitu-begitu. </li><li>  Omong-omong tentang coroutine dan penyebaran aliran kontrol: akan ada beberapa masalah dengan ini, karena setelah me-reboot teks yang diubah AST mungkin tidak berubah dengan cara yang sangat jelas (yaitu, tidak hanya cabang-cabang ini akan dibuang kembali, tetapi di suatu tempat node kosong akan menghilang, di suatu tempat umumnya parsing akan menuju ke arah lain).  Belum lagi bahwa node AST baru tidak akan identik dengan merujuk ke yang lama, dan pencocokan logis dengan yang <code>equals</code> - juga terlihat seperti tugas yang sulit </li><li>  pada prinsipnya, Anda dapat menggunakan kemampuan PMD ke berbagai tingkat: Anda dapat menggunakan tipe terhitung, dependensi penggunaan definisi, dll.  dan melakukan sesuatu yang sangat cerdas (tetapi Anda perlu mempertimbangkan API universal).  Di sisi lain, untuk strategi yang dijelaskan, cukup untuk mendapatkan pohon parse.  Dan di sini Anda bahkan dapat <a href="https://github.com/kaitai-io/kaitai_struct" rel="nofollow">mengaitkan</a> beberapa <a href="https://github.com/kaitai-io/kaitai_struct" rel="nofollow">Kaitai Struct</a> dan mencoba untuk mendorong <a href="https://github.com/google/AFL" rel="nofollow">afl-tmin</a> untuk meminimalkan file biner :) </li></ul><br><h2 id="praktika">  Berlatih </h2><br><p>  Untuk memulai, mari buat minimizer: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/pmd/pmd-scm.git cd pmd-scm ./mvnw clean verify unzip pmd-scm-dist/target/pmd-scm-bin-1.0.0-SNAPSHOT.zip</code> </pre> <br><p>  Sekarang Anda membutuhkan beberapa sumber.  Mari kita ambil <a href="" rel="nofollow">GreedyStrategy.java</a> misalnya. </p><br><p>  Dengan menggunakan <a href="https://github.com/pmd/pmd-designer" rel="nofollow">Rule Designer,</a> cari tahu seperti apa AST pada Java, dan jalankan </p><br><pre> <code class="plaintext hljs">$ ./bin/run.sh scm --language java \ --input-file ../pmd-scm/src/main/java/net/sourceforge/pmd/scm/strategies/GreedyStrategy.java \ --output-file GreedyStrategy-min.java \ --strategy xpath \ --xpath-expression '//BlockStatement[count(../BlockStatement) &gt; 1]' Original file(s): 6155 bytes, 1099 nodes. After initial white-space cleanup: size 4548 bytes (73%), 1099 nodes (100%) After pass #1: size 1984 bytes (32%), 1099 nodes (100%) After final white-space cleanup: size 1984 bytes (32%), 325 nodes (29%) After blank line clean up: size 1767 bytes (28%), 325 nodes (29%)</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> net.sourceforge.pmd.scm.strategies; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.HashMap; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.HashSet; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Map; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Set; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> net.sourceforge.pmd.lang.ast.Node; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreedyStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractMinimizationStrategy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Configuration</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MinimizationStrategy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createStrategy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GreedyStrategy(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MinimizationStrategyConfigurationFactory FACTORY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbstractFactory(<span class="hljs-string"><span class="hljs-string">"greedy"</span></span>) { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MinimizationStrategyConfiguration </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createConfiguration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Configuration(); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreedyStrategy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Configuration configuration)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(configuration); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;Node, HashSet&lt;Node&gt;&gt; directlyDependingNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;Node, Set&lt;Node&gt;&gt; transitivelyDependingNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchDirectDependentsFromSubtree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// process depending nodes } private Set&lt;Node&gt; indirectlyDependentNodesFor(Node currentNode) { } private void collectNodesToRemove(Set&lt;Node&gt; result, Node node) { } private int previousPosition = 0; private int positionCountdown; private void findNodeToRemove(Node currentNode) throws Exception { } private void processSingleRoot(Node currentRoot) throws Exception { // cannot remove root for (int i = 0; i &lt; currentRoot.jjtGetNumChildren(); ++i) { findNodeToRemove(currentRoot.jjtGetChild(i)); } } @Override public void performSinglePass(List&lt;Node&gt; roots) throws Exception { } }</span></span></code> </pre> <br><p>  Artinya, kami mengosongkan semua fungsi yang <em>secara langsung berisi lebih dari satu pernyataan</em> .  Namun, menghapus komentar, baris kosong, dll.  Saya belum menentukannya - lagipula, apakah ini (sejauh ini?) Utamanya merupakan alat untuk <strong>debugging compiler</strong> , daripada membuat deskripsi antarmuka yang indah. </p><br><p>  Mari kita lihat sesuatu yang lebih menarik sekarang: cobalah untuk meminimalkan dua file dengan umpan balik dari kompiler secara bersamaan: </p><br><p>  <strong>orig / TestResource.java:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.err.println(<span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unused</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// unused } }</span></span></code> </pre> <br><p>  <strong>orig / Main.java:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestResource().func(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>; } }</code> </pre> <br><p>  Seperti yang Anda lihat, mereka tidak mengkompilasi: </p><br><pre> <code class="plaintext hljs">$ javac orig/TestResource.java orig/Main.java orig/Main.java:3: error: incompatible types: int cannot be converted to String String str = new TestResource().func(); ^ orig/Main.java:5: error: incompatible types: unexpected return value return 123; ^ 2 errors</code> </pre> <br><p>  Mari kita bayangkan ada sesuatu yang salah dengan kesalahan pertama, dan cobalah membuat contoh minimal yang menghasilkan </p><br><pre> <code class="plaintext hljs">error: incompatible types: int cannot be converted to String</code> </pre> <br><p>  Untuk melakukan ini, jalankan </p><br><pre> <code class="plaintext hljs">$ bin/run.sh scm --language java \ --input-file orig/TestResource.java orig/Main.java \ --output-file TestResource.java Main.java \ --invariant message \ --printed-message "error: incompatible types: int cannot be converted to String"\ --command-line "javac TestResource.java Main.java" \ --strategy greedy Original file(s): 290 bytes, 77 nodes. After initial white-space cleanup: size 258 bytes (88%), 77 nodes (100%) After pass #1: size 255 bytes (87%), 64 nodes (83%) After pass #2: size 244 bytes (84%), 57 nodes (74%) After pass #3: size 205 bytes (70%), 51 nodes (66%) After pass #4: size 192 bytes (66%), 46 nodes (59%) After pass #5: size 181 bytes (62%), 39 nodes (50%) After pass #6: size 179 bytes (61%), 39 nodes (50%) After final white-space cleanup: size 149 bytes (51%), 39 nodes (50%) After blank line clean up: size 147 bytes (50%), 39 nodes (50%)</code> </pre> <br><p>  Hasilnya, kita dapatkan </p><br><p>  <strong>TestResource.java:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p>  <strong>Main.java:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestResource().func(); } }</code> </pre> <br><pre> <code class="plaintext hljs">$ javac TestResource.java Main.java TestResource.java:3: error: missing return statement } ^ Main.java:3: error: incompatible types: int cannot be converted to String String str = new TestResource().func(); ^ 2 errors</code> </pre> <br><p>  Semuanya seperti yang diperintahkan! </p><br><h2 id="itog">  Ringkasan </h2><br><p>  Sejauh ini, proyek ini pada tahap yang cukup awal, tetapi sudah ada sesuatu untuk ditunjukkan.  Di masa depan, ada ide untuk membuat API untuk agnostik yang mengindikasikan ketergantungan antara AST node, untuk memungkinkannya menyediakan strategi khusus bahasa.  Akan lebih baik jika membuat strategi universal yang menjalankan skrip Groovy / Kotlin / sesuatu yang lain - lagipula, orang yang menggunakan Java mungkin tidak pernah melihatnya, tetapi mereka tahu benar, misalnya, Modelika, dan ada di kepala mereka cara canggih untuk memeras sumbernya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482634/">https://habr.com/ru/post/id482634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482616/index.html">Foreve Elon 2019/2020 (NY2020 online meeting)</a></li>
<li><a href="../id482620/index.html">Slurm: Habr, selamat berlibur ...</a></li>
<li><a href="../id482622/index.html">Simulasi berlari di tengah hujan</a></li>
<li><a href="../id482626/index.html">Memantau aplikasi dengan Logger.Backends</a></li>
<li><a href="../id482628/index.html">Tonton "Laba-laba Kecil Hijau"</a></li>
<li><a href="../id482636/index.html">Pengalaman dalam masuk ke magistrasi di Jerman (analisis rinci)</a></li>
<li><a href="../id482642/index.html">OSCD: Sprint Detection Ancaman # 1, hasil</a></li>
<li><a href="../id482644/index.html">Keylogger untuk Windows dengan perubahan hak di DACL</a></li>
<li><a href="../id482646/index.html">Tingkatkan kinerja SPA dengan memecah perpustakaan Angular Anda menjadi beberapa bagian</a></li>
<li><a href="../id482648/index.html">Arthur Khachuyan: "Data Besar Nyata dalam periklanan"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>