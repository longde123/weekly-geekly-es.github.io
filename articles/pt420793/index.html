<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕑 🏮 ✊🏿 Depurando como um processo 👗 👩🏽‍🤝‍👩🏼 🧑🏿‍🤝‍🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Acredita-se que o desenvolvimento leva cerca de 10% do tempo e a depuração, 90%. Talvez essa declaração seja exagerada, mas qualquer desenvolvedor con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Depurando como um processo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/420793/"> Acredita-se que o desenvolvimento leva cerca de 10% do tempo e a depuração, 90%.  Talvez essa declaração seja exagerada, mas qualquer desenvolvedor concorda que a depuração é um processo extremamente intensivo em recursos, especialmente em grandes sistemas multithread. <br><br>  Assim, a otimização e sistematização do processo de depuração pode trazer benefícios significativos na forma de horas de trabalho salvas, aumentando a velocidade da resolução de problemas e, finalmente, aumentando a lealdade de seus usuários. <br><br><img src="https://habrastorage.org/webt/lm/eb/rk/lmebrkzzdxjbw-vsbub7ybrlxjq.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sergey Shchegrikovich</a> (dotmailer) na conferência <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNext 2018 Piter</a> sugeriu considerar a depuração como um processo que pode ser descrito e otimizado.  Se você ainda não tem um plano claro para encontrar bugs - abaixo da transcrição em vídeo e texto do relatório de Sergey. <br><br>  (E no final da postagem, adicionamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> apelo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John Skeet</a> a todos os afiliados, não deixe de conferir) <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Paxi4K5Om1Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Meu objetivo é responder à pergunta: como corrigir erros de forma eficiente e qual deve ser o foco.  Eu acho que a resposta para esta pergunta é um processo.  O processo de depuração, que consiste em regras muito simples, e você as conhece bem, mas provavelmente o usa sem saber.  Portanto, minha tarefa é sistematizá-los e mostrar como se tornar mais eficaz usando um exemplo. <br><br>  Vamos desenvolver uma linguagem comum para comunicação durante a depuração e também veremos um caminho direto para encontrar os principais problemas.  Nos meus exemplos, mostrarei o que aconteceu devido a uma violação dessas regras. <br><br><h2>  Utilitários de depuração </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/292/518/f94/292518f94ecd468e034d8ec952398980.png"><br>  Obviamente, qualquer depuração não é possível sem os utilitários de depuração.  Meus favoritos são: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Windbg</a> , que além do próprio depurador, possui uma funcionalidade rica para estudar despejos de memória.  Um despejo de memória é uma fatia do estado de um processo.  Nele você pode encontrar o valor dos campos de objetos, pilhas de chamadas, mas, infelizmente, o despejo de memória é estático. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O PerfView</a> é um profiler escrito sobre a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tecnologia ETW</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sysinternals</a> é um utilitário escrito por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mark Russinovich</a> , que permite que você mergulhe um pouco mais no dispositivo do sistema operacional. <br></li></ul><br><h2>  Serviço em queda </h2><br>  Vamos começar com um exemplo da minha vida em que mostrarei como a natureza não sistemática do processo de depuração leva à ineficiência. <br><br>  Provavelmente, isso aconteceu com todo mundo, quando você chega a uma nova empresa em uma nova equipe para um novo projeto e, desde o primeiro dia, deseja obter benefícios irreparáveis.  Então foi comigo.  Naquela época, tínhamos um serviço que recebia html para entrada e imagens de saída para saída. <br><br>  O serviço foi escrito em .Net 3.0 e foi há muito tempo.  Este serviço tinha um pequeno recurso - travou.  Caiu frequentemente, cerca de uma vez a cada duas a três horas.  Corrigimos essas propriedades de reinicialização elegantemente definidas nas propriedades do serviço após a queda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cc/b02/1a2/0ccb021a20b6c50d1639cd3e2bef7c28.png"><br><br>  O serviço não foi crítico para nós e pudemos sobreviver.  Mas entrei para o projeto e a primeira coisa que decidi fazer foi corrigi-lo. <br><br>  Para onde vão os desenvolvedores do .NET se algo não funcionar?  Eles vão para o EventViewer.  Mas lá não encontrei nada, exceto o registro de que o serviço caiu.  Não houve mensagens sobre o erro nativo nem uma pilha de chamadas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be3/bdf/2fe/be3bdf2fe39777092ad0f2989e35d92e.png"><br><br>  Existe uma ferramenta comprovada para o que fazer a seguir - envolvemos todo o <code>main</code> no <code>try-catch</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); }</code> </pre><br>  A idéia é simples: o <code>try-catch</code> funcionará, nos incomodará, vamos ler e corrigir o serviço.  Nós compilamos, implantamos na produção, o serviço trava, não há erro.  Adicione outra <code>catch</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); }</code> </pre><br>  Repetimos o processo: o serviço trava, não há erros nos logs.  A última coisa que pode ajudar é <code>finally</code> , que é sempre chamada. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ProcessRequest(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LogError(ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { LogError(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { LogEndOfExecution(); }</code> </pre><br>  Compilamos, implantamos, o serviço falha, não há erros.  Três dias se passaram atrás desse processo, agora já estão chegando os pensamentos de que devemos finalmente começar a pensar e fazer outra coisa.  Você pode fazer muitas coisas: tente reproduzir o erro na máquina local, assista a despejos de memória etc.  Pareceu mais dois dias e vou corrigir esse bug ... <br><br>  Duas semanas se passaram. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1eb/f02/0c3/1ebf020c3dde595f5423fd8247c3137b.png"><br><br>  Procurei no PerformanceMonitor, onde vi um serviço que trava, depois sobe e cai novamente.  Essa condição é chamada <i>desespero</i> e fica assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/e07/904/98be07904a35b99130ba9ddf871af47f.png"><br><br>  Nesta variedade de rótulos, você está tentando descobrir onde realmente está o problema?  Após várias horas de meditação, o problema aparece repentinamente: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/379/2ba/caa/3792bacaa7c418f5fcffa318729bf1a0.png"><br><br>  A linha vermelha é o número de identificadores nativos que o processo possui.  Um identificador nativo é uma referência a um recurso do sistema operacional: arquivo, registro, chave do registro, mutex, etc.  Para alguma estranha combinação de circunstâncias, a queda no crescimento do número de identificadores coincide com os momentos em que o serviço caiu.  Isso leva à idéia de que em algum lugar há um vazamento de alças. <br><br>  Tomamos um despejo de memória, abri-lo no WinDbg.  Começamos a executar comandos.  Vamos tentar ver a fila de finalização desses objetos que devem ser liberados pelo aplicativo. <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">000</span></span>&gt; !FinalizeQueue</code> </pre><br>  No final da lista, encontrei um navegador da web. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6f/aa5/eb3/d6faa5eb38c3b7a4429e55d7f8af655e.png"><br>  A solução é simples - pegue o WebBrowser e ligue para <code>dispose</code> -lo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webBrowser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebBrowser()) { <span class="hljs-comment"><span class="hljs-comment">// Processing ... } }</span></span></code> </pre><br>  As conclusões desta história podem ser tiradas da seguinte forma: duas semanas são longas e longas demais para encontrar um <code>dispose</code> não convidado;  que encontramos uma solução para o problema - sorte, uma vez que não havia uma abordagem específica, não havia uma natureza sistemática. <br><br>  Depois disso, tive uma pergunta: como estrear efetivamente e o que fazer? <br><br>  Para fazer isso, você precisa saber apenas três coisas: <br><br><ol><li>  Regras de depuração <br></li><li>  Algoritmo para encontrar erros. <br></li><li>  Técnicas de depuração proativas. <br></li></ol><br><h2>  Regras de depuração </h2><br><ol><li>  Repita o erro. <br></li><li>  Se você não tiver corrigido o erro, ele não será corrigido. <br></li><li>  Entenda o sistema. <br></li><li>  Verifique a ficha. <br></li><li>  Divida e conquiste. <br></li><li>  Refresque-se. <br></li><li>  Este é o seu erro. <br></li><li>  Cinco porque. <br></li></ol><br>  Essas são regras bem claras que se descrevem. <br><br>  Repita o erro.  Uma regra muito simples, porque se você não cometer um erro, não há nada a corrigir.  Mas existem casos diferentes, especialmente para erros em um ambiente multithread.  De alguma forma, tivemos um erro que apareceu apenas nos processadores Itanium e apenas nos servidores de produção.  Portanto, a primeira tarefa no processo de depuração é encontrar uma configuração do banco de testes no qual o erro seria reproduzido. <br><br>  Se você não tiver corrigido o erro, ele não será corrigido.  Às vezes isso acontece: um rastreador de erros contém um erro que apareceu há meio ano, ninguém o vê há muito tempo e existe um desejo de simplesmente fechá-lo.  Mas, neste momento, perdemos a chance de saber, a chance de entender como nosso sistema funciona e o que realmente acontece com ele.  Portanto, qualquer bug é uma nova oportunidade para aprender algo, aprender mais sobre o seu sistema. <br><br>  Entenda o sistema.  Brian Kernighan disse uma vez que se éramos tão inteligentes ao escrever esse sistema, precisamos ser duplamente inteligentes para lançá-lo. <br><br>  Um pequeno exemplo para a regra.  Nosso monitoramento desenha gráficos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/bfa/85b/4cfbfa85be2cf375741646b55aa373e6.png"><br>  Este é um gráfico do número de solicitações processadas por nosso serviço.  Depois de analisá-lo, tivemos a ideia de que seria possível aumentar a velocidade do serviço.  Nesse caso, a programação aumenta, pode ser possível reduzir o número de servidores. <br><br>  A otimização do desempenho da Web é feita de forma simples: pegamos o PerfView, executamos na máquina de produção, removemos o rastreio dentro de 3-4 minutos, levamos esse rastreio para a máquina local e começamos a estudá-lo. <br><br>  Uma das estatísticas que o PerfView mostra é o coletor de lixo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3a/ed0/c3f/d3aed0c3f4d3c6de77840aa9ffc10004.png"><br><br>  Observando essas estatísticas, vimos que o serviço gasta 85% de seu tempo coletando lixo.  Você pode ver no PerfView exatamente onde esse tempo é gasto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/cd2/e4a/bb5cd2e4a54d4f71d832482217233281.png"><br><br>  No nosso caso, isso está criando cadeias.  A correção propriamente dita se sugere: substituímos todas as strings por StringBuilders.  Localmente, obtemos um aumento de produtividade de 20 a 30%.  Implante na produção, veja os resultados em comparação com o cronograma antigo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/d63/21d/060d6321d41fa993d80d7b9d19d2d95c.png"><br><br>  A regra "Compreender o sistema" não é apenas entender como as interações estão acontecendo no sistema, como as mensagens são, mas tentar modelar o sistema. <br><br>  No exemplo, o gráfico mostra a largura de banda.  Mas se você observar todo o sistema do ponto de vista da teoria das filas, a taxa de transferência de nosso sistema depende de apenas um parâmetro - a velocidade de chegada de novas mensagens.  De fato, o sistema simplesmente não possuía mais de 80 mensagens por vez, portanto não há como otimizar esse agendamento. <br><br>  Verifique a ficha.  Se você abrir a documentação de qualquer eletrodoméstico, ela definitivamente será escrita: se o aparelho não funcionar, verifique se o plugue está inserido na tomada.  Depois de várias horas no depurador, muitas vezes me pego pensando que só precisava recompilar ou simplesmente pegar a versão mais recente. <br><br>  A regra "verifique o plugue" é sobre fatos e dados.  A depuração não inicia executando o WinDbg ou PerfView nas máquinas de produção, mas começa verificando fatos e dados.  Se o serviço não estiver respondendo, talvez ele não esteja sendo executado. <br><br>  Divida e conquiste.  Esta é a primeira e provavelmente a única regra que inclui a depuração como um processo.  Trata-se de hipóteses, sua promoção e teste. <br><br>  Um de nossos serviços não queria parar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f2/cff/169/4f2cff1697473f917e815384d773149a.png"><br><br>  Nós fazemos uma hipótese: talvez exista um ciclo no projeto que processe algo sem fim. <br><br>  Você pode testar a hipótese de maneiras diferentes, uma opção é fazer um despejo de memória.  <code>~*e!ClrStack</code> pilhas de chamadas do despejo e de todos os threads usando o <code>~*e!ClrStack</code> .  Começamos a olhar e ver três fluxos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a54/35b/1d3a5435b697646daaf802e2bd838c7e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f3/185/6b2/2f31856b23147722d7b3e534689572f8.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/ac7/760/d0fac7760f4e8e201d0f028c4deae23e.png"><br><br>  O primeiro thread está em Main, o segundo está no manipulador <code>OnStop()</code> e o terceiro thread estava aguardando algumas tarefas internas.  Assim, nossa hipótese não se justifica.  Não há loop, todos os threads estão esperando por algo.  Provavelmente impasse. <br><br>  Nosso serviço funciona da seguinte maneira.  Existem duas tarefas - inicialização e trabalho.  A inicialização abre uma conexão com o banco de dados, o trabalhador começa a processar os dados.  A comunicação entre eles ocorre através de um sinalizador comum, que é implementado usando <code>TaskCompletionSource</code> . <br><br>  Criamos a segunda hipótese: talvez tenhamos um impasse de uma tarefa para a segunda.  Para verificar isso, você pode ver cada tarefa separadamente através do WinDbg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0f/536/1cf/c0f5361cf09ba6cd40d9a72e6d5dfb06.png"><br><br>  Acontece que uma das tarefas caiu e a segunda não.  No projeto, vimos o seguinte código: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Isso significa que a tarefa de inicialização abre a conexão e, em seguida, define <code>TaskCompletionSource</code> como true.  Mas e se uma exceção cair aqui?  Como não temos tempo para definir <code>SetResult</code> como true, a correção desse bug foi assim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> openAsync(); _initLock.SetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception ex) { _initLock.SetException(ex); }</code> </pre><br>  Neste exemplo, apresentamos duas hipóteses: o loop infinito e o impasse.  A regra "dividir e conquistar" ajuda a localizar o erro.  Aproximações sucessivas resolvem esses problemas. <br><br>  O mais importante nessa regra são hipóteses, porque com o tempo elas se transformam em padrões.  E, dependendo da hipótese, usamos ações diferentes. <br><br>  Refresque-se.  Essa regra é que você só precisa se levantar da mesa e caminhar, beber água, suco ou café, fazer qualquer coisa, mas a coisa mais importante é se distrair do seu problema. <br><br>  Existe um método muito bom chamado pato.  De acordo com o método, devemos falar sobre o problema de se <i>esquivar</i> .  Você pode usar um colega como um <i>pato</i> .  Além disso, ele não precisa responder, apenas ouvir e concordar.  E, muitas vezes, após a primeira conversa sobre o problema, você mesmo encontra uma solução. <br><br>  Este é o seu erro.  Vou contar sobre esta regra por um exemplo. <br><br>  Houve um problema em uma <code>AccessViolationException</code> .  Olhando na pilha de chamadas, vi que ocorreu quando geramos a consulta LinqToSql dentro do cliente sql. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd2/849/7a6/fd28497a66853c5bcf17eaa9d978524a.png"><br><br>  A partir desse bug, ficou claro que em algum lugar a integridade da memória é violada.  Felizmente, naquela época, já usamos o sistema de gerenciamento de alterações.  Como resultado, após algumas horas, ficou claro o que aconteceu: instalamos o .Net 4.5.2 em nossas máquinas de produção. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/bc8/438/f24bc84388e43df0ad4e7af27c0bbc24.png"><br><br>  Assim, enviamos o bug para a Microsoft, eles o examinam, nos comunicamos com eles, eles corrigem o bug no .Net 4.6.1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/c39/535/44ac39535a874ff0ea0f599a55f07252.png"><br><br>  Para mim, isso resultou em 11 meses de trabalho com o suporte da Microsoft, é claro, não todos os dias, mas levou 11 meses desde o início para ser corrigido.  Além disso, enviamos dezenas de gigabytes de despejos de memória, colocamos centenas de assemblies particulares para detectar esse erro.  E durante todo esse tempo, não podíamos dizer aos nossos clientes que a Microsoft era a culpada, não a nós.  Portanto, o bug é sempre seu. <br><br>  Cinco porque.  Nós da nossa empresa usamos o Elastic.  Elastic é bom para agregação de logs. <br><br>  Você vem trabalhar de manhã, e Elastic mente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a1/c80/09b/1a1c8009b49f9c288b3c4b29daf194cc.png"><br><br>  A primeira pergunta é por que o Elastic?  Quase imediatamente ficou claro - os nós principais caíram.  Eles coordenam o trabalho de todo o cluster e, quando caem, o cluster inteiro deixa de responder.  Por que eles não se levantaram?  Talvez deva haver um arranque automático?  Depois de procurar a resposta, descobrimos que a versão do plugin não corresponde.  Por que os nós mestres caíram?  Eles foram mortos pelo OOM Killer.  Isso é algo que ocorre nas máquinas Linux, que, em caso de falta de memória, fecha processos desnecessários.  Por que não há memória suficiente?  Porque o processo de atualização foi iniciado, que segue os logs do sistema.  Por que funcionou antes, mas não agora?  E como adicionamos novos nós uma semana antes, os nós principais precisavam de mais memória para armazenar índices e configurações de cluster. <br><br>  As perguntas "por quê?"  ajudar a encontrar a raiz do problema.  No exemplo, podemos desativar o caminho certo várias vezes, mas a correção completa é assim: atualize o plug-in, inicie serviços, aumente a memória e anote o futuro; na próxima vez em que adicionar novos nós ao cluster, será necessário garantir que a memória no Master seja suficiente Nós <br><br>  A aplicação dessas regras permite revelar problemas reais, muda seu foco para a solução desses problemas e ajuda a se comunicar.  Mas seria ainda melhor se essas regras formassem um sistema.  E existe esse sistema, chamado de algoritmo de depuração. <br><br><h2>  Algoritmo de depuração </h2><br>  Pela primeira vez, li sobre o algoritmo de depuração no livro Debugging Applications de John Robbins.  Ele descreve o processo de depuração da seguinte maneira: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/2af/a07/f1e2afa078f2ab8587467660b25df052.png"><br><br>  Este algoritmo é útil para seu loop interno - trabalhando com uma hipótese. <br><br>  A cada volta do ciclo, podemos nos controlar: sabemos mais sobre o sistema ou não?  Se apresentarmos hipóteses, verifique, elas não funcionam, não aprendemos nada de novo sobre a operação do sistema, provavelmente é hora de refrescar-nos.  Duas perguntas atuais neste momento: quais hipóteses você testou e qual hipótese você está testando agora. <br><br>  Esse algoritmo concorda muito bem com as regras de depuração de que falamos acima: repita o erro - este é o seu erro, descreva o problema - entenda o sistema, formule uma hipótese - divida e conquiste, teste a hipótese - verifique o plug, verifique se está consertado - cinco por que. <br><br>  Eu tenho um bom exemplo para este algoritmo.  Uma exceção ocorreu em um de nossos serviços da web. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/206/a57/d71/206a57d711a7c783c9f22389120d1bf8.png"><br><br>  Nosso primeiro pensamento não é nosso problema.  Mas, de acordo com as regras, esse ainda é nosso problema. <br><br>  Primeiro, repita o erro.  Para cada mil solicitações, há aproximadamente uma <code>StructureMapException</code> , para que possamos reproduzir o problema. <br><br>  Em segundo lugar, estamos tentando descrever o problema: se o usuário fizer uma solicitação http para o nosso serviço no momento em que o StructureMap estiver tentando criar uma nova dependência, ocorrerá uma exceção. <br><br>  Em terceiro lugar, supomos que o StructureMap é um invólucro e existe algo dentro que gera uma exceção interna.  Testamos a hipótese usando procdump.exe. <br><br><pre> <code class="hljs powershell">procdump.exe <span class="hljs-literal"><span class="hljs-literal">-ma</span></span> <span class="hljs-literal"><span class="hljs-literal">-e</span></span> <span class="hljs-operator"><span class="hljs-operator">-f</span></span> StructureMap w3wp.exe</code> </pre><br>  Acontece que dentro é uma <code>NullReferenceException</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2da/773/500/2da773500ffd18d1c28b91f6ff5b45e3.png"><br><br>  Estudando a pilha de chamadas dessa exceção, entendemos que isso acontece dentro do construtor de objetos no próprio StructureMap. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fd/347/8fc/5fd3478fc54df6295244471a33560a3d.png"><br><br>  Mas <code>NullReferenceException</code> não é o problema em si, mas a consequência.  Você precisa entender onde isso ocorre e quem o gera. <br><br>  Apresentamos a seguinte hipótese: por algum motivo, nosso código retorna uma dependência nula.  Dado que no .Net todos os objetos na memória estão localizados um a um, se observarmos os objetos no heap que estão antes da <code>NullReferenceException</code> , eles provavelmente apontarão para o código que lançou a exceção. <br><br>  No WinDbg existe um comando - Listar objetos <code>!lno</code> .  Isso mostra que o objeto em que estamos interessados ​​é a função lambda, que é usada no código a seguir. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompoundInterceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindInterceptor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { CompoundInterceptop interceptor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (_locker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_analyzedInterceptors.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> interceptor)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interceptorArray = _interceptors.FindAll(i =&gt; i.MatchesType(type)); interceptor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompoundInterceptor(interceptorArray); _analyzedInterceptors.Add(type, interceptor); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor; }</code> </pre><br>  Nesse código, primeiro verificamos se o valor no <code>Dictionary</code> <code>_analyzedInterceptors</code> em <code>_analyzedInterceptors</code> ; se não o encontrarmos, adicionamos um novo valor dentro do <code>lock</code> . <br><br>  Em teoria, esse código nunca pode retornar nulo.  Mas o problema aqui está em <code>_analyzedInterceptors</code> , que usa um <code>Dictionary</code> regular em um ambiente com vários threads, não um <code>ConcurrentDictionary</code> . <br><br>  A raiz do problema foi encontrada, atualizamos para a versão mais recente do StructureMap, implantada, e garantimos que tudo estava corrigido.  O último passo do nosso algoritmo é "aprender e contar".  No nosso caso, foi uma pesquisa no código de todos os <code>Dictionary</code> que são usados ​​no bloqueio e verificação de que todos eles são usados ​​corretamente. <br><br>  Portanto, o algoritmo de depuração é um algoritmo intuitivo que economiza tempo significativamente.  Ele se concentra na hipótese - e isso é a coisa mais importante na depuração. <br><br><h2>  Depuração proativa </h2><br>  Na sua essência, a depuração proativa responde à pergunta "o que acontece quando um bug aparece". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/718/900/7aa71890010a8c32900fa5b01e0b690a.png"><br><br>  A importância das técnicas de depuração proativas pode ser vista no diagrama do ciclo de vida do bug. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be0/f6f/06c/be0f6f06cb0c810ca6b19cb861d998c4.png"><br><br>  O problema é que quanto mais tempo o bug vive, mais recursos (tempo) gastamos nele. <br><br>  As regras de depuração e o algoritmo de depuração nos concentram no momento em que o bug é encontrado e podemos descobrir o que fazer a seguir.  De fato, queremos mudar nosso foco no momento em que o bug foi criado.  Acredito que devemos fazer o Produto Mínimo Debugável (MDP), ou seja, um produto que possua o conjunto mínimo de infraestrutura necessário para uma depuração eficiente da produção. <br><br>  O MDP consiste em duas coisas: função de condicionamento físico e método USE. <br><br>  Recursos de fitness.  Eles foram popularizados por Neil Ford e co-autores no livro Building Evolutionary Architectures.  Na essência, as funções de condicionamento físico, de acordo com os autores do livro, têm a seguinte aparência: existe uma arquitetura de aplicativo que podemos cortar em ângulos diferentes, obtendo propriedades arquitetônicas como capacidade de <i>manutenção</i> , <i>desempenho</i> etc. e, para cada seção, devemos escrever um teste - condicionamento físico -função.  Assim, uma função de condicionamento físico é um teste de arquitetura. <br><br>  No caso do MDP, a função de adequação é um teste de depuração.  Você pode usar o que quiser para escrever esses testes: NUnit, MSTest e assim por diante.  Porém, como a depuração geralmente funciona com ferramentas externas, demonstrarei o uso do Pester (estrutura de teste de unidade do powershell) como exemplo.  Sua vantagem aqui é que ele funciona bem com a linha de comando. <br><br>  Por exemplo, dentro da empresa, concordamos que usaremos bibliotecas específicas para o log;  ao registrar, usaremos padrões específicos;  caracteres pdb sempre devem ser dados ao servidor de símbolos.  Essas serão as convenções que testaremos em nossos testes. <br><br><pre> <code class="hljs powershell">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains line numbers in PDBs'</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-ChildItem</span></span> <span class="hljs-literal"><span class="hljs-literal">-Path</span></span> . <span class="hljs-literal"><span class="hljs-literal">-Recurse</span></span> <span class="hljs-literal"><span class="hljs-literal">-Include</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>(<span class="hljs-string"><span class="hljs-string">"*.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"*. dll "</span></span>) ` | <span class="hljs-built_in"><span class="hljs-built_in">ForEach-Object</span></span> { &amp;symchk.exe /v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">"</span></span> /s <span class="hljs-string"><span class="hljs-string">"\\network\"</span></span> *&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> } ` | <span class="hljs-built_in"><span class="hljs-built_in">Where-Object</span></span> { <span class="hljs-variable"><span class="hljs-variable">$_</span></span> <span class="hljs-operator"><span class="hljs-operator">-like</span></span> <span class="hljs-string"><span class="hljs-string">"*Line nubmers: TRUE*"</span></span> } ` | Should <span class="hljs-operator"><span class="hljs-operator">-Not</span></span> –BeNullOrEmpty } }</code> </pre><br>  Este teste verifica se todos os caracteres pdb foram fornecidos ao servidor de símbolos e foram dados corretamente, ou seja, aqueles que contêm números de linhas no interior.  Para fazer isso, pegamos a versão compilada da produção, localizamos todos os arquivos exe e dll, passamos todos esses binários pelo utilitário syschk.exe, que está incluído no pacote de ferramentas de depuração do Windows.  O utilitário syschk.exe verifica o binário com o servidor de símbolos e, se encontrar um arquivo pdb, imprime um relatório sobre ele.  No relatório, procuramos a linha "Números de linha: VERDADEIRO".  E na final, verificamos que o resultado não é "nulo ou vazio". <br><br>  Esses testes devem ser integrados a um pipeline de implantação contínua.  Após os testes de integração e os testes de unidade, as funções de condicionamento físico são iniciadas. <br><br>  Vou mostrar mais um exemplo com a verificação das bibliotecas necessárias no código. <br><br><pre> <code class="hljs powershell">Describe <span class="hljs-string"><span class="hljs-string">'Debuggability'</span></span> { It <span class="hljs-string"><span class="hljs-string">'Contains package for logging'</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-ChildItem</span></span> <span class="hljs-literal"><span class="hljs-literal">-Path</span></span> . <span class="hljs-literal"><span class="hljs-literal">-Recurse</span></span> <span class="hljs-literal"><span class="hljs-literal">-Name</span></span> <span class="hljs-string"><span class="hljs-string">"packages.config"</span></span> ` | <span class="hljs-built_in"><span class="hljs-built_in">ForEach-Object</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Get-Content</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_</span></span></span><span class="hljs-string">"</span></span> } ` | <span class="hljs-built_in"><span class="hljs-built_in">Where-Object</span></span> { <span class="hljs-variable"><span class="hljs-variable">$_</span></span> <span class="hljs-operator"><span class="hljs-operator">-like</span></span> <span class="hljs-string"><span class="hljs-string">"*nlog*"</span></span> } ` | Should <span class="hljs-operator"><span class="hljs-operator">-Not</span></span> –BeNullOrEmpty } }</code> </pre><br>  No teste, pegamos todos os arquivos packages.config e tentamos encontrar as bibliotecas nlog neles.  Da mesma forma, podemos verificar se o campo de identificação de correlação é usado dentro do campo nlog. <br><br>  Métodos de USE.  A última coisa que o MDP consiste são as métricas que você precisa coletar. <br><br>  Vou demonstrar pelo exemplo do método USE, que foi popularizado por Brendan Gregg.  :     - ,    : utilization (), saturation (), errors (),     . <br><br>  ,  Circonus (  monitoring soft),  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/f58/382/70af583826e562f796fb0473c520db15.png"><br><br>   , ,  ,   —    ,  —     ,  —   ,  .       ,   USE-       . <br><br>   - -, ,  ,      : <br><br><ul><li>  —   . <br></li><li>  —  . <br></li><li>  —   . <br></li></ul><br>         ,      .   ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/f89/7ab/6ccf897ab0758b344dfc940eb9be548b.png"><br><br>  ,   , —       .   ,   ,  4-5% CPU. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9a3/f4a/7e19a3f4a52547627e150401b0f1e7e7.png"><br><br>   —    ,    .   etrace. <br><br><pre> <code class="hljs powershell">etrace -<span class="hljs-literal"><span class="hljs-literal">-kernel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Process</span></span> ^ -<span class="hljs-literal"><span class="hljs-literal">-where</span></span> ProcessName=Ex5<span class="hljs-literal"><span class="hljs-literal">-Service</span></span> ^ -<span class="hljs-literal"><span class="hljs-literal">-clr</span></span> Exception</code> </pre><br>    realtime   ETW-events     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1a/d13/52b/f1ad1352bc6e02e3a660f64ce90fdc87.png"><br><br> ,   <code>OutOfMemoryException</code> . ,  ,     ?    —   ,   ,      . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ShouldContinue()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Do(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException) { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); GC.CollectionCount(<span class="hljs-number"><span class="hljs-number">2</span></span>); GC.WaitForPendingFinalizers(); } }</code> </pre><br>   — -   .   ,      . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cache</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConcurrentDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, String&gt; _items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DateTime _nextClearTime = DateTime.UtcNow; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFromCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_nextClearTime &lt; DateTime.UtcNow) { _nextClearTime = DateTime.UtcNow.AddHours(<span class="hljs-number"><span class="hljs-number">1</span></span>); _items.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _items[key]; } }</code> </pre><br>   ,      .     ,     .     USE  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/174/634/0c6174634447a3bd1af03adf10c14cbe.png"><br><br>     —  ,   . <br><br> ,   ,     . <br><br><ul><li>  —    .  , ,    —    .    —    ,      -.     ,       . <br></li><li>     .             ;  Exception ,   ,     -   . <br></li><li> Minimum Debuggable Product —  ,          . <br></li></ul><br><h2> ,    ? </h2><br><ol><li>   . <br></li><li>  . <br></li><li>  . <br></li></ol><br><hr><br>       — Jon Skeet.          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNext</a> ,    (  ). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p2SQbq-umy4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420793/">https://habr.com/ru/post/pt420793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420781/index.html">Armazenamento de dados distribuídos no conceito Data Lake: administração de cluster</a></li>
<li><a href="../pt420783/index.html">Gerenciamento de dependências, eventos e padrões de observadores e mediadores</a></li>
<li><a href="../pt420785/index.html">Trabalhe como especialista em TI no Extremo Oriente - Oblast de Sakhalin</a></li>
<li><a href="../pt420789/index.html">Arquitetura (A | a): por que isso é uma mitigação não padrão para desenvolvedores de sistemas altamente carregados</a></li>
<li><a href="../pt420791/index.html">Robôs domésticos: o que você pode comprar. Visão geral dos robôs domésticos comerciais disponíveis</a></li>
<li><a href="../pt420795/index.html">Equívocos do analista</a></li>
<li><a href="../pt420797/index.html">A aprendizagem não pode ser adiada</a></li>
<li><a href="../pt420799/index.html">MPS 2018.2: testes de gerador, plug-in GitHub, aspecto VCS, notificações de migração e muito mais</a></li>
<li><a href="../pt420803/index.html">Aulas de impressão 3D. Economizando plástico ao imprimir modelos não funcionais do 3Dtool</a></li>
<li><a href="../pt420805/index.html">[Translation] Quando usar fluxos paralelos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>