<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¥ üßëüèº üòΩ Desenvolvimento e teste inteligentes de contratos do Hyperledger Fabric ‚ûï üìí üçÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Hyperledger Fabric (HLF) √© uma plataforma de c√≥digo aberto que usa a tecnologia de contabilidade distribu√≠da (DLT), projetada para desenvolver aplic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento e teste inteligentes de contratos do Hyperledger Fabric</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  O Hyperledger Fabric (HLF) √© uma plataforma de c√≥digo aberto que usa a tecnologia de contabilidade distribu√≠da (DLT), projetada para desenvolver aplicativos que funcionam em um ambiente de rede comercial criado e controlado por um cons√≥rcio de organiza√ß√µes usando regras de acesso (com permiss√£o). </p><br><p>  A plataforma suporta contratos inteligentes, em termos de HLF - c√≥digos de cadeia criados em linguagens gerais como Golang, JavaScript, Java, ao contr√°rio de, por exemplo, o Ethereum, que usa uma funcionalidade limitada orientada a contratos e linguagem Solidity (LLL, Viper, etc.). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  O desenvolvimento e teste de c√≥digos de cadeia, devido √† necessidade de implantar um n√∫mero significativo de componentes da rede blockchain, pode ser um processo bastante demorado, com alto tempo gasto em testes de altera√ß√µes.  Este artigo discute uma abordagem para o r√°pido desenvolvimento e teste de contratos inteligentes da HLF Golang usando a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CCKit</a> . </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  Aplicativo baseado em HLF </h2><br><p>  Do ponto de vista do desenvolvedor, o aplicativo blockchain consiste em duas partes principais: </p><br><ul><li>  <strong>On-chain</strong> - contratos inteligentes (programas) operando em um ambiente isolado da rede blockchain que determina as regras para cria√ß√£o e composi√ß√£o dos atributos de transa√ß√£o.  Em um contrato inteligente, as principais a√ß√µes s√£o a leitura, atualiza√ß√£o e exclus√£o de dados do estado da rede blockchain.  Deve-se enfatizar que a exclus√£o de dados de um estado deixa informa√ß√µes de que esses dados estavam presentes. </li><li>  <strong>Fora da cadeia</strong> √© um aplicativo (por exemplo, uma API) que interage com o ambiente blockchain por meio do SDK.  A intera√ß√£o √© entendida como chamar fun√ß√µes de contrato inteligente e monitorar eventos de contrato inteligente - eventos externos podem causar altera√ß√µes de dados no contrato inteligente, enquanto eventos no contrato inteligente podem desencadear a√ß√µes em sistemas externos. </li></ul><br><p>  Os dados geralmente s√£o lidos atrav√©s do n√≥ da rede blockchain "residencial".  Para registrar dados, o aplicativo envia solicita√ß√µes aos n√≥s das organiza√ß√µes participantes da "pol√≠tica de aprova√ß√£o" de um contrato inteligente espec√≠fico. </p><br><p>  Para desenvolver c√≥digo fora da cadeia (API etc.), √© usado um SDK especializado que encapsula a intera√ß√£o com os n√≥s da blockchain, coletando respostas etc.  Para HLF, existem implementa√ß√µes de SDK para Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Node.Js</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Componentes de malha do Hyperledger </h2><br><h3 id="kanal">  Canal </h3><br><p>  Um canal √© uma sub-rede separada de n√≥s que suporta uma cadeia de blocos isolada (ledger), bem como o estado atual (valor-chave) da cadeia de blocos ( <em>estado mundial</em> ) usado para operar contratos inteligentes.  Um host pode ter acesso a um n√∫mero arbitr√°rio de canais. </p><br><h3 id="tranzakciya">  Transa√ß√£o </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma transa√ß√£o no Hyperledger Fabric</a> √© uma atualiza√ß√£o at√¥mica do estado de uma cadeia de blocos, resultado da execu√ß√£o do m√©todo chaincode.  Uma transa√ß√£o consiste em uma solicita√ß√£o para chamar um m√©todo chaincode com alguns argumentos (Proposta de Transa√ß√£o) assinados pelo n√≥ de chamada e um conjunto de respostas (Resposta da Proposta de Transa√ß√£o) dos n√≥s nos quais a transa√ß√£o foi "confirmada" (Endosso).  As respostas cont√™m informa√ß√µes sobre os pares de valores-chave alterados do status da cadeia de blocos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto de leitura e grava√ß√£o</a> e informa√ß√µes de servi√ßo (assinaturas e certificados de n√≥s que confirmam a transa√ß√£o).  Porque  cadeias de blocos de canais individuais s√£o fisicamente separadas, uma transa√ß√£o pode ser realizada apenas no contexto de um canal. </p><br><p>  As plataformas blockchain "cl√°ssicas", como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bitcoin</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ethereum</a> , usam o ciclo de transa√ß√µes Ordering-Execution executado por todos os n√≥s, o que limita a escalabilidade da rede blockchain. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  O Hyperledger Fabric usa uma arquitetura de execu√ß√£o e distribui√ß√£o de transa√ß√µes que possui 3 opera√ß√µes principais: </p><br><ul><li><p>  Execu√ß√£o ( <strong>execu√ß√£o</strong> ) - cria√ß√£o por um contrato inteligente em execu√ß√£o em um ou v√°rios n√≥s da rede, transa√ß√µes - altera√ß√µes at√¥micas no estado de um registro distribu√≠do ( <em>endosso</em> ) </p><br></li><li><p>  Pedido - pedido e agrupamento de transa√ß√µes em blocos pelo servi√ßo especializado de <em>pedidos</em> , usando um algoritmo de consenso conect√°vel. </p><br></li><li><p>  Validar - verifica√ß√£o por n√≥s da rede de transa√ß√µes provenientes do <em>solicitante</em> antes de colocar as informa√ß√µes deles em sua c√≥pia do registro distribu√≠do </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  Essa abordagem permite executar a fase de execu√ß√£o da transa√ß√£o antes que ela entre na rede blockchain, al√©m de dimensionar horizontalmente a opera√ß√£o dos n√≥s da rede. </p><br><h3 id="cheynkod">  Chaincode </h3><br><p>  Um c√≥digo de c√≥digo, que tamb√©m pode ser chamado de contrato inteligente, √© um programa escrito em Golang, JavaScript (HLF 1.1+) ou Java (HLF 1.3+), que define as regras para criar transa√ß√µes que alteram o estado de uma cadeia de blocos.  O programa √© executado simultaneamente em v√°rios n√≥s independentes de uma rede distribu√≠da de n√≥s blockchain, o que cria um ambiente neutro para a execu√ß√£o de contratos inteligentes, reconciliando os resultados da execu√ß√£o do programa em todos os n√≥s necess√°rios para a "confirma√ß√£o" da transa√ß√£o. </p><br><p>  O c√≥digo deve implementar uma interface que consiste em m√©todos: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  O m√©todo <strong>Init</strong> √© chamado na instancia√ß√£o ou atualiza√ß√£o do c√≥digo de c√≥digo.  Este m√©todo executa a inicializa√ß√£o necess√°ria do estado do c√≥digo de c√≥digo.  √â importante distinguir no c√≥digo do m√©todo se a chamada √© uma instancia√ß√£o ou uma atualiza√ß√£o, para que, por engano, voc√™ n√£o inicialize (redefina) os dados que j√° receberam um estado diferente de zero durante a opera√ß√£o do c√≥digo de c√≥digo. </li><li>  O m√©todo <strong>Invoke</strong> √© chamado quando qualquer fun√ß√£o do c√≥digo de c√≥digo √© acessada.  Este m√©todo funciona com o status de contratos inteligentes. </li></ul><br><p>  O chaincode √© instalado nos pares da rede blockchain.  No n√≠vel do sistema, cada inst√¢ncia do c√≥digo corresponde a um docker-container separado conectado a um n√≥ de rede espec√≠fico, que executa o envio de chamadas para a execu√ß√£o do c√≥digo. <br>  Diferentemente dos contratos inteligentes do Ethereum, a l√≥gica de encadeamento pode ser atualizada, mas isso exige que todos os n√≥s que hospedam o c√≥digo instalem uma vers√£o atualizada. </p><br><p>  Em resposta a uma chamada para a fun√ß√£o chaincode do lado de fora via SDK, o chaincode cria uma altera√ß√£o no estado da cadeia de blocos (conjunto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">leitura e grava√ß√£o</a> ), al√©m de eventos.  Um c√≥digo de chamada refere-se a um canal espec√≠fico e pode alterar dados em apenas um canal.  Ao mesmo tempo, se o host no qual o c√≥digo est√° instalado tamb√©m tiver acesso a outros canais, na l√≥gica do c√≥digo poder√° ler dados desses canais. </p><br><p>  Os c√≥digos de cadeia especiais para gerenciar v√°rios aspectos da opera√ß√£o de uma rede blockchain s√£o chamados de c√≥digos de cadeia do sistema. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Pol√≠tica de Endosso </h3><br><p>  Uma pol√≠tica de aprova√ß√£o define regras de consenso no n√≠vel de transa√ß√µes geradas por um c√≥digo de c√≥digo espec√≠fico.  A pol√≠tica define as regras que determinam quais n√≥s do canal devem criar uma transa√ß√£o.  Para fazer isso, cada um dos n√≥s especificados na pol√≠tica de aprova√ß√£o deve iniciar o m√©todo de encadeamento (a etapa "Executar"), executar uma "simula√ß√£o", ap√≥s a qual os resultados assinados ser√£o coletados e verificados pelo SDK que iniciou a transa√ß√£o (todos os resultados da simula√ß√£o devem ser id√™nticos, assinaturas de todos os n√≥s exigidos pela pol√≠tica).  Em seguida, o SDK envia a transa√ß√£o ao <em>ordenador</em> , ap√≥s o qual todos os n√≥s que t√™m acesso ao canal receber√£o a transa√ß√£o atrav√©s do <em>ordenador</em> e executar√£o a etapa "Validar".  √â importante enfatizar que nem todos os n√≥s do canal devem participar da etapa "Executar". </p><br><p>  A pol√≠tica de aprova√ß√£o √© determinada no momento da instancia√ß√£o ou atualiza√ß√£o do c√≥digo.  Na vers√£o 1.3, tornou-se poss√≠vel definir pol√≠ticas n√£o apenas no n√≠vel do c√≥digo de c√≥digo, mas tamb√©m no n√≠vel de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chaves de endosso</a> individuais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baseadas em estado</a> .  Exemplos de pol√≠ticas de aprova√ß√£o: </p><br><ul><li>  N√≥s A, B, C, D </li><li>  A maioria dos n√≥s do canal </li><li>  Pelo menos 3 n√≥s de A, B, C, D, E, F </li></ul><br><h3 id="sobytie">  Evento </h3><br><p>  Um evento √© um conjunto de dados nomeado que permite publicar um "feed de atualiza√ß√£o" do estado da cadeia de blockchain.  O conjunto de atributos do evento define o chaincode. </p><br><h2 id="infrastruktura-seti">  Infraestrutura de rede </h2><br><h3 id="uzel-seti-peer">  Anfitri√£o (Par) </h3><br><p>  Um host est√° conectado a um n√∫mero arbitr√°rio de canais para os quais possui direitos de acesso.  O host mant√©m sua vers√£o da cadeia de blocos e o estado da cadeia de blocos e tamb√©m fornece um ambiente para a execu√ß√£o de c√≥digos de cadeia.  Se o host n√£o fizer parte da pol√≠tica de aprova√ß√£o, ele n√£o precisar√° ser configurado com c√≥digos de cadeia. </p><br><p>  No n√≠vel do software host, o estado atual da cadeia de blocos (estado mundial) pode ser armazenado no LevelDB ou no CouchDB.  A vantagem do CouchDB √© o suporte a consultas avan√ßadas usando a sintaxe do MongoDB. </p><br><h3 id="orderer">  Orderer </h3><br><p>  O servi√ßo de gerenciamento de transa√ß√µes aceita transa√ß√µes assinadas como uma entrada e garante que as transa√ß√µes sejam distribu√≠das pelos n√≥s da rede na ordem correta. </p><br><p>  O ordenador n√£o executa contratos inteligentes e n√£o cont√©m cadeias de blocos e estados de cadeia de blocos.  No momento (1.3), existem duas implementa√ß√µes do <em>ordenador</em> - um <em>solo de</em> desenvolvimento e uma vers√£o baseada no Kafka que fornece toler√¢ncia a falhas de falha.  Espera-se uma implementa√ß√£o do <em>ordenador que</em> suporte a resist√™ncia ao comportamento incorreto de uma certa fra√ß√£o de participantes (toler√¢ncia a falhas bizantinas) no final de 2018. </p><br><h3 id="servis-identifikacii-membership-services">  Servi√ßos de identidade </h3><br><p>  Em uma rede Hyperledger Fabric, todos os membros t√™m identidades conhecidas por outros membros (identidade).  Para identifica√ß√£o, √© usada a infraestrutura de chave p√∫blica (PKI), atrav√©s da qual os certificados X.509 s√£o criados para organiza√ß√µes, elementos de infraestrutura (n√≥, ordenador), aplicativos e usu√°rios finais.  Como resultado, o acesso √† leitura e modifica√ß√£o de dados pode ser controlado pelas regras de acesso no n√≠vel da rede, em um √∫nico canal ou na l√≥gica de um contrato inteligente.  Na mesma rede blockchain, v√°rios servi√ßos de identifica√ß√£o de v√°rios tipos podem funcionar simultaneamente. </p><br><h1 id="realizaciya-cheynkoda">  Implementa√ß√£o do c√≥digo de c√≥digo </h1><br><p>  O c√≥digo de c√≥digo pode ser considerado como um objeto que possui m√©todos que implementam uma l√≥gica de neg√≥cios espec√≠fica.  Diferentemente do OOP cl√°ssico, um c√≥digo de chatice n√£o pode ter campos de atributo.  Para trabalhar com o estado, cujo armazenamento √© fornecido pela plataforma blockchain HLF, √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usada a</a> camada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ChaincodeStubInterface</a> , que √© transmitida quando os m√©todos <em>Init</em> e <em>Invoke</em> s√£o chamados.  Ele fornece a capacidade de receber argumentos de chamada de fun√ß√£o e fazer altera√ß√µes no estado da cadeia de blocos: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  No contrato inteligente da Ethereum desenvolvido no Solidity, cada m√©todo tem uma fun√ß√£o p√∫blica.  No c√≥digo de chamada Hyperledger Fabric, nos m√©todos <em>Init</em> e <em>Invoke</em> , usando a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ChaincodeStubInterface</a> .  <em>GetArgs (),</em> voc√™ pode obter os argumentos da chamada de fun√ß√£o na forma de uma matriz de matrizes de bytes, enquanto o primeiro elemento da matriz ao chamar <em>Invoke</em> cont√©m o nome da fun√ß√£o chaincode.  Porque  Invoke de qualquer m√©todo chaincode passa pelo m√©todo Invoke; podemos dizer que esta √© uma implementa√ß√£o do padr√£o do controlador frontal. </p><br><p>  Por exemplo, se considerarmos a implementa√ß√£o da interface Ethereum padr√£o para o token <a href="">ERC-20</a> , o contrato inteligente deve implementar os m√©todos: </p><br><ul><li>  totalSupply () </li><li>  balanceOf (propriet√°rio _ do endere√ßo) </li><li>  transfer√™ncia (endere√ßo _to, uint256 _value) </li></ul><br><p>  No caso da implementa√ß√£o do HLF, o <em>c√≥digo da</em> fun√ß√£o <em>Invoke</em> deve poder lidar com casos em que o primeiro argumento para chamadas de <em>Invoca√ß√£o</em> cont√©m o nome dos m√©todos esperados (por exemplo, "totalSupply" ou "balanceOf").  Um exemplo da implementa√ß√£o do padr√£o ERC-20 pode ser visto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><h2 id="primery-cheynkodov">  Exemplos de Chaincode </h2><br><p>  Al√©m da documenta√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hyperledger Fabric</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">existem</a> mais alguns exemplos de c√≥digos de cadeia: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplicativo de seguros Blockchain (2018)</a> </li><li>  <a href="">M√°rmores</a> </li><li>  <a href="">Demonstra√ß√£o de loca√ß√£o de carro (2017)</a> s </li></ul><br><p>  A implementa√ß√£o dos c√≥digos de cadeia nesses exemplos √© bastante detalhada e cont√©m muita l√≥gica repetida para selecionar as fun√ß√µes de roteamento chamadas), verificando o n√∫mero de argumentos, json marshalling / unmarshalling: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Essa organiza√ß√£o do c√≥digo leva a uma deteriora√ß√£o da legibilidade do c√≥digo e a poss√≠veis erros, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse</a> , quando voc√™ simplesmente se esquece de desorganizar os dados de entrada.  As apresenta√ß√µes sobre os planos de desenvolvimento do HLF mencionam uma revis√£o da abordagem para o desenvolvimento de c√≥digos de cadeia, em particular a introdu√ß√£o de anota√ß√µes em c√≥digos de cadeia Java, etc.  A experi√™ncia no desenvolvimento de contratos inteligentes levou √† conclus√£o de que o desenvolvimento e o teste de c√≥digos de cadeia ser√£o mais f√°ceis se voc√™ selecionar a funcionalidade b√°sica em uma biblioteca separada. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit - uma biblioteca para desenvolvimento e teste de c√≥digos de cadeia </h1><br><p>  A biblioteca do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CCKit</a> resume a pr√°tica de desenvolvimento e teste de c√≥digos de cadeia.  Como parte do desenvolvimento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extens√µes</a> de c√≥digo de c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, a</a> biblioteca de extens√µes OpenZeppelin para contratos inteligentes Ethereum foi usada como exemplo.  O CCKit usa as seguintes solu√ß√µes arquiteturais: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Encaminhamento de chamadas para fun√ß√µes inteligentes de contrato </h2><br><p>  Roteamento refere-se ao algoritmo pelo qual o aplicativo responde a uma solicita√ß√£o do cliente.  Essa abordagem √© usada, por exemplo, em quase todas as estruturas http.  O roteador usa certas regras para vincular a solicita√ß√£o e o manipulador de solicita√ß√£o.  Em rela√ß√£o a um chaincode, isso √© para associar o nome da fun√ß√£o chaincode √† fun√ß√£o manipulador. </p><br><p>  Nos exemplos mais recentes de contratos inteligentes, por exemplo, no <a href="">aplicativo Insurance</a> , isso usa o mapeamento entre o nome da fun√ß√£o chaincode e a fun√ß√£o no c√≥digo Golang do formul√°rio: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  O roteador CCKit usa uma abordagem semelhante ao roteador http, bem como a capacidade de usar o contexto de solicita√ß√£o para a fun√ß√£o chaincode e as fun√ß√µes de middleware </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  O contexto da chamada para a fun√ß√£o do c√≥digo </h2><br><p>  Semelhante ao contexto de solicita√ß√£o http, que geralmente tem acesso aos par√¢metros de solicita√ß√£o http, o roteador CCKit usa o contexto da chamada para a fun√ß√£o de <a href="">contrato inteligente</a> , que √© uma abstra√ß√£o sobre <em>shim.ChaincodeStubInterface</em> .  O contexto pode ser o √∫nico argumento para o manipulador da fun√ß√£o encadeamento; por meio dele, o manipulador pode receber os argumentos da chamada de fun√ß√£o, al√©m de acessar funcionalidades auxiliares para trabalhar com o estado do contrato inteligente (State), criar respostas (Response) etc. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Porque  O contexto √© uma interface, em certos c√≥digos de cadeia pode ser expandido. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Fun√ß√µes de Middleware </h2><br><p>  As fun√ß√µes de processamento intermedi√°rio (middleware) s√£o chamadas antes da chamada do manipulador do m√©todo do c√≥digo, t√™m acesso ao contexto da chamada para o m√©todo do c√≥digo e √† pr√≥xima fun√ß√£o intermedi√°ria ou diretamente ao manipulador do m√©todo do pr√≥ximo (pr√≥ximo).  O middleware pode ser usado para: </p><br><ul><li>  convers√£o de dados de entrada (no exemplo abaixo, <em>p.String</em> e <em>p.Struct</em> s√£o middleware) </li><li>  restri√ß√µes no acesso √† fun√ß√£o (por exemplo, <em>owner.Only</em> ) </li><li>  conclus√£o do ciclo de processamento da solicita√ß√£o </li><li>  chamando a pr√≥xima fun√ß√£o de processamento intermedi√°rio da pilha </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Convers√£o da estrutura de dados </h2><br><p>  A interface chaincode pressup√µe que uma matriz de matrizes de bytes seja fornecida √† entrada, cujos elementos s√£o um atributo da fun√ß√£o chaincode.  Para impedir o empacotamento manual de dados da matriz de bytes para o tipo de dados golang (int, string, estrutura, matriz) dos argumentos de chamada da fun√ß√£o em cada manipulador da fun√ß√£o de encadeamento, os tipos de dados esperados s√£o definidos no momento da cria√ß√£o da regra de roteamento no roteador CCKit e o tipo √© convertido automaticamente .  No exemplo a <em>seguir</em> , a fun√ß√£o <em>carGet</em> espera um argumento do tipo string e a fun√ß√£o <em>carRegister espera uma</em> estrutura <em>CarPayload</em> .  O argumento tamb√©m √© nomeado, o que permite que o manipulador obtenha seu valor do contexto pelo nome.  Um exemplo de manipulador ser√° fornecido abaixo.  Protobuf tamb√©m pode ser usado para descrever o esquema de dados de encadeamento. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  Al√©m disso, a convers√£o autom√°tica (empacotamento) √© usada ao gravar dados no estado de um contrato inteligente e ao criar eventos (o tipo golang √© serializado em uma matriz de bytes) </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Ferramentas para depura√ß√£o e registro de c√≥digos de cadeia </h2><br><p>  Para depurar o c√≥digo, voc√™ pode usar a extens√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">depura√ß√£o</a> , que implementa m√©todos de contrato inteligente que permitem inspecionar a presen√ßa de chaves no estado do contrato inteligente, al√©m de ler / alterar / excluir diretamente o valor por chave. </p><br><p>  Para efetuar logon no contexto de uma chamada para uma fun√ß√£o chaincode, o m√©todo Log () pode ser usado, que retorna uma inst√¢ncia do logger usado no HLF. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  M√©todos de contrato inteligentes m√©todos de controle de acesso </h2><br><p>  Como parte da extens√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriet√°rio</a> , s√£o implementadas primitivas b√°sicas para armazenar informa√ß√µes sobre o propriet√°rio do c√≥digo de cadeia instanciado e modificadores de acesso (middleware) para m√©todos de contrato inteligentes. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Ferramentas de Teste de Contrato Inteligente </h2><br><p>  A implanta√ß√£o da rede blockchain, a instala√ß√£o e a inicializa√ß√£o de c√≥digos de cadeia √© uma configura√ß√£o bastante complicada e um longo procedimento.  O tempo para reinstalar / atualizar o c√≥digo do contrato inteligente pode ser reduzido usando o modo DEV do contrato inteligente; no entanto, o processo de atualiza√ß√£o do c√≥digo ainda ser√° lento. </p><br><p>  O pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">shim</a> cont√©m uma implementa√ß√£o do <a href="">MockStub</a> , que envolve chamadas para o c√≥digo, simulando sua opera√ß√£o no ambiente blockchain HLF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O uso do MockStub</a> permite obter resultados de teste quase instantaneamente e reduzir o tempo de desenvolvimento.  Se considerarmos o esquema geral de opera√ß√£o do c√≥digo no HLF, o MockStub basicamente substitui o SDK, permitindo fazer chamadas para as fun√ß√µes do c√≥digo e imita o ambiente de inicializa√ß√£o do c√≥digo no host. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  O MockStub da entrega HLF cont√©m a implementa√ß√£o de quase todos os m√©todos da interface <em>shim.ChaincodeStubInterface</em> , no entanto, na vers√£o atual (1.3), falta a implementa√ß√£o de alguns m√©todos importantes, como GetCreator.  Porque  O c√≥digo da cadeia pode usar esse m√©todo para obter um certificado de um criador da transa√ß√£o para controle de acesso, para obter cobertura m√°xima em testes, √© importante a capacidade de ter um esbo√ßo desse m√©todo. </p><br><p>  A biblioteca do CCKit cont√©m uma vers√£o estendida do <a href="">MockStub</a> , que cont√©m a implementa√ß√£o dos m√©todos ausentes, bem como m√©todos para trabalhar com canais de eventos, etc. </p><br><h2 id="primer-cheynkoda">  Exemplo de Chaincode </h2><br><p>  Por exemplo, vamos criar um c√≥digo de c√≥digo simples para armazenar informa√ß√µes sobre carros registrados </p><br><h3 id="model-dannyh">  Modelo de dados </h3><br><p>  O estado do c√≥digo de c√≥digo √© o armazenamento do valor-chave, no qual a chave √© uma sequ√™ncia, o valor √© uma matriz de bytes.  A pr√°tica b√°sica √© armazenar inst√¢ncias de estruturas de dados golang jonalizadas como valores.  Portanto, para trabalhar com dados no c√≥digo de c√≥digo, ap√≥s a leitura do estado, √© necess√°rio desmarcar a matriz de bytes. </p><br><p>  Para gravar sobre o carro, usaremos o seguinte conjunto de atributos: </p><br><ul><li>  Identificador (n√∫mero do carro) </li><li>  Modelo de carro </li><li>  Informa√ß√µes sobre o propriet√°rio do ve√≠culo </li><li>  Informa√ß√µes sobre hor√°rio de altera√ß√£o de dados </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  Para transferir dados para o c√≥digo de c√≥digo, crie uma estrutura separada contendo apenas os campos provenientes de fora do c√≥digo de c√≥digo: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Trabalhar com chaves </h3><br><p>  Chaves de registro em um estado de contrato inteligente √© uma sequ√™ncia.  Ele tamb√©m suporta a capacidade de criar chaves compostas nas quais partes da chave s√£o separadas por um byte zero ( <em>U + 0000</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  No <em>CCKit, as</em> fun√ß√µes de trabalhar com o estado de um contrato inteligente podem criar automaticamente chaves para registros se as estruturas transferidas suportarem a interface <em>Keyer</em> </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  Para gravar um carro, a fun√ß√£o de gera√ß√£o de chaves ser√° a seguinte: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  Declara√ß√£o de fun√ß√£o de contrato inteligente (roteiro) </h3><br><p>  No m√©todo construtor do chaincode, podemos definir as fun√ß√µes do chaincode e seus argumentos.  Haver√° 3 fun√ß√µes no c√≥digo de registro do carro </p><br><ul><li>  carList, retorna uma matriz de estruturas Car </li><li>  carGet, aceita um identificador de carro e retorna uma estrutura de carro </li><li>  carRegister, aceita uma inst√¢ncia serializada da estrutura CarPayload e retorna o resultado do registro.  O acesso a esse m√©todo √© poss√≠vel apenas para o propriet√°rio do c√≥digo de c√≥digo, que √© salvo usando o middleware do pacote do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propriet√°rio.</a> </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  O exemplo acima usa a estrutura <a href="">Chaincode</a> na qual o processamento dos m√©todos <em>Init</em> e <em>Invoke</em> √© delegado ao roteador: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  O uso de um roteador e a estrutura b√°sica do Chaincode permite a reutiliza√ß√£o de fun√ß√µes do manipulador.  Por exemplo, para implementar o c√≥digo de c√≥digo sem verificar o acesso √† fun√ß√£o <code>carRegister</code> , ser√° suficiente criar um novo <a href="">m√©todo construtor</a> </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Implementa√ß√£o das fun√ß√µes de um contrato inteligente </h3><br><p>  Fun√ß√µes Golang - manipuladores de fun√ß√µes de contrato inteligentes no roteador <strong>CCKit</strong> podem ser de tr√™s tipos: </p><br><ul><li>  <em>StubHandlerFunc</em> - a interface do manipulador padr√£o, aceita <em>shim.ChaincodeStubInterface</em> , retorna a resposta padr√£o <em>peer.Response</em> </li><li>  <em>ContextHandlerFunc</em> - pega um contexto e retorna <em>peer.Response</em> </li><li>  <em>HandlerFunc</em> - pega um contexto, retorna uma interface e um erro.  Uma matriz de bytes pode ser retornada ou qualquer tipo de golang que √© automaticamente convertido em uma matriz de bytes com base na qual <em>peer.Response</em> √© criada.  O status da resposta ser√° <em>shim.Ok</em> ou <em>shim.Error</em> , dependendo do erro passado. </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p>   ,   ,           (   CarPayload) <br>    State ,                      (      ) </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta">  - </h3><br><p>    -       ‚Äî        ,     .      BDD ‚Äì Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Porque   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426705/">https://habr.com/ru/post/pt426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426695/index.html">C√¢meras de vis√£o de m√°quina para entusiastas. Como usar a c√¢mera para navega√ß√£o offline?</a></li>
<li><a href="../pt426697/index.html">Trabalhando com dispositivos LibUsb no Android</a></li>
<li><a href="../pt426699/index.html">Teste de Python com pytest. Simples, r√°pido, eficiente e escal√°vel. Pref√°cio e Introdu√ß√£o</a></li>
<li><a href="../pt426701/index.html">Flutter - uma nova vis√£o do desenvolvimento de plataforma cruzada</a></li>
<li><a href="../pt426703/index.html">O que foi interessante no DataVizDay em Minsk</a></li>
<li><a href="../pt426707/index.html">Sistema de aprova√ß√£o. Como inventamos a bicicleta</a></li>
<li><a href="../pt426709/index.html">Temporizadores JavaScript: tudo o que voc√™ precisa saber</a></li>
<li><a href="../pt426713/index.html">Intel Xeon W-3175X: 28 n√∫cleos para o lar</a></li>
<li><a href="../pt426717/index.html">A ilus√£o da decep√ß√£o: uma ilus√£o de √≥tica visual baseada na previs√£o retroativa</a></li>
<li><a href="../pt426719/index.html">Hackathon sobre Ci√™ncia de Dados no SIBUR: como foi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>