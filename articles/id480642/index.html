<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒƒ ğŸ“˜ ğŸ¯ Pengantar Linux ELF: Memahami dan Menganalisis ğŸŒ” ğŸ‘¨ğŸ»â€ğŸ¨ ğŸ—‘ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada hal-hal di dunia yang kita anggap remeh, meskipun itu adalah mahakarya sejati. Satu hal seperti itu adalah utilitas Linux seperti ls dan ps. Meski...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Linux ELF: Memahami dan Menganalisis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480642/"> Ada hal-hal di dunia yang kita anggap remeh, meskipun itu adalah mahakarya sejati.  Satu hal seperti itu adalah utilitas Linux seperti ls dan ps.  Meskipun mereka biasanya dianggap sederhana, ini jauh dari kasus jika kita melihat ke dalam.  Demikian juga ELF, Format yang Dapat Dieksekusi, dan Dapat Ditautkan.  Format file yang digunakan secara universal, tetapi sedikit yang memahaminya.  Panduan singkat ini akan membantu Anda memahami. <br><br><img src="https://habrastorage.org/webt/ka/0m/em/ka0memy9zppvjiut58hua0_cyt8.jpeg"><br><br>  Setelah membaca panduan ini, Anda akan belajar: <br><br><ul><li>  Mengapa format ELF diperlukan dan untuk jenis file apa digunakan? </li><li>  Struktur file ELF dan detail format </li><li>  Cara membaca dan menganalisis konten biner dari file ELF </li><li>  Alat apa yang digunakan untuk menganalisis file biner? </li></ul><a name="habracut"></a><br><h2>  Apa itu file ELF? </h2><br>  ELF adalah singkatan dari Executable and Linkable Format, dan mendefinisikan struktur file biner, pustaka, dan file inti.  Spesifikasi format memungkinkan sistem operasi untuk menafsirkan instruksi mesin yang terkandung dalam file dengan benar.  File ELF biasanya merupakan file output dari kompiler atau linker dan memiliki format biner.  Dengan menggunakan alat yang sesuai, dapat dianalisis dan dipelajari. <br><br><h3>  Mengapa mempelajari ELF secara detail? </h3><br>  Sebelum masuk ke detail teknis, tidak akan salah menjelaskan mengapa memahami format ELF berguna.  Pertama, ini memungkinkan Anda untuk mempelajari operasi internal sistem operasi.  Ketika terjadi kesalahan, pengetahuan ini akan membantu Anda lebih memahami apa yang sebenarnya terjadi dan untuk alasan apa.  Selain itu, kemampuan untuk memeriksa file ELF dapat bermanfaat untuk menemukan lubang keamanan dan mendeteksi file yang mencurigakan.  Dan akhirnya, untuk pemahaman yang lebih baik tentang proses pengembangan.  Bahkan jika Anda memprogram dalam bahasa tingkat tinggi seperti Go, Anda masih akan lebih tahu apa yang terjadi di balik layar. <br><br>  Jadi mengapa belajar ELF? <br><br><ul><li>  Untuk pemahaman umum tentang sistem operasi </li><li>  Untuk pengembangan perangkat lunak </li><li>  Digital Forensik dan Respon Insiden (DFIR) </li><li>  Penelitian malware (analisis biner) </li></ul><br><h3>  Dari sumber ke proses </h3><br>  Apapun sistem operasi yang kita gunakan, penting untuk menerjemahkan fungsi kode sumber ke dalam bahasa CPU - kode mesin.  Fungsinya bisa menjadi yang paling mendasar, misalnya membuka file di disk atau menampilkan sesuatu di layar.  Alih-alih menggunakan bahasa CPU secara langsung, kami menggunakan bahasa pemrograman yang memiliki fitur standar.  Kompiler kemudian menerjemahkan fungsi-fungsi ini ke dalam kode objek.  Kode objek ini kemudian ditautkan ke dalam program lengkap, dengan menggunakan tautan.  Hasilnya adalah file biner yang dapat dieksekusi pada platform tertentu dan tipe CPU tertentu. <br><br><h3>  Sebelum Anda mulai </h3><br>  Posting ini mengandung banyak tim.  Lebih baik menjalankannya di mesin uji.  Salin binari yang ada sebelum menjalankan perintah ini pada mereka.  Kami juga akan menulis program C kecil yang dapat Anda kompilasi.  Pada akhirnya, latihan adalah cara terbaik untuk mempelajari sesuatu. <br><br><h2>  Anatomi File ELF </h2><br>  Kesalahpahaman yang umum adalah bahwa file ELF hanya untuk file biner atau file yang dapat dieksekusi.  Kami telah mengatakan bahwa mereka dapat digunakan untuk bagian file yang dapat dieksekusi (kode objek).  Contoh lain adalah file perpustakaan dan dump inti (file inti dan file a.out).  Spesifikasi ELF juga digunakan di Linux untuk modul kernel dan kernel. <br><br><img src="https://habrastorage.org/webt/dt/5y/vq/dt5yvqm-oju3s6todxbbd6ivzw0.png"><br><br><h3>  Struktur </h3><br>  Karena ekstensibilitas file ELF, struktur dapat bervariasi untuk file yang berbeda.  File ELF terdiri dari: <br><br><ol><li>  Header ELF </li><li>  data </li></ol><br>  Dengan perintah readelf, kita dapat melihat struktur file, dan itu akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/vo/ng/w-/vongw-d8cy_mvkf9jgcizbdpq0c.png"><br><br><h3>  Header ELF </h3><br>  Seperti yang dapat Anda lihat di tangkapan layar, header ELF dimulai dengan "angka ajaib".  "Angka ajaib" ini memberikan informasi tentang file.  4 byte pertama menentukan bahwa ini adalah file ELF (45 = E, 4c = L, 46 = F, mereka didahului oleh 7f). <br><br>  Diperlukan header ELF.  Diperlukan agar data ditafsirkan dengan benar selama menghubungkan dan eksekusi.  Untuk pemahaman yang lebih baik tentang operasi internal file ELF, penting untuk mengetahui untuk apa informasi ini digunakan. <br><br><h3>  Kelas </h3><br>  Setelah mendeklarasikan tipe ELF, bidang kelas mengikuti.  Nilai ini berarti arsitektur yang menjadi tujuan file.  Itu bisa 01 (arsitektur 32-bit) atau 02 (64-bit).  Di sini kita melihat 02, yang diterjemahkan oleh perintah readelf sebagai file ELF64, yaitu, dengan kata lain, file ini menggunakan arsitektur 64-bit.  Ini tidak mengherankan, prosesor modern dipasang di mobil saya. <br><br><h3>  Data </h3><br>  Selanjutnya muncul bidang "data", yang memiliki dua opsi: 01 - LSB (Least Significant Bit), juga dikenal sebagai little-endian, atau 02 - MSB (Most Significant Bit, big-endian).  Nilai-nilai ini membantu menafsirkan sisa objek dalam file.  Ini penting karena berbagai jenis prosesor menangani struktur data secara berbeda.  Dalam kasus kami, LSB digunakan, karena prosesor memiliki arsitektur AMD64. <br><br>  Efek LSB menjadi terlihat saat menggunakan utilitas hexdump pada file biner.  Mari kita lihat header ELF untuk / bin / ps. <br><br><pre><code class="bash hljs">$ hexdump -n 16 /bin/ps 0000000 457f 464c 0102 0001 0000 0000 0000 0000 0000010</code> </pre> <br>  Kami melihat bahwa pasangan nilai berbeda, karena interpretasi urutan data. <br><br><h3>  Versi </h3><br>  Kemudian ikuti nilai magis lainnya "01", yang merupakan nomor versi.  Hanya versi 01 yang saat ini tersedia, jadi angka ini tidak berarti sesuatu yang menarik. <br><br><h3>  OS / ABI </h3><br>  Setiap sistem operasi memiliki caranya sendiri untuk memanggil fungsi, mereka memiliki banyak kesamaan, tetapi, di samping itu, setiap sistem memiliki perbedaan kecil.  Urutan pemanggilan fungsi ditentukan oleh Application Binary Interface (ABI).  Kolom OS / ABI menjelaskan ABI mana yang digunakan dan versinya.  Dalam kasus kami, nilainya adalah 00, yang berarti ekstensi spesifik tidak digunakan.  Dalam output, ini ditampilkan sebagai Sistem V. <br><br><h3>  Versi ABI </h3><br>  Jika perlu, versi ABI dapat diindikasikan. <br><br><h3>  Mobil </h3><br>  Judul juga menunjukkan jenis mesin yang diharapkan (AMD64). <br><br><h3>  Jenis </h3><br>  Bidang jenis menunjukkan untuk apa file itu.  Berikut adalah beberapa tipe file umum. <br><br>  INTI (nilai 4) <br>  DYN (File objek bersama), pustaka (nilai 3) <br>  EXEC (File yang dapat dieksekusi), file yang dapat dieksekusi (nilai 2) <br>  REL (File yang dapat dipindahkan), file sebelum menautkan (nilai 1) <br><br><h3>  Lihat judul lengkapnya </h3><br>  Meskipun beberapa bidang dapat dilihat melalui readelf, sebenarnya ada lebih banyak.  Misalnya, Anda dapat mengetahui prosesor untuk file mana.  Gunakan hexdump untuk melihat header ELF lengkap dan semua nilai. <br><br><pre> <code class="bash hljs">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 02 00 3e 00 01 00 00 00 a8 2b 40 00 00 00 00 00 |..&gt;......+@.....| 40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00 |@.......0e......| 00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00 |....@.8...@.....|</code> </pre> <br>  (output hexdump -C -n 64 / bin / ps) <br><br>  Bidang yang disorot menentukan jenis mesin.  Nilai 3e adalah desimal 62, yang sesuai dengan AMD64.  Untuk mendapatkan gambaran tentang semua jenis file, lihat file header <a href="" rel="nofollow">ini</a> . <br><br>  Meskipun Anda dapat melakukan semua ini dalam dump heksadesimal, masuk akal untuk menggunakan alat yang berfungsi untuk Anda.  Utilitas dumpelf mungkin berguna.  Ini menunjukkan output yang diformat cocok dengan header ELF.  Akan baik untuk mempelajari bidang mana yang digunakan, dan apa nilai khasnya. <br><br>  Sekarang, di mana kami telah menjelaskan arti dari bidang-bidang ini, sekarang saatnya untuk melihat apa sebenarnya sihir di belakangnya dan beralih ke judul berikutnya! <br><br><h3>  File data </h3><br>  Selain header, file ELF terdiri dari tiga bagian. <br><br><ul><li>  Header atau Segmen Program </li><li>  Bagian atau Judul Bagian </li><li>  Data </li></ul><br>  Sebelum kita menyelami header ini, akan berguna untuk mengetahui bahwa file ELF memiliki dua "tipe" yang berbeda.  Salah satunya dirancang untuk tautan dan memungkinkan eksekusi kode (segmen).  Yang lainnya adalah untuk perintah dan data (bagian).  Tergantung pada tujuannya, jenis header yang sesuai digunakan.  Mari kita mulai dengan tajuk program, yang terletak di file yang dapat dieksekusi ELF. <br><br><h3>  Judul program </h3><br>  File ELF terdiri dari nol atau lebih segmen, dan menjelaskan cara membuat proses, gambar memori untuk eksekusi runtime.  Ketika kernel melihat segmen ini, ia menempatkannya di ruang alamat virtual menggunakan panggilan sistem mmap (2).  Dengan kata lain, itu mengubah instruksi yang sudah disiapkan menjadi gambar dalam memori.  Jika file ELF adalah biner biasa, ia membutuhkan tajuk program ini, jika tidak maka tidak akan berfungsi.  Header ini digunakan, bersama dengan struktur data yang sesuai, untuk membentuk proses.  Untuk pustaka bersama, prosesnya mirip. <br><br><img src="https://habrastorage.org/webt/p4/ja/c_/p4jac_lojwvn9movhy8w5rad1g0.png"><br>  Header program dalam file ELF biner <br><br>  Kita melihat 9 judul program dalam contoh ini.  Pada awalnya sulit untuk memahami apa artinya.  Mari selami rinciannya. <br><br><h3>  GNU_EH_FRAME </h3><br>  Ini adalah antrian yang diurutkan yang digunakan oleh kompiler GCC.  Ini menyimpan penangan pengecualian.  Jika terjadi kesalahan, mereka digunakan untuk menangani situasi dengan benar. <br><br><h3>  GNU_STACK </h3><br>  Header ini digunakan untuk menyimpan informasi tumpukan.  Fitur yang menarik adalah bahwa stack tidak harus dapat dieksekusi, karena ini dapat menyebabkan kerentanan keamanan. <br><br>  Jika segmen GNU_STACK hilang, tumpukan dieksekusi digunakan.  Utilitas scanelf dan execstack menunjukkan detail perangkat stack. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># scanelf -e /bin/ps TYPE STK/REL/PTL FILE ET_EXEC RW- R-- RW- /bin/ps # execstack -q /bin/ps - /bin/ps</span></span></code> </pre> <br>  Perintah untuk melihat tajuk program: <br><br><ul><li>  dumpelf (pax-utils) </li><li>  elfls -S / bin / ps </li><li>  eu-readelf â€“program-header / bin / ps </li></ul><br><h3>  Bagian ELF </h3><br><h4>  Tajuk Bagian </h4><br>  Header bagian menentukan semua bagian file.  Seperti yang telah disebutkan, informasi ini digunakan untuk menghubungkan dan relokasi. <br><br>  Bagian muncul dalam file ELF setelah kompiler GNU C mengubah kode C menjadi assembler, dan assembler GNU membuat objek. <br><br>  Seperti yang ditunjukkan pada gambar di atas, sebuah segmen dapat memiliki 0 bagian atau lebih.  Ada empat bagian utama untuk file yang dapat dieksekusi: .text, .data, .rodata, dan .bss.  Masing-masing bagian ini boot dengan izin yang berbeda, yang dapat dilihat dengan readelf -S. <br><br><h4>  .text </h4><br>  Berisi kode yang dapat dieksekusi.  Ini akan dikemas dalam segmen dengan hak baca dan eksekusi.  Itu diunduh satu kali, dan isinya tidak berubah.  Ini dapat dilihat dengan utilitas objdump. <br><br><pre> <code class="bash hljs">12 .text 0000a3e9 0000000000402120 0000000000402120 00002120 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE</code> </pre> <br><h4>  . data </h4><br>  Data diinisialisasi dengan izin baca dan tulis. <br><br><h4>  .rodata </h4><br>  Data diinisialisasi dengan izin hanya-baca.  (= A). <br><br><h4>  .bss </h4><br>  Data tidak diinisialisasi dengan izin baca / tulis.  (= WA) <br><br><pre> <code class="bash hljs">[24] .data PROGBITS 00000000006172e0 000172e0 0000000000000100 0000000000000000 WA 0 0 8 [25] .bss NOBITS 00000000006173e0 000173e0 0000000000021110 0000000000000000 WA 0 0 32</code> </pre> <br><br>  Perintah untuk melihat bagian dan judul. <br><br><ul><li>  dumpelf </li><li>  elfls -p / bin / ps </li><li>  eu-readelf â€“section-header / bin / ps </li><li>  readelf -S / bin / ps </li><li>  objdump -h / bin / ps </li></ul><br><h4>  Grup Bagian </h4><br>  Beberapa bagian dapat dikelompokkan seolah-olah mereka membentuk satu kesatuan.  Linker baru mendukung fungsi ini.  Tetapi sementara ini tidak umum. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># readelf -g /bin/ps There are no section groups in this file.</span></span></code> </pre> <br>  Meskipun ini mungkin tampak tidak terlalu menarik, pengetahuan tentang alat analisis file ELF memberikan manfaat besar.  Untuk alasan ini, ikhtisar alat-alat ini dan tujuannya diberikan pada akhir artikel. <br><br><h3>  Binari statis dan dinamis </h3><br>  Saat berurusan dengan binari ELF, akan berguna untuk mengetahui bagaimana kedua jenis file ini ditautkan.  Mereka bisa statis dan dinamis, dan ini berlaku untuk perpustakaan yang mereka gunakan.  Jika biner "dinamis", itu berarti ia menggunakan pustaka eksternal yang berisi beberapa fungsi umum, seperti membuka file atau membuat soket jaringan.  Sebaliknya, biner statis menyertakan semua perpustakaan yang diperlukan. <br><br>  Jika Anda ingin memeriksa apakah file itu statis atau dinamis, gunakan perintah file.  Dia akan menunjukkan sesuatu seperti ini: <br><br><pre> <code class="bash hljs">$ file /bin/ps /bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;b&gt;dynamically linked (uses shared libs)&lt;/b&gt;, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped</code> </pre> <br>  Untuk menentukan perpustakaan eksternal mana yang digunakan, cukup gunakan ldd pada biner yang sama: <br><br><pre> <code class="bash hljs">$ ldd /bin/ps linux-vdso.so.1 =&gt; (0x00007ffe5ef0d000) libprocps.so.3 =&gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000) /lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)</code> </pre> <br>  Tip: Untuk melihat dependensi lebih lanjut, lebih baik menggunakan utilitas lddtree. <br><br><h2>  Alat analisis biner </h2><br>  Jika Anda ingin menganalisis file ELF, pasti akan berguna untuk melihat alat yang ada terlebih dahulu.  Ada toolkit untuk membalikkan pengembangan binari dan kode yang dapat dieksekusi.  Jika Anda baru menganalisis file ELF, mulailah dengan analisis statis.  Analisis statis menyiratkan bahwa kami memeriksa file tanpa memulainya.  Ketika Anda mulai lebih memahami pekerjaan mereka, beralihlah ke analisis dinamis.  Jalankan contoh dan lihat perilaku nyata mereka. <br><br><h3>  Alat populer </h3><br><h4>  Radare2 </h4><br>  Toolkit Radare2 diciptakan oleh Sergi Alvarez.  Angka 2 menyiratkan bahwa kode telah sepenuhnya ditulis ulang dibandingkan dengan versi pertama.  Sekarang ini digunakan oleh banyak peneliti untuk mempelajari operasi kode. <br><br><h4>  Paket perangkat lunak </h4><br>  Sebagian besar sistem Linux sudah menginstal binutils.  Paket lain dapat membantu Anda melihat informasi lebih lanjut.  Toolkit yang benar akan menyederhanakan pekerjaan Anda, terutama jika Anda menganalisis file ELF.  Saya telah menyusun di sini daftar paket dan utilitas untuk menganalisis file ELF. <br><br>  <b>elfutils</b> <br>  / usr / bin / eu-addr2line <br>  / usr / bin / eu-ar - alternatif untuk ar, untuk membuat dan memproses file arsip <br>  / usr / bin / eu-elfcmp <br>  / usr / bin / eu-elflint - periksa kepatuhan dengan spesifikasi gABI dan psABI <br>  / usr / bin / eu-findtextrel - mencari relokasi teks <br>  / usr / bin / eu-ld - menggabungkan objek dan arsip file <br>  / usr / bin / eu-make-debug-arsip <br>  / usr / bin / eu-nm - menunjukkan simbol-simbol objek dan file yang dapat dieksekusi <br>  / usr / bin / eu-objdump - menampilkan informasi dari file objek <br>  / usr / bin / eu-ranlib - membuat indeks file arsip <br>  / usr / bin / eu-readelf - menampilkan file ELF dalam bentuk yang dapat dibaca <br>  / usr / bin / eu-size - menunjukkan ukuran setiap bagian (teks, data, bss, dll) <br>  / usr / bin / eu-stack - menunjukkan tumpukan proses saat ini atau dump kernel <br>  / usr / bin / eu-string - menampilkan string teks (seperti utilitas string) <br>  / usr / bin / eu-strip - menghapus tabel karakter dari file ELF <br>  / usr / bin / eu-unstrip - menambahkan simbol dan informasi debug ke biner <br>  Catatan: paket elfutils akan menjadi awal yang baik, ini berisi sebagian besar alat analisis <br><br>  <b>elfkickers</b> <br>  / usr / bin / ebfc - kompiler bahasa Brainfuck <br>  / usr / bin / elfls - menampilkan header program dan header bagian dengan flag <br>  / usr / bin / elftoc - mengkonversi biner ke program C. <br>  / usr / bin / infect - sebuah utilitas yang menginjeksi sebuah dropper menciptakan file setuid di / tmp <br>  / usr / bin / objres - membuat objek dari data biasa atau biner <br>  / usr / bin / rebind - mengubah pengikatan dan visibilitas karakter dalam file ELF <br>  / usr / bin / sstrip - menghapus komponen yang tidak perlu dari file ELF <br>  Catatan: penulis paket ELFKickers berfokus pada memanipulasi file ELF, yang memungkinkan Anda untuk mendapatkan informasi lebih lanjut ketika bekerja dengan binari ELF "salah" <br><br>  <b>pax-utils</b> <br>  / usr / bin / dumpelf - dump dari struktur ELF internal <br>  / usr / bin / lddtree - seperti ldd, dengan mengatur tingkat ketergantungan yang ditampilkan <br>  / usr / bin / pspax - menampilkan informasi ELF / PaX tentang proses yang sedang berjalan <br>  / usr / bin / scanelf - berbagai informasi, termasuk detail PaX <br>  / usr / bin / scanmacho - menampilkan detail binari Mach-O (Mac OS X) <br>  / usr / bin / symtree - menunjukkan karakter pohon <br>  Catatan: beberapa utilitas dalam paket ini dapat memindai direktori secara rekursif, dan sangat ideal untuk menganalisis seluruh isi direktori.  Fokusnya adalah pada alat penelitian PaX.  Selain mendukung ELF, Anda dapat mengekstrak informasi dari binari Mach-O. <br><br>  Contoh keluaran <br><pre> <code class="bash hljs">scanelf -a /bin/ps TYPE PAX PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE ET_EXEC PeMRxS 0755 LE RW- R-- RW- - - LAZY /bin/ps</code> </pre> <br><br>  <b>prelink</b> <br>  / usr / bin / execstack - Anda dapat melihat atau mengubah informasi tentang apakah stack dapat dieksekusi <br>  / usr / bin / prelink - memindahkan panggilan dalam file ELF untuk mempercepat proses <br><br><h2>  Pertanyaan yang Sering Diajukan </h2><br><h3>  Apa itu ABI? </h3><br>  ABI adalah Application Binary Interface dan mendefinisikan antarmuka tingkat rendah antara sistem operasi dan kode yang dapat dieksekusi. <br><br><h3>  Apa itu ELF? </h3><br>  ELF adalah Format yang Dapat Dieksekusi dan Dihubungkan.  Ini adalah spesifikasi format yang menentukan bagaimana instruksi ditulis dalam kode yang dapat dieksekusi. <br><br><h3>  Bagaimana saya bisa melihat jenis file? </h3><br>  Gunakan perintah file untuk analisis tahap pertama.  Perintah ini dapat menunjukkan detail yang diambil dari angka dan judul "ajaib". <br><br><h2>  Kesimpulan </h2><br>  File ELF untuk eksekusi dan penautan.  Tergantung pada tujuannya, mereka berisi segmen dan bagian yang diperlukan.  Kernel OS memindai segmen dan memetakannya ke dalam memori (menggunakan mmap).  Bagian dilihat oleh tautan yang membuat file yang dapat dieksekusi atau objek bersama. <br><br>  File ELF sangat fleksibel dan mendukung berbagai jenis CPU, arsitektur mesin, dan sistem operasi.  Ini juga dapat diperluas, setiap file dirancang secara berbeda, tergantung pada bagian yang diperlukan.  Dengan menggunakan alat yang tepat, Anda dapat mengetahui tujuan file dan memeriksa isi file biner.  Anda dapat melihat fungsi dan garis yang terdapat dalam file.  Awal yang baik bagi mereka yang meneliti malware, atau untuk memahami mengapa proses berperilaku (atau tidak) dengan cara tertentu. <br><br><h2>  Sumber daya untuk studi lebih lanjut </h2><br>  Jika Anda ingin tahu lebih banyak tentang ELF dan rekayasa balik, Anda dapat melihat pekerjaan yang kami lakukan di Linux Security Expert.  Sebagai bagian dari kurikulum, kami memiliki <a href="https://linuxsecurity.expert/training/domains/reverse-engineering" rel="nofollow">modul rekayasa terbalik</a> dengan praktikum langsung. <br><br>  Bagi Anda yang suka membaca, dokumen yang bagus dan mendalam: <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" rel="nofollow">Format ELF</a> dan <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">makalah yang ditulis oleh</a> Brian Raiter, juga dikenal sebagai ELFkickers.  Bagi mereka yang suka memahami sumbernya, lihat <a href="" rel="nofollow">tajuk ELF</a> Apple yang <a href="" rel="nofollow">terdokumentasi</a> . <br><br>  Kiat: <br>  Jika Anda ingin menjadi lebih baik dalam menganalisis file, mulailah menggunakan <a href="https://linuxsecurity.expert/security-tools/binary-analysis-tools" rel="nofollow">alat analisis populer</a> yang saat ini tersedia. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480642/">https://habr.com/ru/post/id480642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480614/index.html">ENUM cepat</a></li>
<li><a href="../id480618/index.html">Permainan elektronik Tic Tac Toe. Apa yang telah saya lakukan?</a></li>
<li><a href="../id480620/index.html">SD-WAN dan DNA untuk membantu administrator: fitur arsitektur dan praktik</a></li>
<li><a href="../id480622/index.html">Cara menggunakan kapasitas penyimpanan yang tersedia dengan benar</a></li>
<li><a href="../id480626/index.html">Warisan sistem dan proses warisan atau 90 hari pertama dalam peran CTO</a></li>
<li><a href="../id480644/index.html">Manifesto tentang penghapusan 146 KUHP dan boikot Sberbank dan pemegang hak cipta-parasit. Untuk open source dan nginx</a></li>
<li><a href="../id480646/index.html">Habr - artikel terbaik, penulis, dan statistik 2019</a></li>
<li><a href="../id480650/index.html">Rambut siapa yang lebih kuat: morfologi rambut</a></li>
<li><a href="../id480652/index.html">Kamera PoE 250 meter melalui kabel - itu mungkin</a></li>
<li><a href="../id480654/index.html">Akankah Julia mengalahkan Python seperti halnya Python yang dilakukan Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>