<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëß üéá üëÇ Processamento de dados competitivo heterog√™neo em tempo real estritamente uma vez üò∏ üì• ‚ÜóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anota√ß√£o 


 O processamento de dados em tempo real exatamente uma vez ( exatamente uma vez ) √© uma tarefa extremamente n√£o trivial e requer uma abord...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Processamento de dados competitivo heterog√™neo em tempo real estritamente uma vez</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="Salsicha competitiva"></p><br><h2 id="annotaciya">  Anota√ß√£o </h2><br><p>  O processamento de dados em tempo real exatamente uma vez ( <em>exatamente uma vez</em> ) √© uma tarefa extremamente n√£o trivial e requer uma abordagem s√©ria e ponderada em toda a cadeia de c√°lculos.  Alguns at√© acreditam que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">essa tarefa √© imposs√≠vel</a> .  Na realidade, quero ter uma abordagem que forne√ßa processamento tolerante a falhas sem demora e o uso de v√°rios armazenamentos de dados, o que apresenta novos requisitos ainda mais rigorosos para o sistema: <em>simult√¢neo exatamente uma vez</em> e a heterogeneidade da camada persistente.  At√© o momento, esse requisito n√£o suporta nenhum dos sistemas existentes. </p><br><p>  A abordagem proposta revelar√° consistentemente os ingredientes secretos e os conceitos necess√°rios que tornam relativamente f√°cil implementar o processamento <em>simult√¢neo</em> heterog√™neo <em>exatamente uma vez</em> literalmente a partir de dois componentes. </p><br><h2 id="vvedenie">  1. Introdu√ß√£o </h2><br><p>  O desenvolvedor de sistemas distribu√≠dos passa por v√°rias etapas: </p><br><p>  <em>Etapa 1: Algoritmos</em> .  Aqui est√° o estudo de algoritmos b√°sicos, estruturas de dados, abordagens de programa√ß√£o como OOP, etc.  O c√≥digo √© exclusivamente de thread √∫nico.  A fase inicial de ingresso na profiss√£o.  No entanto, √© bastante complicado e pode durar anos. </p><br><p>  <em>Etapa 2: Multithreading</em> .  Em seguida, surgem quest√µes sobre como extrair a m√°xima efici√™ncia do ferro, h√° multithreading, assincronia, corrida, depura√ß√£o, strace, noites sem dormir ... Muitos ficam presos nesse est√°gio e at√© come√ßam a sentir uma emo√ß√£o inexplic√°vel em algum momento.  Mas apenas alguns conseguem entender a arquitetura da mem√≥ria virtual e dos modelos de mem√≥ria, algoritmos sem bloqueio / sem espera e v√°rios modelos ass√≠ncronos.  E quase ningu√©m nunca - verifica√ß√£o de c√≥digo multithread. </p><br><p>  <em>Etapa 3: Distribui√ß√£o</em> .  Aqui est√° acontecendo um lixo que nem um conto de fadas nem uma caneta descrevem. </p><a name="habracut"></a><br><p>  Parece que algo complicado.  Fazemos a transforma√ß√£o: muitos threads -&gt; muitos processos -&gt; muitos servidores.  Mas cada passo da transforma√ß√£o traz mudan√ßas qualitativas, e todas elas caem no sistema, esmagando-o e transformando-o em p√≥. </p><br><p>  E o objetivo aqui √© alterar o dom√≠nio de tratamento de erros e a disponibilidade de mem√≥ria compartilhada.  Se antes havia sempre um peda√ßo de mem√≥ria dispon√≠vel em cada encadeamento e, se desejado, em todos os processos, agora n√£o existe esse peda√ßo e n√£o pode existir.  Cada um por si, independente e orgulhoso. </p><br><p>  Se anteriormente, uma falha no fluxo enterrava o fluxo e o processo ao mesmo tempo, e isso era bom, porque  n√£o levou a falhas parciais, agora falhas parciais se tornam a norma e toda vez antes de cada a√ß√£o que voc√™ pensa: ‚Äúe se?‚Äù.  Isso √© t√£o irritante e perturbador para a escrita, de fato, as pr√≥prias a√ß√µes que o c√≥digo por causa disso cresce n√£o √†s vezes, mas por ordens de magnitude.  Tudo se transforma no macarr√£o de manipula√ß√£o de erros, troca de estado e preserva√ß√£o de contexto, restaura√ß√£o devido a falhas de um componente, outro componente, inacessibilidade de alguns servi√ßos, etc.  etc.  Depois de estragar o monitoramento de todas essas coisas, voc√™ pode ter uma √≥tima noite de sono no seu laptop favorito. </p><br><p>  Se √© uma quest√£o de multithreading: peguei o mutex e fui destruir a mem√≥ria compartilhada por prazer.  Beleza! </p><br><p>  Como resultado, temos que os padr√µes chave e testados em batalha foram retirados, e os novos, para substitu√≠-los, por algum motivo n√£o foram entregues, e aconteceu como uma piada sobre como a fada acenou com sua varinha e a torre caiu do tanque. </p><br><p>  No entanto, os sistemas distribu√≠dos t√™m um conjunto de pr√°ticas e algoritmos comprovados.  No entanto, todo programador que se preze considera seu dever rejeitar conquistas conhecidas e aproveitar seu pr√≥prio bem, apesar da experi√™ncia adquirida, um n√∫mero consider√°vel de artigos cient√≠ficos e pesquisas acad√™micas.  Afinal, se voc√™ pode usar algoritmos e multithreading, como pode entrar em confus√£o com a distribui√ß√£o?  N√£o pode haver duas opini√µes aqui! </p><br><p>  Como resultado, os sistemas est√£o com bugs, os dados divergem e se deterioram, os servi√ßos ficam periodicamente indispon√≠veis para grava√ß√£o ou at√© mesmo completamente indispon√≠veis, porque de repente um n√≥ travou, a rede caiu, o Java consumiu muita mem√≥ria e o GC sem gra√ßa, e existem muitos outros motivos que podem atrasar seu t√©rmino. √†s autoridades. </p><br><p>  Contudo, mesmo com abordagens conhecidas e comprovadas, a vida n√£o se torna mais f√°cil, porque  primitivas confi√°veis ‚Äã‚Äãdistribu√≠das s√£o pesadas, com s√©rios requisitos para a l√≥gica do c√≥digo execut√°vel.  Portanto, os cantos s√£o cortados sempre que poss√≠vel.  E, como costuma acontecer, com cantos cortados √†s pressas, a simplicidade e a escalabilidade relativa aparecem, mas a confiabilidade, a disponibilidade e a consist√™ncia de um sistema distribu√≠do desaparecem. </p><br><p>  Idealmente, gostaria de n√£o pensar que nosso sistema seja distribu√≠do e multithread, ou seja,  trabalhe na 1¬™ etapa (algoritmos), sem pensar na 2¬™ (multithreading + assincronia) e na 3¬™ (distribui√ß√£o).  Essa maneira de isolar abstra√ß√µes aumentaria significativamente a simplicidade, a confiabilidade e a velocidade da escrita de c√≥digo.  Infelizmente, no momento isso s√≥ √© poss√≠vel em sonhos. </p><br><p>  No entanto, abstra√ß√µes individuais permitem um isolamento relativo.  Um dos exemplos t√≠picos √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uso de corotinas</a> , em que, em vez de c√≥digo ass√≠ncrono, nos tornamos s√≠ncronos, ou seja,  passamos da 2¬™ para a 1¬™ etapa, o que nos permite simplificar significativamente a escrita e a manuten√ß√£o do c√≥digo. </p><br><p>  O artigo revela sucessivamente o uso de algoritmos sem bloqueio para criar um sistema em tempo real escal√°vel distribu√≠do consistente e confi√°vel, ou seja,  como as conquistas sem bloqueio do segundo est√°gio ajudam na implementa√ß√£o do terceiro, reduzindo a tarefa a algoritmos single-threaded do primeiro est√°gio. </p><br><h2 id="postanovka-zadachi">  Declara√ß√£o do problema </h2><br><p>  Esta tarefa ilustra apenas algumas abordagens importantes e √© apresentada como um exemplo para a introdu√ß√£o de problemas no contexto.  Pode ser facilmente generalizado para casos mais complexos, o que ser√° feito no futuro. </p><br><p>  <strong>Tarefa: processamento de dados de streaming em tempo real</strong> . </p><br><p>  Existem dois fluxos de n√∫meros.  O manipulador l√™ os dados desses fluxos de entrada e seleciona os √∫ltimos n√∫meros por um determinado per√≠odo.  A m√©dia desses n√∫meros √© nesse intervalo de tempo, ou seja,  em uma janela de dados deslizante por um determinado tempo.  O valor m√©dio obtido deve ser gravado na fila de sa√≠da para processamento subseq√ºente.  Al√©m disso, se o n√∫mero de n√∫meros na janela exceder um determinado limite, aumente em um o contador no banco de dados transacional externo. </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="Inicial"></p><br><p>  Observamos alguns recursos desse problema. </p><br><ol><li>  <em>N√£o determinismo</em> .  Existem duas fontes de comportamento n√£o determin√≠stico: √© uma leitura de dois fluxos, bem como uma janela de tempo.  √â claro que a leitura pode ser realizada de diferentes maneiras, e o resultado final depender√° de qual sequ√™ncia os dados ser√£o extra√≠dos.  A janela de tempo tamb√©m altera o resultado do in√≠cio ao in√≠cio, conforme  a quantidade de dados na janela depender√° da velocidade do trabalho. </li><li>  <em>O estado do manipulador</em> .  H√° um estado do manipulador na forma de um conjunto de n√∫meros na janela, do qual dependem os resultados atuais e subsequentes do trabalho.  I.e.  n√≥s temos um manipulador stateful. </li><li>  <em>Intera√ß√£o com armazenamento externo</em> .  √â necess√°rio atualizar o valor do contador no banco de dados externo.  O ponto crucial √© que o tipo de armazenamento externo √© diferente do armazenamento do estado do processador e dos threads. </li></ol><br><p>  Tudo isso, como ser√° mostrado abaixo, afeta seriamente as ferramentas utilizadas e os poss√≠veis m√©todos de implementa√ß√£o. </p><br><p>  Resta adicionar um pequeno toque √† tarefa, que transfere a tarefa imediatamente de uma √°rea al√©m da complexidade para um imposs√≠vel: √© necess√°ria <em>uma</em> garantia <em>simult√¢nea exatamente uma vez</em> . </p><br><h2 id="exactly-once">  Exatamente uma vez </h2><br><p>  <em>Exatamente uma vez √©</em> muitas vezes interpretado de maneira muito ampla, o que emascula o pr√≥prio termo e deixa de atender aos requisitos originais da tarefa.  Se estamos falando de um sistema que roda localmente em um computador - tudo √© simples: aguarde mais, jogue mais longe.  Mas, neste caso, estamos falando de um sistema distribu√≠do no qual: </p><br><ol><li>  O n√∫mero de manipuladores pode ser grande: cada manipulador trabalha com seus pr√≥prios dados.  Al√©m disso, os resultados podem ser adicionados a v√°rios locais, por exemplo, um banco de dados externo, possivelmente at√© embaralhado. </li><li>  Cada manipulador pode parar subitamente o processamento.  Um sistema tolerante a falhas implica em opera√ß√£o cont√≠nua, mesmo no caso de falha de partes individuais do sistema. </li></ol><br><p>  Portanto, devemos estar preparados para o fato de que o manipulador pode cair e outro manipulador deve pegar o trabalho j√° realizado e continuar o processamento. </p><br><p>  Surge imediatamente a pergunta: o que significa <em>exatamente uma vez</em> se o manipulador n√£o determin√≠stico funcionar?  Afinal, toda vez que reiniciarmos, receberemos, de um modo geral, diferentes estados resultantes.  A resposta aqui √© simples: com <em>exatamente uma vez,</em> existe uma execu√ß√£o do sistema em que cada valor de entrada √© processado exatamente uma vez, fornecendo o resultado de sa√≠da correspondente.  Al√©m disso, essa execu√ß√£o n√£o precisa estar fisicamente no mesmo n√≥.  Mas o resultado deve ser como se tudo fosse processado em um √∫nico n√≥ l√≥gico <em>sem falhas</em> . </p><br><h2 id="concurrent-exactly-once">  Concorrente exatamente uma vez </h2><br><p>  Para agravar os requisitos, introduzimos um novo conceito: <em>simult√¢neo exatamente uma vez</em> .  A diferen√ßa fundamental do simples <em>exatamente uma vez</em> √© a aus√™ncia de pausas durante o processamento, como se tudo fosse processado no mesmo n√≥ <strong>sem quedas</strong> e <strong>sem pausas</strong> .  Em nossa tarefa, exigiremos exatamente <em>simult√¢neo exatamente uma vez</em> , para simplificar a apresenta√ß√£o, para n√£o considerar uma compara√ß√£o com sistemas existentes que n√£o est√£o dispon√≠veis atualmente. </p><br><p>  As conseq√º√™ncias de ter esse requisito ser√£o discutidas abaixo. </p><br><h2 id="tranzakcionnost">  Transacional </h2><br><p>  Para que o leitor seja ainda mais profundamente imbu√≠do da complexidade que surgiu, vejamos v√°rios cen√°rios ruins que devem ser considerados ao desenvolver esse sistema.  Tamb√©m tentaremos usar uma abordagem geral que nos permita resolver o problema acima, levando em considera√ß√£o nossos requisitos. </p><br><p>  A primeira coisa que vem √† mente √© a necessidade de registrar o estado do manipulador e os fluxos de entrada e sa√≠da.  O estado dos fluxos de sa√≠da √© descrito por uma fila simples de n√∫meros e o estado dos fluxos de entrada pela posi√ß√£o neles.  Em ess√™ncia, um fluxo √© uma fila infinita e uma posi√ß√£o na fila define um local exclusivamente. </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="Idia"></p><br><p>  A implementa√ß√£o ing√™nua a seguir de um manipulador surge usando algum tipo de armaz√©m de dados.  Nesta fase, as propriedades espec√≠ficas do reposit√≥rio n√£o ser√£o importantes para n√≥s.  Usaremos a linguagem Pseco para ilustrar a ideia (Pseco: = pseudo c√≥digo): </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p>  Aqui est√° um algoritmo simples de thread √∫nico que l√™ dados dos fluxos de entrada e grava os valores desejados de acordo com a tarefa descrita acima. </p><br><p>  Vamos ver o que acontece no caso de um n√≥ cair em pontos arbitr√°rios no tempo, bem como depois de retomar o trabalho.  √â claro que, no caso de uma queda nos pontos <code>(A)</code> e <code>(E)</code> tudo ficar√° bem: ou os dados ainda n√£o foram gravados em nenhum lugar e simplesmente restauramos o estado e continuamos no outro n√≥, ou todos os dados necess√°rios j√° foram gravados e continuamos a pr√≥xima etapa. </p><br><p>  No entanto, no caso de uma queda em todos os outros pontos, problemas inesperados nos aguardam.  Se ocorrer uma queda no ponto <code>(B)</code> , quando o manipulador for reiniciado, restauraremos o estado e registraremos novamente o valor m√©dio aproximadamente no mesmo intervalo de n√∫meros.  No caso de uma queda no ponto <code>(C)</code> al√©m da duplicata m√©dia, uma duplicata ocorrer√° no incremento do valor.  E no caso de uma queda em <code>(D)</code> obteremos um estado inconsistente do manipulador: o estado corresponde a um novo momento no tempo e leremos os valores dos fluxos de entrada antigos. </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="Surpresas"></p><br><p>  Ao mesmo tempo, nada mudar√° fundamentalmente ao reorganizar as opera√ß√µes de grava√ß√£o: a inconsist√™ncia e as duplicatas permanecer√£o assim.  Assim, chegamos √† conclus√£o de que todas as a√ß√µes para alterar o estado do manipulador no reposit√≥rio, na fila de sa√≠da e no banco de dados devem ser executadas de maneira transacional, ou seja,  tudo √© at√¥mico ao mesmo tempo. </p><br><p>  Consequentemente, √© necess√°rio desenvolver um mecanismo para que diferentes armazenamentos possam mudar transacionalmente seu estado, e n√£o dentro de cada um independentemente, mas transacionalmente entre todos os armazenamentos simultaneamente.  Obviamente, voc√™ pode colocar nosso armazenamento em um banco de dados externo; no entanto, a tarefa assumiu que o mecanismo de banco de dados e o mecanismo da estrutura de processamento de dados de streaming s√£o separados e funcionam independentemente um do outro.  Aqui eu quero considerar o caso mais dif√≠cil, porque  casos simples n√£o s√£o interessantes a considerar. </p><br><h2 id="konkurentnaya-otzyvchivost">  Capacidade de resposta competitiva </h2><br><p>  Considere a execu√ß√£o competitiva exatamente uma vez com mais detalhes.  No caso de um sistema tolerante a falhas, exigimos a continua√ß√£o do trabalho a partir de algum ponto.  √â claro que este ponto ser√° algum ponto no passado, porque  Para manter o desempenho, √© imposs√≠vel armazenar todos os momentos de mudan√ßas de estado no presente e no futuro: o √∫ltimo resultado das opera√ß√µes ou um grupo de valores para aumentar o rendimento √© salvo.  Esse comportamento imediatamente nos leva ao fato de que, ap√≥s a restaura√ß√£o do estado do processador, ocorrer√° algum atraso nos resultados, aumentar√° com o aumento do tamanho do grupo de valores e do tamanho do estado. </p><br><p>  Al√©m desse atraso, tamb√©m existem atrasos no sistema associados ao carregamento do estado em outro n√≥.  Al√©m disso, a detec√ß√£o de um n√≥ problem√°tico tamb√©m leva algum tempo, e muitas vezes muito.  Isso se deve, em primeiro lugar, ao fato de que, se definirmos um tempo de detec√ß√£o curto, poss√≠veis falsos positivos frequentes ser√£o poss√≠veis, o que levar√° a todos os tipos de efeitos especiais desagrad√°veis. </p><br><p>  Al√©m disso, com o aumento do n√∫mero de processadores paralelos, repentinamente acontece que nem todos eles funcionam igualmente bem, mesmo na aus√™ncia de falhas.  √Äs vezes ocorrem embotamentos, o que tamb√©m leva a atrasos no processamento.  A raz√£o para tais embotamentos pode ser variada: </p><br><ol><li>  <em>Software</em> : pausas no GC, fragmenta√ß√£o da mem√≥ria, pausas no alocador, interrup√ß√£o do kernel e agendamento de tarefas, problemas com drivers de dispositivo, causando lentid√£o. </li><li>  <em>Hardware</em> : alta carga de disco ou de rede, limita√ß√£o da CPU devido a problemas de refrigera√ß√£o, sobrecarga, etc., lentid√£o no disco devido a problemas t√©cnicos. </li></ol><br><p>  E isso n√£o √© de forma alguma uma lista exaustiva de problemas que podem retardar os manipuladores. </p><br><p>  Por conseguinte, abrandar √© um dado com o qual se tem que viver.  √Äs vezes, esse n√£o √© um problema s√©rio e, √†s vezes, √© extremamente importante manter uma alta velocidade de processamento, apesar de falhas ou lentid√µes. </p><br><p>  Imediatamente surge a id√©ia de duplica√ß√£o de sistemas: vamos rodar para um e o mesmo fluxo de dados, n√£o um, mas dois processadores ao mesmo tempo, ou at√© tr√™s.  O problema aqui √© que, nesse caso, duplicatas e comportamento inconsistente do sistema podem ocorrer facilmente.  Normalmente, as estruturas n√£o s√£o projetadas para esse comportamento e sugerem que o n√∫mero de manipuladores em um determinado momento n√£o exceda um.  Os sistemas que permitem a duplica√ß√£o descrita da execu√ß√£o s√£o chamados <em>simult√¢neos exatamente uma vez</em> . </p><br><p>  Essa arquitetura permite resolver v√°rios problemas ao mesmo tempo: </p><br><ol><li>  Comportamento √† prova de falhas: se um dos n√≥s cai, o outro simplesmente continua a funcionar como se nada tivesse acontecido.  N√£o h√° necessidade de coordena√ß√£o adicional, pois  o segundo manipulador √© executado independentemente do estado do primeiro. </li><li>  Remo√ß√£o de embotamento: quem primeiro forneceu o resultado √© bom para ele.  O outro s√≥ ter√° que pegar um novo estado e continuar a partir deste momento. </li></ol><br><p>  Essa abordagem, em particular, permite concluir um c√°lculo longo dif√≠cil e dif√≠cil por um tempo mais previs√≠vel, porque  a probabilidade de que ambos sejam est√∫pidos e caiam significativamente menos. </p><br><h3 id="veroyatnostnaya-ocenka">  Avalia√ß√£o de probabilidade </h3><br><p>  Vamos tentar avaliar os benef√≠cios da duplica√ß√£o de desempenho.  Suponha que algo aconte√ßa em m√©dia todos os dias com o manipulador: ou o GC est√° embotado, ou o n√≥ est√° mentindo ou os cont√™ineres se tornaram cancer√≠genos.  Suponha tamb√©m que preparemos pacotes de dados em 10 segundos. </p><br><p>  Ent√£o a probabilidade de que algo aconte√ßa durante a cria√ß√£o do pacote √© <code>10 / (24 ¬∑ 3600) ‚âÉ 1e-4</code> . </p><br><p>  Se voc√™ executar dois manipuladores em paralelo, a probabilidade de ambas as moscas serem <code>‚âÉ 1e-8</code> .  Portanto, este evento vir√° em 23 anos!  Sim, os sistemas n√£o vivem tanto, o que significa que isso nunca acontecer√°! </p><br><p>  Al√©m disso, se o tempo de prepara√ß√£o da embalagem for ainda mais curto e / ou os embotamentos ocorrerem com menos frequ√™ncia, esse n√∫mero s√≥ aumentar√°. </p><br><p>  Assim, conclu√≠mos que a abordagem em considera√ß√£o aumenta significativamente a confiabilidade de todo o sistema.  Resta apenas resolver uma pequena quest√£o como esta: onde ler sobre como criar um sistema <em>concorrente exatamente uma vez</em> .  E a resposta √© simples: voc√™ tem que ler aqui. </p><br><h2 id="polutranzakcii">  Meia transa√ß√£o </h2><br><p>  Para uma discuss√£o mais aprofundada, precisamos do conceito de <em>meia transa√ß√£o</em> .  A maneira mais f√°cil de explicar isso com um exemplo. </p><br><p>  Considere transferir fundos de uma conta banc√°ria para outra.  A abordagem tradicional usando transa√ß√µes na linguagem Pseco pode ser descrita da seguinte maneira: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  No entanto, e se essas transa√ß√µes n√£o estiverem dispon√≠veis para n√≥s?  Usando bloqueios, isso pode ser feito da seguinte maneira: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Essa abordagem pode levar a impasses, pois  os bloqueios podem ser feitos em diferentes seq√º√™ncias em paralelo.  Para corrigir esse comportamento, basta introduzir uma fun√ß√£o que simultaneamente leva v√°rios bloqueios em uma sequ√™ncia determin√≠stica (por exemplo, classifica por chaves), que elimina completamente poss√≠veis bloqueios. </p><br><p>  No entanto, a implementa√ß√£o pode ser um pouco simplificada: </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p>  Essa abordagem tamb√©m torna o estado final consistente, preservando os invariantes pelo tipo de preven√ß√£o de gastos excessivos de fundos.  A principal diferen√ßa da abordagem anterior √© que, em tal implementa√ß√£o, temos um certo per√≠odo de tempo em que as contas est√£o em um estado inconsistente.  Nomeadamente, tal opera√ß√£o implica que o estado total dos fundos nas contas n√£o muda.  Nesse caso, h√° um intervalo de tempo entre <code>lock_from.release()</code> e <code>db.lock(to)</code> , durante o qual o banco de dados pode fornecer um valor inconsistente: o valor total pode diferir do valor correto para baixo. </p><br><p>  De fato, dividimos uma transa√ß√£o para transferir dinheiro em duas meias transa√ß√µes: </p><br><ol><li>  A primeira meia transa√ß√£o faz um cheque e deduz da conta o valor necess√°rio. </li><li>  A segunda meia transa√ß√£o grava o valor sacado em outra conta. </li></ol><br><p>  √â claro que dividir uma transa√ß√£o em transa√ß√µes menores, de um modo geral, viola o comportamento transacional.  E o exemplo acima n√£o √© excep√ß√£o.  No entanto, se todas as meias transa√ß√µes na cadeia forem completamente cumpridas, o resultado ser√° consistente com todos os invariantes preservados.  √â exatamente isso que √© uma propriedade importante de uma cadeia de meia transa√ß√£o. </p><br><p>  Perdendo temporariamente alguma consist√™ncia, adquirimos outro recurso √∫til: a independ√™ncia das opera√ß√µes e, como resultado, melhor escalabilidade.  A independ√™ncia se manifesta no fato de que uma meia transa√ß√£o a cada vez trabalha com apenas uma linha, lendo, verificando e alterando seus dados, sem se comunicar com outros dados.  Assim, voc√™ pode embaralhar um banco de dados cujas transa√ß√µes funcionam com apenas um shard.  Al√©m disso, essa abordagem pode ser usada no caso de reposit√≥rios heterog√™neos, ou seja,  meias transa√ß√µes podem come√ßar em um tipo de armazenamento e terminar em outro.  S√£o essas propriedades √∫teis que ser√£o usadas no futuro. </p><br><p>  Surge uma pergunta leg√≠tima: como implementar o meio transe em sistemas distribu√≠dos e n√£o o rake?  Para resolver esse problema, √© necess√°rio considerar a abordagem sem bloqueio. </p><br><h2 id="lock-free">  Sem bloqueio </h2><br><p>  Como voc√™ sabe, as abordagens sem bloqueio √†s vezes melhoram o desempenho de sistemas multithread, especialmente no caso de acesso competitivo ao recurso.  No entanto, √© completamente √≥bvio que essa abordagem pode ser usada em sistemas distribu√≠dos.  Vamos nos aprofundar e considerar o que √© livre de bloqueios e por que essa propriedade ser√° √∫til na solu√ß√£o de nosso problema. </p><br><p>  Alguns desenvolvedores √†s vezes n√£o entendem o que √© livre de bloqueio.  O olhar tacanho sugere que isso √© algo relacionado √†s instru√ß√µes do processador at√¥mico.  √â importante entender aqui que livre de bloqueio significa o uso de "√°tomos", o oposto n√£o √© verdadeiro, ou seja,  nem todos os "at√¥micos" oferecem um comportamento livre de bloqueio. </p><br><p>  Uma propriedade importante do algoritmo sem bloqueio √© que pelo menos um encadeamento avan√ßa no sistema.  Mas, por alguma raz√£o, muitos atribuem essa propriedade como uma defini√ß√£o (√© uma defini√ß√£o t√£o contundente que pode ser encontrada, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na Wikipedia</a> ).  Aqui √© necess√°rio adicionar uma nuance importante: o progresso √© feito mesmo no caso de embotamento de um ou mais threads.  Esse √© um ponto muito cr√≠tico que geralmente √© esquecido e tem s√©rias implica√ß√µes para um sistema distribu√≠do. </p><br><p>  Por que a aus√™ncia de uma condi√ß√£o de progresso de pelo menos um thread nega o conceito de um algoritmo sem bloqueio?  O fato √© que, neste caso, o spinlock usual tamb√©m estar√° livre de bloqueios.  De fato, quem assumiu o controle far√° progressos.  Existe um t√≥pico com progress = = free-lock? </p><br><p>  Obviamente, sem bloqueios significa sem bloqueios, enquanto spinlock por seu nome indica que esse √© um bloqueio real.  √â por isso que √© importante adicionar uma condi√ß√£o ao progresso, mesmo no caso de embotamentos.  Afinal, esses atrasos podem durar indefinidamente, porque  a defini√ß√£o n√£o diz nada sobre a linha do tempo superior.  E, nesse caso, esses atrasos ser√£o equivalentes em certo sentido ao desligamento dos fluxos.  Nesse caso, algoritmos sem bloqueio produzir√£o progresso nesse caso. </p><br><p>  Mas quem disse que as abordagens sem bloqueio se aplicam exclusivamente a sistemas multiencadeados?  Substituindo threads no mesmo processo no mesmo n√≥ por processos em n√≥s diferentes, e a mem√≥ria compartilhada dos threads por armazenamento distribu√≠do compartilhado, obtemos um algoritmo distribu√≠do sem bloqueio. </p><br><p>  Uma queda de n√≥ nesse sistema √© equivalente a um atraso na execu√ß√£o de um encadeamento por algum tempo, porque  √© hora de restaurar o trabalho.  Ao mesmo tempo, a abordagem sem bloqueio permite que outros participantes no sistema distribu√≠do continuem trabalhando.  Al√©m disso, algoritmos especiais livres de bloqueio podem ser executados em paralelo, detectando uma mudan√ßa competitiva e eliminando duplicatas. </p><br><p>  <em>A</em> abordagem <em>Exatamente uma vez</em> implica a presen√ßa de um armazenamento distribu√≠do consistente.  Geralmente, esses armazenamentos representam uma enorme tabela de valor-chave persistente.  Opera√ß√µes poss√≠veis: <code>set</code> , <code>get</code> , <code>del</code> .  No entanto, √© necess√°ria uma opera√ß√£o mais complicada para a abordagem sem bloqueio: CAS ou compare-and-swap.  Vamos considerar em mais detalhes essa opera√ß√£o, as possibilidades de seu uso, bem como os resultados que ela fornece. </p><br><h3 id="cas">  Cas </h3><br><p>  O CAS ou compare-and-swap √© a primitiva principal e importante da sincroniza√ß√£o para algoritmos sem bloqueio e sem espera.  Sua ess√™ncia pode ser ilustrada pelo seguinte Pseco: </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  √Äs vezes, para otimiza√ß√£o, eles retornam n√£o <code>true</code> ou <code>false</code> , mas o valor anterior, porque  muitas vezes essas opera√ß√µes s√£o executadas em loop e, para obter o valor <code>expected</code> , voc√™ deve primeiro l√™-lo: </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p>  Essa abordagem pode salvar uma leitura.  Como parte de nossa an√°lise, usaremos uma forma simples de <code>CAS</code> , porque  se desejado, essa otimiza√ß√£o pode ser feita de forma independente. </p><br><p>  No caso de sistemas distribu√≠dos, cada altera√ß√£o √© versionada.  I.e.  primeiro, lemos o valor da loja, obtendo a vers√£o atual dos dados.  E ent√£o tentamos escrever, esperando que a vers√£o dos dados n√£o tenha mudado.  Nesse caso, a vers√£o √© incrementada toda vez que os dados s√£o atualizados: </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Essa abordagem permite controlar com mais precis√£o a atualiza√ß√£o de valores, evitando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o problema ABA</a> .  Em particular, o controle de vers√£o √© suportado pelo Etcd e pelo Zookeeper. </p><br><p>  Observe a propriedade importante que o uso das opera√ß√µes <code>CAS_versioned</code> fornece.  O fato √© que essa opera√ß√£o pode ser repetida sem preju√≠zo da l√≥gica superior.  Na programa√ß√£o multithread, essa propriedade n√£o possui valor especial, porque  l√°, se a opera√ß√£o falhar, sabemos com certeza que ela n√£o se aplicou.  No caso de sistemas distribu√≠dos, essa invariante √© violada, porque  a solicita√ß√£o pode chegar ao destinat√°rio, mas a resposta bem-sucedida n√£o est√° mais l√°.  Portanto, √© importante poder reenviar solicita√ß√µes sem medo de quebrar invariantes da l√≥gica de alto n√≠vel. </p><br><p>  √â essa propriedade que a opera√ß√£o <code>CAS_versioned</code> .  De fato, essa opera√ß√£o pode ser repetida infinitamente at√© que a resposta real do destinat√°rio seja retornada.  O que, por sua vez, gera toda uma classe de erros relacionados √† intera√ß√£o da rede. </p><br><h3 id="primer">  Exemplo </h3><br><p>  Vejamos como, com base em <code>CAS_versioned</code> e meia transa√ß√£o do <code>CAS_versioned</code> , transferir de uma conta para outra, que pertence, por exemplo, a diferentes c√≥pias do Etcd.  Aqui, suponho que a fun√ß√£o <code>CAS_versioned</code> j√° <code>CAS_versioned</code> implementada de acordo com a API fornecida. </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  Aqui dividimos nossa opera√ß√£o em meias transa√ß√µes e realizamos cada meia transa√ß√£o atrav√©s da opera√ß√£o <code>CAS_versioned</code> .  Essa abordagem permite trabalhar independentemente com cada conta, permitindo o uso de armazenamento heterog√™neo que n√£o est√° conectado entre si.  O √∫nico problema que nos espera aqui √© a perda de dinheiro no caso de uma queda no processo atual no intervalo entre meias transa√ß√µes. </p><br><h2 id="ochered">  Fila </h2><br><p>  Para seguir em frente, voc√™ precisa implementar uma fila de eventos.  A id√©ia √© que, para que os manipuladores se comuniquem, √© necess√°rio ter uma fila de mensagens ordenada na qual os dados n√£o sejam perdidos ou duplicados.  Consequentemente, toda intera√ß√£o na cadeia de manipuladores ser√° constru√≠da sobre esse primitivo.  √â tamb√©m uma ferramenta √∫til para analisar e auditar fluxos de dados de entrada e sa√≠da.  Al√©m disso, muta√ß√µes do estado dos manipuladores tamb√©m podem ser feitas atrav√©s da fila. </p><br><p>  A fila consistir√° em um par de opera√ß√µes: </p><br><ol><li>  Adicione uma mensagem ao final da fila. </li><li>  Recebendo uma mensagem da fila no √≠ndice especificado. </li></ol><br><p>  Nesse contexto, n√£o considero remover mensagens da fila por v√°rios motivos: </p><br><ol><li>  V√°rios processadores podem ler da mesma fila.  Remover a sincroniza√ß√£o ser√° uma tarefa n√£o trivial, embora n√£o seja imposs√≠vel. </li><li>  √â √∫til manter uma fila por um intervalo relativamente longo (dia ou semana) para depura√ß√£o e auditoria.  √â dif√≠cil superestimar a utilidade dessa propriedade. </li><li>  Voc√™ pode excluir itens antigos de acordo com a programa√ß√£o ou definindo TTL nos itens da fila.  √â importante garantir que os processadores consigam processar os dados antes que a vassoura chegue e limpe tudo.  Se o tempo de processamento for da ordem de segundos e o TTL da ordem dos dias, nada disso dever√° acontecer. </li></ol><br><p>  Para armazenar os elementos e implementar efetivamente a adi√ß√£o, precisamos: </p><br><ol><li>  O valor com o √≠ndice atual.  Este √≠ndice aponta para o final da fila para adicionar itens. </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free?  N√£o!   ,    2 :   .         lock-free,     ‚Äî !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     ‚Äî ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          . ..    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     ‚Äî . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    ‚Äî      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="Simples"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="final"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="final"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    .  Porque       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   ‚Äî            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     .  Porque        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        ‚Äî   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        . ..          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       .  Porque     ,       ,        .      ,        :     ,     ‚Äî  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     ‚Äî    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   ‚Äî       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> ‚Äî       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> ‚Äî     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> ‚Äî NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie">  </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        .  Mas isso √© outra hist√≥ria. </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="Light"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  Literatura </h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: O Problema da ABA. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog: voc√™ n√£o pode ter entrega </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">exata uma </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">vez.</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr: alcan√ßabilidade do limite inferior no tempo de execu√ß√£o do commit de transa√ß√µes distribu√≠das √† prova de falhas. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr: assincronia 3: modelo subjetivo. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: sincroniza√ß√£o sem bloqueio.</font></font></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413817/">https://habr.com/ru/post/pt413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413807/index.html">Determina√ß√£o das caracter√≠sticas bal√≠stico-temporais do movimento do centro de massa de um paraquedista que aterra de um avi√£o</a></li>
<li><a href="../pt413809/index.html">Decodificador e experi√™ncias com Android no cont√™iner LXC</a></li>
<li><a href="../pt413811/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 318 (4 a 10 de junho de 2018)</a></li>
<li><a href="../pt413813/index.html">PHP Digest No. 132 (27 de maio a 10 de junho de 2018)</a></li>
<li><a href="../pt413815/index.html">Ir workshop de contribui√ß√£o na R√∫ssia</a></li>
<li><a href="../pt413819/index.html">Honestamente sobre o mercado de TI na R√∫ssia</a></li>
<li><a href="../pt413823/index.html">O boom do emprego sem sentido</a></li>
<li><a href="../pt413827/index.html">Projeto Kubernetes faz 4 anos</a></li>
<li><a href="../pt413831/index.html">A nova vers√£o do Tesla Autopilot ser√° lan√ßada em agosto, pela primeira vez com "recursos de dire√ß√£o totalmente aut√¥nomos"</a></li>
<li><a href="../pt413837/index.html">Fazendo da Defesa da Torre um Jogo de Unidade - Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>