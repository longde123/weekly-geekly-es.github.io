<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â±ï¸ ğŸ‘¨ğŸ¿â€âš–ï¸ ğŸ‘©ğŸ¼â€âš•ï¸ Menggunakan Unity3D di aplikasi asli iOS / Android untuk memodelkan pencahayaan ruang terbuka ğŸš” ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸš¶ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unity3D adalah platform pengembangan game 3D dan 2D yang terkenal yang telah mendapatkan popularitas di seluruh dunia. Pada saat yang sama, kemampuann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan Unity3D di aplikasi asli iOS / Android untuk memodelkan pencahayaan ruang terbuka</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/417779/"><img src="https://habrastorage.org/webt/ac/6n/is/ac6nistgzfsvyyhyj3wqngoiak4.png" alt="gambar"><br><br>  Unity3D adalah platform pengembangan game 3D dan 2D yang terkenal yang telah mendapatkan popularitas di seluruh dunia.  Pada saat yang sama, kemampuannya tidak terbatas pada pengembangan hanya aplikasi game, tetapi cocok untuk digunakan di area lain yang membutuhkan pembuatan aplikasi lintas platform untuk bekerja dengan grafik.  Pada artikel ini kita akan berbicara tentang pengalaman menggunakan Unity3D untuk mengembangkan sistem untuk menghitung pencahayaan ruang terbuka. <br><a name="habracut"></a><br>  Perusahaan tempat kami bekerja sama adalah perusahaan pencahayaan internasional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BOOS LIGHTING GROUP</a> .  Untuk memperluas daya tarik produk mereka dan menyederhanakan interaksi dengan pelanggan, perlu untuk mengembangkan aplikasi yang memungkinkan Anda untuk mensimulasikan secara visual lokasi perangkat pencahayaan, serta melakukan perhitungan pencahayaan dan menampilkan informasi teknis yang diperlukan dalam laporan.  Diasumsikan bahwa aplikasi diluncurkan pada iPad atau tablet Android oleh klien potensial atau perwakilan penjualan dan memungkinkan klien untuk segera mendapatkan ide tentang kemungkinan instalasi pencahayaan. <br><br>  Pekerjaan tersebut dilakukan secara bertahap berdasarkan spesifikasi yang dikembangkan dari persyaratan dan konsultasi dari perusahaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BOOS LIGHTING GROUP</a> mengenai masalah proyek. <br><br>  Secara umum, aplikasi ini adalah editor yang memungkinkan Anda untuk menambah dan mengedit elemen pencahayaan, jalan, elemen dekoratif, melakukan perhitungan rekayasa pencahayaan adegan, menampilkan laporan dalam pdf.  Setiap elemen memiliki set parameter sendiri untuk mengedit dan subtipe yang memengaruhi tampilan dan perhitungannya. <br><br><ul><li>  Ada beberapa jenis tiang lampu, dengan berbagai jenis perlengkapan fixture, sudut kemiringan lampu dan panjang ekstensi.  Untuk jenis luminer tertentu, penyesuaian individual dimungkinkan dengan arah pencahayaan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2o/ci/da/2ocida45cxhpgpekhtfat_mc_6y.png" width="70%" alt="gambar"></div></li><li>  Jalan dapat berupa bagian linier, elemen busur, area, cincin.  Untuk setiap elemen, dimensi, posisi, tipe tata letak, lapisan dapat disesuaikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s1/3s/lx/s13slxoinkzba4yyljw518pqw78.png" alt="gambar" width="70%"></div></li><li>  Elemen dekoratif - mobil, pohon, semak-semak, rambu-rambu jalan </li></ul><br>  Semua elemen adegan dapat diputar dan dipindahkan.  Tindakan standar untuk mengembalikan atau mencoba kembali juga didukung.  Pengaturan umum proyek memungkinkan Anda untuk mengatur tekstur dorg, permukaan bumi, menampilkan parameter tambahan.  Adegan ditampilkan dalam mode 2D / 3D.  Dan saat menghitung iluminasi di permukaan, peta iluminasi permukaan dalam warna fiktif ditampilkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ac/6n/is/ac6nistgzfsvyyhyj3wqngoiak4.png" width="100%" alt="gambar"></div><br><br>  Jika memungkinkan, seluruh UI harus dilakukan dengan alat iOS / Android asli. <br>  Persyaratan teknis utama untuk aplikasi ini adalah untuk dapat menghitung pencahayaan panggung sesuai dengan spesifikasi teknis perlengkapan.  Yang juga diperlukan adalah kemampuan setiap fixture untuk menampilkan dan melihat pola radiasi (kurva intensitas cahaya) dalam mode 3D / 2D. <br><br><h4>  Pemilihan platform </h4><br>  Untuk mengimplementasikan proyek, kami memilih Unity karena lebih nyaman bagi kami untuk mengimplementasikan fungsionalitas yang diperlukan.  Secara umum, perusahaan kami memiliki pengalaman bekerja dengan mesin dan platform 3D lainnya (OpenSceneGraph, Ogre3D, LibGdx) dan secara teknis mereka semua dapat mengatasi tugas yang diperlukan, tetapi kali ini pilihannya jatuh pada Unity, yang membuatnya lebih mudah untuk mengelola adegan selama pengembangan dan debug. dalam proses kerja. <br><br><h4>  Kesulitan utama </h4><br>  Kami tidak akan membahas seluk-beluk pengembangan seluruh aplikasi, karena secara teknis fungsi untuk menampilkan dan mengedit adegan cukup standar.  Secara alami, ada kesulitan dengan mekanisme pengeditan objek tertentu, menambah dan menghapusnya, serta menyimpan rantai perintah untuk kemungkinan pengulangan dan pembatalan tindakan. <br>  Kami hanya ingin memikirkan fitur-fitur sistem yang terkait dengan bekerja dengan UI asli, menghasilkan laporan pdf dan bekerja dengan fotometri dan perhitungan pencahayaan. <br><br><h4>  Bekerja dengan UI asli </h4><br>  Dalam kebanyakan kasus, Unity berinteraksi dengan fungsi asli sistem menggunakan sistem plug-in, yang memungkinkan Anda untuk menanamkan fungsionalitas yang diinginkan dalam aplikasi.  Namun, dalam kasus kami situasinya agak berlawanan.  Kami harus memiliki UI lengkap yang ditampilkan di atas jendela Unity. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4z/0s/41/4z0s41r48kbp8cuzxnc7naj6l3i.png" width="70%" alt="gambar"></div><br><br>  Untungnya, Unity dapat mengekspor proyek yang dapat digunakan sebagai dasar untuk aplikasi asli.  Kesulitan utama dalam kasus ini adalah bagaimana mengintegrasikan UI tambahan ke dalam proyek yang dihasilkan.  Juga, sama pentingnya bahwa ketika merakit proyek Unity, format dan lokasi file-nya dibentuk oleh Unity dan ditulis ulang sebagian, yang membatasi kemungkinan memodifikasi proyek. <br><br>  Saat mengembangkan aplikasi iOS, kami menggunakan mekanisme yang diusulkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> .  Selama pengembangan, Unity 5.5 digunakan dan saat ini, apa yang ditunjukkan di dalamnya mungkin kehilangan relevansi.  Saat merakit proyek android, tidak ada masalah tambahan, dengan pengecualian bahwa Unity menimpa file manifes dan file sumber daya setiap kali. <br>  Masalah tambahan adalah bahwa Unity hanya dapat bekerja dalam satu jendela.  Pada saat yang sama, kami perlu memastikan Unity untuk menampilkan seluruh adegan, dan ketika membuka jendela pengaturan, model 3D dari tubuh fotometrik lampu harus ditampilkan.  Untuk mencapai ini, saya harus menggunakan "retas" dan menggunakan objek UIView yang sama di jendela yang berbeda. <br><br>  Untuk mengirim pesan, kami menggunakan fungsionalitas standar yang ditawarkan oleh Unity.  Artinya, semua pesan dalam format json dan ditransmisikan dalam garis sederhana.  Ini tidak memberlakukan batasan pada kinerja karena ukuran pesan mencapai maksimum 100 karakter, dan frekuensi mereka ditentukan oleh kecepatan bekerja dengan program.  Pada saat yang sama, dalam aplikasi yang lebih menuntut, masuk akal untuk membuat penangan pesan Anda sendiri seperti yang disajikan pada Haber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h4>  Perhitungan pencahayaan </h4><br>  Semua sumber cahaya yang digunakan dalam aplikasi dikirimkan dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IES</a> standar, yang menjelaskan distribusi cahaya dalam arah yang berbeda ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> ).  Format ini banyak digunakan dalam sistem CAD profesional dan editor 3D.  Ini adalah file teks yang menunjukkan intensitas cahaya di berbagai arah dan informasi meta tambahan yang menunjukkan jenis, intensitas total sumber, sumbu dan bidang simetri.  Mengingat simetri perlengkapan, file ies bisa sangat kecil.  Misalnya, dalam kasus simetri aksial, cukup untuk menunjukkan pelacakan cahaya hanya dalam satu bidang. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh file IES sederhana</b> <div class="spoiler_text"><pre><code class="plaintext hljs">IESNA91[TEST] Simple demo intensity distribution [MANUFAC] Lightscape Technologies, Inc. TILT=NONE 1 -1 1 8 1 1 2 0.0 0.0 0.0 1.0 1.0 0.0 0.0 5.0 10.0 20.0 30.0 45.0 65.0 90.0 0.0 1000.0 1100.0 1300.0 1150.0 930.0 650.0 350.0 0.0</code> </pre> <br></div></div><br>  Untuk menampilkan pola radiasi, dua jenis tampilan digunakan: <br><br><ul><li>  Kurva intensitas cahaya (KSS) adalah grafik dua dimensi yang menunjukkan intensitas cahaya di salah satu bidang utama tergantung pada arah.  Untuk kenyamanan, grafik ini dapat direpresentasikan dalam sistem koordinat kutub dan Cartesian. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/df/89/xc/df89xcesta0qlw4jcyuxpbihmyi.png" width="100%" alt="gambar"></div></li><li>  Tubuh fotometrik - gambar tiga dimensi intensitas cahaya dalam arah yang berbeda <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/su/1s/if/su1sifzigs4cwuy-jg6bhpni79o.png" width="100%" alt="gambar"></div></li></ul><br><h4>  Modul perhitungan </h4><br>  Untuk menghitung pencahayaan, pelanggan memiliki modul C ++ sendiri yang digunakan dalam produk-produk lain dari perusahaan, dan oleh karena itu diperlukan untuk mengintegrasikannya ke dalam proyek Unity.  Urutan koneksi modul berbeda dari platform yang digunakan. <br><br><ul><li>  Pada platform iOS, Unitu dapat langsung memanggil fungsi C, jadi cukup salin kode sumber modul langsung ke proyek dan tambahkan kelas untuk interaksinya dengan Unity.  Kelas dapat disimpan baik secara langsung di proyek iOS, dan di folder plugins, yang secara otomatis disalin ketika proyek diekspor ke Xcode.  Contoh memanggil fungsi C ++ adalah sebagai berikut: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__Internal"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateLight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[MarshalAs(UnmanagedType.LPArray, SizeParamIndex = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">)] Light[] lights, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> size, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> CalculationResult result)</span></span>;</code> </pre> </li><li>  Pada platform Android, modul C ++ harus dikompilasi ke pustaka yang terpisah.  Ini dapat dilakukan secara langsung dengan menambahkan sumber C ++ ke proyek dan menyiapkan gradle untuk membuatnya di perpustakaan. </li><li>  Juga, untuk debugging dan menguji bagian Unity, pengembangan dilakukan pada mesin windows, jadi itu perlu untuk menghubungkan kode sumber modul di Windows juga.  Ini dilakukan mirip dengan proyek android, hanya dalam kasus ini file yang diunduh dikumpulkan di perpustakaan dll dan terhubung ke proyek. </li></ul><br><h4>  Tampilan Peta Cahaya </h4><br>  Atas permintaan pelanggan, hasil perhitungan pencahayaan harus ditampilkan di permukaan tempat kejadian.  Di permukaan jalan, perlu menggunakan warna fiktif dengan tampilan skala untuk mencocokkan warna dan intensitas cahaya, dan pada permukaan lainnya, hanya menampilkan kecerahannya sudah cukup. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/18/5q/k9/185qk9lbx4fsoq3ax0miaedzjkm.png" width="70%" alt="gambar"></div><br><br>  Seperti disebutkan sebelumnya, seluruh perhitungan dilakukan oleh plug-in C ++ dimana data tentang sumber warna ditransmisikan.  Hasil perhitungannya adalah susunan intensitas cahaya dua dimensi di seluruh permukaan adegan dengan detail yang diberikan. <br><br>  Peta penyinaran yang dihasilkan dianalisis untuk nilai minimum dan maksimum yang digunakan tekstur gradien satu dimensi (GradientRamp).  Menggunakan tekstur ini, intensitas cahaya dikonversi ke warna fiktif langsung di shader fragmen.  Pada saat yang sama, shader yang sama digunakan untuk permukaan jalan dan permukaan bumi yang berbeda, dan mengganti mode pencahayaan disediakan menggunakan shader " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multi-kompilasi</a> ". <br><br><h4>  Pembuatan file pdf </h4><br>  Sesuai dengan persyaratan teknis, laporan harus dibuat untuk pengguna yang berisi informasi tentang pemandangan umum (dimensi, gambar, parameter pencahayaan) dan informasi tentang setiap jenis luminer yang digunakan, yang menunjukkan posisi, arah karakteristik, serta diagram KCC dan tampilan badan fotometrik. <br>  Karena laporan itu akan ditampilkan di iOS dan Android, itu perlu untuk menghasilkan laporannya langsung di modul Unity, dan kemudian menampilkannya menggunakan alat asli standar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aw/fo/je/awfojewyanvogdxu6sihv6zr-i8.png" alt="gambar"></div><br>  Untuk membangun pdf, pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">iTextSharp</a> dipilih yang memenuhi persyaratan kami.  Membuat laporan di dalamnya tidak terlalu sulit dan terdiri dari membuat blok teks, tabel, gambar langsung dari kode.  Namun, selama pengembangan, kami dihadapkan dengan banyak nuansa, solusi yang kadang-kadang membutuhkan upaya yang cukup besar.  Masalah utamanya adalah peluncuran pembuatan laporan di utas latar belakang. <br><br>  Jika saat pengujian pada mesin desktop, pembuatan pdf berada di urutan beberapa detik, maka saat pengujian pada iPad mini 3 kali ini dengan mudah mencapai 1-3 menit.  Secara alami, pembuatan laporan perlu ditransfer ke utas terpisah, untuk menghindari masalah dengan penangguhan antarmuka.  Dalam kasus umum, ini bukan masalah, tetapi ini bukan kasus ketika menggunakan Unity, di mana ia secara eksplisit dilarang untuk menggunakan Unity API dari luar utas utama.  Pada saat yang sama, untuk laporan kami membutuhkan, paling tidak, untuk membuat CSS dan gambar pemandangan, yang harus dilakukan hanya dari aliran utama. <br><br>  Jadi, untuk membangun laporan, kita perlu menjalankan tugas dalam urutan tertentu, dan pada saat yang sama, beberapa dari mereka dapat bekerja di utas latar belakang, dan sebagian harus diluncurkan di yang utama. <br><br>  Sekilas, untuk mengatasi masalah ini, Anda dapat mencoba menggunakan mekanisme standar dan menjalankan setiap operasi dalam coroutine terpisah.  Namun, ini tidak menyelamatkan kita dari masalah pengereman antarmuka.  Seperti yang Anda ketahui, coroutine bekerja di utas utama dan tidak cocok untuk operasi yang lambat.  Pada saat yang sama, ketika membuat laporan, banyak operasi memerlukan waktu yang signifikan, dan karena itu coroutine tidak dapat membantu menyelesaikan masalah kita. <br><br><h4>  UniRx </h4><br>  Solusi lain adalah dengan membagi kode menjadi bagian yang perlu bekerja di utas utama dan bagian yang dapat dijalankan di utas terpisah.  Dalam hal ini, misalnya, gambar dapat dibangun menggunakan mekanisme coroutine, dan kemudian mereka dapat tertanam dalam laporan dalam aliran yang terpisah.  Namun, dalam hal ini, perlu untuk menyimpan hasil antara di suatu tempat, yang memberlakukan batasan tambahan pada jumlah memori yang digunakan atau ruang kosong pada perangkat. <br><br>  Dalam aplikasi kami, kami lebih memilih untuk langsung dan menjalankan tugas secara berurutan di utas utama atau di utas latar.  Satu-satunya masalah adalah bagaimana mengatur peluncuran tugas-tugas tersebut agar tidak terjebak dalam kekacauan ini dan menyinkronkan operasi dengan benar. <br>  Bantuan signifikan dalam memecahkan masalah ini dibawa oleh penggunaan Rx, perwujudannya sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aset</a> UniRx gratis, yang sudah dijelaskan secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hub</a> . <br><br>  Penggunaannya telah sangat menyederhanakan interaksi antara utas dan contoh di bawah ini menunjukkan Anda dapat menjalankan beberapa metode dalam urutan yang ketat, tetapi dalam utas berbeda <br><br><div class="spoiler">  <b class="spoiler_title">Contoh kode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initializer = Observable.FromCoroutine(initMethod); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> heavyMethod1 = Observable.Start(() =&gt; doHardWork()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mainThread1 = Observable.FromCoroutine(renderImage); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> heavyMethod2 = Observable.Start(() =&gt; doHardWork2()); initializer.SelectMany(heavyMethod1) .SelectMany(mainThread1) .SelectMany(heavyMethod2) .ObserveOnMainThread() .Subscribe((x) =&gt; done()) .AddTo(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre><br>  Dalam contoh ini, metode doHardWork () akan dijalankan secara berurutan di utas latar belakang.  Setelah selesai, renderImage () akan diluncurkan di utas utama, dan setelah itu doHardWork2 () akan dieksekusi lagi di utas latar belakang. <br></div></div><br>  Perlu juga dicatat bahwa selama analisis pembuatan laporan untuk kinerja ditemukan bahwa bagian paling lambat adalah implementasi gambar dalam laporan.  Pencarian di Internet menunjukkan bahwa kami bukan satu-satunya yang menghadapi masalah ini, tetapi tidak ada solusi yang cocok untuk kami.  Kami harus sedikit mengurangi kualitas gambar ke tingkat yang dapat diterima, yang memberikan peningkatan kecepatan sebesar 20-40%. <br><br>  Jadi, dalam aplikasi yang kami buat, adalah mungkin untuk berhasil memperkenalkan mesin grafis Unity ke dalam aplikasi iOS / Android asli.  Ini berbeda dari pendekatan tradisional ketika Unity adalah bagian utama dari aplikasi dan membahas sifat spesifik sistem melalui sistem plug-in.  Pada saat yang sama, pendekatan kami dapat berguna jika Anda perlu mengembangkan antarmuka asli yang rumit di mana Anda ingin menanamkan grafik 3D non-sepele. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417779/">https://habr.com/ru/post/id417779/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417769/index.html">Desain Memori Pengguna: Cara Desain Untuk Usia</a></li>
<li><a href="../id417771/index.html">Paket ICANN: Perusahaan Menawarkan Model Manajemen DNS Root Server Baru</a></li>
<li><a href="../id417773/index.html">Pemasang Komponen OpenPnP buatan sendiri</a></li>
<li><a href="../id417775/index.html">Mekanisme komisi Bitcoin dan mengapa berteman dengan penambang</a></li>
<li><a href="../id417777/index.html">Weekend Reading: 25 bahan untuk penggemar vinyl pemula</a></li>
<li><a href="../id417781/index.html">Probe NASA "menyentuh" â€‹â€‹Matahari - dan tidak meleleh</a></li>
<li><a href="../id417783/index.html">Optimasi Digunakan dengan Python: Daftar dan Tuple</a></li>
<li><a href="../id417785/index.html">Administrator sistem mana yang tidak memimpikan perusahaan outsourcing-nya?</a></li>
<li><a href="../id417787/index.html">Pengalaman Kerja Saya pada Peran Pelatih Agile di Eropa, Bagian Satu</a></li>
<li><a href="../id417789/index.html">Diskusi tentang Prospek Telekomunikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>