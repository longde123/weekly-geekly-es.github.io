<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèº üë®üèæ üîª Angular: ngx-translate. Melhorando a infraestrutura com o Webpack üêÇ üö£üèº üßïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia 


 Est√° na hora de ngx-traduzir hacks de vida. Inicialmente, planejei tr√™s partes, mas como a segunda parte n√£o √© realmente muito informativa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular: ngx-translate. Melhorando a infraestrutura com o Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413787/"><p>  Bom dia </p><br><p>  Est√° na hora de ngx-traduzir hacks de vida.  Inicialmente, planejei tr√™s partes, mas como a segunda parte n√£o √© realmente muito informativa - tentarei resumir a segunda parte o mais breve poss√≠vel. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> </p><br><p> Considere <code>AppTranslateLoader</code> para substituir o <code>TranslateHttpLoader</code> .  Nosso <code>AppTranslateLoader</code> , em primeiro <code>AppTranslateLoader</code> prestar√° aten√ß√£o ao idioma do navegador e conter√° a l√≥gica de fallback, importar√° as localiza√ß√µes do MomentJs e carregar√° atrav√©s do APP_INITIALIZER.  Al√©m disso, como resultado da combina√ß√£o de duas partes dos hacks, ao longo do caminho, vamos nos aprofundar na cria√ß√£o de uma infraestrutura de localiza√ß√£o conveniente e flex√≠vel no projeto. </p><br><p>  O objetivo principal n√£o √© <code>AppTranslateLoader</code> (porque √© bastante simples e n√£o √© dif√≠cil de fazer), mas a cria√ß√£o de infraestrutura. </p><br><p>  Tentei escrever o mais acess√≠vel poss√≠vel, mas como o artigo tem muitas coisas que podem ser descritas em mais detalhes - levar√° muito tempo e n√£o ser√° interessante para quem j√° sabe como.  Portanto, o artigo n√£o foi muito amig√°vel para iniciantes.  Por outro lado, no final, h√° um link para exemplo de prodg. </p><a name="habracut"></a><br><p>  Antes de come√ßar, quero observar que, al√©m do download de idiomas via http, √© poss√≠vel escrever um carregador de forma que carregue os idiomas necess√°rios em nosso pacote na fase de montagem.  Portanto, voc√™ n√£o precisa adicionar carregadores para http, mas, por outro lado, com essa abordagem, ser√° necess√°rio reconstruir o aplicativo toda vez que alterarmos nossos arquivos com localiza√ß√µes, al√©m disso, isso poder√° aumentar bastante o tamanho do pacote .js. </p><br><pre> <code class="hljs pgsql">// webpack-translate-loader.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TranslateLoader } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@ngx-translate/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WebpackTranslateLoader implements TranslateLoader { getTranslation(lang: string): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.fromPromise(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(`../assets/i18n/${lang}.json`)); } }</code> </pre> <br><p>  Se o IDE xingar no <code>System</code> voc√™ precisar√° adicion√°-lo a typings.d.ts: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; interface <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(request: string): Promise&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;; }</code> </pre> <br><p>  Agora podemos usar o <code>WebpackTranslateLoader</code> no app.module: </p><br><pre> <code class="hljs powershell">@NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [ <span class="hljs-type"><span class="hljs-type">TranslateModule.forRoot</span></span>({ <span class="hljs-type"><span class="hljs-type">loader</span></span>: { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TranslateLoader</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">WebpackTranslateLoader</span></span> } }) ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <cut></cut><br><h4 id="apptranslateloader">  AppTranslateLoader </h4><br><p>  Ent√£o, vamos come√ßar a escrever nosso <code>AppTranslateLoader</code> .  Para come√ßar, quero identificar v√°rios problemas que ter√£o que ser encontrados usando o <code>TranslateHttpLoader</code> padr√£o: </p><br><ul><li><p>  <strong>Traduzir cintilando.</strong>  <code>TranslateHttpLoader</code> n√£o sabe como executar como parte do processo de inicializa√ß√£o do aplicativo e podemos entrar em uma situa√ß√£o em que, ap√≥s a inicializa√ß√£o, vemos que temos o local para os r√≥tulos corretos no aplicativo - as chaves (MY_BUTTON_KEY √© o local do bot√£o My), que ap√≥s um momento muda para o texto correto. </p><br></li><li><p>  <strong>Datas</strong>  Seria bom ter um servi√ßo que alterna a localiza√ß√£o de datas.  Quando se trata de localizar texto, √© prov√°vel que voc√™ precise cuidar da localiza√ß√£o de datas, hor√°rios, etc.  Voc√™ pode usar momentJs ou a solu√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">i18n</a> incorporada ao Angular.  Ambas as solu√ß√µes s√£o boas e possuem tubos Angular 2+ para formata√ß√£o de vistas. </p><br></li><li>  <strong>Armazenamento em cache.</strong>  usando o <code>TranslateHttpLoader</code> , voc√™ deve configurar seu servidor FE para armazenar em cache corretamente seus pacotes configur√°veis ‚Äã‚Äãjson.  Caso contr√°rio, os usu√°rios ver√£o vers√µes antigas da localiza√ß√£o, pior ser√£o as chaves de localiza√ß√£o (se novas foram adicionadas ap√≥s o cache pelo usu√°rio).  N√£o quero me incomodar toda vez que implanto em um novo servidor com o momento de configurar o cache.  Portanto, faremos com que o Webpack fa√ßa tudo por n√≥s da maneira que faz nos pacotes .js. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rascunho de AppTranslateLoader</a> </p><cut></cut><br><h5 id="resheniya-problem">  Solu√ß√µes para problemas: </h5><br><h6 id="1-problema-translate-flickering---ispolzovat-apptranslateloaderv-ramkah-app_initializer">  1. traduza o problema de tremula√ß√£o - use <code>AppTranslateLoader</code> como parte de <code>APP_INITIALIZER</code> </h6><br><p>  APP_INITIALIZER tamb√©m esteve envolvido ativamente em um artigo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">token de atualiza√ß√£o</a> , se n√£o tiver bom gosto sobre o inicializador - aconselho a ler o artigo, apesar do fato de ser sobre token de atualiza√ß√£o.  De fato, a decis√£o de usar o inicializador √© muito √≥bvia (para quem tem um inicializador), mas ainda espero que haja pessoas que venham a calhar: </p><br><pre> <code class="hljs powershell">//app.module.ts export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translationLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: AppTranslateLoader)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; loader.loadTranslation(); } @NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">APP_INITIALIZER</span></span>, <span class="hljs-type"><span class="hljs-type">useFactory</span></span>: <span class="hljs-type"><span class="hljs-type">translationLoader</span></span>, <span class="hljs-type"><span class="hljs-type">deps</span></span>: [<span class="hljs-type"><span class="hljs-type">AppTranslateLoader</span></span>], <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><h6 id="2-problema-dat-prosto-budem-pereklyuchat-yazyk-v-momentjs-vmeste-c-ngx-tranlate">  2. O problema das datas.  Vamos apenas mudar o idioma em momentosJs junto com ngx-trad. </h6><br><p>  Tudo √© simples aqui - depois que o json com localiza√ß√£o √© carregado, apenas mudamos a localiza√ß√£o para momentJs (ou i18n). </p><br><p>  Tamb√©m √© importante notar que os momentJs, como o i18n, podem importar localiza√ß√µes separadamente, os momentJs tamb√©m podem importar um pacote, mas o pacote inteiro de localiza√ß√µes leva ~ 260 KB e voc√™ precisa apenas de dois deles. </p><br><p>  Nesse caso, voc√™ pode importar apenas dois deles diretamente no arquivo em que o <code>AppTranslateLoader</code> declarado. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>;</code> </pre> <br><p>  Agora, as localiza√ß√µes en-gb e ru estar√£o no pacote de aplicativos js.  No <code>AppTranslateLoader</code> voc√™ pode adicionar um manipulador de idioma carregado recentemente: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> Class AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . }</code> </pre> <br><p>  !!!  este manipulador tem uma desvantagem: se em nosso projeto apenas a localiza√ß√£o en for fornecida para ngx-translate, mas por exemplo, momento ou precisar usar en ou en-gb, a l√≥gica do processador precisar√° ser expandida ou a localiza√ß√£o en-gb tamb√©m dever√° ser fornecida em ngx-translate. </p><br><p>  !!!  no momento com // TODO: podemos escrever um plug-in para o webpack, consideraremos alguns plug-ins mais tarde, mas ainda n√£o o tenho. </p><br><p>  Voc√™ pergunta, por que √© imposs√≠vel carregar localiza√ß√µes de datas e horas, bem como localiza√ß√µes de texto na interface (dinamicamente, via HTTP)?  Isso ocorre porque as localiza√ß√µes de data cont√™m sua pr√≥pria l√≥gica e, portanto, s√£o apresentadas como c√≥digo <a href="">javascript</a> . </p><br><p>  Mas, apesar disso, existe uma maneira de carregar essas localiza√ß√µes escrevendo um pequeno c√≥digo 'sujo'.  Eu n√£o uso esse c√≥digo na produ√ß√£o, mas a segunda localiza√ß√£o dentro do meu pacote n√£o me incomoda.  Mas se voc√™ possui muitas localiza√ß√µes, deseja carreg√°-las dinamicamente e de maneira n√£o muito segura, lembre-se: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadAngularCulture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angularLocaleText = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(`assets/angular-locales/${locale}.js`).toPromise(); <span class="hljs-comment"><span class="hljs-comment">// extracting the part of the js code before the data, // and i didn't need the plural so i just replace plural by null. const startPos = angularLocaleText.indexOf('export default '); angularLocaleText = 'return ' + angularLocaleText.substring(startPos + 15).replace('plural', null); // The trick is here : to read cldr data, i use a function const f = new Function(angularLocaleText); const angularLocale = f(); // console.log(angularLocale); // And now, just registrer the object you just created with the function registerLocaleData(angularLocale); }</span></span></code> </pre> <br><p>  A √∫ltima vez que testei esse m√©todo no Angular 4. Provavelmente ele est√° funcionando agora. </p><br><p>  Infelizmente, esse truque de vida sujo n√£o funcionar√° no caso de c momentJs (apenas localiza√ß√£o angular).  Pelo menos n√£o consegui encontrar uma maneira de fazer isso, mas se voc√™ √© um programador de hackers muito barbudo, ficarei feliz em ver a solu√ß√£o nos coment√°rios. </p><br><h6 id="3-keshirovanie-podobno-sborke-js-bandla-mozhno-dobavit-k-imeni-json-bandla-hesh">  3. Armazenamento em cache.  Semelhante √† cria√ß√£o de um pacote configur√°vel .js, voc√™ pode adicionar um hash ao nome do pacote configur√°vel .json. </h6><br><p>  Tudo depende de como exatamente voc√™ coleta todos os json'es em um arquivo, talvez voc√™ tenha apenas tudo em um arquivo.  Na Internet, voc√™ pode encontrar v√°rios m√≥dulos npm que podem coletar json pequeno em um arquivo.  N√£o encontrei aqueles que podem anexar um hash e coletar tudo em um arquivo.  O pr√≥prio Webpack tamb√©m n√£o pode manipular o json conforme exigido pelos detalhes do ngx-translate.  Portanto, escreveremos nosso plugin webpack. </p><br><p>  Em resumo: precisamos coletar todos os json no projeto de acordo com um padr√£o espec√≠fico, enquanto precisamos agrup√°-los por nome (en, ru, de, etc.), porque, por exemplo, en.json pode estar em pastas diferentes.  Em seguida, para cada arquivo coletado, voc√™ precisa anexar um hash. </p><br><p>  H√° um problema aqui.  Como o <code>AppTranslateLoader</code> reconhece os nomes dos arquivos se cada localiza√ß√£o tem seu pr√≥prio nome?  Por exemplo, incluindo o pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">configur√°vel</a> em index.html, podemos incluir o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HtmlWebpackPlugin</a> e solicitar que ele adicione uma tag de script com o nome do pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">configur√°vel</a> por si s√≥. </p><br><p>  Para resolver esse problema nas localiza√ß√µes .json, nosso plugin webpack criar√° o config.json, que conter√° a associa√ß√£o do c√≥digo do idioma ao nome do arquivo hash: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"en.some_hash.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.some_hash.json"</span></span> }</code> </pre> <br><p>  O config.json tamb√©m ser√° armazenado em cache pelo navegador, mas levar√° um pouco e podemos simplesmente especificar um par√¢metro queryString aleat√≥rio quando GET aumentar o tamanho desse arquivo (portanto, carreg√°-lo constantemente novamente).  Ou atribua um ID aleat√≥rio ao config.json (descreverei esse m√©todo, o primeiro pode ser encontrado no Google). </p><br><p>  Tamb√©m quero simplificar um pouco a infraestrutura e a atomicidade das localiza√ß√µes.  O json com localiza√ß√£o estar√° na pasta com seu componente.  E, para evitar chaves duplicadas, a estrutura do pacote json ser√° constru√≠da com base no caminho para um arquivo json espec√≠fico.  Por exemplo, temos dois en.json, um localizado no caminho <code>src/app/article-component</code> e o outro <code>src/app/comment-component</code> .  Eu quero obter o seguinte json na sa√≠da: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"article-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Article title"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comment-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Comment title"</span></span> } }</code> </pre> <br><p>  Podemos descartar a parte do caminho que n√£o precisamos, para que as chaves fiquem o mais curtas poss√≠vel nas visualiza√ß√µes. </p><br><p>  !!!  Existe uma desvantagem: quando voc√™ coloca o componente em outra pasta, a chave de localiza√ß√£o muda. </p><br><p>  Posteriormente, consideraremos outro truque de vida que nos permitir√° indicar no componente apenas o √∫ltimo campo-chave, independentemente de onde e qu√£o profundo nosso projeto est√° no projeto, e, portanto, podemos transferi-lo como desejar e renomear como quiser. </p><br><p>  Basicamente, eu quero alcan√ßar o encapsulamento e at√© uma dica de polimorfismo das localiza√ß√µes de convers√£o de ngx.  Gosto do conceito de encapsular vistas no encapsulamento Angular - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Angular View</a> , ou melhor, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DOM DOM</a> .  Sim, isso aumenta o tamanho do aplicativo como um todo, mas direi antecipadamente que depois que o ngx-translate se tornou mais encapsulado, trabalhar com arquivos de localiza√ß√£o se tornou muito mais agrad√°vel.  Os componentes come√ßaram a se importar apenas com suas localiza√ß√µes. Al√©m disso, ser√° poss√≠vel redefinir as localiza√ß√µes no componente filho, dependendo das localiza√ß√µes no componente pai.  Al√©m disso, agora voc√™ pode transferir componentes de um projeto para outro, e eles j√° estar√£o localizados.  Mas como em outros lugares, h√° nuances, mais sobre isso mais tarde. </p><br><p>  Ent√£o vamos ao nosso plugin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que √© e como</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mesclar o plug-in de localiza√ß√£o</a> . <br>  O c√≥digo-fonte do carregador e do plug-in pode ser encontrado no link de exemplo na parte inferior do artigo (pasta ./build-utils). </p><br><p>  O plug-in faz tudo com o que est√° escrito acima e aceita as seguintes op√ß√µes: </p><br><ul><li>  omitir.  nomes no caminho para a localiza√ß√£o que precisam ser ignorados (este √© exatamente o momento em que desejo remover as partes extras do caminho para o arquivo) </li><li>  fileInput.  regular para buscar arquivos de localiza√ß√£o no prodge (como teste no webpack) </li><li>  rootDir.  por onde come√ßar a procurar arquivos pelo padr√£o fileInput </li><li>  outputDir.  onde o arquivo de configura√ß√£o e as localiza√ß√µes ser√£o criados na pasta dist </li><li>  configName.  sob qual nome o arquivo de configura√ß√£o ser√° criado. </li></ul><br><p>  No meu projeto, o plugin est√° conectado desta maneira: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// build-utils.js // part of METADATA { // ... translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config.${Math.random().toString(36).substr(2, 9)}.json`, } //webpack.common.js new MergeLocalizationPlugin({ fileInput: [`**/${METADATA.translationsFolder}/*.json`, 'app-translations/**/*.json'], rootDir: 'src', omit: new RegExp(`app-translations|${METADATA.translationsFolder}|^app`, 'g'), outputDir: METADATA.translationsOutputDir, configName: METADATA.translationsConfig }),</span></span></code> </pre> <br><p>  Dentro dos componentes que precisam de localiza√ß√£o, existe uma pasta <code>@translations</code> , que cont√©m en.json, ru, etc. </p><br><p>  Como resultado, ao inverter, tudo ser√° coletado em um arquivo, levando em considera√ß√£o o caminho para a pasta <code>@translations</code> .  O pacote de localiza√ß√£o estar√° em dist / langs / e a configura√ß√£o ser√° nomeada como config. $ {Some-random} .json. </p><br><p>  Em seguida, garantiremos que o pacote de localiza√ß√£o desejado seja carregado no aplicativo.  H√° um momento fr√°gil - apenas o webpack sabe sobre o caminho para as localiza√ß√µes e o nome do arquivo de configura√ß√£o, vamos levar isso em considera√ß√£o para que os dados mais recentes entrem no AppTranslateLoader e n√£o seja necess√°rio alterar os nomes em dois lugares. </p><br><pre> <code class="hljs powershell">// some inmports // ... // momentJs import * as moment from <span class="hljs-string"><span class="hljs-string">'moment'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>; @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppTranslateLoader</span></span></span></span> { //            public additionalStorageKey: string = <span class="hljs-string"><span class="hljs-string">''</span></span>; private translationsDir: string; private translationsConfig: string; private selectedLang: string; private fallbackLang: string; private loadedLang: string; private config: { [<span class="hljs-type"><span class="hljs-type">key</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]: string; } = null; private loadSubs = new Subscription(); private configSubs = new Subscription(); private loadSubj = new Subject(); private get storageKey(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.additionalStorageKey ? `APP_LANG_<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.additionalStorageKey}` : <span class="hljs-string"><span class="hljs-string">'APP_LANG'</span></span>; } constructor(private http: HttpClient, private translate: TranslateService) { //   webpack       //     . this.translationsDir = `${process.env.TRANSLATE_OUTPUT}`; this.translationsConfig = `${process.env.TRANSLATE_CONFIG}`; this.fallbackLang = <span class="hljs-string"><span class="hljs-string">'en'</span></span>; const storedLang = this.getUsedLanguage(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (storedLang) { this.selectedLang = storedLang; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.selectedLang = translate.getBrowserLang() || this.fallbackLang; } } }</code> </pre> <br><p>  <code>process.env.TRANSLATE_OUTPUT</code> simplesmente n√£o funcionar√°, precisamos declarar outro plugin no webpack (DefinePlugin ou EnvironmentPlugin): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// METADATA declaration const METADATA = { translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config. ${Math.random().toString(36).substr(2, 9)}.json`, }; // complex webpack config... // webpack plugins... new DefinePlugin({ 'process.env.TRANSLATE_OUTPUT': JSON.stringify(METADATA.translationsOutputDir), 'process.env.TRANSLATE_CONFIG': JSON.stringify(METADATA.translationsConfig), }),</span></span></code> </pre> <br><p>  Agora podemos mudar o caminho para localiza√ß√µes e o nome da configura√ß√£o em apenas um lugar. <br>  Por padr√£o, a partir da venda Angular padr√£o gerada no assembly da Webpack ( <code>ng eject</code> ), n√£o √© poss√≠vel especificar <code>process.env.someValue</code> partir do c√≥digo (mesmo se voc√™ usar o DefinePlugin), o compilador pode jurar.  Para que isso funcione, √© necess√°rio atender √†s condi√ß√µes 2a: </p><br><ul><li>  em main.ts adicione a 1¬™ linha <code>/// &lt;reference types="node"/&gt;</code> </li><li>  O package.json deve ter <code>@types/node</code> - <code>npm install --save-dev @types/node</code> . </li></ul><br><p>  Prosseguimos diretamente para o processo de inicializa√ß√£o. <br>  Se voc√™ pretende usar APP_INITIALIZER, retorne Promise, n√£o Observable.  Nossa tarefa √© escrever uma cadeia de consultas: </p><br><ul><li>  Primeiro voc√™ precisa baixar o config.json (apenas se n√£o estiver carregado). </li><li>  tente carregar o idioma, que √© o idioma do navegador do usu√°rio </li><li>  Forne√ßa l√≥gica de fallback com o idioma de download padr√£o. </li></ul><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> imports @Injectable() AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fields ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,         <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subscription    unsubscribe    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   private loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); private configSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       -   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subject       private loadSubj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> constructor ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Promise! public loadTranslation(lang: string = <span class="hljs-string"><span class="hljs-string">''</span></span>): Promise&lt;any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lang) { lang = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lang === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsConfig}</span></span>`) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config = config; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.asObservable().toPromise(); } private loadAndUseLang(lang: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[lang] || </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.fallbackLang]}</span></span>`) .subscribe(res =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.setTranslation(lang, res); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(lang).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(lang); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  ngx-translate   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  http   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); } private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . } private onLoadLangError(langKey: string, error: any) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) .subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(err)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (langKey !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      fallback  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(error); } }</code> </pre> <br><p>  Feito. </p><br><p>  Agora, voltemos ao problema de mover componentes para outras pastas, encapsulamento e semelhan√ßa de polimorfismo. </p><br><p>  De fato, j√° temos algum tipo de encapsulamento.  As localiza√ß√µes s√£o colocadas em pastas ao lado dos componentes, todos os caminhos de chave s√£o √∫nicos, mas ainda podemos localizar as chaves do componente some-component1 dentro de some-component2 e ser√° dif√≠cil acompanhar tudo, descobriremos mais adiante. </p><br><pre> <code class="hljs powershell">&lt;some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span> [<span class="hljs-type"><span class="hljs-type">someLabel</span></span>]=<span class="hljs-string"><span class="hljs-string">"'components.some-component2.some_key' | tanslate"</span></span>&gt;&lt;/some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span>&gt; // components.some<span class="hljs-literal"><span class="hljs-literal">-component2</span></span> -    </code> </pre> <br><p>  Em rela√ß√£o ao movimento de componentes: <br>  Agora, a chave que usaremos na exibi√ß√£o est√° rigidamente vinculada ao caminho relativo do arquivo de localiza√ß√£o e depende da infraestrutura espec√≠fica do projeto. </p><br><p>  Vou dar um caso bastante triste dessa situa√ß√£o: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"+lazy-module.components.article-component.article_title"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Mas e se eu mudar o nome da pasta do componente para p√≥s-componente? <br>  Ser√° muito dif√≠cil inserir essa chave em todos os lugares necess√°rios.  Obviamente, ningu√©m cancelou copiar e colar e encontrar e substituir, mas escrever isso sem as instru√ß√µes do IDE tamb√©m √© estressante. </p><br><p>  Para resolver esses problemas, vamos prestar aten√ß√£o no que o webpack est√° fazendo sobre isso?  O Webpack possui um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregador</a> , existem muitos carregadores dispon√≠veis que operam nos caminhos de arquivos: por exemplo, caminhos de recursos em css - gra√ßas ao webpack, podemos especificar os caminhos relativos da imagem de fundo: url (../ relative.png) e assim por diante. o restante dos caminhos de arquivo no projeto est√£o em toda parte! </p><br><p>  Quem criou seu webpack cria sabe que o carregador recebe um arquivo na entrada que corresponde a um determinado padr√£o.  A tarefa do pr√≥prio carregador √©, de alguma forma, transformar esse arquivo de entrada e devolv√™-lo, para altera√ß√µes adicionais por outros carregadores. </p><br><p>  Portanto, precisamos escrever nosso carregador.  A quest√£o √© que tipo de arquivo vamos alterar: visualiza√ß√µes ou componentes?  Por um lado, as visualiza√ß√µes podem estar diretamente no componente e separadamente.  As visualiza√ß√µes podem ser grandes o suficiente e dif√≠ceis de analisar, imagine se tivermos uma visualiza√ß√£o em que 100 diretivas de convers√£o (n√£o em loop): </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'./some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"100"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'../another_key_!'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre><br><p>  atrav√©s do carregador, podemos substituir o caminho principal para localiza√ß√µes de componentes perto de cada tubo ou diretiva. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'app.some-component.some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// app.some-component. -   loader'</span></span></code> </pre> <br><p>  podemos adicionar um campo a um componente que fornece localiza√ß√£o: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-some'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;div&gt;{{(localization + '</span></span></span><span class="hljs-meta">key</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">') | tanslate}}&lt;/div&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ localization = <span class="hljs-string"><span class="hljs-string">'./'</span></span> }</code> </pre> <br><p>  Tamb√©m √© ruim - voc√™ precisa compor uma chave de localiza√ß√£o em qualquer lugar. </p><br><p>  Como as op√ß√µes mais √≥bvias parecem ruins, tente usar um decorador e salve alguns metadados no prot√≥tipo do componente (como o Angular). </p><br><p><img src="https://habrastorage.org/webt/gu/_4/vp/gu_4vpfjn_3ujxoh3tragj7wi2s.png" alt="imagem"></p><br><p>  <strong>anota√ß√µes</strong> - metadados para decoradores angulares <br>  __app_annotations__ - metadados que armazenaremos para n√≥s mesmos </p><br><p>  O caminho para a pasta de localiza√ß√£o em rela√ß√£o ao componente pode ser gravado no decorador, o mesmo decorador pode ser expandido com outras op√ß√µes, exceto o caminho. </p><br><pre> <code class="hljs powershell">//translate.service.ts const app_annotations_key = <span class="hljs-string"><span class="hljs-string">'__app_annotations__'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Localization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: string)</span></span></span></span> { // tslint:<span class="hljs-built_in"><span class="hljs-built_in">disable-next</span></span><span class="hljs-literal"><span class="hljs-literal">-line</span></span>:only<span class="hljs-literal"><span class="hljs-literal">-arrow</span></span><span class="hljs-literal"><span class="hljs-literal">-functions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target: Function)</span></span></span></span> { const metaKey = app_annotations_key; Object.defineProperty(target, metaKey, { value: { //         path. path, name: <span class="hljs-string"><span class="hljs-string">'Translate'</span></span> } } as PropertyDescriptor); }; } //some.component.ts @Component({...}) @Localization({ path: <span class="hljs-string"><span class="hljs-string">'./'</span></span>, otherOptions: {...} }); export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span></span> { }</code> </pre> <br><p>      webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loader</a>           ,      -    .          ,     (      styleUrls)      . loader,     npm .    . </p><br><p>        ,   -.       ,          -. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'just_key'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre> <br><p>          .    ,      ,      ,           .    ‚Äî Injector, .   ,       Injector,     ''  ,  translate       .      Injector,       (    ),         'get'. </p><br><p><img src="https://habrastorage.org/webt/jl/vw/0x/jlvw0xsep9o3valmkhc3uxblvdm.png" alt="imagem"></p><br><p>  ,  parent  ,     ,    Injector'a  ,      ,     ,   ,   ,        . </p><br><p>  ,     API,   forwarRef() (    Angular reactive forms,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">control</a> ).  ,      .         . </p><br><pre> <code class="hljs powershell">// translate.service.ts export const TRANSLATE_TOKEN = new InjectionToken(<span class="hljs-string"><span class="hljs-string">'MyTranslateToken'</span></span>); // app.component.ts @Component({ selector: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, templateUrl: <span class="hljs-string"><span class="hljs-string">'./app.component.html'</span></span>, styleUrls: [<span class="hljs-string"><span class="hljs-string">'./app.component.css'</span></span>], providers: [{<span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TRANSLATE_TOKEN</span></span>, <span class="hljs-type"><span class="hljs-type">useExisting</span></span>: <span class="hljs-type"><span class="hljs-type">forwardRef</span></span>(() =&gt; <span class="hljs-type"><span class="hljs-type">AppComponent</span></span>)}] }) @Localization(<span class="hljs-string"><span class="hljs-string">'./'</span></span>) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span> { title = <span class="hljs-string"><span class="hljs-string">'app'</span></span>; }</code> </pre> <br><p>        , ,         ,   forwardRef(). </p><br><p>  ,     Injector     forwardRef()        ,             .       ,        '' .     ,   ,   . </p><br><pre> <code class="hljs pgsql">// my-translate.directive.ts @Directive({ // tslint:<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>-next-<span class="hljs-type"><span class="hljs-type">line</span></span>:directive-selector selector: <span class="hljs-string"><span class="hljs-string">'[myTranslate]'</span></span> }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyTranslateDirective extends TranslateDirective { @<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> myTranslate(e: string) { this.translate = e; } private keyPath: string; constructor(private _translateService: TranslateService, private _element: ElementRef, _chRef: ChangeDetectorRef, //    forwardRef() @Inject(TRANSLATE_TOKEN) @Optional() protected cmp: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>) { super(_translateService, _element, _chRef); //    const prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getPrototypeOf(cmp || {}).constructor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prototype[app_annotations_key]) { //      this.keyPath = prototype[app_annotations_key].path; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> updateValue(key: string, node: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, translations: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.keyPath) { //     ,   //   key = `${this.keyPath.replace(/\//, <span class="hljs-string"><span class="hljs-string">'.'</span></span>)}.${key}`; } super.updateValue(key, node, translations); } }</code> </pre> <br><p>      . </p><br><p>  -      : </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'just_this_component_key' | myTranslate}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">myTranslate</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"just_this_component_key"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>    translate , .      ,       ,          -    : </p><br><pre> <code class="hljs pgsql">//en.bundle.json { "global_key": "Global key" "app-component": { "just_key": "Just key" } } //<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.html &lt;div translate="global_key"&gt;&lt;/div&gt;</code> </pre> <br><p> Research and improve! </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">full example</a> </p><br><p>       : </p><br><ol><li>     FE     node.js   stacktrace.js. </li><li>  Jest  Angular . </li><li> Web worker )      , ,  Angular  . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413787/">https://habr.com/ru/post/pt413787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413775/index.html">Ataques adversos na Machines Can See 2018</a></li>
<li><a href="../pt413777/index.html">Leitura de fim de semana: materiais introdut√≥rios de IaaS, seguran√ßa da informa√ß√£o e eventos regulat√≥rios de TI</a></li>
<li><a href="../pt413779/index.html">Temporizadores e multitarefa no Arduino</a></li>
<li><a href="../pt413781/index.html">Como os Bloodhounds de publicidade seguem sua trilha na Internet</a></li>
<li><a href="../pt413783/index.html">Como morrem as estrelas mais massivas: supernova, hipernova ou colapso direto?</a></li>
<li><a href="../pt413789/index.html">Na Fl√≥rida, eles n√£o verificaram os compradores de armas na base do FBI por um ano porque esqueceram a senha</a></li>
<li><a href="../pt413791/index.html">Mec√¢nica Qu√¢ntica de C√°lculos em JS</a></li>
<li><a href="../pt413793/index.html">Cassetes de √°udio na cultura pop: por que o formato obsoleto de grava√ß√£o de som √© novamente considerado moda</a></li>
<li><a href="../pt413795/index.html">Por que a ind√∫stria do entretenimento est√° mudando para o IaaS: estudo de caso</a></li>
<li><a href="../pt413797/index.html">A EA apresentou a nova parte do C&C na E3. E √© fisicamente doloroso olhar para ele</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>