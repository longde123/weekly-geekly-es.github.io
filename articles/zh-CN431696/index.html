<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚗 👨‍✈️ 👶🏽 科丁 基础知识 👨🏽‍💼 😦 👨🏽‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对于第一次Kodein人来说Kodein我找不到可理解的指南，并且该文档在所有地方都不是透明且一致的，因此，我想与您分享该库的主要功能。 一些库功能将发布，但这基本上是高级部分。 在阅读本文时，您会发现一切正常开始，并开始使用Kodein实现依赖关系。 本文基于Kodein 5.3.0 ，因为Kod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>科丁 基础知识</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431696/">对于第一次<code>Kodein</code>人来说<code>Kodein</code>我找不到可理解的指南，并且该文档在所有地方都不是透明且一致的，因此，我想与您分享该库的主要功能。 一些库功能将发布，但这基本上是高级部分。 在阅读本文时，您会发现一切正常开始，并开始使用<code>Kodein</code>实现依赖关系。 本文基于<code>Kodein 5.3.0</code> ，因为<code>Kodein 6.0.0</code>需要<code>Support Library 28</code>或<code>AndroidX</code>并且由于许多第三方库尚未提供兼容版本，因此绝对不会切换到它们。 <br><img src="https://habrastorage.org/webt/uj/ve/am/ujveamkhrxko4wle8mcfugfzjvc.png"><br><a name="habracut"></a><br>  <code>Kodein</code>是用于实现依赖项注入（DI）的库。 如果您不熟悉此概念，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关Dagger2</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>的开头，作者在其中简要介绍DI的理论方面。 <br><br> 在本文中，我们将以Android为例来考虑所有内容，但据开发人员称，Kodein在Kotlin支持的所有平台（JVM，Android，JS，Native）上的行为均相同。 <br><br><h3> 安装方式 </h3><br> 由于Java具有<code>type erasure</code>的事实，因此出现了一个问题-编译器擦除了通用类型。 在字节码级别， <code>List&lt;String&gt;</code>和<code>List&lt;Date&gt;</code>只是<code>List</code> 。 尽管如此，仍然有一种获取有关泛型类型的信息的方法，但是它将花费很多，并且仅在JVM和Android上有效。 在这方面， <code>Kodein</code>开发人员建议使用以下两种依赖关系之一：一种在工作时接收有关广义类型的信息（ <code>kodein-generic</code> ），而另一种则不使用（ <code>kodein-erased</code> ）。 例如，当使用<code>kodein-erased</code> <code>List&lt;String&gt;</code>和<code>List&lt;Date</code> &gt;将被保存为<code>List&lt;*&gt;</code> ，并且使用<code>kodein-generic</code>所有内容将与指定的类型一起保存，即<code>List&lt;String&gt;</code>和<code>List&lt;Date&gt;</code> 。 <br><br> 如何选择？ <br><br>  <b>不要</b>在JVM下写-使用<code>kodein-erased</code> ，否则是不可能的。 <br> 在JVM下进行写操作，性能问题对您来说非常重要-您可以使用<code>kodein-erased</code> ，但是要小心，这种体验在这些词的意义上可能是意料之外的。 如果您创建的常规应用程序没有任何特殊的性能要求，请使用<code>kodein-generic</code> 。 <br><br> 最终，如果考虑到DI对性能的影响，那么大多数依赖关系通常只创建一次，或者创建依赖关系以供重复使用，因此通过此类操作，您不太可能对应用程序的性能产生重大影响。 <br><br> 因此，安装： <br><br> 首先-在存储库之间的build.gradle中应该是jcenter（）（如果不存在）-添加。 <br><br><pre> <code class="plaintext hljs">buildscript { repositories { jcenter() } }</code> </pre><br> 接下来，在依赖关系块中，添加上述基本依赖关系之一： <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-generic-jvm:$version"</code> </pre><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-erased-jvm:$version"</code> </pre><br> 由于我们在谈论Android，因此将会有更多的依赖项。 您当然可以不用它，Kodein可以正常运行，但是为什么拒绝其他对Android有用的功能（我将在本文结尾处讨论它们）？ 选择是您的，但我建议补充。 <br><br> 这里也有选项。 <br><br> 首先，您没有使用<code>SupportLibrary</code> <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-core:$version"</code> </pre><br> 第二次使用 <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-support:$version"</code> </pre><br> 第三-您正在使用AndroidX <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-x:$version"</code> </pre><br><h3> 我们开始创建依赖关系 </h3><br> 使用<code>Dagger2</code> ，我习惯于在应用程序启动时在Application类中创建和初始化依赖项。 <br><br> 使用Kodein，可以这样完成： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> } }</code> </pre><br> 依赖项声明始终以 <br><br><pre> <code class="kotlin hljs">bind&lt;TYPE&gt;() with</code> </pre><br><h4> 标签 </h4><br>  Kodein依赖项标记的功能与<code>Dagger2</code> <code>Qualifier</code> <code>Dagger2</code> 。 在<code>Dagger2</code>您需要执行单独的<code>Qualifier</code>或使用<code>@Named("someTag")</code> ，它实际上也是<code>Qualifier</code> 。 底线很简单-通过这种方式，您可以区分相同类型的两个依赖项。 例如，您需要根据情况获取应用程序或特定<code>Activity</code>的<code>ontext</code> ，因此在声明依赖项时需要为此指定标签。  <code>Kodein</code>允许<code>Kodein</code>声明一个没有标签的依赖项，它是基础的，如果您在接收到依赖项时未指定标签，我们将得到它，另外一个需要加标签，并且在收到依赖项时，需要指定标签。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Context&gt;() with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"main_activity"</span></span>) with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"sale_activity"</span></span>) with ... }</code> </pre><br>  <code>tag</code>参数的类型为<code>Any</code> ，因此您不仅可以使用字符串。 但是请记住，用作标记的类必须实现<code>equals</code>和<code>hashCode</code>方法。 始终有必要将标记作为命名参数传递给函数，而不管是创建依赖项还是接收依赖项。 <br><br><h3> 依赖注入的类型 </h3><br> 有几种在<code>Kodein</code>提供依赖关系的<code>Kodein</code> ， <code>Kodein</code> -创建<code>Kodein</code> 。 单例将位于创建的<code>Kodein</code>实例的框架内。 <br><br><h4> 单身人士介绍 </h4><br> 让我们从一个例子开始： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton { RoomDb() } }</code> </pre><br> 因此，我们提供（提供） <code>IMyDatabase</code> ，在<code>RoomDb</code>将隐藏<code>RoomDb</code>实例。  <code>RoomDb</code>实例将在依赖项的第一个请求时创建；在<code>Kodein</code>新的<code>Kodein</code>实例之前，不会<code>Kodein</code> 。 创建一个单例是同步的，但是如果需要，可以使它不同步。 这将提高生产率，但是您必须了解随之而来的风险。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { RoomDb() } }</code> </pre><br> 如果您不需要在第一次调用时而是在创建<code>Kodein</code>实例后立即创建<code>Kodein</code>实例，请使用另一个函数： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with eagerSingleton { RoomDb() } }</code> </pre><br><h4> 不断创建依赖的新实例 </h4><br> 在访问依赖关系以获取新实例时，可以不创建单调而是连续创建。 为此，使用了<code>provider</code>功能： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMainPresenter&gt;() with provider { QuantityPresenter() } }</code> </pre><br> 在这种情况下，每次我们请求<code>IMainPresenter</code>依赖项时，都会创建一个新的<code>QuantityPresenter</code>实例。 <br><br><h4> 不断创建依赖关系的新实例，并将参数传递给依赖关系的构造函数 </h4><br> 就像上一个示例一样，每次添加依赖项时都可以获取它的新实例，但是要指定用于创建依赖项的参数。 参数最大为<b>5</b> 。 为此，请使用<code>factory</code>方法。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } }</code> </pre><br><h4> 每次我们根据参数创建一个缓存实例 </h4><br> 阅读上一段，您可能会认为，每次根据传递的参数接收一个新实例，而不是接收一个新实例，而是接收对相同参数的依赖项的相同实例，将是一个不错的选择。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br> 在上面的示例中，当我们首先获得具有参数<code>5</code>和<code>10</code>的依赖项时<code>10</code>我们将创建一个<code>IntRandom(5, 10)</code>的新实例，当我们再次使用相同的参数调用该依赖项时，将获得先前创建的实例。 因此，获得了具有延迟初始化的单例<code>map</code> 。 与<code>factory</code>参数最多为<b>5</b> 。 <br><br> 与单调一样，您可以在此处禁用同步。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br><h4> 在Kodein中使用软链接和弱链接 </h4><br> 使用<code>singleton</code>或多<code>singleton</code>提供依赖项时<code>multiton</code>可以指定对存储实例的引用类型。 在上面我们考虑的通常情况下，这将是通常的<code>strong</code>链接。 但是可以使用<code>soft</code>链接和<code>weak</code>链接。 如果您不熟悉这些概念， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请在此处查看</a> 。 <br><br> 因此，您的单调可能会在应用程序生命周期中重新创建，也可能不是。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyMap&gt;() with singleton(ref = softReference) { WorldMap() } bind&lt;IClient&gt;() with singleton(ref = weakReference) { id -&gt; clientFromDB(id) } }</code> </pre><br><h4> 每个流单独的单例 </h4><br> 这是相同的单例，但是对于每个请求依赖项的线程，将创建一个单例。 为此，请使用熟悉的参数<code>ref</code> 。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Cache&gt;() with singleton(ref = threadLocal) { LRUCache(<span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) } }</code> </pre><br><h4> 常量作为可嵌入的依赖项 </h4><br> 您可以提供常量作为依赖项。 该文档提请您注意以下事实：使用<code>Kodein</code>您必须<code>Kodein</code>不带继承或接口的简单类型的常量，例如基元或数据类。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { constant(tag = <span class="hljs-string"><span class="hljs-string">"maxThread"</span></span>) with <span class="hljs-number"><span class="hljs-number">8</span></span> constant(tag = <span class="hljs-string"><span class="hljs-string">"serverURL"</span></span>) with <span class="hljs-string"><span class="hljs-string">"https://my.server.url"</span></span></code> </pre><br><h4> 创建依赖项而不更改类型 </h4><br> 例如，您希望将依赖项作为单例提供，但不要将其隐藏在接口后面。 您根本无法在调用<code>bind</code>时指定类型<code>from</code>而是使用<code>from</code>而不是<code>with</code> 。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind() from singleton { Gson() }</code> </pre><br> 上面示例中的依赖项将具有函数的返回类型，即将<code>Gson</code>类型的依赖项。 <br><br><h4> 创建超类或接口的子类依赖项 </h4><br>  <code>Kodein</code>允许<code>Kodein</code>以不同方式为实现单个接口的一个或多个特定类的后代提供依赖项。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Animal&gt;().subTypes() with { animalType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (animalType.jvmType) { Dog::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eagerSingleton</span></span></span><span class="hljs-class"> </span></span>{ Dog() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; provider { WildAnimal(animalType) } } }</code> </pre><br>  <code>Animal</code>类可以是超类也可以是接口，使用<code>.subtypes</code>我们可以获得<code>TypeToken&lt;*&gt;</code>类型的<code>TypeToken&lt;*&gt;</code> ，从中我们已经可以获取Java类，并根据它以不同的方式提供依赖性。 如果您在许多情况下都使用<code>TypeToken</code>或其派生类作为构造函数参数，则此功能很有用。 同样，通过这种方式，您可以避免为相同类型创建相同的依赖项而导致不必要的代码。 <br><br><h4> 创建需要其他依赖项作为参数的依赖项 </h4><br> 通常，我们不仅创建没有参数作为依赖的类，而且创建需要将参数传递给构造函数的类。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductGateway</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: IProductApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchers: IDispatchersContainer) : IProductGateway</code> </pre><br> 为了创建一个具有以前在<code>Kodein</code>创建的依赖关系的类，只需将instance（）函数调用作为参数传递<code>Kodein</code>足够了。 在这种情况下，创建的顺序并不重要。 <br><br><pre> <code class="kotlin hljs">bind&lt;IDispatchersContainer&gt;() with singleton { DispatchersContainer() } bind&lt;IProductGateway&gt;() with singleton { ProductGateway(instance(), instance()) } bind&lt;IProductApi&gt;() with singleton { ProductApi() }</code> </pre><br> 除了<code>instance()</code>可能还有对<code>provider()</code>或<code>factory()</code>调用；我们将在获取和实现依赖项的部分中仔细研究这些方法。 <br><br><h4> 通过调用先前创建的依赖方法来创建依赖 </h4><br> 听起来不太好，但是您可以调用<code>instance&lt;TYPE&gt;</code>来获取我们已经在某个地方提供的类，然后调用该类的方法以获取新的依赖项。 <br><br><pre> <code class="kotlin hljs">bind&lt;DataSource&gt;() with singleton { MySQLDataSource() } bind&lt;Connection&gt;() with provider { instance&lt;DataSource&gt;().openConnection() }</code> </pre><br><h3> 模组 </h3><br> 使用<code>Dagger2</code> ，我习惯于<code>Dagger2</code>依赖性。 乍一看，在<code>Kodein</code> ，一切看起来都不太好。 您需要在<code>Application</code>类中创建很多依赖关系，而我个人并不喜欢它。 但是有一个解决方案， <code>Kodein</code>还允许您创建模块，然后在需要的地方将它们连接起来。 <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br> 但是请注意，模块只是声明用于获取依赖关系的方法的容器；它们本身不会创建类。 因此，如果您在模块中将接收的接收声明为单例，然后将此模块导入到<code>Kodein</code>两个不同实例中，那么您将获得两个不同的单例，每个<code>Kodein</code>实例一个。 <br><br> 另外，每个模块的名称必须唯一。 但是，如果需要从另一个项目导入模块，则很难保证名称的唯一性；为此，您可以重命名模块或在其名称上添加前缀。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(apiModule.copy(name = <span class="hljs-string"><span class="hljs-string">"firstAPI"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondApiModule.copy(prefix = <span class="hljs-string"><span class="hljs-string">"secondAPI-"</span></span>))</code> </pre><br> 当模块相互依赖并构成某种层次结构时，我习惯于工作。  <code>Kodein</code>可以一次将每个模块导入<code>Kodein</code> ，因此，如果尝试将具有相同相关模块的两个模块导入一个<code>Kodein</code> ，则应用程序将崩溃。 解决方案很简单-您需要使用<code>importOnce(someModule)</code>调用进行导入，这将检查先前是否导入了具有相同名称的模块，然后在必要时进行导入。 <br><br> 例如，在这种情况下，应用程序将崩溃： <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br> 但是，如果<code>importOnce</code>调用正在第二次尝试连接，那么一切都会正常。 小心点 <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><h4> 传承 </h4><br> 如果两次使用同一模块，将创建不同的依赖关系，但是继承和实现类似于<code>Dagger2</code> <code>Subcomponents</code>的<code>Dagger2</code>呢？ 一切都很简单，您只需要从<code>Kodein</code>实例继承，就可以访问继承人中父代的所有依赖项。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   } val subKodein = Kodein { extend(kodein) //   }</span></span></code> </pre><br><h4> 重新定义 </h4><br> 默认情况下，您无法覆盖依赖关系，否则用户会疯狂寻找应用程序无法正常工作的原因。 但是可以使用<code>bind</code>函数的附加参数来执行此操作。 此功能对于组织测试非常有用。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Api&gt;() with singleton { ApiImpl() } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> bind&lt;Api&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { OtherApiImpl() } }</code> </pre><br> 默认情况下，模块及其依存关系不能覆盖<code>Kodein</code>对象中已声明的依存关系，但是在导入模块时，您可以指示现有的依存关系可以覆盖其依存关系，并且在该模块内部，您可以指定其他人可以覆盖的依存关系。 <br><br> 听起来不太清楚，让我们使用示例。 在这些情况下，应用程序将崩溃： <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br> 并且在此情况下，模块依赖项将覆盖<code>Kodein</code>对象中声明的依赖<code>Kodein</code> 。 <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br> 但是，如果您确实想要并且了解自己在做什么，那么可以创建一个模块，如果该模块与<code>Kodein</code>对象具有相同的依赖关系<code>Kodein</code>则将重新定义它们，并且应用程序不会崩溃。 我们为模块使用<code>allowSilentOverride</code>参数。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testModule = Kodein.Module(name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, allowSilentOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { bind&lt;EmailClient&gt;() with singleton { MockEmailClient() } }</code> </pre><br> 该文档讨论了有关继承和重新定义依赖关系以及在继承人中复制依赖关系的更为复杂的情况，但此处将不考虑这些情况。 <br><br><h3> 检索和注入依赖项 </h3><br> 最后，我们弄清楚了如何以多种方式声明依赖关系，是时候弄清楚如何在其类中获取依赖关系了。 <br><br>  <code>Kodein</code>开发人员共享获取依赖项的两种方式- <code>injection</code>和<code>retieval</code> 。 简而言之， <code>injection</code>是指类在创建时即在构造函数中接收所有依赖项的情况，而<code>retrieval</code>是指类本身负责获取其依赖项的情况。 <br><br> 使用<code>injection</code>您的类对<code>Kodein</code>并且该类中的代码更加<code>Kodein</code> ，但是，如果您使用<code>Kodein</code> ，那么您将有机会更灵活地管理依赖项。 在<code>retrieval</code>的情况下，仅在第一次依赖时才延迟<code>retrieval</code>所有依赖。 <br><br><h4> 依赖关系的<code>Kodein</code>方法 </h4><br>  <code>Kodein</code>类的实例具有三种返回依赖项，依赖项工厂或依赖项提供程序的方法-分别是<code>instance()</code> ， <code>factory()</code>和<code>provider()</code> 。 因此，如果使用<code>factory</code>或<code>provider</code>提供依赖项，则不仅可以接收函数执行的结果，还可以接收函数本身。 请记住，您可以在所有变体中使用标签。 <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: () -&gt; Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> provider()</code> </pre><br><h4> 通过构造函数进行依赖注入 </h4><br> 如您所知，这将与<code>injection</code>有关。 要实现，必须首先将类的所有依赖项放入其构造函数中，然后通过调用<code>kodein.newInstance</code>创建该类的实例。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h4> 可空属性中的依赖注入 </h4><br> 很可能您不知道是否已声明依赖项。 如果未在<code>Kodein</code>实例中声明依赖<code>Kodein</code> ，则上例中的代码将导致<code>Kodein.NotFoundException</code> 。 如果要获得<code>null</code> （如果没有依赖关系），则可以使用三个辅助函数： <code>instanceOrNull()</code> ， <code>factoryOrNull()</code>和<code>providerOrNull()</code> 。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient?, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instanceOrNull(), instance()) } }</code> </pre><br><h4> 获取类内部的依赖关系。 </h4><br> 如前所述，在使用<code>retrieval</code>的情况下，默认情况下所有依赖项的初始化都是延迟的。 这使您可以仅在需要时获取依赖关系，并在系统创建的类中获取依赖关系。 <br><br>  <code>Activity</code> ， <code>Fragment</code>和其他具有各自生命周期的类，全都与它们有关。 <br><br> 要在<code>Activity</code>实现依赖关系<code>Activity</code>我们只需要链接到Kodein实例，此后便可以使用众所周知的方法。 实际上，您已经在上面看到了<code>retrieval</code>示例，您只需要声明一个属性并将其委托给以下功能之一： <code>instance()</code> ， <code>factory()</code>或<code>provider()</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instanceOrNull() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: (() -&gt; Random)? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.providerOrNull()</code> </pre><br><h4> 将参数传递给工厂 </h4><br> 您已经看到，为了将参数传递给工厂，使用<code>instance</code>函数的<code>arg</code>参数就足够了。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果有几个参数（我之前说过一个工厂最多可以有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">）怎么办？</font><font style="vertical-align: inherit;">您只需要将一个</font></font><code>arg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">传递给</font></font><code>M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有重载构造函数</font><font style="vertical-align: inherit;">的参数</font><font style="vertical-align: inherit;">，并且可以使用2到5个参数。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> picker: IColorPicker <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = M(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">211</span></span>, <span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">215</span></span>))</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 强制依赖初始化 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如他们所说-默认情况下，初始化是惰性的，但是您可以创建一个触发器，将其绑定到一个属性，多个属性或整个实例上</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后再拉动该触发器，并将初始化依赖项。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(trigger = myTrigger).instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//     Gson</span></span></code> </pre><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinWithTrigger = kodein.on(trigger = myTrigger) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodeinWithTrigger.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//        kodeinWithTrigger</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 懒惰的Kodein实例创建 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此之前，我们一直在显式创建一个实例</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是可以使用</font></font><code>LazyKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在构造函数中采用应返回一个对象的函数</font><font style="vertical-align: inherit;">的类来延迟此属性的初始化</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，如果完全不知道是否需要来自给定Kodein实例的依赖项，则此方法很有用。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = LazyKodein { Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 调用Kodein.lazy将导致类似的结果。 </font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein.lazy { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein延迟初始化 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于延迟的初始化，</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在一个对象</font></font><code>LateInitKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以创建该对象，将其创建委托给它，然后在初始化对象本身之后，将该属性设置为</font></font><code>baseKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，之后您就可以访问依赖项了。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = LateInitKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> kodein.baseKodein = <span class="hljs-comment"><span class="hljs-comment">/*     Kodein */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> gson.fromJson(someStr)</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 获取指定类型的所有实例 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以向Kodein索要指定类型的实例及其形式的所有后代</font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一切都只在指定的标记内。</font><font style="vertical-align: inherit;">要做到这一点的方法有</font></font><code>allInstances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>allProviders</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>allFactories</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.allInstances()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您打印到日志，您将在此处看到[32767，136.88，4562，12.46]。</font><font style="vertical-align: inherit;">带有标签的依赖项不在列表中。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用KodeinAware界面简化依赖获取 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此接口使您必须重写type属性</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且作为返回，它提供对实例可用的所有功能的访问</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，现在您可以简单地编写</font></font><code>by allInstances()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><code>by kodein.allInstances()</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前的内容，我们已经讨论了接收依赖项的触发器。</font><font style="vertical-align: inherit;">在界面中，</font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以覆盖触发器，并在调用此触发器时获取所有声明的依赖项。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() kodeinTrigger.trigger() } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于对依赖项和实例的访问</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是延迟的，因此您可以将实例初始化委托给</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin中</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">内置函数</font></font><code>lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">根据类的上下文，这种方法在类中可能很有用，例如在中</font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出于相同的原因，可以使用修饰符</font></font><code>lateinit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) kodein = (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无需委派属性即可访问依赖项 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果由于某种原因您不想使用属性委托，则可以通过</font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（直接）</font><font style="vertical-align: inherit;">使用直接访问</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">主要区别在于不再有延迟初始化，在调用时将立即获得相关性</font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且具有类似的功能。</font><font style="vertical-align: inherit;">您</font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以从现有的Kodein实例中</font><font style="vertical-align: inherit;">获取</font><font style="vertical-align: inherit;">它，也可以从头开始构建。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.TEN } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein: DKodein = kodein.direct <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein2: DKodein = Kodein.direct { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.ONE } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber:BigDecimal = directKodein.instance() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber2:BigDecimal = directKodein2.instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kodein可以在框架中使用</font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且可以</font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在框架中</font></font><code>DKodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行实验。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在任何上下文中获取依赖项 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了从一个对象中获取</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多个相同类型的依赖项</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">我们已经研究了使用带参数的标签和工厂的选择，但是还有另外一件事-使用上下文（这不是Android中的上下文）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与带有标签的依赖项的区别：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 标签不能在我们创建依赖关系的函数中使用 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用上下文时，我们可以在依赖项创建函数中访问上下文实例 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，您可以使用带有参数的工厂来代替上下文，并且</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果不确定使用什么</font><font style="vertical-align: inherit;">，开发人员</font><font style="vertical-align: inherit;">建议您这样做。但是，例如当您不能将两个参数强制转换为相同类型时，上下文可能会很有用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，您拥有</font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且您希望使用一个对象</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，根据接收它们的类，以不同的方式提供几种不同类型的依赖项。为了领导</font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种类型-你需要一个可选的接口，工厂将不得不检查所生成的参数的类型。该方案不是很方便。因此，我们看一下如何使用上下文：</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesActivity&gt;().provider { context.getActivityBigDecimal() } bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesPresenter&gt;().factory { initialValue:BigDecimal -&gt; context.getPresenterBigDecimal(initialValue) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), AppKodeinAware { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActivityBigDecimal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = BigDecimal(<span class="hljs-string"><span class="hljs-string">"16.34"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> activityBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesPresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppKodeinAware { fun getPresenterBigDecimal</span></span></span></span>(initialValue: BigDecimal) = initialValue * BigDecimal.TEN <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> presenterBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance(arg = BigDecimal(<span class="hljs-string"><span class="hljs-string">"31.74"</span></span>)) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，有个例子会让人耳目一新，实际上，您不太可能会遇到这种情况，但是这个例子说明了上下文是如何工作的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要声明依赖关系，您可以指定不是</font></font><code>with provider()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是</font><font style="vertical-align: inherit;">指定</font></font><code>with contexted&lt;OurContextClass&gt;().provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中</font></font><code>OurContextClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的类型为，类的实例将作为上下文。</font></font><code>contexted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能是提供商或工厂。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过名为的变量访问返回依赖关系的函数中的此上下文</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要获得与上下文的依赖关系，您首先需要</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过函数</font><font style="vertical-align: inherit;">指定对象的上下文</font></font><code>on()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后请求依赖关系。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似地，在中使用上下文</font></font><code>injection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = someContext).newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Android扩展 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文开头，我答应考虑的扩展选项</font></font><code>Android</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如上所述，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有什么可以阻止您使用</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它的，但是您可以使一切变得更方便。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 内置Android的Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个非常有用的东西是为Android准备的模块。</font><font style="vertical-align: inherit;">要连接它，该类有必要</font><font style="vertical-align: inherit;">延迟</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现</font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和初始化属性</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以访问实例</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">作为回报，您可以从类中获得大量已声明的依赖关系</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，包括所需的一切</font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如何连接-看一个例子。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein.lazy { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(androidModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MyApplication</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//  } val inflater: LayoutInflater by instance() }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如你所看到的-你可以得到的，例如</font></font><code>LayoutInflater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有关模块中声明的依赖关系的完整列表，请参见</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果要将这些依赖项从知道其上下文的Android类之外获取，请显式指定上下文。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = getActivity()).instance()</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过最接近的科德（）快速获取父级科丁（） </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很简单，在Android中，某些对象依赖于其他对象。</font><font style="vertical-align: inherit;">顶层是应用程序，其下是活动，然后是片段。</font><font style="vertical-align: inherit;">您可以在Activity中实现</font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并作为初始化进行调用</font></font><code>closestKodein()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从而</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font><font style="vertical-align: inherit;">获取实例</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds: DataSource <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br> <code>closestKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您也可以在Android类之外获取它，但是您需要一个Android上下文才能从中调用该函数。</font><font style="vertical-align: inherit;">如果使用它</font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则还要为其指定上下文（重写相应的属性，并将Android上下文传递给函数</font></font><code>kcontext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span></span>(androidContext: Context) : KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> androidContext.closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinContext = kcontext(androidContext) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在活动中创建一个单独的Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很有必要从Activity中的父Kodein继承并进行扩展。</font><font style="vertical-align: inherit;">解决方案非常简单。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Kodein.lazy { extend(parentKodein) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein正在进行配置更改 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是的，可以。</font><font style="vertical-align: inherit;">有一个功能</font></font><code>retainedKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用它时，</font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改配置后将不会重新创建</font><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> retainedKodein { extend(parentKodein) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 文章中没有说什么？ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我并没有假装自己是完整的，而且我本人对某些事情也不了解，无法尝试陈述它们。</font><font style="vertical-align: inherit;">以下列出了您可以了解的基本原理，可以自己学习：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 范围 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 实例绑定 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 多重装订 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 即时回调 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 外部来源 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 删除版本的陷阱 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可配置的Kodein </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JSR-330兼容性 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 以及与文档的链接： </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">核心5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始页</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 感谢您的阅读，希望本文对您有所帮助！ </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431696/">https://habr.com/ru/post/zh-CN431696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431686/index.html">物联网除外：Mirai僵尸网络对Linux机器发起了攻击</a></li>
<li><a href="../zh-CN431688/index.html">Clang如何编译函数</a></li>
<li><a href="../zh-CN431690/index.html">解决卡巴斯基实验室的难题</a></li>
<li><a href="../zh-CN431692/index.html">免疫疗法在多发性硬化症治疗中的进展</a></li>
<li><a href="../zh-CN431694/index.html">排序“河内塔”</a></li>
<li><a href="../zh-CN431698/index.html">＃HolyJS18展台hh.ru上的问题分析</a></li>
<li><a href="../zh-CN431700/index.html">我在市场上找不到的家用万用表</a></li>
<li><a href="../zh-CN431702/index.html">苏联HI-FI及其创造者：一部唱片的耳机或一个被遗忘的故事电子产品TDK-3“ Quad”</a></li>
<li><a href="../zh-CN431704/index.html">周末阅读：如何不损害您的听力并避免城市噪音-17篇文章和实用指南</a></li>
<li><a href="../zh-CN431706/index.html">幸福理论。 事故不是偶然的吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>