<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😍 🦉 🏚️ Antarmuka Penghasil Klien Berbasis Database Golang 🚺 🦗 🤶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Basis data klien golang berdasarkan antarmuka. 





 Untuk bekerja dengan database, Golang menawarkan paket database/sql , yang merupakan abstraksi d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Antarmuka Penghasil Klien Berbasis Database Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431984/"><p>  Basis data <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien</a> golang berdasarkan antarmuka. </p><br><p><img src="https://habrastorage.org/webt/jn/y8/f1/jny8f1pghqry-6htgynybbcufbi.png"></p><br><p> Untuk bekerja dengan database, Golang menawarkan paket <code>database/sql</code> , yang merupakan abstraksi dari antarmuka pemrograman basis data relasional.  Di satu sisi, paket termasuk fungsionalitas yang kuat untuk mengelola kumpulan koneksi, bekerja dengan pernyataan yang disiapkan, transaksi, dan antarmuka kueri basis data.  Di sisi lain, Anda harus menulis sejumlah besar jenis kode yang sama dalam aplikasi web untuk berinteraksi dengan database.  Pustaka go-gad / sal menawarkan solusi dalam bentuk menghasilkan jenis kode yang sama berdasarkan antarmuka yang dijelaskan. </p><a name="habracut"></a><br><h2 id="motivation">  Motivasi </h2><br><p>  Saat ini, ada cukup banyak perpustakaan yang menawarkan solusi dalam bentuk ORM, pembantu untuk membangun kueri, menghasilkan pembantu berdasarkan skema database. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/jmoiron/sqlx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/go-reform/reform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/jinzhu/gorm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Masterminds/squirrel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/volatiletech/sqlboiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/drone/sqlgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/gocraft/dbr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/go-gorp/gorp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/doug-martin/goqu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/src-d/go-kallax</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/go-pg/pg</a> </li></ul><br><p>  Ketika saya beralih ke bahasa Golang beberapa tahun yang lalu, saya sudah memiliki pengalaman bekerja dengan database dalam berbagai bahasa.  Menggunakan ORM, seperti ActiveRecord, dan tanpa.  Setelah beralih dari cinta menjadi benci, tidak memiliki masalah menulis beberapa baris kode tambahan, berinteraksi dengan basis data di Golang menghasilkan sesuatu seperti pola penyimpanan.  Kami menggambarkan antarmuka untuk bekerja dengan database, kami menerapkannya menggunakan standar db.Query, row.Scan.  Untuk menggunakan pembungkus tambahan sama sekali tidak masuk akal, itu buram, itu akan memaksa untuk waspada. </p><br><p>  Bahasa SQL itu sendiri sudah merupakan abstraksi antara program Anda dan data dalam repositori.  Tampaknya selalu tidak masuk akal bagi saya untuk mencoba menggambarkan skema data, dan kemudian membangun kueri yang kompleks.  Struktur respons dalam kasus ini berbeda dari skema data.  Ternyata kontrak perlu dijelaskan bukan pada tingkat skema data, tetapi pada tingkat permintaan dan tanggapan.  Kami menggunakan pendekatan ini dalam pengembangan web ketika kami menggambarkan struktur data permintaan dan tanggapan API.  Saat mengakses layanan menggunakan RESTful JSON atau gRPC, kami mendeklarasikan kontrak pada tingkat permintaan dan respons menggunakan Skema atau Protobuf JSON, dan bukan skema data entitas dalam layanan. </p><br><p>  Artinya, berinteraksi dengan database datang ke metode yang serupa: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { FindUser(id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) (*User, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Postgres <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pg *Postgres)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resp User err := pg.DB.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT id, name FROM users WHERE id=$1"</span></span>, id).Scan(&amp;resp.ID, &amp;resp.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HanlderFindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s Store, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// logic of service object user, err := s.FindUser(id) //... }</span></span></code> </pre> <br><p>  Dengan cara ini, program Anda dapat diprediksi.  Tapi jujur ​​saja, ini bukan mimpi penyair.  Kami ingin mengurangi jumlah kode boilerplate untuk membuat kueri, mengisi struktur data, menggunakan pengikatan variabel, dan sebagainya.  Saya mencoba merumuskan daftar persyaratan yang harus dipenuhi oleh seperangkat utilitas yang diinginkan. </p><br><h2 id="requirements">  Persyaratan </h2><br><ul><li>  Deskripsi interaksi dalam bentuk antarmuka. </li><li>  Antarmuka dijelaskan oleh metode dan pesan permintaan dan tanggapan. </li><li>  Dukungan untuk variabel yang mengikat dan pernyataan yang disiapkan. </li><li>  Dukungan untuk argumen yang disebutkan. </li><li>  Menautkan respons basis data ke bidang struktur data pesan. </li><li>  Dukungan untuk struktur data atipikal (array, json). </li><li>  Pekerjaan transparan dengan transaksi. </li><li>  Dukungan asli untuk middleware. </li></ul><br><p>  Kami ingin mengabstraksi implementasi interaksi dengan database menggunakan antarmuka.  Ini akan memungkinkan kami untuk menerapkan sesuatu yang mirip dengan pola desain seperti repositori.  Pada contoh di atas, kami menggambarkan antarmuka Store.  Sekarang kita bisa menggunakannya sebagai ketergantungan.  Pada tahap pengujian, kita dapat melewatkan tulisan rintisan yang dihasilkan berdasarkan antarmuka ini, dan dalam produk kita akan menggunakan implementasi kita berdasarkan pada struktur Postgres. </p><br><p>  Setiap metode antarmuka menjelaskan satu permintaan basis data.  Parameter input dan output metode harus menjadi bagian dari kontrak untuk permintaan tersebut.  String kueri harus dapat memformat tergantung pada parameter input.  Ini terutama benar ketika menyusun kueri dengan kondisi pengambilan sampel yang kompleks. </p><br><p>  Saat menyusun kueri, kami ingin menggunakan subtitusi dan pengikatan variabel.  Sebagai contoh, di PostgreSQL, Anda menulis <code>$1</code> alih-alih nilai, dan bersama-sama dengan kueri, berikan array argumen.  Argumen pertama akan digunakan sebagai nilai dalam kueri yang dikonversi.  Dukungan untuk ekspresi yang disiapkan memungkinkan Anda untuk tidak khawatir mengatur penyimpanan ekspresi yang sama ini.  Pangkalan data / sql menyediakan alat yang ampuh untuk mendukung ekspresi yang disiapkan, itu sendiri menangani kumpulan koneksi, koneksi tertutup.  Tetapi pada bagian pengguna, tindakan tambahan diperlukan untuk menggunakan kembali ekspresi yang disiapkan dalam transaksi. </p><br><p>  Basis data, seperti PostgreSQL dan MySQL, menggunakan sintaks yang berbeda untuk menggunakan substitusi dan pengikatan variabel.  PostgreSQL menggunakan format <code>$1</code> , <code>$2</code> , ... menggunakan MySQL <code>?</code>  terlepas dari lokasi nilainya.  Pangkalan data / sql mengusulkan format universal untuk argumen bernama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://golang.org/pkg/database/sql/#NamedArg</a> .  Contoh penggunaan: </p><br><pre> <code class="go hljs">db.ExecContext(ctx, <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE created_at &lt; @end`</span></span>, sql.Named(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, endTime))</code> </pre> <br><p>  Dukungan untuk format ini lebih baik digunakan dibandingkan dengan solusi PostgreSQL atau MySQL. </p><br><p>  Respons dari database yang memproses driver perangkat lunak dapat direpresentasikan secara kondisional sebagai berikut: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title | url <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+-------+------------ 1 | 2012-03-13 11:17:23.609 | Tech | technology 2 | 2015-07-21 18:05:43.412 | Style | fashion (2 rows)</span></span></code> </pre> <br><p>  Dari sudut pandang pengguna di tingkat antarmuka, akan lebih mudah untuk menggambarkan parameter output sebagai susunan struktur formulir: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreatedAt time.Time Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Selanjutnya, proyeksikan nilai <code>id</code> pada <code>resp.ID</code> dan seterusnya.  Secara umum, fungsi ini mencakup sebagian besar kebutuhan. </p><br><p>  Ketika mendeklarasikan pesan melalui struktur data internal, muncul pertanyaan tentang bagaimana mendukung tipe data non-standar.  Misalnya, sebuah array.  Jika Anda menggunakan driver github.com/lib/pq saat bekerja dengan PostgreSQL, Anda dapat menggunakan fungsi bantu seperti <code>pq.Array(&amp;x)</code> saat menyampaikan argumen kueri atau memindai respons.  Contoh dari dokumentasi: </p><br><pre> <code class="go hljs">db.Query(<span class="hljs-string"><span class="hljs-string">`SELECT * FROM t WHERE id = ANY($1)`</span></span>, pq.Array([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">235</span></span>, <span class="hljs-number"><span class="hljs-number">401</span></span>})) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x []sql.NullInt64 db.QueryRow(<span class="hljs-string"><span class="hljs-string">'SELECT ARRAY[235, 401]'</span></span>).Scan(pq.Array(&amp;x))</code> </pre> <br><p>  Oleh karena itu, harus ada cara untuk menyiapkan struktur data. </p><br><p>  Saat mengeksekusi salah satu metode antarmuka, koneksi database dapat digunakan dalam bentuk objek <code>*sql.DB</code>  Jika Anda perlu menjalankan beberapa metode dalam satu transaksi, saya ingin menggunakan fungsionalitas transparan dengan pendekatan yang sama untuk bekerja di luar transaksi, bukan lewat argumen tambahan. </p><br><p>  Ketika bekerja dengan implementasi antarmuka, sangat penting bagi kita untuk dapat menanamkan toolkit.  Misalnya, masuk semua permintaan.  Toolkit harus mendapatkan akses ke variabel permintaan, kesalahan respons, runtime, nama metode antarmuka. </p><br><p>  Sebagian besar, persyaratan dirumuskan sebagai sistematisasi skenario database. </p><br><h2 id="solution-go-gadsal">  Solusi: go-gad / sal </h2><br><p>  Salah satu cara untuk menangani kode boilerplate adalah dengan membuatnya.  Untungnya, Golang memiliki alat dan contoh untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blog.golang.org/generate</a> ini.  GoMock <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/golang/mock</a> , tempat analisis antarmuka dilakukan menggunakan refleksi, dipinjam sebagai solusi arsitektur untuk generasi tersebut.  Berdasarkan pendekatan ini, sesuai dengan persyaratan, utilitas salgen dan perpustakaan sal ditulis, yang menghasilkan kode implementasi antarmuka dan menyediakan satu set fungsi tambahan. </p><br><p>  Untuk mulai menggunakan solusi ini, perlu untuk mendeskripsikan antarmuka yang menggambarkan perilaku lapisan interaksi dengan database.  Tentukan <code>go:generate</code> arahan dengan seperangkat argumen dan mulai generasi.  Anda akan mendapatkan konstruktor dan banyak kode boilerplate, siap digunakan. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./postgres_client.go -package=dev/taxi/repo dev/taxi/repo Postgres type Postgres interface { CreateDriver(ctx context.Context, r *CreateDriverReq) error } type CreateDriverReq struct { taxi.Driver } func (r *CreateDriverReq) Query() string { return `INSERT INTO drivers(id, name) VALUES(@id, @name)` }</span></span></code> </pre> <br><h4 id="interface">  Antarmuka </h4><br><p>  Semuanya dimulai dengan mendeklarasikan antarmuka dan perintah khusus untuk utilitas <code>go generate</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./client.go -package=github.com/go-gad/sal/examples/profile/storage github.com/go-gad/sal/examples/profile/storage Store type Store interface { ...</span></span></code> </pre> <br><p>  Di sini dijelaskan bahwa untuk antarmuka <code>Store</code> kami, <code>salgen</code> utilitas konsol akan dipanggil dari paket, dengan dua opsi dan dua argumen.  Opsi <code>-destination</code> pertama menentukan di mana file kode yang dihasilkan akan ditulis.  Opsi kedua <code>-package</code> menentukan path lengkap (jalur impor) dari perpustakaan untuk implementasi yang dihasilkan.  Berikut ini adalah dua argumen.  Yang pertama menjelaskan jalur paket lengkap ( <code>github.com/go-gad/sal/examples/profile/storage</code> ) di mana antarmuka berada, yang kedua menunjukkan nama antarmuka itu sendiri.  Perhatikan bahwa perintah untuk <code>go generate</code> dapat ditemukan di mana saja, tidak harus di sebelah antarmuka target. </p><br><p>  Setelah menjalankan perintah <code>go generate</code> , kami mendapatkan konstruktor yang namanya dibangun dengan menambahkan awalan <code>New</code> ke nama antarmuka.  Konstruktor mengambil parameter yang diperlukan terkait dengan antarmuka <code>sal.QueryHandler</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { QueryContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (*sql.Rows, error) ExecContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (sql.Result, error) PrepareContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*sql.Stmt, error) }</code> </pre> <br><p>  Antarmuka ini sesuai dengan objek <code>*sql.DB</code> </p><br><pre> <code class="go hljs">connStr := <span class="hljs-string"><span class="hljs-string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span></span> db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connStr) client := storage.NewStore(db)</code> </pre> <br><h4 id="methods">  Metode </h4><br><p>  Metode antarmuka menentukan set kueri basis data yang tersedia. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CreateAuthor(ctx context.Context, req CreateAuthorReq) (CreateAuthorResp, error) GetAuthors(ctx context.Context, req GetAuthorsReq) ([]*GetAuthorsResp, error) UpdateAuthor(ctx context.Context, req *UpdateAuthorReq) error }</code> </pre> <br><ul><li>  Jumlah argumen selalu dua. </li><li>  Argumen pertama adalah konteksnya. </li><li>  Argumen kedua berisi data untuk variabel yang mengikat dan mendefinisikan string kueri. </li><li>  Parameter output pertama dapat berupa objek, array objek, atau tidak ada. </li><li>  Parameter keluaran terakhir selalu merupakan kesalahan. </li></ul><br><p>  Argumen pertama selalu <code>context.Context</code> . Objek <code>context.Context</code> .  Konteks ini akan diteruskan ketika menggunakan database dan toolkit.  Argumen kedua mengharapkan parameter dengan <code>struct</code> tipe dasar (atau pointer ke <code>struct</code> ).  Parameter harus memenuhi antarmuka berikut: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Queryer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Query() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Metode <code>Query()</code> akan dipanggil sebelum menjalankan query database.  String yang dihasilkan akan dikonversi ke format khusus basis data.  Yaitu, untuk PostgreSQL, <code>@end</code> akan diganti dengan <code>$1</code> , dan nilai <code>&amp;req.End</code> akan diteruskan ke array argumen </p><br><p>  Bergantung pada parameter output, ditentukan metode mana (Query / Exec) yang akan dipanggil: </p><br><ul><li>  Jika parameter pertama adalah <code>struct</code> tipe dasar (atau pointer ke <code>struct</code> ), metode <code>QueryContext</code> akan dipanggil.  Jika respons dari database tidak mengandung satu baris, maka kesalahan <code>sql.ErrNoRows</code> akan <code>sql.ErrNoRows</code> .  Artinya, perilaku ini mirip dengan <code>db.QueryRow</code> . </li><li>  Jika parameter pertama dengan <code>slice</code> tipe dasar, metode <code>QueryContext</code> akan dipanggil.  Jika respons dari database tidak berisi baris, daftar kosong akan dikembalikan.  Tipe dasar dari item daftar harus <code>stuct</code> (atau pointer ke <code>struct</code> ). </li><li>  Jika parameter output adalah salah satu dengan tipe <code>error</code> , metode <code>ExecContext</code> akan dipanggil. </li></ul><br><h4 id="prepared-statements">  Pernyataan yang disiapkan </h4><br><p>  Kode yang dihasilkan mendukung ekspresi yang disiapkan.  Ekspresi yang disiapkan di-cache.  Setelah persiapan pertama dari ekspresi, itu di-cache.  Pangkalan data / sql sendiri memastikan bahwa ekspresi yang disiapkan diterapkan secara transparan ke koneksi database yang diinginkan, termasuk pemrosesan koneksi tertutup.  Pada gilirannya, perpustakaan <code>go-gad/sal</code> menangani penggunaan kembali pernyataan yang disiapkan dalam konteks transaksi.  Ketika ekspresi yang disiapkan dieksekusi, argumen dilewatkan menggunakan pengikatan variabel, transparan kepada pengembang. </p><br><p>  Untuk mendukung argumen bernama di sisi perpustakaan <code>go-gad/sal</code> , permintaan dikonversi ke tampilan yang sesuai untuk database.  Sekarang ada dukungan konversi untuk PostgreSQL.  Nama bidang objek kueri digunakan untuk menggantikan dalam argumen bernama.  Untuk menentukan nama yang berbeda dan bukan nama bidang objek, Anda harus menggunakan tag <code>sql</code> untuk bidang struktur.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteOrdersRequest <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"user_id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r * DeleteOrdersRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE user_id=@user_id AND created_at&lt;@end`</span></span> }</code> </pre> <br><p>  String kueri akan dikonversi, dan menggunakan tabel korespondensi dan pengikatan variabel, daftar akan diteruskan ke argumen eksekusi kueri: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// generated code: db.Query("DELETE FROM orders WHERE user_id=$1 AND created_at&lt;$2", &amp;req.UserID, &amp;req.CreatedAt)</span></span></code> </pre> <br><h4 id="map-structs-to-requests-arguments-and-response-messages">  Peta struct untuk meminta argumen dan pesan tanggapan </h4><br><p>  Pustaka <code>go-gad/sal</code> menangani mengaitkan garis respons basis data dengan struktur respons, kolom tabel dengan bidang struktur: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r GetRubricReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`SELECT * FROM rubrics`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp []*Rubric <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetRubrics(ctx context.Context, req GetRubricsReq) (GetRubricsResp, error) }</code> </pre> <br><p>  Dan jika respons basis data adalah: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+------- 1 | 2012-03-13 11:17:23.609 | Tech 2 | 2015-07-21 18:05:43.412 | Style (2 rows)</span></span></code> </pre> <br><p>  Kemudian daftar GetRubricsResp akan kembali kepada kami, elemen yang akan menjadi pointer ke Rubrik, di mana bidang diisi dengan nilai-nilai dari kolom yang sesuai dengan nama tag. </p><br><p>  Jika respons database berisi kolom dengan nama yang sama, maka bidang struktur yang sesuai akan dipilih dalam urutan deklarasi. </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rubrics, subrubrics; id | title | id | title <span class="hljs-comment"><span class="hljs-comment">----+-------+----+---------- 1 | Tech | 3 | Politics</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subrubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetCategoryResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rubric Subrubric }</code> </pre> <br><h4 id="non-standard-data-types">  Tipe data non-standar </h4><br><p>  Paket <code>database/sql</code> menyediakan dukungan untuk tipe data dasar (string, angka).  Untuk memproses tipe data seperti array atau json dalam permintaan atau respons, perlu untuk mendukung <code>driver.Valuer</code> dan <code>sql.Scanner</code> . <code>sql.Scanner</code> .  Implementasi driver yang berbeda memiliki fungsi pembantu khusus.  Misalnya <code>lib/pq.Array</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://godoc.org/github.com/lib/pq#Array</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span> { driver.Valuer sql.Scanner }</code> </pre> <br><p>  Secara default, pustaka <code>go-gad/sql</code> untuk bidang struktur tampilan </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteAuthrosReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Tags []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"tags"`</span></span> }</code> </pre> <br><p>  akan menggunakan nilai <code>&amp;req.Tags</code> .  Jika struktur memenuhi antarmuka <code>sal.ProcessRower</code> , </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProcessRower <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ProcessRow(rowMap RowMap) }</code> </pre> <br><p>  maka nilai yang digunakan bisa disesuaikan </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rowMap sal.RowMap)</span></span></span></span> { rowMap.Set(<span class="hljs-string"><span class="hljs-string">"tags"</span></span>, pq.Array(r.Tags)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM authors WHERE tags=ANY(@tags::UUID[])`</span></span> }</code> </pre> <br><p>  Handler ini dapat digunakan untuk argumen permintaan dan respons.  Dalam kasus daftar dalam respons, metode harus dimiliki item daftar. </p><br><h4 id="transactions">  Transaksi </h4><br><p>  Untuk mendukung transaksi, antarmuka (Store) harus diperluas dengan metode berikut: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginTx(ctx context.Context, opts *sql.TxOptions) (Store, error) sal.Txer ...</code> </pre> <br><p>  Implementasi metode akan dihasilkan.  Metode <code>BeginTx</code> menggunakan koneksi dari objek <code>sal.QueryHandler</code> saat ini dan membuka transaksi <code>db.BeginTx(...)</code> ;  mengembalikan objek implementasi baru dari antarmuka <code>Store</code> , tetapi menggunakan objek <code>*sql.Tx</code> diterima sebagai <code>*sql.Tx</code> </p><br><h4 id="middleware">  Middleware </h4><br><p>  Kait disediakan untuk alat penyemat. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BeforeQueryFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, FinalizerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalizerFunc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span></code> </pre> <br><p>  Hook <code>BeforeQueryFunc</code> akan dipanggil sebelum <code>db.PrepareContext</code> atau <code>db.Query</code> .  Yaitu, pada awal program, ketika cache ekspresi yang disiapkan kosong, ketika <code>store.GetAuthors</code> dipanggil, kait <code>BeforeQueryFunc</code> akan dipanggil dua kali.  Pengait <code>BeforeQueryFunc</code> dapat mengembalikan pengait <code>FinalizerFunc</code> , yang akan dipanggil sebelum keluar dari metode pengguna, di case <code>store.GetAuthors</code> , menggunakan <code>defer</code> . </p><br><p>  Pada saat pelaksanaan kait, konteksnya diisi dengan kunci layanan dengan nilai-nilai berikut: </p><br><ul><li>  <code>ctx.Value(sal.ContextKeyTxOpened)</code> boolean menentukan apakah metode ini dipanggil dalam konteks transaksi atau tidak. </li><li>  <code>ctx.Value(sal.ContextKeyOperationType)</code> , nilai string dari jenis operasi, <code>"QueryRow"</code> , <code>"Query"</code> , <code>"Exec"</code> , <code>"Commit"</code> , dll. </li><li>  <code>ctx.Value(sal.ContextKeyMethodName)</code> string dari metode antarmuka, seperti <code>"GetAuthors"</code> . </li></ul><br><p>  Sebagai argumen, kait <code>BeforeQueryFunc</code> menerima string sql dari kueri dan argumen <code>req</code> dari metode kueri pengguna.  Pengait <code>FinalizerFunc</code> mengambil variabel <code>err</code> sebagai argumen. </p><br><pre> <code class="go hljs">beforeHook := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, sal.FinalizerFunc)</span></span></span></span> { start := time.Now() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"%q &gt; Opeartion %q: %q with req %#v took [%v] inTx[%v] Error: %+v"</span></span>, ctx.Value(sal.ContextKeyMethodName), ctx.Value(sal.ContextKeyOperationType), query, req, time.Since(start), ctx.Value(sal.ContextKeyTxOpened), err, ) } } client := NewStore(db, sal.BeforeQuery(beforeHook))</code> </pre> <br><p>  Contoh keluaran: </p><br><pre> <code class="plaintext hljs">"CreateAuthor" &gt; Opeartion "Prepare": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES($1, $2, now()) RETURNING ID, CreatedAt" with req &lt;nil&gt; took [50.819µs] inTx[false] Error: &lt;nil&gt; "CreateAuthor" &gt; Opeartion "QueryRow": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES(@Name, @Desc, now()) RETURNING ID, CreatedAt" with req bookstore.CreateAuthorReq{BaseAuthor:bookstore.BaseAuthor{Name:"foo", Desc:"Bar"}} took [150.994µs] inTx[false] Error: &lt;nil&gt;</code> </pre> <br><h3 id="whats-next">  Apa selanjutnya </h3><br><ul><li>  Dukungan untuk variabel yang mengikat dan ekspresi yang disiapkan untuk MySQL. </li><li>  Kait RowAppender untuk menyesuaikan respons. </li><li>  Mengembalikan nilai <code>Exec.Result</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431984/">https://habr.com/ru/post/id431984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431972/index.html">Data Pengguna Quora Bocor</a></li>
<li><a href="../id431974/index.html">Tumblr sepenuhnya meninggalkan konten "stroberi"</a></li>
<li><a href="../id431976/index.html">Hari Informatika di Rusia: sejarah proyek pertama komputer otomatis</a></li>
<li><a href="../id431978/index.html">Promosi toko online: apa yang harus diperbaiki</a></li>
<li><a href="../id431982/index.html">Digerati, Hakerazzi, dan Kolesterol dalam Data: Tentang IT Slang</a></li>
<li><a href="../id431986/index.html">Fuck Up story: bagaimana saya kecewa dengan layanan digital untuk bisnis dan punya bisnis sendiri (well, hampir)</a></li>
<li><a href="../id431988/index.html">Ketika teorema menjadi aksioma: ONYX BOOX Ulasan Euclid</a></li>
<li><a href="../id431990/index.html">Kesenjangan dimenangkan. Menerjemahkan dokumentasi Konvensi Koding Kotlin dari JetBrains</a></li>
<li><a href="../id431992/index.html">Biometrik: bagaimana keadaan kita dan mereka</a></li>
<li><a href="../id431994/index.html">Diskusi lisensi PVS-Studio gratis untuk proyek-proyek yang dihosting di GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>