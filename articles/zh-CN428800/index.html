<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍖 🧖🏼 ✊🏼 烹饪完美的CSS 👯 🕟 🍀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 不久前，我意识到在所有应用程序中使用CSS会对开发人员和用户造成痛苦。 

 我要解决的问题是，在正确使用样式的过程中出现了一堆奇怪的代码和陷阱。 


 CSS问题 
 在我所做的React和Vue项目中，样式的方法大致相同。 该项目由webpack组装，从主入口点导入一个CSS文...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>烹饪完美的CSS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/constanta/blog/428800/"> 哈Ha！ <br><br> 不久前，我意识到在所有应用程序中使用CSS会对开发人员和用户造成痛苦。 <br><br> 我要解决的问题是，在正确使用样式的过程中出现了一堆奇怪的代码和陷阱。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hh/ut/5e/hhut5eodm-tw-e1wdqnecn7dxlu.png"></div><a name="habracut"></a><br><h2>  CSS问题 </h2><br> 在我所做的React和Vue项目中，样式的方法大致相同。 该项目由webpack组装，从主入口点导入一个CSS文件。 此文件将使用BEM命名类的其余CSS文件导入其内部。 <br><br><pre><code class="plaintext hljs">styles/ indes.css blocks/ apps-banner.css smart-list.css ...</code> </pre> <br> 熟悉吗？ 我几乎在所有地方都使用了此实现。 一切都很好，直到其中一个站点发展到一种状态问题，使我的眼睛开始大为恼火。 <br><br>  <b>1.热装问题</b> <br> 相互之间导入样式是通过postcss插件或手写笔加载器进行的。 <br> 要注意的是： <br><br> 当我们通过postcss或stylus-loader插件解决导入问题时，输出为一个大CSS文件。 现在，即使其中一个样式表稍有更改，所有CSS文件也将被再次处理。 <br><br> 它确实杀死了热重装的速度：处理大约950 KB的手写笔文件大约需要4秒钟。 <br><br><div class="spoiler">  <b class="spoiler_title">关于CSS加载器的注意事项</b> <div class="spoiler_text"> 如果通过css-loader解决了导入CSS文件的问题，则不会出现这样的问题： <br>  css-loader将CSS变成JavaScript。 它将用require替换所有样式导入。 然后，更改一个CSS文件不会影响其他文件，并且热重新加载会很快发生。 <br><br> 到css-loader <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* main.css */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./test.css'</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">html</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* background-color: #a1616e; */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: red; }</code> </pre><br> 之后 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* main.css */</span></span> <span class="hljs-comment"><span class="hljs-comment">// imports exports.i(require("-!../node_modules/css-loader/index.js!./test.css"), ""); // module exports.push([module.id, "html, body {\n margin: 0;\n padding: 0;\n width: 100%;\n height: 100%;\n}\n\nbody {\n /* background-color: #a1616e; */\n background-color: red;\n}\n", ""]); // exports</span></span></code> </pre><br></div></div><br>  <b>2.代码拆分问题</b> <br><br> 从单独的文件夹加载样式时，我们不知道每种样式的使用上下文。 使用这种方法，无法将CSS分成多个部分并根据需要加载它们。 <br><br>  <b>3.很棒的CSS类名</b> <br><br> 每个BEM类名称如下所示：block-name__element-name。 如此长的名称会严重影响最终的CSS文件大小：例如，在Habr网站上，CSS类名占样式文件大小的36％。 <br><br>  Google意识到了这个问题，并且长期以来一直在其所有项目中使用名称最小化： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zb/ft/yx/zbftyxjxnsh-irc6odfc5cszvxk.png" alt="一块google.com"></div><br>  <font color="#999999"><i>一块google.com</i></font> <br><br> 所有这些问题使我井然有序，我最终决定结束这些问题，并取得理想的结果。 <br><br><h2> 决策选择 </h2><br> 为了摆脱上述所有问题，我找到了两个解决方案：JS中的CSS（样式组件）和CSS模块。 <br><br> 我没有看到这些解决方案中的严重缺陷，但最终由于以下几个原因，我选择使用CSS模块： <br><br><ul><li> 您可以将CSS放在单独的文件中，以分别缓存JS和CSS。 </li><li> 烧结样式的更多选项。 </li><li> 使用CSS文件更为常见。 </li></ul><br> 做出了选择，是时候开始做饭了！ <br><br><h2> 基本设定 </h2><br> 稍微配置一下webpack。 添加css-loader并在其中启用CSS模块： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* webpack.config.js */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.css$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [ <span class="hljs-string"><span class="hljs-string">'style-loader'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { <span class="hljs-attr"><span class="hljs-attr">modules</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } }, ], }, ], }, };</code> </pre><br> 现在，我们将CSS文件传播到包含组件的文件夹中。 在每个组件内部，我们导入必要的样式。 <br><br><pre> <code class="plaintext hljs">project/ components/ CoolComponent/ index.js index.css</code> </pre><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* components/CoolComponent/index.css */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.contentWrapper</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">8px</span></span> <span class="hljs-number"><span class="hljs-number">16px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgba</span></span>(45, 45, 45, .3); } <span class="hljs-selector-class"><span class="hljs-selector-class">.title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">font-size</span></span>: <span class="hljs-number"><span class="hljs-number">14px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">font-weight</span></span>: bold; } <span class="hljs-selector-class"><span class="hljs-selector-class">.text</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">font-size</span></span>: <span class="hljs-number"><span class="hljs-number">12px</span></span>; }</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* components/CoolComponent/index.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styles <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ({ text }) =&gt; ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{styles.contentWrapper}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{styles.title}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Weird title </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{styles.text}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {text} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre><br> 既然我们已经破坏了CSS文件，热重装将只处理对一个文件的更改。 问题1解决了，干杯！ <br><br><h2> 将CSS分成大块 </h2><br> 当一个项目有很多页面，而客户端只需要其中一个页面时，将所有数据抽出是没有意义的。  React为此提供了一个很棒的react-loadable库。 它允许您创建一个组件，该组件可以根据需要动态下载我们需要的文件。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* AsyncCoolComponent.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Loadable <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-loadable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Loading <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'path/to/Loading'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Loadable({ <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-comment"><span class="hljs-comment">/* webpackChunkName: 'CoolComponent' */</span></span><span class="hljs-string"><span class="hljs-string">'path/to/CoolComponent'</span></span>), <span class="hljs-attr"><span class="hljs-attr">loading</span></span>: Loading, });</code> </pre><br>  Webpack将把CoolComponent组件转换为一个单独的JS文件（块），该文件将在呈现AsyncCoolComponent时下载。 <br><br> 同时，CoolComponent包含自己的样式。 到目前为止，CSS都以JS字符串形式存在于其中，并使用style-loader作为样式插入。 但是为什么不将样式切成单独的文件呢？ <br><br> 我们将为主文件和每个块创建自己的CSS文件。 <br><br> 安装mini-css-extract-plugin并与webpack配置结合使用： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* webpack.config.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MiniCssExtractPlugin = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mini-css-extract-plugin'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isDev = process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'development'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> test: <span class="hljs-regexp"><span class="hljs-regexp">/\.css$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [ (isDev ? <span class="hljs-string"><span class="hljs-string">'style-loader'</span></span> : MiniCssExtractPlugin.loader), { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { <span class="hljs-attr"><span class="hljs-attr">modules</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, }, ], }, ], }, <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ...(isDev ? [] : [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MiniCssExtractPlugin({ <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].css'</span></span>, <span class="hljs-attr"><span class="hljs-attr">chunkFilename</span></span>: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].css'</span></span>, }), ]), ], };</code> </pre><br> 仅此而已！ 让我们以生产模式组装项目，打开浏览器并查看网络选项卡： <br><br><pre> <code class="plaintext hljs">//    GET /main.aff4f72df3711744eabe.css GET /main.43ed5fc03ceb844eab53.js //  CoolComponent ,   JS  CSS GET /CoolComponent.3eaa4773dca4fffe0956.css GET /CoolComponent.2462bbdbafd820781fae.js</code> </pre><br> 问题2已经结束。 <br><br><h2> 我们缩小CSS类 </h2><br>  Css-loader在内部更改类名，并返回一个变量，该变量具有本地类名到全局的映射。 <br><br> 完成基本设置后，css-loader会根据文件的名称和位置生成一个长哈希。 <br><br> 在浏览器中，我们的CoolComponent现在如下所示： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"rs2inRqijrGnbl0txTQ8v"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"_2AU-QBWt5K2v7J1vRT0hgn"</span></span></span><span class="hljs-tag">&gt;</span></span> Weird title <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"_1DaTAH8Hgn0BQ4H13yRwQ0"</span></span></span><span class="hljs-tag">&gt;</span></span> Lorem ipsum dolor sit amet consectetur. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 当然，这对我们来说还不够。 <br><br> 在开发过程中，必须有名称来查找原始样式。 在生产模式下，应最小化类名。 <br><br>  Css-loader允许您通过选项localIdentName和getLocalIdent自定义类名称的更改。 在开发模式下，我们将设置描述性的localIdentName-'[path] _ [name] _ [local]'，在生产模式下，我们将创建一个将类名最小化的函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* webpack.config.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getScopedName = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path/to/getScopedName'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isDev = process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'development'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.css$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [ <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">isDev ? </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'style-loader'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : MiniCssExtractPlugin.loader</span></span></span><span class="hljs-function">), { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">loader</span></span></span><span class="hljs-function">: '</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">css</span></span></span><span class="hljs-function">-</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">loader</span></span></span><span class="hljs-function">', </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">: { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modules</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">true</span></span></span><span class="hljs-function">, ...(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">isDev ? { localIdentName: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'[path]_[name]_[local]'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, } : { getLocalIdent: (context, localIdentName, localName</span></span></span><span class="hljs-function">) =&gt;</span></span> ( getScopedName(localName, context.resourcePath) ), }), }, }, ], }, ], }, };</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* getScopedName.js */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,        CSS      */</span></span> <span class="hljs-comment"><span class="hljs-comment">//      const incstr = require('incstr'); const createUniqueIdGenerator = () =&gt; { const uniqIds = {}; const generateNextId = incstr.idGenerator({ //  d ,    ad, //      Adblock alphabet: 'abcefghijklmnopqrstuvwxyzABCEFGHJKLMNOPQRSTUVWXYZ', }); //       return (name) =&gt; { if (!uniqIds[name]) { uniqIds[name] = generateNextId(); } return uniqIds[name]; }; }; const localNameIdGenerator = createUniqueIdGenerator(); const componentNameIdGenerator = createUniqueIdGenerator(); module.exports = (localName, resourcePath) =&gt; { //   ,     index.css const componentName = resourcePath .split('/') .slice(-2, -1)[0]; const localId = localNameIdGenerator(localName); const componentId = componentNameIdGenerator(componentName); return `${componentId}_${localId}`; };</span></span></code> </pre><br> 在这里，我们正在开发漂亮的视觉名称： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"src-components-ErrorNotification-_index_content-wrapper"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"src-components-ErrorNotification-_index_title"</span></span></span><span class="hljs-tag">&gt;</span></span> Weird title <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"src-components-ErrorNotification-_index_text"</span></span></span><span class="hljs-tag">&gt;</span></span> Lorem ipsum dolor sit amet consectetur. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 并在生产中减少班级： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"e_f"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"e_g"</span></span></span><span class="hljs-tag">&gt;</span></span> Weird title <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"e_h"</span></span></span><span class="hljs-tag">&gt;</span></span> Lorem ipsum dolor sit amet consectetur. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 第三个问题被克服。 <br><br><h2> 删除不必要的缓存失效 </h2><br> 使用上述的类最小化技术，尝试多次构建项目。 注意文件缓存： <br><br><pre> <code class="plaintext hljs">/*   */ app.bf70bcf8d769b1a17df1.js app.db3d0bd894d38d036117.css /*   */ app.1f296b75295ada5a7223.js app.eb2519491a5121158bd2.css</code> </pre><br> 似乎在每个新构建之后，我们都使缓存无效。 怎么会这样 <br><br> 问题在于webpack无法保证文件的处理顺序。 也就是说，CSS文件将以不可预测的顺序处理，对于具有不同程序集的相同类名称，将生成不同的最小名称。 <br><br> 为了克服这个问题，让我们在程序集之间保存有关生成的类名的数据。 稍微更新getScopedName.js文件： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* getScopedName.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> incstr = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'incstr'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     const { getGeneratorData, saveGeneratorData, } = require('./generatorHelpers'); const createUniqueIdGenerator = (generatorIdentifier) =&gt; { //    const uniqIds = getGeneratorData(generatorIdentifier); const generateNextId = incstr.idGenerator({ alphabet: 'abcefghijklmnopqrstuvwxyzABCEFGHJKLMNOPQRSTUVWXYZ', }); return (name) =&gt; { if (!uniqIds[name]) { uniqIds[name] = generateNextId(); //    , //      // (   debounce  ) saveGeneratorData(generatorIdentifier, uniqIds); } return uniqIds[name]; }; }; //     , //          const localNameIdGenerator = createUniqueIdGenerator('localName'); const componentNameIdGenerator = createUniqueIdGenerator('componentName'); module.exports = (localName, resourcePath) =&gt; { const componentName = resourcePath .split('/') .slice(-2, -1)[0]; const localId = localNameIdGenerator(localName); const componentId = componentNameIdGenerator(componentName); return `${componentId}_${localId}`; };</span></span></code> </pre><br>  generatorHelpers.js文件的实现并不重要，但是如果您有兴趣，这里是我的： <br><br><div class="spoiler">  <b class="spoiler_title">generatorHelpers.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getGeneratorDataPath = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generatorIdentifier</span></span></span><span class="hljs-function"> =&gt;</span></span> ( path.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">`meta/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${generatorIdentifier}</span></span></span><span class="hljs-string">.json`</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getGeneratorData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generatorIdentifier</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = getGeneratorDataPath(generatorIdentifier); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fs.existsSync(path)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(path); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> saveGeneratorData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generatorIdentifier, uniqIds</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = getGeneratorDataPath(generatorIdentifier); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(uniqIds, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fs.writeFileSync(path, data, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { getGeneratorData, saveGeneratorData, };</code> </pre><br></div></div><br> 各个版本之间的缓存已相同，一切都很好。 另外一点对我们有利！ <br><br><h2> 删除运行时变量 </h2><br> 由于我决定做出更好的决定，因此最好通过类映射来删除此变量，因为我们在编译阶段拥有所有必需的数据。 <br><br>  Babel-plugin-react-css-modules将对此提供帮助。 在编译时，它： <br><br><ol><li> 将在文件中找到CSS导入。 </li><li> 它将打开此CSS文件，并像css-loader一样更改CSS类名称。 </li><li> 它将找到具有styleName属性的JSX节点。 </li><li> 将styleName中的本地类名称替换为全局名称。 </li></ol><br> 设置此插件。 让我们玩babel配置： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* .babelrc.js */</span></span> <span class="hljs-comment"><span class="hljs-comment">//   ,     const getScopedName = require('path/to/getScopedName'); const isDev = process.env.NODE_ENV === 'development'; module.exports = { /* ... */ plugins: [ /* ... */ ['react-css-modules', { generateScopedName: isDev ? '[path]_[name]_[local]' : getScopedName, }], ], };</span></span></code> </pre><br> 更新我们的JSX文件： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* CoolComponent/index.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ({ text }) =&gt; ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">styleName</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"content-wrapper"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">styleName</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Weird title </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">styleName</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {text} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre><br> 因此，我们不再使用显示样式名称的变量，而现在还没有它！ <br><br>  ...还是在那里？ <br><br> 我们将收集项目并研究资源： <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* main.24436cbf94546057cae3.js */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, t, n</span></span></span><span class="hljs-function">) </span></span>{ e.exports = { <span class="hljs-string"><span class="hljs-string">"content-wrapper"</span></span>: <span class="hljs-string"><span class="hljs-string">"e_f"</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"e_g"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"e_h"</span></span> } } <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span></code> </pre><br> 尽管没有在任何地方使用它，但看起来该变量仍然存在。 为什么会这样呢？ <br><br> 该webpack支持多种类型的模块化结构，其中最受欢迎的是ES2015（导入）和commonJS（必需）。 <br><br>  ES2015模块与commonJS不同，由于它们的静态结构，它们支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摇树</a> 。 <br><br> 但是css-loader和mini-css-extract-plugin加载器都使用commonJS语法导出类名，因此不会从构建中删除导出的数据。 <br><br> 我们将编写我们的小型加载器，并在生产模式下删除多余的数据： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* webpack.config.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resolve = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">relativePath</span></span></span><span class="hljs-function"> =&gt;</span></span> path.resolve(__dirname, relativePath); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isDev = process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'development'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.css$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [ ...(isDev ? [<span class="hljs-string"><span class="hljs-string">'style-loader'</span></span>] : [ resolve(<span class="hljs-string"><span class="hljs-string">'path/to/webpack-loaders/nullLoader'</span></span>), MiniCssExtractPlugin.loader, ]), { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'css-loader'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }, ], }, ], }, };</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* nullLoader.js */</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ,   module.exports = () =&gt; '// empty';</span></span></code> </pre><br> 再次检查汇编文件： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* main.35f6b05f0496bff2048a.js */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, t, n</span></span></span><span class="hljs-function">) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span></code> </pre><br> 您可以松一口气，一切正常。 <br><br><div class="spoiler">  <b class="spoiler_title">删除类映射变量失败</b> <div class="spoiler_text"> 最初，对我来说，使用已经存在的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">null加载程序</a>包似乎最为明显。 <br><br> 但事实证明并非如此简单： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  null-loader */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'// empty (null-loader)'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pitch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'// empty (null-loader)'</span></span>; }</code> </pre><br> 如您所见，除了主函数外，空加载器还导出了pitch函数。 我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从文档</a>中了解到，音调方法比其他方法更早被调用，并且如果它们从此方法返回一些数据，则可以取消所有后续的加载器。 <br><br> 使用null-loader，CSS生成序列开始如下所示： <br><br><ul><li> 调用null-loader的pitch方法，该方法返回一个空字符串。 </li><li> 由于pitch方法返回值，因此不会调用所有后续加载程序。 </li></ul><br> 我再也没有看到解决方案，因此决定自己制造装载机。 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">与Vue.js一起使用</b> <div class="spoiler_text"> 如果您只有一个Vue.js触手可及，但真的想压缩类名并删除运行时变量，那么我有个不错的选择！ <br><br> 我们需要的是两个插件：babel-plugin-transform-vue-jsx和babel-plugin-react-css-modules。 我们将需要第一个在渲染函数中编写JSX，第二个，正如您已经知道的，需要在编译阶段生成名称。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* .babelrc.js */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [ <span class="hljs-string"><span class="hljs-string">'transform-vue-jsx'</span></span>, [<span class="hljs-string"><span class="hljs-string">'react-css-modules'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">//    attributeNames: { styleName: 'class', }, }], ], };</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TextComponent = { render(h) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">styleName</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Lorem ipsum dolor. </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }, mounted() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I\'m mounted!'</span></span>); }, }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TextComponent;</code> </pre><br></div></div><br><br><h2> 充分压缩CSS </h2><br> 假设以下CSS出现在项目中： <br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.component1__title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.component2__title</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.component2__title_red</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br> 您是CSS缩小器。 您会如何挤压它？ <br><br> 我认为您的答案是这样的： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.component2__title</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:green} <span class="hljs-selector-class"><span class="hljs-selector-class">.component2__title_red</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.component1__title</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:red}</code> </pre><br> 现在，我们将检查常用的缩小器会执行的操作。 将我们的代码放在一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在线压缩器中</a> ： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.component1__title</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:red} <span class="hljs-selector-class"><span class="hljs-selector-class">.component2__title</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:green} <span class="hljs-selector-class"><span class="hljs-selector-class">.component2__title_red</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:red}</code> </pre><br> 他为什么不能呢？ <br><br> 缩小器担心由于样式声明顺序的更改，某些东西会损坏。 例如，如果项目具有以下代码： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"component1__title component2__title"</span></span></span><span class="hljs-tag">&gt;</span></span>Some weird title<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 由于您的原因，标题将变为红色，并且在线缩小器将保留正确的样式声明顺序，并且将变为绿色。 当然，您知道component1__title和component2__title永远不会交集，因为它们位于不同的组件中。 但是，如何对矿工说呢？ <br><br> 搜索文档后，我发现可以指定仅用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">csso的</a>类的上下文。 而且他没有开箱即用的Webpack便捷解决方案。 要走得更远，我们需要一辆小型自行车。 <br><br> 您需要将每个组件的类名组合到单独的数组中，并在csso中提供它。 早些时候，我们根据这种模式生成了最小化的类名：“ [componentId] _ [classNameId]”。 因此，可以通过名称的第一部分简单地组合类名称！ <br><br> 系好安全带并编写插件： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* webpack.config.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cssoLoader = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path/to/cssoLoader'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> plugins: [ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cssoLoader(), ], };</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* cssoLoader.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csso = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'csso'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RawSource = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack-sources/lib/RawSource'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getScopes = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./helpers/getScopes'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isCssFilename = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function"> =&gt;</span></span> /\.css$/.test(filename); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cssoPlugin</span></span></span><span class="hljs-class"> </span></span>{ apply(compiler) { compiler.hooks.compilation.tap(<span class="hljs-string"><span class="hljs-string">'csso-plugin'</span></span>, (compilation) =&gt; { compilation.hooks.optimizeChunkAssets.tapAsync(<span class="hljs-string"><span class="hljs-string">'csso-plugin'</span></span>, (chunks, callback) =&gt; { chunks.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chunk</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    CSS  chunk.files.forEach((filename) =&gt; { if (!isCssFilename(filename)) { return; } const asset = compilation.assets[filename]; const source = asset.source(); //  ast  CSS  const ast = csso.syntax.parse(source); //        const scopes = getScopes(ast); //  ast const { ast: compressedAst } = csso.compress(ast, { usage: { scopes, }, }); const minifiedCss = csso.syntax.generate(compressedAst); compilation.assets[filename] = new RawSource(minifiedCss); }); }); callback(); }); }); } } /*    sourceMap,     ,       https://github.com/zoobestik/csso-webpack-plugin" */</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* getScopes.js */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,          ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csso = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'csso'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getComponentId = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">className</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokens = className.split(<span class="hljs-string"><span class="hljs-string">'_'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   ,   //   [componentId]_[classNameId], //     if (tokens.length !== 2) { return 'default'; } return tokens[0]; }; module.exports = (ast) =&gt; { const scopes = {}; //      csso.syntax.walk(ast, (node) =&gt; { if (node.type !== 'ClassSelector') { return; } const componentId = getComponentId(node.name); if (!scopes[componentId]) { scopes[componentId] = []; } if (!scopes[componentId].includes(node.name)) { scopes[componentId].push(node.name); } }); return Object.values(scopes); };</span></span></code> </pre><br> 并不是那么困难，对吧？ 通常，此缩小还会将CSS压缩3-6％。 <br><br><h2> 值得吗？ </h2><br> 当然可以 <br><br> 在我的应用程序中，终于出现了快速的热重装，CSS开始分裂成碎片，平均重量减轻了40％。 <br><br> 这将加快网站的加载速度，并减少解析样式的时间，这不仅会影响用户，还会影响CEO。 <br><br> 这篇文章已经有了很大的增长，但是我很高兴有人能够将其滚动到最后。 感谢您的宝贵时间！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cd/wm/b8/cdwmb8ygmq0mysnve4zjina7-iw.png"></div><br><h4> 所用材料 </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过减少类名并使用范围隔离将CSS包大小减少70％</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428800/">https://habr.com/ru/post/zh-CN428800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428790/index.html">我们正在使用longpoll在python中为VKontakte编写机器人聊天。 第二部分 双循环，异常和其他异端</a></li>
<li><a href="../zh-CN428792/index.html">新的Apple T2芯片使笔记本电脑的内置麦克风难以收听</a></li>
<li><a href="../zh-CN428794/index.html">约束问题数学优化的基本方法概述</a></li>
<li><a href="../zh-CN428796/index.html">在Unity上实时操纵网格</a></li>
<li><a href="../zh-CN428798/index.html">如何在独立开发人员中生存。 第二部分</a></li>
<li><a href="../zh-CN428806/index.html">消费者支票分析：他们在亚马逊购买的商品</a></li>
<li><a href="../zh-CN428808/index.html">学生生活中的不便</a></li>
<li><a href="../zh-CN428810/index.html">18种音频数字技术材料</a></li>
<li><a href="../zh-CN428812/index.html">TypeScript：使用属性的类型验证将JSON反序列化为类</a></li>
<li><a href="../zh-CN428814/index.html">使用Elasticsearch为竞争对手的价格监控服务进行产品匹配</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>