<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèΩ ‚§¥Ô∏è üë©üèΩ‚Äçüç≥ Programmation et √©change de donn√©es avec ARDUINO via WIFI via ESP8266 Part One üßî üë∏üèø ‚¨ÖÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comme beaucoup d'autres produits faits maison, j'utilise r√©guli√®rement des microcontr√¥leurs AVR pour toutes sortes de bricolages amateurs. Et gr√¢ce au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation et √©change de donn√©es avec ARDUINO via WIFI via ESP8266 Part One</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406559/">  Comme beaucoup d'autres produits faits maison, j'utilise r√©guli√®rement des microcontr√¥leurs AVR pour toutes sortes de bricolages amateurs.  Et gr√¢ce au concept Arduino, ces objets artisanaux prennent d√©sormais √©galement un aspect √©l√©gant.  En effet, pour quelque 300-400 roubles, nous obtenons une carte multicouche miniature avec un masque, une s√©rigraphie et avec les p√©riph√©riques pour le microcontr√¥leur compl√®tement √©lev√©s dessus (d'ailleurs, dans la version SMD!).  Je ne parle pas de toutes sortes de plug-ins de la m√™me s√©rie "Arduino": capteurs, contr√¥leurs, √©crans et ensembles entiers, les p√©riph√©riques suppl√©mentaires dont nous avons tant besoin.  Et encore une fois, tout est √©galement bon march√© et d'excellentes performances.  Pratiquement plus besoin d'√©lever quelque chose et de souder sur le "genou". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/dcc/5a0/51d/dcc5a051d0554a7a86eaf37d51702ce6.jpg"></div><br>  Mais tous ces diff√©rents m√©tiers amateurs, n√©cessitent naturellement une <b>programmation pr√©alable.</b>  Et plus tard, avec diverses am√©liorations, je dois constamment reflasher ces m√©tiers.  Il est clair qu'il est plus pratique de le faire √† distance que de les faire constamment glisser vers un programmeur normal.  En g√©n√©ral, gr√¢ce √† la m√™me plate-forme Arduino, il existe de nombreuses options ici: Bluetooth, ZigBee, un canal radio avec votre protocole personnel, IR et m√™me Wi-Fi.  Tous vous permettent d'√©tablir un contact sans fil avec votre microcontr√¥leur.  Mais nous nous arr√™terons sur la derni√®re option.  Il y a quatre raisons principales: <br><br>  1: moderne, l'Internet des objets! <br><br>  2: il y a un routeur sans fil dans chaque appartement, enregistrez vos appareils sur le r√©seau domestique et le tour est jou√©! <br><br>  3: vos m√©tiers font un saut r√©volutionnaire dans leur d√©veloppement;  non seulement ils peuvent √™tre programm√©s √† distance, mais ils peuvent d√©sormais √©galement communiquer avec le monde qui les entoure: l'horloge √©lectronique prend ind√©pendamment l'heure exacte des horloges du serveur NTP, les appareils ex√©cutifs sont contr√¥l√©s √† l'autre bout de la ville ou du pays, les appareils d'enregistrement stockent les donn√©es accumul√©es dans nuage etc.  etc. <br><br>  4: il existe une merveilleuse s√©rie de puces ESP8266 sur lesquelles <s>il n'est pas tr√®s</s> facile de mettre en ≈ìuvre tout cela. <br><a name="habracut"></a><br>  De plus, dans cet article, en utilisant l'exemple d'un bras m√©canique sur des servos, la programmation √† distance et l'√©change de donn√©es avec un PC (ou autre) avec des appareils bas√©s sur des microcontr√¥leurs AVR seront d√©mont√©s et d√©montr√©s.  Je tiens √† noter tout de suite que tous les programmes √©num√©r√©s ci-dessous sont purement d√©monstratifs et n'ont aucune valeur commerciale.  Par cons√©quent, les affirmations, telles que pourquoi le programmeur est si castr√© et mal fonctionnel ou pourquoi il n'y a pas de services suppl√©mentaires partout, ne sont pas accept√©es.  √âtant donn√© que les codes sont ouverts, tout le monde peut les terminer √† leur discr√©tion, mais j'ai encore assez de travail. <br><br>  Il est suppos√© que le lecteur conna√Æt d√©j√† √† la fois les modules Arduino (blindages) et la connexion et le firmware de l'ESP8266.  En fait, une √©norme quantit√© de mat√©riel a √©t√© publi√©e sur le Web expliquant les bases du travail avec ces appareils et je ne voudrais pas r√©p√©ter ici.  Pour les d√©butants, √† la fin de l'article, il y a une liste de liens utiles sur ces questions, o√π vous pouvez trouver beaucoup d'informations <s>, pourquoi tout cela ne fonctionne pas pour vous</s> .  D'apr√®s mon exp√©rience en tant qu'ancien ing√©nieur en √©lectronique, je peux d√©clarer de mani√®re responsable que 99% des probl√®mes sont les suivants: <br><br>  1. Mauvais contacts.  √âtant donn√© que les boucliers ¬´Arduino¬ª impliquent une commutation entre eux via des fils de type ¬´p√®re-m√®re¬ª, et non par soudage, tr√®s souvent quelque chose, quelque part, dispara√Æt.  V√©rifiez-le.  Et en effet, comme on dit, l'√©lectronique est la science des contacts. <br><br>  2. Probl√®mes d'alimentation.  Ne fournissez pas 5 volts de puissance l√† o√π 3,3 est requis.  Parfois, la fum√©e provient de l'ESP8266.  Bien que, d'un autre c√¥t√©, il dig√®re sans probl√®me les signaux logiques des appareils √† cinq volts. <br><br>  3. Probl√®mes avec une puissance suffisante.  L'ESP8266 a un caract√®re vil et peut parfois consommer pr√®s de trois cents milliamp√®res, bien qu'avant il puisse se contenter de trente.  En cons√©quence, la fragile carte stabilisateur 3,3 volts "Arduino", √† laquelle vous ne pouvez rien ajouter, elle est connect√©e, elle descend imm√©diatement √† des valeurs microscopiques.  Et vous ne pouvez pas comprendre pourquoi cela fonctionne, alors non. <br><br>  4. Confusion avec les conclusions.  V√©rifiez toujours quels signaux vont o√π.  Le r√©cepteur RXD doit se connecter √† l'√©metteur TXD, ainsi que le TXD √† RXD, mais MOSI doit se connecter √† MOSI, et MISO √† MISO, etc. <br><br>  5. Ne vous fiez pas aux r√©sistances de rappel en circuit dans l'ESP8266, tirez toujours les fils √† z√©ro ou √† la puissance, √† travers des r√©sistances externes de 5 √† 10 kilo-ohms, et pas seulement un cavalier.  Sinon, vous pouvez, au mieux, obtenir une consommation actuelle sans pr√©c√©dent, puis sentir l'odeur d√©sagr√©able du plastique br√ªl√©. <br><br>  6. Bancs de logiciels.  √âtant donn√© que les logiciels pour les utilisateurs individuels sont √©crits par les m√™mes passionn√©s, des probl√®mes du micrologiciel lui-m√™me et des bogues apparaissent p√©riodiquement lors de la mise √† jour des versions du m√™me micrologiciel.  Il est trait√© en rampant dans les forums concern√©s, parfois m√™me en anglais.  Certains camarades ont m√™me affirm√© que la puce ESP elle-m√™me √©tait humide comme le temps √† Saint-P√©tersbourg, mais d'autre part, il y avait aussi l'opinion que depuis 2014 (l'ann√©e de sa premi√®re sortie), la situation avec cela s'√©tait consid√©rablement am√©lior√©e (contrairement √† la m√©t√©o). <br><br>  7. Probl√®mes myst√©rieux.  Il s'agit d'un ph√©nom√®ne rare, mais consommateur de nerfs.  Par exemple, je n'avais pas d'appareil ¬´Arduino¬ª distant.  C'est plut√¥t arriv√©, mais avec des erreurs.  Mais cela s'est pass√© sans erreur si un c√¢ble du programmeur √©tait accroch√© (mais sans le programmeur lui-m√™me).  "AHA," me dis-je, et soudai un condensateur de 15 pF entre la broche de transfert de donn√©es et la broche de synchronisation.  Tout fonctionnait.  Mais le jour a tu√©. <br><br>  Commen√ßons donc par le plus simple.  Nous avons un membre m√©canique MechArm (mais pas ce que Howard Volovits a assembl√©) fabriqu√© en Chine et un ordinateur personnel avec Windows.  La t√¢che consiste √† flasher √† distance le programme et √† le g√©rer depuis l'ordinateur. <br><img src="https://habrastorage.org/web/296/4e6/530/2964e653055742f1a6641f06f2d767b1.jpg"><br>  Pour le contr√¥leur de contr√¥le, nous prenons une jolie √©charpe miniature Arduino Nano avec une pierre ATmega328P.  Cette planche est parfaitement enfonc√©e dans le bras m√©canique. <br><img src="https://habrastorage.org/web/45f/320/2e5/45f3202e545d485faa6d1b5fb71bc574.jpg"><br>  Maintenant, nous d√©cidons comment nous allons le programmer.  Il existe trois m√©thodes principales qui conviennent le mieux au micrologiciel distant: via l'interface SPI, via le chargeur de d√©marrage int√©gr√©, via le port JTAG. <br><br>  L'option la plus simple est bien s√ªr le chargeur de d√©marrage int√©gr√© (chargeur de d√©marrage).  Il s'agit d'une m√©moire pr√©enregistr√©e dans FLASH, un programme qui re√ßoit un code selon un certain protocole (par exemple, en utilisant l'UART le plus simple) et l'√©crit √† l'emplacement du programme charg√© avec des commandes sp√©ciales.  Cela fonctionne, par exemple, le bootloader ARDUINO IDE.  Apr√®s une r√©initialisation ou un d√©marrage, le chargeur de d√©marrage attend un certain temps pour recevoir des donn√©es et s'il n'attend pas, il d√©marre l'ex√©cution du programme √† partir de l'adresse z√©ro.  Si les donn√©es arrivent, il les √©crit dans la section programme.  Apr√®s la prochaine r√©initialisation, le programme t√©l√©charg√© d√©marre.  En d√©tail, j'ai peut-√™tre d√©crit de mani√®re inexacte, mais l'essentiel est juste cela.  Par cons√©quent, nous n'avons besoin que de trois sorties pour la programmation: r√©cepteur RTD, r√©initialisation RESET et masse GND.  En g√©n√©ral, l'√©metteur TRD est √©galement utilis√© pour v√©rifier le programme enregistr√©, mais pour les applications de d√©monstration simples (pas pour une centrale nucl√©aire), la v√©rification peut √™tre omise. <br><br>  Le chargeur lui-m√™me est √©crit en langage assembleur, il y a des exemples de chargeurs simples dans les fiches techniques sur AVR.  Vous pouvez creuser un chargeur de d√©marrage existant s'il est dans le domaine public et simplement l'utiliser sous une forme pr√™te √† l'emploi si le protocole par lequel il fonctionne est connu.  La seule mise en garde est que vous devez configurer l'AVR dans un mode sp√©cial en faisant clignoter des bits de fusible sp√©ciaux, ce qui est fait par un programmeur normal, puis vous pouvez √©galement coudre le chargeur de d√©marrage dans la m√©moire du microcontr√¥leur (c'est-√†-dire que vous ne pouvez pas vous passer d'une programmation). <br><br>  La deuxi√®me option consiste √† programmer via l'interface s√©rie SPI.  Il n'y a pas de chargeur de d√©marrage interne ici, mais nous programmons en envoyant des commandes sp√©ciales puis des donn√©es via l'interface susmentionn√©e.  Ici, nous avons un chargeur de d√©marrage externe, mais vous devez toujours l'√©crire.  En plus de RESET et GND, quatre sorties MOSI suppl√©mentaires sont utilis√©es pour la transmission, les donn√©es MISO, la synchronisation SLK, la s√©lection de la puce CS.  Mais en g√©n√©ral, vous pouvez √©galement supprimer MISO et CS.  Les donn√©es ne seront accept√©es (il n'y aura alors aucune v√©rification du programme), et nous n'avons qu'un seul cristal. <br><br>  Chaque approche a ses avantages et ses inconv√©nients (et je n'ai pas du tout consid√©r√© JTAG, car la vie humaine est courte).  Mais √† la fin, je me suis pench√© vers SPI parce que j'√©tais trop paresseux pour √©crire dans l'assembleur, mais je n'ai pas trouv√© de chargeurs de d√©marrage pr√™ts √† l'emploi ouverts (je ne l'ai pas bien cherch√©). <br><br>  Pour construire un canal sans fil, j'ai, comme d√©j√† mentionn√©, choisi la puce ESP8266 actuellement tr√®s connue - un microcontr√¥leur, ou plut√¥t, un SoC (System-on-Chip) entier du fabricant chinois Espressif avec une interface Wi-Fi.  En plus du Wi-Fi, il se distingue par la possibilit√© d'ex√©cuter des programmes √† partir de la m√©moire flash externe.  Et sp√©cifiquement pour mon projet, j'ai pris l'ESP8266-07 avec 512 Ko de m√©moire √† bord. <br><br><img src="https://habrastorage.org/web/e50/03b/ab1/e5003bab173c4deca207971fd82261f0.jpg"><br>  En g√©n√©ral, n'importe quel ESP8266 convient o√π il y a des jambes suppl√©mentaires pour impl√©menter SPI.  Par cons√©quent, le ESP8266-01 le plus simple ne nous convient pas, car il a tr√®s peu de jambes pour les ports d'entr√©e / sortie.  Mais d'un autre c√¥t√©, la diff√©rence de prix est inf√©rieure √† cent roubles et ils sont disponibles √† parts √©gales.  Eh bien, les grandes cartes de d√©bogage avec ESP, o√π un tas de p√©riph√©riques sont pratiques, ne nous conviennent pas non plus, car elles ne vont pas l√† o√π nous voulons les pousser dans notre bras m√©canique. <br><br>  L'essence globale de l'id√©e en g√©n√©ral √©tait la suivante.  Le corps du programme charg√© dans le microcontr√¥leur est transf√©r√© de l'ordinateur √† l'ESP sans fil via WI-FI (au sein de votre r√©seau domestique).  Et ESP d√©j√† c√¢bl√© √† l'aide de l'interface SPI √©crit ce programme directement dans la m√©moire FLASH du microcontr√¥leur.  Ensuite, il le r√©initialise naturellement et permet au programme charg√© de s'ex√©cuter.  De plus, l'ESP doit avoir une unit√© ind√©pendante, qui g√®re √©galement l'√©change de donn√©es avec le microcontr√¥leur, car nous voulons non seulement programmer, mais aussi √©changer des donn√©es avec lui.  En particulier, pour un projet avec MechArm, apr√®s avoir enregistr√© le programme, nous transmettons toujours des signaux d'asservissement afin de mettre cette main en mouvement.  Par cons√©quent, sur l'ESP lui-m√™me, il est conseill√© pour nous d'√©lever un serveur TCP pour le transfert de programme et un serveur UDP pour contr√¥ler MechArm.  En cons√©quence, ces serveurs rejoignent le r√©seau domestique et √©coutent attentivement s'il y a quelqu'un qui veut t√©l√©charger un nouveau code sur MechaArm ou le faire signe √† quelqu'un. <br><br>  J'ai donc trouv√© sur le Web que le firmware vous permet d√©j√† de programmer l'AVR par voie a√©rienne, mais l√† le principal probl√®me est que pour quoi d'autre ce firmware ne peut plus √™tre utilis√©.  Apr√®s la programmation, nous aimerions √©galement communiquer avec AVR √† distance. <br><br>  Quels logiciels utiliserons-nous: <br><br>  Pour PC, j'ai tout √©crit en JAVA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntelliJ IDEA</a> .  Mais en gros, vous pouvez tout faire, l'essentiel pour nous est d'√©crire un client qui enverra le programme pour flasher AVR √† ESP8266. <br><br>  J'√©cris moi-m√™me des programmes pour AVR dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ATMEL STUDIO</a> , en langage C, rarement en assembleur.  Je n'utilise pas de croquis Arduino en principe, presque toutes les biblioth√®ques n√©cessaires sont √©crites en une heure ou deux, avec une compr√©hension compl√®te de son travail.  J'ai essay√© les croquis, mais tant que vous n'avez pas de syst√®me d'exploitation sur l'AVR, les croquis enl√®veront les p√©riph√©riques √† un ami et √©choueront r√©guli√®rement.  Oui, l'IDE Arduino lui-m√™me, par rapport √† ATMEL STUDIO, est bien s√ªr une chose tr√®s primitive.  Mais ici, la question est, bien s√ªr, controvers√©e, pour les sciences humaines et les √©coliers, ce sera plus amusant et plus facile, probablement, avec des croquis. <br><br>  Pour programmer l'ESP8266, j'ai utilis√© le firmware NodeMCU et j'ai √©crit des programmes en Lua.  Non, j'aimerais √©crire en Java et en C, mais il n'y en a pas en ESP.  Le langage Lu tel qu'il est appliqu√© √† notre t√¢che n'est pas difficile, pour ma√Ætriser quelques trivialit√©s.  Et en fait, pour t√©l√©charger des programmes et les d√©boguer sur ESP, j'ai pris l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDE ESPlorer</a> .  Un produit domestique gratuit (mais vous pouvez le donner √† l'auteur), qui ne peut bien s√ªr pas √™tre compar√© aux environnements mentionn√©s ci-dessus, mais comme le dit le cheval du cadeau ... Mais pour utiliser ESPlorer et √©crire sur LUA, nous devons d'abord changer le firmware de base (fourni par le fabricant) dans la puce ESP8266 pour nouveau.  Le programme NODE MCU PyFlasher nous aidera dans cette entreprise.  Je veux dire, cela aidera √† le reflasher.  Et nous allons cr√©er le firmware nous-m√™mes et le remettre entre les mains du site Web des cr√©ateurs: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NodeMCU</a> . Et vous pouvez en savoir plus sur ce processus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici:</a> <br><br>  Tout est tr√®s accessible et compr√©hensible.  Nous ajoutons la prise en charge SPI et les op√©rations binaires aux biblioth√®ques de base (dans LUA, dans notre cas, les op√©rations binaires sont surcharg√©es et inutiles).  De nombreuses biblioth√®ques ne doivent pas √™tre ins√©r√©es dans le firmware des biblioth√®ques, car en raison de la pr√©sence de divers logiciels sur l'ESP8266, il reste tr√®s peu de m√©moire, une sorte de 20 kB path√©tique. <br><br>  Bien s√ªr, vous pouvez simplement prendre le firmware fini, dont beaucoup tra√Ænent d√©j√† sur Internet, mais je ne le recommande pas.  Du moins parce que certains d'entre eux ne prennent pas en charge les op√©rations sur les bits (et nous en avons besoin) et qu'il n'y a pas de r√©gulation du taux de transfert de donn√©es via SPI. <br>  En cons√©quence, ils sont transmis par d√©faut √† une vitesse de 40 MHz divis√©e par un petit coefficient et donc l'AVR n'a pas le temps de les dig√©rer. <br><br>  Qui est trop paresseux pour cr√©er un firmware, vous pouvez t√©l√©charger le mien depuis le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cloud</a> . <br><br>  Nous avons maintenant le firmware et nous devons le charger dans l'ESP8266 au lieu de celui de base.  Pour ce faire, nous avons besoin d'un simple adaptateur USB - UART. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/48a/a27/8c7/48aa278c709446c38f3c89dd7b063bb6.jpg"></div><br>  Nous connectons les jambes TXD √† RXD et RXD √† TXD, nous faisons la masse commune, mais n'utilisons pas, il semble, une sortie d'alimentation 3,3 V pratique sur l'adaptateur.  Dans la plupart des cas, l'ESP8266 le vidange compl√®tement.  Par cons√©quent, nous le nourrissons s√©par√©ment.  Ensuite, nous avons mis l'ESP en mode de programmation (GP0 au sol, si quelqu'un a oubli√©) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ex√©cutons</a> le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NODE MCU PyFlasher</a> . <br><br><img src="https://habrastorage.org/web/437/bd0/676/437bd067628f4a9db96466bb8d0d793b.png"><br><br>  Surtout, n'oubliez pas d'effacer la m√©moire flash (oui, efface toutes les donn√©es), sinon, selon la version du micrologiciel, apr√®s la programmation, des d√©chets inutiles peuvent rester dans la m√©moire, qui √† leur tour d√©versera des d√©chets dans la console lors de travaux ult√©rieurs.  Avant cela, j'utilisais un logiciel, o√π il n'y avait pas d'option pour effacer la m√©moire au pr√©alable, j'√©tais terriblement tourment√©, car rien ne fonctionnait.  Et le cercueil vient d'ouvrir, seule la v√©rit√© sur le forum anglais des cr√©ateurs de NODE MCU. <br><br>  Apr√®s avoir acquis le firmware n√©cessaire, nous pouvons maintenant √©crire et d√©boguer des programmes LUA (il y a aussi MicroPython, mais je ne l'ai pas utilis√©) en utilisant des API tr√®s pratiques de NODE MCU.  Nous lan√ßons l'ESPlorer d√©j√† mentionn√©. <br><br><img src="https://habrastorage.org/web/8c0/a47/d1f/8c0a47d1fbfa41c8a1413852852a1513.png"><br><br>  Nous le configurons √©galement pour fonctionner avec ESP8266, d√©finissons les param√®tres de la connexion s√©rie.  Tout est assez simple et r√©p√©t√© √† plusieurs reprises sur Internet. <br><br>  Maintenant, nous √©crivons le programme sur LUA, que nous t√©l√©chargeons ensuite sur ESP8266: <br><br><div class="spoiler">  <b class="spoiler_title">Lua bootloader pour AVR √©crit sur ESP8266</b> <div class="spoiler_text"><pre><code class="lua hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming"&lt;/b&gt; p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then print("connection established") p=33 if(p==31) then print("no connection") end end end end &lt;b&gt;function ProgrammingDisable ()&lt;/b&gt; pin=2--END OF ESET FOR MK gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) pin=5--CLK MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI gpio.mode(pin, gpio.INPUT) end &lt;b&gt;function ProgrammingEnable ()&lt;/b&gt; pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end &lt;b&gt;function InstrFlashErase() &lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) print( "FLASH is erased") InstrProgrammingEnable () end &lt;b&gt;function InstrStorePAGE(H, address, data)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end &lt;b&gt;function InstrWriteFLASH(page_address_low,page_address_high)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end &lt;b&gt;function Programming (payload)&lt;/b&gt; pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end &lt;b&gt;--MAIN BLOCK&lt;/b&gt; wifi.setmode(wifi.STATION) --wifi.sta.config(" ","") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid=" " tmr.delay(30000) station_cfg.pwd="" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) print(wifi.sta.status()) print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end sv=net.createServer(net.TCP,30) tmr.delay(100) print("SERVER READY") sv:listen(4000,function(c) c:on("receive", function(c, payload) print(payload) if (payload =="program\r\n") then c:send("ready\r\n") print("ready for program\r\n") spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,320,spi.FULLDUPLEX) ProgrammingEnable () tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--    st=net.createServer(net.TCP,30) st:listen(4001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then c:send("ready\r\n") print("ready for data\r\n") srv=net.createServer(net.UDP) tmr.delay(1000) pin=10 gpio.write(pin, gpio.HIGH) uart.setup(0,9600,8,0,1,0) srv:listen(5000) srv:on("receive", function(srv, pl) pl=pl*1 --print(pl) uart.write(0,pl) tmr.wdclr() end) end if (payload =="stop\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () print("stop program") end if(srv~=nil) then srv:close() print("stop data") end end end) end) end)</span></span></code> </pre> <br><br></div></div><br>  Lorsque les fonctions concern√©es effectuent les actions suivantes: <br><br>  <b>function InstrProgrammingEnable ()</b> - met le microcontr√¥leur en mode de programmation avec une commande sp√©ciale envoy√©e via SPI. <br><br>  <b>Fonction ProgrammingEnable ()</b> - il suffit de r√©initialiser l'AVR pendant 25 ms avant de commencer la programmation <br><br>  <b>function ProgrammingDisable ()</b> - apr√®s la fin de la programmation, nous traduisons les sorties SPI dans ESP8266 dans un √©tat inactif afin qu'elles n'interf√®rent pas avec nous lors de l'ex√©cution de code sur le microcontr√¥leur (du coup elles y sont utilis√©es) <br><br>  <b>function InstrFlashErase ()</b> - nous effa√ßons la m√©moire flash du microcontr√¥leur avant de programmer.  Pourquoi cela doit √™tre expliqu√© n'est pas n√©cessaire. <br><br>  <b>fonction InstrStorePAGE (H, adresse, donn√©es)</b> - cette commande √©crit l'octet du programme dans le tampon interne du microcontr√¥leur.  Mais ce n'est pas l'enregistrement flash lui-m√™me, car le flash est √©crit ici page par page √† 128 octets. <br><br>  <b>fonction InstrWriteFLASH (page_address_low, page_address_high)</b> - mais il s'agit d'un enregistrement flash et cela prend du temps, faites attention au retard de 5000 Œºs. <br><br>  <b>Programmation de fonction (charge utile)</b> - la fonction la plus grande et la plus importante utilisant les fonctions ci-dessus.  Il prend le programme transmis en morceaux de 1024 octets, les divise en octets et forme les adresses pour eux, puis l'envoie au microcontr√¥leur dans le tampon interne et initialise l'enregistrement flash tous les 128 octets.  Puis il prend le kilo-octet suivant de code et r√©p√®te l'op√©ration, naturellement avec un d√©calage dans les adresses, afin d'√©crire plus loin et de ne pas √©craser l'enregistrement.  Au d√©but, j'ai essay√© de transf√©rer le programme entier, mais lorsque je d√©passe 6 kilo-octets dans ESP8266, la m√©moire disponible se termine et elle se bloque.  Un kilo-octet s'est av√©r√© √™tre l'unit√© la plus pratique, car il est soigneusement divis√© en parties et facilement transmis via TCP (nous devons toujours l'obtenir de l'ordinateur).  Une taille plus grande n'est √©galement pas n√©cessaire, TCP, vous savez, dans la version actuelle limite le paquet transmis √† 1500 ou octets (mais pour une raison quelconque, 1440 m'a √©t√© transmis, en quelque sorte). <br><br>  Comme si rien de compliqu√©, mais quelques √©cueils devaient √™tre surmont√©s. <br><br>  Vient ensuite le BLOC PRINCIPAL.  Dans ce document, nous: <br><br>  Nous sommes enregistr√©s dans un r√©seau sans fil. <br><br>  Nous cr√©ons d'abord un serveur TCP qui √©coute trois commandes: <br><br>  1. ¬´programme¬ª (nous programmerons) <br><br>  2. ¬´donn√©es¬ª (nous allons modifier les donn√©es), <br><br>  3. ¬´stop¬ª (on arr√™te tout). <br><br>  Si nous programmons, nous initialisons d'abord le SPI et cr√©ons un autre serveur TCP qui saisit les donn√©es (code du micrologiciel) par kilo-octet et appelle les fonctions de programmation du microcontr√¥leur pour eux.  Je comprends qu'il semble stupide de cr√©er un deuxi√®me serveur, mais c'est une n√©cessit√©, car l'API locale prend en charge la cr√©ation d'un seul socket, et nous devons s√©parer les commandes "programme" et "donn√©es" avec les donn√©es transmises, car √† l'≈ìil, elles ne diff√®rent pas, il y a des octets et voici des octets. <br><br>  Si nous voulons ne pas programmer, mais √©changer des donn√©es, en les envoyant dans notre cas au microcontr√¥leur, alors nous envoyons d'abord la cha√Æne ¬´data¬ª via TCP.  En r√©ponse √† cela, un serveur UDP sera d√©j√† cr√©√© (je vous rappelle que nous ne g√©rons pas dynamiquement avec une main m√©canique et que nous n'avons pas besoin de retards avec la formation de paquets TCP, et envoyons en effet un octet dans son ensemble une trame TCP en harmonie).  Et les datagrammes UDP seront petits et se formeront rapidement. <br><br>  Une fois l'UART initialis√©, chaque octet re√ßu sans fil est d√©j√† envoy√© via le c√¢ble TXD au microcontr√¥leur, qui est oblig√© de l'accepter si le programme correspondant y est mis √† jour.  L'√©change de donn√©es dans une autre direction n'est pas non plus difficile √† organiser, mais je ne l'ai pas encore mis en ≈ìuvre. <br><br>  Eh bien, avec la commande "stop", les serveurs mentionn√©s ci-dessus (sauf le tout premier) ferment les connexions et le serveur principal passe √† nouveau dans l'√©tat d'attente des commandes "programme" et "donn√©es". <br><br>  √âtant donn√© que l'interface SPI est √©mul√©e par programme dans ESP8266, les ports d'E / S pour les signaux CS, CLK, MISO, MOSI, RESET (pour AVR), vous pouvez utiliser tous ceux disponibles, et non ceux indiqu√©s dans mon chargeur de d√©marrage.  En outre, il s'est av√©r√© que CS et MISO, en principe, peuvent √©galement √™tre interrompus dans ce cas, cela fonctionnera sans eux.  Eh bien, une broche est utilis√©e sur la LED int√©gr√©e √† la carte ESP8266 de sorte qu'elle clignote parfois et indique que le programme est toujours vivant. <br><br>  Les v√©rifications des erreurs d'enregistrement ne sont pas effectu√©es (√† l'exception de la premi√®re demande √† AVR, mais ces informations sont simplement affich√©es sur la console), l'EEPROM n'est pas programm√©, plus de 32 Ko n'est pas cousu - bref, il y a encore du travail √† faire.  La vitesse d'√©change SPI est d'environ 115 Kbit, en quelques secondes tout clignote, environ, comme avec un programmeur s√©rie ordinaire comme ISP500). <br><br>  Prenez le code, entrez vos r√©seaux et mots de passe, compilez sur ESplorer, appelez-le ¬´init¬ª (pour qu'il d√©marre au red√©marrage) et envoyez-le √† ESP8266.  √áa devrait marcher.  Dans le sens de travailler en tant que programmeur sans fil, au moins. <br><br>  Nous allons maintenant traiter avec la partie gestionnaire - un ordinateur personnel. <br><br>  En fait, nous devons prendre le fichier HEX dans lequel vos programmes √©crits dans l'environnement ATMEL STUDIO se tournent et l'envoyer via WI-FI au port socket que nous connaissons (dans ce cas 4000).  Le petit hic, c'est que nous avons besoin d'un fichier BIN binaire pour le transfert, et ATMEL STUDIO ne nous pla√Æt qu'avec un HEX.  Il existe deux voies de sortie;  ou convertissez-le au format BIN avec un convertisseur de programme sp√©cial, tel que WinHex, ou faites-le vous-m√™me dans votre programme.  Je ne l'ai pas encore fait, mais cela ne semble pas difficile, il faut couper le titre et faire autre chose. <br><br>  En cons√©quence, j'ai √©crit le programme de chargeur de d√©marrage dans JAVA (principalement parce que je ne sais rien faire d'autre), travaillant dans l'environnement IntelliJ IDEA tout simplement magnifique et gratuit.  Il cr√©e un client TCP qui recherche un serveur s'ex√©cutant sur ESP8266.  S'il le trouve, il le contacte et lui envoie un fichier situ√© √† une telle adresse.  Le code est ci-dessous. <br><br><div class="spoiler">  <b class="spoiler_title">T√©l√©chargeur de fichiers JAVA sur PC</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Net</span></span></span><span class="hljs-class"> </span></span>{ &lt;b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Http_client(<span class="hljs-number"><span class="hljs-number">4000</span></span>); }&lt;/b&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http_client</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; String s; String Greetings_from_S; Http_client(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//192.168.1.113 -  ESP8266   .  ,      //    ,    try (Socket socket = new Socket("192.168.1.113", port)) { PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()),true); pw.println("program");// Greetings with SERVER System.out.println("program"); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); Greetings_from_S = br.readLine(); System.out.println(Greetings_from_S); if(Greetings_from_S.equals("ready")) { try { File file = new File("d:BlinkOUT.bin");//    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); byte [] data = new byte[bis.available()]; bis.read(data); byte [] data_buffer = new byte[1024]; int frames = data.length/1024; System.out.println(frames); int residy = data.length%1024; for (int i = 0; i &lt; frames;i++) { for (int k = 0; k&lt; (1024); k++) { data_buffer[k] = data[k+1024*(i)]; } sendingChunk(data_buffer); } byte [] data_buffer2= new byte[residy]; for (int i = 0; i &lt; residy;i++) { data_buffer2[i] = data[i+1024*(frames)]; } sendingChunk(data_buffer2); pw.println("stop");// System.out.println("stop program"); } catch (Exception e) { System.out.println(e); } } } catch (Exception e) { System.out.println(e); } } public void sendingChunk (byte [] data_buffer){ try (Socket socket = new Socket("192.168.1.113", 4001)){ BufferedOutputStream bos = new BufferedOutputStream((socket.getOutputStream())); bos.write(data_buffer); bos.flush(); System.out.println(data_buffer.length); } catch (Exception e) { System.out.println(e); } } }</span></span></code> </pre><br><br></div></div><br>  Ici, bien s√ªr, trop de blessures ont √©t√© enroul√©es, toutes sortes de pr√™ts, en principe, ne sont pas n√©cessaires.  Si la connexion TCP est √©tablie, elle l'est.  Le seul probl√®me √©tait que le fichier ne voulait en aucun cas √™tre envoy√© en morceaux de 1024 octets, comme j'avais vraiment besoin, bien que j'indique explicitement la taille.  Apparemment, il existe une sorte de tampon final inaccessible √† partir de JAVA, et il envoie des paquets de la taille qu'il souhaite, ce qui est compl√®tement inacceptable pour le c√¥t√© r√©cepteur.  Au d√©but, j'ai essay√© de retarder afin que le tampon se lasse d'attendre les prochaines pi√®ces et de l'envoyer tel quel.  Mais le retard a commenc√© √† fonctionner lorsqu'il a atteint 10 secondes, ce qui semblait en quelque sorte un peu trop pour un kilo-octet transf√©r√©. <br><br>  Mais ensuite, j'ai remarqu√© que pour une raison quelconque, la premi√®re pi√®ce se d√©roule toujours sans heurts, laquelle a √©t√© command√©e, et d√®s la seconde commence une bacchanale impr√©visible.  Par cons√©quent, j'ai demand√© au client d'ouvrir la connexion, d'envoyer une partie du code en 1024 octets et de fermer la connexion.  Et ainsi de suite jusqu'√† l'envoi de l'int√©gralit√© du fichier.  Tout fonctionnait bien. <br><br>  La seule chose √† faire est d'installer le runtime JAVA sur l'ordinateur.  Mais je commence g√©n√©ralement tout de suite √† partir d'IntelliJ IDEA car l√†, vous pouvez toujours voir ce qui se passe dans la console (mais ici, vous avez besoin d'un environnement JAVA).  Bien s√ªr, d'une mani√®re intelligente, vous devez cr√©er une interface graphique.  Autrement dit, la fen√™tre o√π le chemin d'acc√®s au fichier tombe, la possibilit√© de modifier les num√©ros de port dans la fen√™tre et, bien, d'autres choses n√©cessaires.  Et collectez tout cela sous la forme d'un fichier ex√©cutable. <br><br>  Et tapericha, comme Koroviev disait, revenons aux citoyens, en fait, au membre m√©canique MechArm, qui a √©t√© mentionn√© au tout d√©but.  Nous avons maintenant la possibilit√© de le programmer √† distance, puis de le g√©rer.  Passons au programme de contr√¥le sur le c√¥t√© du microcontr√¥leur. <br><br>  Dans ce cas, nous devons contr√¥ler quatre servos.  Voici ceux-l√†. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/d29/b6c/8ee/d29b6c8ee960405b9070649d8dc0b2a2.jpg"></div><br>  Un tel entra√Ænement est contr√¥l√© par des impulsions rectangulaires d'une p√©riode de 20 ms (50 Hz) avec un facteur de marche de 2 √† 4%.  Autrement dit, 2% est un virage complet dans un sens, 4% dans l'autre.  La t√¢che est juste pour le PWM int√©gr√© dans l'AVR. <br><br><img src="https://habrastorage.org/web/9a8/385/2f6/9a83852f6093435abf70b5a8f8d5f29c.png"><br><br>  Un servomoteur est utilis√© pour se d√©placer √† gauche et √† droite;  le second sur soi - de soi;  troisi√®me de haut en bas;  le quatri√®me est la griffe elle-m√™me, qui doit √™tre comprim√©e et d√©velopp√©e.  Tout est √©crit en C et compil√© dans un fichier HEX dans ATMEL STUDIO.  Un type de programme un peu √©trange est d√ª au fait qu'au d√©part, la main √©tait contr√¥l√©e depuis le clavier attach√© avec des fils au microcontr√¥leur.  Mais les fils d'hier, nous devons encore √©voluer. <br><br>  Vous pouvez bien s√ªr utiliser des croquis pour les servos de "ARDUINO", mais je ne les aimais pas.  C'est plus int√©ressant de t'√©crire.  De plus, les quatre servos devraient fonctionner simultan√©ment, et non en mode multiplex√©, lorsque le PWM passe successivement √† chaque servo.  Car personne n'a annul√© la gravit√©, et un membre sur√©lev√© descendra imm√©diatement si les impulsions de contr√¥le cessent d'arriver au servomoteur correspondant.  Je ne suis pas s√ªr que l'esquisse ¬´ARDUINO¬ª permette un fonctionnement simultan√© pour quatre servos.  Mais nous-m√™mes pouvons bien √©crire un programme qui r√©pond aux exigences n√©cessaires.  En g√©n√©ral, en l'absence d'un syst√®me d'exploitation qui s√©pare les agneaux des ch√®vres, l'utilisation de croquis en concurrence pour les p√©riph√©riques du microcontr√¥leur (et nous ne savons m√™me pas lesquels √† l'avance) est trop bogu√©. <br><br>  Voici le code lui-m√™me que nous √©crivons sur l'Arduino Nano en utilisant l'ESP8266-07. <br><br><div class="spoiler">  <b class="spoiler_title">Programme de contr√¥le de MechArm pour microcontr√¥leur AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;stdint.h&gt;//    #include &lt;avr/interrupt.h&gt; #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;avr/eeprom.h&gt; #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; //  #define UART_BAUD_RATE 115200 //  1    20 #define COUNTER1_OFF TCCR1B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER1_ON TCCR1B=0b00000011 //  0       0  1 #define COUNTER0_OFF TCCR0B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER0_ON TCCR0B=0b00000100 //  2       B2(PD6)  3(PD7) #define COUNTER2_OFF TCCR2B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER2_ON TCCR2B=0b00000110 volatile uint16_t period_20ms; volatile uint8_t State_of_keyboard; volatile uint8_t start_position [6]; volatile int8_t number_servo; ISR(USART_RX_vect)//   UART { State_of_keyboard=UDR0; return; } ISR(TIMER0_COMPA_vect)//  0    { PORTB &amp;=~(1&lt;&lt;0); TIMSK0&amp;=~(1&lt;&lt;OCIE0A); TIFR0 |=(1&lt;&lt;OCF0A); return; } ISR(TIMER0_COMPB_vect) //  1    { PORTB &amp;=~(1&lt;&lt;1); TIFR0 |=(1&lt;&lt;OCF0B); TIMSK0 &amp;=~(1&lt;&lt;OCIE0B); return; } ISR(TIMER2_COMPA_vect)//  2(PD6)    { PORTD &amp;=~(1&lt;&lt;6); TIFR2 |=(1&lt;&lt;OCF2A); TIMSK2 &amp;=~(1&lt;&lt;OCIE2A); return; } ISR(TIMER2_COMPB_vect)//  3(PD7)    { PORTD &amp;=~(1&lt;&lt;7); TIFR2 |=(1&lt;&lt;OCF2B); TIMSK2 &amp;=~(1&lt;&lt;OCIE2B); return; } ISR(TIMER1_OVF_vect){//   20      COUNTER1_OFF; COUNTER0_OFF; COUNTER2_OFF; TIFR0 |=(1&lt;&lt;OCF0A); TIFR0 |=(1&lt;&lt;OCF0B); TIFR2 |=(1&lt;&lt;OCF2A); TIFR2 |=(1&lt;&lt;OCF2B); TIFR1 |=(1&lt;&lt;TOV1); PORTB |=(1&lt;&lt;0)|(1&lt;&lt;1); PORTD |=(1&lt;&lt;6)|(1&lt;&lt;7); TCNT1 = period_20ms; //  20  TCNT0 = 0; TCNT2 = 0; TIMSK0|=(1&lt;&lt;OCIE0A)|(1&lt;&lt;OCIE0B); TIMSK2|=(1&lt;&lt;OCIE2A)|(1&lt;&lt;OCIE2B); OCR0A=start_position[1];//  0  0 OCR0B=start_position[2];//  0  1 OCR2A=start_position[3];//  0  2 OCR2B=start_position[4];//  0  3 COUNTER1_ON; COUNTER2_ON; COUNTER0_ON; return; } void time_delay(long i) { cli();sei(); long k; i*=2000; for(k=0;k&lt;i;k++){;;}; } void timer_counter0_1_2_INIT()//   0,1,2 { // 1 TCCR1A &amp;=~(1&lt;&lt;COM1A0)|~(1&lt;&lt;COM1A1)|~(1&lt;&lt;COM1B0)|~(1&lt;&lt;COM1B1);//   TCCR1A &amp;=~(1&lt;&lt;WGM10)|~(1&lt;&lt;WGM11); TCCR1B &amp;=~(1&lt;&lt;WGM12)|~(1&lt;&lt;WGM13);//    period_20ms=60575; TCNT1 = period_20ms; TIMSK1|=(1&lt;&lt;TOIE1);//|    //TIFR0   TOV0 // 0 TCCR0A &amp;=~(1&lt;&lt;COM0A0)|~(1&lt;&lt;COM0A1)|~(1&lt;&lt;COM0B0)|~(1&lt;&lt;COM0B1);//   TCCR0A &amp;=~(1&lt;&lt;WGM00)|~(1&lt;&lt;WGM01); TCCR0B &amp;=~(1&lt;&lt;WGM02);//    // 2 TCCR2A &amp;=~(1&lt;&lt;COM2A0)|~(1&lt;&lt;COM2A1)|~(1&lt;&lt;COM2B0)|~(1&lt;&lt;COM2B1);//   TCCR2A &amp;=~(1&lt;&lt;WGM20)|~(1&lt;&lt;WGM21); TCCR2B &amp;=~(1&lt;&lt;WGM22);//    COUNTER1_ON; } void servo_reset() { start_position[1]=97;//  0  0 start_position[2]=70;//  0  1 start_position[3]=92;//  0  2 start_position[4]=124; // 0  3 COUNTER1_ON; time_delay(100); } void servo_go( int8_t moven, uint8_t servo_position_max, uint8_t servo_position_min)// { switch (moven){ case 1: start_position[number_servo]++; if(start_position[number_servo]==servo_position_max){start_position[number_servo]--;};//  +90  break; case 2: start_position[number_servo]--; if(start_position[number_servo]==servo_position_min){start_position[number_servo]++;};//6  -90  break; }; time_delay(20); return; } //PORTB-0,1, PORTD - 6,7 -  , 8-  COUNTER 0 int main(void) { uint8_t servo_positionmin=0, servo_positionmax=0; int8_t const servo_position1max = 122, servo_position1min=58; //  int8_t const servo_position2max = 120, servo_position2min=36;// int8_t const servo_position3max = 125, servo_position3min=68;// int8_t const servo_position4max = 129, servo_position4min=108;// 128 108 sei(); DDRD = 0B11000010; //   D2-D5  , D0  RX, D1  TX, D6 D7   3  4 PORTD = 0B00111110; //     DDRB |=(1&lt;&lt;0)|(1&lt;&lt;1);//         PORTB &amp;=(~1&lt;&lt;0)|(~1&lt;&lt;1); UCSR0A=0;// UART UCSR0B=0b10010000; UCSR0C=0b00000110; UBRR0L=103;//  115200 UBRR0H=0; timer_counter0_1_2_INIT(); servo_reset(); PORTB |=(1&lt;&lt;5); while (1) { switch (State_of_keyboard) { case 1://   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 2: //   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 5: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 6: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 7: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 8: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 3: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  case 4: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  // c    - ,       4-  //        ,         } if(State_of_keyboard==1||State_of_keyboard==3||State_of_keyboard==5||State_of_keyboard==7) { servo_go(1,servo_positionmax,servo_positionmin);// } if(State_of_keyboard==2||State_of_keyboard==4||State_of_keyboard==6||State_of_keyboard==8) //     { servo_go(2,servo_positionmax,servo_positionmin);// } time_delay(20); } }</span></span></span></span></code> </pre><br><br></div></div><br>  L'essence du programme ressort clairement du texte et des commentaires.  Nous utilisons un compteur T1 pour une p√©riode exemplaire de 20 ms et des compteurs T0, T2 pour √©mettre des signaux PWM vers quatre lignes du port d'E / S, puisque chacun de ces deux compteurs peut fonctionner sur deux appareils. <br>  Le programme d√©finit les positions initiales des servos en chargeant les registres de comptage OCR0A, OCR0B, OCR2A, OCR2B.  Des constantes de contrainte sont √©galement introduites, car nous n'avons pas toujours besoin d'une plage de 180 degr√©s.  Eh bien et plus loin, par interruption de l'UART, le programme capture le num√©ro envoy√© par ESP8266 (de 1 √† 8) et le traduit en une commande pour le servo correspondant.  Il y a quatre disques, chacun fonctionnant dans deux directions, donc des entiers de un √† huit suffisent.  Une fois le nombre s√©lectionn√©, le contenu des registres de compteur ci-dessus est soit incr√©ment√© soit d√©cr√©ment√©, modifiant respectivement le rapport cyclique de l'impulsion de commande et l'angle de rotation du servo-variateur s√©lectionn√©.  Les entra√Ænements que nous n'avons pas s√©lectionn√©s conservent l'ancienne valeur de l'angle de rotation (puisque le contenu des registres correspondants, bien qu'ils aient √©t√© mis √† jour, n'ont pas chang√©) et continuent de maintenir le bras m√©canique dans la m√™me position. <br><br>  Il ne nous reste plus qu'√† √©crire un programme de contr√¥le, d√©sol√© pour la tautalogie, pour contr√¥ler une main m√©canique directement depuis l'ordinateur via WI-FI. <br>  Le code est √©galement √©crit en JAVA, mais un peu anobli.  Une interface graphique et la possibilit√© de modifier les num√©ros de port et l'adresse r√©seau de l'ESP8266 sont apparues. <br><br><img src="https://habrastorage.org/web/d48/d3e/27a/d48d3e27af904919b00d0873de532d3d.png"><br><br>  Ce qui se passe l√†-bas est clair depuis la fen√™tre.  Je ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fournis</a> pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> texte du programme ici (il est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> ), pour la raison suivante: environ 95% de son volume est la cr√©ation de fen√™tres et le traitement du signal √† partir du clavier.  Mais l'essentiel est le m√™me que le programme pr√©c√©dent sur JAVA.  Un client est cr√©√©, seul UDP, qui, selon la touche enfonc√©e, envoie un num√©ro de 1 √† 8, √† l'adresse indiqu√©e sur le port sp√©cifi√©. <br>  Ou vous pouvez imm√©diatement obtenir l'ex√©cutable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> .  Pour les machines 64 bits avec Windows.  M√™me un environnement JAVA install√© n'est pas n√©cessaire.  Tout a d√©j√† √©t√© pouss√© dans 178 Mo. <br><br>  Ainsi, le stylo m√©canique a √©t√© assembl√©, d√©bogu√© et pr√©sent√© √† son fr√®re pour son anniversaire.  Peut ramasser des piles de plastique avec de la vodka, sur Skype dans une autre ville.  Bien que pour le bras m√©canique d'Howard Volovitsa de la s√©rie "The Big Bang Theory", elle est encore loin. <br><br>  Mais ensuite, dans les articles suivants (si quelqu'un est int√©ress√©), nous pourrons le g√©rer √† partir d'un t√©l√©phone mobile, faire de m√™me avec un chariot robotique √† quatre roues et mettre √† jour l'heure des montres √©lectroniques des serveurs de montre sur Internet.  Ensuite, nous avons mis l'ancien smartphone sur le chariot et en avons transf√©r√© la vid√©o vers le r√©seau neuronal avec reconnaissance des formes, puis les signaux de contr√¥le vers les moteurs, <s>oh, quelque chose me porte d√©j√† ...</s> <br><br>  Et tout cela avec le magnifique ESP8266. <br>  Je serais heureux si quelqu'un trouvait l'article int√©ressant. <br><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brochage et sp√©cifications de l'ESP8266</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Connexion de l'ESP8266.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©marrage rapide.</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mise √† jour du firmware de NodeMCU via le cloud</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NODE MCU PyFlasher</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ESPlorer - IDE pour ESP8266</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation C pour AVR</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revue d'articles - ¬´Programmation de microcontr√¥leurs en langage C¬ª</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Description de l'API NodeMCU</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [9] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rence Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [10] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts et modules Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [11] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntelliJ IDEA</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [12] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√©l√©chargez Java sur votre ordinateur maintenant! </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atmel Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr406559/">https://habr.com/ru/post/fr406559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr406547/index.html">Examen des cartes sur SoC ARM + FPGA. Premi√®re partie Xilinx World</a></li>
<li><a href="../fr406549/index.html">Un guide des mat√©riaux √©lectriques pour tout le monde. Partie 9</a></li>
<li><a href="../fr406551/index.html">Monowheel: deux saisons d'exp√©rience</a></li>
<li><a href="../fr406553/index.html">Top 10 des machines de bureau CNC pour la maison 2017</a></li>
<li><a href="../fr406555/index.html">Toi, moi et mon intelligence artificielle</a></li>
<li><a href="../fr406561/index.html">Micromachines dans le traitement des maladies de l'estomac</a></li>
<li><a href="../fr406563/index.html">Pourquoi votre cerveau a besoin de plus de repos</a></li>
<li><a href="../fr406567/index.html">Sous les coups des √©l√©ments: le Kennedy Space Center se pr√©pare √† l'ouragan "Irma"</a></li>
<li><a href="../fr406569/index.html">XRONOS - agr√©gateur</a></li>
<li><a href="../fr406571/index.html">Comment vaincre le vieillissement - plan d'action</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>