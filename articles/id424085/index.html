<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➰ 💪 📹 Kami sedang mengembangkan modul prosesor NIOS II untuk IDA Pro 🖐🏼 💞 🗜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tangkapan Layar Antarmuka IDA Pro Disassembler 

 IDA Pro adalah disassembler terkenal yang telah digunakan oleh para peneliti keamanan informasi di s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami sedang mengembangkan modul prosesor NIOS II untuk IDA Pro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424085/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/141/008/5b2/1410085b245c7ef6a18074b47dda1b6b.gif" alt="gambar"></a> <br><br>  <i>Tangkapan Layar Antarmuka IDA Pro Disassembler</i> <br><br>  IDA Pro adalah disassembler terkenal yang telah digunakan oleh para peneliti keamanan informasi di seluruh dunia selama bertahun-tahun.  Kami di Positive Technologies juga menggunakan alat ini.  Selain itu, kami dapat mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul prosesor disassembler</a> kami sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk arsitektur mikroprosesor NIOS II</a> , yang meningkatkan kecepatan dan kenyamanan analisis kode. <br><br>  Hari ini saya akan menceritakan tentang sejarah proyek ini dan menunjukkan apa yang terjadi pada akhirnya. <a name="habracut"></a><br><br><h2>  Latar belakang </h2><br>  Semuanya dimulai pada tahun 2016, ketika kami harus mengembangkan modul prosesor kami sendiri untuk menganalisis firmware dalam satu tugas.  Pengembangan dilakukan dari awal pada manual <a href="">Panduan Referensi Prosesor Klasik Nios II</a> , yang saat itu paling relevan.  Secara total, pekerjaan ini memakan waktu sekitar dua minggu. <br><br>  Modul prosesor dikembangkan untuk versi IDA 6.9.  Untuk kecepatan, IDA Python dipilih.  Di tempat modul prosesor berada - subdirektori procs di dalam direktori instalasi IDA Pro - ada tiga modul Python: msp430, ebc, spu.  Di dalamnya, Anda dapat melihat bagaimana modul disusun dan bagaimana fungsionalitas pembongkaran dasar dapat diimplementasikan: <br><br><ul><li>  instruksi parsing dan operan, </li><li>  penyederhanaan dan tampilan mereka, </li><li>  membuat offset, referensi silang, serta kode dan data yang mereka rujuk </li><li>  pemrosesan saklar konstruksi, </li><li>  menangani manipulasi dengan variabel stack dan stack. </li></ul><br>  Kira-kira fungsi seperti itu diterapkan pada waktu itu.  Untungnya, alat ini berguna dalam proses mengerjakan tugas lain, di mana, setahun kemudian, alat itu secara aktif digunakan dan disempurnakan. <br><br>  Saya memutuskan untuk berbagi pengalaman membuat modul prosesor dengan komunitas di PHDays 8. Presentasi membangkitkan minat (laporan video <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterbitkan</a> di situs web PHDays), bahkan pencipta IDA Pro Ilfak Gilfanov hadir.  Salah satu pertanyaannya adalah apakah dukungan untuk IDA Pro versi 7. Diimplementasikan pada saat itu tidak ada, tetapi setelah kinerja saya berjanji untuk membuat rilis modul yang sesuai.  Di sinilah kesenangan dimulai. <br><br>  Sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual</a> terbaru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari Intel</a> , yang digunakan untuk memverifikasi dan memeriksa kesalahan.  Saya secara signifikan merevisi modul, menambahkan sejumlah fitur baru, termasuk menyelesaikan masalah-masalah yang tidak dapat dikalahkan sebelumnya.  Yah, tentu saja, saya menambahkan dukungan untuk versi 7 IDA Pro.  Inilah yang terjadi. <br><br><h2>  Model Perangkat Lunak NIOS II </h2><br>  NIOS II adalah prosesor perangkat lunak yang dikembangkan untuk FPGA Altera (sekarang bagian dari Intel).  Dari sudut pandang program, ia memiliki fitur berikut: urutan byte little endian, ruang alamat 32-bit, set instruksi 32-bit, yaitu, 4 byte, 32 umum dan 32 register tujuan khusus digunakan untuk menyandikan setiap perintah. <br><br><h2>  Pembongkaran dan referensi kode </h2><br>  Jadi, kami membuka file baru di IDA Pro, dengan firmware untuk prosesor NIOS II.  Setelah menginstal modul, kita akan melihatnya dalam daftar prosesor Pro IDA.  Pilihan prosesor ditunjukkan pada gambar. <br><br><img src="https://habrastorage.org/webt/9x/wd/ni/9xwdnil54uqjf3wru4nqcc0fkr8.png"><br><br>  Misalkan modul belum mengimplementasikan bahkan analisis dasar perintah.  Mengingat bahwa setiap perintah membutuhkan 4 byte, kita mengelompokkan byte menjadi empat, maka semuanya akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/be/v9/_j/bev9_jokezmrwfxgr5gtscagrma.png"><br><br>  Setelah menerapkan fungsionalitas dasar instruksi dan operasi decoding, menampilkannya di layar, dan menganalisis instruksi transfer kontrol, byte yang ditetapkan dari contoh di atas dikonversi ke kode berikut. <br><br><img src="https://habrastorage.org/webt/w6/zm/5c/w6zm5c7rzp0ee0qec2twmkzdnxe.png"><br><br>  Seperti dapat dilihat dari contoh, referensi silang juga dihasilkan dari perintah transfer kontrol (dalam hal ini, Anda dapat melihat lompatan bersyarat dan panggilan prosedur). <br><br>  Salah satu properti berguna yang dapat diimplementasikan dalam modul prosesor adalah komentar perintah.  Jika Anda menonaktifkan output nilai byte dan mengaktifkan output komentar, bagian kode yang sama sudah akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/gu/ia/u0/guiau0csjjbidgimzewinug4pvq.png"><br><br>  Di sini, jika Anda pertama kali menemukan kode assembler dari arsitektur baru untuk Anda, menggunakan komentar Anda dapat memahami apa yang terjadi.  Selanjutnya, contoh kode akan berada dalam bentuk yang sama - dengan komentar, agar tidak melihat manual NIOS II, tetapi untuk segera memahami apa yang terjadi di bagian kode, yang diberikan sebagai contoh. <br><br><h2>  Instruksi semu dan penyederhanaan perintah </h2><br>  Beberapa perintah NIOS II adalah instruksi palsu.  Tidak ada opcode yang terpisah untuk tim semacam itu, dan mereka sendiri dimodelkan sebagai kasus khusus dari tim lain.  Dalam proses pembongkaran, penyederhanaan instruksi dilakukan - penggantian kombinasi tertentu dengan instruksi semu.  Instruksi semu dalam NIOS II secara umum dapat dibagi menjadi empat jenis: <br><br><ul><li>  ketika salah satu sumber adalah nol (r0) dan dapat dihapus dari pertimbangan, </li><li>  ketika tim memiliki nilai negatif dan tim digantikan oleh yang sebaliknya, </li><li>  ketika kondisinya terbalik, </li><li>  ketika offset 32-bit dimasukkan dalam dua tim di bagian (yang termuda dan tertua) dan ini digantikan oleh satu perintah. </li></ul><br>  Dua tipe pertama diimplementasikan, karena mengganti kondisi tidak memberikan sesuatu yang istimewa, dan offset 32-bit memiliki lebih banyak pilihan daripada yang disajikan dalam manual. <br><br>  Misalnya, untuk tampilan pertama, perhatikan kodenya. <br><br><img src="https://habrastorage.org/webt/ix/if/kt/ixifktzau98plchui3ypjf0qn6c.png"><br><br>  Terlihat bahwa penggunaan daftar nol dalam perhitungan sering ditemukan di sini.  Jika Anda memperhatikan contoh ini dengan seksama, Anda akan melihat bahwa semua perintah kecuali transfer kontrol adalah opsi untuk hanya memasukkan nilai ke register spesifik. <br><br>  Setelah mengimplementasikan pemrosesan instruksi semu, kami mendapatkan bagian kode yang sama, tetapi sekarang tampilannya lebih mudah dibaca, dan alih-alih variasi dari atau dan menambahkan perintah, kami mendapatkan variasi dari perintah mov. <br><br><img src="https://habrastorage.org/webt/ka/4j/_q/ka4j_qwz2elzmsmccfrewbtn9cc.png"><br><br><h2>  Variabel tumpukan </h2><br>  Arsitektur NIOS II mendukung stack, dan di samping stack pointer sp, ada juga pointer ke frame stack fp.  Pertimbangkan contoh prosedur kecil yang menggunakan tumpukan. <br><br><img src="https://habrastorage.org/webt/82/_o/1v/82_o1v_n-ojrlgtveqtfjln2vve.png"><br><br>  Jelas, ruang disediakan untuk variabel lokal di stack.  Dapat diasumsikan bahwa register ra disimpan dalam variabel stack dan kemudian dikembalikan darinya. <br><br>  Setelah menambahkan fungsionalitas ke modul yang melacak perubahan dalam penunjuk tumpukan dan membuat variabel tumpukan, contoh yang sama akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/zg/pk/fx/zgpkfxblezz4cp78gfqswegbjza.png"><br><br>  Sekarang kode terlihat sedikit lebih jelas, dan Anda sudah dapat memberi nama variabel stack dan menguraikan tujuannya dengan mengikuti referensi silang.  Fungsi dalam contoh ini adalah tipe __fastcall dan argumennya di register r4 dan r5 didorong ke stack untuk memanggil subprocedure yang bertipe _stdcall. <br><br><h2>  Angka dan offset 32-bit </h2><br>  Keunikan NIOS II adalah bahwa dalam satu operasi, yaitu, ketika menjalankan satu perintah, dimungkinkan untuk mendaftarkan paling banyak nilai langsung ukuran 2 byte (16 bit).  Di sisi lain, register prosesor dan ruang alamat adalah 32-bit, yaitu, untuk pengalamatan, 4 byte harus dimasukkan ke dalam register. <br><br>  Untuk mengatasi masalah ini, perpindahan dua bagian digunakan.  Mekanisme serupa digunakan dalam prosesor di PowerPC: offset terdiri dari dua bagian, yang tertua dan yang termuda, dan dimasukkan ke dalam register dengan dua perintah.  Di PowerPC, ini adalah sebagai berikut. <br><br><img src="https://habrastorage.org/webt/n8/qm/5z/n8qm5zedw9ffnckmjclzmhfwkh8.png"><br><br>  Dalam pendekatan ini, cross-link dibentuk dari kedua tim, meskipun pada kenyataannya, alamat dikonfigurasi dalam perintah kedua.  Ini terkadang bisa menjadi gangguan saat menghitung jumlah referensi silang. <br><br>  Properti offset untuk bagian yang lebih lama menggunakan tipe HIGHA16 yang tidak standar, terkadang tipe HIGH16 digunakan, untuk bagian yang lebih muda - LOW16. <br><br><img src="https://habrastorage.org/webt/l-/u3/6r/l-u36riq53_ejmry2mwdv7qewp4.png"><br><br>  Tidak ada yang rumit dalam perhitungan angka dua bagian 32-bit.  Kesulitan muncul dalam pembentukan operan sebagai offset untuk dua tim yang terpisah.  Semua pemrosesan ini jatuh pada modul prosesor.  Tidak ada contoh bagaimana mengimplementasikan ini (terutama dengan Python) di IDA SDK. <br><br>  Dalam laporan PHDays, bias berdiri sebagai masalah yang belum terselesaikan.  Untuk mengatasi masalah, kami menipu: 32-bit offset hanya dari bagian termuda - di pangkalan.  Basis dihitung sebagai bagian tertua, bergeser ke kiri sebanyak 16 bit. <br><br><img src="https://habrastorage.org/webt/ip/lc/60/iplc60jwuylhovnugr8qgyxorbq.png"><br><br>  Dengan pendekatan ini, referensi silang dibentuk hanya dengan perintah untuk masuk ke bagian bawah offset 32-bit. <br><br>  Basis terlihat di properti offset dan properti ditandai untuk menganggapnya sebagai angka, sehingga sejumlah besar referensi silang ke alamat itu sendiri tidak terbentuk, yang kami ambil sebagai basis. <br><br><img src="https://habrastorage.org/webt/_3/ui/wy/_3uiwyr9jt0lpipfsounaz07q3c.png"><br><br>  Dalam kode untuk NIOS II, mekanisme berikut ditemukan untuk memasukkan angka 32-bit ke dalam register.  Pertama, bagian tertua dari offset dimasukkan ke dalam register dengan perintah movhi.  Kemudian bagian yang lebih muda bergabung.  Ini dapat dilakukan dengan tiga cara (dengan perintah): menambahkan addi, mengurangi subi, logika OR ori. <br><br>  Sebagai contoh, pada bagian kode berikutnya, register diatur ke angka 32-bit, yang kemudian dimasukkan ke register - argumen sebelum memanggil fungsi. <br><br><img src="https://habrastorage.org/webt/rs/4l/ms/rs4lmsgotpjsjrb92qh6gkk9s-y.png"><br><br>  Setelah menambahkan perhitungan offset, kami mendapatkan representasi berikut dari blok kode ini. <br><br><img src="https://habrastorage.org/webt/sg/3c/i_/sg3ci__0-wvfkj-5j40xuemubva.png"><br><br>  32-bit offset yang dihasilkan ditampilkan di sebelah perintah untuk masuk ke bagian bawahnya.  Contoh ini cukup ilustratif, dan kita bahkan dapat dengan mudah menghitung semua angka 32-bit dalam pikiran hanya dengan menambahkan bagian minor dan tertinggi.  Dilihat dari nilai-nilai, mereka kemungkinan besar tidak bias. <br><br>  Pertimbangkan kasus ketika pengurangan digunakan ketika memasuki bagian yang lebih muda.  Dalam contoh ini, tidak akan mungkin untuk menentukan angka 32-bit terakhir (offset) saat bepergian. <br><br><img src="https://habrastorage.org/webt/i-/8x/yt/i-8xyto-q5iqeiffz3hua-d29ew.png"><br><br>  Setelah menerapkan perhitungan angka 32-bit, kami mendapatkan formulir berikut. <br><br><img src="https://habrastorage.org/webt/tf/da/8-/tfda8-uw3xkthiqqe930jut8ovs.png"><br><br>  Di sini kita melihat bahwa sekarang, jika alamat berada di ruang alamat, offset terbentuk di atasnya, dan nilai yang terbentuk sebagai akibat dari koneksi bagian minor dan senior tidak lagi ditampilkan di dekatnya.  Di sini mereka mendapat offset dengan garis "10/22/08".  Agar sisa offset menunjuk ke alamat yang valid, mari tambah sedikit segmennya. <br><br><img src="https://habrastorage.org/webt/0i/qq/fh/0iqqfhcomre0yd3siixym3vt0o8.png"><br><br>  Setelah meningkatkan segmen, kami mendapatkan bahwa sekarang semua angka 32-bit yang dihitung adalah offset dan menunjukkan alamat yang valid. <br><br>  Disebutkan di atas bahwa ada opsi lain untuk menghitung offset ketika perintah ATAU logis digunakan.  Berikut adalah contoh kode di mana dua offset dihitung dengan cara ini. <br><br><img src="https://habrastorage.org/webt/xr/or/am/xroramzy4_lj_g3po7yxo-m0sxy.png"><br><br>  Yang dievaluasi dalam register r8 kemudian didorong ke stack. <br><br>  Setelah konversi, dapat dilihat bahwa dalam kasus ini register dikonfigurasikan ke alamat awal prosedur, yaitu alamat prosedur didorong ke stack. <br><br><img src="https://habrastorage.org/webt/wr/au/qm/wrauqmfpotzlhjdiz4_i8mnghri.png"><br><br><h2>  Membaca dan menulis relatif terhadap basis </h2><br>  Sebelum itu, kami mempertimbangkan kasus-kasus ketika angka 32-bit yang dimasukkan menggunakan dua perintah bisa berupa angka dan juga offset.  Dalam contoh berikut, pangkalan dimasukkan di bagian atas register, kemudian membaca atau menulis terjadi relatif terhadap itu. <br><br><img src="https://habrastorage.org/webt/ho/2v/ve/ho2vvexmp7367xll5prt5xwpc8m.png"><br><br>  Setelah memproses situasi seperti itu, kami mendapatkan offset ke variabel dari perintah baca dan tulis sendiri.  Selain itu, tergantung pada dimensi operasi, ukuran variabel itu sendiri diatur. <br><br><img src="https://habrastorage.org/webt/cl/pi/g-/clpig-mgt5xtsshbvp67wh9rrdg.png"><br><br><h2>  Ganti konstruksi </h2><br>  Konstruk saklar yang ditemukan dalam file biner dapat memfasilitasi analisis.  Misalnya, dengan jumlah kasus pemilihan di dalam switch switch, Anda dapat melokalkan switch yang bertanggung jawab untuk memproses protokol atau sistem perintah tertentu.  Oleh karena itu, tugas muncul untuk mengenali sakelar itu sendiri dan parameternya.  Pertimbangkan bagian kode berikut. <br><br><img src="https://habrastorage.org/webt/g9/t7/7u/g9t77ugtkercggcjphfq9xfam_0.png"><br><br>  Utas eksekusi berhenti pada transisi register jmp r2.  Selanjutnya ada blok kode yang ada tautannya dari data, dan di akhir setiap blok ada lompatan ke label yang sama.  Jelas, ini adalah saklar konstruksi dan blok-blok individual ini menangani kasus-kasus tertentu darinya.  Di atas Anda juga dapat melihat pemeriksaan jumlah kasus dan lompatan default. <br><br>  Setelah menambahkan pemrosesan switch, kode ini akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/rm/qj/hw/rmqjhwhrknmc_cycqu5d57kjpmq.png"><br><br>  Sekarang lompatan itu sendiri ditunjukkan, alamat meja dengan offset, jumlah kasing, serta setiap kasing dengan nomor yang sesuai. <br><br>  Tabel itu sendiri dengan offset ke opsi adalah sebagai berikut.  Untuk menghemat ruang, lima elemen pertama diberikan. <br><br><img src="https://habrastorage.org/webt/9b/ke/x9/9bkex9oxlk_vv4nrpdya3nckv3m.png"><br><br>  Bahkan, pemrosesan switch terdiri dari kembali melalui kode dan mencari semua komponennya.  Yaitu, beberapa skema organisasi sakelar dijelaskan.  Terkadang mungkin ada pengecualian dalam skema.  Ini mungkin menjadi alasan untuk kasus ketika sakelar yang tampaknya jernih tidak dikenali dalam modul prosesor yang ada.  Ternyata saklar yang sebenarnya tidak termasuk dalam skema yang didefinisikan di dalam modul prosesor.  Masih ada opsi yang memungkinkan ketika sirkuit tampaknya ada, tetapi ada tim lain di dalamnya yang tidak terlibat dalam sirkuit, atau tim utama disusun ulang, atau dipecah oleh transisi. <br><br>  Modul prosesor NIOS II mengenali sakelar dengan instruksi "asing" di antara perintah-perintah utama, serta dengan tempat-tempat yang disusun kembali dari perintah-perintah utama dan dengan pemutusan sirkuit.  Jalur balik digunakan di sepanjang jalur eksekusi, dengan mempertimbangkan kemungkinan transisi yang memutus sirkuit, dengan pemasangan variabel internal yang memberi sinyal berbagai keadaan pengenal.  Hasilnya, sekitar 10 opsi organisasi sakelar berbeda yang ditemukan dalam firmware dikenali. <br><br><h2>  Instruksi kustom </h2><br>  Ada fitur yang menarik dalam arsitektur NIOS II - instruksi khusus.  Ini memberikan akses ke 256 instruksi yang ditentukan pengguna yang dimungkinkan dalam arsitektur NIOS II.  Dalam pekerjaannya, selain register tujuan umum, instruksi khusus dapat mengakses satu set khusus 32 register kustom.  Setelah menerapkan logika untuk parsing perintah kustom, kami mendapatkan formulir berikut. <br><br><img src="https://habrastorage.org/webt/ws/8d/zo/ws8dzozz7aext7buc0g3re8kwno.png"><br><br>  Anda mungkin memperhatikan bahwa dua instruksi terakhir memiliki nomor instruksi yang sama dan tampaknya melakukan tindakan yang sama. <br><br>  Menurut instruksi khusus, ada <a href="">manual terpisah</a> .  Menurutnya, salah satu opsi paling komprehensif dan terkini untuk set instruksi kustom adalah set instruksi Komponen 2 Floating Point Hardware (FPH2) NIOS II untuk bekerja dengan floating point.  Setelah mengimplementasikan parsing dari perintah FPH2, contohnya akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/ex/-q/1g/ex-q1g9sszau_hhllau3_xrvgdw.png"><br><br>  Dari mnemonik dari dua tim terakhir, kami memastikan bahwa mereka benar-benar melakukan tindakan yang sama - perintah fadds. <br><br><h2>  Transisi berdasarkan nilai register </h2><br>  Dalam firmware yang sedang diselidiki, suatu situasi sering ditemui ketika lompatan dilakukan sesuai dengan nilai register, di mana offset 32-bit, yang menentukan tempat lompatan, dimasukkan sebelumnya. <br><br>  Pertimbangkan sepotong kode. <br><br><img src="https://habrastorage.org/webt/sj/ej/ys/sjejysq65hywye8w6usdbshkc60.png"><br><br>  Di baris terakhir ada lompatan dalam nilai register, sementara itu jelas bahwa sebelum alamat prosedur dimasukkan dalam register, yang dimulai pada baris pertama dari contoh.  Dalam hal ini, jelas bahwa lompatan dibuat pada awalnya. <br><br>  Setelah menambahkan fungsi pengenalan lompatan, formulir berikut diperoleh. <br><br><img src="https://habrastorage.org/webt/ov/tm/j2/ovtmj2lcb_8lrx8qmxvekuul0lw.png"><br><br>  Di sebelah perintah jmp r8, alamat tempat lompatan terjadi jika dimungkinkan untuk dihitung ditampilkan.  Referensi silang juga dibentuk antara tim dan alamat tempat lompatan berlangsung.  Dalam hal ini, tautannya terlihat di baris pertama, lompatan itu sendiri dilakukan dari baris terakhir. <br><br><h2>  Nilai register Gp (global pointer), simpan dan muat </h2><br>  Adalah umum untuk menggunakan penunjuk global yang dikonfigurasikan ke beberapa alamat, dan variabel dialamatkan relatif terhadapnya.  NIOS II menggunakan register gp (global pointer) untuk menyimpan global pointer.  Pada titik tertentu, sebagai aturan, dalam prosedur inisialisasi firmware, nilai alamat dimasukkan dalam register gp.  Modul prosesor menangani situasi ini;  Untuk menggambarkan hal ini, berikut ini adalah contoh kode dan jendela output IDA Pro ketika pesan debug diaktifkan di modul prosesor. <br><br>  Dalam contoh ini, modul prosesor menemukan dan menghitung nilai register gp di database baru.  Saat menutup basis data idb, nilai gp disimpan dalam basis data. <br><br><img src="https://habrastorage.org/webt/cx/ll/hk/cxllhko-hugm77k68idqqam4wzm.png"><br><br>  Saat memuat basis data idb yang ada dan jika nilai gp telah ditemukan, itu diambil dari basis data, seperti yang ditunjukkan dalam pesan debug dalam contoh berikut. <br><br><img src="https://habrastorage.org/webt/-y/z7/1u/-yz71u_odhytnmobj0dlfb73v-k.png"><br><br><h2>  Membaca dan menulis tentang gp </h2><br>  Operasi umum membaca dan menulis dengan offset relatif terhadap register gp.  Sebagai contoh, dalam contoh berikut, tiga pembacaan dan satu catatan dari jenis ini dilakukan. <br><br><img src="https://habrastorage.org/webt/6b/0l/-b/6b0l-bqxv1qiuw5nvh3i08vvstk.png"><br><br>  Karena kita sudah mendapatkan nilai dari alamat yang disimpan dalam register gp, kita dapat mengatasi jenis membaca dan menulis ini. <br><br>  Setelah menambahkan pemrosesan untuk situasi membaca dan menulis relatif terhadap register gp, kami mendapatkan gambar yang lebih nyaman. <br><br><img src="https://habrastorage.org/webt/wx/st/c1/wxstc1auiw0z0gvfzwmcooocooq.png"><br><br>  Di sini Anda dapat melihat variabel mana yang sedang diakses, melacak penggunaannya dan mengidentifikasi tujuannya. <br><br><h2>  Mengatasi relatif ke gp </h2><br>  Ada lagi penggunaan register gp untuk mengatasi variabel. <br><br><img src="https://habrastorage.org/webt/ng/nn/oc/ngnnocz7scbya0x41l7gagf4bew.png"><br><br>  Sebagai contoh, di sini kita melihat bahwa register dikonfigurasi relatif terhadap register gp ke beberapa variabel atau area data. <br><br>  Setelah menambahkan fungsionalitas yang mengenali situasi seperti itu, mengonversi ke offset dan menambahkan referensi silang, kami mendapatkan formulir berikut. <br><br><img src="https://habrastorage.org/webt/sm/0d/nd/sm0dndgvrmn2xwivnfux3ol-t1e.png"><br><br>  Di sini Anda sudah dapat melihat area mana yang relatif terhadap register gp yang dikonfigurasi, dan semakin jelas apa yang terjadi. <br><br><h2>  Mengatasi relatif ke sp </h2><br>  Demikian pula, dalam contoh berikut, register disetel ke beberapa area memori, kali ini relatif terhadap register sp - pointer ke stack. <br><br><img src="https://habrastorage.org/webt/p1/nv/k7/p1nvk7gox_d3cwi1gof80k_oizq.png"><br><br>  Jelas, register disetel ke beberapa variabel lokal.  Situasi seperti itu - pengaturan argumen ke buffer lokal sebelum panggilan prosedur - cukup umum. <br><br>  Setelah menambahkan pemrosesan (mengonversi nilai langsung ke offset), kami mendapatkan formulir berikut. <br><br><img src="https://habrastorage.org/webt/mg/8s/ps/mg8spswm9tq-_zjj-80s0s6lbnk.png"><br><br>  Sekarang menjadi jelas bahwa setelah pemanggilan prosedur, nilai-nilai diambil dari variabel-variabel yang alamatnya dilewati sebagai parameter sebelum pemanggilan fungsi. <br><br><h2>  Referensi silang dari kode ke bidang struktur </h2><br>  Mendefinisikan struktur dan menggunakannya dalam IDA Pro dapat memfasilitasi analisis kode. <br><br><img src="https://habrastorage.org/webt/l6/4u/8u/l64u8ubhx9-ypg1vo914_fa8vta.png"><br><br>  Melihat bagian kode ini, kita dapat memahami bahwa field__range bertambah dan, mungkin, merupakan counter dari terjadinya suatu peristiwa.  Jika bidang membaca dan menulis dipisahkan dalam kode pada jarak yang sangat jauh, referensi silang dapat membantu. <br><br>  Pertimbangkan struktur itu sendiri. <br><br><img src="https://habrastorage.org/webt/px/zf/lt/pxzflte9x7kmxfrnipa_yjerstc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun akses ke bidang struktur adalah, seperti yang kita lihat, tidak ada referensi silang dari kode ke elemen struktur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah situasi seperti itu diproses, untuk kasus kami semuanya akan terlihat sebagai berikut. </font></font><br><br><img src="https://habrastorage.org/webt/k_/7t/zu/k_7tzupju7tyyje9r-i6ed6ra08.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang ada referensi silang ke bidang struktur dari tim tertentu yang bekerja dengan bidang ini. </font><font style="vertical-align: inherit;">Referensi silang maju dan mundur dibuat, dan Anda dapat melacak dengan prosedur yang berbeda di mana nilai-nilai bidang struktur dibaca dan di mana mereka dimasukkan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perbedaan antara manual dan kenyataan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam manual, ketika mendekodekan beberapa perintah, bit tertentu harus mengambil nilai yang didefinisikan dengan ketat. </font><font style="vertical-align: inherit;">Sebagai contoh, untuk perintah kembali dari pengecualian eret, bit 22-26 harus 0x1E. </font></font><br><br><img src="https://habrastorage.org/webt/6r/o4/ys/6ro4ys-mrzuck_-stdnjctilwq8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah contoh dari perintah ini dari satu firmware. </font></font><br><br><img src="https://habrastorage.org/webt/te/lv/at/telvatwfv4tmdjpaurhickredpo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuka firmware lain di tempat dengan konteks yang sama, kami menghadapi situasi yang berbeda. </font></font><br><br><img src="https://habrastorage.org/webt/ss/p3/qg/ssp3qgrbyu4stqyfht6mmzitgmi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytes ini tidak secara otomatis dikonversi ke perintah, meskipun ada pemrosesan semua perintah. </font><font style="vertical-align: inherit;">Dilihat oleh lingkungan, dan bahkan alamat yang sama, ini harus tim yang sama. </font><font style="vertical-align: inherit;">Mari kita perhatikan dengan cermat byte. </font><font style="vertical-align: inherit;">Ini adalah perintah eret yang sama, dengan pengecualian bahwa bit 22-26 tidak sama dengan 0x1E, tetapi sama dengan nol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita harus sedikit memperbaiki analisis dari perintah ini. </font><font style="vertical-align: inherit;">Sekarang tidak cukup sesuai dengan manual, tetapi sesuai dengan kenyataan.</font></font><br><br><img src="https://habrastorage.org/webt/as/fn/nl/asfnnlau91zf6y1aan-f3l__wz0.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dukungan IDA 7 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dimulai dengan IDA 7.0, API yang disediakan oleh Python IDA untuk skrip biasa telah banyak berubah. Sedangkan untuk modul prosesor, perubahannya sangat besar. Meskipun demikian, modul prosesor NIOS II mampu dibuat ulang untuk versi 7, dan berhasil bekerja di dalamnya. </font></font><br><br><img src="https://habrastorage.org/webt/-w/zh/z_/-wzhz_lzuq_ad226tgx_0abl3ke.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya momen yang tidak dapat dipahami: ketika memuat file biner baru di bawah NIOS II di IDA 7, analisis otomatis awal yang ada di IDA 6.9 tidak terjadi.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain fungsionalitas pembongkaran dasar, contoh-contohnya ada di SDK, modul prosesor mengimplementasikan banyak fitur berbeda yang memudahkan pekerjaan kode explorer. </font><font style="vertical-align: inherit;">Jelas bahwa semua ini dapat dilakukan secara manual, tetapi, misalnya, ketika ada ribuan dan puluhan ribu offset dari berbagai jenis pada file biner dengan firmware beberapa megabyte, mengapa menghabiskan waktu untuk ini? </font><font style="vertical-align: inherit;">Biarkan modul prosesor melakukan ini untuk kita. </font><font style="vertical-align: inherit;">Lagi pula, bagaimana fitur menyenangkan dari navigasi cepat melalui kode yang dipelajari menggunakan referensi silang! </font><font style="vertical-align: inherit;">Ini menjadikan IDA alat yang nyaman dan menyenangkan seperti yang kita ketahui. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diposting oleh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anton Dorfman, Positive Technologies</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424085/">https://habr.com/ru/post/id424085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424071/index.html">Teori kebahagiaan. Termodinamika ketidaksetaraan kelas</a></li>
<li><a href="../id424073/index.html">Eksekusi kode jauh di Microsoft JET Database Engine</a></li>
<li><a href="../id424077/index.html">Perancis menuntut membuat "hak untuk dilupakan" global - apa yang bisa memengaruhi</a></li>
<li><a href="../id424081/index.html">RESS - Arsitektur Baru untuk Aplikasi Seluler</a></li>
<li><a href="../id424083/index.html">Layanan untuk perdagangan di bursa Robinhood dituduh menjual data pada aplikasi pengguna ke pedagang frekuensi tinggi</a></li>
<li><a href="../id424087/index.html">Perangkat Android yang dikendalikan Bluetooth yang dikontrol Arduino - siklus penuh (bagian 1)</a></li>
<li><a href="../id424089/index.html">Konferensi itu jahat. Atau bagus?</a></li>
<li><a href="../id424091/index.html">WiX.Py: kami mengumpulkan paket MSI "dalam tiga baris"</a></li>
<li><a href="../id424093/index.html">Dari radio antik hingga pengeras suara DIY: 12 saluran YouTube untuk perangkat akustik</a></li>
<li><a href="../id424099/index.html">Menentukan kematangan semangka menggunakan Keras: siklus penuh, dari ide hingga program di Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>