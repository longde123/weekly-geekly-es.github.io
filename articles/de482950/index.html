<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèæ üî© üêò Java: Dinge, die einem erfahrenen Entwickler neugierig erscheinen m√∂gen ‚ÜîÔ∏è ‚ùáÔ∏è üåë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gute Tageszeit! 

 Der Artikel wurde im Anschluss an die Ver√∂ffentlichung ‚ÄûDinge, die Sie [vielleicht] nicht √ºber Java wussten‚Äú von einem anderen Auto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java: Dinge, die einem erfahrenen Entwickler neugierig erscheinen m√∂gen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482950/"> Gute Tageszeit! <br><br>  Der Artikel wurde im Anschluss an die Ver√∂ffentlichung <a href="https://habr.com/ru/post/482364">‚ÄûDinge, die Sie [vielleicht] nicht √ºber Java wussten‚Äú von</a> einem anderen Autor verfasst, den ich als ‚Äûf√ºr Anf√§nger‚Äú einstufen w√ºrde.  Als ich es las und kommentierte, stellte ich fest, dass es eine Reihe interessanter Dinge gibt, die ich gelernt habe und die ich bereits seit mehr als einem Jahr in Java programmiere.  Vielleicht scheinen diese Dinge jemand anderem neugierig zu sein. <br><br><a name="habracut"></a>  Die Tatsachen, die aus meiner Sicht f√ºr Anf√§nger n√ºtzlich sein k√∂nnten, habe ich in den "Spoilern" beseitigt.  Einige Dinge k√∂nnten f√ºr erfahrene noch interessant sein.  Zum Beispiel wusste ich selbst erst zum Zeitpunkt des Schreibens, dass Boolean.hashCode (true) == 1231 und Boolean.hashCode (false) == 1237. <br><br><div class="spoiler">  <b class="spoiler_title">F√ºr Anf√§nger</b> <div class="spoiler_text"><ul><li>  Boolean.hashCode (true) == 1231 </li><li>  Boolean.hashCode (false) == 1237 </li><li>  Float.hashCode (Wert) == Float.floatToIntBits (Wert) </li><li>  Double.hashCode (value) - xor des ersten und zweiten 32-Bit-Halbworts Double.doubleToLongBits (value) </li></ul></div></div><br><h2>  Object.hashCode () ist nicht l√§nger die Adresse eines Objekts im Speicher </h2><br>  Haftungsausschluss: Dies ist ein JVM-Detail von Oracle (HotSpot). <br><br><div class="spoiler">  <b class="spoiler_title">Es war einmal so.</b> <div class="spoiler_text">  Aus jdk1.2.1 / docs / api / java / lang / Object.html # hashCode (): <blockquote>  Die von der Klasse Object definierte hashCode-Methode gibt, soweit dies sinnvoll ist, unterschiedliche Ganzzahlen f√ºr unterschiedliche Objekte zur√ºck.  (Dies wird normalerweise durch Konvertieren der internen Adresse des Objekts in eine Ganzzahl implementiert. Diese Implementierungstechnik wird jedoch von der Programmiersprache JavaTM nicht ben√∂tigt.) </blockquote></div></div><br>  Dann lehnten sie es ab.  Dies ist, was <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Object.html" rel="nofollow">Javadoc f√ºr JDK 12</a> sagt. <br><br>  <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko</a> schlug vor, dass altes Verhalten mit -XX wiederhergestellt werden kann: hashCode = 4.  Und die Verhaltens√§nderung selbst war fast von Java 1.2-Version. <br><br><h2>  Integer.valueOf (15) == Integer.valueOf (15);  Integer.valueOf (128)! = Integer.valueOf (128) </h2><br>  Haftungsausschluss: Dies ist ein Teil von <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html" rel="nofollow">jls</a> . <br><br>  Es ist klar, dass beim Vergleich zweier Wrapper mit dem Operator == (! =) Kein Autoboxing auftritt.  Im Allgemeinen ist es die erste Gleichheit, die verwirrt.  Fakt ist, dass f√ºr Integer-Werte i: -129 &lt;i &lt;128 Integer-Wrapper-Objekte zwischengespeichert werden.  Daher erstellt Integer.valueOf (i) f√ºr i aus diesem Bereich nicht jedes Mal ein neues Objekt, sondern gibt ein bereits erstelltes zur√ºck.  F√ºr i, die nicht in diesen Bereich fallen, erstellt Integer.valueOf (i) immer ein neues Objekt.  Wenn Sie nicht genau √ºberwachen, was genau und wie genau es verglichen wird, k√∂nnen Sie Code schreiben, der zu funktionieren scheint und sogar von Tests abgedeckt wird, aber gleichzeitig einen solchen "Rechen" enth√§lt. <br><br>  In jvm von Oracle (HotSpot) kann die obere Grenze des Cachings √ºber die Eigenschaft <a href="" rel="nofollow">"java.lang.Integer.IntegerCache.high"</a> ge√§ndert werden. <br><br><h2>  In einigen F√§llen werden die Werte von primitiven oder endg√ºltigen statischen Feldern einer anderen Klasse zur Kompilierungszeit aufgel√∂st </h2><br>  Das klingt verwirrend und die Aussage ist etwas lang.  Die Bedeutung ist dies.  Wenn wir eine Klasse haben, die Konstanten primitiver Typen oder Zeichenfolgen als endg√ºltige statische Felder mit sofortiger Initialisierung definiert, <br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_1 = <span class="hljs-string"><span class="hljs-string">"case_1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_2 = <span class="hljs-string"><span class="hljs-string">"case_2"</span></span>; }</code> </pre> <br>  wenn in anderen Klassen verwendet, <pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TheClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... public static int getCaseNumber(String caseName) { switch (caseName) { case AnotherClass.CASE_1: return 1; case AnotherClass.CASE_2: return 2; default: throw new IllegalArgumentException("value of the argument caseName does not belong to the allowed value set"); } } }</span></span></code> </pre><br>  Die Werte dieser Konstanten ("case_1", "case_2") werden zur Kompilierzeit aufgel√∂st.  Und sie werden als Werte und nicht als Links in den Code eingef√ºgt.  Das hei√üt, wenn wir solche Konstanten aus der Bibliothek verwenden und dann eine neue Version der Bibliothek erhalten, in der sich die Werte der Konstanten ge√§ndert haben, sollten wir das Projekt neu kompilieren.  Andernfalls werden m√∂glicherweise weiterhin alte Konstantenwerte im Code verwendet. <br><br>  Dieses Verhalten wird an allen Stellen beobachtet, an denen konstante Ausdr√ºcke verwendet werden m√ºssen (z. B. switch / case) oder der Compiler Ausdr√ºcke in Konstanten konvertieren darf, und er kann dies tun. <br><br>  Diese Felder k√∂nnen nicht in konstanten Ausdr√ºcken verwendet werden, sobald die sofortige Initialisierung durch √úbertragen der Initialisierung in den statischen Block entfernt wird. <br><br><div class="spoiler">  <b class="spoiler_title">F√ºr Anf√§nger</b> <div class="spoiler_text"><h2>  Unter bestimmten Umst√§nden wird der Garbage Collector m√∂glicherweise nie ausgef√ºhrt. </h2><br>  Infolgedessen wird kein finalize () gestartet.  Aus diesem Grund sollten Sie keinen Code schreiben, der auf der Tatsache beruht, dass finalize () immer funktioniert.  Ja, und wenn das Objekt vor dem Ende des Programms in den M√ºll gelangt ist, wird es h√∂chstwahrscheinlich nicht vom Sammler eingesammelt. <br><br><h2>  Die finalize () -Methode f√ºr ein bestimmtes Objekt kann nur einmal aufgerufen werden. </h2><br>  In finalize () k√∂nnen wir das Objekt wieder sichtbar machen und der Garbage Collector wird es dieses Mal nicht "entfernen".  Wenn dieses Objekt wieder in den M√ºll f√§llt, wird es "kompiliert", ohne finalize () aufzurufen.  Wenn in finalize () eine Ausnahme ausgel√∂st wird und das Objekt f√ºr niemanden sichtbar ist, wird es ‚Äûzusammengesetzt‚Äú.  Finalize () wird nicht erneut aufgerufen. <br><br><h2>  Der Stream, in dem finalize () aufgerufen wird, ist nicht im Voraus bekannt </h2><br>  Es wird nur garantiert, dass dieser Thread frei von Sperren ist, die vom Hauptprogramm angezeigt werden. <br><br><h2>  Das Vorhandensein einer √ºberschriebenen finalize () -Methode f√ºr Objekte verlangsamt den Garbage Collection-Prozess </h2><br>  Was auf der Oberfl√§che liegt, ist die Notwendigkeit, die Barrierefreiheit von Objekten zu √ºberpr√ºfen - einmal vor dem Aufruf von finalize (), einmal in einer der folgenden Garbage Collection-L√§ufe. <br><br><h2>  Es ist wirklich schwer, Deadlocks beim Finalisieren zu bek√§mpfen () </h2><br>  In nicht-trivial finalize () k√∂nnen Sperren erforderlich sein, die angesichts der oben beschriebenen Besonderheiten nur sehr schwer zu debuggen sind. <br><br><h2>  Object.finalize () seit Version 9 von Java ist als veraltet markiert! </h2><br>  Was angesichts der oben beschriebenen Besonderheiten nicht √ºberraschend ist. </div></div><br><h2>  klassische Lazy-Singleton-Initialisierung: Doppelte Sperrung erforderlich </h2><br>  Zu diesem Thema gibt es ein Missverst√§ndnis, dass der folgende Ansatz (Double-Check-Idiom), der sehr logisch aussieht, immer funktioniert: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// read 1, check 1 synchronized (this) { if (instance == null) { // read 2, check 2 instance = new Singleton(); } } } return instance; // read 3 } }</span></span></code> </pre><br>  Wir pr√ºfen, ob das Objekt erstellt wurde (lesen Sie 1, √ºberpr√ºfen Sie 1).  Wenn ja, dann senden Sie es zur√ºck.  Wenn nicht, setzen Sie die Sperre, stellen Sie sicher, dass das Objekt nicht erstellt wurde, erstellen Sie das Objekt (die Sperre wird entfernt) und geben Sie das Objekt zur√ºck. <br><br>  Der Ansatz funktioniert aus den folgenden Gr√ºnden nicht.  <s>(read 1, check 1) und (read 3) sind nicht synchron.</s>  <s>Gem√§√ü dem Konzept des Java-Speichermodells sind √Ñnderungen, die in einem anderen Thread vorgenommen wurden, f√ºr unseren Thread m√∂glicherweise erst nach der Synchronisierung sichtbar.</s>  Danke <a href="https://habr.com/ru/users/mk2/" class="user_link">mk2</a> f√ºr den Kommentar, hier ist die korrekte Beschreibung des Problems: <br><blockquote>  Ja, read1 und read3 sind nicht synchronisiert, aber das Problem liegt nicht in einem anderen Thread.  Und die Tatsache, dass nicht synchronisierte Ablesungen neu angeordnet werden k√∂nnen, d.h.  read1! = null, aber read3 == null.  Gleichzeitig k√∂nnen wir aufgrund von "instance = new Singleton ();" einen Verweis auf das Objekt erhalten, bevor es vollst√§ndig erstellt wurde, und dies ist wirklich ein Synchronisationsproblem mit einem anderen Thread, aber nicht read1 und read3, sondern read3 und access Mitglieder zu Instanz. </blockquote>  Es wird entweder durch Hinzuf√ºgen einer Synchronisation w√§hrend des Lesens oder durch Markieren der Variable, in der sich die Verkn√ºpfung zum Singleton befindet, als fl√ºchtig behandelt.  (Die L√∂sung mit Volatile funktioniert nur mit Java 5+. Davor hatte Java in dieser Situation ein Speichermodell mit Unsicherheit.) Hier ist eine funktionierende Version (mit zus√§tzlicher Optimierung - die lokale Variable "res" wurde hinzugef√ºgt, um die Anzahl der Lesevorg√§nge aus dem volatile-Feld zu verringern). <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SafeLocalDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Singleton res = instance; <span class="hljs-comment"><span class="hljs-comment">// read 1 if (res == null) { // check 1 synchronized (this) { res = instance; // read 2 if (res == null) { // check 2 res = new Singleton(); instance = res; } } } return res; } }</span></span></code> </pre><br>  Der Code stammt <a href="https://shipilev.net/blog/2014/safe-public-construction/" rel="nofollow">von hier</a> aus der Site von Alexei Shipilev.  Weitere Details zu diesem Problem finden Sie darauf. <br><br><h2>  "Initialization-on-Demand Holder Idiom" - eine sehr sch√∂ne "faule" Initialisierung von Singleton </h2><br>  Java initialisiert Klassen (Klassenobjekte) nur nach Bedarf und nat√ºrlich nur einmal.  Und das k√∂nnen Sie nutzen!  Der Initialisierungs-On-Demand-Inhaber-Idiom-Mechanismus macht genau das.  (Der Code ist <a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom" rel="nofollow">von hier</a> .) <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Something</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Something INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Something(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Something </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LazyHolder.INSTANCE; } }</code> </pre><br>  Die LazyHolder-Klasse wird nur beim ersten Aufruf von Something.getInstance () initialisiert.  Jvm stellt sicher, dass dies nur einmal und dar√ºber hinaus sehr effizient geschieht - wenn die Klasse bereits initialisiert ist, entsteht kein Overhead.  Dementsprechend wird LazyHolder.INSTANCE auch einmalig "faul" und threadsicher initialisiert. <div class="spoiler">  <b class="spoiler_title">St√ºck spec √ºber Overhead</b> <div class="spoiler_text">  Wenn diese Initialisierungsprozedur normal abgeschlossen wird und das Class-Objekt vollst√§ndig initialisiert und einsatzbereit ist, ist der Aufruf der Initialisierungsprozedur nicht mehr erforderlich und kann aus dem Code entfernt werden, z. B. durch Patchen oder anderweitige Neuerstellung des Codes . <br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" rel="nofollow">Quelle</a> </div></div><br>  Singletones gelten im Allgemeinen nicht als Best Practice. <br><br>  Das Material ist noch nicht vorbei.  Wenn also die H√§nde ‚Äûreichen‚Äú und das, was bereits geschrieben wurde, gefragt ist, werde ich irgendwie mehr zu diesem Thema schreiben. <br><br>  Vielen Dank f√ºr die konstruktiven Kommentare.  Mehrere Stellen im Artikel wurden dank <a href="https://habr.com/ru/users/sergey-gornostaev/" class="user_link">sergey-gornostaev</a> , <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko</a> , <a href="https://habr.com/ru/users/olehkurpiak/" class="user_link">OlehKurpiak</a> , <a href="https://habr.com/ru/users/mk2/" class="user_link">mk2 erweitert</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482950/">https://habr.com/ru/post/de482950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482940/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 396 (30. Dezember 2019 - 5. Januar 2020)</a></li>
<li><a href="../de482942/index.html">Mythen und Legenden des alten Fediversums</a></li>
<li><a href="../de482944/index.html">Mehrkomponenten-F√∂rderspender</a></li>
<li><a href="../de482946/index.html">1–° DSS und Sch√§tzung der Projektlaufzeiten und -kosten nach der COCOMO II-Methode</a></li>
<li><a href="../de482948/index.html">"Eins, zwei, drei - verbrenne den Weihnachtsbaum!" Oder mein erster Blick auf den CANNY 3 winzigen Controller</a></li>
<li><a href="../de482956/index.html">√úberpr√ºfung von WCS 5.2 - WebRTC Server f√ºr Webcast- und Webcam-Entwickler</a></li>
<li><a href="../de482958/index.html">"Wachstumsregeln: Vom Junior zum CTO", Auszug aus einem Webinar von Fedor Borshchev</a></li>
<li><a href="../de482960/index.html">WCS 5.2 √úbersicht - WebRTC Server f√ºr Webentwickler von Online-Broadcasts und Video-Chats</a></li>
<li><a href="../de482968/index.html">Quarkus - Ein neuer Blick auf Cloud Native Java</a></li>
<li><a href="../de482970/index.html">Hack The Box - Walkthrough Craft. Wir st√∂bern in Git, nutzen Schwachstellen in der API aus, besch√§ftigen uns mit Vault</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>