<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👡 🗻 📈 Funktionales Denken. Teil 9 🚣🏽 ⚜️ 🧑🏿‍🤝‍🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist bereits Teil 9 einer Artikelserie zur funktionalen Programmierung in F #! Ich bin sicher, dass es auf Habré nicht sehr viele so lange Zyklen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales Denken. Teil 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433406/"><p>  Dies ist bereits Teil 9 einer Artikelserie zur funktionalen Programmierung in F #!  Ich bin sicher, dass es auf Habré nicht sehr viele so lange Zyklen gibt.  Aber wir werden nicht aufhören.  Heute werden wir über verschachtelte Funktionen, Module, Namespaces und das Mischen von Typen und Funktionen in Modulen sprechen. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fünfter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sechster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Siebter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Achter Teil</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Jetzt wissen Sie, wie man Funktionen definiert, aber wie man sie organisiert? </p><br><p>  F # hat drei Möglichkeiten: </p><br><ul><li>  Funktionen können in andere Funktionen verschachtelt werden. </li><li>  Auf Anwendungsebene werden Funktionen der obersten Ebene in „Module“ gruppiert. </li><li>  oder Sie können einen objektorientierten Ansatz verfolgen und Funktionen als Methoden an Typen anhängen. </li></ul><br><p>  In diesem Artikel werden wir die ersten beiden Methoden und die verbleibende in der nächsten betrachten. </p><br><h2>  Verschachtelte Funktionen </h2><br><p>  In F # können Sie Funktionen innerhalb anderer Funktionen definieren.  Dies ist eine gute Möglichkeit, Hilfsfunktionen zu kapseln, die nur für die Hauptfunktion benötigt werden und von außen nicht sichtbar sein sollten. </p><br><p> Im folgenden Beispiel ist <code>add</code> in <code>addThreeNumbers</code> verschachtelt: </p><br><pre> <code class="plaintext hljs">let addThreeNumbers xyz = //     let add n = fun x -&gt; x + n //    x |&gt; add y |&gt; add z addThreeNumbers 2 3 4</code> </pre> <br><p>  Verschachtelte Funktionen können direkt auf die übergeordneten Parameter zugreifen, da sie sich in ihrem Bereich befinden. <br>  Im folgenden Beispiel <code>printError</code> verschachtelte Funktion <code>printError</code> keine Parameter, da  sie kann direkt auf <code>n</code> und <code>max</code> zugreifen. </p><br><pre> <code class="plaintext hljs">let validateSize max n = //       let printError() = printfn "Oops: '%i' is bigger than max: '%i'" n max //    if n &gt; max then printError() validateSize 10 9 validateSize 10 11</code> </pre> <br><p>  Ein sehr häufiges Muster ist die Hauptfunktion, die die verschachtelte rekursive Hilfsfunktion definiert, die mit den entsprechenden Anfangswerten aufgerufen wird. <br>  Das Folgende ist ein Beispiel für einen solchen Code: </p><br><pre> <code class="plaintext hljs">let sumNumbersUpTo max = //      let rec recursiveSum n sumSoFar = match n with | 0 -&gt; sumSoFar | _ -&gt; recursiveSum (n-1) (n+sumSoFar) //       recursiveSum max 0 sumNumbersUpTo 10</code> </pre> <br><p>  Vermeiden Sie eine tiefe Verschachtelung, insbesondere bei direktem Zugriff (nicht in Form von Parametern) auf übergeordnete Variablen. <br>  Übermäßig tief verschachtelte Funktionen sind ebenso schwer zu verstehen wie die schlimmsten von vielen verschachtelten imperativen Zweigen. </p><br><p>  Ein Beispiel dafür, wie man es <em>nicht</em> macht: </p><br><pre> <code class="plaintext hljs">// wtf,    ? let fx = let f2 y = let f3 z = x * z let f4 z = let f5 z = y * z let f6 () = y * x f6() f4 y x * f2 x</code> </pre> <br><h2>  Module </h2><br><p>  Ein Modul ist einfach eine Sammlung von Funktionen, die zusammen gruppiert sind, normalerweise weil sie mit demselben Datentyp oder denselben Datentypen arbeiten. </p><br><p>  Eine Moduldefinition ist einer Funktionsdefinition sehr ähnlich.  Es beginnt mit dem Schlüsselwort <code>module</code> , dann kommt das Zeichen <code>=</code> , gefolgt vom Inhalt des Moduls. <br>  Der Inhalt des Moduls <em>muss</em> mit einem Offset formatiert sein, ebenso wie die Ausdrücke in der Definition von Funktionen. </p><br><p>  Definition eines Moduls mit zwei Funktionen: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Wenn Sie diesen Code in Visual Studio öffnen <code>add</code> können Sie beim <code>MathStuff.add</code> des <code>MathStuff.add</code> über <code>add</code> den vollständigen Namen <code>add</code> , der tatsächlich <code>MathStuff.add</code> , als wäre <code>MastStuff</code> eine Klasse und <code>add</code> eine Methode. </p><br><p>  Genau das passiert gerade.  Hinter den Kulissen erstellt der F # -Compiler eine statische Klasse mit statischen Methoden.  Das C # -Äquivalent würde folgendermaßen aussehen: </p><br><pre> <code class="plaintext hljs">static class MathStuff { static public int add(int x, int y) { return x + y; } static public int subtract(int x, int y) { return x - y; } }</code> </pre> <br><p>  Wenn Sie erkennen, dass Module nur statische Klassen und Funktionen statische Methoden sind, erhalten Sie ein gutes Verständnis der Funktionsweise von Modulen in F #, da die meisten Regeln, die für statische Klassen gelten, auch für Module gelten. </p><br><p>  Und genau wie in C # sollte jede eigenständige Funktion Teil der Klasse sein, in F # sollte jede eigenständige Funktion Teil des Moduls sein. </p><br><h3>  Zugriff auf Funktionen außerhalb des Moduls </h3><br><p>  Wenn Sie von einem anderen Modul aus auf eine Funktion zugreifen müssen, können Sie über den vollständigen Namen darauf verweisen. </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y module OtherStuff = //     MathStuff let add1 x = MathStuff.add x 1</code> </pre> <br><p>  Sie können auch alle Funktionen eines anderen Moduls mithilfe der <code>open</code> Direktive importieren. Anschließend können Sie den Kurznamen anstelle des vollständigen Namens verwenden. </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff //      let add1 x = add x 1</code> </pre> <br><p>  Die Regeln für die Verwendung von Namen werden durchaus erwartet.  Sie können jederzeit über den vollständigen Namen auf eine Funktion zugreifen oder je nach aktuellem Bereich relative oder unvollständige Namen verwenden. </p><br><h3>  Verschachtelte Module </h3><br><p>  Module können wie statische Klassen verschachtelte Module enthalten: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Andere Module können auf Funktionen in verschachtelten Modulen verweisen, wobei der vollständige oder relative Name verwendet wird: </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff let add1 x = add x 1 //   let add1Float x = MathStuff.FloatLib.add x 1.0 //   let sub1Float x = FloatLib.subtract x 1.0</code> </pre> <br><h3>  Module der obersten Ebene </h3><br><p>  Da die Module verschachtelt werden können, können Sie in der Kette ein übergeordnetes Modul der obersten Ebene erreichen.  Das ist tatsächlich so. </p><br><p>  Module der obersten Ebene werden anders definiert als die zuvor gezeigten Module. </p><br><ul><li>  Die <code>module MyModuleName</code> <em>muss</em> die erste Deklaration in der Datei sein </li><li>  Zeichen <code>=</code> fehlt </li><li>  Der Modulinhalt darf <em>nicht</em> eingerückt werden </li></ul><br><p>  Im Allgemeinen sollte in jeder <code>.FS</code> Quelldatei <code>.FS</code> Deklaration der obersten Ebene vorhanden sein.  Es gibt einige Ausnahmen, aber es ist immer noch eine gute Praxis.  Der Modulname muss nicht mit dem Dateinamen übereinstimmen, aber zwei Dateien dürfen keine Module mit demselben Namen enthalten. </p><br><p>  Für <code>.FSX</code> Dateien wird die Moduldeklaration nicht benötigt. In diesem Fall wird der Name der Skriptdatei automatisch zum <code>.FSX</code> . </p><br><p>  Ein Beispiel für ein <code>MathStuff</code> , das als "Top-Modul" -Modul deklariert wurde: </p><br><pre> <code class="plaintext hljs">//    module MathStuff let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Beachten Sie, dass der Code der "obersten Ebene" ( <code>module MathStuff</code> ist) keinen Einzug <code>module MathStuff</code> , während der Inhalt eines verschachtelten <code>FloatLib</code> Moduls noch eingerückt werden muss. </p><br><h3>  Sonstige Modulinhalte </h3><br><p>  Neben Funktionen können Module auch andere Deklarationen enthalten, z. B. Typdeklarationen, einfache Werte und Initialisierungscode (z. B. statische Konstruktoren). </p><br><pre> <code class="plaintext hljs">module MathStuff = //  let add xy = x + y let subtract xy = x - y //   type Complex = {r:float; i:float} type IntegerFunction = int -&gt; int -&gt; int type DegreesOrRadians = Deg | Rad // "" let PI = 3.141 // "" let mutable TrigType = Deg //  /   do printfn "module initialized"</code> </pre><br><p>  Wenn Sie diese Beispiele interaktiv ausführen, müssen Sie die Sitzung möglicherweise häufig genug neu starten, damit der Code „frisch“ bleibt und nicht durch vorherige Berechnungen infiziert wird. </p><br><h3>  Verschleierung (Überlappung, Beschattung) </h3><br><p>  Dies ist wieder unser Beispielmodul.  Beachten Sie, dass <code>MathStuff</code> die <code>add</code> Funktion <em>sowie</em> <code>MathStuff</code> enthält. </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Was passiert, wenn Sie <em>beide</em> Module im aktuellen Bereich öffnen und <code>add</code> aufrufen? </p><br><pre> <code class="plaintext hljs">open MathStuff open MathStuff.FloatLib let result = add 1 2 // Compiler error: This expression was expected to // have type float but here has type int</code> </pre> <br><p>  Und es kam vor, dass das <code>MathStuff.FloatLib</code> Modul das ursprüngliche <code>MathStuff</code> neu <code>MathStuff</code> , das vom <code>FloatLib</code> Modul blockiert (ausgeblendet) wurde. </p><br><p>  Als Ergebnis erhalten wir den FS0001-Compilerfehler, da der erste Parameter <code>1</code> als Float erwartet wurde.  Um dies zu beheben, müssen Sie <code>1</code> in <code>1.0</code> ändern. </p><br><p>  Leider wird dies in der Praxis <em>diskret</em> und leicht übersehen.  Manchmal können Sie mit dieser Technik interessante Tricks ausführen, fast wie Unterklassen, aber meistens ist das Vorhandensein gleichnamiger Funktionen ärgerlich (zum Beispiel bei der extrem häufigen <code>map</code> ). </p><br><p>  Wenn Sie dieses Verhalten vermeiden möchten, können Sie es mit dem <code>RequireQualifiedAccess</code> Attribut <code>RequireQualifiedAccess</code> .  Das gleiche Beispiel, in dem beide Module mit diesem Attribut dekoriert sind: </p><br><pre> <code class="plaintext hljs">[&lt;RequireQualifiedAccess&gt;] module MathStuff = let add xy = x + y let subtract xy = x - y //   [&lt;RequireQualifiedAccess&gt;] module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Jetzt ist die <code>open</code> Richtlinie nicht verfügbar: </p><br><pre> <code class="plaintext hljs">open MathStuff //  open MathStuff.FloatLib // </code> </pre> <br><p>  Sie können jedoch weiterhin (ohne Mehrdeutigkeit) über ihre vollständigen Namen auf Funktionen zugreifen: </p><br><pre> <code class="plaintext hljs">let result = MathStuff.add 1 2 let result = MathStuff.FloatLib.add 1.0 2.0</code> </pre> <br><h3>  Zugangskontrolle </h3><br><p>  F # unterstützt die Verwendung von Standard-.NET-Zugriffssteuerungsoperatoren wie <code>public</code> , <code>private</code> und <code>internal</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der MSDN-Artikel</a> enthält vollständige Informationen. </p><br><ul><li>  Diese Zugriffsspezifizierer können auf Funktionen, Werte, Typen und andere Deklarationen der obersten Ebene in einem Modul angewendet werden ("gebunden lassen").  Sie können auch für die Module selbst angegeben werden (beispielsweise wird möglicherweise ein privates verschachteltes Modul benötigt). </li><li>  Standardmäßig hat alles öffentlichen Zugriff (mit Ausnahme einiger Fälle). Um sie zu schützen, müssen Sie <code>private</code> oder <code>internal</code> . </li></ul><br><p>  Diese Zugriffsspezifizierer sind nur eine Möglichkeit, die Sichtbarkeit in F # zu steuern.  Eine völlig andere Möglichkeit besteht darin, Signaturdateien zu verwenden, die C-Header-Dateien ähneln. Sie beschreiben abstrakt den Inhalt des Moduls.  Signaturen sind sehr nützlich für eine ernsthafte Kapselung. Um jedoch ihre Funktionen zu berücksichtigen, müssen Sie auf die geplante Serie zu Kapselung und <em>Sicherheit</em> warten, die <em>auf Funktionen basiert</em> . </p><br><h2>  Namespaces </h2><br><p>  Namespaces in F # ähneln Namespaces in C #.  Sie können verwendet werden, um Module und Typen zu organisieren, um Namenskonflikte zu vermeiden. </p><br><p>  Ein mit dem <code>namespace</code> Schlüsselwort deklarierter <code>namespace</code> : </p><br><pre> <code class="plaintext hljs">namespace Utilities module MathStuff = //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Aufgrund dieses Namespace wurde der vollständige Name des <code>MathStuff</code> Moduls zu <code>Utilities.MathStuff</code> , und der vollständige Name <code>add</code> lautet <code>Utilities.MathStuff.add</code> . </p><br><p>  Die gleichen Einrückungsregeln gelten für Module in einem Namespace, die oben für Module gezeigt wurden. </p><br><p>  Sie können einen Namespace auch explizit deklarieren, indem Sie dem Modulnamen einen Punkt hinzufügen.  Das heißt,  Der obige Code kann folgendermaßen umgeschrieben werden: </p><br><pre> <code class="plaintext hljs">module Utilities.MathStuff //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Der vollständige Name des <code>MathStuff</code> Moduls lautet weiterhin <code>Utilities.MathStuff</code> . Jetzt handelt es sich jedoch um ein Modul der obersten Ebene, dessen Inhalt nicht <code>MathStuff</code> werden muss. </p><br><p>  Einige zusätzliche Funktionen zur Verwendung von Namespaces: </p><br><ul><li>  Namespaces sind für Module optional.  Im Gegensatz zu C # gibt es für F # -Projekte keinen Standard-Namespace, sodass ein Modul der obersten Ebene ohne Namespace global ist.  Wenn Sie wiederverwendbare Bibliotheken erstellen möchten, müssen Sie mehrere Namespaces hinzufügen, um Konflikte mit dem Code anderer Bibliotheken zu vermeiden. </li><li>  Namespaces können direkt Typdeklarationen enthalten, jedoch keine Funktionsdeklarationen.  Wie bereits erwähnt, müssen alle Funktions- und Wertdeklarationen Teil eines Moduls sein. </li><li>  Beachten Sie schließlich, dass Namespaces in Skripten nicht funktionieren.  Wenn Sie beispielsweise versuchen, eine Namespace-Deklaration, z. B. <code>namespace Utilities</code> , an ein interaktives Fenster zu senden, wird ein Fehler empfangen. </li></ul><br><h3>  Namespace-Hierarchie </h3><br><p>  Sie können eine Hierarchie von Namespaces erstellen, indem Sie die Namen einfach durch Punkte teilen: </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y</code> </pre> <br><p>  Sie können auch <em>zwei</em> Namespaces in einer Datei deklarieren, wenn Sie möchten.  Es ist zu beachten, dass alle Namespaces mit ihrem vollständigen Namen deklariert werden müssen - sie unterstützen keine Verschachtelung. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core.Extra module MoreMathStuff = let add xy = x + y</code> </pre> <br><p>  Ein Namenskonflikt zwischen dem Namespace und dem Modul ist nicht möglich. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core //    - Core.Utilities //     ! module Utilities = let add xy = x + y</code> </pre> <br><h2>  Mischen von Typen und Funktionen in Modulen </h2><br><p>  Wie wir gesehen haben, bestehen Module normalerweise aus vielen voneinander abhängigen Funktionen, die mit einem bestimmten Datentyp interagieren. </p><br><p>  In OOP würden darüber liegende Datenstrukturen und Funktionen innerhalb einer Klasse kombiniert.  In der funktionalen F # werden Datenstrukturen und Funktionen darüber zu einem Modul zusammengefasst. </p><br><p>  Es gibt zwei Muster zum Kombinieren von Typen und Funktionen: </p><br><ul><li>  Typ wird getrennt von Funktionen deklariert </li><li>  Typ wird im selben Modul wie Funktionen deklariert </li></ul><br><p>  Im ersten Fall wird der Typ <em>außerhalb eines</em> Moduls (aber im Namespace) deklariert. Danach werden die Funktionen, die mit diesem Typ arbeiten, in das Modul desselben Typs eingefügt. </p><br><pre> <code class="plaintext hljs">//    namespace Example //      type PersonType = {First:string; Last:string} //    ,     module Person = //  let create first last = {First=first; Last=last} // ,     let fullName {First=first; Last=last} = first + " " + last let person = Person.create "john" "doe" Person.fullName person |&gt; printfn "Fullname=%s"</code> </pre> <br><p>  Alternativ wird der Typ <em>innerhalb des</em> Moduls deklariert und hat einen einfachen Namen wie " <code>T</code> " oder den Namen des Moduls.  Der Zugriff auf Funktionen ist ungefähr wie folgt: <code>MyModule.Func</code> und <code>MyModule.Func2</code> und Zugriff auf den Typ: <code>MyModule.T</code> : </p><br><pre> <code class="plaintext hljs">module Customer = // Customer.T -      type T = {AccountId:int; Name:string} //  let create id name = {T.AccountId=id; T.Name=name} // ,     let isValid {T.AccountId=id; } = id &gt; 0 let customer = Customer.create 42 "bob" Customer.isValid customer |&gt; printfn "Is valid?=%b"</code> </pre> <br><p>  Beachten Sie, dass in beiden Fällen eine Konstruktorfunktion vorhanden sein muss, die eine neue Instanz des Typs (Factory) erstellt.  Dann müssen Sie im Client-Code kaum explizit auf den Typnamen zugreifen und müssen sich nicht fragen, ob sich der Typ im Modul befindet oder nicht. </p><br><p>  Welchen Weg wählen? </p><br><ul><li>  Der erste Ansatz ähnelt eher klassischem .NET und sollte bevorzugt werden, wenn Sie diese Bibliothek für Code außerhalb von F # verwenden möchten, für den eine separat vorhandene Klasse erwartet wird. </li><li>  Der zweite Ansatz ist in anderen funktionalen Sprachen üblicher.  Der Typ innerhalb des Moduls wird als verschachtelte Klasse kompiliert, was für OOP-Sprachen normalerweise nicht sehr praktisch ist. </li></ul><br><p>  Sie können selbst mit beiden Methoden experimentieren.  Bei der Teamentwicklung muss ein Stil gewählt werden. </p><br><h3>  Module, die nur Typen enthalten </h3><br><p>  Wenn es viele Typen gibt, die ohne Funktionen deklariert werden müssen, verwenden Sie das Modul nicht.  Sie können Typen direkt im Namespace deklarieren, ohne auf verschachtelte Klassen zurückgreifen zu müssen. </p><br><p>  Zum Beispiel möchten Sie vielleicht Folgendes tun: </p><br><pre> <code class="plaintext hljs">//    module Example //     type PersonType = {First:string; Last:string} //    ,  ...</code> </pre> <br><p>  Und hier ist eine andere Möglichkeit, dasselbe zu tun.  Das <code>module</code> einfach durch den <code>namespace</code> . </p><br><pre> <code class="plaintext hljs">//    namespace Example //     type PersonType = {First:string; Last:string}</code> </pre> <br><p>  In beiden Fällen hat <code>PersonType</code> denselben vollständigen Namen. </p><br><p>  Bitte beachten Sie, dass dieser Ersatz nur mit Typen funktioniert.  Funktionen müssen <strong>immer</strong> innerhalb des Moduls deklariert werden. </p><br><h1>  Zusätzliche Ressourcen </h1><br><p>  Es gibt viele Tutorials für F #, einschließlich Materialien für diejenigen, die mit C # oder Java-Erfahrung kommen.  Die folgenden Links können hilfreich sein, wenn Sie tiefer in F # einsteigen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Anleitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # für Spaß und Profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne X in Y Minuten: F #</a> </li></ul><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> auch verschiedene andere Möglichkeiten beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um mit dem Lernen von F # zu beginnen</a> . </p><br><p>  Schließlich ist die F # Community sehr anfängerfreundlich.  Bei Slack gibt es einen sehr aktiven Chat, der von der F # Software Foundation unterstützt wird, mit Anfängerräumen, an denen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei teilnehmen können</a> .  Wir empfehlen Ihnen dringend, dies zu tun! </p><br><p>  Vergessen Sie nicht, die Seite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community F #</a> zu besuchen!  Wenn Sie Fragen zum Erlernen einer Sprache haben, diskutieren wir diese gerne in Chatrooms: </p><br><ul><li>  Raum <code>#ru_general</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Telegramm chatten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatte in gitter</a> </li><li>  Raum #en_general im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  Über Übersetzungsautoren </h2><br><p>  Übersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Übersetzungs- und redaktionelle Änderungen wurden durch die Bemühungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community von F # -Entwicklern vorgenommen</a> .  Wir danken auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@schvepsss</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@shwars</em></a> für die Vorbereitung dieses Artikels zur Veröffentlichung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433406/">https://habr.com/ru/post/de433406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433396/index.html">Frontend 2018: Ergebnisse des Jahres</a></li>
<li><a href="../de433398/index.html">Funktionales Denken. Teil 7</a></li>
<li><a href="../de433400/index.html">React Tutorial Teil 2: Funktionskomponenten</a></li>
<li><a href="../de433402/index.html">Funktionales Denken. Teil 8</a></li>
<li><a href="../de433404/index.html">React Tutorial Teil 3: Komponentendateien, Projektstruktur</a></li>
<li><a href="../de433408/index.html">Effiziente Speicherbehandlung in Node.js.</a></li>
<li><a href="../de433410/index.html">Funktionales Denken. Teil 10</a></li>
<li><a href="../de433412/index.html">Funktionales Denken. Teil 11: Finale</a></li>
<li><a href="../de433414/index.html">PRTG Network Monitor testen und mit Zabbix vergleichen</a></li>
<li><a href="../de433420/index.html">ZeroNights 2018 Ergebnisse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>