<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë° üóª üìà Funktionales Denken. Teil 9 üö£üèΩ ‚öúÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist bereits Teil 9 einer Artikelserie zur funktionalen Programmierung in F #! Ich bin sicher, dass es auf Habr√© nicht sehr viele so lange Zyklen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales Denken. Teil 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433406/"><p>  Dies ist bereits Teil 9 einer Artikelserie zur funktionalen Programmierung in F #!  Ich bin sicher, dass es auf Habr√© nicht sehr viele so lange Zyklen gibt.  Aber wir werden nicht aufh√∂ren.  Heute werden wir √ºber verschachtelte Funktionen, Module, Namespaces und das Mischen von Typen und Funktionen in Modulen sprechen. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºnfter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sechster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Siebter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Achter Teil</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Jetzt wissen Sie, wie man Funktionen definiert, aber wie man sie organisiert? </p><br><p>  F # hat drei M√∂glichkeiten: </p><br><ul><li>  Funktionen k√∂nnen in andere Funktionen verschachtelt werden. </li><li>  Auf Anwendungsebene werden Funktionen der obersten Ebene in ‚ÄûModule‚Äú gruppiert. </li><li>  oder Sie k√∂nnen einen objektorientierten Ansatz verfolgen und Funktionen als Methoden an Typen anh√§ngen. </li></ul><br><p>  In diesem Artikel werden wir die ersten beiden Methoden und die verbleibende in der n√§chsten betrachten. </p><br><h2>  Verschachtelte Funktionen </h2><br><p>  In F # k√∂nnen Sie Funktionen innerhalb anderer Funktionen definieren.  Dies ist eine gute M√∂glichkeit, Hilfsfunktionen zu kapseln, die nur f√ºr die Hauptfunktion ben√∂tigt werden und von au√üen nicht sichtbar sein sollten. </p><br><p> Im folgenden Beispiel ist <code>add</code> in <code>addThreeNumbers</code> verschachtelt: </p><br><pre> <code class="plaintext hljs">let addThreeNumbers xyz = //     let add n = fun x -&gt; x + n //    x |&gt; add y |&gt; add z addThreeNumbers 2 3 4</code> </pre> <br><p>  Verschachtelte Funktionen k√∂nnen direkt auf die √ºbergeordneten Parameter zugreifen, da sie sich in ihrem Bereich befinden. <br>  Im folgenden Beispiel <code>printError</code> verschachtelte Funktion <code>printError</code> keine Parameter, da  sie kann direkt auf <code>n</code> und <code>max</code> zugreifen. </p><br><pre> <code class="plaintext hljs">let validateSize max n = //       let printError() = printfn "Oops: '%i' is bigger than max: '%i'" n max //    if n &gt; max then printError() validateSize 10 9 validateSize 10 11</code> </pre> <br><p>  Ein sehr h√§ufiges Muster ist die Hauptfunktion, die die verschachtelte rekursive Hilfsfunktion definiert, die mit den entsprechenden Anfangswerten aufgerufen wird. <br>  Das Folgende ist ein Beispiel f√ºr einen solchen Code: </p><br><pre> <code class="plaintext hljs">let sumNumbersUpTo max = //      let rec recursiveSum n sumSoFar = match n with | 0 -&gt; sumSoFar | _ -&gt; recursiveSum (n-1) (n+sumSoFar) //       recursiveSum max 0 sumNumbersUpTo 10</code> </pre> <br><p>  Vermeiden Sie eine tiefe Verschachtelung, insbesondere bei direktem Zugriff (nicht in Form von Parametern) auf √ºbergeordnete Variablen. <br>  √úberm√§√üig tief verschachtelte Funktionen sind ebenso schwer zu verstehen wie die schlimmsten von vielen verschachtelten imperativen Zweigen. </p><br><p>  Ein Beispiel daf√ºr, wie man es <em>nicht</em> macht: </p><br><pre> <code class="plaintext hljs">// wtf,    ? let fx = let f2 y = let f3 z = x * z let f4 z = let f5 z = y * z let f6 () = y * x f6() f4 y x * f2 x</code> </pre> <br><h2>  Module </h2><br><p>  Ein Modul ist einfach eine Sammlung von Funktionen, die zusammen gruppiert sind, normalerweise weil sie mit demselben Datentyp oder denselben Datentypen arbeiten. </p><br><p>  Eine Moduldefinition ist einer Funktionsdefinition sehr √§hnlich.  Es beginnt mit dem Schl√ºsselwort <code>module</code> , dann kommt das Zeichen <code>=</code> , gefolgt vom Inhalt des Moduls. <br>  Der Inhalt des Moduls <em>muss</em> mit einem Offset formatiert sein, ebenso wie die Ausdr√ºcke in der Definition von Funktionen. </p><br><p>  Definition eines Moduls mit zwei Funktionen: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Wenn Sie diesen Code in Visual Studio √∂ffnen <code>add</code> k√∂nnen Sie beim <code>MathStuff.add</code> des <code>MathStuff.add</code> √ºber <code>add</code> den vollst√§ndigen Namen <code>add</code> , der tats√§chlich <code>MathStuff.add</code> , als w√§re <code>MastStuff</code> eine Klasse und <code>add</code> eine Methode. </p><br><p>  Genau das passiert gerade.  Hinter den Kulissen erstellt der F # -Compiler eine statische Klasse mit statischen Methoden.  Das C # -√Ñquivalent w√ºrde folgenderma√üen aussehen: </p><br><pre> <code class="plaintext hljs">static class MathStuff { static public int add(int x, int y) { return x + y; } static public int subtract(int x, int y) { return x - y; } }</code> </pre> <br><p>  Wenn Sie erkennen, dass Module nur statische Klassen und Funktionen statische Methoden sind, erhalten Sie ein gutes Verst√§ndnis der Funktionsweise von Modulen in F #, da die meisten Regeln, die f√ºr statische Klassen gelten, auch f√ºr Module gelten. </p><br><p>  Und genau wie in C # sollte jede eigenst√§ndige Funktion Teil der Klasse sein, in F # sollte jede eigenst√§ndige Funktion Teil des Moduls sein. </p><br><h3>  Zugriff auf Funktionen au√üerhalb des Moduls </h3><br><p>  Wenn Sie von einem anderen Modul aus auf eine Funktion zugreifen m√ºssen, k√∂nnen Sie √ºber den vollst√§ndigen Namen darauf verweisen. </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y module OtherStuff = //     MathStuff let add1 x = MathStuff.add x 1</code> </pre> <br><p>  Sie k√∂nnen auch alle Funktionen eines anderen Moduls mithilfe der <code>open</code> Direktive importieren. Anschlie√üend k√∂nnen Sie den Kurznamen anstelle des vollst√§ndigen Namens verwenden. </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff //      let add1 x = add x 1</code> </pre> <br><p>  Die Regeln f√ºr die Verwendung von Namen werden durchaus erwartet.  Sie k√∂nnen jederzeit √ºber den vollst√§ndigen Namen auf eine Funktion zugreifen oder je nach aktuellem Bereich relative oder unvollst√§ndige Namen verwenden. </p><br><h3>  Verschachtelte Module </h3><br><p>  Module k√∂nnen wie statische Klassen verschachtelte Module enthalten: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Andere Module k√∂nnen auf Funktionen in verschachtelten Modulen verweisen, wobei der vollst√§ndige oder relative Name verwendet wird: </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff let add1 x = add x 1 //   let add1Float x = MathStuff.FloatLib.add x 1.0 //   let sub1Float x = FloatLib.subtract x 1.0</code> </pre> <br><h3>  Module der obersten Ebene </h3><br><p>  Da die Module verschachtelt werden k√∂nnen, k√∂nnen Sie in der Kette ein √ºbergeordnetes Modul der obersten Ebene erreichen.  Das ist tats√§chlich so. </p><br><p>  Module der obersten Ebene werden anders definiert als die zuvor gezeigten Module. </p><br><ul><li>  Die <code>module MyModuleName</code> <em>muss</em> die erste Deklaration in der Datei sein </li><li>  Zeichen <code>=</code> fehlt </li><li>  Der Modulinhalt darf <em>nicht</em> einger√ºckt werden </li></ul><br><p>  Im Allgemeinen sollte in jeder <code>.FS</code> Quelldatei <code>.FS</code> Deklaration der obersten Ebene vorhanden sein.  Es gibt einige Ausnahmen, aber es ist immer noch eine gute Praxis.  Der Modulname muss nicht mit dem Dateinamen √ºbereinstimmen, aber zwei Dateien d√ºrfen keine Module mit demselben Namen enthalten. </p><br><p>  F√ºr <code>.FSX</code> Dateien wird die Moduldeklaration nicht ben√∂tigt. In diesem Fall wird der Name der Skriptdatei automatisch zum <code>.FSX</code> . </p><br><p>  Ein Beispiel f√ºr ein <code>MathStuff</code> , das als "Top-Modul" -Modul deklariert wurde: </p><br><pre> <code class="plaintext hljs">//    module MathStuff let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Beachten Sie, dass der Code der "obersten Ebene" ( <code>module MathStuff</code> ist) keinen Einzug <code>module MathStuff</code> , w√§hrend der Inhalt eines verschachtelten <code>FloatLib</code> Moduls noch einger√ºckt werden muss. </p><br><h3>  Sonstige Modulinhalte </h3><br><p>  Neben Funktionen k√∂nnen Module auch andere Deklarationen enthalten, z. B. Typdeklarationen, einfache Werte und Initialisierungscode (z. B. statische Konstruktoren). </p><br><pre> <code class="plaintext hljs">module MathStuff = //  let add xy = x + y let subtract xy = x - y //   type Complex = {r:float; i:float} type IntegerFunction = int -&gt; int -&gt; int type DegreesOrRadians = Deg | Rad // "" let PI = 3.141 // "" let mutable TrigType = Deg //  /   do printfn "module initialized"</code> </pre><br><p>  Wenn Sie diese Beispiele interaktiv ausf√ºhren, m√ºssen Sie die Sitzung m√∂glicherweise h√§ufig genug neu starten, damit der Code ‚Äûfrisch‚Äú bleibt und nicht durch vorherige Berechnungen infiziert wird. </p><br><h3>  Verschleierung (√úberlappung, Beschattung) </h3><br><p>  Dies ist wieder unser Beispielmodul.  Beachten Sie, dass <code>MathStuff</code> die <code>add</code> Funktion <em>sowie</em> <code>MathStuff</code> enth√§lt. </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Was passiert, wenn Sie <em>beide</em> Module im aktuellen Bereich √∂ffnen und <code>add</code> aufrufen? </p><br><pre> <code class="plaintext hljs">open MathStuff open MathStuff.FloatLib let result = add 1 2 // Compiler error: This expression was expected to // have type float but here has type int</code> </pre> <br><p>  Und es kam vor, dass das <code>MathStuff.FloatLib</code> Modul das urspr√ºngliche <code>MathStuff</code> neu <code>MathStuff</code> , das vom <code>FloatLib</code> Modul blockiert (ausgeblendet) wurde. </p><br><p>  Als Ergebnis erhalten wir den FS0001-Compilerfehler, da der erste Parameter <code>1</code> als Float erwartet wurde.  Um dies zu beheben, m√ºssen Sie <code>1</code> in <code>1.0</code> √§ndern. </p><br><p>  Leider wird dies in der Praxis <em>diskret</em> und leicht √ºbersehen.  Manchmal k√∂nnen Sie mit dieser Technik interessante Tricks ausf√ºhren, fast wie Unterklassen, aber meistens ist das Vorhandensein gleichnamiger Funktionen √§rgerlich (zum Beispiel bei der extrem h√§ufigen <code>map</code> ). </p><br><p>  Wenn Sie dieses Verhalten vermeiden m√∂chten, k√∂nnen Sie es mit dem <code>RequireQualifiedAccess</code> Attribut <code>RequireQualifiedAccess</code> .  Das gleiche Beispiel, in dem beide Module mit diesem Attribut dekoriert sind: </p><br><pre> <code class="plaintext hljs">[&lt;RequireQualifiedAccess&gt;] module MathStuff = let add xy = x + y let subtract xy = x - y //   [&lt;RequireQualifiedAccess&gt;] module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Jetzt ist die <code>open</code> Richtlinie nicht verf√ºgbar: </p><br><pre> <code class="plaintext hljs">open MathStuff //  open MathStuff.FloatLib // </code> </pre> <br><p>  Sie k√∂nnen jedoch weiterhin (ohne Mehrdeutigkeit) √ºber ihre vollst√§ndigen Namen auf Funktionen zugreifen: </p><br><pre> <code class="plaintext hljs">let result = MathStuff.add 1 2 let result = MathStuff.FloatLib.add 1.0 2.0</code> </pre> <br><h3>  Zugangskontrolle </h3><br><p>  F # unterst√ºtzt die Verwendung von Standard-.NET-Zugriffssteuerungsoperatoren wie <code>public</code> , <code>private</code> und <code>internal</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der MSDN-Artikel</a> enth√§lt vollst√§ndige Informationen. </p><br><ul><li>  Diese Zugriffsspezifizierer k√∂nnen auf Funktionen, Werte, Typen und andere Deklarationen der obersten Ebene in einem Modul angewendet werden ("gebunden lassen").  Sie k√∂nnen auch f√ºr die Module selbst angegeben werden (beispielsweise wird m√∂glicherweise ein privates verschachteltes Modul ben√∂tigt). </li><li>  Standardm√§√üig hat alles √∂ffentlichen Zugriff (mit Ausnahme einiger F√§lle). Um sie zu sch√ºtzen, m√ºssen Sie <code>private</code> oder <code>internal</code> . </li></ul><br><p>  Diese Zugriffsspezifizierer sind nur eine M√∂glichkeit, die Sichtbarkeit in F # zu steuern.  Eine v√∂llig andere M√∂glichkeit besteht darin, Signaturdateien zu verwenden, die C-Header-Dateien √§hneln. Sie beschreiben abstrakt den Inhalt des Moduls.  Signaturen sind sehr n√ºtzlich f√ºr eine ernsthafte Kapselung. Um jedoch ihre Funktionen zu ber√ºcksichtigen, m√ºssen Sie auf die geplante Serie zu Kapselung und <em>Sicherheit</em> warten, die <em>auf Funktionen basiert</em> . </p><br><h2>  Namespaces </h2><br><p>  Namespaces in F # √§hneln Namespaces in C #.  Sie k√∂nnen verwendet werden, um Module und Typen zu organisieren, um Namenskonflikte zu vermeiden. </p><br><p>  Ein mit dem <code>namespace</code> Schl√ºsselwort deklarierter <code>namespace</code> : </p><br><pre> <code class="plaintext hljs">namespace Utilities module MathStuff = //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Aufgrund dieses Namespace wurde der vollst√§ndige Name des <code>MathStuff</code> Moduls zu <code>Utilities.MathStuff</code> , und der vollst√§ndige Name <code>add</code> lautet <code>Utilities.MathStuff.add</code> . </p><br><p>  Die gleichen Einr√ºckungsregeln gelten f√ºr Module in einem Namespace, die oben f√ºr Module gezeigt wurden. </p><br><p>  Sie k√∂nnen einen Namespace auch explizit deklarieren, indem Sie dem Modulnamen einen Punkt hinzuf√ºgen.  Das hei√üt,  Der obige Code kann folgenderma√üen umgeschrieben werden: </p><br><pre> <code class="plaintext hljs">module Utilities.MathStuff //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Der vollst√§ndige Name des <code>MathStuff</code> Moduls lautet weiterhin <code>Utilities.MathStuff</code> . Jetzt handelt es sich jedoch um ein Modul der obersten Ebene, dessen Inhalt nicht <code>MathStuff</code> werden muss. </p><br><p>  Einige zus√§tzliche Funktionen zur Verwendung von Namespaces: </p><br><ul><li>  Namespaces sind f√ºr Module optional.  Im Gegensatz zu C # gibt es f√ºr F # -Projekte keinen Standard-Namespace, sodass ein Modul der obersten Ebene ohne Namespace global ist.  Wenn Sie wiederverwendbare Bibliotheken erstellen m√∂chten, m√ºssen Sie mehrere Namespaces hinzuf√ºgen, um Konflikte mit dem Code anderer Bibliotheken zu vermeiden. </li><li>  Namespaces k√∂nnen direkt Typdeklarationen enthalten, jedoch keine Funktionsdeklarationen.  Wie bereits erw√§hnt, m√ºssen alle Funktions- und Wertdeklarationen Teil eines Moduls sein. </li><li>  Beachten Sie schlie√ülich, dass Namespaces in Skripten nicht funktionieren.  Wenn Sie beispielsweise versuchen, eine Namespace-Deklaration, z. B. <code>namespace Utilities</code> , an ein interaktives Fenster zu senden, wird ein Fehler empfangen. </li></ul><br><h3>  Namespace-Hierarchie </h3><br><p>  Sie k√∂nnen eine Hierarchie von Namespaces erstellen, indem Sie die Namen einfach durch Punkte teilen: </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y</code> </pre> <br><p>  Sie k√∂nnen auch <em>zwei</em> Namespaces in einer Datei deklarieren, wenn Sie m√∂chten.  Es ist zu beachten, dass alle Namespaces mit ihrem vollst√§ndigen Namen deklariert werden m√ºssen - sie unterst√ºtzen keine Verschachtelung. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core.Extra module MoreMathStuff = let add xy = x + y</code> </pre> <br><p>  Ein Namenskonflikt zwischen dem Namespace und dem Modul ist nicht m√∂glich. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core //    - Core.Utilities //     ! module Utilities = let add xy = x + y</code> </pre> <br><h2>  Mischen von Typen und Funktionen in Modulen </h2><br><p>  Wie wir gesehen haben, bestehen Module normalerweise aus vielen voneinander abh√§ngigen Funktionen, die mit einem bestimmten Datentyp interagieren. </p><br><p>  In OOP w√ºrden dar√ºber liegende Datenstrukturen und Funktionen innerhalb einer Klasse kombiniert.  In der funktionalen F # werden Datenstrukturen und Funktionen dar√ºber zu einem Modul zusammengefasst. </p><br><p>  Es gibt zwei Muster zum Kombinieren von Typen und Funktionen: </p><br><ul><li>  Typ wird getrennt von Funktionen deklariert </li><li>  Typ wird im selben Modul wie Funktionen deklariert </li></ul><br><p>  Im ersten Fall wird der Typ <em>au√üerhalb eines</em> Moduls (aber im Namespace) deklariert. Danach werden die Funktionen, die mit diesem Typ arbeiten, in das Modul desselben Typs eingef√ºgt. </p><br><pre> <code class="plaintext hljs">//    namespace Example //      type PersonType = {First:string; Last:string} //    ,     module Person = //  let create first last = {First=first; Last=last} // ,     let fullName {First=first; Last=last} = first + " " + last let person = Person.create "john" "doe" Person.fullName person |&gt; printfn "Fullname=%s"</code> </pre> <br><p>  Alternativ wird der Typ <em>innerhalb des</em> Moduls deklariert und hat einen einfachen Namen wie " <code>T</code> " oder den Namen des Moduls.  Der Zugriff auf Funktionen ist ungef√§hr wie folgt: <code>MyModule.Func</code> und <code>MyModule.Func2</code> und Zugriff auf den Typ: <code>MyModule.T</code> : </p><br><pre> <code class="plaintext hljs">module Customer = // Customer.T -      type T = {AccountId:int; Name:string} //  let create id name = {T.AccountId=id; T.Name=name} // ,     let isValid {T.AccountId=id; } = id &gt; 0 let customer = Customer.create 42 "bob" Customer.isValid customer |&gt; printfn "Is valid?=%b"</code> </pre> <br><p>  Beachten Sie, dass in beiden F√§llen eine Konstruktorfunktion vorhanden sein muss, die eine neue Instanz des Typs (Factory) erstellt.  Dann m√ºssen Sie im Client-Code kaum explizit auf den Typnamen zugreifen und m√ºssen sich nicht fragen, ob sich der Typ im Modul befindet oder nicht. </p><br><p>  Welchen Weg w√§hlen? </p><br><ul><li>  Der erste Ansatz √§hnelt eher klassischem .NET und sollte bevorzugt werden, wenn Sie diese Bibliothek f√ºr Code au√üerhalb von F # verwenden m√∂chten, f√ºr den eine separat vorhandene Klasse erwartet wird. </li><li>  Der zweite Ansatz ist in anderen funktionalen Sprachen √ºblicher.  Der Typ innerhalb des Moduls wird als verschachtelte Klasse kompiliert, was f√ºr OOP-Sprachen normalerweise nicht sehr praktisch ist. </li></ul><br><p>  Sie k√∂nnen selbst mit beiden Methoden experimentieren.  Bei der Teamentwicklung muss ein Stil gew√§hlt werden. </p><br><h3>  Module, die nur Typen enthalten </h3><br><p>  Wenn es viele Typen gibt, die ohne Funktionen deklariert werden m√ºssen, verwenden Sie das Modul nicht.  Sie k√∂nnen Typen direkt im Namespace deklarieren, ohne auf verschachtelte Klassen zur√ºckgreifen zu m√ºssen. </p><br><p>  Zum Beispiel m√∂chten Sie vielleicht Folgendes tun: </p><br><pre> <code class="plaintext hljs">//    module Example //     type PersonType = {First:string; Last:string} //    ,  ...</code> </pre> <br><p>  Und hier ist eine andere M√∂glichkeit, dasselbe zu tun.  Das <code>module</code> einfach durch den <code>namespace</code> . </p><br><pre> <code class="plaintext hljs">//    namespace Example //     type PersonType = {First:string; Last:string}</code> </pre> <br><p>  In beiden F√§llen hat <code>PersonType</code> denselben vollst√§ndigen Namen. </p><br><p>  Bitte beachten Sie, dass dieser Ersatz nur mit Typen funktioniert.  Funktionen m√ºssen <strong>immer</strong> innerhalb des Moduls deklariert werden. </p><br><h1>  Zus√§tzliche Ressourcen </h1><br><p>  Es gibt viele Tutorials f√ºr F #, einschlie√ülich Materialien f√ºr diejenigen, die mit C # oder Java-Erfahrung kommen.  Die folgenden Links k√∂nnen hilfreich sein, wenn Sie tiefer in F # einsteigen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Anleitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # f√ºr Spa√ü und Profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne X in Y Minuten: F #</a> </li></ul><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> auch verschiedene andere M√∂glichkeiten beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um mit dem Lernen von F # zu beginnen</a> . </p><br><p>  Schlie√ülich ist die F # Community sehr anf√§ngerfreundlich.  Bei Slack gibt es einen sehr aktiven Chat, der von der F # Software Foundation unterst√ºtzt wird, mit Anf√§ngerr√§umen, an denen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei teilnehmen k√∂nnen</a> .  Wir empfehlen Ihnen dringend, dies zu tun! </p><br><p>  Vergessen Sie nicht, die Seite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community F #</a> zu besuchen!  Wenn Sie Fragen zum Erlernen einer Sprache haben, diskutieren wir diese gerne in Chatrooms: </p><br><ul><li>  Raum <code>#ru_general</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Telegramm chatten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatte in gitter</a> </li><li>  Raum #en_general im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  √úber √úbersetzungsautoren </h2><br><p>  √úbersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  √úbersetzungs- und redaktionelle √Ñnderungen wurden durch die Bem√ºhungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community von F # -Entwicklern vorgenommen</a> .  Wir danken auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@schvepsss</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@shwars</em></a> f√ºr die Vorbereitung dieses Artikels zur Ver√∂ffentlichung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433406/">https://habr.com/ru/post/de433406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433396/index.html">Frontend 2018: Ergebnisse des Jahres</a></li>
<li><a href="../de433398/index.html">Funktionales Denken. Teil 7</a></li>
<li><a href="../de433400/index.html">React Tutorial Teil 2: Funktionskomponenten</a></li>
<li><a href="../de433402/index.html">Funktionales Denken. Teil 8</a></li>
<li><a href="../de433404/index.html">React Tutorial Teil 3: Komponentendateien, Projektstruktur</a></li>
<li><a href="../de433408/index.html">Effiziente Speicherbehandlung in Node.js.</a></li>
<li><a href="../de433410/index.html">Funktionales Denken. Teil 10</a></li>
<li><a href="../de433412/index.html">Funktionales Denken. Teil 11: Finale</a></li>
<li><a href="../de433414/index.html">PRTG Network Monitor testen und mit Zabbix vergleichen</a></li>
<li><a href="../de433420/index.html">ZeroNights 2018 Ergebnisse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>