<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏻 👒 ⛄️ Navigation dans l'application Android à l'aide de coordinateurs 📈 🌪️ 🐙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours des dernières années, nous avons développé des approches communes pour la création d'applications Android. Architecture pure, modèles archite...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Navigation dans l'application Android à l'aide de coordinateurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/416301/">  Au cours des dernières années, nous avons développé des approches communes pour la création d'applications Android.  Architecture pure, modèles architecturaux (MVC, MVP, MVVM, MVI), modèle de référentiel et autres.  Cependant, il n'existe toujours pas d'approche généralement acceptée pour organiser la navigation dans l'application.  Aujourd'hui, je veux vous parler du modèle «coordinateur» et des possibilités de son application dans le développement d'applications Android. <br><blockquote>  Le modèle de coordinateur est souvent utilisé dans les applications iOS et a été introduit par Soroush Khanlou afin de simplifier la navigation de l'application.  On pense que le travail de Sorush est basé sur l’approche du contrôleur d’application décrite dans les modèles d’architecture d’application d’entreprise de Martin Fowler. <br></blockquote>  Le modèle «coordinateur» est conçu pour résoudre les tâches suivantes: <br><br><ul><li>  lutte avec le problème Massive View Controller (le problème était déjà écrit sur le hub - note du traducteur), qui se manifeste souvent avec l'avènement de God-Activity (activité avec beaucoup de responsabilités). </li><li>  séparation de la logique de navigation en une entité distincte </li><li>  réutilisation des écrans d'application (activité / fragments) en raison d'une faible connexion avec la logique de navigation </li></ul><br>  Mais, avant de vous familiariser avec le modèle et d'essayer de l'implémenter, jetons un coup d'œil aux implémentations de navigation utilisées dans les applications Android. <br><a name="habracut"></a><br><h3>  La logique de navigation est décrite dans l'activité / le fragment </h3><br>  Étant donné que le SDK Android nécessite Context pour ouvrir une nouvelle activité (ou FragmentManager afin d'ajouter un fragment à l'activité), la logique de navigation est souvent décrite directement dans l'activité / le fragment.  Même les exemples de la documentation du SDK Android utilisent cette approche. <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, CheckoutActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span></span>(intent) } } }</code> </pre> <br>  Dans l'exemple ci-dessus, la navigation est étroitement liée à l'activité.  Est-il pratique de tester un tel code?  On pourrait faire valoir que nous pouvons séparer la navigation en une entité distincte et la nommer, par exemple, Navigateur, qui peut être implémenté.  Voyons voir: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { navigator.showCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Navigator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCheckout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = Intent(activity, CheckoutActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">activity</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span></span>(intent) } }</code> </pre><br>  Cela s'est avéré pas mal, mais j'en veux plus. <br><br><h3>  Navigation avec MVVM / MVP </h3><br>  Je vais commencer par la question: où placeriez-vous la logique de navigation lors de l'utilisation de MVVM / MVP? <br><br>  Dans la couche sous le présentateur (appelons cela la logique métier)?  Ce n'est pas une bonne idée, car vous réutiliserez très probablement votre logique métier dans d'autres modèles de présentation ou présentateurs. <br><br>  Dans la couche d'affichage?  Voulez-vous vraiment lancer des événements entre la présentation et le modèle présentateur / présentation?  Regardons un exemple: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShoppingCartView</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter : ShoppingCartPresenter <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { presenter.checkoutClicked() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToCheckout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartPresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Presenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShoppingCartView</span></span></span><span class="hljs-class">&gt; </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkoutClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ view?.navigateToCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Ou si vous préférez MVVM, vous pouvez utiliser SingleLiveEvents ou EventObserver <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShoppingCartView</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewModel : ViewModel <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { viewModel.checkoutClicked() } viewModel.navigateToCheckout.observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Observer { navigator.showCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigateToCheckout = MutableLiveData&lt;Event&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkoutClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigateToCheckout.value = Event(<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Trigger the event by setting a new Event as a new value } }</span></span></code> </pre><br>  Ou plaçons un navigateur dans un modèle de vue au lieu d'utiliser EventObserver comme indiqué dans l'exemple précédent <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ShoppingCartViewModel @Inject <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val navigator : Navigator)</span></span></span><span class="hljs-function"> :</span></span> ViewModel() <span class="hljs-comment"><span class="hljs-comment">{ fun checkoutClicked(){ navigator.showCheckout() }</span></span> }</code> </pre><br>  Veuillez noter que cette approche peut être appliquée au présentateur.  Nous ignorons également une éventuelle fuite de mémoire dans le navigateur s'il conserve un lien vers l'activateur. <br><br><h3>  Coordinateur </h3><br>  Alors, où plaçons-nous la logique de navigation?  Logique métier?  Plus tôt, nous avons déjà envisagé cette option et sommes arrivés à la conclusion que ce n'était pas la meilleure solution.  Lancer des événements entre la vue et le modèle de vue peut fonctionner, mais cela ne ressemble pas à une solution élégante.  De plus, la vue est toujours responsable de la logique de navigation, même si nous l'avons apportée au navigateur.  Suite à la méthode d'exclusion, nous avons toujours la possibilité de placer la logique de navigation dans le modèle de présentation, et cette option semble prometteuse.  Mais le modèle de vue doit-il se soucier de la navigation?  N'est-ce pas juste une couche entre la vue et le modèle?  C'est pourquoi nous sommes arrivés à la notion de coordinateur. <br><br>  "Pourquoi avons-nous besoin d'un autre niveau d'abstraction?"  - demandez-vous.  Vaut-il la complexité du système?  Dans les petits projets, l'abstraction peut vraiment s'avérer utile pour l'abstraction, cependant, dans les applications complexes ou dans le cas de l'utilisation de tests A / B, le coordinateur peut être utile.  Supposons qu'un utilisateur puisse créer un compte et se connecter.  Nous avons déjà une certaine logique, où nous devons vérifier si l'utilisateur s'est connecté et afficher soit l'écran de connexion, soit l'écran principal de l'application.  Le coordinateur peut vous aider avec l'exemple donné.  Notez que le coordinateur n'aide pas à écrire moins de code; il aide à obtenir le code de la logique de navigation à partir de la vue ou du modèle de vue. <br><br>  L'idée du coordinateur est extrêmement simple.  Il ne sait que quel écran d'application ouvrir ensuite.  Par exemple, lorsqu'un utilisateur clique sur le bouton de paiement d'une commande, le coordinateur reçoit l'événement correspondant et sait que l'étape suivante consiste à ouvrir l'écran de paiement.  Dans iOS, le coordinateur est utilisé comme localisateur de services pour créer des ViewControllers et contrôler la pile arrière.  Cela suffit pour le coordinateur (rappelez-vous le principe de la responsabilité exclusive).  Dans les applications Android, le système crée des activités, nous avons de nombreux outils pour implémenter les dépendances et il y a un backstack pour les activités et les fragments.  Revenons maintenant à l'idée originale du coordinateur: le coordinateur sait simplement quel écran sera le prochain. <br><br><h3>  Exemple: application d'actualités utilisant un coordinateur </h3><br>  Parlons enfin directement du modèle.  Imaginez que nous devons créer une application de nouvelles simple.  L'application dispose de 2 écrans: «liste d'articles» et «texte d'article», qui s'ouvre en cliquant sur un élément de la liste. <br><br><img src="https://habrastorage.org/webt/yw/oy/cl/ywoycl_vvhclm0s6wlwkzpcgzpk.png"><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsFlowCoordinator</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigator : Navigator) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showNewsList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNewsArticle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ navigator.showNewsArticle(id) } }</code> </pre><br>  Un script (Flow) contient un ou plusieurs écrans.  Dans notre exemple, le scénario de l'actualité se compose de 2 écrans: «liste d'articles» et «texte d'article».  Le coordinateur était extrêmement simple.  Lorsque l'application démarre, nous appelons NewsFlowCoordinator # start () pour afficher une liste d'articles.  Lorsqu'un utilisateur clique sur un élément de la liste, la méthode NewsFlowCoordinator # readNewsArticle (id) est appelée et un écran avec le texte intégral de l'article s'affiche.  Nous travaillons toujours avec le navigateur (nous en reparlerons un peu plus tard), auquel nous déléguons l'ouverture de l'écran.  Le coordinateur n'a pas d'état, il ne dépend pas de l'implémentation du back-end et implémente une seule fonction: il détermine où aller ensuite. <br><br>  Mais comment connecter le coordinateur à notre modèle de présentation?  Nous suivrons le principe de l'inversion de dépendance: nous passerons le lambda au modèle de vue, qui sera appelé lorsque l'utilisateur tapotera sur l'article. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsListViewModel</span></span></span></span>( newsRepository : NewsRepository, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onNewsItemClicked: ( (<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )? ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newsArticles = MutableLiveData&lt;List&lt;News&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> disposable = newsRepository.getNewsArticles().subscribe { newsArticles.value = it } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newsArticleClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ onNewsItemClicked!!(id) <span class="hljs-comment"><span class="hljs-comment">// call the lambda } override fun onCleared() { disposable.dispose() onNewsItemClicked = null // to avoid memory leaks } }</span></span></code> </pre><br>  onNewsItemClicked: (Int) -&gt; Unit est un lambda qui a un argument entier et renvoie Unit.  Veuillez noter que lambda peut être nul, cela nous permettra d'effacer le lien afin d'éviter une fuite de mémoire.  Le créateur du modèle de vue (par exemple, une dague) doit transmettre un lien vers la méthode coordinatrice: <br><br><pre> <code class="hljs lisp">return NewsListViewModel( <span class="hljs-name"><span class="hljs-name">newsRepository</span></span> = newsRepository, onNewsItemClicked = newsFlowCoordinator:<span class="hljs-symbol"><span class="hljs-symbol">:readNewsArticle</span></span> )</code> </pre><br>  Plus tôt, nous avons mentionné le navigateur, qui effectue le changement d'écrans.  La mise en œuvre du navigateur est à votre discrétion, car elle dépend de votre approche spécifique et de vos préférences personnelles.  Dans notre exemple, nous utilisons une activité avec plusieurs fragments (un écran - un fragment avec son propre modèle de présentation).  Je donne une implémentation naïve d'un navigateur: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Navigator</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activity : FragmentActivity? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showNewsList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ activty!!.supportFragmentManager .beginTransaction() .replace(R.id.fragmentContainer, NewsListFragment()) .commit() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showNewsDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(newsId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { activty!!.supportFragmentManager .beginTransaction() .replace(R.id.fragmentContainer, NewsDetailFragment.newInstance(newsId)) .addToBackStack(<span class="hljs-string"><span class="hljs-string">"NewsDetail"</span></span>) .commit() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContentView(R.layout.activity_main) navigator.activty = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() navigator.activty = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-comment"><span class="hljs-comment">// Avoid memory leaks } }</span></span></code> </pre><br>  La mise en œuvre ci-dessus du navigateur n'est pas idéale, mais l'idée principale de ce message est d'introduire un coordinateur dans le modèle.  Il convient de noter que, puisque le navigateur et le coordinateur n'ont pas d'état, ils peuvent être déclarés dans l'application (par exemple, les étendues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Singleton</a> dans un poignard) et peuvent être instanciés dans Application # onCreate (). <br><br>  Ajoutons une autorisation à notre application.  Nous allons définir un nouvel écran de connexion (LoginFragment + LoginViewModel, pour plus de simplicité, nous allons omettre la récupération et l'enregistrement des mots de passe) et LoginFlowCoordinator.  Pourquoi ne pas ajouter de nouvelles fonctionnalités à NewsFlowCoordinator?  Nous ne voulons pas avoir un God-Coordinator qui sera responsable de toute la navigation dans l'application?  De plus, le script d'autorisation ne s'applique pas au scénario du lecteur de news, non? <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginFlowCoordinator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigator: Navigator ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showLogin() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerNewUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showRegistration() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forgotPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showRecoverPassword() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> usermanager: Usermanager, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onSignUpClicked: ( () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )?, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onForgotPasswordClicked: ( () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )? ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(username : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, password : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ usermanager.login(username, password) ... } ... }</code> </pre><br>  Ici, nous voyons que pour chaque événement d'interface utilisateur, il existe un lambda correspondant, mais il n'y a pas de lambda pour le rappel d'une connexion réussie.  C'est aussi un détail d'implémentation et vous pouvez ajouter le lambda correspondant, mais j'ai une meilleure idée.  Ajoutons un RootFlowCoordinator et souscrivons aux modifications du modèle. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootFlowCoordinator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> usermanager: Usermanager, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loginFlowCoordinator: LoginFlowCoordinator, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newsFlowCoordinator: NewsFlowCoordinator, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onboardingFlowCoordinator: OnboardingFlowCoordinator ) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { usermanager.currentUser.subscribe { user -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (user){ <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NotAuthenticatedUser -&gt; loginFlowCoordinator.start() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AuthenticatedUser -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.onBoardingCompleted) newsFlowCoordinator.start() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> onboardingFlowCoordinator.start() } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onboardingCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ newsFlowCoordinator.start() } }</code> </pre><br>  Ainsi, RootFlowCoordinator sera le point d'entrée de notre navigation au lieu de NewsFlowCoordinator.  Concentrons-nous sur le RootFlowCoordinator.  Si l'utilisateur est connecté, nous vérifions s'il a terminé l'intégration (plus d'informations à ce sujet plus tard) et commençons le script pour les actualités ou l'intégration.  Veuillez noter que LoginViewModel n'est pas impliqué dans cette logique.  Nous décrivons le scénario d'intégration. <br><br><img src="https://habrastorage.org/webt/hm/dg/nq/hmdgnqdu3xrkvkkisqk0xdo5mnw.png"><br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OnboardingFlowCoordinator</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">navigator</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Navigator</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">onboardingFinished</span></span></span><span class="hljs-class">: () -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class"> // this is </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RootFlowCoordinator</span></span></span><span class="hljs-class">.onboardingCompleted() ) { fun start(){ navigator.showOnboardingWelcome() } fun welcomeShown(){ navigator.showOnboardingPersonalInterestChooser() } fun onboardingCompleted(){ onboardingFinished() } }</span></span></code> </pre><br>  Onboarding est démarré en appelant OnboardingFlowCoordinator # start (), qui affiche WelcomeFragment (WelcomeViewModel).  Après avoir cliqué sur le bouton "Suivant", la méthode OnboardingFlowCoordinator # welcomeShown () est appelée.  Ce qui montre l'écran suivant PersonalInterestFragment + PersonalInterestViewModel, sur lequel l'utilisateur sélectionne des catégories de nouvelles intéressantes.  Après avoir sélectionné les catégories, l'utilisateur appuie sur le bouton «Suivant» et la méthode OnboardingFlowCoordinator # onboardingCompleted () est appelée, qui procède par proxy à l'appel à RootFlowCoordinator # onboardingCompleted (), qui lance NewsFlowCoordinator. <br>  Voyons comment le coordinateur peut simplifier le travail avec les tests A / B.  J'ajouterai un écran avec une offre pour effectuer un achat dans l'application et le montrerai à certains utilisateurs. <br><br><img src="https://habrastorage.org/webt/e7/ok/a8/e7oka8yuwnttopnufiday2904iw.png"><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsFlowCoordinator</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigator : Navigator, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> abTest : AbTest ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showNewsList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNewsArticle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ navigator.showNewsArticle(id) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeNews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abTest.isB){ navigator.showInAppPurchases() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { navigator.closeNews() } } }</code> </pre><br>  Encore une fois, nous n'avons ajouté aucune logique à la vue ou à son modèle.  Avez-vous décidé d'ajouter InAppPurchaseFragment à l'intégration?  Pour ce faire, il vous suffit de changer le coordinateur d'intégration, car le fragment de magasinage et son modèle de vue sont complètement indépendants des autres fragments et nous pouvons le réutiliser librement dans d'autres scénarios.  Le coordinateur aidera également à mettre en œuvre le test A / B, qui compare deux scénarios d'intégration. <br><br>  Des sources complètes peuvent être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouvées sur le github</a> , et pour les paresseux j'ai préparé une démo vidéo <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PfRLZeRLvTo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Conseil utile: en utilisant kotlin, vous pouvez créer un dsl pratique pour décrire les coordinateurs sous la forme d'un graphique de navigation. <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newsFlowCoordinator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(navigator, abTest)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigator</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showNewsList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNewsArticle</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span><span class="hljs-function"> -&gt;</span></span> navigator.showNewsArticle(id) } closeNews { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abTest.isB){ navigator.showInAppPurchases() } else { navigator.closeNews() } } }</code> </pre><br><h3>  Résumé: </h3><br>  Le coordinateur aidera à apporter la logique de navigation au composant faiblement couplé testé.  Pour le moment, il n'y a pas de bibliothèque prête pour la production, je n'ai décrit que le concept de résolution du problème.  Le coordinateur est-il applicable à votre candidature?  Je ne sais pas, cela dépend de vos besoins et de la facilité avec laquelle il sera intégré à l'architecture existante.  Il pourrait être utile d'écrire une petite application en utilisant un coordinateur. <br><br><h5>  FAQ: </h5><br>  <i>L'article ne mentionne pas l'utilisation d'un coordinateur avec un modèle MVI.</i>  <i>Est-il possible d'utiliser un coordinateur avec cette architecture?</i>  Oui, j'ai un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article séparé</a> . <br><br>  <i>Google a récemment introduit le contrôleur de navigation dans le cadre d'Android Jetpack.</i>  <i>Quel est le lien entre le coordinateur et la navigation Google?</i>  Vous pouvez utiliser le nouveau contrôleur de navigation au lieu du navigateur dans les coordinateurs ou directement dans le navigateur au lieu de créer manuellement des transactions de fragments. <br><br>  <i>Et si je ne veux pas utiliser de fragments / activité et que je veux écrire mon propre back-end pour gérer les vues - pourrai-je utiliser le coordinateur dans mon cas?</i>  J'y ai également réfléchi et je travaille sur un prototype.  J'écrirai à ce sujet sur mon blog.  Il me semble que la machine d'état simplifiera considérablement la tâche. <br><br>  <i>Le coordinateur est-il attaché à l'approche de candidature à une seule activité?</i>  Non, vous pouvez l'utiliser dans différents scénarios.  L'implémentation de la transition entre les écrans est masquée dans le navigateur. <br><br>  <i>Avec l'approche décrite, vous obtenez un énorme navigateur.</i>  <i>Nous avons en quelque sorte essayé de nous éloigner de Dieu-Object'a?</i>  Nous ne sommes pas tenus de décrire le navigateur dans une classe.  Créez plusieurs petits navigateurs pris en charge, par exemple, un navigateur distinct pour chaque scénario utilisateur. <br><br>  <i>Comment travailler avec des animations de transition continue?</i>  <i>Décrivez les animations de transition dans le navigateur, puis l'activité / le fragment ne saura rien de l'écran précédent / suivant.</i>  <i>Comment le navigateur sait-il quand démarrer l'animation?</i>  Supposons que nous voulons montrer une animation de la transition entre les fragments A et B. Nous pouvons souscrire à l'événement onFragmentViewCreated (v: View) à l'aide de FragmentLifecycleCallback et lorsque cet événement se produit, nous pouvons travailler avec des animations de la même manière que nous l'avons fait directement dans le fragment: ajouter OnPreDrawListener d'attendre d'être prêt et d'appeler startPostponedEnterTransition ().  De la même manière, vous pouvez implémenter une transition animée entre une activité à l'aide de ActivityLifecycleCallbacks ou entre ViewGroup à l'aide de OnHierarchyChangeListener.  N'oubliez pas de vous désabonner des événements ultérieurement pour éviter les fuites de mémoire. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416301/">https://habr.com/ru/post/fr416301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416291/index.html">Comment construire une architecture IIoT à faire soi-même. Partie 2: «Choses»</a></li>
<li><a href="../fr416293/index.html">Un avion électrique hybride réduira les émissions et le bruit</a></li>
<li><a href="../fr416295/index.html">Le plus grand télescope du monde pourra enfin voir les étoiles sans rayons de diffraction</a></li>
<li><a href="../fr416297/index.html">plug-in ml-agent pour l'unité</a></li>
<li><a href="../fr416299/index.html">Les gens suivent les glaciers en Islande depuis des décennies; Maintenant, la technique le fera</a></li>
<li><a href="../fr416303/index.html">Recréer le premier déclencheur</a></li>
<li><a href="../fr416305/index.html">La normalisation est la plus longue aventure de l'Internet des objets</a></li>
<li><a href="../fr416307/index.html">iOS 12: nouveau dans les notifications</a></li>
<li><a href="../fr416309/index.html">Comment utiliser les fichiers HDF5 en Python</a></li>
<li><a href="../fr416313/index.html">Liste de contrôle d'analyse du journal des événements de sécurité</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>