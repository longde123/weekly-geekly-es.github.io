<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤐 ⛅️ 🚶🏻 Implementación de PPPOS en stm32f4-discovery 🎳 👑 ♊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez, antes de mí, había una tarea para proporcionar acceso a Internet en el STM32 teniendo para esto solo un puerto COM. Para resolver este proble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementación de PPPOS en stm32f4-discovery</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419037/">  Una vez, antes de mí, había una tarea para proporcionar acceso a Internet en el STM32 teniendo para esto solo un puerto COM.  Para resolver este problema, necesitaba PPP o, para ser precisos, PPPoS (Protocolo punto a punto sobre serie, una de las formas de implementar PPP, se usa cuando se conecta a través del puerto COM). <br><br>  En el proceso de resolver la tarea que tenía ante mí, me encontré con algunas dificultades, una de las cuales, en mi opinión, era la cobertura insuficiente de los problemas relacionados con PPPoS en Internet.  Con esta publicación intentaré cerrar la brecha designada, en la medida en que lo permita mi modesto conocimiento. <br><br>  Este artículo describe cómo crear un proyecto para System Workbench para STM32 desde cero.  Muestra un ejemplo de trabajo con UART.  Hay ejemplos de código para implementar PPP.  Y, por supuesto, un ejemplo de enviar un mensaje a una computadora vecina. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  PPP (Protocolo punto a punto) es un protocolo de enlace de datos de dos puntos del modelo de red OSI.  Por lo general, se usa para establecer comunicación directa entre dos nodos de red, y puede proporcionar autenticación de conexión, cifrado y compresión de datos.  Se utiliza en muchos tipos de redes físicas: cable de módem nulo, línea telefónica, celular, etc. <br><br>  A menudo hay subespecies del protocolo PPP, como el Protocolo punto a punto a través de Ethernet (PPPoE), que se utiliza para conectarse a través de Ethernet y, a veces, a través de DSL;  y el Protocolo punto a punto sobre ATM (PPPoA), que se utiliza para la conexión a través de la Capa de adaptación ATM 5 (AAL5), que es la principal alternativa PPPoE para DSL. <br><br>  PPP es una familia de protocolos: Protocolo de control de enlace (LCP), Protocolo de control de red (NCP), Protocolos de autenticación (PAP, CHAP), PPP multicanal (MLPPP). <br><br>  <i>De Wikipedia</i> <br><br><h3>  Preparación </h3><br>  Para resolver el problema necesitamos: <br><br><h4>  Hierro: </h4><br><ol><li>  Placa de depuración stm32f4_discovery: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u1/0k/6-/u10k6-una1bkmaphl4wlazibaca.jpeg"></div></li><li>  Adaptador USB a miniUSB para conectar la placa a una computadora. </li><li>  Dos adaptadores USBtoUART FT232: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/uk/mo/uhukmolq4_t-pckn8h2rjofspnu.png"></div></li><li>  Dos cables de extensión USB también son útiles, no necesariamente, sino simplemente convenientes. </li></ol><br><h4>  Suave: </h4><br><ol><li>  Máquina virtual VirtualBox.  Puedes descargarlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  También descargamos e instalamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete de extensión</a> para VirtualBox. </li><li>  Dos discos de instalación con los sistemas operativos Windows y Linux.  Tomamos Windows <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Después de instalar el sistema operativo, deberá instalar complementos para el sistema operativo invitado.  Para la tarea tenemos suficientes sistemas 32x, no puede engañar con la inclusión de la virtualización. </li><li>  Para Windows, necesitamos un programa que pueda aceptar solicitudes y responderlas a través de TCP / IP, y un programa de terminal para trabajar con un puerto COM.  Descargue PacketSender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> (haga clic en "No, gracias, déjeme descargar"). El terminal está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Además, necesitamos STM32CubeMX para la configuración inicial del proyecto.  Descargar desde st.com (después del registro, el enlace se enviará por correo electrónico). </li><li>  Ponemos System Workbench para STM32 en el sistema operativo principal.  Descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aquí</a> (se requiere registro). </li></ol><br><h3>  Etapa 1. Creando un proyecto </h3><br>  En primer lugar, abra STM32CubeMX y cree un nuevo proyecto allí para nuestra placa de descubrimiento stm32f4.  Encienda RCC, Ethernet (ETH), SYS, USART2, USART3, luego encienda FREERTOS y LWIP. <br><br><img src="https://habrastorage.org/webt/vr/jk/ve/vrjkveavft5ry-oasa7h2e07rwe.png"><br><img src="https://habrastorage.org/webt/9c/v2/rv/9cv2rv-_8yf5w67mr7bw7ynp1vk.png"><br><br>  Para el diagnóstico, necesitamos LED en el tablero.  Para esto, configure las patas de PD12-PD15 como GPIO_Output. <br><br><img src="https://habrastorage.org/webt/-s/bb/lk/-sbblkybmbdz1wrftiow38tq4eg.png"><br><br>  En la pestaña Configuración del reloj, configure la frecuencia, como en la imagen a continuación. <br><br><img src="https://habrastorage.org/webt/sd/cc/qy/sdccqyreetba7g_m8yq_gypc-ge.png"><br><br>  A continuación, en la pestaña Configuración, configure los puertos USART.  Trabajaremos con ellos en modo DMA.  Tenemos dos puertos USART, uno que usaremos para transmitir y recibir datos a través de PPP, el segundo para el registro.  Para que funcionen, necesitamos configurar DMA en RX y TX para ambos puertos.  Para todas las patas de ajuste de DMA, establezca Medio en prioridad.  Para USART2 leg RX, configure el modo en "Circular".  El resto de la configuración se deja por defecto. <br><br><img src="https://habrastorage.org/webt/96/s8/9u/96s89uloxfrdtxd0scqvcyb-zng.png"><br><br>  También deberá habilitar la interrupción global para ambos puertos en la pestaña "Configuración de NVIC". <br><br>  Esto completa la configuración inicial del proyecto en STM32CubeMX.  Guardamos el archivo del proyecto y hacemos la generación del código para System Workbench para STM32. <br><br><img src="https://habrastorage.org/webt/ss/_d/8l/ss_d8lzdxneoj5mjasvmyhhhxiu.png"><br><br><h4>  Implementación </h4><br>  Ahora verifiquemos que el código descargado se compila y funciona.  Para hacer esto, en el archivo main.c en la función "StartDefaultTask", reemplazamos el cuerpo del bucle infinito for (;;) con el código LED de encendido y apagado. <br><br>  Debería ser así: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* StartDefaultTask function */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> MX_LWIP_Init(); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Infinite loop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 5 */</span></span> }</code> </pre> <br>  Compilamos el firmware y miramos.  Los cuatro LED deben parpadear en el tablero. <br><br><h3>  Etapa 2. Trabajar con USART </h3><br>  Nuestra siguiente tarea es verificar el correcto funcionamiento de nuestro USART. <br><br>  Lo primero que debemos hacer es conectar nuestro FT232 al descubrimiento.  Para hacer esto, observe en qué patas están divorciadas las interfaces USART.  Lo tengo PD6 y PD5 para USART2_RX y USART2_TX respectivamente. <br><br><img src="https://habrastorage.org/webt/qj/yh/yo/qjyhyoohdofxtqedphuhzq7qcac.png"><br><br>  Además de PD9 y PD8 para USART3_RX y USART3_TX, respectivamente. <br><br><img src="https://habrastorage.org/webt/37/bf/om/37bfomzqqcapediljrf14flpuiu.png"><br><br>  Además, necesitamos un pie GND. <br><br>  Encontramos estos pines en el tablero y los conectamos a los pines FT232, mientras que el pin GND en el tablero puede ser cualquiera, el pin RX en el tablero debe estar conectado al pin TX en el FT232, y el pin TX en el tablero debe estar conectado al pin RX en el FT232.  Las conclusiones restantes no se utilizan. <br><br>  Queda por conectar nuestro FT232 a los puertos USB de la computadora, así como también conectar la placa de descubrimiento a través del conector miniUSB a la computadora (que no debe confundirse con microUSB). <br><br>  Después de conectar FT232, el sistema operativo principal instalará los controladores para ellos, después de lo cual estos dispositivos deberán ser enviados al invitado de Windows en la máquina virtual. <br><br>  Ahora agregamos el código del programa que se necesita para el funcionamiento de nuestro USART.  Para hacer esto, agregaremos cuatro archivos: usart.h, usart.c, logger.h, logger.c. <br><br>  Contenido del archivo: <br><br>  <b>archivo usart.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> void usart_Open(void); bool usart_Send(char* bArray, int size_bArray); uint16_t usart_Recv(char* bArray, uint16_t maxLength); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _USART_ */</span></span></span></span></code> </pre><br>  <b>archivo usart.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmsis_os.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Q_USART2_SIZE 200 xQueueHandle g_qUsart; osThreadId g_usart_rxTaskHandle; extern UART_HandleTypeDef huart2; void usart_rxTask(void); uint8_t bGet[Q_USART2_SIZE] = {0}; uint16_t g_tail = 0; void usart_Open(void) { g_qUsart = xQueueCreate( Q_USART2_SIZE, sizeof( unsigned char ) ); osThreadDef(usart_rxTask_NAME, usart_rxTask, osPriorityNormal, 0, Q_USART2_SIZE/4+128); g_usart_rxTaskHandle = osThreadCreate(osThread(usart_rxTask_NAME), NULL); HAL_UART_Receive_DMA(&amp;huart2, bGet, Q_USART2_SIZE); } void usart_rxTask(void) { for(;;) { uint16_t length = Q_USART2_SIZE - huart2.hdmarx-&gt;Instance-&gt;NDTR; while(length - g_tail) { uint8_t tmp = bGet[g_tail]; xQueueSendToBack( g_qUsart, &amp;tmp, 100 ); g_tail++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (g_tail == Q_USART2_SIZE) g_tail = 0; } } } bool usart_Send(char* bArray, int size_bArray) { HAL_StatusTypeDef status; status = HAL_UART_Transmit_DMA(&amp;huart2, bArray, size_bArray); while (HAL_UART_GetState(&amp;huart2) != HAL_UART_STATE_READY) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (HAL_UART_GetState(&amp;huart2) == HAL_UART_STATE_BUSY_RX) break; osDelay(1); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (status == HAL_OK) return true; return false; } uint16_t usart_Recv(char* bArray, uint16_t maxLength) { uint8_t tmp = 0; uint16_t length = 0; while(uxQueueMessagesWaiting(g_qUsart)) { xQueueReceive( g_qUsart, &amp;tmp, 100 ); bArray[length] = tmp; length++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length &gt;= maxLength) break; } return length; }</span></span></code> </pre><br>  <b>archivo logger.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _LOGGER_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _LOGGER_ void logger(const char *format, ...); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _LOGGER_ */</span></span></span></span></code> </pre><br>  <b>archivo logger.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdarg.h&gt; extern UART_HandleTypeDef huart3; #define MAX_STRING_SIZE 1024 HAL_StatusTypeDef logger_Send(char* bArray, uint32_t size_bArray) { HAL_StatusTypeDef status; for(int i=0;i&lt;5;i++) { status = HAL_UART_Transmit_DMA(&amp;huart3, bArray, size_bArray); if (status == HAL_OK) break; osDelay(2); } while (HAL_UART_GetState(&amp;huart3) != HAL_UART_STATE_READY) { osDelay(1); } return status; } void logger(const char *format, ...) { char buffer[MAX_STRING_SIZE]; va_list args; va_start (args, format); vsprintf(buffer, format, args); va_end(args); buffer[MAX_STRING_SIZE-1]=0; logger_Send(buffer, strlen(buffer)); }</span></span></span></span></code> </pre><br>  Necesitamos usart para transmitir y recibir datos en usart2.  Será nuestra interfaz principal para comunicarnos con un servidor PPP. <br><br>  Necesitamos Logger para implementar el registro enviando mensajes a la terminal.  La función void usart_Open (void) forma una cola e inicia la tarea de dar servicio a esta cola.  Esta función debe completarse antes de usar USART.  Entonces todo es simple, la función bool usart_Send (char * bArray, int size_bArray) envía datos al puerto, y <br>  uint16_t usart_Recv (char * bArray, uint16_t maxLength) los obtiene de la cola en la que la función void usart_rxTask (void) los ha agregado amablemente. <br><br>  Para el registrador, todavía es más simple; no hay necesidad de obtener datos, por lo tanto, ni la cola ni la tarea de mantenimiento de la cola son necesarias. <br><br>  Al comienzo del archivo <b>main.h</b> , debe agregar varias definiciones que describan el tipo bool, que no está disponible en C. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> true 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> false 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span></span></code> </pre><br>  Ahora es el momento de verificar la funcionalidad del código resultante.  Para hacer esto, en el archivo <b>main.c</b> , cambie el código de la tarea ya conocida "StartDefaultTask" <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_MESSAGE_LENGTH 100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> MX_LWIP_Init(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span></span><span class="hljs-meta"> usart_Open(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Infinite loop */</span></span></span><span class="hljs-meta"> uint8_t send[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Send message\r\n"</span></span></span><span class="hljs-meta">; uint8_t recv[MAX_MESSAGE_LENGTH] = {0}; uint16_t recvLength = 0; for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (usart_Send(send, sizeof(send)-1)) logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SEND - %s"</span></span></span><span class="hljs-meta">, send); recvLength = usart_Recv(recv, MAX_MESSAGE_LENGTH-1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (recvLength) { recv[recvLength] = 0; logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RECV - %s\r\n"</span></span></span><span class="hljs-meta">, recv); } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 5 */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  Además, necesitamos dar más memoria a la pila de nuestra tarea.  Para hacer esto, en la llamada a la función osThreadDef (), el archivo main.c, necesita corregir 128 por 128 * 10 para obtener esto: <br><br><pre> <code class="hljs lisp">osThreadDef(<span class="hljs-name"><span class="hljs-name">defaultTask</span></span>, StartDefaultTask, osPriorityNormal, <span class="hljs-number"><span class="hljs-number">0</span></span>, &lt;b&gt;128*10&lt;/b&gt;)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Compilamos y flasheamos.  Los LED parpadean de la misma manera que en la tarea anterior. <br><br>  Para ver el resultado de nuestro trabajo, debe ejecutar el programa Terminal en nuestra máquina virtual.  Una instancia del programa para el puerto de registro, la segunda para el principal.  Mire en el administrador de dispositivos qué números de puerto se asignaron a su FT232.  Si a los números se les ha asignado más de 10, reasigne. <br><br>  Cuando inicia la segunda instancia del programa, puede producirse un error, cierre la ventana con el error y continúe trabajando con el programa. <br><br>  Para ambos puertos establecemos una conexión a 115200 baudios, bits de datos - 8, paridad - ninguno, bits de parada - 1, apretón de manos - ninguno. <br><br>  Si hizo todo correctamente, en la ventana de terminal para usart2 se transmitirá el mensaje "Enviar mensaje".  El mismo mensaje se duplicará en la ventana de terminal para el registrador solo con el prefijo "ENVIAR -" <br><br>  Si en la ventana de terminal para usart2 escribe texto en el campo "Enviar" y hace clic en el botón correspondiente a la derecha de este campo, en la ventana del registrador verá el mismo mensaje con el prefijo "RECV -" <br><br>  En la imagen a continuación: a la izquierda está el registrador, a la derecha está usart2. <br><br><img src="https://habrastorage.org/webt/k5/v6/hc/k5v6hcxebj6hfdgbitfwyzs1ffw.png"><br><br><h3>  Etapa 3. Comenzando con PPP </h3><br>  Como parte de esta tarea, crearemos una conexión PPP.  En primer lugar, habilite el uso de PPP, cambie el valor de la definición PPP_SUPPORT en el archivo ppp_opts.h a 1. Luego redefinimos las definiciones necesarias en el archivo lwipopts.h, <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEMP_NUM_SYS_TIMEOUT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_IP 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_TCP 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 1 */</span></span></span></span></code> </pre><br>  Al mismo tiempo, las definiciones antiguas deben comentarse. <br><br>  Ahora modificamos el archivo lwip.c, inserte el siguiente código en el bloque "/ * USER CODE BEGIN 0 * /": <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pppos.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp.h"</span></span></span><span class="hljs-meta"> static ppp_pcb *ppp; struct netif pppos_netif; void PppGetTask(void const * argument) { uint8_t recv[2048]; uint16_t length = 0; for(;;) { length=usart_Recv(recv, 2048); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length) { pppos_input(ppp, recv, length); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"read - PppGetTask() len = %d\n"</span></span></span><span class="hljs-meta">, length); } osDelay(10); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ip4_addr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx) { struct netif *pppif = ppp_netif(pcb); LWIP_UNUSED_ARG(ctx); switch(err_code) { case PPPERR_NONE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No error. */</span></span></span><span class="hljs-meta"> { logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_NONE\n\r"</span></span></span><span class="hljs-meta">); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" our_ip4addr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_addr(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" his_ipaddr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_gw(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" netmask = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_netmask(pppif))); } break; case PPPERR_PARAM: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid parameter. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PARAM\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_OPEN: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to open PPP session. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_OPEN\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_DEVICE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid I/O device for PPP. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_DEVICE\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_ALLOC: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to allocate resources. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_ALLOC\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_USER: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* User interrupt. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_USER\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection lost. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_AUTHFAIL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed authentication challenge. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_AUTHFAIL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PROTOCOL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed to meet protocol. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PROTOCOL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PEERDEAD: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PEERDEAD\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_IDLETIMEOUT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Idle Timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_IDLETIMEOUT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECTTIME: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PPPERR_CONNECTTIME. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECTTIME\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_LOOPBACK: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_LOOPBACK\n"</span></span></span><span class="hljs-meta">); break; default: logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: unknown errCode %d\n"</span></span></span><span class="hljs-meta">, err_code); break; } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Callback used by ppp connection static u32_t ppp_output_cb(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx) { LWIP_UNUSED_ARG(pcb); LWIP_UNUSED_ARG(ctx); if (len &gt; 0) { if (!usart_Send(data, len)) return 0x05; } logger("write - ppp_output_cb() len = %d\n", len); return len; } void pppConnect(void) { ppp = pppos_create(&amp;pppos_netif, ppp_output_cb, ppp_link_status_cb, NULL); ppp_set_default(ppp); osThreadId PppGetTaskHandle; osThreadDef(PPP_GET_TASK_NAME, PppGetTask, osPriorityNormal, 0, 128*10); PppGetTaskHandle = osThreadCreate(osThread(PPP_GET_TASK_NAME), NULL); err_t err = ppp_connect(ppp,0); if (err == ERR_ALREADY) { logger("Connected successfully"); } for(int i=0;i&lt;40;i++) { osDelay(500); if (ppp-&gt;phase &gt;= PPP_PHASE_RUNNING) break; } } /* USER CODE END 0 */</span></span></span></span></code> </pre><br>  Luego, en la función MX_LWIP_Init (), en el bloque "/ * USER CODE BEGIN 3 * /" agregamos una llamada a la función pppConnect (). <br><br>  Además, debe aumentar el tamaño del almacenamiento dinámico, para esto, en el archivo FreeRTOSConfig.h, debe comentar la definición de configTOTAL_HEAP_SIZE y, al final del archivo, en el / * CÓDIGO DE USUARIO COMIENZA Define * / block, declararlo con un nuevo valor. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Defines */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configTOTAL_HEAP_SIZE ((size_t)1024*30) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Defines */</span></span></span></span></code> </pre><br>  Además, en el archivo usart.c, cambie el valor de la definición Q_USART2_SIZE a 2048. <br><br>  La configuración de la conexión comienza con la función MX_LWIP_Init (); se creó automáticamente; acabamos de agregarle una llamada a la función pppConnect ().  En esta función, se inician las tareas que sirven a la conexión PPPOS.  Las funciones pppos_create () necesitan pasar las direcciones de las funciones que servirán para enviar mensajes y la salida de información sobre el cambio del estado de la conexión.  Para nosotros, estas son las funciones ppp_output_cb () y ppp_link_status_cb (), respectivamente.  Además, la función pppConnect () iniciará la tarea de atender los mensajes recibidos.  Al final de su operación, la función pppConnect () esperará a que se establezca una conexión con el servidor y luego completará su operación. <br><br>  El trabajo con la red se realizará a un nivel superior, tan pronto como LWIP decida que es necesario enviar un mensaje a la red, la función ppp_output_cb () se llamará automáticamente.  La respuesta de la red será recibida por la función PppGetTask (), como parte de la tarea de atender los mensajes entrantes, y transferida a las entrañas de LWIP.  Si el estado de la conexión cambia, la función ppp_link_status_cb () se llamará automáticamente. <br><br>  Finalmente, modificaremos la tarea StartDefaultTask.  Ahora debería verse así: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> <span class="hljs-comment"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); } /* USER CODE END 5 */ }</span></span></code> </pre><br>  Hecho, puedes compilar y flashear. <br><br>  En este punto, debe iniciar el servidor PPP.  Para hacer esto, primero debe implementar una máquina virtual con Linux.  Usé Ubuntu 16.04 x32.  Después de instalar el sistema operativo, debe configurar el uso del puerto COM. <br><br>  En esta parte, no necesitamos una máquina virtual con Windows, podemos apagarla de manera segura.  Conectamos ambos FT232 en Linux. <br><br>  En Linux, antes de comenzar a trabajar con un puerto COM, debe permitir que el usuario lo use.  Para hacer esto, ejecute el siguiente comando: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> addgroup USERNAME dialout</code> </pre> <br>  donde USERNAME es el nombre del usuario actual. <br><br>  Para ver los puertos disponibles en el sistema COM, debe ejecutar el comando: <br><br><pre> <code class="hljs perl">dmesg | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> tty</code> </pre> <br><img src="https://habrastorage.org/webt/zc/h4/mp/zch4mpfwyybln76dl1jnhpxjt0s.png"><br><br>  Vemos que hay dos puertos ttyUSB en el sistema.  No podemos decir de inmediato cuál es el registrador y cuál es usart2.  Solo necesita verificarlos a su vez. <br><br>  Primero, ejecute los comandos para leer desde un puerto: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB0 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB0</code> </pre> <br>  luego de otro: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB1</code> </pre> <br>  Donde vemos esa imagen, eso es registrador. <br><br><img src="https://habrastorage.org/webt/u0/cu/zc/u0cuzcnbhzppwdhpibm2o6zelpk.png"><br><br>  Puede salir de esta ventana, no nos molestará. <br><br>  A continuación, debe permitir que los paquetes enviados desde nuestra placa salgan de los límites de su subred.  Para hacer esto, configure iptables.  Realizamos las siguientes acciones: <br><br>  1. Abra una nueva ventana de consola <br>  2. Necesita averiguar su ip y el nombre de la interfaz de red (ejecute el comando <b>ifconfig</b> ) <br><br><img src="https://habrastorage.org/webt/jy/d4/9s/jyd49satpc3erdlzeddi44gwcy4.png"><br><br>  3. Ejecute los comandos de configuración nat <br><br><pre> <code class="hljs powershell">sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_forward &gt; /dev/null sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_dynaddr &gt; /dev/null sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> FORWARD sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-A</span></span> POSTROUTING <span class="hljs-literal"><span class="hljs-literal">-o</span></span> enp0s3 <span class="hljs-literal"><span class="hljs-literal">-j</span></span> SNAT -<span class="hljs-literal"><span class="hljs-literal">-to</span></span><span class="hljs-literal"><span class="hljs-literal">-source</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">10.196</span></span> sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-L</span></span></code> </pre> <br>  donde enp0s3 es el nombre de la interfaz de red <br>  192.168.10.196 - su dirección IP <br>  / proc / sys / net / ipv4 / - ruta al archivo correspondiente. <br><br>  Estos comandos pueden reescribirse en un archivo por lotes y ejecutarlo cada vez antes de iniciar el servidor PPP.  Puede agregarlo a la ejecución automática, pero no lo hice. <br><br>  Ahora estamos listos para iniciar el servidor, solo queda crear un archivo de configuración.  Lo llamé " <b>pppd.conf</b> ", sugiero usar la siguiente configuración: <br><br><pre> <code class="hljs pgsql">nodetach noauth passive <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> lcp-echo-<span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> lcp-echo-failure <span class="hljs-number"><span class="hljs-number">1</span></span> cdtrcts</code> </pre> <br>  Reescribimos la configuración en un archivo y luego puede iniciar el servidor.  Esto se hace con el <b>comando sudo pppd file ./pppd.conf</b> <br><br>  El servidor PPPD debe iniciarse antes del inicio del descubrimiento, por lo que después del inicio de PPPD debe hacer clic en el botón "Restablecer" ubicado en la placa. <br><br>  Si hizo todo correctamente, verá la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/kv/-p/lj/kv-pljob3duk3bigzj3iazcsasa.png"><br><br>  Ejecutando pppd a la izquierda, registrador a la derecha. <br><br><h3>  Etapa 4. Enviamos una bolsa </h3><br>  En esta etapa, necesitamos ambas máquinas virtuales.  Linux para pppd y Windows para recibir el paquete.  Para simplificar la tarea, necesita que ambas máquinas estén en la misma subred, la solución ideal sería especificar una conexión de puente de red para ambas máquinas en la configuración de red de VirtualBox y desactivar el firewall en Windows. <br><br>  Iniciamos las máquinas virtuales y configuramos la conexión ppp de la placa de descubrimiento con pppd.  En Windows, descubrimos la dirección IP de la máquina (comando ipconfig), la obtuve 192.168.10.97. <br><br>  Inicie Packet Sender y configúrelo de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/k8/zt/uv/k8ztuv4eccjueyvlk8gigjbmkj0.png"><br><br>  Ahora nuevamente, modifique la tarea StartDefaultTask en el archivo <b>main.c.</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sockets.h"</span></span></span><span class="hljs-meta"> typedef uint32_t SOCKET; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ uint8_t sendStr[]="Test message TCP/IP."; uint8_t resvStr[100]={0}; int resvLength = 0; struct sockaddr_in sockAddr; sockAddr.sin_family = AF_INET; sockAddr.sin_port = htons( 6565 ); uint32_t addr = inet_addr("192.168.10.97"); sockAddr.sin_addr.s_addr = addr; SOCKET socket = NULL; int nError = 0; /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); socket = socket( AF_INET, SOCK_STREAM, 0 ); nError = connect( socket, (struct sockaddr*)&amp;sockAddr, sizeof(sockAddr) ); if ( nError == 0 ) { nError = send( socket, sendStr, sizeof(sendStr)-1, 0 ); if ( nError &lt; 0 ) logger("SEND ERROR %d\n", nError); else { logger("SEND - %s\n", sendStr); resvLength = 0; while(resvLength &lt; 1) resvLength = lwip_recv( socket, resvStr, sizeof(resvStr), MSG_WAITALL); resvStr[resvLength]=0; logger("GET - %s\n", resvStr); } lwip_close(socket); } else logger("CONNECT ERROR %d\n", nError); } /* USER CODE END 5 */ }</span></span></span></span></code> </pre><br>  Como valor de la variable addr, usamos la dirección de la máquina Windows, número de puerto 6565. <br>  Mensaje enviado "Mensaje de prueba TCP / IP". Respuesta "Se recibió el mensaje". <br><br>  Aquí puede ver que las funciones PPP no se utilizan directamente para enviar y recibir mensajes.  Todo el trabajo se lleva a cabo en un nivel superior, y nuestras funciones se llaman automáticamente. <br><br>  Compilamos y flasheamos. <br><br>  El resultado de conectarse a pppd es visible en una máquina Linux: <br><br><img src="https://habrastorage.org/webt/il/og/h6/ilogh6wuak7zym8unedcnddcjr4.png"><br><br>  Las solicitudes recibidas y las respuestas enviadas se pueden ver en el programa Packet Sender en una máquina con Windows: <br><br><img src="https://habrastorage.org/webt/30/yh/4m/30yh4m_l52nvlkdixrv9zmivehc.png"><br><br>  Bueno, eso es todo, el paquete enviado por nosotros desde la placa de descubrimiento fue al puerto COM, llegó al servidor pppd, se envió al puerto 6565 de Windows de la máquina, allí se recibió con éxito, en respuesta a él se envió otro paquete que pasó este camino en la dirección opuesta y fue adoptado con éxito en el tablero.  También podría enviar mensajes a cualquier máquina en Internet. <br><br>  → El código completo del proyecto se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419037/">https://habr.com/ru/post/es419037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419025/index.html">Compilación de @Pythonetc, julio de 2018</a></li>
<li><a href="../es419027/index.html">Seguridad de la información de los pagos bancarios sin efectivo. Parte 6 - Análisis del crimen bancario</a></li>
<li><a href="../es419029/index.html">Fortnite se ha convertido en un fenómeno social. Los padres cada vez más contratan entrenadores para sus hijos y juegan con ellos.</a></li>
<li><a href="../es419033/index.html">Una pequeña nota sobre el tema de ejecutar vue.js en el clúster de kubernetes</a></li>
<li><a href="../es419035/index.html">Libro “Head First Agile. Gestión flexible de proyectos ”</a></li>
<li><a href="../es419041/index.html">Los nueve rastrillos de Elasticsearch que pisé</a></li>
<li><a href="../es419043/index.html">El elusivo problema del tiempo de trama</a></li>
<li><a href="../es419047/index.html">Reddit hackeó, filtró la base de datos con contraseñas y correo electrónico para 2005-2007</a></li>
<li><a href="../es419049/index.html">GeekBrains lanza el maratón educativo en línea gratuito "Find Yourself in Digital"</a></li>
<li><a href="../es419051/index.html">Cómo Flant ayuda a los principiantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>