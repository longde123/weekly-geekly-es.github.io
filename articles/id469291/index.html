<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèª üöé ü§≤üèª Inisialisasi dan pengoperasian juru kode bytecode di JVM HotSpot di bawah x86 üéΩ üë©üèø‚Äçüé§ üì†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hampir setiap pengembang Java tahu bahwa program yang ditulis dalam Java pada awalnya dikompilasi menjadi bytecode JVM dan disimpan sebagai file kelas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inisialisasi dan pengoperasian juru kode bytecode di JVM HotSpot di bawah x86</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469291/"><p> Hampir setiap pengembang Java tahu bahwa program yang ditulis dalam Java pada awalnya dikompilasi menjadi bytecode JVM dan disimpan sebagai file kelas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format standar</a> .  Setelah mendapatkan file-kelas seperti itu di dalam mesin virtual dan sampai kompiler belum mencapai mereka, JVM menafsirkan bytecode yang terkandung dalam file-file kelas ini.  Artikel ini memberikan tinjauan umum tentang bagaimana interpreter bekerja sehubungan dengan OpenJDK JVM HotSpot. </p><a name="habracut"></a><br><p>  Isi artikel: </p><br><ul><li>  Lingkungan </li><li>  Menjalankan aplikasi java </li><li>  Inisialisasi juru bahasa dan kontrol transfer ke kode java </li><li>  Contoh </li></ul><br><h4 id="okruzhenie">  Lingkungan </h4><br><p>  Untuk percobaan, kami menggunakan perakitan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">revisi</a> OpenJDK JDK12 terbaru yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia</a> dengan <a href="">konfigurasi autoconf</a> </p><br><pre><code class="plaintext hljs">--enable-debug --with-native-debug-symbols=internal</code> </pre> <br><p>  pada Ubuntu 18.04 / gcc 7.4.0. </p><br><p>  <code>--with-native-debug-symbols=internal</code> -imbol <code>--with-native-debug-symbols=internal</code> berarti bahwa, ketika membangun JDK, simbol debazh akan terkandung dalam binari itu sendiri. </p><br><p>  <code>--enable-debug</code> - bahwa biner akan berisi kode debug tambahan. </p><br><p>  Membangun JDK 12 di lingkungan seperti itu bukanlah proses yang rumit.  Yang perlu saya lakukan adalah menginstal JDK11 ( <a href="">untuk membangun JDK n, JDK n-1 diperlukan</a> ) dan mengirimkan secara otomatis perpustakaan yang diperlukan untuk autoconf.  Selanjutnya, jalankan perintah </p><br><pre> <code class="plaintext hljs">bash configure --enable-debug --with-native-debug-symbols=internal &amp;&amp; make CONF=fastdebug images</code> </pre> <br><p>  dan setelah menunggu sedikit (di laptop saya sekitar 10 menit), kita mendapatkan fastdebug build JDK 12. </p><br><p>  Pada prinsipnya, cukup menginstal jdk dari repositori publik dan juga mengirimkan paket openjdk-xx-dbg dengan simbol debug, di mana xx adalah versi jdk, tetapi rakitan fastdebug menyediakan fungsi debugging dari gdb yang dapat membuat hidup lebih mudah dalam beberapa kasus.  Saat ini, saya aktif menggunakan <a href="">ps ()</a> , sebuah fungsi untuk melihat jejak Java stack dari gdb, dan <a href="">pfl ()</a> , sebuah fungsi untuk menganalisis tumpukan frame (sangat nyaman ketika men-debug penerjemah dalam gdb). </p><br><div class="spoiler">  <b class="spoiler_title">Contoh ps () dan pfl ()</b> <div class="spoiler_text"><p>  Misalnya, perhatikan skrip gdb berikut </p><br><pre> <code class="plaintext hljs">#   java file /home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/java #   SEGV-, HotSpot #  SEGV  . #, https://hg.openjdk.java.net/jdk/jdk12/file/06222165c35f/src/hotspot/cpu/x86/vm_version_x86.cpp#l361 handle SIGSEGV nostop noprint set breakpoint pending on set pagination off #  ,   #    # java- public static void main(String args[]) b PostJVMInit thread 2 commands #   , #    set $buf = (char *) malloc(1000) #        #(   ) b *AbstractInterpreter::_entry_table[0] thread 2 commands #      rbx. #   Method* set $mthd = ((Method *) $rbx) #    $buf call $mthd-&gt;name_and_sig_as_C_string($buf, 1000) # ,  public static void main(String args) if strcmp()("Main.main([Ljava/lang/String;)V", $buf) == 0 #   ,      # ps/pfl        #(    ps/pfl) b InterpreterRuntime::build_method_counters(JavaThread*, Method*) commands #  ,    #   delete breakpoints call ps() call pfl() c end end c end c end r -cp /home/dmitrii/jdk12/ Main</code> </pre> <br><p>  Hasil menjalankan skrip tersebut adalah: </p><br><pre> <code class="plaintext hljs">"Executing ps" for thread: "main" #1 prio=5 os_prio=0 cpu=468,61ms elapsed=58,65s tid=0x00007ffff001b800 nid=0x5bfa runnable [0x00007ffff7fd9000] java.lang.Thread.State: RUNNABLE Thread: 0x00007ffff001b800 [0x5bfa] State: _running _has_called_back 0 _at_poll_safepoint 0 JavaThread state: _thread_in_Java 1 - frame( sp=0x00007ffff7fd9920, unextended_sp=0x00007ffff7fd9920, fp=0x00007ffff7fd9968, pc=0x00007fffd828748b) Main.main(Main.java:10) "Executing pfl" for thread: "main" #1 prio=5 os_prio=0 cpu=468,83ms elapsed=58,71s tid=0x00007ffff001b800 nid=0x5bfa runnable [0x00007ffff7fd9000] java.lang.Thread.State: RUNNABLE Thread: 0x00007ffff001b800 [0x5bfa] State: _running _has_called_back 0 _at_poll_safepoint 0 JavaThread state: _thread_in_Java [Describe stack layout] 0x00007ffff7fd99e0: 0x00007ffff7fd9b00 #2 entry frame call_stub word fp - 0 0x00007ffff7fd99d8: 0x00007ffff7fd9c10 call_stub word fp - 1 0x00007ffff7fd99d0: 0x00007fffd8287160 call_stub word fp - 2 0x00007ffff7fd99c8: 0x00007fffbf1fb3e0 call_stub word fp - 3 0x00007ffff7fd99c0: 0x000000000000000a call_stub word fp - 4 0x00007ffff7fd99b8: 0x00007ffff7fd9ce8 call_stub word fp - 5 0x00007ffff7fd99b0: 0x00007ffff7fd9a80 call_stub word fp - 6 0x00007ffff7fd99a8: 0x00007ffff001b800 call_stub word fp - 7 0x00007ffff7fd99a0: 0x00007ffff7fd9b40 call_stub word fp - 8 0x00007ffff7fd9998: 0x00007ffff7fd9c00 call_stub word fp - 9 0x00007ffff7fd9990: 0x00007ffff7fd9a80 call_stub word fp - 10 0x00007ffff7fd9988: 0x00007ffff7fd9ce0 call_stub word fp - 11 0x00007ffff7fd9980: 0x00007fff00001fa0 call_stub word fp - 12 0x00007ffff7fd9978: 0x0000000716a122b8 sp for #2 locals for #1 unextended_sp for #2 local 0 0x00007ffff7fd9970: 0x00007fffd82719f3 0x00007ffff7fd9968: 0x00007ffff7fd99e0 #1 method Main.main([Ljava/lang/String;)V @ 0 - 1 locals 1 max stack 0x00007ffff7fd9960: 0x00007ffff7fd9978 interpreter_frame_sender_sp 0x00007ffff7fd9958: 0x0000000000000000 interpreter_frame_last_sp 0x00007ffff7fd9950: 0x00007fffbf1fb3e0 interpreter_frame_method 0x00007ffff7fd9948: 0x0000000716a11c40 interpreter_frame_mirror 0x00007ffff7fd9940: 0x0000000000000000 interpreter_frame_mdp 0x00007ffff7fd9938: 0x00007fffbf1fb5e8 interpreter_frame_cache 0x00007ffff7fd9930: 0x00007ffff7fd9978 interpreter_frame_locals 0x00007ffff7fd9928: 0x00007fffbf1fb3d0 interpreter_frame_bcp 0x00007ffff7fd9920: 0x00007ffff7fd9920 sp for #1 interpreter_frame_initial_sp unextended_sp for #1</code> </pre> <br><p>  Seperti yang Anda lihat, dalam kasus <code>ps()</code> kita baru saja mendapatkan stack panggilan, dalam kasus <code>pfl()</code> - organisasi stack penuh. </p></div></div><br><h4 id="zapusk-java-prilozheniya">  Menjalankan aplikasi java </h4><br><p>  Sebelum melanjutkan ke diskusi interpreter secara langsung, kami akan meninjau secara singkat tindakan yang dilakukan sebelum mentransfer kontrol ke kode java.  Misalnya, ambil program Java yang "tidak melakukan apa-apa": </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span></span>{ } }</code> </pre> <br><p>  dan coba cari tahu apa yang terjadi ketika Anda menjalankan aplikasi seperti itu: </p><br><p> <code>javac Main.java &amp;&amp; java Main</code> </p> <br><p>  Hal pertama yang harus dilakukan untuk menjawab pertanyaan ini adalah menemukan dan melihat java binary - yang kami gunakan untuk menjalankan semua aplikasi JVM kami.  Dalam kasus saya, ini terletak di sepanjang jalan </p><br><p>  <code>/home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/java</code> . </p><br><p>  Tetapi pada akhirnya, tidak ada yang istimewa untuk ditonton.  Ini adalah biner yang, bersama dengan simbol debazhnymi hanya membutuhkan 20KB dan dikompilasi dari hanya satu <a href="">peluncur</a> file sumber <a href="">/ main.c.</a> </p><br><p>  Yang dia lakukan adalah menerima argumen baris perintah (char * argv []), <a href="">membaca argumen dari variabel lingkungan JDK_JAVA_OPTIONS</a> , melakukan preprocessing dan validasi dasar (misalnya, Anda tidak dapat menambahkan <a href="">opsi terminal</a> atau nama kelas utama ke variabel lingkungan ini) dan <a href="">memanggil fungsi JLI_Launch</a> dengan daftar argumen yang dihasilkan. </p><br><p>  Definisi fungsi JLI_Launch tidak terkandung dalam java binary dan, jika Anda melihat dependensi langsungnya: </p><br><pre> <code class="plaintext hljs">$ ldd java linux-vdso.so.1 (0x00007ffcc97ec000) libjli.so =&gt; /home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/./../lib/libjli.so (0x00007ff27518d000) // &lt;---------    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff274d9c000) libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007ff274b7f000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff27497b000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff27475c000) /lib64/ld-linux-x86-64.so.2 (0x00007ff27559f000)</code> </pre> <br><p>  Anda dapat melihat <strong>libjli.so</strong> yang terhubung dengannya.  Perpustakaan ini berisi antarmuka peluncur - satu set fungsi yang digunakan java untuk menginisialisasi dan memulai mesin virtual, di antaranya ada JLI_Launch. </p><br><div class="spoiler">  <b class="spoiler_title">Daftar lengkap fitur antarmuka</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ objdump -T -j .text libjli.so libjli.so: file format elf64-x86-64 DYNAMIC SYMBOL TABLE: 0000000000009280 g DF .text 0000000000000038 Base JLI_List_add 0000000000003330 g DF .text 00000000000001c3 Base JLI_PreprocessArg 0000000000008180 g DF .text 0000000000000008 Base JLI_GetStdArgs 0000000000008190 g DF .text 0000000000000008 Base JLI_GetStdArgc 0000000000007e50 g DF .text 00000000000000b8 Base JLI_ReportErrorMessage 000000000000a400 g DF .text 00000000000000df Base JLI_ManifestIterate 0000000000002e70 g DF .text 0000000000000049 Base JLI_InitArgProcessing 0000000000008000 g DF .text 0000000000000011 Base JLI_ReportExceptionDescription 0000000000003500 g DF .text 0000000000000074 Base JLI_AddArgsFromEnvVar 0000000000007f10 g DF .text 00000000000000e9 Base JLI_ReportErrorMessageSys 0000000000005840 g DF .text 00000000000000b8 Base JLI_ReportMessage 0000000000009140 g DF .text 000000000000003a Base JLI_SetTraceLauncher 0000000000009020 g DF .text 000000000000000a Base JLI_MemFree 0000000000008f90 g DF .text 0000000000000026 Base JLI_MemAlloc 00000000000059c0 g DF .text 0000000000002013 Base JLI_Launch 00000000000091c0 g DF .text 000000000000003b Base JLI_List_new 0000000000008ff0 g DF .text 0000000000000026 Base JLI_StringDup 0000000000002ec0 g DF .text 000000000000000c Base JLI_GetAppArgIndex</code> </pre> </div></div><br><p>  Setelah transfer kontrol ke JLI_Launch, sejumlah tindakan diperlukan untuk memulai JVM, seperti: </p><br><p>  <strong>Saya</strong>  Memuat karakter JVM HotSpot ke dalam memori dan mendapatkan pointer ke fungsi untuk membuat VM. </p><br><p>  Semua kode JVM HotSpot terletak di perpustakaan libjvm.so.  Setelah menentukan jalur absolut ke libjvm.so, <a href="">pustaka dimuat ke memori</a> dan <a href="">penunjuk ke fungsi JNI_CreateJavaVM dicabut darinya</a> .  Pointer fungsi ini disimpan dan selanjutnya digunakan untuk membuat dan menginisialisasi mesin virtual. </p><br><p>  Jelas libjvm.so tidak ditautkan ke libjli.so </p><br><p>  <strong>II</strong>  Argumen parsing berlalu setelah preprocessing. </p><br><p>  Fungsi dengan nama berbicara <a href="">ParseArguments</a> mem-parsing argumen yang dilewatkan dari baris perintah.  Parser argumen ini mendefinisikan <a href="">mode startup aplikasi</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> LaunchMode { <span class="hljs-comment"><span class="hljs-comment">// cf. sun.launcher.LauncherHelper LM_UNKNOWN = 0, LM_CLASS, LM_JAR, LM_MODULE, LM_SOURCE };</span></span></code> </pre> <br><p>  Itu juga mengubah bagian dari argumen ke format <code>-DpropertyName=propertyValue</code> , misalnya, <code>-cp=/path</code> dikonversi ke <code>-Djava.class.path=/path</code> .  Selanjutnya, <code>SystemProperty</code> tersebut disimpan dalam <a href="">array global</a> di JVM HotSpot dan diteruskan ke <code>java.lang.System::props</code> pada <a href="">fase pertama inisialisasi</a> (Dalam JDK12, mekanisme inisialisasi java.lang.System.props telah dimodifikasi, lebih dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit ini</a> ). </p><br><p>  Argumen parsing juga membuang beberapa opsi yang tidak diproses oleh JVM (misalnya <code>--list-modules</code> , pemrosesan opsi ini terjadi langsung di launcher pada saat <a href="">ini</a> ). </p><br><p>  <strong>III</strong> .  Garpu utas primordial dan buat VM di dalamnya </p><br><p>  Tetapi jika ada yang salah, upaya dilakukan untuk <a href="">memulai JVM di utas utama</a> "coba saja". </p><br><p>  Setelah mempelajari pertanyaan itu, saya menemukan salah satu alasan yang memungkinkan mengapa JVM tidak dimulai di utas utama.  Faktanya adalah bahwa (setidaknya di Linux) pthreads dan utas utama bekerja secara berbeda dengan stack.  Ukuran main-thread'a dibatasi oleh <code>ulimit -s</code> , yaitu  saat mengatur nilai besar yang sewenang-wenang, kami mendapatkan tumpukan besar yang sewenang-wenang.  Utas utama menggunakan sesuatu yang mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MAP_GROWSDOWN</a> , tetapi tidak <code>MAP_GROWSDOWN</code> .  Menggunakan <code>MAP_GROWSDOWN</code> dalam bentuknya yang murni tidak aman dan, jika ingatanku benar, terkunci.  Di komputer saya, <code>MAP_GROWSDOWN</code> tidak menambahkan efek apa pun.  Perbedaan antara pemetaan utas utama dan MAP_GROWSDOWN adalah bahwa tidak ada <code>mmap</code> lain, dengan pengecualian <code>MAP_FIXED</code> , akan dapat bertabrakan dengan bidang kemungkinan ekspansi tumpukan.  Semua yang diperlukan dari perangkat lunak adalah untuk menetapkan nilai <code>rsp</code> sesuai dan kemudian OS akan mengetahuinya: Dan kesalahan halaman akan memproses dan <a href="">penjaga akan mengatur</a> .  Perbedaan ini memengaruhi sejumlah penggaruk: <a href="">Saat menentukan ukuran tumpukan aliran saat ini</a> , <a href="">saat membuat halaman jaga</a> </p><br><p>  Jadi, kami akan menganggap bahwa saat ini kami telah berhasil mengurai opsi dan membuat utas untuk VM.  Setelah itu, utas hanya bercabang mulai membuat mesin virtual dan memasuki fungsi <a href="">Threads :: create_vm</a> </p><br><p>  Dalam fungsi ini, sejumlah besar dibuat <del>  ilmu hitam </del>  inisialisasi, kami akan tertarik hanya beberapa dari mereka. </p><br><h4 id="inicializaciya-intepretatora-i-peredacha-upravleniya-java-kodu">  Inisialisasi penerjemah dan transfer kontrol ke kode java </h4><br><p>  Untuk setiap instruksi di JVM HotSpot ada template kode mesin khusus untuk arsitektur tertentu.  Ketika penerjemah mulai menjalankan instruksi, hal pertama yang dicari adalah alamat <a href="">templatnya di</a> tabel <a href="">DispatchTable</a> khusus.  Selanjutnya, <a href="">lompat</a> ke alamat templat ini dan setelah eksekusi instruksi selesai, jvm mengeluarkan alamat <a href="">instruksi selanjutnya secara berurutan</a> ) dan mulai mengeksekusinya dengan cara yang sama, dan seterusnya.  Perilaku ini diamati dengan interpreter hanya untuk instruksi yang tidak "mengirim", misalnya, instruksi aritmatika ( <code>xsub</code> , <code>xdiv</code> , dll, di mana <code>x</code> - <code>i</code> , <code>l</code> , <code>f</code> , <code>d</code> ).  Yang mereka lakukan adalah melakukan operasi aritmatika. </p><br><p>  Dalam kasus instruksi pemanggilan prosedur ( <code>invokestatic</code> , <code>invokevirtual</code> , dll.), Instruksi selanjutnya yang akan dieksekusi akan menjadi instruksi pertama dalam prosedur yang disebut.  Instruksi semacam itu sendiri menuliskan alamat dari bytecode-instructions yang akan dieksekusi dalam template mereka. </p><br><p>  Untuk memastikan pengoperasian mesin ini di <a href=""><code>Threads::create_vm</code></a> , sejumlah inisialisasi dilakukan di mana penerjemah bergantung: </p><br><p>  <strong>Saya</strong>  Menginisialisasi tabel bytecodes yang tersedia </p><br><p>  Sebelum melanjutkan dengan inisialisasi interpreter, perlu menginisialisasi tabel bytecodes yang digunakan.  Ini dijalankan dalam fungsi <a href="">Bytecodes :: inisialisasi</a> dan disajikan sebagai label yang sangat mudah dibaca.  Fragmennya adalah sebagai berikut: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Java bytecodes // bytecode bytecode name format wide f. result tp stk traps def(_nop , "nop" , "b" , NULL , T_VOID , 0, false); def(_aconst_null , "aconst_null" , "b" , NULL , T_OBJECT , 1, false); def(_iconst_m1 , "iconst_m1" , "b" , NULL , T_INT , 1, false); def(_iconst_0 , "iconst_0" , "b" , NULL , T_INT , 1, false); def(_iconst_1 , "iconst_1" , "b" , NULL , T_INT , 1, false); def(_iconst_2 , "iconst_2" , "b" , NULL , T_INT , 1, false); def(_iconst_3 , "iconst_3" , "b" , NULL , T_INT , 1, false); def(_iconst_4 , "iconst_4" , "b" , NULL , T_INT , 1, false); def(_iconst_5 , "iconst_5" , "b" , NULL , T_INT , 1, false); def(_lconst_0 , "lconst_0" , "b" , NULL , T_LONG , 2, false); def(_lconst_1 , "lconst_1" , "b" , NULL , T_LONG , 2, false); def(_fconst_0 , "fconst_0" , "b" , NULL , T_FLOAT , 1, false); def(_fconst_1 , "fconst_1" , "b" , NULL , T_FLOAT , 1, false); def(_fconst_2 , "fconst_2" , "b" , NULL , T_FLOAT , 1, false); def(_dconst_0 , "dconst_0" , "b" , NULL , T_DOUBLE , 2, false); def(_dconst_1 , "dconst_1" , "b" , NULL , T_DOUBLE , 2, false); def(_bipush , "bipush" , "bc" , NULL , T_INT , 1, false); def(_sipush , "sipush" , "bcc" , NULL , T_INT , 1, false); def(_ldc , "ldc" , "bk" , NULL , T_ILLEGAL, 1, true ); def(_ldc_w , "ldc_w" , "bkk" , NULL , T_ILLEGAL, 1, true ); def(_ldc2_w , "ldc2_w" , "bkk" , NULL , T_ILLEGAL, 2, true );</span></span></code> </pre> <br><p>  Sesuai dengan tabel ini, untuk setiap bytecode panjangnya diatur (ukuran selalu 1 byte, tetapi mungkin juga ada indeks di <code>ConstantPool</code> , serta bytecode lebar), nama, bytecode dan bendera: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Bytecodes::_is_initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* Bytecodes::_name [Bytecodes::number_of_codes]; BasicType Bytecodes::_result_type [Bytecodes::number_of_codes]; s_char Bytecodes::_depth [Bytecodes::number_of_codes]; u_char Bytecodes::_lengths [Bytecodes::number_of_codes]; Bytecodes::Code Bytecodes::_java_code [Bytecodes::number_of_codes]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> Bytecodes::_flags [(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;BitsPerByte)*<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre> <br><p>  Parameter ini selanjutnya diperlukan untuk menghasilkan kode templat juru bahasa. </p><br><p>  <strong>II</strong>  Inisialisasi Kode Cache </p><br><p>  Untuk menghasilkan kode untuk template juru bahasa, Anda harus terlebih dahulu mengalokasikan memori untuk bisnis ini.  Reservasi memori untuk kode cache diterapkan dalam fungsi dengan nama yang sama <a href="">CodeCache :: initialize ()</a> .  Seperti dapat dilihat dari bagian kode berikut dari fungsi ini </p><br><pre> <code class="cpp hljs"> CodeCacheExpansionSize = align_up(CodeCacheExpansionSize, os::vm_page_size()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SegmentedCodeCache) { <span class="hljs-comment"><span class="hljs-comment">// Use multiple code heaps initialize_heaps(); } else { // Use a single code heap FLAG_SET_ERGO(uintx, NonNMethodCodeHeapSize, 0); FLAG_SET_ERGO(uintx, ProfiledCodeHeapSize, 0); FLAG_SET_ERGO(uintx, NonProfiledCodeHeapSize, 0); ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize); add_heap(rs, "CodeCache", CodeBlobType::All); }</span></span></code> </pre> <br><p>  kode cache dikontrol oleh opsi <a href=""><code>-XX:ReservedCodeCacheSize</code></a> , <a href=""><code>-XX:SegmentedCodeCache</code></a> , <a href=""><code>-XX:CodeCacheExpansionSize</code></a> , <a href=""><code>-XX:NonNMethodCodeHeapSize</code></a> , <a href=""><code>-XX:ProfiledCodeHeapSize</code></a> <a href=""><code>-XX:CodeCacheExpansionSize</code></a> , <a href=""><code>-XX:NonNMethodCodeHeapSize</code></a> .  Penjelasan singkat tentang opsi-opsi ini dapat ditemukan pada tautan yang dipimpinnya.  Selain baris perintah, nilai beberapa opsi ini disesuaikan secara ergonomis, misalnya, jika nilai <code>SegmentedCodeCache</code> secara default (tidak aktif), kemudian dengan ukuran kode <code>&gt;= 240Mb</code> , <code>SegmentedCodeCache</code> akan dimasukkan dalam <a href="">CompilerConfig :: set_tiered_flags</a> . </p><br><p>  Setelah melakukan pemeriksaan, area ukuran byte <code>ReservedCodeCacheSize</code> .  Jika <code>SegmentedCodeCache</code> ternyata terpapar, maka area ini dibagi menjadi beberapa bagian: Metode yang dikompilasi JIT, rutin tikaman, dll. </p><br><p>  <strong>III</strong> .  Inisialisasi pola interpreter </p><br><p>  Setelah tabel bytecode dan kode cache diinisialisasi, Anda dapat melanjutkan ke pembuatan kode templat juru bahasa.  Untuk melakukan ini, juru bahasa cadangan buffer dari kode cache yang diinisialisasi sebelumnya.  Pada setiap tahap pembuatan kode, <a href="">kode</a> - bagian kecil kode - akan dipotong dari <a href="">buffer</a> .  Setelah menyelesaikan generasi saat ini, bagian dari codelet yang tidak digunakan oleh kode dibebaskan dan menjadi tersedia untuk generasi kode berikutnya. </p><br><p>  Pertimbangkan masing-masing langkah ini secara individual: </p><br><ul><li>  <a href="">slow_signature_handler</a> </li></ul><br><pre> <code class="cpp hljs"> { <span class="hljs-function"><span class="hljs-function">CodeletMark </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_masm, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"slow signature handler"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; AbstractInterpreter::_slow_signature_handler = generate_slow_signature_handler(); }</code> </pre><br><p>  penangan tanda tangan digunakan untuk menyiapkan argumen untuk panggilan ke metode asli.  Dalam hal ini, penangan generik dihasilkan jika, misalnya, metode asli memiliki lebih dari 13 argumen (saya tidak memeriksa dalam debugger, tetapi menilai dengan <a href="">kode itu</a> harus seperti ini) </p><br><ul><li>  <a href="">pemrosesan bytecode tidak valid</a> </li></ul><br><pre> <code class="cpp hljs"> { <span class="hljs-function"><span class="hljs-function">CodeletMark </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_masm, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"error exits"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; _unimplemented_bytecode = generate_error_exit(<span class="hljs-string"><span class="hljs-string">"unimplemented bytecode"</span></span>); _illegal_bytecode_sequence = generate_error_exit(<span class="hljs-string"><span class="hljs-string">"illegal bytecode sequence - method not verified"</span></span>); }</code> </pre> <br><p>  VM memvalidasi file class selama inisialisasi, tetapi ini dalam kasus argumen pada stack tidak dalam format yang diperlukan atau bytecode yang tidak diketahui oleh VM.  Rintisan ini digunakan saat membuat kode templat untuk masing-masing bytecode. </p><br><ul><li>  <a href="">kembali dari fungsi</a> </li></ul><br><p>  Setelah memanggil prosedur, perlu untuk mengembalikan data frame stack, yang sebelum prosedur dipanggil dari mana pengembalian dilakukan. </p><br><ul><li>  <a href="">awal</a> </li></ul><br><p>  Digunakan saat memanggil runtime dari seorang juru bahasa. </p><br><ul><li><p>  <a href="">Melempar pengecualian</a> </p><br></li><li><p>  <a href="">Metode Titik Masuk</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> method_entry(kind) \ { CodeletMark cm(_masm, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"method entry point (kind = "</span></span></span><span class="hljs-meta"> #kind </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">")"</span></span></span><span class="hljs-meta">); \ Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind); \ Interpreter::update_cds_entry_table(Interpreter::kind); \ }</span></span></code> </pre> <br><p>  Disajikan sebagai makro tergantung pada jenis metode.  Dalam kasus umum, persiapan <a href="">frame stack yang ditafsirkan</a> dilakukan, cek StackOverflow, stack-banging  Untuk metode asli, penangan tanda tangan didefinisikan. </p><br></li><li><p>  <a href="">Pembuatan Bytecode Template</a> </p><br></li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Bytecodes set_entry_points_for_all_bytes(); // installation of code in other places in the runtime // (ExcutableCodeManager calls not needed to copy the entries) set_safepoints_for_all_bytes();</span></span></code> </pre> <br><p>  Untuk menjalankan instruksi, spesifikasi VM mengharuskan operan berada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operand Stack</a> , tetapi ini tidak mencegah HotSpot dari caching mereka dalam register.  Untuk menentukan keadaan saat ini dari bagian atas tumpukan, <a href="">enumerasi</a> digunakan <a href="">.</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TosState { <span class="hljs-comment"><span class="hljs-comment">// describes the tos cache contents btos = 0, // byte, bool tos cached ztos = 1, // byte, bool tos cached ctos = 2, // char tos cached stos = 3, // short tos cached itos = 4, // int tos cached ltos = 5, // long tos cached ftos = 6, // float tos cached dtos = 7, // double tos cached atos = 8, // object cached vtos = 9, // tos not cached number_of_states, ilgl // illegal state: should not occur };</span></span></code> </pre> <br><p>  Setiap instruksi menentukan status input dan output dari bagian atas <code>TosState</code> dari stack, dan pembentukan pola terjadi tergantung pada status ini.  Templat ini diinisialisasi dalam <a href="">tabel templat yang</a> dapat dibaca.  Sebuah fragmen dari tabel ini adalah sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// interpr. templates // Java spec bytecodes ubcp|disp|clvm|iswd in out generator argument def(Bytecodes::_nop , ____|____|____|____, vtos, vtos, nop , _ ); def(Bytecodes::_aconst_null , ____|____|____|____, vtos, atos, aconst_null , _ ); def(Bytecodes::_iconst_m1 , ____|____|____|____, vtos, itos, iconst , -1 ); def(Bytecodes::_iconst_0 , ____|____|____|____, vtos, itos, iconst , 0 ); def(Bytecodes::_iconst_1 , ____|____|____|____, vtos, itos, iconst , 1 ); def(Bytecodes::_iconst_2 , ____|____|____|____, vtos, itos, iconst , 2 ); def(Bytecodes::_iconst_3 , ____|____|____|____, vtos, itos, iconst , 3 ); def(Bytecodes::_iconst_4 , ____|____|____|____, vtos, itos, iconst , 4 ); def(Bytecodes::_iconst_5 , ____|____|____|____, vtos, itos, iconst , 5 ); def(Bytecodes::_lconst_0 , ____|____|____|____, vtos, ltos, lconst , 0 ); def(Bytecodes::_lconst_1 , ____|____|____|____, vtos, ltos, lconst , 1 ); def(Bytecodes::_fconst_0 , ____|____|____|____, vtos, ftos, fconst , 0 ); def(Bytecodes::_fconst_1 , ____|____|____|____, vtos, ftos, fconst , 1 ); def(Bytecodes::_fconst_2 , ____|____|____|____, vtos, ftos, fconst , 2 ); def(Bytecodes::_dconst_0 , ____|____|____|____, vtos, dtos, dconst , 0 ); def(Bytecodes::_dconst_1 , ____|____|____|____, vtos, dtos, dconst , 1 ); def(Bytecodes::_bipush , ubcp|____|____|____, vtos, itos, bipush , _ ); def(Bytecodes::_sipush , ubcp|____|____|____, vtos, itos, sipush , _ );</span></span></code> </pre> <br><p>  Kami akan sangat tertarik <code>in</code> , <code>out</code> dan <code>generator</code> . </p><br><p>  <code>in</code> - keadaan bagian atas tumpukan pada saat instruksi dimulai <br>  <code>out</code> - keadaan bagian atas tumpukan pada saat selesai <br>  <code>generator</code> - generator template kode instruksi mesin </p><br><p>  Tampilan umum templat untuk semua bytecode dapat digambarkan sebagai: </p><br><ol><li><p>  Jika bit pengiriman tidak diatur untuk instruksi, prolog instruksi dieksekusi (no-op pada x86) </p><br></li><li><p>  Menggunakan <code>generator</code> , kode mesin dihasilkan </p><br></li><li><p>  Jika bit pengiriman tidak diatur untuk instruksi, transisi ke instruksi berikutnya dilakukan tergantung pada keadaan <code>out</code> dari bagian atas tumpukan, yang akan <code>in</code> untuk instruksi berikutnya </p><br></li></ol><br><p>  Alamat titik entri untuk templat yang dihasilkan disimpan di tabel global dan dapat digunakan untuk debugging. </p><br><p>  Di HotSpot, kode yang relatif bodoh berikut ini bertanggung jawab untuk ini: </p><br><div class="spoiler">  <b class="spoiler_title">Generator kode instruksi</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TemplateInterpreterGenerator::set_entry_points(Bytecodes::Code code) { <span class="hljs-function"><span class="hljs-function">CodeletMark </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_masm, Bytecodes::name(code), code)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// initialize entry points assert(_unimplemented_bytecode != NULL, "should have been generated before"); assert(_illegal_bytecode_sequence != NULL, "should have been generated before"); address bep = _illegal_bytecode_sequence; address zep = _illegal_bytecode_sequence; address cep = _illegal_bytecode_sequence; address sep = _illegal_bytecode_sequence; address aep = _illegal_bytecode_sequence; address iep = _illegal_bytecode_sequence; address lep = _illegal_bytecode_sequence; address fep = _illegal_bytecode_sequence; address dep = _illegal_bytecode_sequence; address vep = _unimplemented_bytecode; address wep = _unimplemented_bytecode; // code for short &amp; wide version of bytecode if (Bytecodes::is_defined(code)) { Template* t = TemplateTable::template_for(code); assert(t-&gt;is_valid(), "just checking"); set_short_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep); } if (Bytecodes::wide_is_defined(code)) { Template* t = TemplateTable::template_for_wide(code); assert(t-&gt;is_valid(), "just checking"); set_wide_entry_point(t, wep); } // set entry points EntryPoint entry(bep, zep, cep, sep, aep, iep, lep, fep, dep, vep); Interpreter::_normal_table.set_entry(code, entry); Interpreter::_wentry_point[code] = wep; } //... void TemplateInterpreterGenerator::set_short_entry_points(Template* t, address&amp; bep, address&amp; cep, address&amp; sep, address&amp; aep, address&amp; iep, address&amp; lep, address&amp; fep, address&amp; dep, address&amp; vep) { assert(t-&gt;is_valid(), "template must exist"); switch (t-&gt;tos_in()) { case btos: case ztos: case ctos: case stos: ShouldNotReachHere(); // btos/ctos/stos should use itos. break; case atos: vep = __ pc(); __ pop(atos); aep = __ pc(); generate_and_dispatch(t); break; case itos: vep = __ pc(); __ pop(itos); iep = __ pc(); generate_and_dispatch(t); break; case ltos: vep = __ pc(); __ pop(ltos); lep = __ pc(); generate_and_dispatch(t); break; case ftos: vep = __ pc(); __ pop(ftos); fep = __ pc(); generate_and_dispatch(t); break; case dtos: vep = __ pc(); __ pop(dtos); dep = __ pc(); generate_and_dispatch(t); break; case vtos: set_vtos_entry_points(t, bep, cep, sep, aep, iep, lep, fep, dep, vep); break; default : ShouldNotReachHere(); break; } } //... void TemplateInterpreterGenerator::generate_and_dispatch(Template* t, TosState tos_out) { if (PrintBytecodeHistogram) histogram_bytecode(t); #ifndef PRODUCT // debugging code if (CountBytecodes || TraceBytecodes || StopInterpreterAt &gt; 0) count_bytecode(); if (PrintBytecodePairHistogram) histogram_bytecode_pair(t); if (TraceBytecodes) trace_bytecode(t); if (StopInterpreterAt &gt; 0) stop_interpreter_at(); __ verify_FPU(1, t-&gt;tos_in()); #endif // !PRODUCT int step = 0; if (!t-&gt;does_dispatch()) { step = t-&gt;is_wide() ? Bytecodes::wide_length_for(t-&gt;bytecode()) : Bytecodes::length_for(t-&gt;bytecode()); if (tos_out == ilgl) tos_out = t-&gt;tos_out(); // compute bytecode size assert(step &gt; 0, "just checkin'"); // setup stuff for dispatching next bytecode if (ProfileInterpreter &amp;&amp; VerifyDataPointer &amp;&amp; MethodData::bytecode_has_profile(t-&gt;bytecode())) { __ verify_method_data_pointer(); } __ dispatch_prolog(tos_out, step); } // generate template t-&gt;generate(_masm); // advance if (t-&gt;does_dispatch()) { #ifdef ASSERT // make sure execution doesn't go beyond this point if code is broken __ should_not_reach_here(); #endif // ASSERT } else { // dispatch to next bytecode __ dispatch_epilog(tos_out, step); } }</span></span></code> </pre> </div></div><br><p>     ,     .         JVM.       Java-    .       <a href="">JavaCalls</a> .     JVM  ,     <a href="">  main</a> . </p><br><h4 id="primer">  </h4><br><p>  ,        ,     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span></span>{ Sum.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); } }</code> </pre> <br><p>         <code>Sum.sum(II)</code> . </p><br><p>   2  <code>javac -c *.java</code>    ,      . <br>  <code>Sum.sum</code> : </p><br><pre> <code class="plaintext hljs"> descriptor: (II)I flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=2 0: iload_0 1: iload_1 2: iadd 3: ireturn LineNumberTable: line 3: 0</code> </pre> <br><p>  Main.main </p><br><pre> <code class="plaintext hljs"> descriptor: ([Ljava/lang/String;)V flags: (0x0009) ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: iconst_2 1: iconst_3 2: invokestatic #2 // Method Sum.sum:(II)I 5: pop 6: return LineNumberTable: line 13: 0 line 14: 6</code> </pre> <br><p>   ,          ‚Äî      . </p><br><p>   <code>invokestatic</code> '  x86   -   HotSpot    <a href=""></a> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TemplateTable::invokestatic(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> byte_no) { transition(vtos, vtos); assert(byte_no == f1_byte, <span class="hljs-string"><span class="hljs-string">"use this argument"</span></span>); prepare_invoke(byte_no, rbx); <span class="hljs-comment"><span class="hljs-comment">// get f1 Method* // do the call __ profile_call(rax); __ profile_arguments_type(rax, rbx, rbcp, false); __ jump_from_interpreted(rbx, rax); }</span></span></code> </pre> <br><p> <code>byte_no == f1_byte</code> ‚Äî   <code>ConstantPoolCache</code> ,    , <code>rbx</code> ‚Äî ,      <code>Method *</code> .      :  , ,      ( <code>method_entry</code>    ). </p><br><p>   <code>prepare_invoke</code> .  ,     <code>invokestatic</code>    <code>ConstantPool</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Constant_Methodref_Info</code></a> .   HotSpot    .  2      .. <a href=""><code>ConstantPoolCache</code></a> . <code>ConstantPoolCache</code>       ,    (,    <code>ConstantPoolCacheEntry</code>   ,      ).     <code>ConstantPoolCacheEntry</code> ,      (   0)        / .   ,         <code>ConstantPool</code> ,        <code>ConstantPoolCache</code>      ( x86 Little Endian). </p><br><p> , ,  HotSpot    <code>prepare_invoke</code> ‚Äî     <code>ConstantPoolCache</code> .  ,   ,     <code>ConstantPoolCacheEntry</code>    </p><br><pre> <code class="cpp hljs"> __ get_cache_and_index_and_bytecode_at_bcp(Rcache, index, temp, byte_no, <span class="hljs-number"><span class="hljs-number">1</span></span>, index_size); __ cmpl(temp, code); <span class="hljs-comment"><span class="hljs-comment">// have we resolved this bytecode? __ jcc(Assembler::equal, resolved); // resolve first time through address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache); __ movl(temp, code); __ call_VM(noreg, entry, temp); // Update registers with resolved info __ get_cache_and_index_at_bcp(Rcache, index, 1, index_size); __ bind(resolved);</span></span></code> </pre> <br><p>  ,    <code>InterpreterRuntime::resolve_from_cache</code> . </p><br><p>       receiver'a   ,         .     (, ,  ,  <code>ConstantPoolCache</code>   <code>&lt;clinit&gt;</code> ,      ). <a href="">  </a>      define class,    <code>EagerInitialization</code> ( ,      ,           :)).     HotSpot   ( CDS  )     . </p><br><p>  ,         ,   <code>ConstantPoolCacheEntry</code>    .      <code>Method *</code>  <code>rbx</code> ,   ,         . </p><br><p>       <code>Sum.sum(2, 3)</code> .      gdb-script <code>sum.gdb</code> : </p><br><pre> <code class="plaintext hljs">#    java file /home/dmitrii/jdk12/build/linux-x86_64-server-fastdebug/images/jdk/bin/java # gdb    SEGV' #,   https://hg.openjdk.java.net/jdk/jdk12/file/06222165c35f/src/hotspot/cpu/x86/vm_version_x86.cpp#l361 handle SIGSEGV nostop noprint #       set breakpoint pending on #    , #    set pagination off #      main b PostJVMInit commands #   , #    set $buffer = malloc(1000) #   . #jmp       # invokestatic b *AbstractInterpreter::_entry_table[0] thread 2 commands #     invokestatic, # Method*   rbx set $mthd = (Method *) $rbx #    $buffer call $mthd-&gt;name_and_sig_as_C_string($buffer, 1000) if strcmp()($buffer, "Sum.sum(II)I") == 0 #  iload_0,     b *TemplateInterpreter::_normal_table._table[vtos][26] thread 2 #  iload_1,   - int,  #  iload_0 b *TemplateInterpreter::_normal_table._table[itos][27] thread 2 #   iadd b *TemplateInterpreter::_normal_table._table[itos][96] thread 2 end c end c end r -cp . Main</code> </pre><br><p>    <code>gdb -x sum.gdb</code> ,       <code>Sum.sum</code> </p><br><pre> <code class="plaintext hljs">$453 = 0x7ffff7fdcdd0 "Sum.sum(II)I"</code> </pre> <br><p>   <code>layout asm</code> ,    ,   <a href="">generate_normal_entry</a> .      -,  StackOverflow, stack-banging    dispatch    <code>iload_0</code>    .       : </p><br><pre> <code class="plaintext hljs">0x7fffd828fa1f mov eax,DWORD PTR [r14] ;, iload_0 0x7fffd828fa22 movzx ebx,BYTE PTR [r13+0x1] ;   0x7fffd828fa27 inc r13 ; bcp (byte code pointer) 0x7fffd828fa2a movabs r10,0x7ffff717e8a0 ; DispatchTable 0x7fffd828fa34 jmp QWORD PTR [r10+rbx*8] ;jump     </code> </pre> <br><p>        <code>rax</code> ,        </p><br><pre> <code class="plaintext hljs">0x7fffd828fabe push rax ;     ;   ,      0x7fffd828fabf mov eax,DWORD PTR [r14-0x8] 0x7fffd828fac3 movzx ebx,BYTE PTR [r13+0x1] 0x7fffd828fac8 inc r13 0x7fffd828facb movabs r10,0x7ffff717e8a0 0x7fffd828fad5 jmp QWORD PTR [r10+rbx*8]</code> </pre> <br><p>       <code>iadd</code> : </p><br><pre> <code class="plaintext hljs">0x7fffd8292ba7 mov edx,DWORD PTR [rsp] ; ,     iload_1 0x7fffd8292baa add rsp,0x8 ; rsp    0x7fffd8292bae add eax,edx ;   0x7fffd8292bb0 movzx ebx,BYTE PTR [r13+0x1] 0x7fffd8292bb5 inc r13 0x7fffd8292bb8 movabs r10,0x7ffff717e8a0 0x7fffd8292bc2 jmp QWORD PTR [r10+rbx*8]</code> </pre> <br><p>    <code>gdb</code>  <code>eax</code>  <code>edx</code>    ,    </p><br><pre> <code class="plaintext hljs">(gdb) p $eax $457 = 3 (gdb) p $edx $458 = 2</code> </pre> <br><p>       ,     <code>Sum.sum</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469291/">https://habr.com/ru/post/id469291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469271/index.html">Serialisasi dan Deserializing .NET Core vs Go Data</a></li>
<li><a href="../id469275/index.html">Seperti yang saya lakukan di 18 universitas AS</a></li>
<li><a href="../id469277/index.html">Siapa itu DevOps?</a></li>
<li><a href="../id469287/index.html">Pertempuran Golem dari kartu. Bagaimana kami mengubah permainan menjadi Liga Kartu Parobot</a></li>
<li><a href="../id469289/index.html">Apa itu margin trading di bursa, dan bagaimana cara kerjanya</a></li>
<li><a href="../id469295/index.html">"Finds of an Audio Man": pohon genre musik, gambang dari acara GitHub, dan siaran satelit</a></li>
<li><a href="../id469297/index.html">Konferensi besi. SOM i.MX6, Aliceduino, Keras + STM32Cube.AI</a></li>
<li><a href="../id469299/index.html">Tampilan Instan, Instan dan tidak dapat diakses</a></li>
<li><a href="../id469301/index.html">Agilean: Lean + Agile</a></li>
<li><a href="../id469303/index.html">Andrei Belyaev tentang refleksi di Jawa pada pertemuan jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>