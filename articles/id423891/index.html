<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏿 📓 🙌🏻 Pohon Ekspresi Pengembangan Perusahaan 💻 🤰🏻 🚎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagi sebagian besar pengembang, penggunaan pohon ekspresi terbatas pada ekspresi lambda di LINQ. Seringkali kita tidak mementingkan bagaimana teknolog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pohon Ekspresi Pengembangan Perusahaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/423891/">  Bagi sebagian besar pengembang, penggunaan pohon ekspresi terbatas pada ekspresi lambda di LINQ.  Seringkali kita tidak mementingkan bagaimana teknologi bekerja “di bawah tenda”. <br><br>  Pada artikel ini saya akan menunjukkan kepada Anda teknik-teknik canggih untuk bekerja dengan pohon ekspresi: menghilangkan duplikasi kode dalam LINQ, pembuatan kode, metaprogramming, transpilation, otomatisasi uji. <br><br>  Anda akan belajar cara menggunakan pohon ekspresi secara langsung, perangkap apa yang telah disiapkan teknologi, dan cara menyiasatinya. <br><br><img src="https://habrastorage.org/webt/e5/qh/tt/e5qhttxqyi5a27s-4dtlt2jq1mo.png"><br><br>  Di bawah potongan - video dan teks transkrip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan saya</a> dengan DotNext 2018 Piter. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J2XzsCoJM4o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nama saya Maxim Arshinov, saya adalah salah satu pendiri perusahaan outsourcing Grup Hi-Tech.  Kami terlibat dalam pengembangan perangkat lunak untuk bisnis, dan hari ini saya akan berbicara tentang bagaimana teknologi pohon ekspresi digunakan dalam pekerjaan sehari-hari dan bagaimana teknologi itu mulai membantu kami. <br><br>  Saya tidak pernah secara khusus ingin mempelajari struktur internal pohon ekspresi, sepertinya ini adalah semacam teknologi internal untuk .NET Team untuk LINQ untuk bekerja, dan pemrogram aplikasi tidak perlu mengetahui API-nya.  Ternyata ada beberapa masalah terapan yang perlu diselesaikan.  Agar saya menyukai solusinya, saya harus naik ke usus. <br><br>  Seluruh cerita ini membentang dalam waktu, ada proyek yang berbeda, kasus yang berbeda.  Sesuatu keluar, dan saya menyelesaikannya, tetapi saya akan membiarkan diri saya mengorbankan kebenaran sejarah demi presentasi yang lebih artistik, jadi semua contohnya akan menggunakan model subjek yang sama - toko online. <br><br><img src="https://habrastorage.org/webt/g5/yf/cr/g5yfcrf13ptoovmcheym1x15fdk.png"><br><br>  Bayangkan kita semua sedang menulis toko online.  Ini memiliki produk dan tanda centang "Dijual" di panel admin.  Kami hanya akan menampilkan produk-produk yang memiliki tanda centang ini ditandai pada bagian publik. <br><br><img src="https://habrastorage.org/webt/cg/_e/jt/cg_ejtgmxn1u0hq12ezlonenue8.png"><br><br>  Kami mengambil beberapa DbContext atau NHibernate, kami menulis Where (), kami menampilkan IsForSale. <br><br>  Semuanya baik-baik saja, tetapi aturan bisnis tidak sama sehingga kami menulisnya sekali dan untuk semua.  Mereka berkembang seiring waktu.  Seorang manajer datang dan mengatakan bahwa kita masih harus memantau saldo dan hanya menampilkan barang-barang yang memiliki saldo di bagian publik, tidak melupakan tanda centang. <br><br><img src="https://habrastorage.org/webt/8e/b1/mz/8eb1mzde7casnjrrilroqxpp8ku.png"><br><br>  Kami dengan mudah menambahkan properti seperti itu.  Sekarang aturan bisnis kami dienkapsulasi, kami dapat menggunakannya kembali. <br><br><img src="https://habrastorage.org/webt/6s/yj/09/6syj09lcwmeiktufuwl4a4wzvyq.png"><br><br>  Mari kita coba edit LINQ.  Apakah semuanya baik-baik saja di sini? <br>  Tidak, ini tidak akan berfungsi, karena IsAvailable tidak memetakan dengan cara apa pun ke database, ini adalah kode kami, dan penyedia kueri tidak tahu bagaimana menguraikannya. <br><br><img src="https://habrastorage.org/webt/qb/yt/dp/qbytdpgh5ybdiua4kjpc-rouxbs.png"><br><br>  Kita dapat memberitahunya bahwa properti kita memiliki kisah seperti itu.  Tapi sekarang lambda ini digandakan baik dalam ekspresi LINQ dan properti. <br><br><pre><code class="cs hljs">Where(x =&gt; x.IsForSale &amp;&amp; x.InStock &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) IsAvailable =&gt; IsForSale &amp;&amp; InStock &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Jadi, kali berikutnya lambda ini berubah, kita harus melakukan Ctrl + Shift + F pada proyek.  Tentu, kita semua tidak akan menemukan - bug dan waktu.  Saya ingin menghindari ini. <br><br><img src="https://habrastorage.org/webt/8b/8b/j8/8b8bj8voopaagucck7rcl1j9tcg.png"><br><br>  Kita bisa pergi dari sisi ini dan meletakkan ToList () lain di depan Where ().  Ini adalah keputusan yang buruk, karena jika ada sejuta barang di database, semua orang naik ke RAM dan menyaring di sana. <br><br><img src="https://habrastorage.org/webt/ca/2t/2g/ca2t2gbdetsmcijcefubnokpfeu.png"><br><br>  Jika Anda memiliki tiga produk di toko, solusinya bagus, tetapi di E-commerce biasanya ada lebih banyak.  Ini bekerja hanya karena, meskipun kesamaan lambda satu sama lain, mereka memiliki tipe yang sama sekali berbeda.  Dalam kasus pertama, ini adalah delegasi Fungsi, dan yang kedua, pohon ekspresi.  Terlihat sama, tipenya berbeda, bytecode sama sekali berbeda. <br><br><img src="https://habrastorage.org/webt/2l/qi/ya/2lqiya8v9axdrfchqrdqtrxbe4o.png"><br><br>  Untuk berpindah dari ekspresi ke delegasi, Anda hanya perlu memanggil metode Kompilasi ().  API ini menyediakan .NET: ada ekspresi - dikompilasi, menerima delegasi. <br><br>  Tetapi bagaimana cara kembali?  Apakah ada sesuatu di .NET untuk berpindah dari delegasi ke pohon ekspresi?  Jika Anda terbiasa dengan LISP, misalnya, maka ada mekanisme kutipan yang memungkinkan kode untuk ditafsirkan sebagai struktur data, tetapi dalam. NET tidak. <br><br><h1>  Ekspresikan atau delegasi? </h1><br>  Mengingat bahwa kita memiliki dua jenis lambda, kita dapat berfilsafat apa yang utama: pohon ekspresi atau delegasi. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// so slo-oooooo-ow var delegateLambda = expressionLambda.Compile();</span></span></code> </pre> <br>  Sekilas, jawabannya jelas: karena ada metode Compile () yang bagus, pohon ekspresi adalah yang utama.  Dan kita harus menerima delegasi dengan menyusun ekspresi.  Tetapi kompilasi adalah proses yang lambat, dan jika kita mulai melakukan ini di mana-mana, kita mendapatkan penurunan kinerja.  Selain itu, kami akan menerimanya secara acak, di mana ekspresi harus dikompilasi menjadi delegasi, akan ada penurunan kinerja.  Anda dapat menemukan tempat-tempat ini, tetapi mereka akan memengaruhi waktu respons server, dan secara acak. <br><br><img src="https://habrastorage.org/webt/ur/jw/y_/urjwy_veoqpl7udanxvc3-ddsl8.png"><br><br>  Karena itu, mereka perlu di-cache entah bagaimana.  Jika Anda mendengarkan ceramah tentang struktur data bersamaan, maka Anda tahu tentang ConcurrentDictionary (atau hanya tahu tentang itu).  Saya akan menghilangkan detail tentang metode caching (dengan kunci, bukan kunci).  Hanya saja ConcurrentDictionary memiliki metode GetOrAdd () yang sederhana, dan implementasi paling sederhana adalah memasukkannya ke ConcurrentDictionary dan menyimpannya.  Pertama kali kita mendapatkan kompilasi, tetapi semuanya akan cepat, karena delegasi sudah dikompilasi. <br><br><img src="https://habrastorage.org/webt/h1/wp/gb/h1wpgbo_5pi3xhnfaivvvjsz4ks.png"><br><br>  Kemudian Anda dapat menggunakan metode ekstensi seperti itu, Anda dapat menggunakan dan memperbaiki kode kami dengan IsAvailable (), mendeskripsikan ekspresi, kompilasi properti IsAvailable () dan menyebutnya relatif terhadap objek saat ini. <br><br>  Setidaknya ada dua paket yang mengimplementasikan ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft.Linq.Translations</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Signum Framework</a> (kerangka kerja open source yang ditulis oleh perusahaan komersial).  Baik di sana maupun di sana tentang kisah yang sama dengan kompilasi para delegasi.  API yang sedikit berbeda, tetapi semuanya seperti yang saya tunjukkan pada slide sebelumnya. <br><br>  Namun, ini bukan satu-satunya pendekatan, dan Anda dapat beralih dari delegasi ke ekspresi.  Sudah lama ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang Habre tentang Delegate Decompiler, di mana penulis mengklaim bahwa semua kompilasi itu buruk, karena untuk waktu yang lama. <br><br>  Secara umum, delegasi sebelum ekspresi, dan Anda dapat beralih ke mereka dari delegasi.  Untuk melakukan ini, penulis menggunakan methodBody.GetILAsByteArray ();  dari Reflection, yang benar-benar mengembalikan seluruh kode IL metode sebagai array byte.  Jika Anda memasukkannya lebih jauh ke Reflection, Anda bisa mendapatkan representasi objek dari case ini, lewati dengan loop dan buat pohon ekspresi.  Dengan demikian, transisi balik juga dimungkinkan, tetapi harus dilakukan dengan tangan. <br><br><img src="https://habrastorage.org/webt/_r/pp/d5/_rppd5sfv3tmy9mfacmg6wydi3k.png"><br><br>  Agar tidak menjalankan semua properti, penulis menyarankan untuk menggantung atribut yang dihitung untuk menunjukkan bahwa properti ini perlu digarisbawahi.  Sebelum permintaan, kita naik ke IsAvailable (), mengeluarkan kode-IL-nya, mengonversinya menjadi pohon ekspresi dan mengganti panggilan IsAvailable () dengan apa yang tertulis dalam pengambil ini.  Ternyata inlining manual seperti itu. <br><br><img src="https://habrastorage.org/webt/nt/jx/g1/ntjxg17v2olokmu7ebckzs7v_uq.png"><br><br>  Agar ini berfungsi, sebelum meneruskan semuanya ke ToList (), kami memanggil metode khusus Decompile ().  Ini menyediakan dekorator untuk query asli dan inlining.  Hanya setelah itu kami memberikan segalanya kepada penyedia permintaan, dan semuanya baik-baik saja dengan kami. <br><br><img src="https://habrastorage.org/webt/ze/cz/qw/zeczqw8mzr-k72ivpyfzqrpuhrm.png"><br><br>  Satu-satunya masalah dengan pendekatan ini adalah Delegate Decompiler 0.23.0 tidak akan bergerak maju, tidak ada dukungan Core, dan penulis sendiri mengatakan bahwa ini adalah alpha yang dalam, ada banyak yang belum selesai, sehingga Anda tidak dapat menggunakannya dalam produksi.  Meskipun kami akan kembali ke topik ini. <br><br><h1>  Operasi Boolean </h1><br>  Ternyata kami telah memecahkan masalah duplikasi kondisi tertentu. <br><br><img src="https://habrastorage.org/webt/gc/-u/5n/gc-u5nh7vip9kn5cq1d5gn3ivxm.png"><br><br>  Tetapi kondisinya seringkali perlu digabungkan dengan menggunakan logika Boolean.  Kami memiliki IsForSale (), InStock ()&gt; 0, dan di antara mereka kondisi "AND".  Jika ada kondisi lain, atau kondisi "ATAU" diperlukan. <br><br><img src="https://habrastorage.org/webt/9f/xu/hy/9fxuhyfzinahcrlertade-zam2s.png"><br><br>  Dalam kasus "Dan," Anda dapat menipu dan membuang semua pekerjaan pada penyedia kueri, yaitu, menulis banyak Di mana () berturut-turut, ia tahu bagaimana melakukannya. <br><br><img src="https://habrastorage.org/webt/dd/hp/c9/ddhpc9tfdvmeiadkmyfmswnr4h8.png"><br><br>  Jika "ATAU" diperlukan, ini tidak akan berhasil, karena WhereOr () tidak di LINQ, dan operator | | tidak kelebihan dengan ekspresi. <br><br><h1>  Spesifikasi </h1><br>  Jika Anda terbiasa dengan buku DDD Evans atau hanya tahu sesuatu tentang pola Spesifikasi, yaitu, pola desain yang dirancang khusus untuk ini.  Ada beberapa aturan bisnis dan Anda ingin menggabungkan operasi dalam logika Boolean - mengimplementasikan Spesifikasi. <br><br><img src="https://habrastorage.org/webt/nj/cb/4n/njcb4n2xt0g8dk3joumhmsgmuyg.png"><br><br>  Spesifikasi adalah istilah seperti itu, pola lama dari Jawa.  Dan di Jawa, terutama yang lama, tidak ada LINQ, jadi itu diterapkan di sana hanya dalam bentuk metode isSatisfiedBy (), yaitu, hanya delegasi, tetapi tidak ada pembicaraan tentang ekspresi.  Ada implementasi di Internet yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LinqSpecs</a> , pada slide Anda akan melihatnya.  Saya mengajukannya sedikit untuk diri saya sendiri, tetapi idenya milik perpustakaan. <br><br>  Di sini, semua operator Boolean kelebihan beban, operator benar dan salah kelebihan beban sehingga kedua operator “&amp;&amp;” dan “||” bekerja, tanpa mereka hanya satu ampersand yang akan berfungsi. <br><br><img src="https://habrastorage.org/webt/nh/8b/16/nh8b16hfmjec4t6yotlcmu5nbzi.png"><br><br>  Selanjutnya, kami menambahkan pernyataan implisit yang membuat kompiler berasumsi bahwa spesifikasi adalah ekspresi dan delegasi.  Di mana saja di mana Ekspresi &lt;&gt; atau Fungsi &lt;&gt; harus masuk ke fungsi, Anda dapat melewati spesifikasi.  Karena operator implisit kelebihan beban, kompiler akan mengurai dan mengganti properti Ekspresi atau IsSatisfiedBy. <br><br><img src="https://habrastorage.org/webt/pd/-t/jk/pd-tjkx5uxieorm3go74act-2gc.png"><br><br>  IsSatisfiedBy () dapat diimplementasikan dengan caching ekspresi yang datang.  Dalam kasus apa pun, ternyata kami berasal dari Ekspresi, sesuai dengan delegasi itu, kami telah menambahkan dukungan untuk operator Boolean.  Sekarang semua ini bisa diatur.  Aturan bisnis dapat dimasukkan ke dalam spesifikasi statis, dideklarasikan dan digabungkan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Spec&lt;Product&gt; IsForSaleSpec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spec&lt;Product&gt;(x =&gt; x.IsForSale); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Spec&lt;Product&gt; IsInStockSpec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spec&lt;Product&gt;(x =&gt; x.InStock &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/ru/ju/ya/rujuyaoj1ogssqq_resyqjmkutm.png"><br><br>  Setiap aturan bisnis ditulis hanya sekali, tidak akan hilang di mana pun, tidak akan diduplikasi, mereka dapat digabungkan.  Orang yang datang ke proyek dapat melihat apa yang Anda miliki, kondisi apa, memahami model subjek. <br><br><img src="https://habrastorage.org/webt/td/5l/zi/td5lzi5sx9bcq522numfdrylehg.png"><br><br>  Ada masalah kecil: Ekspresi tidak memiliki metode And (), Or (), dan Not ().  Ini adalah metode penyuluhan, mereka harus dilaksanakan secara mandiri. <br><br><img src="https://habrastorage.org/webt/l9/go/tj/l9gotjytui3drpptkcdtbyeymcc.png"><br><br>  Upaya pertama implementasi adalah ini.  Tentang pohon ekspresi, ada sedikit dokumentasi di Internet, dan semuanya tidak terperinci.  Oleh karena itu, saya mencoba hanya untuk mengambil Ekspresi, menekan Ctrl + Space, melihat OrElse (), membacanya.  Melewati dua Ekspresi untuk mengkompilasi dan mendapatkan lambda.  Ini tidak akan berfungsi. <br><br><img src="https://habrastorage.org/webt/v4/p3/8u/v4p38uvzgxubb2y8olt38ivbipq.png"><br><br>  Faktanya adalah bahwa Ekspresi ini terdiri dari dua bagian: parameter dan tubuh.  Yang kedua juga terdiri dari parameter dan badan.  Dalam OrElse (), Anda harus melewati tubuh ekspresi, yaitu, tidak ada gunanya membandingkan lambda dengan "AND" dan "OR", ini tidak akan berhasil.  Kami memperbaiki, tetapi tidak akan berfungsi lagi. <br><br>  Tetapi jika terakhir kali ada NotSupportedException bahwa lambda tidak didukung, sekarang ada cerita aneh tentang parameter 1, parameter 2, "ada sesuatu yang salah, saya tidak akan bekerja". <br><br><h1>  C # 7.0 Singkatnya </h1><br>  Kemudian saya berpikir bahwa metode poke ilmiah tidak akan berhasil, saya perlu mencari tahu.  Dia mulai mencari google dan menemukan situs buku Albahari " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C # 7.0 in a Nutshell</a> ". <br><br><img src="https://habrastorage.org/webt/m6/0b/ag/m60bagpqsrrcakt5wz-p05lcfyq.png"><br><br>  Joseph Albahari, yang juga merupakan pengembang perpustakaan LINQKit dan LINQPad yang populer, hanya menjelaskan masalah ini.  Anda tidak bisa hanya mengambil dan menggabungkan Ekspresi, dan jika Anda mengambil Ekspresi ajaib. Tingkatkan (), itu akan berhasil. <br><br>  Pertanyaan: apa itu Expression.Invoke ()?  Buka Google lagi.  Itu menciptakan InvocationExpression yang menerapkan ekspresi delegasi atau lambda ke daftar argumen. <br><br><img src="https://habrastorage.org/webt/br/du/mh/brdumhygufxqwgu5hfly1nlac0a.png"><br><br>  Jika saya membaca kode ini untuk Anda sekarang setelah kami menggunakan Expression.Invoke (), kami meneruskan parameter, maka hal yang sama ditulis dalam bahasa Inggris.  Tidak semakin jelas.  Ada beberapa Magic Expression.Invoke () yang karena alasan tertentu menyelesaikan masalah ini dengan parameter.  Kita harus percaya, tidak perlu dipahami. <br><br><img src="https://habrastorage.org/webt/ja/88/po/ja88po-nxrjqtzdya6f8xxnfwre.png"><br><br>  Pada saat yang sama, jika Anda mencoba untuk memberi makan Ekspresi gabungan seperti EF, itu akan jatuh lagi dan mengatakan bahwa Ekspresi.Invoke () tidak didukung.  Omong-omong, EF Core mulai mendukung, tetapi EF 6 tidak berlaku.  Tapi Albahari hanya menawarkan untuk menulis AsExpandable (), dan semuanya berfungsi. <br><br><img src="https://habrastorage.org/webt/z5/4s/lq/z54slqaaitigetkidixpw-0a408.png"><br><br>  Dan Anda dapat mengganti di sub-kueri Ekspresi di mana kami membutuhkan delegasi.  Untuk membuatnya cocok, kita menulis Compile (), tetapi pada saat yang sama, jika kita menulis AsExpandable (), seperti yang disarankan Albahari, Compile ini () tidak akan benar-benar terjadi, tetapi semuanya entah bagaimana akan dilakukan secara ajaib dengan benar. <br><br><img src="https://habrastorage.org/webt/u_/bd/wo/u_bdwop-dd-1gf_xvq3e_d9hbj8.png"><br><br>  Saya tidak percaya sepatah kata pun dan naik ke sumber.  Apa metode AsExpandable ()?  Ini memiliki query dan QueryOptimizer.  Kami akan meninggalkan yang kedua dari kurung, karena tidak menarik, tetapi hanya menempelkan Ekspresi: jika ada 3 + 5, itu akan menempatkan 8. <br><br><img src="https://habrastorage.org/webt/l6/8j/tw/l68jtwqse6njinyczxh7xs3ilmw.png"><br><br>  Sangat menarik bahwa metode Expand () dipanggil kemudian, setelah itu queryOptimizer, dan kemudian semuanya dilewatkan ke penyedia kueri entah bagaimana diperbaiki setelah metode Expand (). <br><br><img src="https://habrastorage.org/webt/pr/dv/oc/prdvockxs8plz7f2lyciiyu0s5y.png"><br><br>  Kami membukanya, ini adalah Pengunjung, di dalamnya kami melihat Kompilasi non-asli (), yang mengkompilasi sesuatu yang lain.  Saya tidak akan memberi tahu Anda apa sebenarnya, meskipun ini memiliki arti tertentu, tetapi kami menghapus satu kompilasi dan menggantinya dengan yang lain.  Hebat, tapi itu memukul pemasaran level 80 karena dampak kinerja tidak ke mana-mana. <br><br><h1>  Mencari alternatif </h1><br>  Saya pikir ini tidak akan berhasil dan mulai mencari solusi lain.  Dan menemukannya.  Ada Pete Montgomery yang juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> tentang masalah ini dan mengklaim bahwa Albahari memalsukan. <br><img src="https://habrastorage.org/webt/k9/pu/hy/k9puhyrru6xqi3hyozftlav_lvk.png"><br>  Pete berbicara dengan pengembang EF, dan mereka mengajarinya untuk menggabungkan semuanya tanpa Ekspresi.Evoke ().  Idenya sangat sederhana: penyergapan dilakukan dengan parameter.  Faktanya adalah bahwa dengan Ekspresi kombinasi ada parameter dari ekspresi pertama dan parameter yang kedua.  Mereka tidak cocok.  Mayat-mayat itu direkatkan bersama, tetapi parameternya tetap menggantung di udara.  Mereka perlu dibalut dengan cara yang benar. <br><br>  Untuk melakukan ini, Anda perlu mengkompilasi kamus dengan melihat parameter ekspresi, jika lambda bukan dari satu parameter.  Kami membuat kamus, dan kami mengikat kembali semua parameter yang kedua ke parameter yang pertama, sehingga parameter awal memasukkan Ekspresi, melewati seluruh tubuh yang kami tempelkan bersama. <br><img src="https://habrastorage.org/webt/yn/ct/37/ynct37iynt07424au-grgvhhz1o.png"><br>  Metode sederhana seperti ini memungkinkan Anda untuk menyingkirkan semua penyergapan dengan Expression.Invoke ().  Apalagi dalam implementasi Pete Montgomery, ini dibuat lebih keren.  Ini memiliki metode Tulis () yang memungkinkan Anda untuk menggabungkan ekspresi apa pun. <br><br><img src="https://habrastorage.org/webt/wc/of/fv/wcoffvtu4s62gggy_qqykowjtns.png"><br><br>  Kami mengambil ekspresi dan melalui AndJuga kami terhubung, berfungsi tanpa Dapat Diperluas ().  Implementasi inilah yang digunakan dalam operasi Boolean. <br><br><h1>  Spesifikasi dan unit </h1><br>  Semuanya baik-baik saja sampai menjadi jelas bahwa agregat ada di alam.  Bagi mereka yang tidak terbiasa, saya akan menjelaskan: jika Anda memiliki model domain dan Anda mewakili semua entitas yang terkait satu sama lain dalam bentuk pohon, maka pohon yang digantung secara terpisah adalah agregat.  Urutan bersama dengan item pesanan akan disebut agregat, dan esensi pesanan adalah akar agregasi. <br><br><img src="https://habrastorage.org/webt/zr/vr/6a/zrvr6af-865n3tluhcoivfjn68g.png"><br><br>  Jika, selain produk, masih ada kategori dengan aturan bisnis yang diumumkan untuk mereka dalam bentuk spesifikasi, bahwa ada peringkat tertentu yang harus lebih dari 50, seperti yang dikatakan pemasar dan kami ingin menggunakannya seperti itu, maka ini bagus. <br><br><img src="https://habrastorage.org/webt/tp/vh/u-/tpvhu-12wisjnbsdhnmddkqpkw4.png"><br><br>  Tetapi jika kita ingin menarik barang keluar dari kategori yang baik, sekali lagi itu buruk, karena jenis kita tidak cocok.  Spesifikasi untuk kategori, tetapi produk diperlukan. <br><br><img src="https://habrastorage.org/webt/yz/cj/wp/yzcjwpjtf0jvuwff1dae8jef7ha.png"><br><br>  Sekali lagi, kita perlu menyelesaikan masalah.  Opsi pertama: ganti Select () dengan SelectMany ().  Saya tidak suka dua hal di sini.  Pertama, saya tidak tahu bagaimana dukungan SelectMany () diimplementasikan di semua penyedia kueri populer.  Kedua, jika seseorang menulis penyedia kueri, hal pertama yang akan dia lakukan adalah menulis lemparan tidak menerapkan pengecualian dan SelectMany ().  Dan poin ketiga: orang berpikir bahwa SelectMany () adalah fungsionalitas, atau bergabung, biasanya tidak terkait dengan permintaan SELECT. <br><br><h1>  Komposisi </h1><br>  Saya ingin menggunakan Select (), bukan SelectMany (). <br><br><img src="https://habrastorage.org/webt/-_/bv/qm/-_bvqmi8jssf1sva8boyiuh1vsg.png"><br><br>  Sekitar waktu yang sama, saya membaca tentang teori kategori, tentang komposisi fungsional dan berpikir bahwa jika ada spesifikasi dari produk di bool di bawah ini, ada beberapa fungsi yang dapat beralih dari produk ke kategori, ada spesifikasi mengenai kategori, kemudian mengganti yang pertama berfungsi sebagai argumen kedua, kita mendapatkan apa yang kita butuhkan, spesifikasi mengenai produk.  Sama persis dengan komposisi fungsional berfungsi, tetapi untuk pohon ekspresi. <br><br><img src="https://habrastorage.org/webt/hg/wp/7h/hgwp7h8a0nrpv2xsfphtltel160.png"><br><br>  Maka akan mungkin untuk menulis metode Where () sehingga perlu untuk beralih dari produk ke kategori dan menerapkan spesifikasi untuk entitas terkait ini.  Sintaks semacam itu untuk selera subjektif saya terlihat cukup dimengerti. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;T&gt; Where&lt;T, TParam&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;T&gt; queryable, Expression&lt;Func&lt;T, TParam&gt;&gt; prop, Expression&lt;Func&lt;TParam, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queryable.Where(prop.Compose(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>)); }</code> </pre> <br>  Dengan metode Compose (), ini juga dapat dilakukan dengan mudah.  Kami mengambil Ekspresi input dari produk dan menggabungkannya dengan spesifikasi untuk produk dan hanya itu. <br><br><img src="https://habrastorage.org/webt/5p/5k/re/5p5krejfyvexk6c-hf50hymykss.png"><br><br>  Sekarang Anda dapat menulis Where ().  Ini akan berfungsi jika Anda memiliki mesin dengan panjang berapa pun.  Kategori memiliki Kategori Super dan sejumlah properti lebih lanjut yang dapat diganti. <br><br>  "Karena kita memiliki alat untuk komposisi fungsional, dan karena kita dapat mengompilasinya, dan karena kita dapat merangkainya secara dinamis, itu berarti ada bau meta-pemrograman!" Saya pikir. <br><br><h1>  Proyeksi </h1><br>  Di mana kita bisa menerapkan meta-pemrograman sehingga kita harus menulis lebih sedikit kode. <br><br><img src="https://habrastorage.org/webt/z6/dw/gi/z6dwgivuday4edqii5me2z0yuw0.png"><br><br>  Opsi pertama adalah proyeksi.  Mencabut seluruh entitas seringkali terlalu mahal.  Paling sering kita menyebarkannya ke depan, bersambung JSON.  Tetapi itu tidak membutuhkan keseluruhan esensi bersama dengan agregat.  Anda dapat melakukan ini dengan LINQ seefisien mungkin dengan menulis Select () seperti itu secara manual.  Tidak sulit, tetapi membosankan. <br><br><img src="https://habrastorage.org/webt/1r/co/xd/1rcoxdmbzmuplg1vyuvkz5hrrqg.png"><br><br>  Sebagai gantinya, saya sarankan semua orang menggunakan ProjectToType ().  Setidaknya ada dua perpustakaan yang dapat melakukan ini: Automapper dan Mapster.  Untuk beberapa alasan, banyak orang tahu bahwa AutoMapper dapat melakukan pemetaan dalam memori, tetapi tidak semua orang tahu bahwa ia memiliki Queryable Extensions, ia juga memiliki Expression, dan dapat membangun ekspresi SQL.  Jika Anda masih menulis pertanyaan manual dan Anda menggunakan LINQ, karena Anda tidak memiliki kendala kinerja yang sangat serius, maka tidak ada gunanya melakukannya dengan tangan Anda, ini adalah pekerjaan mesin, bukan orangnya. <br><br><h1>  Penyaringan </h1><br>  Jika kita dapat melakukan ini dengan proyeksi, mengapa tidak melakukannya untuk memfilter. <br><br><img src="https://habrastorage.org/webt/wg/ei/pd/wgeipdnvwwusix--gk7_zch9nhs.png"><br><br>  Ini kodenya juga.  Filter masuk.  Banyak aplikasi bisnis terlihat seperti ini: filter datang, tambahkan Where (), filter lain datang, tambahkan Where ().  Ada berapa banyak filter, begitu banyak dan ulangi.  Tidak ada yang rumit, tetapi banyak sekali copy-paste. <br><br><img src="https://habrastorage.org/webt/fd/7r/wl/fd7rwlnpkuiluiadq0zppn7_t-y.png"><br><br>  Jika kita, sebagai AutoMapper, melakukannya, menulis AutoFilter, Project dan Filter sehingga dia melakukan semuanya sendiri, itu akan menjadi kode yang lebih keren. <br><br><img src="https://habrastorage.org/webt/9g/es/tg/9gestgfo-ouzbolexklhu78gv8q.png"><br><br>  Ini tidak rumit.  Ambil Expression.Property, berjalanlah melalui DTO dan pada intinya.  Kami menemukan properti umum yang disebut identik.  Jika mereka disebut sama, itu tampak seperti filter. <br><br>  Selanjutnya, Anda perlu memeriksa nol, gunakan konstanta untuk menarik nilai dari DTO, gantilah dengan ekspresi dan tambahkan konversi jika Anda memiliki Int dan NullableInt atau Nullable lainnya sehingga jenisnya cocok.  Dan masukkan, misalnya, Equals (), filter yang memeriksa kesetaraan. <br><br><img src="https://habrastorage.org/webt/09/x6/me/09x6mep3p-rrvwo0vodcnke_8eo.png"><br><br>  Kemudian kumpulkan lambda dan pergi ke setiap properti: jika ada banyak, kumpulkan baik melalui "DAN" atau "ATAU", tergantung pada cara kerja filter untuk Anda. <br><br><img src="https://habrastorage.org/webt/ha/vw/en/havwen3xvrbraul6plgdadjjusy.png"><br><br>  Hal yang sama dapat dilakukan untuk menyortir, tetapi sedikit lebih rumit, karena metode OrderBy () memiliki dua obat generik, jadi Anda harus mengisinya dengan tangan Anda, gunakan Refleksi untuk membuat metode OrderBy () dari dua obat generik, masukkan jenis entitas yang kami ambil, jenis sortasi Properti  Secara umum, Anda juga bisa melakukan ini, tidak sulit. <br><br>  Muncul pertanyaan: di mana harus meletakkan Where () - di tingkat entitas, ketika spesifikasi diumumkan atau setelah proyeksi, dan di sana-sini itu akan berfungsi. <br><br><img src="https://habrastorage.org/webt/e1/4g/4g/e14g4gelsidqhaeq7avs0wgp51i.png"><br><br>  Benar dan benar, karena spesifikasinya adalah, menurut definisi, aturan bisnis, dan kita harus menghargai dan menghargainya dan tidak membuat kesalahan dengan itu.  Ini adalah lapisan satu dimensi.  Dan filter lebih banyak tentang UI, yang berarti mereka memfilter oleh DTO.  Oleh karena itu, Anda dapat meletakkan dua Di mana ().  Ada beberapa kemungkinan pertanyaan mengenai seberapa baik penyedia kueri akan menangani ini dengan baik, tetapi saya percaya bahwa solusi ORM tetap menulis SQL yang buruk, dan itu tidak akan jauh lebih buruk.  Jika ini sangat penting bagi Anda, maka cerita ini sama sekali bukan tentang Anda. <br><br><img src="https://habrastorage.org/webt/46/wn/kc/46wnkcjkjayv9boma0pot5of0rs.png"><br><br>  Seperti yang mereka katakan, lebih baik melihat sekali daripada mendengar seratus kali. <br>  Sekarang toko memiliki tiga produk: Snickers, Subaru Impreza dan Mars.  Toko aneh.  Mari kita coba cari Snickers.  Ada.  Mari kita lihat apa yang seratus rubel.  Juga Snickers.  Dan untuk 500?  Perbesar, tidak ada apa-apa.  Dan untuk 100500 Subaru Impreza.  Hebat, hal yang sama berlaku untuk penyortiran. <br><br>  Sortir berdasarkan abjad dan berdasarkan harga.  Kode di sana ditulis persis seperti sebelumnya.  Filter ini berfungsi untuk semua kelas, apa pun.  Jika Anda mencoba mencari berdasarkan nama, maka Subaru juga ada.  Dan dalam presentasi saya adalah Equals ().  Bagaimana bisa begitu?  Faktanya adalah bahwa kode di sini dan di dalam presentasi sedikit berbeda.  Saya berkomentar di baris tentang Equals () dan menambahkan beberapa sihir jalanan khusus.  Jika kita memiliki tipe String, maka kita tidak perlu Equals (), tetapi panggil StartWith (), yang juga saya terima.  Oleh karena itu, filter berbeda dibuat untuk baris. <br><br><img src="https://habrastorage.org/webt/t7/fa/kp/t7fakpf7peg_v2swpq2xwksiecu.png"><br><br>  Ini berarti bahwa di sini Anda dapat menekan Ctrl + Shift + R, pilih metode dan menulis tidak jika, tetapi beralih, atau Anda bahkan dapat menerapkan pola "Strategi" dan kemudian menjadi gila.  Anda dapat mewujudkan keinginan apa pun tentang pengoperasian filter.  Itu semua tergantung pada jenis yang Anda gunakan.  Yang terpenting, filter akan bekerja sama. <br><br>  Anda dapat menyetujui bahwa filter di semua elemen UI harus berfungsi seperti ini: string dicari dengan satu cara, uang dicari dengan cara lain.  Koordinasikan semua ini, tulis sekali, semuanya akan dilakukan dengan benar di antarmuka yang berbeda, dan tidak ada pengembang lain yang akan merusaknya, karena kode ini tidak pada level aplikasi, tetapi di suatu tempat baik di perpustakaan eksternal atau di kernel Anda. <br><br><h1>  Validasi </h1><br>  Selain pemfilteran dan proyeksi, Anda dapat melakukan validasi.  JS library <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TComb.validation</a> datang dengan ide ini.  TComb adalah singkatan dari Combinator Tipe dan didasarkan pada sistem tipe dan sebagainya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perbaikan, perbaikan. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// null and undefined validate('a', t.Nil).isValid(); // =&gt; false validate(null, t.Nil).isValid(); // =&gt; true validate(undefined, t.Nil).isValid(); // =&gt; true // strings validate(1, t.String).isValid(); // =&gt; false validate('a', t.String).isValid(); // =&gt; true // numbers validate('a', t.Number).isValid(); // =&gt; false validate(1, t.Number).isValid(); // =&gt; true</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertama, primitif dinyatakan sesuai untuk semua jenis JS, dan tipe nill tambahan sesuai dengan yang tidak terdefinisi atau nol. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// a predicate is a function with signature: (x) -&gt; boolean var predicate = function (x) { return x &gt;= 0; }; // a positive number var Positive = t.refinement(t.Number, predicate); validate(-1, Positive).isValid(); // =&gt; false validate(1, Positive).isValid(); // =&gt; true</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian kesenangan dimulai. </font><font style="vertical-align: inherit;">Setiap jenis dapat ditingkatkan dengan predikat. </font><font style="vertical-align: inherit;">Jika kita menginginkan angka lebih besar dari nol, maka kita menyatakan predikat x&gt; = 0 dan melakukan validasi terhadap tipe Positif. </font><font style="vertical-align: inherit;">Jadi, dari blok bangunan, Anda dapat mengumpulkan validasi apa pun. </font><font style="vertical-align: inherit;">Kami perhatikan, mungkin, ada juga ekspresi lambda. </font></font><br><br><img src="https://habrastorage.org/webt/ha/wx/lj/hawxljvmttn1bc0rhh5k4fvtywe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan itu diterima. </font><font style="vertical-align: inherit;">Kami melakukan penyempurnaan yang sama, menulisnya dalam C #, menulis metode IsValid (), dan mengkompilasi dan mengeksekusi Ekspresi juga. </font><font style="vertical-align: inherit;">Sekarang kami memiliki kesempatan untuk melakukan validasi.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RefinementAttribute</span></span>: <span class="hljs-title"><span class="hljs-title">ValidationAttribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IValidator&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; Refinement { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefinementAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type refinmentType</span></span></span><span class="hljs-function">)</span></span> { Refinement = (IValidator&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;) Activator.CreateInstance(refinmentType); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Refinement.Validate(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>).IsValid(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengintegrasikan dengan sistem DataAnnotations standar di ASP.NET MVC sehingga semuanya bekerja di luar kotak. Kami mendeklarasikan RefinementAttribute (), meneruskan tipe ke konstruktor. Faktanya adalah bahwa RefinementAttribute adalah generik, jadi Anda harus menggunakan tipe seperti ini karena Anda tidak dapat mendeklarasikan atribut generik di .NET, sayangnya. </font></font><br><br><img src="https://habrastorage.org/webt/ml/e7/j9/mle7j92pbchiswi1ni7zfvizgou.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi tandai kelas pengguna dengan refinance. AdultRefinement, yang lebih dari 18. </font></font><br><br><img src="https://habrastorage.org/webt/cp/2o/yt/cp2oytz1rrhql042hddkb3va8ug.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar benar-benar bagus, mari kita buat validasi pada klien dan server sama. Pendukung NoJS menyarankan penulisan dukungan dan depan di JS. Ok, saya akan menulis kembali dan depan dalam C #, tidak apa-apa dan saya hanya memindahkannya ke JS. Javascriptists dapat menulis di JSX, ES6 dan menerjemahkannya ke dalam JavaScript. Kenapa kita tidak bisa? Kami menulis Pengunjung, melalui operator mana yang dibutuhkan dan menulis JavaScript.</font></font><br><br><img src="https://habrastorage.org/webt/lg/qe/9y/lgqe9yl63oz8p8wmlkrmyfmkkky.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus validasi terpisah yang sering adalah ekspresi reguler, mereka juga perlu dibongkar. Jika Anda memiliki regexp, ambil StringBuilder, bangun regexp. Di sini saya menggunakan dua tanda seru, karena JS adalah bahasa yang diketik secara dinamis, ungkapan ini akan dilemparkan ke bool selalu, sehingga semuanya baik-baik saja dengan jenisnya. Mari kita lihat tampilannya.</font></font><br><br><pre> <code class="cs hljs">{ predicate: “x=&gt; (x &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>)”, errorMessage: “For adults only» }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah pemurnian kami, yang berasal dari backend, predikat garis, seperti di JS tidak ada lambda dan pesan error “Khusus untuk orang dewasa”. Mari kita coba mengisi formulir. Tidak lulus. Kami melihat bagaimana itu dibuat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini Bereaksi, kami meminta dari backend dari metode UserRefinment () Ekspresi dan errorMessage, buat pemurnian relatif terhadap angka, gunakan eval untuk mendapatkan lambda. Jika saya mengulang ini dan menghapus batasan jenis, ganti dengan nomor biasa, validasi akan jatuh pada JS. Masukkan unit, kirim. Saya tidak tahu apakah itu terlihat atau tidak, false disimpulkan di sini. </font></font><br><br><img src="https://habrastorage.org/webt/km/vw/ls/kmvwlsxxw5csttfvkh_rxrpbwpe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode ini waspada. Ketika kami mengirim onSubmit, beri tahu apa yang datang dari backend. Dan backend adalah kode sederhana. </font></font><br><br><img src="https://habrastorage.org/webt/xj/hm/mz/xjhmmznmn7xgzlcxedk_tgvdzcu.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami hanya mengembalikan Ok (ModelState.IsValid), kelas pengguna yang kami dapatkan dari formulir di JavaScript. Inilah atribut Penyempurnaan ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DemoApp.Core</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span>: <span class="hljs-title"><span class="hljs-title">HasNameBase</span></span> { [Refinement(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(AdultRefinement))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Age { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, validasi juga berfungsi pada backend, yang dinyatakan dalam lambda ini. </font><font style="vertical-align: inherit;">Dan kami menerjemahkannya ke dalam JavaScript. </font><font style="vertical-align: inherit;">Ternyata, kami menulis ekspresi lambda di C #, dan kode dieksekusi di sana dan di sana. </font><font style="vertical-align: inherit;">Jawaban kami adalah NoJS, kami juga bisa melakukannya.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengujian </font></font></h1><br><img src="https://habrastorage.org/webt/jz/fm/y0/jzfmy0ngjejazfvdrf5ld9y8cc4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya Timlids yang lebih memperhatikan jumlah kesalahan dalam kode. Mereka yang menulis tes unit tahu perpustakaan Moq. </font><font style="vertical-align: inherit;">Apakah Anda ingin menulis tiruan atau mendeklarasikan beberapa kelas - ada moq, ia memiliki sintaks yang lancar. </font><font style="vertical-align: inherit;">Anda dapat melukis bagaimana Anda ingin dia berperilaku dan menyelipkan aplikasinya untuk pengujian. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lambdas ini dalam moq juga Ekspresi, bukan delegasi. </font><font style="vertical-align: inherit;">Dia menjalankan melalui pohon ekspresi, menerapkan logikanya, dan kemudian memberi makan di Castle.DynamicProxy. </font><font style="vertical-align: inherit;">Dan dia menciptakan kelas yang diperlukan dalam runtime. </font><font style="vertical-align: inherit;">Tetapi kita juga bisa melakukannya.</font></font><br><br><img src="https://habrastorage.org/webt/tc/xo/fk/tcxofk6igzdettbtprnfewltn_q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seorang teman saya baru-baru ini bertanya apakah ada sesuatu seperti WCF di Core kami. Saya menjawab bahwa ada WebAPI. Dia ingin di WebAPI, seperti di WCF di WSDL untuk membangun proxy. Hanya ada kesombongan di WebAPI. Tapi kesombongan hanyalah teks, dan seorang teman tidak ingin menonton setiap kali ketika API berubah dan apa yang rusak. Ketika ada WCF, itu mengaktifkan WSDL, jika spesifikasi telah berubah di API, kompilasi rusak.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini masuk akal, karena enggan untuk mencari, dan kompiler dapat membantu. Dengan analogi dengan moq, Anda dapat mendeklarasikan metode GetResponse &lt;&gt; () generik dengan ProductController Anda, dan lambda yang masuk ke metode ini diparameterisasi oleh pengontrol. Yaitu, ketika Anda mulai menulis lambda, tekan Ctrl + Space dan lihat semua metode yang dimiliki pengontrol ini, asalkan ada pustaka, dll dengan kode. Ada Intellisense, tulis semua ini seolah-olah Anda memanggil controller.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, seperti Moq, kami tidak akan menyebutnya, tetapi cukup membangun pohon ekspresi, melewatinya, menarik semua informasi perutean dari konfigurasi API. Dan alih-alih melakukan sesuatu dengan controller, yang tidak dapat kita jalankan, karena kita harus mengeksekusinya di server, kita hanya membuat permintaan POST atau GET yang kita butuhkan, dan sebaliknya kita deserialize yang diterima, karena dari Intellisense dan pohon ekspresi yang kita ketahui tentang semua tipe pengembalian. Ternyata, kami menulis kode tentang pengontrol, tetapi sebenarnya kami membuat permintaan Web. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi Refleksi </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segala sesuatu tentang meta-pemrograman memiliki banyak kesamaan dengan Refleksi.</font></font><br><br><img src="https://habrastorage.org/webt/gr/bq/r_/grbqr_q2oqe0rulsblvpejylomk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tahu bahwa Refleksi lambat, saya ingin menghindari ini. Di sini, juga, ada beberapa kasus yang baik untuk bekerja dengan Ekspresi. Yang pertama adalah aktivator CreateInstance. Anda tidak boleh menggunakannya sama sekali, karena ada Expression.New (), yang bisa Anda pakai ke lambda, kompilasi dan dapatkan konstruktornya. </font></font><br><br><img src="https://habrastorage.org/webt/8u/me/lv/8umelvrhhu0ctn0gaunjp1ldmxg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya meminjam slide ini dari pembicara yang hebat dan musisi Vagif. Dia melakukan semacam tolok ukur di sebuah blog. Ini Activator, ini adalah Puncak Komunisme, Anda lihat betapa dia berusaha melakukan semuanya. Constructor_Invoke, sekitar setengahnya bagus. Dan di sebelah kiri adalah lambda Baru dan disusun. Ada sedikit peningkatan kinerja karena fakta bahwa ini adalah delegasi, bukan konstruktor, tetapi pilihannya jelas, jelas bahwa ini jauh lebih baik. </font></font><br><br><img src="https://habrastorage.org/webt/yr/sv/7k/yrsv7kspmbbmnfjxc1slzkemvx4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal yang sama dapat dilakukan dengan getter atau setter.</font></font><br><br><img src="https://habrastorage.org/webt/gf/2d/4e/gf2d4ebwaltmazxfjicoupxwrbk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dilakukan dengan sangat sederhana. Jika karena alasan tertentu Anda tidak nyaman dengan Fast Memember, Mark Gravelli atau Fast Reflect, jika Anda tidak ingin menarik ketergantungan ini, Anda dapat melakukan hal yang sama. Satu-satunya kesulitan adalah Anda perlu memonitor semua kompilasi ini, menyimpan dan menghangatkan cache di suatu tempat. Artinya, jika ada banyak ini, maka pada awalnya perlu untuk kompilasi sekali. </font></font><br><br><img src="https://habrastorage.org/webt/hi/x1/e7/hix1e7peelljkkm6kewh4blyhgq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena ada konstruktor, pengambil dan penyetel, hanya ada perilaku, metode. Tetapi mereka juga dapat dikompilasi menjadi delegasi, dan Anda hanya akan mendapatkan kebun binatang delegasi besar yang harus Anda kelola. Mengetahui semua yang saya bicarakan, mungkin muncul ide seseorang bahwa jika ada banyak delegasi, banyak ekspresi, maka mungkin ada ruang untuk apa yang disebut DSL, Bahasa Kecil atau pola juru bahasa, monad gratis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini semua adalah hal yang sama ketika untuk beberapa tugas kami datang dengan seperangkat perintah dan baginya kami menulis juru bahasa kami sendiri yang melakukan ini. Artinya, di dalam aplikasi kita menulis kompiler atau juru bahasa lain yang tahu bagaimana menggunakan perintah ini. Ini persis apa yang dilakukan di DLR, di bagian yang berfungsi dengan IronPython, bahasa IronRuby. Pohon Ekspresi di sana digunakan untuk mengeksekusi kode dinamis di CLR. Hal yang sama dapat dilakukan dalam aplikasi bisnis, tetapi sejauh ini kami belum melihat kebutuhan seperti itu dan ini masih di luar kurung.</font></font><br><br><h1>  Ringkasan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai kesimpulan, saya ingin berbicara tentang kesimpulan apa yang kami dapatkan setelah implementasi dan pengujian. Seperti yang saya katakan, ini terjadi pada proyek yang berbeda. Semua yang saya tulis, kami tidak gunakan di mana-mana, tetapi di suatu tempat jika perlu, beberapa hal digunakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai tambah pertama adalah kemampuan untuk mengotomatisasi rutinitas. Jika Anda memiliki 100 ribu cetakan dengan penyaringan, pagination, dan semua itu. Mozart punya lelucon bahwa menggunakan dadu, waktu yang cukup dan segelas anggur merah, Anda dapat menulis waltz dalam jumlah berapa pun. Di sini dengan bantuan Pohon Ekspresi, sebuah meta-pemrograman kecil, Anda dapat menulis formulir dalam jumlah berapa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah kode sangat berkurang, sebagai alternatif untuk pembuatan kode, jika Anda tidak menyukainya, karena Anda mendapatkan banyak kode, Anda tidak dapat menulisnya, meninggalkan semuanya dalam runtime.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan kode seperti itu untuk tugas-tugas sederhana, kami selanjutnya mengurangi persyaratan untuk pemain, karena kode imperatif sangat sedikit dan tidak ada ruang untuk kesalahan juga. Setelah menarik sejumlah besar kode ke komponen yang dapat digunakan kembali, kami menghapus kelas kesalahan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sisi lain, kami sangat meningkatkan persyaratan untuk kualifikasi desainer, karena pertanyaan muncul dari pengetahuan tentang bekerja dengan Ekspresi, Refleksi, optimalisasi mereka, tentang tempat-tempat di mana Anda dapat menembak diri sendiri. Ada banyak nuansa seperti itu, sehingga seseorang yang tidak terbiasa dengan API ini tidak akan segera mengerti mengapa Ekspresi tidak digabungkan. Perancang harus lebih dingin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam beberapa kasus, melalui Expression.Compile (), Anda dapat menangkap penurunan kinerja. Dalam contoh caching, saya memiliki batasan bahwa Ekspresi statis karena Kamus digunakan untuk caching. Jika seseorang tidak tahu bagaimana ini diatur secara internal, ia mulai tanpa berpikir melakukan hal itu, menyatakan spesifikasi di dalamnya tidak statis, metode cache tidak akan berfungsi, dan kami akan mendapatkan panggilan ke Compile () di tempat-tempat acak. Persis apa yang ingin saya hindari.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minus yang paling tidak menyenangkan adalah bahwa kode berhenti terlihat seperti kode C #, menjadi kurang idiomatis, panggilan statis muncul, metode Where () tambahan aneh, beberapa operator implisit kelebihan beban. Ini bukan dalam dokumentasi MSDN, dalam contoh. Jika, misalnya, seseorang dengan sedikit pengalaman mendatangi Anda, yang tidak terbiasa masuk ke kode sumber jika terjadi sesuatu, ia kemungkinan besar akan bersujud sedikit untuk pertama kalinya, karena ini tidak cocok dengan gambar dunia, tidak ada contoh seperti itu di StackOverflow, tetapi dengan ini harus bekerja entah bagaimana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, ini semua yang ingin saya bicarakan hari ini. Banyak hal yang saya ceritakan, lebih detail, dengan detail </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditulis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Habré. Kode perpustakaan diposting di github, tetapi memiliki satu kesalahan fatal - kurangnya dokumentasi.</font></font><br><blockquote> 22-23     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DotNext 2018 Moscow</a> .       , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     ( <b>  </b>   ). </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423891/">https://habr.com/ru/post/id423891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423877/index.html">29-31 Oktober: membuat kluster Kubernet yang siap produksi</a></li>
<li><a href="../id423879/index.html">Apakah mudah untuk menambahkan fitur baru ke kerangka lama? Pilihan tepung pada contoh pengembangan SObjectizer</a></li>
<li><a href="../id423881/index.html">Apa tukang las untuk optik (bagian dua)</a></li>
<li><a href="../id423885/index.html">Undangan untuk pertunjukan cahaya dan orang dalam kecil dari platform Circle of Light di Moskow</a></li>
<li><a href="../id423889/index.html">Kekecewaan saya pada perangkat lunak</a></li>
<li><a href="../id423893/index.html">Hello World untuk menerima data dari perangkat Bluetooth (BLE) melalui C #</a></li>
<li><a href="../id423895/index.html">Anda tidak perlu pengacara. Tapi itu tidak pasti</a></li>
<li><a href="../id423897/index.html">Kiat Berguna untuk Menggunakan HyperLynx DDR Wizard untuk Analisis QDR4</a></li>
<li><a href="../id423901/index.html">Saat kecepatan dan penskalaan diperlukan: server perangkat iOS yang didistribusikan</a></li>
<li><a href="../id423903/index.html">Perendaman dalam AD: kami menganalisis serangan lanjutan pada Microsoft Active Directory dan cara mendeteksi mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>