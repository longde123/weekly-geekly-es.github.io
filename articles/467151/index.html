<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤫 ♌️ 🍈 Manejo de objeciones: el análisis estático ocupará parte del tiempo de trabajo 🧔🏾 🥕 🗼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hablando con personas en conferencias y en comentarios a artículos, nos enfrentamos a la siguiente objeción: el análisis estático reduce el tiempo par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manejo de objeciones: el análisis estático ocupará parte del tiempo de trabajo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/467151/"><img src="https://habrastorage.org/getpro/habr/post_images/44e/3f2/c43/44e3f2c43b9bf3f6a6bcde04008188d1.png" alt="bicho" align="left">  Hablando con personas en conferencias y en comentarios a artículos, nos enfrentamos a la siguiente objeción: el análisis estático reduce el tiempo para detectar errores, pero toma el tiempo de los programadores, lo que niega los beneficios de usarlo e incluso ralentiza el proceso de desarrollo.  Aclaremos esta objeción e intentemos demostrar que no tiene fundamento. <br><a name="habracut"></a><br>  La afirmación "el análisis estático le quitará parte del tiempo de trabajo" fuera del contexto es correcta.  Definitivamente lleva algún tiempo revisar regularmente las advertencias del analizador, emitidas para código nuevo o modificado.  Sin embargo, debemos continuar con la idea: pero el tiempo dedicado a esto es mucho menor que el tiempo necesario para encontrar errores por otros métodos.  Es aún peor descubrir errores de los usuarios. <br><br>  Las pruebas unitarias pueden ser una muy buena analogía aquí.  Las pruebas unitarias también toman tiempo de los desarrolladores, pero no es la razón para no usarlas.  Los beneficios de un código más seguro y de mejor calidad cuando se utilizan pruebas unitarias superan el costo de escribirlos. <br><br>  Otra analogía: advertencias del compilador.  Este es generalmente un tema muy cercano, ya que las advertencias de las herramientas de análisis estático pueden considerarse como una extensión de las advertencias del compilador hasta cierto punto.  Naturalmente, cuando un programador ve una advertencia del compilador, pasa algún tiempo lidiando con ella.  Tiene que cambiar el código o claramente pasar algún tiempo suprimiendo advertencias, por ejemplo, usando #pragma.  Sin embargo, este compromiso de tiempo nunca ha sido la razón para deshabilitar las advertencias del compilador.  Y si alguien hace eso, los demás lo interpretarán inequívocamente como incapacidad profesional. <br><br>  Sin embargo, ¿de dónde viene el miedo a perder el tiempo por las advertencias de los analizadores de código estático? <br><br>  La respuesta es muy simple.  Los programadores que aún no están familiarizados con esta metodología confunden los lanzamientos de prueba y el uso regular.  En la primera ejecución, cualquier analizador ofrece una gran lista de advertencias, lo que es incluso aterrador de ver.  La razón es que el analizador aún no está configurado.  Mientras que un analizador configurado emite una pequeña cantidad de falsos positivos que se utilizan regularmente.  En otras palabras, la mayoría de las advertencias indican defectos reales u olores de código.  Es importante hacer esta configuración.  Este es el truco que convierte un analizador estático de un mal desperdiciador de tiempo en un amigo y un asistente. <br><br>  Cualquier analizador estático emitirá primero muchos falsos positivos.  Hay muchas razones para esto, y este tema merece un artículo separado.  Naturalmente, tanto los desarrolladores de otros analizadores como nuestro equipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">luchan</a> contra los falsos positivos.  Pero aún habrá muchas advertencias, si solo toma y ejecuta el analizador en un proyecto por primera vez.  Por cierto, la misma situación es con las advertencias del compilador.  Supongamos que tiene un gran proyecto que siempre ha estado construyendo, por ejemplo, con el compilador de Visual C ++.  Digamos que el proyecto milagrosamente resultó ser portátil y compilado usando GCC.  Aun así, recibirá un montón de advertencias de GCC.  Las personas que han experimentado un cambio de compiladores en un gran proyecto entienden de lo que estoy hablando. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b2/25b/769/8b225b7693ce622964fbe9f49092c2a5.png" alt="advertencias"></div><br>  Sin embargo, nadie lo obliga a excavar constantemente las pilas de advertencias después de cambiar el compilador o después de ejecutar el analizador.  El siguiente paso obvio es configurar un compilador o analizador.  Quienes dicen que "el análisis de advertencias lleva mucho tiempo" evalúan la complejidad de adoptar la herramienta, pensando solo en todas estas advertencias que deben superarse al principio, pero no piensen en el uso regular sin prisas. <br><br>  Configurar analizadores, así como compiladores, no es tan difícil y laborioso como a los programadores les gusta progresar.  Si eres gerente, no los escuches.  Solo están siendo flojos.  El programador puede decir con orgullo cómo estaba buscando un error encontrado por el probador / cliente durante 3 días.  Y eso está bien para él.  Sin embargo, desde su punto de vista, no es aceptable pasar un día configurando la herramienta, después de lo cual se detectará dicho error antes de que ingrese al sistema de control de versiones. <br><br>  Sí, los falsos positivos estarán presentes después de la configuración.  Pero su número es exagerado.  Es muy posible configurar un analizador para que el porcentaje de falsos positivos sea del 10% al 15%.  Es decir, para 9 defectos encontrados, solo 1 advertencia requerirá supresión como falsa.  Entonces, ¿dónde está la "pérdida de tiempo" aquí?  Al mismo tiempo, el 15% es un valor muy real;  Puedes leer más sobre esto en este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> . <br><br>  Queda una cosa más.  Un programador puede objetar: <br><br>  <i>Bueno, digamos que las ejecuciones regulares de análisis estático son realmente efectivas.</i>  <i>¿Pero qué hacer con el ruido que recibo la primera vez?</i>  <i>En nuestro gran proyecto, no podremos configurar la herramienta para 1 día prometido.</i>  <i>Solo la recompilación para verificar el próximo lote de configuraciones lleva varias horas.</i>  <i>No estamos listos para pasar un par de semanas en esto.</i> <br><br>  Y esto no es un problema, sino un intento de encontrar una razón para no introducir algo nuevo.  Por supuesto, en un gran proyecto, todo siempre es difícil.  Pero primero, brindamos soporte y ayudamos a integrar PVS-Studio en el proceso de desarrollo.  Y en segundo lugar, no es necesario comenzar inmediatamente a clasificar todas las advertencias. <br><br>  Si su aplicación funciona, entonces los errores que existen allí, no son tan críticos y probablemente viven en un código poco utilizado.  Ya se han encontrado y solucionado errores obvios serios utilizando métodos más lentos y caros.  Escribiré sobre esto a continuación en la <b>nota</b> .  Eso no es lo que es de gran importancia ahora.  No tiene sentido realizar ediciones masivas en el código, corrigiendo muchos errores insignificantes.  Con una refactorización tan grande, es fácil romper algo y el daño será más que bueno. <br><br>  Es mejor tener en cuenta las advertencias existentes de la deuda técnica.  Puede volver a la deuda más tarde y trabajar gradualmente con las viejas advertencias.  Al usar el mecanismo de supresión de advertencias masivas, puede comenzar a usar PVS-Studio rápidamente en un proyecto grande.  Aquí hay una breve descripción de lo que está sucediendo: <br><br><ol><li>  Excluye directorios obviamente redundantes (bibliotecas de terceros) del análisis.  Será mejor que lo haga desde el principio para reducir el tiempo de análisis. </li><li>  Intenta PVS-Studio e investiga las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">advertencias más interesantes</a> .  Te gustan los resultados y muestras la herramienta a colegas y jefes.  El equipo decide comenzar a usarlo regularmente. </li><li>  El proyecto está siendo revisado.  Todas las advertencias suprimidas se desactivan mediante el mecanismo de supresión masiva.  En otras palabras, todas las advertencias que tiene en este momento ahora se consideran una deuda técnica que se puede revisar más adelante. </li><li>  El archivo resultante con advertencias suprimidas ingresa al sistema de control de versiones.  Este archivo es grande, pero está bien.  Realiza estas acciones solo una vez (o, al menos, muy raramente).  Y ahora todos los desarrolladores tendrán este archivo. </li><li>  Ahora todos los desarrolladores ven advertencias que solo están relacionadas con código nuevo o modificado.  A partir de ese momento, el equipo comienza a beneficiarse del análisis estático.  Luego, configura gradualmente el analizador y se ocupa de la deuda técnica. </li></ol><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8b/6a4/b4b/e8b6a4b4bf8404d32c8ba4e4f4dd7557.png"></div><br>  Por cierto, el sistema de almacenamiento de advertencias poco interesantes es bastante inteligente.  Los hashes se guardan para la línea con un posible error, así como para la línea anterior y la siguiente.  Como resultado, si agrega una línea al comienzo de uno de los archivos, nada se perderá y el analizador guardará silencio para el código, que se considera una deuda técnica. <br><br>  Espero haber logrado disipar una de las ideas preconcebidas sobre el análisis estático.  Ven, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descarga</a> y prueba nuestro analizador de código estático PVS-Studio.  Detectará muchos errores en las primeras etapas y hará que su código sea generalmente más confiable y mejor. <br><br>  <b>Nota</b> <br><br>  Al desarrollar cualquier proyecto, constantemente aparecen nuevos errores y se solucionan.  Los errores no encontrados "se asientan" en el código durante mucho tiempo, y luego se pueden detectar muchos de ellos cuando se aplica el análisis de código estático.  Esto a veces da la falsa impresión de que los analizadores estáticos encuentran solo algunos errores poco interesantes en piezas de código poco utilizadas.  Bueno, es cierto, en caso de que use el analizador incorrectamente y lo ejecute solo de vez en cuando, por ejemplo, poco antes del lanzamiento.  Más sobre este tema está escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Sí, nosotros mismos hacemos verificaciones únicas de proyectos de código abierto cuando escribimos artículos.  Pero tenemos un propósito diferente.  Nos centramos en demostrar las capacidades del analizador de código para detectar defectos.  En términos generales, esta tarea tiene poco que ver con mejorar la calidad del código del proyecto y reducir el costo de corregir errores. <br><br>  <b>Enlaces Adicionales</b> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio ROI</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Por qué el análisis estático puede mejorar una base de código compleja de C ++</a> . </li><li>  Ivan Ponomarev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduzca el análisis estático en el proceso, no solo busque errores con él</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467151/">https://habr.com/ru/post/467151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467141/index.html">Mitapa Saint TeamLead Conf para un tema más profundo</a></li>
<li><a href="../467143/index.html">Uso de impurezas en aplicaciones Flutter</a></li>
<li><a href="../467145/index.html">No solo comercio: cómo usar el intercambio como una alternativa a los depósitos bancarios y obtener ingresos</a></li>
<li><a href="../467147/index.html">Ataques masivos: características de contraataque a la experiencia de los últimos años.</a></li>
<li><a href="../467149/index.html">Antigüedades: 1992 en la prensa informática</a></li>
<li><a href="../467153/index.html">Trabajar con objeciones: el análisis estático tomará parte del tiempo de trabajo</a></li>
<li><a href="../467155/index.html">Mejores prácticas para contenedores de Kubernetes: controles de salud</a></li>
<li><a href="../467161/index.html">Aplicación web en Kotlin + Spring Boot + Vue.js</a></li>
<li><a href="../467163/index.html">Cómo migrar a la nube en dos horas gracias a Kubernetes y la automatización</a></li>
<li><a href="../467165/index.html">Siguiendo los pasos del movimiento ruso Scala. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>