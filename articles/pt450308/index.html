<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîí üÜö üè¥ Rastreamento de GPU Ray no Unity - Parte 3 üß¶ üç® ‚úçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ A primeira e a segunda partes.] 


 Hoje vamos dar um grande salto. Vamos nos afastar de estruturas exclusivamente esf√©ricas e do plano infinito que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rastreamento de GPU Ray no Unity - Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450308/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A primeira</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segunda</a> partes.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a8a/4f2/f9fa8a4f2a79b8c394636de6a128d0d5.png"></div><br>  Hoje vamos dar um grande salto.  Vamos nos afastar de estruturas exclusivamente esf√©ricas e do plano infinito que tra√ßamos anteriormente e adicionar tri√¢ngulos - toda a ess√™ncia da computa√ß√£o gr√°fica moderna, um elemento que consiste em todos os mundos virtuais.  Se voc√™ quiser continuar com o que terminamos da √∫ltima vez, use o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo da parte 2</a> .  O c√≥digo final para o que faremos hoje est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Vamos come√ßar! <br><br><h2>  Tri√¢ngulos </h2><br>  <em>Um tri√¢ngulo</em> √© apenas uma lista de tr√™s <em>v√©rtices</em> conectados, cada um dos quais armazena sua pr√≥pria posi√ß√£o e, √†s vezes, normal.  A ordem de deslocamento dos v√©rtices do seu ponto de vista determina o que estamos vendo - a frente ou a face traseira do tri√¢ngulo.  Tradicionalmente, a ‚Äúfrente‚Äù √© considerada a ordem de rota√ß√£o no sentido anti-hor√°rio. <br><br>  Primeiro, precisamos ser capazes de determinar se o raio cruza um tri√¢ngulo e, em caso afirmativo, em que ponto.  Um algoritmo muito popular (mas certamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o o √∫nico</a> ) para determinar a interse√ß√£o de um raio com um tri√¢ngulo foi proposto em 1997 pelos cavalheiros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thomas Akenin-Meller</a> e Ben Trembor.  Voc√™ pode ler mais sobre isso em seu artigo "Interse√ß√£o r√°pida e m√≠nima com raios-tri√¢ngulo de armazenamento" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><a name="habracut"></a><br>  O c√≥digo do artigo pode ser facilmente transportado para o c√≥digo de shader HLSL: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> EPSILON = <span class="hljs-number"><span class="hljs-number">1e-8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectTriangle_MT97</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// find vectors for two edges sharing vert0 float3 edge1 = vert1 - vert0; float3 edge2 = vert2 - vert0; // begin calculating determinant - also used to calculate U parameter float3 pvec = cross(ray.direction, edge2); // if determinant is near zero, ray lies in plane of triangle float det = dot(edge1, pvec); // use backface culling if (det &lt; EPSILON) return false; float inv_det = 1.0f / det; // calculate distance from vert0 to ray origin float3 tvec = ray.origin - vert0; // calculate U parameter and test bounds u = dot(tvec, pvec) * inv_det; if (u &lt; 0.0 || u &gt; 1.0f) return false; // prepare to test V parameter float3 qvec = cross(tvec, edge1); // calculate V parameter and test bounds v = dot(ray.direction, qvec) * inv_det; if (v &lt; 0.0 || u + v &gt; 1.0f) return false; // calculate t, ray intersects triangle t = dot(edge2, qvec) * inv_det; return true; }</span></span></code> </pre> <br>  Para usar esta fun√ß√£o, precisamos de um raio e tr√™s v√©rtices de um tri√¢ngulo.  O valor de retorno nos diz se o tri√¢ngulo se cruzou.  Em caso de interse√ß√£o, tr√™s valores adicionais s√£o calculados: <code>t</code> descreve a dist√¢ncia ao longo da viga at√© o ponto de interse√ß√£o e <code>u</code> / <code>v</code> s√£o duas das tr√™s coordenadas baric√™ntricas que determinam a localiza√ß√£o do ponto de interse√ß√£o no tri√¢ngulo (a √∫ltima coordenada pode ser calculada como <code>w = 1 - u - v</code> ).  Se voc√™ ainda n√£o est√° familiarizado com as coordenadas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">barric√™ntricas</a> , leia a excelente explica√ß√£o no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Scratchapixel</a> . <br><br>  Sem muito atraso, vamos tra√ßar um tri√¢ngulo com os v√©rtices indicados no c√≥digo!  Localize a fun√ß√£o <code>Trace</code> no shader e adicione o seguinte fragmento de c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Trace single triangle float3 v0 = float3(-150, 0, -150); float3 v1 = float3(150, 0, -150); float3 v2 = float3(0, 150 * sqrt(2), -150); float t, u, v; if (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { if (t &gt; 0 &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = 0.00f; bestHit.specular = 0.65f * float3(1, 0.4f, 0.2f); bestHit.smoothness = 0.9f; bestHit.emission = 0.0f; } }</span></span></code> </pre> <br>  Como eu disse, <code>t</code> armazena a dist√¢ncia ao longo da viga e podemos usar diretamente esse valor para calcular o ponto de interse√ß√£o.  O normal, que √© importante para calcular a reflex√£o correta, pode ser calculado usando o produto vetorial de quaisquer duas arestas do tri√¢ngulo.  Inicie o modo de jogo e admire seu primeiro tri√¢ngulo tra√ßado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/65a/a84/b2965aa84ae9d882e6c26f7f44da2af7.png"></div><br>  <strong>Exerc√≠cio:</strong> Tente calcular a posi√ß√£o usando coordenadas barric√™ntricas em vez de dist√¢ncia.  Se voc√™ fizer tudo certo, o tri√¢ngulo brilhante ser√° exatamente como antes. <br><br><h2>  Malhas triangulares </h2><br>  Superamos o primeiro obst√°culo, mas tra√ßar malhas inteiras a partir de tri√¢ngulos √© uma hist√≥ria completamente diferente.  Primeiro, precisamos aprender algumas informa√ß√µes b√°sicas sobre malhas.  Se voc√™ os conhece, pode pular com seguran√ßa o pr√≥ximo par√°grafo. <br><br>  Na computa√ß√£o gr√°fica, a malha √© definida por v√°rios buffers, sendo os mais importantes os buffers de <em>v√©rtice</em> e <em>√≠ndice</em> .  <em>O buffer de v√©rtice</em> √© uma lista de vetores 3D que descrevem a posi√ß√£o de cada v√©rtice no <em>espa√ßo do objeto</em> (isso significa que esses valores n√£o precisam ser alterados ao mover, girar ou dimensionar um objeto - eles s√£o convertidos do <em>espa√ßo do objeto</em> para o <em>espa√ßo</em> do <em>mundo</em> em tempo real usando a multiplica√ß√£o de matrizes) .  <em>Um buffer de √≠ndice</em> √© uma lista de valores inteiros que s√£o <em>√≠ndices</em> que apontam para o buffer de v√©rtice.  A cada tr√™s √≠ndices formam um tri√¢ngulo.  Por exemplo, se o buffer de √≠ndice tiver a forma [0, 1, 2, 0, 2, 3], ele ter√° dois tri√¢ngulos: o primeiro tri√¢ngulo consistir√° nos primeiro, segundo e terceiro v√©rtices no buffer de v√©rtice e o segundo tri√¢ngulo consistir√° no primeiro, terceiro e quarto picos.  Portanto, o buffer de √≠ndice tamb√©m determina a ordem de travessia mencionada acima.  Al√©m dos buffers e √≠ndices de v√©rtices, pode haver buffers adicionais que adicionam outras informa√ß√µes a cada v√©rtice.  Os buffers adicionais mais comuns armazenam <em>normais</em> , <em>coordenadas de textura</em> (chamadas <em>texcoords</em> ou simplesmente <em>UV</em> ), al√©m de <em>cores de v√©rtice</em> . <br><br><h2>  Usando GameObjects </h2><br>  Primeiro de tudo, precisamos descobrir quais GameObjects devem se tornar parte do processo de rastreamento de raios.  Uma solu√ß√£o ing√™nua seria simplesmente usar <code>FindObjectOfType&lt;MeshRenderer&gt;()</code> , mas fazer algo mais flex√≠vel e r√°pido.  Vamos adicionar um novo componente <code>RayTracingObject</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RayTracingObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.RegisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.UnregisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br>  Esse componente √© adicionado a cada objeto que queremos usar para o tra√ßado de raios e √© envolvido em seu registro usando o <code>RayTracingMaster</code> .  Adicione as seguintes fun√ß√µes ao assistente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;RayTracingObject&gt; _rayTracingObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RayTracingObject&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Add(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Remove(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Tudo est√° indo bem - agora sabemos quais objetos precisam ser rastreados.  Mas a parte complicada continua: vamos coletar todos os dados das malhas do Unity (matriz, buffers de v√©rtices e √≠ndices - lembra-se deles?), Grav√°-los em nossas pr√≥prias estruturas de dados e carreg√°-los na GPU para que o shader possa us√°-los.  Vamos come√ßar definindo estruturas de dados e buffers no lado do C #, no assistente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MeshObject { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;MeshObject&gt; _meshObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MeshObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; _vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _meshObjectBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _vertexBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _indexBuffer;</code> </pre> <br>  ... e agora vamos fazer o mesmo no shader.  Voc√™ est√° acostumado? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MeshObject</span></span></span><span class="hljs-class"> {</span></span> float4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; }; StructuredBuffer&lt;MeshObject&gt; _MeshObjects; StructuredBuffer&lt;float3&gt; _Vertices; StructuredBuffer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _Indices;</code> </pre> <br>  As estruturas de dados est√£o prontas e podemos preench√™-las com dados reais.  Coletamos todos os v√©rtices de todas as malhas em uma grande <code>List&lt;Vector3&gt;</code> e todos os √≠ndices em uma grande <code>List&lt;int&gt;</code> .  N√£o h√° problemas com os v√©rtices, mas os √≠ndices precisam ser alterados para que continuem apontando para o v√©rtice correto em nosso buffer grande.  Imagine que j√° adicionamos objetos de 1000 v√©rtices e agora adicionamos um cubo de malha simples.  O primeiro tri√¢ngulo pode consistir em √≠ndices [0, 1, 2], mas como j√° t√≠nhamos 1000 v√©rtices no buffer, precisamos mudar os √≠ndices antes de adicionar v√©rtices ao cubo.  Ou seja, eles se transformar√£o em [1000, 1001, 1002].  Aqui est√° o que parece no c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RebuildMeshObjectBuffers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_meshObjectsNeedRebuilding) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Clear all lists _meshObjects.Clear(); _vertices.Clear(); _indices.Clear(); // Loop over all objects and gather their data foreach (RayTracingObject obj in _rayTracingObjects) { Mesh mesh = obj.GetComponent&lt;MeshFilter&gt;().sharedMesh; // Add vertex data int firstVertex = _vertices.Count; _vertices.AddRange(mesh.vertices); // Add index data - if the vertex buffer wasn't empty before, the // indices need to be offset int firstIndex = _indices.Count; var indices = mesh.GetIndices(0); _indices.AddRange(indices.Select(index =&gt; index + firstVertex)); // Add the object itself _meshObjects.Add(new MeshObject() { localToWorldMatrix = obj.transform.localToWorldMatrix, indices_offset = firstIndex, indices_count = indices.Length }); } CreateComputeBuffer(ref _meshObjectBuffer, _meshObjects, 72); CreateComputeBuffer(ref _vertexBuffer, _vertices, 12); CreateComputeBuffer(ref _indexBuffer, _indices, 4); }</span></span></code> </pre> <br>  Chamamos <code>RebuildMeshObjectBuffers</code> na fun√ß√£o <code>OnRenderImage</code> e n√£o se esque√ßa de liberar novos buffers no <code>OnDisable</code> .  Aqui est√£o duas fun√ß√µes auxiliares que usei no c√≥digo acima para simplificar um pouco o buffer: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateComputeBuffer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ComputeBuffer buffer, List&lt;T&gt; data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do we already have a compute buffer? if (buffer != null) { // If no data or buffer doesn't match the given criteria, release it if (data.Count == 0 || buffer.count != data.Count || buffer.stride != stride) { buffer.Release(); buffer = null; } } if (data.Count != 0) { // If the buffer has been released or wasn't there to // begin with, create it if (buffer == null) { buffer = new ComputeBuffer(data.Count, stride); } // Set data on the buffer buffer.SetData(data); } } private void SetComputeBuffer(string name, ComputeBuffer buffer) { if (buffer != null) { RayTracingShader.SetBuffer(0, name, buffer); } }</span></span></code> </pre> <br>  √ìtimo, criamos buffers e eles s√£o preenchidos com os dados necess√°rios!  Agora s√≥ precisamos relatar isso ao shader.  Adicione o seguinte c√≥digo ao <code>SetShaderParameters</code> (e, gra√ßas √†s novas fun√ß√µes auxiliares, podemos reduzir o c√≥digo do buffer da esfera): <br><br><pre> <code class="cs hljs">SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Spheres"</span></span>, _sphereBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_MeshObjects"</span></span>, _meshObjectBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Vertices"</span></span>, _vertexBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Indices"</span></span>, _indexBuffer);</code> </pre> <br>  Portanto, o trabalho √© chato, mas vamos ver o que acabamos de fazer: coletamos todos os dados internos das malhas (matriz, v√©rtices e √≠ndices), os colocamos em uma estrutura conveniente e simples e os enviamos para a GPU, que agora espera quando eles podem ser usados. <br><br><h2>  Rastreamento de malha </h2><br>  N√£o vamos faz√™-lo esperar.  No shader, j√° temos o c√≥digo de rastreamento de um tri√¢ngulo individual, e a malha √©, de fato, apenas muitos tri√¢ngulos.  O √∫nico aspecto novo aqui √© que usamos a matriz para transformar os v√©rtices do espa√ßo do objeto para o espa√ßo do mundo usando a fun√ß√£o <code>mul</code> (abrevia√ß√£o de multiplicar).  A matriz cont√©m a transla√ß√£o, rota√ß√£o e escala do objeto.  Ele tem um tamanho de 4 √ó 4, portanto, para multiplica√ß√£o, precisamos de um vetor 4d.  Os tr√™s primeiros componentes (x, y, z) s√£o obtidos do buffer de v√©rtice.  Definimos o quarto componente (w) como 1 porque estamos lidando com um ponto.  Se essa fosse a dire√ß√£o, escrever√≠amos 0 nela para ignorar todas as tradu√ß√µes e a escala na matriz.  Isso √© confuso para voc√™?  Em seguida, leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este tutorial</a> pelo menos oito vezes.  Aqui est√° o c√≥digo shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectMeshObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, inout RayHit bestHit, MeshObject meshObject)</span></span></span><span class="hljs-function"> </span></span>{ uint offset = meshObject.indices_offset; uint count = offset + meshObject.indices_count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = offset; i &lt; count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { float3 v0 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v1 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v2 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t, u, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; bestHit.specular = <span class="hljs-number"><span class="hljs-number">0.65f</span></span>; bestHit.smoothness = <span class="hljs-number"><span class="hljs-number">0.99f</span></span>; bestHit.emission = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } } } }</code> </pre> <br>  Estamos apenas a um passo de ver tudo em a√ß√£o.  Vamos reestruturar um pouco a fun√ß√£o <code>Trace</code> e adicionar um rastreamento de objetos de malha: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray)</span></span></span><span class="hljs-function"> </span></span>{ RayHit bestHit = CreateRayHit(); uint count, stride, i; <span class="hljs-comment"><span class="hljs-comment">// Trace ground plane IntersectGroundPlane(ray, bestHit); // Trace spheres _Spheres.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectSphere(ray, bestHit, _Spheres[i]); } // Trace mesh objects _MeshObjects.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectMeshObject(ray, bestHit, _MeshObjects[i]); } return bestHit; }</span></span></code> </pre> <br><h2>  Resultados </h2><br>  Isso √© tudo!  Vamos adicionar algumas malhas simples (as primitivas do Unity s√£o boas), fornecer o componente <code>RayTracingObject</code> e observar a m√°gica.  Ainda <strong>n√£o use</strong> malhas detalhadas (mais de algumas centenas de tri√¢ngulos)!  Nosso shader n√£o possui otimiza√ß√£o e, se voc√™ exagerar, pode levar alguns segundos ou at√© minutos para rastrear pelo menos uma amostra por pixel.  Como resultado, o sistema interromper√° o driver da GPU, o mecanismo do Unity poder√° travar e o computador precisar√° reiniciar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/1d4/40e/c801d440e5a0a21f660b5a7e82e1b368.png"></div><br>  Observe que nossas malhas n√£o t√™m sombreamento suave, mas plano.  Como ainda n√£o carregamos as normais dos v√©rtices no buffer, para obter a normal dos v√©rtices de cada tri√¢ngulo, devemos executar um produto vetorial.  Al√©m disso, n√£o podemos interpolar sobre a √°rea do tri√¢ngulo.  Lidaremos com esse problema na pr√≥xima parte do tutorial. <br><br>  Por uma quest√£o de interesse, baixei Stanford Bunny do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivo Morgan McGwire</a> e, usando o modificador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dizima√ß√£o do</a> pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blender</a> , reduzi o n√∫mero de v√©rtices para 431. Voc√™ pode experimentar par√¢metros de ilumina√ß√£o e material codificado na fun√ß√£o de sombreamento <code>IntersectMeshObject</code> .  Aqui est√° um coelho diel√©trico com belas sombras suaves e um pouco de ilumina√ß√£o global difusa no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grafitti Shelter</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0da/860/bb4/0da860bb41d9465f2dc21d649a509a66.png"></div><br>  ... e aqui est√° um coelho de metal sob a forte luz direcional de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cape Hill</a> , lan√ßando brilho de discoteca no piso plano: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/bb1/a64/a76bb1a642d620929ecd250f92e1ef1f.jpg"></div><br>  ... e aqui est√£o dois coelhinhos escondidos sob a grande pedra Suzanne sob o c√©u azul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kiara 9 Dusk</a> (prescrevi material alternativo para o segundo objeto, verificando se a mudan√ßa de √≠ndice √© zero): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ef/196/a4f/7ef196a4f818b366b4838f2b1e4148f5.png"></div><br><h2>  O que vem a seguir? </h2><br>  √â √≥timo ver uma malha real em seu pr√≥prio marcador pela primeira vez, certo?  Hoje processamos alguns dados, descobrimos a interse√ß√£o usando o algoritmo Meller-Trambor e coletamos tudo para que pud√©ssemos usar imediatamente o mecanismo GameObjects do mecanismo Unity.  Al√©m disso, vimos uma das vantagens do rastreamento de raios: assim que voc√™ adiciona uma nova interse√ß√£o ao c√≥digo, todos os belos efeitos (sombras suaves, ilumina√ß√£o global refletida e difusa e assim por diante) come√ßam imediatamente a funcionar. <br><br>  Renderizar um coelho brilhante levou muito tempo, e eu ainda tive que usar um pouco de filtragem para me livrar do barulho mais √≥bvio.  Para resolver esse problema, uma cena geralmente √© escrita em uma estrutura espacial, por exemplo, em uma grade, em uma √°rvore K-dimensional ou em uma hierarquia de volumes delimitadores, o que aumenta significativamente a velocidade de renderiza√ß√£o de grandes cenas. <br><br>  Mas precisamos avan√ßar em ordem: al√©m disso, eliminaremos o problema das normais, para que nossas malhas (mesmo as de baixo poli) pare√ßam mais suaves do que agora.  Tamb√©m seria bom atualizar matrizes automaticamente ao mover objetos e se referir diretamente aos materiais do Unity, e n√£o apenas escrev√™-los no c√≥digo.  √â isso que faremos na pr√≥xima parte da s√©rie de tutoriais.  Obrigado pela leitura e at√© a parte 4! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450308/">https://habr.com/ru/post/pt450308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450294/index.html">Os venenos mais assustadores</a></li>
<li><a href="../pt450298/index.html">Futuro qu√¢ntico (continua√ß√£o)</a></li>
<li><a href="../pt450300/index.html">Pare de discutir sobre programa√ß√£o funcional e POO</a></li>
<li><a href="../pt450302/index.html">Amateur Radio Technology: fabrica√ß√£o de prot√≥tipos de placas de circuito em uma f√°brica chinesa</a></li>
<li><a href="../pt450304/index.html">Carapuzik montando uma formiga: 100 milh√µes de anos de mirmecofilia</a></li>
<li><a href="../pt450310/index.html">Como o Philips VideoWRITER funciona. Primeiras fotos de ferro, depois um pouco de t√©dio</a></li>
<li><a href="../pt450312/index.html">Guia de inicia√ß√£o do Docker Compose</a></li>
<li><a href="../pt450314/index.html">TensorFlow para iniciantes. Parte 1: informa√ß√µes gerais, instalando a biblioteca</a></li>
<li><a href="../pt450316/index.html">TDD: uma metodologia de desenvolvimento que mudou minha vida</a></li>
<li><a href="../pt450318/index.html">Padr√µes de design no desenvolvimento moderno de JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>