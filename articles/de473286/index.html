<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèª üêù üë©üèø‚Äçü§ù‚Äçüë®üèº Wir schreiben Schutz gegen DDoS-Angriffe auf XDP. Kernteil üôè ‚ùáÔ∏è üîÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die XDP-Technologie (EXpress Data Path) erm√∂glicht die willk√ºrliche Verarbeitung des Datenverkehrs auf Linux-Schnittstellen, bevor Pakete auf dem Kern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben Schutz gegen DDoS-Angriffe auf XDP. Kernteil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473286/"><p>  Die XDP-Technologie (EXpress Data Path) erm√∂glicht die willk√ºrliche Verarbeitung des Datenverkehrs auf Linux-Schnittstellen, bevor Pakete auf dem Kernel-Netzwerkstapel eintreffen.  Anwendung von XDP - Schutz vor DDoS-Angriffen (CloudFlare), ausgefeilte Filter, Statistiksammlung (Netflix).  XDP-Programme werden von der virtuellen eBPF-Maschine ausgef√ºhrt. Daher unterliegen sie je nach Filtertyp Einschr√§nkungen hinsichtlich des Codes und der verf√ºgbaren Kernelfunktionen. </p><br><p>  Der Artikel soll die M√§ngel zahlreicher XDP-Materialien ausgleichen.  Erstens stellen sie vorgefertigten Code bereit, der die Funktionen von XDP sofort umgeht: Zur √úberpr√ºfung vorbereitet oder zu einfach, um Probleme zu verursachen.  Wenn Sie versuchen, Ihren Code von Grund auf neu zu schreiben, wissen Sie nicht, wie Sie mit typischen Fehlern umgehen sollen.  Zweitens werden Methoden zum lokalen Testen von XDP ohne VMs und Hardware nicht behandelt, obwohl sie ihre eigenen Fallstricke haben.  Der Text richtet sich an Programmierer, die mit Netzwerken und Linux vertraut sind und sich f√ºr XDP und eBPF interessieren. </p><a name="habracut"></a><br><p> In diesem Teil werden wir detailliert untersuchen, wie der XDP-Filter zusammengesetzt ist und wie er getestet wird. Anschlie√üend werden wir eine einfache Version des bekannten SYN-Cookie-Mechanismus auf Paketverarbeitungsebene schreiben.  Wir werden zwar keine "wei√üe Liste" bilden <br>  Kunden verifiziert, Z√§hler gef√ºhrt und Filter verwaltet - gen√ºgend Protokolle. </p><br><p>  Wir werden in C schreiben - das ist nicht in Mode, aber praktisch.  Der gesamte Code ist auf GitHub √ºber den Link am Ende verf√ºgbar und wird gem√§√ü den im Artikel beschriebenen Schritten in Commits unterteilt. </p><br><p>  <strong>Haftungsausschluss.</strong>  W√§hrend des Artikels wird eine Minil√∂sung entwickelt, um DDoS-Angriffe abzuwehren, da dies eine realistische Aufgabe f√ºr XDP und meinen Bereich ist.  Das Hauptziel ist jedoch der Umgang mit Technologie. Dies ist kein Leitfaden f√ºr die Schaffung eines vorgefertigten Schutzes.  Der Trainingscode ist nicht optimiert und l√§sst einige Nuancen aus. </p><br><h2 id="kratkiy-obzor-xdp">  XDP auf einen Blick </h2><br><p>  Ich werde nur wichtige Punkte skizzieren, um die Dokumentation und die vorhandenen Artikel nicht zu duplizieren. </p><br><p> Der Filtercode wird also in den Kernel geladen.  Eingehende Pakete werden an den Filter gesendet.  Infolgedessen muss der Filter eine Entscheidung treffen: √úberspringen Sie das Paket zum Kernel ( <code>XDP_PASS</code> ), verwerfen Sie das Paket ( <code>XDP_DROP</code> ) oder senden Sie es zur√ºck ( <code>XDP_TX</code> ).  Der Filter kann das Paket √§ndern, dies gilt insbesondere f√ºr <code>XDP_TX</code> .  Sie k√∂nnen das Programm auch zum Absturz bringen ( <code>XDP_ABORTED</code> ) und das Paket verwerfen. Dies ist jedoch ein Analogon von <code>assert(0)</code> zum Debuggen. </p><br><p>  Die virtuelle eBPF-Maschine (erweiterter Berkley Packet Filter) wurde speziell vereinfacht, damit der Kernel √ºberpr√ºfen kann, ob der Code keine Schleife durchl√§uft und den Speicher eines anderen nicht besch√§digt.  Aggregierte Einschr√§nkungen und √úberpr√ºfungen: </p><br><ul><li>  Verbotene Zyklen (zur√ºckspringen). </li><li>  Es gibt einen Stapel f√ºr Daten, aber keine Funktionen (alle C-Funktionen m√ºssen inline sein). </li><li>  Der Zugriff auf Speicher au√üerhalb des Stapels und des Paketpuffers ist verboten. </li><li>  Die Codegr√∂√üe ist begrenzt, aber in der Praxis ist dies nicht sehr wichtig. </li><li>  Aufrufe sind nur f√ºr spezielle Kernelfunktionen (eBPF-Helfer) zul√§ssig. </li></ul><br><p>  Das Design und die Installation des Filters sehen folgenderma√üen aus: </p><br><ol><li>  Der Quellcode (z. B. <code>kernel.c</code> ) wird unter der Architektur der virtuellen eBPF-Maschine in das Objekt ( <code>kernel.o</code> ) kompiliert.  Ab Oktober 2019 wird die Kompilierung in eBPF von Clang unterst√ºtzt und in GCC 10.1 versprochen. </li><li>  Wenn in diesem Objektcode Kernelstrukturen (z. B. Tabellen und Z√§hler) aufgerufen werden, werden anstelle ihrer IDs Nullen verwendet, dh, ein solcher Code kann nicht ausgef√ºhrt werden.  Vor dem Laden in den Kernel m√ºssen Sie diese Nullen durch die ID bestimmter Objekte ersetzen, die durch Kernelaufrufe erstellt wurden (Linkcode).  Sie k√∂nnen dies mit externen Dienstprogrammen tun oder ein Programm schreiben, das einen bestimmten Filter verkn√ºpft und l√§dt. </li><li>  Der Kernel √ºberpr√ºft das geladene Programm.  Das Fehlen von Schleifen und Fehlzeiten √ºber die Grenzen von Paket und Stapel hinaus werden √ºberpr√ºft.  Wenn der Pr√ºfer nicht nachweisen kann, dass der Code korrekt ist, wird das Programm abgelehnt - Sie m√ºssen in der Lage sein, ihm zu gefallen. </li><li>  Nach erfolgreicher √úberpr√ºfung kompiliert der Kernel den eBPF-Architekturobjektcode in den Maschinencode der Systemarchitektur (Just-in-Time). </li><li>  Das Programm wird an die Schnittstelle angeschlossen und beginnt mit der Verarbeitung von Paketen. </li></ol><br><p>  Da XDP im Kernel funktioniert, erfolgt das Debuggen √ºber Ablaufverfolgungsprotokolle und tats√§chlich √ºber Pakete, die das Programm filtert oder generiert.  EBPF bietet jedoch Sicherheit f√ºr den geladenen Code des Systems, sodass Sie direkt unter lokalem Linux mit XDP experimentieren k√∂nnen. </p><br><h2 id="podgotovka-okruzheniya">  Umweltvorbereitung </h2><br><h3 id="sborka">  Montage </h3><br><p>  Clang kann keinen Objektcode f√ºr die eBPF-Architektur direkt ausgeben, daher besteht der Prozess aus zwei Schritten: </p><br><ol><li>  Kompilieren Sie C-Code in LLVM-Bytecode ( <code>clang -emit-llvm</code> ). </li><li>  Konvertieren Sie den Bytecode in den eBPF-Objektcode ( <code>llc -march=bpf -filetype=obj</code> ). </li></ol><br><p>  Beim Schreiben eines Filters sind einige Dateien mit Zusatzfunktionen und Makros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aus Kerneltests</a> hilfreich.  Es ist wichtig, dass sie mit der Kernel-Version ( <code>KVER</code> ) <code>KVER</code> .  Laden Sie sie in <code>helpers/</code> herunter: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KVER=v5.3.7 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> BASE=https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/plain/tools/testing/selftests/bpf wget -P helpers --content-disposition <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_helpers.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${BASE}</span></span></span><span class="hljs-string">/bpf_endian.h?h=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KVER}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span> KVER BASE</code> </pre> <br><p>  Makefile f√ºr Arch Linux (Kernel 5.3.7): </p><br><pre> <code class="plaintext hljs">CLANG ?= clang LLC ?= llc KDIR ?= /lib/modules/$(shell uname -r)/build ARCH ?= $(subst x86_64,x86,$(shell uname -m)) CFLAGS = \ -Ihelpers \ \ -I$(KDIR)/include \ -I$(KDIR)/include/uapi \ -I$(KDIR)/include/generated/uapi \ -I$(KDIR)/arch/$(ARCH)/include \ -I$(KDIR)/arch/$(ARCH)/include/generated \ -I$(KDIR)/arch/$(ARCH)/include/uapi \ -I$(KDIR)/arch/$(ARCH)/include/generated/uapi \ -D__KERNEL__ \ \ -fno-stack-protector -O2 -g xdp_%.o: xdp_%.c Makefile $(CLANG) -c -emit-llvm $(CFLAGS) $&lt; -o - | \ $(LLC) -march=bpf -filetype=obj -o $@ .PHONY: all clean all: xdp_filter.o clean: rm -f ./*.o</code> </pre> <br><p>  <code>KDIR</code> enth√§lt den Pfad zu den Kernel-Headern, <code>ARCH</code> - die Architektur des Systems.  Pfade und Werkzeuge k√∂nnen zwischen den Verteilungen geringf√ºgig variieren. </p><br><div class="spoiler">  <b class="spoiler_title">Differenzbeispiel f√ºr Debian 10 (Kernel 4.19.67)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   CLANG ?= clang LLC ?= llc-7 #   KDIR ?= /usr/src/linux-headers-$(shell uname -r) ARCH ?= $(subst x86_64,x86,$(shell uname -m)) #    -I CFLAGS = \ -Ihelpers \ \ -I/usr/src/linux-headers-4.19.0-6-common/include \ -I/usr/src/linux-headers-4.19.0-6-common/arch/$(ARCH)/include \ #   </code> </pre> </div></div><br><p>  <code>CFLAGS</code> enthalten ein Verzeichnis mit zus√§tzlichen Headern und mehrere Verzeichnisse mit Kernel-Headern.  Das Symbol <code>__KERNEL__</code> bedeutet, dass UAPI-Header (Userspace-APIs) f√ºr den Kernelcode definiert sind, da der Filter im Kernel ausgef√ºhrt wird. </p><br><p>  Der <code>-fno-stack-protector</code> kann deaktiviert werden ( <code>-fno-stack-protector</code> ), da der eBPF-Code-Verifizierer weiterhin nach einem Ausweg aus dem Stapel sucht.  Die Optimierung sollte sofort einbezogen werden, da die Gr√∂√üe des eBPF-Bytecodes begrenzt ist. </p><br><p>  Beginnen wir mit einem Filter, der alle Pakete √ºberspringt und nichts tut: </p><br><pre> <code class="plaintext hljs">#include &lt;uapi/linux/bpf.h&gt; #include &lt;bpf_helpers.h&gt; SEC("prog") int xdp_main(struct xdp_md* ctx) { return XDP_PASS; } char _license[] SEC("license") = "GPL";</code> </pre> <br><p>  Der Befehl <code>make</code> <code>xdp_filter.o</code> .  Wo kann man es jetzt testen? </p><br><h3 id="testovyy-stend">  Pr√ºfstand </h3><br><p>  Der Stand sollte zwei Schnittstellen enthalten: auf denen sich ein Filter befindet und von denen Pakete gesendet werden.  Dies m√ºssen vollwertige Linux-Ger√§te mit ihrer IP sein, um zu √ºberpr√ºfen, wie regul√§re Anwendungen mit unserem Filter funktionieren. </p><br><p>  Ger√§te wie veth (virtuelles Ethernet) sind f√ºr uns geeignet: Sie sind ein Paar virtueller Netzwerkschnittstellen, die direkt miteinander ‚Äûverbunden‚Äú sind.  Sie k√∂nnen sie folgenderma√üen erstellen (in diesem Abschnitt werden alle <code>ip</code> Befehle als <code>root</code> ): </p><br><pre> <code class="bash hljs">ip link add xdp-remote <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> veth peer name xdp-local</code> </pre> <br><p>  Hier sind <code>xdp-remote</code> und <code>xdp-local</code> Ger√§tenamen.  Ein Filter wird an <code>xdp-local</code> (192.0.2.1/24) angeh√§ngt, und eingehender Datenverkehr wird von <code>xdp-remote</code> (192.0.2.2/24) gesendet.  Es gibt jedoch ein Problem: Die Schnittstellen befinden sich auf demselben Computer, und Linux sendet keinen Datenverkehr √ºber den anderen an einen von ihnen.  Sie k√∂nnen dies mit den kniffligen <code>iptables</code> Regeln l√∂sen, aber sie m√ºssen die Pakete √§ndern, was beim Debuggen unpraktisch ist.  Es ist besser, Netzwerk-Namespaces (Netzwerk-Namespaces, im Folgenden netns) zu verwenden. </p><br><p>  Der Netzwerk-Namespace enth√§lt eine Reihe von Schnittstellen, Routing-Tabellen und NetFilter-Regeln, die von √§hnlichen Objekten in anderen Netzwerken isoliert sind.  Jeder Prozess wird in einem Namespace ausgef√ºhrt, auf den nur Objekte dieser Netze zugreifen k√∂nnen.  Standardm√§√üig verf√ºgt das System √ºber einen einzigen Netzwerk-Namespace f√ºr alle Objekte, sodass Sie unter Linux arbeiten k√∂nnen und keine Kenntnisse √ºber Netze haben. </p><br><p>  Erstellen Sie einen neuen <code>xdp-test</code> Namespace und verschieben Sie <code>xdp-remote</code> . </p><br><pre> <code class="bash hljs">ip netns add xdp-test ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-remote netns xdp-test</code> </pre> <br><p>  Dann wird der in <code>xdp-test</code> Prozess <code>xdp-local</code> nicht "sehen" (er bleibt standardm√§√üig in netns) und wird beim Senden eines Pakets an 192.0.2.1 √ºber <code>xdp-remote</code> , da dies die einzige Schnittstelle in 192.0.2.0/ ist. 24 f√ºr diesen Prozess verf√ºgbar.  Dies funktioniert auch in die entgegengesetzte Richtung. </p><br><p>  Beim Wechsel zwischen den Netzwerken wird die Schnittstelle gel√∂scht und verliert die Adresse.  Um die Schnittstelle in netns zu konfigurieren, m√ºssen Sie <code>ip ...</code> in diesem <code>ip netns exec</code> Befehls <code>ip netns exec</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip address add 192.0.2.2/24 dev xdp-remote ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-remote up</code> </pre> <br><p>  Wie Sie sehen, unterscheidet sich dies nicht von der Einstellung von <code>xdp-local</code> im Standard-Namespace: </p><br><pre> <code class="bash hljs"> ip address add 192.0.2.1/24 dev xdp-local ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> xdp-local up</code> </pre> <br><p>  Wenn Sie <code>tcpdump -tnevi xdp-local</code> , k√∂nnen Sie sehen, dass von <code>xdp-test</code> gesendete Pakete an diese Schnittstelle gesendet werden: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test ping 192.0.2.1</code> </pre> <br><p>  Es ist praktisch, die Shell im <code>xdp-test</code> .  Im Repository befindet sich ein Skript, das die Arbeit mit dem Stand automatisiert. Sie k√∂nnen den Stand beispielsweise mit dem Befehl <code>sudo ./stand up</code> konfigurieren und mit dem Befehl <code>sudo ./stand down</code> l√∂schen. </p><br><h3 id="trassirovka">  Trace </h3><br><p>  Der Filter wird wie folgt an das Ger√§t angeschlossen: </p><br><pre> <code class="bash hljs">ip -force link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp object xdp_filter.o verbose</code> </pre> <br><p>  Der <code>-force</code> ben√∂tigt, um ein neues Programm zu binden, wenn bereits ein anderes gebunden ist.  "Keine Nachricht ist eine gute Nachricht" handelt nicht von diesem Befehl, die Schlussfolgerung ist auf jeden Fall umfangreich.  <code>verbose</code> optional, aber damit wird ein Bericht √ºber die Arbeit des Codeverifizierers mit der Assembly-Liste angezeigt: </p><br><pre> <code class="plaintext hljs">Verifier analysis: 0: (b7) r0 = 2 1: (95) exit</code> </pre> <br><p>  L√∂sen Sie das Programm von der Oberfl√§che: </p><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev xdp-local xdp off</code> </pre> <br><p>  Im Skript sind dies die <code>sudo ./stand detach</code> <code>sudo ./stand attach</code> und <code>sudo ./stand detach</code> . </p><br><p>  Durch Anh√§ngen eines Filters k√∂nnen Sie √ºberpr√ºfen, ob <code>ping</code> weiterhin funktioniert. Funktioniert das Programm jedoch?  F√ºgen Sie die Protokolle hinzu.  Die Funktion <a href=""><code>bpf_trace_printk()</code></a> √§hnelt <code>printf()</code> , unterst√ºtzt jedoch nur bis zu drei Argumente, mit Ausnahme der Vorlage und einer begrenzten Liste von Qualifizierern.  Das Makro <code>bpf_printk()</code> vereinfacht den Aufruf. </p><br><pre> <code class="diff hljs"> SEC("prog") int xdp_main(struct xdp_md* ctx) { + bpf_printk("got packet: %p\n", ctx); return XDP_PASS; }</code> </pre> <br><p>  Die Ausgabe geht an den Kernel-Trace-Kanal, den Sie aktivieren m√ºssen: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n 1 | sudo tee /sys/kernel/debug/tracing/options/trace_printk</code> </pre> <br><p>  Nachrichtenfluss anzeigen: </p><br><pre> <code class="bash hljs">cat /sys/kernel/debug/tracing/trace_pipe</code> </pre> <br><p>  Beide Befehle rufen <code>sudo ./stand log</code> . </p><br><p>  Ping sollte nun die folgenden Meldungen ausl√∂sen: </p><br><pre> <code class="plaintext hljs">&lt;...&gt;-110930 [004] ..s1 78803.244967: 0: got packet: 00000000ac510377</code> </pre> <br><p>  Wenn Sie sich die Ausgabe des √úberpr√ºfers genau ansehen, werden Sie seltsame Berechnungen bemerken: </p><br><pre> <code class="plaintext hljs">0: (bf) r3 = r1 1: (18) r1 = 0xa7025203a7465 3: (7b) *(u64 *)(r10 -8) = r1 4: (18) r1 = 0x6b63617020746f67 6: (7b) *(u64 *)(r10 -16) = r1 7: (bf) r1 = r10 8: (07) r1 += -16 9: (b7) r2 = 16 10: (85) call bpf_trace_printk#6 &lt;...&gt;</code> </pre> <br><p>  Tatsache ist, dass eBPF-Programme keinen Datenabschnitt haben. Die einzige M√∂glichkeit, eine Formatzeichenfolge zu codieren, besteht in den unmittelbaren Argumenten der VM-Befehle: </p><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">"import binascii; print(bytes(reversed(binascii.unhexlify('0a7025203a74656b63617020746f67'))))"</span></span> b<span class="hljs-string"><span class="hljs-string">'got packet: %p\n'</span></span></code> </pre> <br><p>  Aus diesem Grund erh√∂ht die Debug-Ausgabe den resultierenden Code erheblich. </p><br><h3 id="otpravka-paketov-xdp">  Senden von XDP-Paketen </h3><br><p>  Lassen Sie uns den Filter √§ndern: Lassen Sie ihn alle eingehenden Pakete zur√ºcksenden.  Dies ist aus Netzwerksicht falsch, da die Adressen in den Headern ge√§ndert werden m√ºssten, aber jetzt ist die Arbeit im Prinzip wichtig. </p><br><pre> <code class="diff hljs"> bpf_printk("got packet: %p\n", ctx); - return XDP_PASS; + return XDP_TX; }</code> </pre> <br><p>  F√ºhren Sie <code>tcpdump</code> auf <code>xdp-remote</code> .  Es sollte identische ausgehende und eingehende ICMP-Echoanforderung anzeigen und keine ICMP-Echoantwort mehr anzeigen.  Zeigt aber nicht.  Es stellt sich heraus, dass f√ºr <code>XDP_TX</code> , damit es in einem Programm auf <code>xdp-local</code> , die <code>xdp-remote</code> Schnittstelle <code>xdp-remote</code> werden muss, auch wenn sie leer ist, und sie <a href="">muss</a> <code>xdp-remote</code> werden. </p><br><div class="spoiler">  <b class="spoiler_title">Wie habe ich es herausgefunden?</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der</a> Perf-Ereignismechanismus, der dieselbe virtuelle Maschine verwendet, erm√∂glicht es √ºbrigens, den Paketpfad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Kernel zu verfolgen</a> , dh eBPF wird zum Zerlegen mit eBPF verwendet. </p><br><blockquote>  Aus dem B√∂sen muss man Gutes machen, denn es gibt nichts mehr zu machen. </blockquote><br><pre> <code class="bash hljs">$ sudo perf trace --call-graph dwarf -e <span class="hljs-string"><span class="hljs-string">'xdp:*'</span></span> 0.000 ping/123455 xdp:xdp_bulk_tx:ifindex=19 action=TX sent=0 drops=1 err=-6 veth_xdp_flush_bq ([veth]) veth_xdp_flush_bq ([veth]) veth_poll ([veth]) &lt;...&gt;</code> </pre> <br><p>  Was ist Code 6? </p><br><pre> <code class="bash hljs">$ errno 6 ENXIO 6 No such device or address</code> </pre> <br><p>  Die Funktion <code>veth_xdp_flush_bq()</code> erh√§lt einen Fehlercode von <code>veth_xdp_xmit()</code> , wo wir nach <code>ENXIO</code> suchen und einen Kommentar finden. </p></div></div><br><p>  <code>XDP_PASS</code> den Mindestfilter ( <code>XDP_PASS</code> ) in der Datei <code>xdp_dummy.c</code> , f√ºgen Sie ihn dem Makefile hinzu und h√§ngen Sie ihn an <code>xdp-remote</code> : </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> remote \ ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev int xdp object dummy.o</code> </pre> <br><p>  Jetzt zeigt <code>tcpdump</code> , was erwartet wird: </p><br><pre> <code class="plaintext hljs">62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64 62:57:8e:70:44:64 &gt; 26:0e:25:37:8f:96, ethertype IPv4 (0x0800), length 98: (tos 0x0, ttl 64, id 13762, offset 0, flags [DF], proto ICMP (1), length 84) 192.0.2.2 &gt; 192.0.2.1: ICMP echo request, id 46966, seq 1, length 64</code> </pre> <br><p>  Wenn stattdessen nur ARP angezeigt wird, m√ºssen Sie die Filter entfernen (dies erfolgt durch <code>sudo ./stand detach</code> ), den <code>ping</code> starten, dann die Filter einstellen und es erneut versuchen.  Das Problem ist, dass der <code>XDP_TX</code> Filter sowohl ARP als auch den Stack beeinflusst <br>  <code>xdp-test</code> Namespace hat es geschafft, die MAC-Adresse 192.0.2.1 zu "vergessen". Diese IP kann nicht aufgel√∂st werden. </p><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p>  Fahren wir mit der angegebenen Aufgabe fort: Schreiben Sie den SYN-Cookie-Mechanismus auf XDP. </p><br><p>  Bis jetzt ist die SYN-Flut ein beliebter DDoS-Angriff, dessen Kern wie folgt ist.  Beim Herstellen einer Verbindung (TCP-Handshake) empf√§ngt der Server eine SYN, weist Ressourcen f√ºr eine zuk√ºnftige Verbindung zu, antwortet mit einem SYNACK-Paket und wartet auf eine ACK.  Der Angreifer sendet einfach SYN-Pakete von gef√§lschten Adressen in H√∂he von Tausenden pro Sekunde von jedem Host aus einem Multi-Tausend-Botnetz.  Der Server ist gezwungen, Ressourcen sofort nach dem Eintreffen des Pakets zuzuweisen, und wird durch ein gro√ües Zeitlimit frei, wodurch Speicher oder Limits ersch√∂pft werden, neue Verbindungen nicht akzeptiert werden und der Dienst nicht verf√ºgbar ist. </p><br><p>  Wenn Sie dem SYN-Paket keine Ressourcen zuweisen, sondern nur mit einem SYNACK-Paket antworten, wie kann der Server dann verstehen, dass das sp√§ter eingegangene ACK-Paket auf ein nicht gespeichertes SYN-Paket verweist?  Schlie√ülich kann ein Angreifer auch gef√§lschte ACKs generieren.  Die Essenz des SYN-Cookies besteht darin, die <code>seqnum</code> in <code>seqnum</code> als Hash aus Adressen, Ports und wechselndem Salt zu codieren.  Wenn die ACK vor dem <code>acknum</code> angekommen ist, k√∂nnen Sie den Hash erneut berechnen und mit <code>acknum</code> vergleichen.  Der Angreifer kann kein <code>acknum</code> vort√§uschen, da das Salz ein Geheimnis enth√§lt und aufgrund des begrenzten Kanals keine Zeit zum <code>acknum</code> hat. </p><br><p>  SYN-Cookie ist seit langem im Linux-Kernel implementiert und wird m√∂glicherweise sogar automatisch aktiviert, wenn SYN zu schnell und in gro√üen Mengen eintrifft. </p><br><div class="spoiler">  <b class="spoiler_title">Bildungsprogramm zum TCP-Handshake</b> <div class="spoiler_text"><p>  TCP stellt die Daten√ºbertragung als Bytestrom bereit. Beispielsweise werden HTTP-Anforderungen √ºber TCP gesendet.  Der Stream wird in Paketen in St√ºcken √ºbertragen.  Alle TCP-Pakete haben logische Flags und 32-Bit-Sequenznummern: </p><br><ul><li><p>  Die Kombination von Flags bestimmt die Rolle eines bestimmten Pakets.  Das SYN-Flag bedeutet, dass dies das erste Senderpaket in der Verbindung ist.  Das ACK-Flag bedeutet, dass der Absender alle Verbindungsdaten vor dem <code>acknum</code> .  Ein Paket kann mehrere Flags haben und wird durch ihre Kombination aufgerufen, beispielsweise ein SYNACK-Paket. </p><br></li><li><p>  Die Sequenznummer (seqnum) definiert den Offset im Datenstrom f√ºr das erste Byte, das in diesem Paket √ºbertragen wird.  Wenn beispielsweise im ersten Paket mit X Datenbytes diese Nummer N war, ist sie im n√§chsten Paket mit neuen Daten N + X.  Zu Beginn der Verbindung w√§hlt jede Seite diese Nummer willk√ºrlich aus. </p><br></li><li><p>  Best√§tigungsnummer (acknum) - der gleiche Versatz wie seqnum, bestimmt jedoch nicht die Anzahl der zu √ºbertragenden Bytes, sondern die Nummer des ersten Bytes des Empf√§ngers, das der Absender nicht gesehen hat. </p><br></li></ul><br><p>  Zu Beginn der Verbindung m√ºssen sich die Parteien auf <code>seqnum</code> und <code>acknum</code> .  Der Client sendet ein SYN-Paket mit der <code>seqnum = X</code>  Der Server antwortet mit einem SYNACK-Paket, in das er seine <code>seqnum = Y</code> schreibt und <code>acknum = X + 1</code> .  Der Client antwortet auf SYNACK mit einem ACK-Paket, wobei <code>seqnum = X + 1</code> , <code>acknum = Y + 1</code> .  Danach beginnt die eigentliche Daten√ºbertragung. </p><br><p>  Wenn der Gespr√§chspartner den Empfang des Pakets nicht best√§tigt, sendet TCP es erneut per Timeout. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Warum werden SYN-Cookies nicht immer verwendet?</b> <div class="spoiler_text"><p>  Wenn SYNACK oder ACK verloren gehen, m√ºssen Sie zun√§chst auf das erneute Senden warten - die Verbindung wird verlangsamt.  Zweitens im SYN-Paket - und nur darin!  - Es werden eine Reihe von Optionen √ºbertragen, die sich auf den weiteren Betrieb der Verbindung auswirken.  Ohne sich an die eingehenden SYN-Pakete zu erinnern, ignoriert der Server diese Optionen. In den n√§chsten Paketen sendet der Client sie nicht mehr.  In diesem Fall kann TCP funktionieren, aber zumindest in der Anfangsphase nimmt die Qualit√§t der Verbindung ab. </p></div></div><br><p>  In Bezug auf Pakete sollte ein XDP-Programm Folgendes tun: </p><br><ul><li>  SYNACK mit Cookie, um auf SYN zu antworten; </li><li>  auf ACK RST reagieren (trennen); </li><li>  andere Pakete verwerfen. </li></ul><br><p>  Algorithmus Pseudocode zusammen mit dem Parsen des Pakets: </p><br><pre> <code class="plaintext hljs">   Ethernet,  .    IPv4,  .     , (*)    ,  .    TCP,  . (**)   SYN,  SYN-ACK  cookie.   ACK,   acknum   cookie,  .      N  . (*)  RST. (**)     .</code> </pre> <br><p>  Ein <code>(*)</code> gibt die Punkte an, an denen der Status des Systems gesteuert werden soll. In der ersten Phase k√∂nnen Sie auf diese Punkte verzichten, indem Sie einfach einen TCP-Handshake mit der Generierung eines SYN-Cookies als Folge implementieren. </p><br><p>  An Ort und Stelle <code>(**)</code> √ºberspringen wir das Paket, obwohl wir keine Tabelle haben. </p><br><h2 id="realizaciya-tcp-handshake">  TCP-Handshake-Implementierung </h2><br><h3 id="razbor-paketa-i-verifikaciya-koda">  Analysieren Sie das Paket und √ºberpr√ºfen Sie den Code </h3><br><p>  Wir ben√∂tigen Netzwerk-Header-Strukturen: Ethernet ( <code>uapi/linux/if_ether.h</code> ), IPv4 ( <code>uapi/linux/ip.h</code> ) und TCP ( <code>uapi/linux/tcp.h</code> ).  Als letztes konnte ich aufgrund von Fehlern im Zusammenhang mit <code>atomic64_t</code> keine Verbindung <code>atomic64_t</code> . Ich musste die erforderlichen Definitionen in den Code kopieren. </p><br><p>  Alle Funktionen, die in C zur besseren Lesbarkeit zugewiesen sind, sollten am Ort des Aufrufs eingebaut werden, da der eBPF-Verifizierer im Kernel R√ºck√ºberg√§nge verhindert, dh Schleifen und Funktionsaufrufe. </p><br><pre> <code class="plaintext hljs">#define INTERNAL static __attribute__((always_inline))</code> </pre> <br><p>  Das Makro <code>LOG()</code> deaktiviert das Drucken im Release-Build. </p><br><p>  Das Programm ist ein F√∂rderer von Funktionen.  Jeder empf√§ngt ein Paket, in dem der Header der entsprechenden Ebene hervorgehoben ist. Beispielsweise erwartet <code>process_ether()</code> dass der <code>ether</code> voll ist.  Basierend auf den Ergebnissen der Feldanalyse kann die Funktion das Paket auf eine h√∂here Ebene √ºbertragen.  Das Ergebnis der Funktion ist die XDP-Aktion.  Bisher √ºbergeben SYN- und ACK-Handler alle Pakete. </p><br><pre> <code class="plaintext hljs">struct Packet { struct xdp_md* ctx; struct ethhdr* ether; struct iphdr* ip; struct tcphdr* tcp; }; INTERNAL int process_tcp_syn(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp_ack(struct Packet* packet) { return XDP_PASS; } INTERNAL int process_tcp(struct Packet* packet) { ... } INTERNAL int process_ip(struct Packet* packet) { ... } INTERNAL int process_ether(struct Packet* packet) { struct ethhdr* ether = packet-&gt;ether; LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto)); if (ether-&gt;h_proto != bpf_ntohs(ETH_P_IP)) { return XDP_PASS; } // B struct iphdr* ip = (struct iphdr*)(ether + 1); if ((void*)(ip + 1) &gt; (void*)packet-&gt;ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } packet-&gt;ip = ip; return process_ip(packet); } SEC("prog") int xdp_main(struct xdp_md* ctx) { struct Packet packet; packet.ctx = ctx; // A struct ethhdr* ether = (struct ethhdr*)(void*)ctx-&gt;data; if ((void*)(ether + 1) &gt; (void*)ctx-&gt;data_end) { return XDP_PASS; } packet.ether = ether; return process_ether(&amp;packet); }</code> </pre> <br><p>  Ich mache auf die mit A und B gekennzeichneten Schecks aufmerksam. Wenn Sie A auskommentieren, wird das Programm zusammengestellt, aber beim Laden tritt ein √úberpr√ºfungsfehler auf: </p><br><pre> <code class="plaintext hljs">Verifier analysis: &lt;...&gt; 11: (7b) *(u64 *)(r10 -48) = r1 12: (71) r3 = *(u8 *)(r7 +13) invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0) R7 offset is outside of the packet processed 11 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0 Error fetching program/map!</code> </pre> <br><p>  Die Schl√ºsselzeile ist <code>invalid access to packet, off=13 size=1, R7(id=0,off=0,r=0)</code> : Es gibt Ausf√ºhrungspfade, wenn das dreizehnte Byte vom Anfang des Puffers au√üerhalb des Pakets liegt.  Gem√§√ü der Auflistung ist es schwierig zu verstehen, um welche Zeile es sich handelt, aber es gibt eine Anweisungsnummer (12) und einen Disassembler, der die Zeilen des Quellcodes anzeigt: </p><br><pre> <code class="bash hljs">llvm-objdump -S xdp_filter.o | less</code> </pre> <br><p>  In diesem Fall zeigt es auf eine Zeichenfolge </p><br><pre> <code class="plaintext hljs">LOG("Ether(proto=0x%x)", bpf_ntohs(ether-&gt;h_proto));</code> </pre> <br><p>  womit klar ist, dass das Problem im <code>ether</code> .  Es w√§re immer so. </p><br><h3 id="otvet-na-syn">  Antworte auf SYN </h3><br><p>  Das Ziel in dieser Phase ist es, ein korrektes SYNACK-Paket mit einer festen <code>seqnum</code> , das in Zukunft durch ein SYN-Cookie ersetzt wird.  Alle √Ñnderungen erfolgen in <code>process_tcp_syn()</code> und in der Umgebung. </p><br><h4 id="proverka-paketa">  Paketpr√ºfung </h4><br><p>  Seltsamerweise ist hier die bemerkenswerteste Zeile, genauer gesagt, ein Kommentar dazu: </p><br><pre> <code class="plaintext hljs">/* Required to verify checksum calculation */ const void* data_end = (const void*)ctx-&gt;data_end;</code> </pre> <br><p>  Beim Schreiben der ersten Version des Codes wurde der 5.1-Kernel verwendet, f√ºr dessen <code>data_end</code> ein Unterschied zwischen <code>data_end</code> und <code>(const void*)ctx-&gt;data_end</code> .  Beim Schreiben des Artikels hatte der 5.3.1-Kernel kein solches Problem.  M√∂glicherweise hat der Compiler anders als im Feld auf die lokale Variable zugegriffen.  Moralisch vereinfachter Code kann bei vielen Verschachtelungen helfen. </p><br><p>  Weitere routinem√§√üige L√§ngenpr√ºfungen zu Ehren des Pr√ºfers;  √ºber <code>MAX_CSUM_BYTES</code> unten. </p><br><pre> <code class="plaintext hljs">const u32 ip_len = ip-&gt;ihl * 4; if ((void*)ip + ip_len &gt; data_end) { return XDP_DROP; /* malformed packet */ } if (ip_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ } const u32 tcp_len = tcp-&gt;doff * 4; if ((void*)tcp + tcp_len &gt; (void*)ctx-&gt;data_end) { return XDP_DROP; /* malformed packet */ } if (tcp_len &gt; MAX_CSUM_BYTES) { return XDP_ABORTED; /* implementation limitation */ }</code> </pre> <br><h4 id="razvorot-paketa">  Paket verteilt </h4><br><p>  F√ºllen Sie <code>seqnum</code> und <code>acknum</code> , setzen Sie ACK (SYN ist bereits gesetzt): </p><br><pre> <code class="plaintext hljs">const u32 cookie = 42; tcp-&gt;ack_seq = bpf_htonl(bpf_ntohl(tcp-&gt;seq) + 1); tcp-&gt;seq = bpf_htonl(cookie); tcp-&gt;ack = 1;</code> </pre> <br><p>  Tauschen Sie TCP-Ports, IP-Adresse und MAC-Adresse aus.  Auf die Standardbibliothek kann vom XDP-Programm nicht zugegriffen werden, daher ist <code>memcpy()</code> ein Makro, das die Clang-Eigenschaft verbirgt. </p><br><pre> <code class="plaintext hljs">const u16 temp_port = tcp-&gt;source; tcp-&gt;source = tcp-&gt;dest; tcp-&gt;dest = temp_port; const u32 temp_ip = ip-&gt;saddr; ip-&gt;saddr = ip-&gt;daddr; ip-&gt;daddr = temp_ip; struct ethhdr temp_ether = *ether; memcpy(ether-&gt;h_dest, temp_ether.h_source, ETH_ALEN); memcpy(ether-&gt;h_source, temp_ether.h_dest, ETH_ALEN);</code> </pre> <br><h4 id="pereschet-kontrolnyh-summ">  Neuberechnung der Pr√ºfsumme </h4><br><p>  Die IPv4- und TCP-Pr√ºfsummen erfordern das Hinzuf√ºgen aller 16-Bit-W√∂rter in den Headern, und die Gr√∂√üe der Header wird in diese geschrieben, dh zum Zeitpunkt der Kompilierung ist dies nicht bekannt.  Dies ist ein Problem, da der Pr√ºfer eine regul√§re Schleife nicht zu einer variablen Grenze √ºberspringt.  Die Gr√∂√üe der Header ist jedoch begrenzt: jeweils bis zu 64 Byte.  Sie k√∂nnen eine Schleife mit einer festen Anzahl von Iterationen erstellen, die vorzeitig enden kann. </p><br><p>  Ich stelle fest, dass es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 1624 gibt,</a> wie die Pr√ºfsumme teilweise neu berechnet werden kann, wenn nur feste Paketw√∂rter ge√§ndert werden.  Die Methode ist jedoch nicht universell und die Implementierung w√§re schwieriger aufrechtzuerhalten. </p><br><p>  Pr√ºfsummenberechnungsfunktion: </p><br><pre> <code class="plaintext hljs">#define MAX_CSUM_WORDS 32 #define MAX_CSUM_BYTES (MAX_CSUM_WORDS * 2) INTERNAL u32 sum16(const void* data, u32 size, const void* data_end) { u32 s = 0; #pragma unroll for (u32 i = 0; i &lt; MAX_CSUM_WORDS; i++) { if (2*i &gt;= size) { return s; /* normal exit */ } if (data + 2*i + 1 + 1 &gt; data_end) { return 0; /* should be unreachable */ } s += ((const u16*)data)[i]; } return s; }</code> </pre> <br><p>   ,  <code>size</code>   ,    ,      . </p><br><p>  32-     : </p><br><pre> <code class="plaintext hljs">INTERNAL u32 sum16_32(u32 v) { return (v &gt;&gt; 16) + (v &amp; 0xffff); }</code> </pre> <br><p>        : </p><br><pre> <code class="plaintext hljs">ip-&gt;check = 0; ip-&gt;check = carry(sum16(ip, ip_len, data_end)); u32 tcp_csum = 0; tcp_csum += sum16_32(ip-&gt;saddr); tcp_csum += sum16_32(ip-&gt;daddr); tcp_csum += 0x0600; tcp_csum += tcp_len &lt;&lt; 8; tcp-&gt;check = 0; tcp_csum += sum16(tcp, tcp_len, data_end); tcp-&gt;check = carry(tcp_csum); return XDP_TX;</code> </pre> <br><p>  <code>carry()</code>   32-  16-   ,  RFC 791. </p><br><h4 id="proverka-rukopozhatiya-tcp">   TCP </h4><br><p>      <code>netcat</code> ,   ACK,   Linux  RST-,       SYN ‚Äî     SYNACK    -       ,     . </p><br><pre> <code class="bash hljs">$ sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>        <code>tcpdump</code>  <code>xdp-remote</code>  , , <code>hping3</code>      . </p><br><h3 id="syn-cookie"> SYN cookie </h3><br><p>    XDP   .    , ,    .  Linux, ,   SipHash,     XDP     . </p><br><p>    TODO,    : </p><br><ul><li><p> XDP-    <code>cookie_seed</code> (  )   ,    ,         . </p><br></li><li><p>   SYN cookie  ACK-    ,   IP  ,     . </p><br></li></ul><br><p>   : </p><br><pre> <code class="bash hljs">$ sudoip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test nc -nv 192.0.2.1 6666 192.0.2.1 6666: Connection reset by peer</code> </pre> <br><p>      ( <code>flags=0x2</code> ‚Äî  SYN, <code>flags=0x10</code> ‚Äî  ACK): </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x20e6e11a dst=0x20e6e11e proto=6) TCP(sport=50836 dport=6666 flags=0x2) Ether(proto=0x800) IP(src=0xfe2cb11a dst=0xfe2cb11e proto=6) TCP(sport=50836 dport=6666 flags=0x10) cookie matches for client 20200c0</code> </pre> <br><p>     IP,    SYN flood  ,     ACK flood,   : </p><br><pre> <code class="bash hljs">sudo ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> xdp-test hping3 --flood -A -s 1111 -p 2222 192.0.2.1</code> </pre> <br><p>   : </p><br><pre> <code class="plaintext hljs">Ether(proto=0x800) IP(src=0x15bd11a dst=0x15bd11e proto=6) TCP(sport=3236 dport=2222 flags=0x10) cookie mismatch</code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  eBPF   XDP        ,     . , XDP ‚Äî      ,     ,  DPDK    kernel bypass.   , XDP     , ,   ,       .     ,          userspace-. </p><br><p>   ,   ,       ,     userspace-   . </p><br><p>  Referenzen: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>   GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bpftrace Cheat Sheet</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BPF and XDP Reference Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XDP Tutorial</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PoC: compiling to eBPF from Rust</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473286/">https://habr.com/ru/post/de473286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473274/index.html">Digitale Veranstaltungen in Moskau vom 28. Oktober bis 3. November</a></li>
<li><a href="../de473276/index.html">Digitale Veranstaltungen in St. Petersburg vom 28. Oktober bis 3. November</a></li>
<li><a href="../de473278/index.html">Windows Terminal Update: Vorschau 1910</a></li>
<li><a href="../de473282/index.html">Parthenon. Slumdog-Milliard√§re: Wie die Bukhman-Br√ºder zu Milliard√§ren wurden, und Online-Vologda - global</a></li>
<li><a href="../de473284/index.html">Senior, TechLead, Architekt - wie geht es weiter? Wie gehe ich mit einer Arbeitsroutine um und wohin gehe ich?</a></li>
<li><a href="../de473288/index.html">Erstellen Sie Ihren Code von Grund auf neu, er wird Ihr Level verbessern</a></li>
<li><a href="../de473290/index.html">Julia. Wo soll ich das Projekt starten? ...</a></li>
<li><a href="../de473292/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 319 (am 21. und 27. Oktober)</a></li>
<li><a href="../de473294/index.html">Speicherverwaltung oder seltener schie√üen Sie sich in den Fu√ü</a></li>
<li><a href="../de473296/index.html">Start ohne Geld. Pers√∂nliche Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>