<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍇 🚓 🕣 第6部分：将MemTest86 +移植到RISC-V 👩🏼‍🤝‍👨🏿 🏇🏾 👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大概很少有IT专家需要解释一下Memtest86 +是什么-也许它已经成为或多或少成为测试PC RAM的标准。 在上一部分内容中，我碰到了与主板捆绑在一起的损坏的内存条，它（与支持DDR2的上网本一起）似乎是一个显而易见的解决方案。 另一个问题是，从原则上讲，肉眼可以看到系统的不稳定运行。 在更棘手...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>第6部分：将MemTest86 +移植到RISC-V</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484026/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ne/fb/ha/nefbhar5ihkfmvccfwp0jqrm78u.png"></div><br><p>大概很少有IT专家需要解释一下Memtest86 +是什么-也许它已经成为或多或少成为测试PC RAM的标准。 在<a href="https://habr.com/ru/post/459470/">上一部分内容中，</a>我碰到了与主板捆绑在一起的损坏的内存条，它（与支持DDR2的上网本一起）似乎是一个显而易见的解决方案。 另一个问题是，从原则上讲，肉眼可以看到系统的不稳定运行。 在更棘手的情况下，我听说除了可以无限次“窃听”存储单元至无穷大之外，该工具还使用了一些特殊的数据模式，在这些数据模式上更有可能检测到DDR操作中的错误。 总的来说，这是一件奇妙的事情，可惜的是，即使它的名字说的是：86-“仅适用于x86兼容系统”。 还是不行 </p><br><p> 在剪切下，您将看到我尝试将MemTest86 + v5.1移植到RISC-V以及小计的情况。  <em>剧透：它移动了！</em> </p><a name="habracut"></a><br><p>  <strong>免责声明：我仅在特定板上的特定RocketChip组件上对测试结果进行了最少的测试。</strong>  <strong>不保证准确性和安全性（尤其是在其他系统上）。</strong>  <strong>使用风险自负。</strong>  <strong>特别是，如果当前保留的内存区域属于RAM范围，则不会对其进行任何处理。</strong> </p><br><p> 正如我已经说过的，不久前我在速卖通上购买了带有Cyclone IV的主板，但其中的内存有问题。 幸运的是，该板卡的重要功能之一是使用了常规的DDR2 SO-DIMM模块-与我的旧上网本相同。 然而，可以说，获得一种用于测试内存模块（实际上也是控制器）的自托管解决方案是很有趣的。 在内存不足的情况下调试我的错误的前景根本不令人满意。 尤其是不希望有一个快速的解决方案，并且不希望在无限长的时间内推迟在另一个汇编器中进行完全重写，我打开了一篇有关Memtest86 +的Wikipedia文章，突然发现卡片中写着“用C和汇编语言编写”。 嗯，也就是说，他虽然是“ ... 86”，但不是完全用汇编语言编写的？ 这令人鼓舞。 仍然只有了解关系。 </p><br><p> 因此，请转到<a href="http://www.memtest.org/" rel="nofollow">memtest.org</a>并在GPL2下下载版本5.01。 为了便于开发，我在GitHub上<a href="https://github.com/atrosinenko/memtest86-plus-riscv" rel="nofollow">重新加载了</a>它。 幸运的是，在源代码档案中，我们受到名为<a href="https://github.com/atrosinenko/memtest86-plus-riscv/blob/68b365d13cf22accd52f88af49c33f57c6643ae5/README.background" rel="nofollow">README.background的</a>文件的欢迎。 </p><br><blockquote>  Memtest86-SMP的解剖与生理 </blockquote><p>它详细解释了代码的高级操作（甚至使用ASCII形式的图片）。 在文档的开始，我们看到一个<em>Binary布局</em> ，它由<code>bootsect.o</code> ， <code>setup.o</code> ， <code>head.o</code>和一些<code>memtest_shared</code> 。 显而易见，这三个目标文件是从相应的汇编程序源中获得的。 乍一看，其他所有内容都是用C编写的！ 还不错，还不错... </p><br><p> 结果，我将<code>Makefile</code>复制到<code>Makefile.arch</code>并开始重写所有内容，并尝试丢弃不对应的内容。 当然，首先，我需要RISC-V的工具链，幸运的是，自从之前的实验以来，它一直在我身边。 起初我想为32位体系结构创建一个端口，但是后来我想起一个64位处理器已上传到板上，并且我的<code>riscv64-</code>带有<code>riscv64-</code>前缀。 </p><br><p>  <em>抒情离题：</em>当然，首先是研究32位和64位代码的兼容性问题。 结果，在<code>1.3 RISC-V ISA Overview</code>声明的第<code>1.3 RISC-V ISA Overview</code>段中找到了ISA（指令集体系结构）的非特权部分的规范： </p><br><blockquote> 显式分离基本ISA的主要优点是，可以针对每个基本ISA进行优化，而无需支持其他基本ISA所需的所有操作。 例如，RV64I可以省略仅用于处理RV32I中较窄寄存器的指令和CSR。  RV32I选项可以使用编码空间，否则仅保留给更宽的地址空间变体所需的指令使用。 </blockquote><p> 我还想指出的是，如果正确选择了目标体系结构，则带有<code>riscv64-</code>前缀的工具链很可能会轻松收集32位代码-稍后会对此进行更多介绍。 </p><br><p> 移植时，将这些文件放在手边很有意义： </p><br><ul><li>  <a href="https://riscv.org/specifications/" rel="nofollow">RISC-V指令集手册第一卷：无特权的ISA</a> </li><li>  <a href="https://riscv.org/specifications/privileged-isa/" rel="nofollow">RISC-V指令集手册第二卷：特权架构</a> </li><li> 另外，某些<a href="https://sifive.cdn.prismic.io/sifive%252F834354f0-08e6-423c-bf1f-0cb58ef14061_fu540-c000-v1.0.pdf" rel="nofollow">SiFive FU540-C000手册</a> -该芯片手册，其行为类似于软件处理器，用于FPGA调试，其行为不会改变。 </li></ul><br><h2 id="nastroyka-sborki"> 构建设置 </h2><br><p> 让我们从达成一致开始：我想获得一个适合进一步移植到x86和RISC-V以外的体系结构的端口。 我还建议将引导软盘和其他x86细节排除在跨平台构建之外。 </p><br><p> 我们最终拥有的是：三个汇编器文件： <code>bootsect.S</code> ， <code>setup.S</code>和<code>head.S</code> 仅在启动时才需要前两个，而稍后在重定位到另一个存储区域时则需要第三个。 事实是，为了“自己”测试内存，测试代码必须首先移至新位置。  Sich文件在ELF中收集，然后从中获取代码，数据等部分。 此外，它以PIC（位置独立代码）的形式收集-起初，我什至感到惊讶：尽管代码是独立的（即，没有内核，libc等），但它使用了此类高级功能。 </p><br><p> 此外，在Makefile中会定期遇到定义体系结构的参数： <code>-march=i486</code>和<code>-m32</code>等。 我需要写这样的东西 <del> 然后像一个吸盘 </del>  。 从体系结构的角度来看，RISC-V的情况是这样的： <code>rv32</code>和<code>rv64</code>有很多选项（例如，对于将来的<code>rv128</code> ，仍然有截断的嵌入式和保留，但我们对它们不是很感兴趣），而ISA名称是通过为该前缀分配字母而形成的扩展： <code>i</code>基本的整数指令集， <code>m</code>整数乘法和除法，...当然，我想做<code>rv64i</code> ，但是如果没有乘法，Memtest86很难移植到体系结构上。 没错，似乎编译器将只生成函数调用而不是“有问题的”指令，但是存在极大降低性能的风险（更不用说这些函数将需要在某个地方编写或使用）。 </p><br><p> 您还将需要ABI行。 原则上，调用约定的基础已经在“ RISC-V汇编程序员手册”中指定的<code>Volume I</code>进行了介绍，因此我将做类似 </p><br><pre> <code class="plaintext hljs">$ riscv64-linux-gnu-gcc-9 -mabi=help riscv64-linux-gnu-gcc-9: error: unrecognized argument in option '-mabi=help' riscv64-linux-gnu-gcc-9: note: valid arguments to '-mabi=' are: ilp32 ilp32d ilp32e ilp32f lp64 lp64d lp64f riscv64-linux-gnu-gcc-9: fatal error: no input files compilation terminated.</code> </pre> <br><p>  <code>lp64</code>考虑，我就<code>lp64</code> 。  <em>展望未来，我要说的是，使用此ABI，标准库中的头文件不起作用，因此我选择了<code>lp64f</code> ，并将ARCH“升级”为<code>rv64imf</code> 。</em>  <em>没有恐慌，我不打算在端口中真正使用浮点。</em> </p><br><p> 由于我某种程度上不想钻研跨平台的链接描述文件-因此我无法立即<em>找到ld的键</em> ，因此我决定使用一个汇编器<code>head.S</code>文件，并使用<code>memtest_shared.arch.lds</code>其余功能。 我从中给出了输出格式和体系结构的指示（毕竟，从Makefile中的变量更改输出更容易），并在最后临时注释掉<code>DISCARD</code> ，无法弄清我需要哪些特定的调试信息部分。  <em>（展望：良好的调试信息，但必须添加<code>.rela</code> ）</em>一般来说，x86版本强调了必须适合64k的能力-我希望这与实模式的功能相关，并且在RISC-V上与我们无关。 结果，将收集与PIC共享的对象，就像在原始对象中一样，将要加载到内存中的代码和数据也被咬掉。 </p><br><p> 我们收集...，并且编译位于第一个<code>reloc.c</code>文件上-显然，它是从<code>ld-linux.so</code>提取的，并负责支持Global Offset Table等。 根据x86的调用约定。 事实证明，它需要使用汇编程序插入直接处理寄存器。 但是我们在RISC-V上-它最初是为本地支持PIC制作的，因此请随意抛出<code>reloc.c</code> 。 此外，仍然有插入物，有时很长。 幸运的是，它们要么在被注释掉的C代码之后立即进入测试代码，然后对其进行优化（我从中再次编写了由preprocessor指令切换的完整代码），要么依赖于平台，在某些情况下，如果没有这些代码，您可以（可能）做（例如打开/关闭缓存，减去CPUID等）。 最后，还有一些类似<code>rdtsc</code>调用，我<code>rdtsc</code>没有将任何大问题放入与平台相关的标头中，并根据RISC-V的文档进行了实现。 </p><br><p> 结果，我们获得了<code>arch/i386</code>目录，其中移动了大量的PCI支持代码，从芯片组读取信息，特定于平台的内存映射地址定义等。 同样， <code>test_start</code>函数的开头<code>test_start</code> ，它是<code>setup.S</code>到C代码的入口。多长时间，短，但是注释掉所有可能的东西，并实现在RISC-V下不能注释掉的所有东西（例如<code>setup.S</code>和用于工作的代码） SiFive实现中的串行端口），我得到了<code>arch/riscv</code> ，使用该<code>arch/riscv</code>或多或少地进行了所有编译。 </p><br><p> 在这里，我不得不澄清一下，实验本身是在撰写本文之前部分进行的，因此特定<em>的</em>动作<em>序列</em>可能包含一定量的“艺术小说”。 但是，我至少尝试以某种方式进行演示，使其在任何情况下都代表一种可能的方式<em>（我是程序员，我记得那）</em> 。 因此，让我们看看如何开始一切。 </p><br><h2 id="zapusk-na-zheleze"> 在铁上运行 </h2><br><p> 从过去的实验开始，我仍然在Raspberry Pi上有一个尘土飞扬的“架子”，并连接到调试板上。 电线提供UART，JTAG和带有SD卡的适配器。 将带有DDR2控制器的RV64处理器缝入配置存储器。 和以前一样，我打开“树莓”，在它之前打开两个SSH会话，其中一个转发3333 TCP端口，用于将gdb连接到OpenOCD。 在一个会话中，我启动minicom来监视UART，在另一个会话中，我启动opencomd来通过JTAG从主机进行调试。 我打开了板子的电源-控制台中出现了有关如何从SD加载数据的消息。 </p><br><p> 现在，您可以运行以下命令： </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:3333' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80010000' \ -ex 'add-symbol-file /path/to/memtest_shared 0x80010000' -ex 'set $pc=0x80010000'</code> </pre> <br><p>  <code>-ex</code>选项<code>-ex</code> gdb假装用户已从控制台输入以下命令： </p><br><ul><li> 第一个与OpenOCD建立连接 </li><li> 第二个将指定主机文件的内容复制到指定地址 </li><li> 第三部分向gdb解释说，必须从<em>该</em>文件中获取有关源代码的信息，并考虑到它是从<em>该</em>地址下载的（而不是其本身指示的内容） <br><ul><li> 注意：我们从ELF文件中提取字符，并加载“原始”二进制文件 </li></ul></li><li> 最后，第四个将当前命令指针强制转换为我们的代码 </li></ul><br><p> 不幸的是，并不是所有的事情都能顺利进行，尽管调试器中的代码行显示正确，但是在所有全局变量中均显示为零。 实际上，如果在gdb中执行形式为<code>p &amp;global_var</code>的命令，可惜我们看到的地址与初始下载地址（我有<code>0x0</code> ）一致，而该地址未使用<code>add-symbol-file</code>指定。 作为拐杖，但非常简单的解决方案，我只是手动将<code>0x80010000</code>添加到指定的地址，并通过<code>x/x 0xADDR</code>内存的内容。 实际上，有可能在链接描述文件中临时指示正确的起始地址， <em>此刻</em> <em>此</em>地址将与<em>此测试配置中</em>的下载地址一致。 </p><br><h2 id="osobennosti-relokacii-na-sovremennyh-arhitekturah"> 现代建筑搬迁的特征 </h2><br><p> 好了，如何以某种方式找到我们下载的代码-我们开始了。 不起作用。 逐步调试表明，我们陷入了<code>switch_to_main_stack</code>函数的运行过程中-似乎它仍在尝试使用与工作堆栈相对应的符号地址的不相关值。 </p><br><p> 一样，第一卷文档告诉我们不同的伪指令以及它们与PIC一起使用和关闭的工作： </p><br><p><img src="https://habrastorage.org/webt/vj/7-/_u/vj7-_uqmqyqjloo1webrgpqsdc8.png" alt="某些RISC-V伪指令"></p><br><p> 如您所见，一般的原理是从当前指令开始计算存储器中的地址，第一个加上偏移量的顶部，第二个则<code>add</code>低位。 声明这样的全局变量几乎无济于事 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vars</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variables</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><p> 因此，我们使用RISC-V ELF psABI文档<a href="" rel="nofollow">以及重定位类型的描述，</a>并为<code>reloc.c</code>编写了特定于平台的部分。 这里应该注意的是，原始文件显然是来自跨平台代码的。 在那里，即使未指定特定的位深度， <code>ElfW(Addr)</code>宏， <code>Elf32_Addr</code>为<code>Elf32_Addr</code>或<code>Elf64_Addr</code> 。 但是，并不是到处都存在，这就是为什么我们将它们添加到通用代码（以及<a href="" rel="nofollow"><code>arch/riscv/reloc.inc.c</code></a>中不存在的地方的原因-毕竟，对于RISC-V，没有特殊意义要绑定到特定的位深度，而不是特定的位深度必填）。 </p><br><p> 结果， <code>switch_to_main_stack</code>开始通过（当然不是没有平台相关的汇编器指令）。 调试器显示全局变量仍然不正确。 好吧，好的:( </p><br><h2 id="opredelenie-oborudovaniya"> 硬件定义 </h2><br><p> 当然，对于测试而言，可以使用硬编码的常量来代替抛出的设备定义代码，但是对于每个特定的处理器组件，按照我的应用程序的标准来重建memtest的成本甚至太高。 因此，我们将“作为严肃的成年人”行事。 幸运的是，在RISC-V上（可能在大多数现代体系结构上），引导加载程序习惯将代码传递给<a href="https://en.wikipedia.org/wiki/Device_tree" rel="nofollow">Device Tree Blob</a> ，它是DTS描述的编译版本，如下所示： </p><br><div class="spoiler">  <b class="spoiler_title">zeowaa-1gb.dts</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/dts-v1/; / { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-dev"; model = "freechips,rocketchip-unknown"; chosen { bootargs = "console=ttySIF0,125200 debug loglevel=7"; }; firmware { sifive,uboot = "YYYY-MM-DD"; }; L16: aliases { serial0 = &amp;L8; }; L15: cpus { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; timebase-frequency = ^_^lt󴉀gt^_^; L5: cpu@0 { device_type = "cpu"; clock-frequency = ^_^lt&amp;#0;gt^_^; compatible = "sifive,rocket0", "riscv"; d-cache-block-size = ^_^lt gt^_^; d-cache-sets = ^_^lt@gt^_^; d-cache-size = ^_^ltကgt^_^; d-tlb-sets = ^_^lt gt^_^; d-tlb-size = ^_^lt gt^_^; i-cache-block-size = ^_^lt gt^_^; i-cache-sets = ^_^lt@gt^_^; i-cache-size = ^_^ltကgt^_^; i-tlb-sets = ^_^lt gt^_^; i-tlb-size = ^_^lt gt^_^; mmu-type = "riscv,sv39"; next-level-cache = &lt;&amp;L10&gt;; reg = &lt;0x0&gt;; riscv,isa = "rv64imafdc"; status = "okay"; timebase-frequency = ^_^lt󴉀gt^_^; tlb-split; L3: interrupt-controller { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,cpu-intc"; interrupt-controller; }; }; }; L10: ram@80000000 { device_type = "memory"; reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;; reg-names = "mem"; }; L14: soc { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-soc", "simple-bus"; ranges; L1: clint@2000000 { compatible = "riscv,clint0"; interrupts-extended = &lt;&amp;L3 3 &amp;L3 7&gt;; reg = &lt;0x2000000 0x10000&gt;; reg-names = "control"; }; L2: debug-controller@0 { compatible = "sifive,debug-013", "riscv,debug-013"; interrupts-extended = &lt;&amp;L3 65535&gt;; reg = &lt;0x0 0x1000&gt;; reg-names = "control"; }; L9: gpio@64002000 { #gpio-cells = ^_^lt gt^_^; #interrupt-cells = ^_^lt gt^_^; compatible = "sifive,gpio0"; gpio-controller; interrupt-controller; interrupt-parent = &lt;&amp;L0&gt;; interrupts = &lt;3 4 5 6 7 8&gt;; reg = &lt;0x64002000 0x1000&gt;; reg-names = "control"; }; L0: interrupt-controller@c000000 { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,plic0"; interrupt-controller; interrupts-extended = &lt;&amp;L3 11 &amp;L3 9&gt;; reg = &lt;0xc000000 0x4000000&gt;; reg-names = "control"; riscv,max-priority = ^_^lt gt^_^; riscv,ndev = ^_^lt gt^_^; }; L6: rom@10000 { compatible = "sifive,maskrom0"; reg = &lt;0x10000 0x2000&gt;; reg-names = "mem"; }; L8: serial@64000000 { compatible = "sifive,uart0"; interrupt-parent = &lt;&amp;L0&gt;; clocks = &lt;&amp;tlclk&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64000000 0x1000&gt;; reg-names = "control"; }; L7: spi@64001000 { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; compatible = "sifive,spi0"; interrupt-parent = &lt;&amp;L0&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64001000 0x1000&gt;; clocks = &lt;&amp;tlclk&gt;; reg-names = "control"; L12: mmc@0 { compatible = "mmc-spi-slot"; disable-wp; reg = &lt;0x0&gt;; spi-max-frequency = ^_^lt gt^_^; voltage-ranges = &lt;3300 3300&gt;; }; }; tlclk: tlclk { #clock-cells = ^_^lt&amp;#0;gt^_^; clock-frequency = ^_^lt gt^_^; clock-output-names = "tlclk"; compatible = "fixed-clock"; }; }; };</code> </pre> </div></div><br><p> 我曾经解析ELF文件，但现在我再次对FDT（平面设备树）深信不疑：这些<a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.2/devicetree-specification-v0.2.pdf" rel="nofollow">规范是</a>由<em>有爱心的人</em>编写的 <del>  （仍然，他们自己然后解析它！） </del> 解析此类文件（至少直到您需要处理不受信任的输入为止）不会造成任何特殊问题。 所以在这里：在文件的开头，有一个简单的头结构，其中包含魔术数字<code>0xd00dfeed</code>和更多字段。 我们对“扁平树” <code>off_dt_struct</code>和行表<code>off_dt_strings</code>的偏移量感兴趣。 实际上，您还需要处理<code>off_mem_rsvmap</code> ，它枚举了最好避免使用的内存区域。 我仍然不理（它们（它们不在我的木板上），但是<strong>不要在家中重复</strong> 。 </p><br><p> 原则上，处理并不是特别困难：您只需要根据令牌在平整的树上行走即可。  <em>有</em>三个<em>主要</em>标记： </p><br><ul><li>  <code>FDT_BEGIN_NODE</code>在紧随其后的额外数据中，以空终止字符串的形式出现子树元素的名称。 只需将名称添加到堆栈中 </li><li>  <code>FDT_END_NODE</code>子树结束，从堆栈中删除元素 </li><li>  <code>FDT_PROP</code>这有点棘手：它后面是一个结构，然后是len个字节的额外数据。  “变量”的名称位于字符串表中的偏移<code>nameoff</code> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nameoff; }</code> </pre> </li></ul><br><p> 好吧，总的来说，就是这样：我们仔细阅读本节，不要忘记观察4个字节的对齐情况。 美中不足的是：FDT中的数字采用大端格式，所以我们做一个简单的函数 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">be32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff00</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><p> 结果，在<code>riscv_entry</code>首先要做的是解析FDT，而<code>head.S</code>负责将控制权转移到<code>riscv_entry</code>看起来像这样 </p><br><pre> <code class="plaintext hljs"> .globl startup_32 #  --    ... startup_32: lla sp, boot_stack_top mv s0, a0 # s0, s1 -- callee-saved mv s1, a1 # ...  .bss #   jal _dl_start #      mv a0, s0 mv a1, s1 j riscv_entry</code> </pre> <br><p> 在寄存器<code>a0</code>我们得到了一个hart id（hart类似于RISC-V术语中的硬件流）-我还没有使用它，我必须在单线程情况下弄清楚它。 在<code>a1</code>引导加载程序会放置一个指向FDT的指针。 我们将其传递给函数<code>void riscv_entry(ulong hartid, uint8_t *fdt_address)</code> 。 </p><br><p> 现在，随着我代码中FDT parsilka的出现，电路板的加载顺序如下所示： </p><br><ul><li> 打开电源 </li><li> 等待U-boot控制台 </li><li> 在其中输入命令以准备正确的FDT。 尤其是<code>/chosen/bootargs</code> command <code>/chosen/bootargs</code>存储内核命令行。 我从FDT取得的所有其他信息-RAM范围，UART地址，...-可以并且应该保留原样 <br><pre> <code class="plaintext hljs">run fdtsetup fdt set /chosen bootargs "console=ttyS0 btrace"</code> </pre> </li><li> 使用<code>fdt addr</code>命令，查找FDT下载地址（如果您尚未查看） </li></ul><br><p> 从gdb端添加命令 </p><br><ul><li> <code>-ex 'set $a1=0xfdtaddr'</code> </li> </ul><br><h2 id="vyvod-informacii-na-ekran"> 信息输出到屏幕 </h2><br><p> 事实证明，除了汇编插入外，还存在已知的内存地址。 例如<code>SCREEN_ADR</code> （ <code>SCREEN_ADR</code>类似，带有一个<code>D</code> ），它指向与屏幕上显示的内容相对应的区域。 当我遇到此问题时，我只是用宽大的手势将所有引用它的内容放在<code>#if HAS_SCREEN</code> ，然后盲目调试了很长时间。 我以为已经有一段时间手动将其全部转储到控制台了，但是后来我注意到，相同的代码令人痛苦地将许多转义序列输出到串行端口。 事实证明，所有事情已经写在我们面前，您只需要更准确地放置定义-此处是minicom窗口中熟悉的界面（尽管是黑色和白色）！  （目前，根本不使用HAS_SCREEN-我只是启动了<code>dummy_con</code>数组以最少更改原始代码。） </p><br><h2 id="otladka-na-qemu"> 在QEMU上调试 </h2><br><p> 因此，我花了一段时间在一块真正的板上调试了所有东西-甚至不是盲目的。 但是一切都减慢了JTAG的速度-恐怖！ 好吧，最后，所有内容都应该在真实的硬件上运行，但是在QEMU上进行调试会很好。 经过一定数量的实验，结果发现这是一个拐杖，但与使用电路板非常相似： </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M help Supported machines are: none empty machine sifive_e RISC-V Board compatible with SiFive E SDK sifive_u RISC-V Board compatible with SiFive U SDK spike_v1.10 RISC-V Spike Board (Privileged ISA v1.10) (default) spike_v1.9.1 RISC-V Spike Board (Privileged ISA v1.9.1) virt RISC-V VirtIO Board (Privileged ISA v1.10)</code> </pre> <br><p> 我们看一下QEMU准备模拟哪些板。 我对<code>sifive_u</code>兼容的硬件感兴趣。 </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M sifive_u,dumpdtb -m 1g # - QEMU      on --  strace   $ ls -l on -rw-rw-r-- 1 trosinenko trosinenko 1923  19 20:14 on $ dtc -I dtb &lt; on &gt; on.dts #   $ vim on.dts #  bootargs $ dtc &lt; on.dts &gt; on.dtb &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 1 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 2 is not a phandle reference</code> </pre> <br><p> 现在我们有了一个“固定”的设备树blob。  <strong>在不更改虚拟机配置的情况下</strong> ，执行以下操作： </p><br><pre> <code class="plaintext hljs">qemu-system-riscv64 \ -M sifive_u -m 1g \ -serial stdio \ -s -S</code> </pre> <br><p>  <code>-serial stdio</code>将串行端口重定向到控制台，因为将积极使用转义序列。  <code>-s -S</code>选项分别引发gdbserver和创建要暂停的VM。 您可以使用<code>loader</code>下载代码，但是每次都必须重新启动QEMU。 </p><br><p> 您可以使用连接 </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:1234' \ -ex 'restore /path/to/on.dtb binary 0x80100000' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80020000' \ -ex 'add-symbol-file memtest_shared 0x80100000' \ -ex 'set $a1=0x80020000' \ -ex 'set $pc=0x80100000'</code> </pre> <br><p> 结果，一切都变得比聪明更有效！ </p><br><h2 id="obschiy-princip-raboty"> 一般工作原理 </h2><br><p> , ,  ,   Memtest86+   <code>btrace</code> ,        ,      (  ,     QEMU): </p><br><p><img src="https://habrastorage.org/webt/su/lr/qh/sulrqhzmiona327osxqzaikijf0.png" alt="btrace模式"></p><br><p>  ,      , memtest          .     ,      (, trap):  ,   ,   QEMU - !  «»   <code>Illegal instruction</code>  ,    .      <code>mcause</code> (?),   — <code>mepc</code> (?),   — <code>mtval</code> (    ?),    . </p><br><p><img src="https://habrastorage.org/webt/lc/is/ho/lcishowkkjngpnorx_gkyav-svg.png" alt="非法指示"></p><br><p>   ,      : </p><br><p> <strong>head.S:</strong> </p><br><pre> <code class="plaintext hljs">#       #   = 0 ---   ,   #  ,    ,     ... lla t1, _trap_entry csrw mtvec, t1 # ... _trap_entry: csrr a0, mcause csrr a1, mepc csrr a2, mtval jal riscv_trap_entry</code> </pre> <br><p>  ,        calling convention,  .        memtest,    HiFive_U-Boot,      <code>Volume II</code> : </p><br><p> <strong>arch.c:</strong> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *errors[] = { <span class="hljs-string"><span class="hljs-string">"Instruction address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Instruction access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Illegal instruction"</span></span>, <span class="hljs-string"><span class="hljs-string">"Breakpoint"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO access fault"</span></span>, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Instruction page fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load page fault"</span></span>, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Store/AMO page fault"</span></span>, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">riscv_trap_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ulong cause, ulong epc, ulong tval)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"EXCP: "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cause &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, errors[cause]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { itoa(buf, cause); cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, buf); } cprint(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"PC: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, epc, <span class="hljs-number"><span class="hljs-number">8</span></span>); cprint(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Addr: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, tval, <span class="hljs-number"><span class="hljs-number">8</span></span>); HALT(); }</code> </pre> <br><p>        —    « »   .   ,   «»    ,  ,      ,  . </p><br><p>         :     .       ,  memtest  :    : «       ,   ,    .        ».    :  <code>do_test</code>   <code>main.c</code>    2,   (    ),       —    «» ,    memtest.       ,    <code>run_at</code> ,    memtest  <code>_start</code>  <code>_end</code>    (   «»  ),  -     spinlock'        <code>goto *addr;</code>        . ,  ,      «»    ,    «». </p><br><p>      ,    <strong> </strong>  <code>bss</code>    —    <code>_dl_start</code>  ,   <code>riscv_entry</code>  ,   trap entry. ,   :     L1I-,   .    ,     <code>fence.i</code> . </p><br><p>   ,  Memtest86+ — ,         <code>barrier_s</code>    .       ,          . ,   ,       . </p><br><h2 id="podvodnye-kamni">   </h2><br><p>    ,   :   .   :           .    <em></em> : ,  -       (Own Address,     )   .     ,     ,   .       . -    .   ,   x86 , ,    <code>uint64_t</code>   <code>0x80000002</code>       . ,     : <a href="https://stackoverflow.com/questions/12491578/whats-the-actual-effect-of-successful-unaligned-accesses-on-x86" rel="nofollow"> </a> ,   load/store  x86   ,     — .    ,    QEMU    ,  «  ,      ». </p><br><p> ,     ,  <em>  </em> —   unaligned access  .. </p><br><p> ,   ,     RocketChip,   — QEMU,   ,  ,   RocketChip — unaligned access trap,  QEMU  «  ». <br>   «misaligned»            ,   </p><br><blockquote> Changed description of misaligned load and store behavior. The specification now allows visible misaligned address traps in execution environment interfaces, rather than just mandating invisible handling of misaligned loads and stores in user mode. Also, now allows access exceptions to be reported for misaligned accesses (including atomics) that should not be emulated. </blockquote><p>  , ,  —   ,  user-mode code   ,             .     .   , ,   .   ,       — -   machine mode    . ,     <code>rdtsc</code> (x86)  <code>rdtime</code> (rv64),   trap,     . , ,                memory-mapped . </p><br><p>    :      ,  <em> </em>   <code>low_test_addr</code> (       ),  ,   fdt   .   ,  ,  <code>low_test_addr</code>   ,  ,      2   <code>high_test_adr</code>    … ,     —   : <code>head.S</code>       <code>initial_load_addr</code> ,    <code>riscv_entry</code>    <code>move_to_correct_addr</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_to_correct_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_start = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_start; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_end = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_end; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur_start == low_test_addr || cur_start == high_test_adr) { <span class="hljs-comment"><span class="hljs-comment">//  ,     return; } if (cur_start == initial_load_addr &amp;&amp; (cur_start - low_test_addr) &lt; (cur_end - cur_start) ) { //   " ":   , //           //     ,    ,   //     ... serial_echo_print("FIRST STARTUP RELOCATION...\n"); void *temp_addr = (((uintptr_t)&amp;_end &gt;&gt; 12) + 1) &lt;&lt; 12; run_at(temp_addr, 0); } else { // ,    --- ,  . serial_echo_print("FINAL STARTUP RELOCATION...\n"); run_at(low_test_addr, 0); } }</span></span></code> </pre> <br><p> ,     —   ,  memtest ,  RAM  -   .  RISC-V    ,        <code>v-&gt;plim_lower</code> . </p><br><p>     ,   «» ,    -,   —  <code>test.c</code>    <code>ulong</code> (  <code>unsigneg long</code> ),   32- x86   <code>uint32_t</code> ,    « 64 »   <code>uint64_t</code> .       «!!! Good: ffffffff Real: ffffffff Bad bits: 00000000».   ?       - -1,  32    1.   ,         ,        0…  ,     : ,  <code>ulong</code>      ( <code>uint32_t</code> ),          ( <code>uintptr_t</code> ). ,       . ,     <code>uint64_t</code>   4. RISC-V  <em></em>  ,       C, ,    —    UB. <del>     memtest  UBSan. </del>  ,  ,  UBSan   trap-on-error        JTAG. </p><br><h2 id="upakovyvaem-dlya-zagruzchika">    </h2><br><p> ,  memtest -  ,    ,          U-Boot. </p><br><p>       :    <code>mkimage</code>   U-Boot   <em>  Linux</em> : </p><br><pre> <code class="plaintext hljs">mkimage -A riscv -O linux -T kernel -C none \ -a 0x80000000 -e 0x80000000 \ -n memtest -d memtest.bin memtest.uboot</code> </pre> <br><p>      SD-      </p><br><pre> <code class="plaintext hljs">run mmcsetup; run fdtsetup; fdt set /chosen bootargs "console=ttyS0"; fatload mmc 0:1 82000000 memtest.uboot; bootm fdt; bootm 82000000 - ${fdtaddr}</code> </pre> <br><p> (   ,   <code>run</code>     —        ). </p><br><p>      :       FDT: <code>0xbffb7c80</code> . ,  :    <code>ffffffff</code> ,     .     ,         (     ),    :   HiFive_U-Boot      : </p><br><pre> <code class="cpp hljs"> theKernel(machid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)images-&gt;ft_addr);</code> </pre> <br><p>    ,     </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*theKernel)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arch, uint params);</code> </pre> <br><p>  ,     , ,  ,  32        ,     <code>head.S</code> : </p><br><pre> <code class="plaintext hljs"> li t0, 0xffffffffL and a1, a1, t0</code> </pre> <br><h2 id="promezhutochnyy-itog">   </h2><br><p> ,  , - ,  ,     ,  : </p><br><ul><li>     x86.       —       review         <strong>   </strong> </li><li>   SMP   RISC-V </li><li>        <code>arch/</code> -  </li><li>     <code>test.c</code>  RISC-V (      <code>-O0</code> !) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484026/">https://habr.com/ru/post/zh-CN484026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484012/index.html">简化大容量笔记本的书写过程</a></li>
<li><a href="../zh-CN484014/index.html">2020年将抛弃10个SEO神话</a></li>
<li><a href="../zh-CN484016/index.html">关于调试自动编码器示例的深度学习基础，第1部分</a></li>
<li><a href="../zh-CN484018/index.html">游艇的IT技术面</a></li>
<li><a href="../zh-CN484020/index.html">您想给谁留下深刻的印象？</a></li>
<li><a href="../zh-CN484028/index.html">马蹄弯-可折叠平板电脑，带折叠显示屏</a></li>
<li><a href="../zh-CN484036/index.html">新行业集团为智能家居创建通用标准</a></li>
<li><a href="../zh-CN484046/index.html">使用PVS-Studio检查Emby</a></li>
<li><a href="../zh-CN484048/index.html">PHP和正则表达式：初学者的基础</a></li>
<li><a href="../zh-CN484050/index.html">使用PVS-Studio分析器嵌入源代码分析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>