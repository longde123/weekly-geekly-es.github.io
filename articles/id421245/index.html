<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😠 🏦 🙎 C #: satu kasus penggunaan untuk tugas apa pun ☹️ 👈🏾 🧚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Kami terus berbicara tentang pemrograman asinkron dalam C #. Hari ini kita akan berbicara tentang kasus penggunaan tunggal atau skenario k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C #: satu kasus penggunaan untuk tugas apa pun</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/421245/">  Halo, Habr!  Kami terus berbicara tentang pemrograman asinkron dalam C #.  Hari ini kita akan berbicara tentang kasus penggunaan tunggal atau skenario khusus pengguna yang cocok untuk tugas apa pun dalam rangka pemrograman asinkron.  Kami akan menyentuh pada topik sinkronisasi, deadlock, pengaturan operator, penanganan pengecualian, dan banyak lagi.  Bergabunglah sekarang! <br><br><img src="https://habrastorage.org/webt/fn/3y/w8/fn3yw8b2lmo8cbbziqaiogmvsxy.jpeg"><a name="habracut"></a><br><br><blockquote>  <b>Artikel Terkait Sebelumnya</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C # Asynchronous Programming: Bagaimana kinerja Anda?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengganti Equals dan GetHashCode.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tetapi apakah itu perlu?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang dapat ditemukan dalam kode orang lain?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pilihan bahan yang berguna untuk .NET</a> </li></ul></blockquote><br>  Hampir setiap perilaku non-standar dari metode asinkron dalam C # dapat dijelaskan berdasarkan satu skenario pengguna: mengonversi kode sinkron yang ada ke asinkron harus sesederhana mungkin.  Anda harus dapat menambahkan kata kunci async sebelum kembali jenis metode, menambahkan akhiran Async ke nama metode ini, dan menambahkan kata kunci tunggu di sini dan di area teks metode untuk mendapatkan metode asinkron berfungsi penuh. <br><br><img width="550" src="https://habrastorage.org/webt/di/uw/i8/diuwi85jehdfov_iozovmreg59s.png"><br><br>  Skenario “sederhana” secara dramatis mengubah banyak aspek perilaku metode asinkron: dari merencanakan durasi tugas hingga menangani pengecualian.  Script terlihat meyakinkan dan signifikan, tetapi dalam konteksnya, kesederhanaan metode asinkron menjadi sangat menyesatkan. <br><br><h2>  Sinkronkan konteks </h2><br>  Pengembangan User Interface (UI) adalah salah satu area di mana skenario di atas sangat penting.  Karena operasi yang panjang di utas antarmuka pengguna, waktu respons aplikasi meningkat, dalam hal ini pemrograman asinkron selalu dianggap sebagai alat yang sangat efektif. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 -- UI Thread var result = await _stockPrices.GetStockPricesForAsync("MSFT"); // 2 -- Usually non-UI Thread textBox.Text = "Result is: " + result; //3 -- Should be UI Thread }</span></span></code> </pre> <br>  Kode terlihat sangat sederhana, tetapi ada satu masalah.  Ada batasan untuk sebagian besar antarmuka pengguna: Elemen UI hanya dapat diubah oleh utas khusus.  Yaitu, di baris 3 kesalahan terjadi jika durasi tugas dijadwalkan di utas dari kumpulan utas.  Untungnya, masalah ini sudah lama diketahui, dan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konteks sinkronisasi telah</a> muncul di .NET Framework 2.0. <br><br>  Setiap UI menyediakan utilitas khusus untuk mengatur tugas menjadi satu atau lebih utas antarmuka pengguna khusus.  Formulir Windows menggunakan metode <code>Control.Invoke</code> , WPF <code>Control.Invoke</code> metode Dispatcher.Invoke, sistem lain dapat mengakses metode lain.  Skema yang digunakan dalam semua kasus ini sebagian besar serupa, tetapi berbeda dalam detailnya.  Konteks sinkronisasi memungkinkan Anda untuk abstrak dari perbedaan dengan menyediakan API untuk menjalankan kode dalam konteks "khusus" yang menyediakan pemrosesan detail kecil dengan tipe turunan seperti <code>WindowsFormsSynchronizationContext</code> , <code>DispatcherSynchronizationContext</code> , dll. <br><br>  Untuk mengatasi masalah afinitas utas, programmer C # memutuskan untuk memasukkan konteks sinkronisasi saat ini pada tahap awal implementasi metode asinkron dan merencanakan semua operasi selanjutnya dalam konteks ini.  Sekarang, setiap blok antara menunggu pernyataan dieksekusi di utas antarmuka pengguna, yang memungkinkan untuk mengimplementasikan skrip utama.  Namun, solusi ini memunculkan sejumlah masalah baru. <br><br><h2>  Jalan buntu </h2><br>  Mari kita lihat sepotong kecil kode yang relatif sederhana.  Apakah ada masalah di sini? <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { await Task.Yield(); return 42; }</span></span></code> </pre> <br>  Kode ini menyebabkan <b>jalan buntu</b> .  Utas antarmuka pengguna memulai operasi asinkron dan menunggu hasilnya secara sinkron.  Namun, metode asinkron tidak dapat diselesaikan karena baris kedua <code>GetStockPricesForAsync</code> harus dieksekusi di utas antarmuka pengguna yang menyebabkan kebuntuan. <br><br>  Anda akan keberatan bahwa masalah ini cukup mudah dipecahkan.  Ya memang.  Anda harus melarang semua panggilan ke metode <code>Task.Result</code> atau <code>Task.Wait</code> dari kode antarmuka pengguna, namun masalah masih dapat terjadi jika komponen yang digunakan oleh kode tersebut menunggu hasil operasi pengguna secara sinkron: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // We know that the initialization step is very fast, // and completes synchronously in most cases, // let's wait for the result synchronously for "performance reasons". InitializeIfNeededAsync().Wait(); return Task.FromResult((decimal)42); } // StockPrices.dll private async Task InitializeIfNeededAsync() =&gt; await Task.Delay(1);</span></span></code> </pre> <br>  Kode ini lagi menyebabkan kebuntuan.  Cara mengatasinya: <br><br><ul><li>  Anda seharusnya tidak memblokir kode asinkron dengan <code>Task.Wait()</code> atau <code>Task.Result</code> dan </li><li>  gunakan <code>ConfigureAwait(false)</code> dalam kode perpustakaan. </li></ul><br>  Arti dari rekomendasi pertama jelas, dan yang kedua akan kami jelaskan di bawah ini. <br><br><h2>  Mengkonfigurasi menunggu pernyataan </h2><br>  Ada dua alasan mengapa kebuntuan terjadi dalam contoh terakhir: <code>Task.Wait()</code> di <code>GetStockPricesForAsync</code> dan penggunaan tidak langsung dari konteks sinkronisasi dalam langkah-langkah selanjutnya dalam InitializeIfNeededAsync.  Meskipun pemrogram C # tidak merekomendasikan pemblokiran panggilan ke metode asinkron, jelas bahwa dalam kebanyakan kasus pemblokiran ini masih digunakan.  Pemrogram C # menawarkan solusi berikut untuk masalah kebuntuan: <code>Task.ConfigureAwait(continueOnCapturedContext:false)</code> . <br><br>  Terlepas dari penampilan yang aneh (jika pemanggilan metode dieksekusi tanpa argumen bernama, ini tidak berarti apa-apa sama sekali), solusi ini menjalankan fungsinya: ia memberikan kelanjutan eksekusi yang dipaksakan tanpa konteks sinkronisasi. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  Dalam hal ini, kelanjutan tugas <code>Task.Delay(1</code> ) (di sini adalah pernyataan kosong) direncanakan di utas dari kumpulan utas, dan bukan di utas antarmuka pengguna, yang menghilangkan kebuntuan. <br><br><h2>  Menonaktifkan konteks sinkronisasi </h2><br>  Saya tahu bahwa <code>ConfigureAwait</code> sebenarnya memecahkan masalah ini, tetapi memunculkan lebih banyak.  Ini adalah contoh kecil: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Initialize the cache field first await _cache.InitializeAsync().ConfigureAwait(false); // Do some work await Task.Delay(1); }</span></span></code> </pre> <br>  Apakah Anda melihat masalahnya?  Kami menggunakan <code>ConfigureAwait(false)</code> , jadi semuanya harus baik-baik saja.  Tapi bukan fakta. <br><br>  <code>ConfigureAwait(false)</code> mengembalikan objek custom awaiter <code>ConfiguredTaskAwaitable</code> , dan kami tahu bahwa itu hanya digunakan jika tugas tidak selesai secara sinkron.  Yaitu, jika <code>_cache.InitializeAsync()</code> selesai secara sinkron, jalan buntu masih mungkin terjadi. <br><br>  Untuk menghilangkan kebuntuan, semua tugas yang menunggu penyelesaian harus "dihiasi" dengan panggilan ke metode <code>ConfigureAwait(false)</code> .  Semua ini mengganggu dan menghasilkan kesalahan. <br><br>  Atau, Anda dapat menggunakan objek kustom penunggu di semua metode publik untuk menonaktifkan konteks sinkronisasi dalam metode asinkron: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).Result; textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; } <span class="hljs-comment"><span class="hljs-comment">// StockPrices.dll public async Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // The rest of the method is guarantee won't have a current sync context. await Awaiters.DetachCurrentSyncContext(); // We can wait synchronously here and we won't have a deadlock. InitializeIfNeededAsync().Wait(); return 42; }</span></span></code> </pre> <br>  <code>Awaiters.DetachCurrentSyncContext</code> mengembalikan objek penunggu kustom berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DetachSynchronizationContextAwaiter : ICriticalNotifyCompletion { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Returns true if a current synchronization context is null. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> It means that the continuation is called only when a current context </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> is presented. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public bool IsCompleted =&gt; SynchronizationContext.Current == null; public void OnCompleted(Action continuation) { ThreadPool.QueueUserWorkItem(state =&gt; continuation()); } public void UnsafeOnCompleted(Action continuation) { ThreadPool.UnsafeQueueUserWorkItem(state =&gt; continuation(), null); } public void GetResult() { } public DetachSynchronizationContextAwaiter GetAwaiter() =&gt; this; } public static class Awaiters { public static DetachSynchronizationContextAwaiter DetachCurrentSyncContext() { return new DetachSynchronizationContextAwaiter(); } }</span></span></code> </pre> <br>  <code>DetachSynchronizationContextAwaiter</code> melakukan hal berikut: metode async bekerja dengan konteks sinkronisasi non-nol.  Tetapi jika metode async bekerja tanpa konteks sinkronisasi, properti <code>IsCompleted</code> mengembalikan true, dan kelanjutan metode dilakukan secara sinkron. <br><br>  Ini berarti bahwa data layanan mendekati nol ketika metode asinkron dijalankan dari utas di utas, dan pembayaran dilakukan sekali untuk mentransfer eksekusi dari utas antarmuka pengguna ke utas dari utas dari utas. <br><br>  Manfaat lain dari pendekatan ini tercantum di bawah ini. <br><br><ul><li>  <b>Kemungkinan kesalahan berkurang.</b>  <code>ConfigureAwait(false)</code> hanya berfungsi jika diterapkan pada semua tugas yang menunggu penyelesaian.  Perlu dilupakan setidaknya satu hal - dan kebuntuan dapat terjadi.  Dalam kasus objek penunggu kustom, ingat bahwa semua metode perpustakaan umum harus dimulai dengan <code>Awaiters.DetachCurrentSyncContext()</code> .  Kesalahan mungkin terjadi di sini, tetapi kemungkinannya jauh lebih rendah. </li><li>  <b>Kode yang dihasilkan lebih deklaratif dan jelas.</b>  Metode <code>ConfigureAwait</code> dengan beberapa panggilan tampaknya kurang dapat dibaca oleh saya (karena elemen tambahan) dan tidak cukup informatif untuk pemula. </li></ul><br><h2>  Penanganan pengecualian </h2><br>  Apa perbedaan antara dua opsi ini: <br><br>  Task mayFail = Task.FromException (ArgumentNullException baru ()); <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Case 1 try { await mayFail; } catch (ArgumentException e) { // Handle the error } // Case 2 try { mayFail.Wait(); } catch (ArgumentException e) { // Handle the error }</span></span></code> </pre> <br>  Dalam kasus pertama, semuanya memenuhi harapan - pemrosesan kesalahan dilakukan, tetapi dalam kasus kedua ini tidak terjadi.  Pustaka tugas paralel TPL dirancang untuk pemrograman asinkron dan paralel, dan Tugas / Tugas dapat mewakili hasil beberapa operasi.  Itulah sebabnya <code>Task.Result</code> dan <code>Task.Wait()</code> selalu melempar <code>AggregateException</code> , yang mungkin mengandung beberapa kesalahan. <br><br>  Namun, skenario utama kami mengubah segalanya: pengguna harus dapat menambahkan operator async / menunggu tanpa menyentuh logika penanganan kesalahan.  Artinya, pernyataan menunggu harus berbeda dari <code>Task.Result</code> / <code>Task.Wait()</code> : itu harus mengambil pembungkus satu pengecualian dalam contoh <code>AggregateException</code> .  Hari ini kita akan memilih pengecualian pertama. <br><br>  Semuanya baik-baik saja jika semua metode berdasarkan Tugas tidak sinkron dan komputasi paralel tidak digunakan untuk melakukan tugas.  Tetapi dalam beberapa kasus, semuanya berbeda: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// await will rethrow the first exception await Task.WhenAll(task1, task2); } catch (Exception e) { // ArgumentNullException. The second error is lost! Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br>  <code>Task.WhenAll</code> mengembalikan tugas dengan dua kesalahan, pernyataan menunggu menunggu dan hanya mengisi yang pertama. <br><br>  Ada dua cara untuk mengatasi masalah ini: <br><br><ol><li>  melihat tugas secara manual jika mereka memiliki akses, atau </li><li>  mengkonfigurasi pustaka TPL untuk memaksa pengecualian untuk dibungkus dengan <code>AggregateException</code> lain. </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// t.Result forces TPL to wrap the exception into AggregateException await Task.WhenAll(task1, task2).ContinueWith(t =&gt; t.Result); } catch(Exception e) { // AggregateException Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br><h2>  Metode batal async </h2><br>  Metode berbasis tugas mengembalikan token yang dapat digunakan untuk memproses hasil di masa depan.  Jika tugas tersebut hilang, token menjadi tidak dapat diakses untuk dibaca oleh kode pengguna.  Operasi asinkron yang mengembalikan metode void melempar kesalahan yang tidak dapat ditangani dalam kode pengguna.  Dalam hal ini, token tidak berguna dan bahkan berbahaya - sekarang kita akan melihatnya.  Namun, skenario utama kami mengasumsikan penggunaan wajib mereka: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; }</code> </pre> <br>  Tetapi bagaimana jika <code>GetStockPricesForAsync</code> melakukan kesalahan?  Pengecualian metode async void yang tidak ditangani dimasukkan ke dalam konteks sinkronisasi saat ini, memicu perilaku yang sama seperti untuk kode sinkron (untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode ThrowAsync</a> pada halaman web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AsyncMethodBuilder.cs</a> ).  Pada Windows Forms, pengecualian yang tidak ditangani dalam event handler memecat <code>Application.ThreadException</code> AcaraThreadException, untuk WPF, <code>Application.DispatcherUnhandledException</code> acara kebakaran, dan sebagainya. <br><br>  Bagaimana jika metode void async tidak mendapatkan konteks sinkronisasi?  Dalam hal ini, pengecualian yang tidak ditangani menyebabkan crash aplikasi yang fatal.  Itu tidak akan memecat acara [ <code>TaskScheduler.UnobservedTaskException</code> ] yang akan dipulihkan, tetapi itu akan memecat <code>AppDomain.UnhandledException</code> acara yang tidak dapat dipulihkan dan kemudian menutup aplikasi.  Ini terjadi dengan sengaja, dan inilah hasil yang kita butuhkan. <br><br>  Sekarang mari kita lihat cara terkenal lainnya: menggunakan metode batal asinkron hanya untuk penangan peristiwa antarmuka pengguna. <br><br>  Sayangnya, metode void asynch mudah dipanggil secara tidak sengaja. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Task&lt;T&gt; ActionWithRetry&lt;T&gt;(Func&lt;Task&lt;T&gt;&gt; provider, Action&lt;Exception&gt; onError) { <span class="hljs-comment"><span class="hljs-comment">// Calls 'provider' N times and calls 'onError' in case of an error. } public async Task&lt;string&gt; AccidentalAsyncVoid(string fileName) { return await ActionWithRetry( provider: () =&gt; { return File.ReadAllTextAsync(fileName); }, // Can you spot the issue? onError: async e =&gt; { await File.WriteAllTextAsync(errorLogFile, e.ToString()); }); }</span></span></code> </pre> <br>  Pada pandangan pertama, ekspresi lambda sulit untuk mengatakan apakah fungsinya adalah metode berbasis tugas atau metode batal async, dan oleh karena itu kesalahan dapat merayap ke dalam basis kode Anda, meskipun ada pemeriksaan paling teliti. <br><br><h2>  Kesimpulan </h2><br>  Banyak aspek pemrograman asinkron dalam C # dipengaruhi oleh skenario pengguna tunggal - cukup dengan mengubah kode sinkron aplikasi antarmuka pengguna yang ada menjadi asinkron: <br><br><ul><li>  Eksekusi selanjutnya dari metode asinkron dijadwalkan dalam konteks sinkronisasi yang dihasilkan, yang dapat menyebabkan kebuntuan. </li><li>  Untuk mencegahnya, perlu dilakukan panggilan <code>ConfigureAwait(false)</code> di mana-mana dalam kode pustaka asinkron. </li><li>  menunggu tugas;  menghasilkan kesalahan pertama, dan ini mempersulit penciptaan pengecualian pemrosesan untuk pemrograman paralel. </li><li>  Metode batal async telah diperkenalkan untuk menangani peristiwa antarmuka pengguna, tetapi mereka mudah dijalankan secara tidak sengaja, yang akan menyebabkan aplikasi mogok jika pengecualian dilemparkan. </li></ul><br>  Keju gratis hanya terjadi di perangkap tikus.  Kemudahan penggunaan kadang-kadang dapat menyebabkan kesulitan besar di bidang lain.  Jika Anda terbiasa dengan sejarah pemrograman asinkron dalam C #, perilaku paling aneh tidak lagi tampak aneh, dan kemungkinan kesalahan dalam kode asinkron berkurang secara signifikan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421245/">https://habr.com/ru/post/id421245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421227/index.html">Tinjauan umum kerangka kerja pengembangan lintas platform</a></li>
<li><a href="../id421229/index.html">Kisah sakit kepala saya</a></li>
<li><a href="../id421235/index.html">Magic Leap One kacamata - kacamata seharga $ 2295 dengan rawatan 3 dari 10</a></li>
<li><a href="../id421241/index.html">Bank Sentral meminta pemblokiran awal situs-situs jahat</a></li>
<li><a href="../id421243/index.html">LLTR Bagian 2: Algoritma untuk menentukan topologi jaringan dari statistik yang dikumpulkan</a></li>
<li><a href="../id421247/index.html">Bagaimana mengubah gambar menjadi suara, dan mengapa Anda membutuhkannya</a></li>
<li><a href="../id421249/index.html">Mengapa pemodal Wall Street bekerja terlalu banyak dan dapatkah diperbaiki</a></li>
<li><a href="../id421251/index.html">Sistem cadangan</a></li>
<li><a href="../id421253/index.html">Mengapa kita perlu mobil berekor?</a></li>
<li><a href="../id421255/index.html">Elon Musk membatalkan rencana untuk mengubah Tesla menjadi perusahaan swasta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>