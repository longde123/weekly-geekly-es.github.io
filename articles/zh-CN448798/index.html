<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤯 📺 👸🏼 使用pytest进行Python测试。 将pytest与其他工具结合使用，第7章 🍣 🙏 🎳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="回去 


 通常，pytest不是单独使用，而是在带有其他工具的测试环境中使用。 本章讨论了通常与pytest结合使用以进行有效测试的其他工具。 尽管这绝不是一个详尽的清单，但是这里讨论的工具将使您了解将pytest与其他工具混合使用的威力。 





 本书中的示例是使用Python 3.6和...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用pytest进行Python测试。 将pytest与其他工具结合使用，第7章</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448798/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回去</a> </p><br><p>  <em>通常，pytest不是单独使用，而是在带有其他工具的测试环境中使用。</em>  <em>本章讨论了通常与pytest结合使用以进行有效测试的其他工具。</em>  <em>尽管这绝不是一个详尽的清单，但是这里讨论的工具将使您了解将pytest与其他工具混合使用的威力。</em> </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p> 本书中的示例是使用Python 3.6和pytest 3.2编写的。  pytest 3.2支持Python 2.6、2.7和Python 3.3+。 </p><br><blockquote>本书网页上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">链接</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com</a>上提供了Tasks项目以及本书中显示的所有测试的源代码。 您无需下载源代码即可了解测试代码。 示例中以方便的形式提供了测试代码。 但是，为了跟上项目的任务，或者改编测试示例来测试自己的项目（不费力气！），您必须转到本书的网页并下载工作。 在该书的网页上，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/errata">勘误</a>信息链接和一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://forums.pragprog.com/forums/438">论坛</a> 。 </blockquote><p> 在剧透下方是该系列文章的列表。 </p><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>引言</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第1章：pytest入门</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第2章：编写测试函数</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第3章：Pytest固定装置</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第4章：内置灯具</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第5章：插件</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第6章：配置</strong></a> </li><li>  [ <strong>第7章：与其他工具一起使用pytest</strong> ]（本文）（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/zh/post/448798/</a> ） </li></ul></div></div><br><h2 id="pdb-debugging-test-failures">  pdb：调试测试失败 </h2><br><p> <code>pdb</code>模块是标准库中的Python调试器。 您使用<code>--pdb</code>以便pytest在出现故障时启动调试会话。 让我们来看一下Tasks项目上下文中的<code>pdb</code> 。 </p><br><p> 在第64页的“参数化夹具”中，我们使Tasks项目留下了一些错误： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/c/tasks_proj $ pytest --tb=no -q .........................................FF.FFFF FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF........... 42 failed, 54 passed in 4.74 seconds</code> </pre> <br><p> 在查看<code>pdb</code>如何帮助我们调试此测试之前，让我们看一下可用的pytest选项以加快调试测试错误的速度，我们首先在第9页的“使用选项”部分中进行了检查： </p><br><ul><li>  <code>--tb=[auto/long/short/line/native/no]</code> ：控制跟踪样式。 </li><li>  <code>-v / --verbose</code> ：显示所有通过或失败的测试名称。 </li><li>  <code>-l / --showlocals</code> ：在堆栈跟踪旁边显示局部变量。 </li><li>  <code>-lf / --last-failed</code> ：仅运行失败的测试。 </li><li>  <code>-x / --exitfirst</code> ：在第一次失败时停止测试会话。 </li><li>  <code>--pdb</code> ：在故障点启动交互式调试会话。 </li></ul><br><hr><br><p>  <em>安装MongoDB</em> </p><br><hr><br><p> 如第49页的第3章“ Pytest固定装置”中所述，运行MongoDB测试需要<code>MongoDB</code>和<code>pymongo</code>安装。 </p><br><p> 我测试了位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.mongodb.com/download-center上</a>的社区服务器的版本。  pymongo使用<code>pip install pymongo</code> ： <code>pip install pymongo</code> 。 但是，这是使用MongoDB的书中的最后一个示例。 要在不使用MongoDB的情况下尝试调试器，可以从<code>code/ch2/</code>运行pytest命令，因为该目录还包含一些失败的测试。 </p><br><hr><br><p> 我们只是从<code>code/ch3/c</code>运行了测试，以确保其中一些不起作用。 我们没有看到回溯或测试名称，因为<code>--tb=no</code>禁用了跟踪，并且没有启用<code>--verbose</code> 。 让我们用详细的文本重复错误（不超过三个）： </p><br><pre> <code class="plaintext hljs">$ pytest --tb=no --verbose --lf --maxfail=3 ============================= test session starts ============================= collected 96 items / 52 deselected run-last-failure: rerun previous 44 failures tests/func/test_add.py::test_add_returns_valid_id[mongo] ERROR [ 2%] tests/func/test_add.py::test_added_task_has_id_set[mongo] ERROR [ 4%] tests/func/test_add.py::test_add_increases_count[mongo] ERROR [ 6%] =================== 52 deselected, 3 error in 0.72 seconds ====================</code> </pre> <br><p> 现在我们知道哪些测试失败了。 让我们看一下其中的一个，使用<code>-x</code> ，打开跟踪，不使用<code>--tb=no</code> ，并使用<code>-l</code>显示局部变量： </p><br><pre> <code class="plaintext hljs">$ pytest -v --lf -l -x ===================== test session starts ====================== run-last-failure: rerun last 42 failures collected 96 items tests/func/test_add.py::test_add_returns_valid_id[mongo] FAILED =========================== FAILURES =========================== _______________ test_add_returns_valid_id[mongo] _______________ tasks_db = None def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;) should return an integer.""" # GIVEN an initialized tasks db # WHEN a new task is added # THEN returned task_id is of type int new_task = Task('do something') task_id = tasks.add(new_task) &gt; assert isinstance(task_id, int) E AssertionError: assert False E + where False = isinstance(ObjectId('59783baf8204177f24cb1b68'), int) new_task = Task(summary='do something', owner=None, done=False, id=None) task_id = ObjectId('59783baf8204177f24cb1b68') tasks_db = None tests/func/test_add.py:16: AssertionError !!!!!!!!!!!! Interrupted: stopping after 1 failures !!!!!!!!!!!! ===================== 54 tests deselected ====================== =========== 1 failed, 54 deselected in 2.47 seconds ============</code> </pre><br><p> 通常这足以了解测试失败的原因。 在这种特殊情况下，很明显<code>task_id</code>不是整数-它是ObjectId的实例。  ObjectId是MongoDB在数据库中用于对象标识符的类型。 我对<code>tasksdb_pymongo.py</code>层的意图是使系统其余部分隐藏MongoDB实现的某些细节。 很明显，在这种情况下，它不起作用。 </p><br><p> 但是，我们希望了解如何将pdb与pytest一起使用，因此让我们想象一下尚不清楚该测试为何失败。 我们可以使pytest启动调试会话，并使用<code>--pdb</code>在故障点<code>--pdb</code> ： </p><br><pre> <code class="plaintext hljs">$ pytest -v --lf -x --pdb ===================== test session starts ====================== run-last-failure: rerun last 42 failures collected 96 items tests/func/test_add.py::test_add_returns_valid_id[mongo] FAILED &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; traceback &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; tasks_db = None def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;) should return an integer.""" # GIVEN an initialized tasks db # WHEN a new task is added # THEN returned task_id is of type int new_task = Task('do something') task_id = tasks.add(new_task) &gt; assert isinstance(task_id, int) E AssertionError: assert False E + where False = isinstance(ObjectId('59783bf48204177f2a786893'), int) tests/func/test_add.py:16: AssertionError &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; entering PDB &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; /path/to/code/ch3/c/tasks_proj/tests/func/test_add.py(16) &gt; test_add_returns_valid_id() -&gt; assert isinstance(task_id, int) (Pdb)</code> </pre> <br><p> 现在，我们将在提示符（Pdb）的提示下，访问所有交互式pdb调试功能。 查看崩溃时，我经常使用以下命令： </p><br><ul><li>  <code>p/print expr</code> ：打印exp的值。 </li><li>  <code>pp expr</code> ：漂亮打印出expr的值。 </li><li>  <code>l/list</code> ：列出故障点以及上下两行代码。 </li><li>  <code>l/list begin,end</code> ：枚举特定的行号。 </li><li>  <code>a/args</code> ：显示当前函数的参数及其值。 </li><li>  <code>u/up</code> ：将堆栈路径上移一层。 </li><li>  <code>d/down</code> ：在堆栈跟踪中下移一级。 </li><li>  <code>q/quit</code> ：结束调试会话。 </li></ul><br><p> 其他导航命令（例如step和next）不是很有用，因为我们位于assert语句中。 您也可以简单地输入变量名称并获取值。 </p><br><p> 您可以与<code>-l/--showlocals</code>类似地使用<code>p/print expr</code>来查看函数中的值： </p><br><pre> <code class="plaintext hljs">(Pdb) p new_task Task(summary='do something', owner=None, done=False, id=None) (Pdb) p task_id ObjectId('59783bf48204177f2a786893') (Pdb)</code> </pre> <br><p> 现在，您可以退出调试器并继续测试。 </p><br><pre> <code class="plaintext hljs">(Pdb) q !!!!!!!!!!!! Interrupted: stopping after 1 failures !!!!!!!!!!!! ===================== 54 tests deselected ====================== ========== 1 failed, 54 deselected in 123.40 seconds ===========</code> </pre> <br><p> 如果我们不使用<code>-</code> ，pytest将在下一个测试中再次打开Pdb。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python文档中</a>提供了有关使用pdb模块的更多信息。 </p><br><h2 id="coveragepy-opredelenie-obema-testiruemogo-koda">  Coverage.py：确定测试代码的数量 </h2><br><p> 代码覆盖率是一组测试所测试的已测试代码百分比的指标。 在为“任务”项目运行测试时，某些“任务”功能在每次测试时都会执行，但不会全部执行。 </p><br><p> 代码覆盖率工具非常适合让您知道测试完全忽略了系统的哪些部分。 </p><br><p>  <code>Coverage.py</code>是首选的Python覆盖率工具，用于测量代码的覆盖率。 </p><br><p> 您将使用它通过pytest验证Tasks项目代码。 </p><br><p> 要使用<code>coverage.py</code>您需要安装它。 安装名为<code>pytest-cov</code>的插件<code>pytest-cov</code>没有什么坏处，该插件使您可以从pytest中调用<code>coverage.py</code>并提供其他一些pytest选项。 由于<code>coverage</code>是<code>pytest-cov</code>的依赖项之一，因此只需安装<code>pytest-cov</code> ，它将采用<code>coverage.py</code> ： </p><br><pre> <code class="plaintext hljs">$ pip install pytest-cov Collecting pytest-cov Using cached pytest_cov-2.5.1-py2.py3-none-any.whl Collecting coverage&gt;=3.7.1 (from pytest-cov) Using cached coverage-4.4.1-cp36-cp36m-macosx_10_10_x86 ... Installing collected packages: coverage, pytest-cov Successfully installed coverage-4.4.1 pytest-cov-2.5.1</code> </pre> <br><p> 让我们运行第二个任务版本的覆盖率报告。 如果您仍然安装了Tasks项目的第一个版本，请卸载它并安装版本2： </p><br><pre> <code class="plaintext hljs">$ pip uninstall tasks Uninstalling tasks-0.1.0: /path/to/venv/bin/tasks /path/to/venv/lib/python3.6/site-packages/tasks.egg-link Proceed (y/n)? y Successfully uninstalled tasks-0.1.0 $ cd /path/to/code/ch7/tasks_proj_v2 $ pip install -e . Obtaining file:///path/to/code/ch7/tasks_proj_v2 ... Installing collected packages: tasks Running setup.py develop for tasks Successfully installed tasks $ pip list ... tasks (0.1.1, /path/to/code/ch7/tasks_proj_v2/src) ...</code> </pre> <br><p> 现在已安装任务的下一版本，您可以运行基本覆盖率报告： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch7/tasks_proj_v2 $ pytest --cov=src ===================== test session starts ====================== plugins: mock-1.6.2, cov-2.5.1 collected 62 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ......... tests/func/test_unique_id.py . tests/unit/test_cli.py ..... tests/unit/test_task.py .... ---------- coverage: platform darwin, python 3.6.2-final-0 ----------- Name Stmts Miss Cover -------------------------------------------------- src\tasks\__init__.py 2 0 100% src\tasks\api.py 79 22 72% src\tasks\cli.py 45 14 69% src\tasks\config.py 18 12 33% src\tasks\tasksdb_pymongo.py 74 74 0% src\tasks\tasksdb_tinydb.py 32 4 88% -------------------------------------------------- TOTAL 250 126 50% ================== 62 passed in 0.47 seconds ===================</code> </pre> <br><p> 由于当前目录为<code>tasks_proj_v2</code> ，并且受测试的源代码位于src中，因此添加<code>--cov=src</code>选项仅针对该受测试目录生成覆盖报告。 </p><br><p> 如您所见，某些文件的覆盖率非常低，甚至为0％。 这些是有用的提醒： <code>tasksdb_pymongo.py</code> 0％，因为我们已禁用此版本中的MongoDB测试。 其中一些是相当低的。 在准备黄金时间之前，该项目当然必须为所有这些领域提供测试。 </p><br><p> 我相信几个文件的覆盖率更高： <code>api.py</code>和<code>tasksdb_tinydb.py</code> 。 让我们看一下<code>tasksdb_tinydb.py</code> ，看看缺少了什么。 我认为做到这一点的最佳方法是使用HTML报告。 </p><br><p> 如果使用<code>--cov-report=html</code>选项再次运行<code>coverage.py</code> ，将生成<code>--cov-report=html</code> ： </p><br><pre> <code class="plaintext hljs">$ pytest --cov=src --cov-report=html ===================== test session starts ====================== plugins: mock-1.6.2, cov-2.5.1 collected 62 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ......... tests/func/test_unique_id.py . tests/unit/test_cli.py ..... tests/unit/test_task.py .... ---------- coverage: platform darwin, python 3.6.2-final-0 ----------- Coverage HTML written to dir htmlcov ================== 62 passed in 0.45 seconds ===================</code> </pre> <br><p> 然后，您可以在浏览器中打开<code>htmlcov/index.html</code> ，在以下屏幕上显示输出： </p><br><p><img src="https://habrastorage.org/webt/vs/sc/84/vssc84hovxefvf2g65740gu3ll0.png"></p><br><p> 单击<code>tasksdb_tinydb.py</code>将显示一个文件的报告。 覆盖行的百分比显示在报告的顶部，加上覆盖的行数和未覆盖的行，如下一屏幕所示： </p><br><p><img src="https://habrastorage.org/webt/os/pc/-o/ospc-o_yzzdfh1lzllw_1qtilrc.png"></p><br><p> 向下滚动，您可以看到缺失的行，如以下屏幕所示： </p><br><p><img src="https://habrastorage.org/webt/85/rg/lt/85rgltocwrunycedzbeweix4zyc.png"></p><br><p> 即使此屏幕不是该文件的完整页面，也足以告诉我们： </p><br><ol><li> 我们不使用所有者集来测试<code>list_tasks()</code> 。 </li><li> 我们不测试<code>update()</code>或<code>delete()</code> 。 </li><li> 也许我们没有彻底测试<code>unique_id()</code> 。 </li></ol><br><p> 太好了 我们可以将它们包括在我们的TO-DO测试列表中，同时可以测试配置系统。 </p><br><p> 尽管代码覆盖率工具非常有用，但是争取100％覆盖率可能很危险。 当您看到未经测试的代码时，可能意味着需要测试。 但这也意味着有些系统功能是不需要的，可以删除。 像所有软件开发工具一样，代码覆盖率分析也不能取代思维。 </p><br><p> 有关更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> coverage.py</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>pytest-cov</code></a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> coverage.py</code></a> 。 </p><br><h2 id="mock-podmena-chastey-sistemy"> 模拟：替换系统零件 </h2><br><p> 模拟包用于替换系统的某些部分，以将测试代码的部分与系统的其余部分隔离开。 模拟-对象有时被称为测试双打，间谍，假货或存根。 </p><br><p> 在您自己的pytest Monkeypatch夹具（在第85页的使用Monkeypatch中所述）和模拟之间，您应该具有所有必需的双重测试功能。 </p><br><blockquote> 注意！ 模拟和很奇怪 <br> 如果这是您第一次遇到模拟，存根和间谍之类的测试双胞胎，请做好准备！ 这将是非常奇怪，非常快，有趣，尽管非常令人印象深刻。 </blockquote><p>  <code>mock</code>包随附标准的Python库，自Python 3.3起<code>unittest.mock</code> 。 在早期版本中，它作为通过PyPI安装的单独软件包提供。 这意味着您可以使用Python 2.6的<code>mock</code> PyPI版本到最新的Python版本，并获得与最新的<code>mock</code> Python相同的功能。 但是，与pytest一起使用时，名为<code>pytest-mock</code>的插件具有一些功能，使其成为我的模拟系统首选界面。 </p><br><p> 对于Tasks项目，我们将使用<code>mock</code>来帮助我们测试命令行界面。 在Coverage.py中：通过确定要测试的代码量，在第129页上，您看到我们的<code>cli.py</code>文件根本没有经过测试。 我们现在将开始修复它。 但是，让我们先谈谈策略。 </p><br><p>  Tasks项目中的第一个解决方案是通过<code>api.py</code>进行大多数功能测试。 因此，一个合理的解决方案是命令行测试不必是完整的功能测试。 如果在CLI测试期间获得湿API级别，我们可以确保系统将通过CLI正常工作。 这也是一种方便的解决方案，可让我们在此部分中查看moki。 </p><br><p>  CLI Tasks实现使用第三方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Click</a>命令行界面包。 有许多实现命令行界面的方法，包括内置在Python <code>argparse</code>的模块。 我选择Click的原因之一是因为它包含一个可帮助我们测试Click应用程序的测试引擎。 但是，尽管我们希望<code>cli.py</code>的代码是Click应用程序的典型，但它并不明显。 </p><br><p> 让我们放慢速度并安装第三个版本的Tasks： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ $ pip install -e ch7/tasks_proj_v2 ... Successfully installed tasks</code> </pre> <br><p> 在本节的其余部分，您将开发一些测试来测试列表的功能。 <br> 让我们看一下它的作用，以了解我们要检查的内容： </p><br><blockquote>  <strong><em>译者注：</em></strong>在使用Windows平台时，在测试下面的会话时遇到了几个问题。 <br><ol><li> 应该在用户文件夹中为名为<strong><code>tasks_db</code></strong>的数据库创建一个文件夹。 例如<code>c:\Users\User_1\tasks_db\</code> <br> 否则，我们得到-&gt;&gt; FileNotFoundError：[Errno 2]没有这样的文件或目录：'c：\ Users \ User_1 // tasks_db // tasks_db.json' </li><li> 使用双引号而不是撇号。 否则会出现错误 <br>  “做点很棒的事” <br> 用法：任务添加[选项]摘要 <br> 尝试“任务添加-h”以获取帮助。 <br><br> 错误：出现了意外的额外参数（很棒的“”） <br></li></ol><br></blockquote><br><pre> <code class="plaintext hljs">$ tasks list ID owner done summary -- ----- ---- ------- $ tasks add 'do something great' $ tasks add "repeat" -o Brian $ tasks add "again and again" --owner Okken $ tasks list ID owner done summary -- ----- ---- ------- 1 False do something great 2 Brian False repeat 3 Okken False again and again $ tasks list -o Brian ID owner done summary -- ----- ---- ------- 2 Brian False repeat $ tasks list --owner Brian ID owner done summary -- ----- ---- ------- 2 Brian False repeat</code> </pre> <br><p> 看起来很简单。  <code>tasks list</code>命令在标题下显示所有任务的列表。 <br> 即使列表为空，也会打印标题。 如果使用<code>-o</code>或<code>--owner</code> ，则该命令仅显示来自一个所有者的数据。 以及我们如何检查呢？ 有很多方法，但是我们将使用moki。 </p><br><p> 使用MOK的测试必定是<em>白盒测试</em> ，我们需要研究代码来确定要击打的内容和位置。 主要入口点在这里： </p><br><blockquote>  ch7 /tasks_proj_v2/src/tasks/cli.py </blockquote><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: tasks_cli()</code> </pre> <br><p> 这只是对<code>tasks_cli()</code>的调用： </p><br><blockquote>  ch7 /tasks_proj_v2/src/tasks/cli.py </blockquote><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@click.group(context_settings={'help_option_names': ['-h', '--help']}) @click.version_option(version='0.1.1') def tasks_cli(): """Run the tasks application.""" pass</span></span></code> </pre> <br><p> 显然吗？ 不行 但是，等等，它会变得好（或坏，取决于您的观点）。 这是<code>list</code>命令之一： </p><br><blockquote>  ch7 /tasks_proj_v2/src/tasks/cli.py </blockquote><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@tasks_cli.command(name="list", help="list tasks") @click.option('-o', '--owner', default=None, help='list tasks with this owner') def list_tasks(owner): """    .   ,      . """ formatstr = "{: &gt;4} {: &gt;10} {: &gt;5} {}" print(formatstr.format('ID', 'owner', 'done', 'summary')) print(formatstr.format('--', '-----', '----', '-------')) with _tasks_db(): for t in tasks.list_tasks(owner): done = 'True' if t.done else 'False' owner = '' if t.owner is None else t.owner print(formatstr.format( t.id, owner, done, t.summary))</span></span></code> </pre> <br><p> 当您习惯于编写Click代码时，请确保该代码还不错。 我不会在这里解释它在此功能中的作用和工作方式，因为命令行代码的开发不是本书的重点。 但是，尽管我几乎绝对可以确保我拥有正确的代码，但是总会有很大的人为错误余地。 因此，要确保此功能正常运行，必须进行一系列良好的自动化测试。 <br> 此<code>list_tasks(owner)</code>函数依赖于其他几个函数： <code>tasks_db()</code>是上下文管理器，而<code>tasks.list_tasks(owner)</code>是API函数。 </p><br><p> 我们将使用<code>mock</code>将虚假函数放置在<code>tasks_db()</code>和<code>tasks.list_tasks()</code>适当位置。 然后，我们可以通过命令行界面调用<code>list_tasks</code>方法，并确保它调用了<code>tasks.list_tasks()</code>函数，该函数可以正常工作并正确处理返回值。 <br> 要淹没<code>tasks_db()</code> ，让我们看一个实际的实现： </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回去</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448798/">https://habr.com/ru/post/zh-CN448798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448782/index.html">使用pytest进行Python测试。 pytest入门，第1章</a></li>
<li><a href="../zh-CN448786/index.html">使用pytest进行Python测试。 第3章pytest固定装置</a></li>
<li><a href="../zh-CN448788/index.html">使用pytest进行Python测试。 第2章，编写测试函数</a></li>
<li><a href="../zh-CN448790/index.html">SpaceVIL-用于在.Net Core，.Net Standard和JVM上开发的跨平台GUI框架</a></li>
<li><a href="../zh-CN448796/index.html">使用pytest进行Python测试。 配置，第6章</a></li>
<li><a href="../zh-CN448800/index.html">使用.vsconfig在整个组织中配置Visual Studio</a></li>
<li><a href="../zh-CN448802/index.html">关于门户网站的思考：在虚幻引擎4中创建门户网站</a></li>
<li><a href="../zh-CN448804/index.html">为macOS的强化运行时和公证做好准备</a></li>
<li><a href="../zh-CN448806/index.html">在Qt库上创建扩展系统</a></li>
<li><a href="../zh-CN448808/index.html">关于简单的事情，复杂的。 “睡觉的钢。” 如何用单个螺栓对生锈的螺栓或非WD-40螺栓润滑</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>