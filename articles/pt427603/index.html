<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎁 🍑 🔻 Como finalmente começar a escrever testes e não se arrepender 👨🏿‍🤝‍👨🏻 🖖🏻 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chegando a um novo projeto, encontro regularmente uma das seguintes situações: 



1. Não há testes. 
2. Existem poucos testes, eles raramente são esc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como finalmente começar a escrever testes e não se arrepender</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/427603/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/vr/v7/q_/vrv7q_kwfiqd5f7qx7jxwukv62g.jpeg"></a> <br><br>  Chegando a um novo projeto, encontro regularmente uma das seguintes situações: <br><br><ol><li>  Não há testes. </li><li>  Existem poucos testes, eles raramente são escritos e não são executados continuamente. </li><li>  Os testes estão presentes e incluídos no CI (integração contínua), mas causam mais danos do que benefícios. </li></ol><br>  Infelizmente, é o último cenário que geralmente leva a sérias tentativas de iniciar a implementação de testes na ausência de habilidades apropriadas. <br><br>  O que pode ser feito para mudar a situação atual?  A ideia de usar testes não é nova.  Ao mesmo tempo, a maioria dos tutoriais se assemelha à famosa figura sobre como desenhar uma coruja: conecte o JUnit, escreva o primeiro teste, use o primeiro simulador - e pronto!  Esses artigos não respondem a perguntas sobre quais testes precisam ser escritos, em que vale a pena prestar atenção e como conviver com tudo isso.  A partir daqui, a ideia deste artigo nasceu.  Tentei resumir brevemente minha experiência na implementação de testes em diferentes projetos, a fim de facilitar esse caminho para todos. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"></div><br>  Existem artigos introdutórios mais do que suficientes sobre esse tópico, portanto não nos repetiremos e tentaremos ir do outro lado.  Na primeira parte, desbancaremos o mito de que o teste acarreta custos exclusivamente adicionais.  Será mostrado como a criação de testes de qualidade, por sua vez, pode acelerar o processo de desenvolvimento.  Então, no exemplo de um projeto pequeno, serão considerados os princípios e regras básicos que devem ser seguidos para obter esse benefício.  Finalmente, na seção final, recomendações específicas de implementação serão fornecidas: como evitar problemas típicos quando os testes começam, pelo contrário, diminuem significativamente o desenvolvimento. <br><br>  Como minha principal especialização é o Java back-end, a seguinte pilha de tecnologia será usada nos exemplos: Java, JUnit, H2, Mockito, Spring, Hibernate.  Ao mesmo tempo, uma parte significativa do artigo é dedicada a problemas gerais de teste e as dicas são aplicáveis ​​a uma gama muito maior de tarefas. <br><br>  No entanto, tenha cuidado!  Os testes são muito viciantes: depois que você aprender a usá-los, não poderá mais viver sem eles. <br><br><div class="spoiler">  <b class="spoiler_title">Conteúdo</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Testes versus velocidade de desenvolvimento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Executando código em qualquer lugar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relançando testes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depuração</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eficácia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Da teoria à prática</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desafio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo de domínio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrutura do projeto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Testes de integração</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Testes unitários</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recomendações de implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclusão</a> </div></div><br><a name="TestsVsSpeed"></a><h2>  Testes versus velocidade de desenvolvimento </h2><br>  As principais perguntas que surgem ao discutir a implementação de testes: quanto tempo levará para escrever testes e quais benefícios ele terá?  Os testes, como qualquer outra tecnologia, exigirão esforços sérios para desenvolvimento e implementação, portanto, a princípio, nenhum benefício significativo deve ser esperado.  Quanto aos custos de tempo, eles são altamente dependentes da equipe em particular.  No entanto, menos de 20 a 30% dos custos adicionais da codificação não devem ser calculados exatamente.  Menos simplesmente não é suficiente para alcançar pelo menos algum resultado.  A expectativa de retornos instantâneos é frequentemente o principal motivo para restringir essa atividade antes mesmo que os testes se tornem úteis. <br><br>  Mas de que tipo de eficiência estamos falando?  Vamos soltar as letras das dificuldades de implementação e ver quais oportunidades específicas para economizar tempo nos testes se abrem. <br><br><a name="CodeRun"></a><h3>  Executando código em qualquer lugar </h3><br>  Se não houver testes no projeto, a única maneira de começar é levantar o aplicativo inteiro.  É bom que demore cerca de 15 a 20 segundos, mas os casos de grandes projetos nos quais um lançamento completo pode demorar alguns minutos estão longe de ser raros.  O que isso significa para os desenvolvedores?  Uma parte significativa de seu tempo de trabalho serão essas breves sessões de espera, durante as quais é impossível continuar trabalhando na tarefa atual, mas ao mesmo tempo, há muito pouco tempo para mudar para outra coisa.  Muitos já encontraram pelo menos uma vez esses projetos em que o código escrito em uma hora requer muitas horas de depuração devido a longas reinicializações entre as correções.  Nos testes, você pode limitar-se a executar pequenas partes do aplicativo, o que reduzirá significativamente o tempo de espera e aumentará a produtividade do trabalho no código. <br><br>  Além disso, a capacidade de executar código em qualquer lugar leva a uma depuração mais completa.  Frequentemente, verificar até os principais casos de uso positivos por meio da interface do aplicativo requer muito esforço e tempo.  A presença de testes torna possível realizar uma verificação detalhada de uma funcionalidade específica com muito mais facilidade e rapidez. <br><br>  Outra vantagem é a capacidade de regular o tamanho da unidade testada.  Dependendo da complexidade da lógica que está sendo testada, você pode restringir-se a um método, uma classe, um grupo de classes que implementa alguma funcionalidade, um serviço etc., até a automação do teste de todo o aplicativo.  Essa flexibilidade permite descarregar testes de alto nível de várias partes devido ao fato de que eles serão testados em níveis mais baixos. <br><br><a name="RepeatedRun"></a><h3>  Relançando testes </h3><br>  Esse plus é frequentemente citado como a essência da automação de testes, mas vamos ver de um ângulo menos familiar.  Que novas oportunidades ele abre para os desenvolvedores? <br><br>  Primeiramente, cada novo desenvolvedor que veio ao projeto poderá executar facilmente testes existentes para entender a lógica do aplicativo usando exemplos.  Infelizmente, a importância disso é muito subestimada.  Em condições modernas, as mesmas pessoas raramente trabalham em um projeto por mais de um a dois anos.  E como as equipes são compostas por várias pessoas, a aparência de um novo participante a cada 2-3 meses é uma situação típica para projetos relativamente grandes.  Projetos particularmente difíceis estão passando por mudanças de gerações inteiras de desenvolvedores!  A capacidade de iniciar facilmente qualquer parte do aplicativo e observar o comportamento do sistema às vezes simplifica a imersão de novos programadores no projeto.  Além disso, um estudo mais detalhado da lógica do código reduz o número de erros cometidos na saída e o tempo para depurá-los no futuro. <br><br>  Em segundo lugar, a capacidade de verificar facilmente se o aplicativo está funcionando corretamente abre caminho para a refatoração contínua.  Infelizmente, esse termo é muito menos popular que o IC.  Isso significa que a refatoração pode e deve ser feita sempre que o código é refinado.  É o cumprimento regular da notória regra dos escoteiros “deixe o estacionamento mais limpo do que era antes da sua chegada”, o que permite evitar a degradação do código base e garante ao projeto uma vida longa e feliz. <br><br><a name="Debugging"></a><h3>  Depuração </h3><br>  A depuração já foi mencionada nos parágrafos anteriores, mas esse ponto é tão importante que merece uma análise mais detalhada.  Infelizmente, não há uma maneira confiável de medir a relação entre o tempo gasto escrevendo e depurando o código, pois esses processos são praticamente inseparáveis ​​um do outro.  No entanto, a presença de testes de qualidade no projeto reduz significativamente o tempo de depuração, até a quase completa ausência da necessidade de executar um depurador. <br><br><a name="Efficiency"></a><h3>  Eficácia </h3><br>  Todas as opções acima podem economizar significativamente tempo na depuração inicial do código.  Com a abordagem correta, somente isso pagará todos os custos adicionais de desenvolvimento.  Os bônus de teste restantes - melhorando a qualidade da base de código (código mal projetado é difícil de testar), reduzindo o número de defeitos, a capacidade de verificar a correção do código a qualquer momento etc. - ficarão quase gratuitos. <br><br><a name="FromTheoryToPractice"></a><h2>  Da teoria à prática </h2><br>  Em palavras, tudo parece bom, mas vamos ao que interessa.  Como mencionado anteriormente, existem materiais mais do que suficientes sobre como fazer a configuração inicial do ambiente de teste.  Portanto, prosseguimos imediatamente para o projeto finalizado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes aqui.</a> <br><br><a name="Task"></a><h3>  Desafio </h3><br>  Como uma tarefa de modelo, considere um pequeno fragmento do back-end de uma loja online.  Escreveremos uma API típica para trabalhar com produtos: criar, receber, editar.  Além de alguns métodos para trabalhar com os clientes: alterar um "produto favorito" e calcular pontos de bônus para um pedido. <br><br><a name="DomainModel"></a><h3>  Modelo de domínio </h3><br>  Para não sobrecarregar o exemplo, nos restringimos a um conjunto mínimo de campos e classes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/pn/pz/wcpnpz94fmrb-av0-wkkuu4l2wi.jpeg"></div><br><br>  O cliente possui um nome de usuário, um link para um produto favorito e um sinalizador indicando se é um cliente premium. <br><br>  Produto (Produto) - nome, preço, desconto e sinalizador indicando se é atualmente anunciado. <br><br><a name="ProjectStructure"></a><h3>  Estrutura do projeto </h3><br>  A estrutura do código principal do projeto é a seguinte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/qa/m3/ksqam31c3vwkzdfwkmi8r7o3ggk.jpeg"></div><br><br>  As classes são em camadas: <br><br><ul><li>  Modelo - modelo de domínio do projeto; </li><li>  Jpa - repositórios para trabalhar com bancos de dados baseados em Spring Data; </li><li>  Serviço - lógica de negócios da aplicação; </li><li>  Controlador - controladores que implementam a API. </li></ul><br>  Estrutura de teste de unidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/_1/mi/i3_1micxy4kvvlb6dlgihfmmng0.jpeg"></div><br><br>  As classes de teste estão nos mesmos pacotes que o código original.  Além disso, foi criado um pacote com construtores para a preparação dos dados de teste, mas mais sobre isso abaixo. <br><br>  É conveniente separar testes de unidade e testes de integração.  Eles geralmente têm dependências diferentes e, para um desenvolvimento confortável, deve haver a capacidade de executar um ou outro.  Isso pode ser alcançado de várias maneiras: convenções de nomenclatura, módulos, pacotes, sourceSets.  A escolha de um método específico é exclusivamente uma questão de gosto.  Neste projeto, os testes de integração estão em um sourceSet - integrationTest separado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/1w/z7/qq1wz7n9tq77_zromu01ofx9cns.jpeg"></div><br><br>  Como os testes de unidade, as classes com testes de integração estão nos mesmos pacotes que o código original.  Além disso, existem classes base que ajudam a se livrar da duplicação de configuração e, se necessário, contêm métodos universais úteis. <br><br><a name="IntegrationTests"></a><h3>  Testes de integração </h3><br>  Existem diferentes abordagens para quais testes valem a pena começar.  Se a lógica testada não for muito complicada, você poderá prosseguir imediatamente para as de integração (elas também são chamadas de aceitação).  Ao contrário dos testes de unidade, eles garantem que o aplicativo como um todo funcione corretamente. <br><br>  <b>Arquitetura</b> <br><br>  Primeiro, você precisa decidir em que nível específico as verificações de integração serão executadas.  O Spring Boot oferece total liberdade de escolha: você pode elevar parte do contexto, todo o contexto e até um servidor completo, acessível a partir dos testes.  À medida que o tamanho do aplicativo aumenta, esse problema se torna cada vez mais complexo.  Muitas vezes, você precisa escrever testes diferentes em diferentes níveis. <br><br>  Um bom ponto de partida seria o teste do controlador sem iniciar o servidor.  Em aplicações relativamente pequenas, é aceitável elevar todo o contexto, pois, por padrão, é reutilizado entre testes e inicializado apenas uma vez.  Considere os métodos básicos da classe <code>ProductController</code> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"new"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.createProduct(product); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.getProduct(productId); } <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}/edit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId, @RequestBody Product product) </span></span>{ productService.updateProduct(productId, product); }</code> </pre> <br>  A questão do tratamento de erros é deixada de lado.  Suponha que ele seja implementado externamente com base em uma análise de exceções lançadas.  O código dos métodos é muito simples, sua implementação no <code>ProductService</code> não <code>ProductService</code> muito mais complicada: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(product)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId, Product product)</span></span></span><span class="hljs-function"> </span></span>{ Product dbProduct = productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); dbProduct.setPrice(product.getPrice()); dbProduct.setDiscount(product.getDiscount()); dbProduct.setName(product.getName()); dbProduct.setIsAdvertised(product.isAdvertised()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(dbProduct); }</code> </pre> <br>  O repositório <code>ProductRepository</code> não contém seus próprios métodos: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Tudo indica que essas classes não precisam de testes de unidade simplesmente porque toda a cadeia pode ser verificada com facilidade e eficiência por vários testes de integração.  A duplicação dos mesmos testes em testes diferentes complica a depuração.  No caso de um erro no código, agora nenhum teste cairá, mas 10 a 15 de uma vez.  Por sua vez, isso exigirá uma análise mais aprofundada.  Se não houver duplicação, é provável que o único teste reprovado indique imediatamente um erro. <br><br>  <b>Configuração</b> <br><br>  Por conveniência, destacamos a classe base <code>BaseControllerIT</code> , que contém a configuração Spring e alguns campos: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.NONE) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseControllerIT</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ProductRepository productRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> CustomerRepository customerRepository; }</code> </pre> <br>  Os repositórios são movidos para a classe base para não confundir as classes de teste.  Sua função é exclusivamente auxiliar: preparando dados e verificando o status do banco de dados após o controlador funcionar.  Quando você aumenta o tamanho do aplicativo, isso pode não ser mais conveniente, mas, para começar, é bastante adequado. <br><br>  A configuração principal do Spring é definida pelas seguintes linhas: <br><br>  <code>@SpringBootTest</code> - usado para definir o contexto do aplicativo.  <code>WebEnvironment.NONE</code> significa que nenhum contexto da web precisa ser gerado. <br><br>  <code>@Transactional</code> - <code>@Transactional</code> todos os testes de classe em uma transação com reversão automática para salvar o estado do banco de dados. <br><br>  <b>Estrutura de teste</b> <br><br>  Vamos passar para um conjunto minimalista de testes para a classe <code>ProductControllerIT</code> - <code>ProductControllerIT</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct_productSaved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); Product createdProduct = productController.createProduct(product); Product dbProduct = productRepository.getOne(createdProduct.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  O código do teste deve ser extremamente simples e compreensível à primeira vista.  Caso contrário, a maioria das vantagens dos testes descritos na primeira seção do artigo são perdidas.  É uma boa prática dividir o corpo de teste em três partes que podem ser visualmente separadas uma da outra: preparar dados, chamar o método de teste, validar os resultados.  Ao mesmo tempo, é muito desejável que o código de teste caiba na tela como um todo. <br><br>  Pessoalmente, parece-me mais óbvio quando os valores de teste da seção de preparação de dados são usados ​​posteriormente nas verificações.  Como alternativa, você pode comparar explicitamente objetos, por exemplo, assim: <br><br><pre> <code class="java hljs">assertEquals(product, dbProduct);</code> </pre> <br>  Em outro teste para atualizar as informações do produto ( <code>updateProduct</code> ), fica claro que a criação de dados se tornou um pouco mais complicada e, para manter a integridade visual das três partes do teste, eles são separados por dois feeds de linha seguidos: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct_productUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product updatedProduct = product(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); updatedProduct.setId(product.getId()); productController.updateProduct(product.getId(), updatedProduct); Product dbProduct = productRepository.getOne(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Cada uma das três partes da massa pode ser simplificada.  Para a preparação dos dados, os construtores de teste são excelentes, os quais contêm a lógica para criar objetos que é conveniente para usar a partir de testes.  Chamadas de método muito complexas podem ser transformadas em métodos auxiliares nas classes de teste, ocultando alguns dos parâmetros que são irrelevantes para essa classe.  Para simplificar verificações complexas, você também pode escrever funções auxiliares ou implementar seus próprios correspondentes.  O principal com todas essas simplificações é não perder a visibilidade do teste: tudo deve ficar claro rapidamente no método principal, sem a necessidade de aprofundar. <br><br>  <b>Construtores de teste</b> <br><br>  Os construtores de teste merecem atenção especial.  Encapsular a lógica da criação de objetos simplifica a manutenção do teste.  Em particular, o preenchimento dos campos do modelo que não são relevantes para este teste pode ser oculto dentro do construtor.  Para fazer isso, não é necessário criá-lo diretamente, mas use um método estático que preencha os campos ausentes com valores padrão.  Por exemplo, se novos campos obrigatórios aparecerem no modelo, eles poderão ser facilmente adicionados a esse método.  No <code>ProductBuilder</code> fica assim: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder() .name(name) .advertised(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .price(<span class="hljs-string"><span class="hljs-string">"0.00"</span></span>); }</code> </pre> <br>  <b>Nome do teste</b> <br><br>  É imperativo entender o que é testado especificamente neste teste.  Para maior clareza, é melhor dar uma resposta a esta pergunta em seu título.  Usando os testes de amostra para o método <code>getProduct</code> considere a convenção de nomenclatura usada: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_oneProductInDb_productReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product result = productController.getProduct(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, result.getName()); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_twoProductsInDb_correctProductReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Product result = productController.getProduct(product1.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>, result.getName()); }</code> </pre> <br>  No caso geral, o cabeçalho do método de teste consiste em três partes, separadas por sublinhado: o nome do método que está sendo testado, o script e o resultado esperado.  No entanto, ninguém cancelou o bom senso e pode ser justificado omitir algumas partes do nome se elas não forem necessárias nesse contexto (por exemplo, um script em um único teste para criar um produto).  O objetivo dessa nomeação é garantir que a essência de cada teste seja compreensível sem aprender o código.  Isso torna a janela dos resultados do teste o mais clara possível e é com ela que o trabalho com os testes geralmente começa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/0k/p9/gu0kp9p5hdbswo4i8d6ti2sy1qi.jpeg"></div><br><br>  <b>Conclusões</b> <br><br>  Isso é tudo.  Pela primeira vez, um conjunto mínimo de quatro testes é suficiente para testar os métodos da classe <code>ProductController</code> .  No caso de detecção de erros, você sempre pode adicionar os testes ausentes.  Ao mesmo tempo, o número mínimo de testes reduz significativamente o tempo e o esforço para apoiá-los.  Isso, por sua vez, é fundamental no processo de implementação dos testes, uma vez que os primeiros testes geralmente não são da melhor qualidade e criam muitos problemas inesperados.  Ao mesmo tempo, esse conjunto de testes é suficiente para receber os bônus descritos na primeira parte do artigo. <br><br>  Vale ressaltar que esses testes não verificam a camada da web do aplicativo, mas geralmente isso não é necessário.  Se necessário, você pode escrever testes separados para a camada da Web com um esboço em vez da base ( <code>@WebMvcTest</code> , <code>MockMvc</code> , <code>@MockBean</code> ) ou usar um servidor completo.  O último pode complicar a depuração e o trabalho com transações, pois o teste não pode controlar a transação do servidor.  Um exemplo desse teste de integração pode ser encontrado na classe <code>CustomerControllerServerIT</code> . <br><br><a name="UnitTests"></a><h3>  Testes unitários </h3><br>  Os testes de unidade têm várias vantagens sobre os testes de integração: <br><br><ul><li>  A inicialização leva milissegundos; </li><li>  Tamanho pequeno da unidade testada; </li><li>  É fácil implementar a verificação de um grande número de opções, pois quando o método é chamado diretamente, a preparação dos dados é bastante simplificada. </li></ul><br>  Apesar disso, os testes de unidade, por natureza, não podem garantir a operacionalidade do aplicativo como um todo e não permitem que você evite gravar os de integração.  Se a lógica da unidade em teste for simples, a duplicação de testes de integração com testes de unidade não trará nenhum benefício, mas apenas adicionará mais código ao suporte. <br><br>  A única classe neste exemplo que merece teste de unidade é o <code>BonusPointCalculator</code> .  Sua característica distintiva é um grande número de ramos da lógica de negócios.  Por exemplo, supõe-se que o comprador receba bônus de 10% do custo do produto, multiplicado por não mais de 2 multiplicadores da lista a seguir: <br><br><ul><li>  O produto custa mais de 10.000 (× 4); </li><li>  O produto participa de uma campanha publicitária (× 3); </li><li>  O produto é o produto "favorito" do cliente (× 5); </li><li>  O cliente tem um status premium (× 2); </li><li>  Se o cliente tiver um status premium e comprar um produto “favorito”, em vez dos dois multiplicadores indicados, um (× 8) será usado. </li></ul><br>  Na vida real, é claro, valeria a pena projetar um mecanismo universal flexível para calcular esses bônus, mas, para simplificar o exemplo, nos restringimos a uma implementação fixa.  O código de cálculo do multiplicador é assim: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;BigDecimal&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateMultipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, Product product)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;BigDecimal&gt; multipliers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.getFavProduct() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; customer.getFavProduct().equals(product)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_FAVORITE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { multipliers.add(FAVORITE_MULTIPLIER); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.isAdvertised()) { multipliers.add(ADVERTISED_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.getPrice().compareTo(EXPENSIVE_THRESHOLD) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { multipliers.add(EXPENSIVE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multipliers; }</code> </pre> <br>  Um grande número de opções leva ao fato de que dois ou três testes de integração não são limitados aqui.  Um conjunto minimalista de testes de unidade é perfeito para depurar essa funcionalidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/jw/ai/bkjwai9dy1mrxxarxncx6jgfehq.jpeg"></div><br><br>  O conjunto de testes correspondente pode ser encontrado na classe <code>BonusPointCalculatorTest</code> .  Aqui estão alguns deles: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_oneProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); assertEquals(expectedBonus, bonus); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_favProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).favProduct(product).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).addMultiplier(FAVORITE_MULTIPLIER).build(); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Vale ressaltar que nos testes nos referimos especificamente à API pública da classe - o método de <code>calculate</code> .  Testar um contrato de classe em vez de sua implementação evita quebras de testes devido a alterações não funcionais e refatoração. <br><br>  Finalmente, quando verificamos a lógica interna com testes de unidade, não precisamos mais colocar todos esses detalhes em integração.  Nesse caso, basta um teste mais ou menos representativo, por exemplo: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateBonusPoints_twoProductTypes_correctValueCalculated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"10.00"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); customerRepository.save(customer); Map&lt;Long, Long&gt; quantities = mapOf(product1.getId(), <span class="hljs-number"><span class="hljs-number">1L</span></span>, product2.getId(), <span class="hljs-number"><span class="hljs-number">2L</span></span>); BigDecimal bonus = customerController.calculateBonusPoints( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalculateBonusPointsRequest(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, quantities) ); BigDecimal bonusPointsProduct1 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); BigDecimal bonusPointsProduct2 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).quantity(<span class="hljs-number"><span class="hljs-number">2</span></span>).build(); BigDecimal expectedBonus = bonusPointsProduct1.add(bonusPointsProduct2); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Como no caso de testes de integração, o conjunto de testes de unidade usado é muito pequeno e não garante a total correção da aplicação.  No entanto, sua presença aumenta significativamente a confiança no código, facilita a depuração e concede os outros bônus listados na primeira parte do artigo. <br><br><a name="ImplementationConsiderations"></a><h2>  Recomendações de implementação </h2><br>  Espero que as seções anteriores tenham sido suficientes para convencer pelo menos um desenvolvedor a tentar começar a usar testes em seu projeto.  Este capítulo listará brevemente as principais recomendações que ajudarão a evitar problemas sérios e reduzirão os custos iniciais de implementação. <br><br>  <b>Tente começar a implementar os testes no novo aplicativo.</b>  Escrever os primeiros testes em um grande projeto legado será muito mais difícil e exigirá mais habilidade do que em um recém-criado.  Portanto, se possível, é melhor começar com um novo aplicativo pequeno.  Se novos aplicativos completos não forem esperados, você pode tentar desenvolver algum utilitário útil para uso interno.  O principal é que a tarefa deve ser mais ou menos realista - exemplos inventados não fornecerão uma experiência completa. <br><br>  <b>Configure execuções de teste regulares.</b>  Se os testes não forem executados regularmente, eles não apenas param de executar sua função principal - verificar a correção do código - mas também rapidamente se tornam desatualizados.  Portanto, é extremamente importante configurar pelo menos o pipeline mínimo de IC com o lançamento automático de testes sempre que o código for atualizado no repositório. <br><br>  <b>Não persiga a tampa.</b>  Como no caso de qualquer outra tecnologia, a princípio os testes não serão obtidos da melhor qualidade.  A literatura relevante (links no final do artigo) ou um mentor competente pode ajudar aqui, mas isso não cancela a necessidade de cones autoadesivos.  Os testes nesse sentido são semelhantes ao restante do código: para entender como eles afetarão o projeto, é possível somente depois de viver com eles por um tempo.  Portanto, para minimizar os danos, a primeira vez é melhor não perseguir o número e números bonitos como cem por cento de cobertura.  Em vez disso, você deve limitar-se aos principais cenários positivos para a sua própria funcionalidade de aplicativo. <br><br>  <b>Não se deixe levar pelos testes de unidade.</b>  Continuando o tema “quantidade versus qualidade”, deve-se notar que testes de unidade honestos não devem ser realizados pela primeira vez, porque isso pode facilmente levar a especificações excessivas da aplicação.  Por sua vez, isso se tornará um sério fator inibidor nas subsequentes melhorias na refatoração e aplicação.  Os testes de unidade devem ser usados ​​apenas se houver lógica complexa em uma classe ou grupo de classes específico, o que é inconveniente para verificar no nível de integração. <br><br>  <b>Não se empolgue com classes de stub e métodos de aplicação.</b>  Os stubs (stub, mock) são outra ferramenta que requer uma abordagem equilibrada e a manutenção de um equilíbrio.  Por um lado, o isolamento completo da unidade permite que você se concentre na lógica testada e não pense no resto do sistema.  Por outro lado, isso exigirá tempo de desenvolvimento adicional e, como nos testes de unidade, pode levar à especificação excessiva de comportamento. <br><br>  <b>Desatar testes de integração de sistemas externos.</b>  Um erro muito comum nos testes de integração é o uso de um banco de dados real, filas de mensagens e outros sistemas externos ao aplicativo.  Obviamente, a capacidade de executar um teste em um ambiente real é útil para depuração e desenvolvimento.  Tais testes em pequenas quantidades podem fazer sentido, especialmente para execução interativa.  No entanto, seu uso generalizado leva a vários problemas: <br><br><ol><li>  Para executar os testes, você precisará configurar o ambiente externo.  Por exemplo, instale um banco de dados em cada máquina em que o aplicativo será montado.  Isso dificultará a entrada de novos desenvolvedores no projeto e a configuração do IC. </li><li>  O estado dos sistemas externos pode variar em máquinas diferentes antes de executar os testes.  Por exemplo, o banco de dados já pode conter as tabelas que o aplicativo precisa com dados que não são esperados no teste.  Isso levará a falhas imprevisíveis nos testes e sua eliminação exigirá uma quantidade significativa de tempo. </li><li>  Se houver trabalho paralelo em vários projetos, é possível a influência não óbvia de alguns projetos em outros.  Por exemplo, configurações específicas do banco de dados feitas para um dos projetos podem ajudar a funcionalidade de outro projeto a funcionar corretamente, o que, no entanto, será interrompido quando iniciado em um banco de dados limpo em outra máquina. </li><li>  Os testes são realizados por um longo tempo: uma execução completa pode chegar a dezenas de minutos.  Isso leva ao fato de que os desenvolvedores param de executar testes localmente e analisam seus resultados somente após enviar as alterações para o repositório remoto.  Esse comportamento nega a maioria das vantagens dos testes, discutidos na primeira parte do artigo. </li></ol><br>  <b>Limpe o contexto entre testes de integração.</b>  Freqüentemente, para acelerar o trabalho de testes de integração, é necessário reutilizar o mesmo contexto entre eles.  Até a documentação oficial do Spring faz essa recomendação.  Ao mesmo tempo, a influência dos testes um no outro deve ser evitada.  Como são lançadas em uma ordem arbitrária, a presença de tais conexões pode levar a erros irreprodutíveis aleatórios.  Para impedir que isso aconteça, os testes não devem deixar para trás nenhuma alteração no contexto.  Por exemplo, ao usar um banco de dados, para isolamento, geralmente é suficiente reverter todas as transações confirmadas no teste.  Se não for possível evitar alterações no contexto, você poderá configurar sua recreação usando a anotação <code>@DirtiesContext</code> . <br><br> <b>  ,      .</b>         ,       - .    ,            .  ,   , —      ,           . <br><br> <b>      .</b>      ,    ,       . ,    ,       . <br><br> <b>   TDD (Test-Driven Development).</b> TDD    ,      ,     .  ,        ,     .   ,         ,        . <br><br><h2>   ,  ? </h2><br>              ,  : <br><br><ol><li>       (  )?             . </li><li>           ,      ( ,  CI)?    . </li><li>     ?                     . </li><li>     ?    .   ,      ,      . </li></ol><br>        ,      .     , , -   .   —           . <br><br><a name="Conclusion"></a><h2>  Conclusão </h2><br>       ,     .    -    ,    .  ,  -      .        —         ,      ,    -.      ,                 . <br><br> ,    ,        ,            ! <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   GitHub</a> <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Growing Object-Oriented Software, Guided by Tests</a> , Steve Freeman, Nat Pryce <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Art of Unit Testing</a> , Roy Osherove <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Test-driven Development: By Example</a> , Kent Beck <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Refactoring: Improving the Design of Existing Code</a> , Martin Fowler <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427603/">https://habr.com/ru/post/pt427603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427589/index.html">Escrevemos um bate-papo on-line no Websockets usando o Swoole</a></li>
<li><a href="../pt427591/index.html">Arquitetura como um fardo</a></li>
<li><a href="../pt427593/index.html">Magia de Comando Rápido em Vivaldi 2.1</a></li>
<li><a href="../pt427595/index.html">Tente Micronaut ou Darling, eu reduzi o quadro</a></li>
<li><a href="../pt427601/index.html">Caso 5 + 1 em que a especificação da API REST desempenha um grande papel</a></li>
<li><a href="../pt427605/index.html">Como a plataforma de crowdsourcing da Yandex ajuda a treinar drones e avaliar a qualidade do serviço</a></li>
<li><a href="../pt427607/index.html">Datacenter na Suíça: trabalhar como um relógio</a></li>
<li><a href="../pt427609/index.html">Resolvendo a equação com divisão inteira sem força bruta</a></li>
<li><a href="../pt427611/index.html">A história de como eu atualizei o Yandex MapKit no iOS ou mapas, dinheiro, 2 mappits</a></li>
<li><a href="../pt427613/index.html">10 blogs úteis para programadores em inglês</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>