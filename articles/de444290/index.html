<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¢Ô∏è üë©üèø‚Äçü§ù‚Äçüë©üèΩ üåΩ Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 2. Bediener und Rohre üö¥üèæ üï° üë©üèø‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel haben wir uns angesehen, was Streams sind und womit sie essen. Im neuen Teil werden wir lernen, welche Methoden RxJS zum Ers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 2. Bediener und Rohre</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444290/"><img src="https://habrastorage.org/webt/rj/7g/bm/rj7gbmr84swtbidqadkbgh5bg3q.png"><br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel haben</a> wir uns angesehen, was Streams sind und womit sie essen.  Im neuen Teil werden wir lernen, welche Methoden RxJS zum Erstellen von Flows bereitstellt, was Operatoren, Pipes sind und wie mit ihnen gearbeitet wird. <br><br>  Artikelserie "Grundlagen der reaktiven Programmierung mit RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. Reaktivit√§t und Fl√ºsse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3. Observable h√∂herer Ordnung</a> </li></ul><br><br>  RxJS verf√ºgt √ºber eine umfangreiche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">API</a> .  Die Dokumentation beschreibt mehr als hundert Methoden.  Um sie ein wenig kennenzulernen, werden wir eine einfache Anwendung schreiben und in der Praxis sehen, wie der reaktive Code aussieht.  Sie werden sehen, dass dieselben Aufgaben, die fr√ºher routinem√§√üig erschienen und viel Code schreiben mussten, eine elegante L√∂sung haben, wenn Sie sie durch das Prisma der Reaktivit√§t betrachten.  Bevor wir jedoch mit der Praxis beginnen, werden wir uns ansehen, wie Flows grafisch dargestellt werden k√∂nnen, und uns mit praktischen Methoden zum Erstellen und Verarbeiten von Flows vertraut machen. <a name="habracut"></a><br><br><h4>  Grafische Darstellung von Threads </h4><br>  Um deutlich zu machen, wie sich ein bestimmter Fluss verh√§lt, verwende ich die im reaktiven Ansatz verwendete Notation.  Erinnern Sie sich an unser Beispiel aus dem vorherigen Artikel: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); });</code> </pre> <br>  So sieht die grafische Darstellung aus: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Die Str√∂mung wird normalerweise als gerade Linie dargestellt.  Wenn der Stream einen Wert ausgibt, wird er in der Zeile als Kreis angezeigt.  Eine gerade Linie im Display ist das Signal zum Beenden des Streams.  Verwenden Sie das Symbol ‚Äû√ó‚Äú, um den Fehler anzuzeigen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.error(); });</code> </pre><br><img src="https://habrastorage.org/webt/qo/7i/ut/qo7iutxhycufjmujmhhbvjzxz5w.png"><br><br><h4>  Eine Zeile wird gestreamt </h4><br>  In meiner Praxis musste ich selten meine eigenen Observable-Instanzen direkt erstellen.  Die meisten Methoden zum Erstellen von Threads befinden sich bereits in RxJS.  Um einen Stream mit den Werten 1 und 2 zu erstellen, reicht es aus, die of-Methode zu verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Die of-Methode akzeptiert eine beliebige Anzahl von Argumenten und gibt eine fertige Instanz des Observable zur√ºck.  Nach dem Abonnieren werden die empfangenen Werte ausgegeben und Folgendes ausgef√ºhrt: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Wenn Sie das Array als Stream darstellen m√∂chten, k√∂nnen Sie die from-Methode verwenden.  Die from-Methode als Argument erwartet jedes iterierbare Objekt (Array, String usw.) oder Versprechen und projiziert dieses Objekt auf den Stream.  So sieht der aus der Zeichenfolge erhaltene Stream aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/y7/ky/nd/y7kynd1a6oolkik-adnjnriav6e.png"><br><br>  Und so k√∂nnen Sie ein Versprechen in einen Stream einwickeln: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(promise);</code> </pre><br><img src="https://habrastorage.org/webt/rc/us/sr/rcussrgfjolqzykg9ao3lkj_aj4.png"><br><br>  <b>Hinweis:</b> Oft werden Threads mit Versprechen verglichen.  Tats√§chlich haben sie nur eines gemeinsam - eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Push-Strategie zur</a> Verbreitung von Ver√§nderungen.  Der Rest sind v√∂llig andere Einheiten.  Versprechen kann nicht mehrere Werte erzeugen.  Es kann nur Aufl√∂sung oder Zur√ºckweisung ausf√ºhren, d. H.  habe nur zwei Zust√§nde.  Ein Stream kann mehrere Werte √ºbertragen und wiederverwendet werden. <br><br>  Erinnerst du dich an das Beispiel mit dem Intervall vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> ?  Dieser Stream ist ein Timer, der die Zeit in Sekunden ab dem Zeitpunkt des Abonnements z√§hlt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  So k√∂nnen Sie dasselbe in einer Zeile implementieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/yd/ju/ks/ydjuksn4esnkrup6euizzcnqwm8.png"><br><br>  Und schlie√ülich eine Methode, mit der Sie einen Ereignisstrom f√ºr DOM-Elemente erstellen k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = fromEvent(domElementRef, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);</code> </pre><br>  Als Werte empf√§ngt und sendet dieser Stream Keyup-Ereignisobjekte. <br><br><h4>  Rohre &amp; Bediener </h4><br>  Pipe ist eine Observable-Klassenmethode, die in RxJS in Version 5.5 hinzugef√ºgt wurde.  Dank dessen k√∂nnen wir Operatorketten f√ºr die sequentielle Verarbeitung der im Stream empfangenen Werte erstellen.  Pipe ist ein unidirektionaler Kanal, der die Bediener miteinander verbindet.  Die Operatoren selbst sind normale Funktionen, die in RxJS beschrieben sind und Werte aus einem Stream verarbeiten. <br><br>  Sie k√∂nnen beispielsweise den Wert konvertieren und weiter an den Stream √ºbergeben, oder sie k√∂nnen als Filter fungieren und keine Werte √ºberspringen, wenn sie die angegebene Bedingung nicht erf√ºllen. <br><br>  Schauen wir uns die Operatoren in Aktion an.  Multiplizieren Sie jeden Wert aus dem Stream mit 2 mit dem Kartenoperator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value * <span class="hljs-number"><span class="hljs-number">2</span></span>) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  So sieht der Stream aus, bevor Sie den Kartenoperator anwenden: <br><br><img src="https://habrastorage.org/webt/ns/a_/fh/nsa_fhvt6qqz_yktb4yl4jgac-k.png"><br><br>  Nach der Map-Anweisung: <br><br><img src="https://habrastorage.org/webt/5_/vt/ku/5_vtku2aaynipw8jt4gae9iotlc.png"><br><br>  Verwenden wir den Filteroperator.  Diese Anweisung funktioniert genau wie die Filterfunktion in der Array-Klasse.  Die Methode verwendet eine Funktion als erstes Argument, das eine Bedingung beschreibt.  Wenn der Wert aus dem Stream die Bedingung erf√ºllt, wird er weitergegeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( <span class="hljs-comment"><span class="hljs-comment">//     filter(value =&gt; value % 2 !== 0), map(value = value * 2) ).subscribe({ next: console.log });</span></span></code> </pre><br>  Und so wird das gesamte Schema unseres Streams aussehen: <br><br><img src="https://habrastorage.org/webt/ke/ne/wm/kenewmpioakcrwofit2b2x2k-je.png"><br><br>  Nach dem Filter: <br><br><img src="https://habrastorage.org/webt/l1/xr/z1/l1xrz1kaxs96xuz7t35k_6safny.png"><br><br>  Nach Karte: <br><br><img src="https://habrastorage.org/webt/uv/za/va/uvzavasqypswdfiqk51esahuu0g.png"><br><br>  <b>Hinweis:</b> pipe! == abonnieren.  Die Pipe-Methode deklariert das Flie√üverhalten, abonniert jedoch nicht.  Bis Sie die Subscribe-Methode aufrufen, funktioniert Ihr Stream nicht. <br><br><h4>  Wir schreiben eine Bewerbung </h4><br>  Nachdem wir herausgefunden haben, was Rohrleitungen und Bediener sind, k√∂nnen Sie mit dem √úben beginnen.  Unsere Anwendung f√ºhrt eine einfache Aufgabe aus: Anzeigen einer Liste offener Github-Repositorys anhand des eingegebenen Spitznamens des Besitzers. <br><br>  Es wird nur wenige Anforderungen geben: <br><br><ul><li>  F√ºhren Sie keine API-Anforderung aus, wenn die in die Eingabe eingegebene Zeichenfolge weniger als 3 Zeichen enth√§lt. </li><li>  Um die Anforderung f√ºr jedes vom Benutzer eingegebene Zeichen nicht zu erf√ºllen, muss vor dem Zugriff auf die API eine Verz√∂gerung (Entprellen) von 700 Millisekunden festgelegt werden. </li></ul><br>  Um nach Repositorys zu suchen, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Github-API</a> .  Ich empfehle, die Beispiele selbst auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">stackblitz auszuf√ºhren</a> .  Dort habe ich die fertige Implementierung angelegt.  Links finden Sie am Ende des Artikels. <br><br>  Beginnen wir mit dem HTML-Markup.  Beschreiben wir die Eingabe- und ul-Elemente: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In der Datei js oder ts erhalten wir dann mithilfe der Browser-API Links zu den aktuellen Elementen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>);</code> </pre><br>  Wir ben√∂tigen auch eine Methode, die eine Anforderung an die Github-API ausf√ºhrt.  Unten finden Sie den Code f√ºr die Funktion getUsersRepsFromAPI, die den Spitznamen des Benutzers akzeptiert und eine Ajax-Anforderung mithilfe von fetch ausf√ºhrt.  Dann gibt es ein Versprechen zur√ºck und wandelt die erfolgreiche Antwort auf dem Weg in json um: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(response.ok) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>); }); }</code> </pre><br>  Als n√§chstes schreiben wir eine Methode, die die Namen der Repositorys auflistet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> recordRepsToList = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reps.length; i++) { <span class="hljs-comment"><span class="hljs-comment">//    ,    if (!ul.children[i]) { const newEl = document.createElement('li'); ul.appendChild(newEl); } //      const li = ul.children[i]; li.innerHTML = reps[i].name; } //    while (ul.children.length &gt; reps.length) { ul.removeChild(ul.lastChild); } }</span></span></code> </pre><br>  Die Vorbereitungen sind abgeschlossen.  Es ist Zeit, einen Blick auf RxJS in Aktion zu werfen.  Wir m√ºssen uns das Keyup-Ereignis unserer Eingabe anh√∂ren.  Zun√§chst m√ºssen wir verstehen, dass wir in einem reaktiven Ansatz mit Fl√ºssen arbeiten.  Gl√ºcklicherweise bietet RxJS bereits eine √§hnliche Option.  Denken Sie an die oben erw√§hnte fromEvent-Methode.  Wir benutzen es: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyUp = fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>); keyUp.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Jetzt wird unsere Veranstaltung als Stream pr√§sentiert.  Wenn wir uns ansehen, was in der Konsole angezeigt wird, sehen wir ein Objekt vom Typ KeyboardEvent.  Wir ben√∂tigen jedoch einen vom Benutzer eingegebenen Wert.  Hier bieten sich die Pipe-Methode und der Kartenoperator an: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Wir fahren mit der Umsetzung der Anforderungen fort.  Zun√§chst f√ºhren wir die Abfrage aus, wenn der eingegebene Wert mehr als zwei Zeichen enth√§lt.  Verwenden Sie dazu den Filteroperator: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Wir haben uns mit der ersten Anforderung befasst.  Wir fahren mit dem zweiten fort.  Wir m√ºssen Debounce implementieren.  RxJS hat eine debounceTime-Anweisung.  Dieser Operator nimmt als erstes Argument die Anzahl der Millisekunden an, in denen der Wert vor der Weitergabe gehalten wird.  In diesem Fall setzt jeder neue Wert den Timer zur√ºck.  Somit erhalten wir am Ausgang den letzten Wert, nach dem 700 Millisekunden vergangen sind. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  So k√∂nnte unser Stream ohne debounceTime aussehen: <br><br><img src="https://habrastorage.org/webt/c4/tl/lc/c4tllccvfohixydheaohwj2wcvy.png"><br><br>  Und so sieht derselbe Stream aus, der durch diese Anweisung geleitet wird: <br><br><img src="https://habrastorage.org/webt/o0/lg/lx/o0lglx4knoa6ulhkaafuvxyhl1o.png"><br><br>  Mit debounceTime wird die API mit geringerer Wahrscheinlichkeit verwendet, wodurch Datenverkehr gespart und der Server entlastet wird. <br><br>  F√ºr zus√§tzliche Optimierung schlage ich vor, einen anderen Operator zu verwenden - uniqueUntilChanged.  Diese Methode sch√ºtzt uns vor Duplikaten.  Es ist am besten, seine Arbeit anhand eines Beispiels zu zeigen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'aaabccc'</span></span>).pipe( distinctUntilChanged() )</code> </pre><br>  Ohne eindeutigeUntilChanged: <br><br><img src="https://habrastorage.org/webt/ti/ng/7j/ting7jpkqbe1bgfb713x5wleaki.png"><br><br>  Mit uniqueUntilChanged: <br><br><img src="https://habrastorage.org/webt/kv/is/-1/kvis-1lx1hwylsyg4dfvuf4tgoa.png"><br><br>  F√ºgen Sie diese Anweisung unmittelbar nach der debounceTime-Anweisung hinzu.  Daher werden wir nicht auf die API zugreifen, wenn der neue Wert aus irgendeinem Grund mit dem vorherigen √ºbereinstimmt.  Eine √§hnliche Situation kann auftreten, wenn der Benutzer neue Zeichen eingegeben und diese dann wieder gel√∂scht hat.  Da wir eine Verz√∂gerung implementiert haben, f√§llt nur der letzte Wert in den Stream, auf den wir bereits eine Antwort haben. <br><br><h4>  Gehen Sie zum Server </h4><br>  Bereits jetzt k√∂nnen wir die Logik der Anfrage und die Verarbeitung der Antwort beschreiben.  Wir k√∂nnen zwar nur mit Versprechen arbeiten.  Daher beschreiben wir einen anderen Kartenoperator, der die Methode getUsersRepsFromAPI aufruft.  Im Beobachter beschreiben wir die Verarbeitungslogik unseres Versprechens: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  !     RxJS    promise,      */</span></span> fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> getUsersRepsFromAPI(value)) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function"> =&gt;</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps)) });</code> </pre><br>  Im Moment haben wir alles umgesetzt, was wir wollten.  Unser Beispiel hat jedoch einen gro√üen Nachteil: Es gibt keine Fehlerbehandlung.  Unser Beobachter erh√§lt nur ein Versprechen und hat keine Ahnung, dass etwas schief gehen k√∂nnte. <br><br>  Nat√ºrlich k√∂nnen wir bei der n√§chsten Methode das Versprechen einhalten, aber aus diesem Grund wird unser Code immer mehr einer ‚ÄûR√ºckruf-H√∂lle‚Äú √§hneln.  Wenn wir pl√∂tzlich eine weitere Anforderung ausf√ºhren m√ºssen, erh√∂ht sich die Komplexit√§t des Codes. <br><br>  <b>Hinweis: Die</b> Verwendung von Versprechen im RxJS-Code wird als Antipattern betrachtet.  Versprechen hat viele Nachteile gegen√ºber beobachtbar.  Es kann nicht r√ºckg√§ngig gemacht und nicht wiederverwendet werden.  Wenn Sie eine Wahl haben, w√§hlen Sie beobachtbar.  Gleiches gilt f√ºr die toPromise-Methode der Observable-Klasse.  Diese Methode wurde aus Gr√ºnden der Kompatibilit√§t mit Bibliotheken implementiert, die nicht mit Streams arbeiten k√∂nnen. <br><br>  Wir k√∂nnen die from-Methode verwenden, um ein Versprechen auf einen Stream zu projizieren. Diese Methode ist jedoch mit zus√§tzlichen Aufrufen der subscribe-Methode behaftet und f√ºhrt auch zu Wachstum und Komplexit√§t des Codes. <br><br>  Dieses Problem kann mit dem Operator mergeMap gel√∂st werden: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Jetzt m√ºssen wir keine Versprechen-Verarbeitungslogik schreiben.  Die from-Methode hat einen Versprechen-Stream erstellt und vom mergeMap-Operator verarbeitet.  Wenn das Versprechen erfolgreich erf√ºllt wird, wird die n√§chste Methode aufgerufen und unser Beobachter erh√§lt das fertige Objekt.  Wenn ein Fehler auftritt, wird die Fehlermethode aufgerufen und unser Beobachter gibt einen Fehler in der Konsole aus. <br><br>  Der mergeMap-Operator unterscheidet sich geringf√ºgig von den Operatoren, mit denen wir zuvor gearbeitet haben. Er geh√∂rt zu den sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Observables h√∂herer Ordnung</a> , auf die ich im n√§chsten Artikel eingehen werde.  Mit Blick auf die Zukunft werde ich jedoch sagen, dass die mergeMap-Methode selbst den Stream abonniert. <br><br><h4>  Fehlerbehandlung </h4><br>  Wenn unser Thread einen Fehler empf√§ngt, wird er beendet.  Und wenn wir versuchen, nach einem Fehler mit der Anwendung zu interagieren, erhalten wir keine Reaktion, da unser Thread abgeschlossen ist. <br><br>  Hier hilft uns der Operator catchError.  catchError wird nur ausgel√∂st, wenn im Stream ein Fehler auftritt.  Sie k√∂nnen es abfangen, verarbeiten und den √ºblichen Wert an den Stream zur√ºckgeben, was nicht zu seiner Fertigstellung f√ºhrt. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Wir fangen den Fehler in catchError ab und geben stattdessen einen Stream mit einem leeren Array zur√ºck.  Wenn nun ein Fehler auftritt, l√∂schen wir die Liste der Repositorys.  Aber dann endet der Fluss wieder. <br><br>  Die Sache ist, dass catchError unseren urspr√ºnglichen Stream durch einen neuen ersetzt.  Und dann h√∂rt unser Beobachter nur auf ihn.  Wenn der of-Stream ein leeres Array ausgibt, wird die vollst√§ndige Methode aufgerufen. <br><br>  Um unseren urspr√ºnglichen Thread nicht zu ersetzen, rufen wir den catchError-Operator f√ºr den from-Thread innerhalb des mergeMap-Operators auf. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Somit wird unser urspr√ºnglicher Stream nichts bemerken.  Anstelle eines Fehlers wird ein leeres Array angezeigt. <br><br><h4>  Fazit </h4><br>  Wir haben endlich angefangen zu √ºben und haben gesehen, wof√ºr Rohrleitungen und Bediener sind.  Wir haben uns angesehen, wie Sie mithilfe der von RxJS bereitgestellten Rich-API Code reduzieren k√∂nnen.  Nat√ºrlich ist unsere Bewerbung noch nicht fertig. Im n√§chsten Teil werden wir analysieren, wie es m√∂glich ist, eine andere in einem Thread zu verarbeiten und unsere http-Anfrage abzubrechen, um noch mehr Verkehr und Ressourcen unserer Bewerbung zu sparen.  Und damit Sie den Unterschied sehen k√∂nnen, habe ich ein Beispiel ohne Verwendung von RxJS erstellt. Sie k√∂nnen es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier sehen</a> .  Unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">diesem Link</a> finden Sie den vollst√§ndigen Code der aktuellen Anwendung.  Um die Schaltungen zu erzeugen, habe ich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RxJS-Visualizer verwendet</a> . <br><br>  Ich hoffe, dieser Artikel hat Ihnen geholfen, besser zu verstehen, wie RxJS funktioniert.  Ich w√ºnsche Ihnen viel Erfolg beim Studium! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444290/">https://habr.com/ru/post/de444290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444278/index.html">So bringen Sie Zehntausende dazu, Ihren englischsprachigen Artikel f√ºr Habr zu lesen: 3 einfache Tipps</a></li>
<li><a href="../de444282/index.html">7 Chrome-Erweiterungen zum Englischlernen</a></li>
<li><a href="../de444284/index.html">Vervollst√§ndigung von Komponisten und Befehlszeilen</a></li>
<li><a href="../de444286/index.html">PTZ-Kamera-Analyse: Was ist drin und wie funktioniert es?</a></li>
<li><a href="../de444288/index.html">Neue mobile Anwendung LampTest.ru</a></li>
<li><a href="../de444294/index.html">Wie die Gesch√§ftsluftfahrt in Russland funktioniert (FBO-Zentren)</a></li>
<li><a href="../de444296/index.html">6 n√ºtzliche Ressourcen und Dienstleistungen f√ºr potenzielle Auswanderer in die USA, nach Deutschland und Kanada</a></li>
<li><a href="../de444298/index.html">Wissenschaftler sagen, dass sie lebende Dinosaurier f√ºr 5 Jahre umgestalten k√∂nnen</a></li>
<li><a href="../de444300/index.html">Die Entwicklung der Architektur des Handels- und Clearingsystems der Moskauer B√∂rse. Teil 1</a></li>
<li><a href="../de444302/index.html">Die Entwicklung der Architektur des Handels- und Clearingsystems der Moskauer B√∂rse. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>