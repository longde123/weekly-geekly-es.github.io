<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛢️ 👩🏿‍🤝‍👩🏽 🌽 Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 2. Bediener und Rohre 🚴🏾 🕡 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel haben wir uns angesehen, was Streams sind und womit sie essen. Im neuen Teil werden wir lernen, welche Methoden RxJS zum Ers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 2. Bediener und Rohre</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444290/"><img src="https://habrastorage.org/webt/rj/7g/bm/rj7gbmr84swtbidqadkbgh5bg3q.png"><br><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel haben</a> wir uns angesehen, was Streams sind und womit sie essen.  Im neuen Teil werden wir lernen, welche Methoden RxJS zum Erstellen von Flows bereitstellt, was Operatoren, Pipes sind und wie mit ihnen gearbeitet wird. <br><br>  Artikelserie "Grundlagen der reaktiven Programmierung mit RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. Reaktivität und Flüsse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3. Observable höherer Ordnung</a> </li></ul><br><br>  RxJS verfügt über eine umfangreiche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">API</a> .  Die Dokumentation beschreibt mehr als hundert Methoden.  Um sie ein wenig kennenzulernen, werden wir eine einfache Anwendung schreiben und in der Praxis sehen, wie der reaktive Code aussieht.  Sie werden sehen, dass dieselben Aufgaben, die früher routinemäßig erschienen und viel Code schreiben mussten, eine elegante Lösung haben, wenn Sie sie durch das Prisma der Reaktivität betrachten.  Bevor wir jedoch mit der Praxis beginnen, werden wir uns ansehen, wie Flows grafisch dargestellt werden können, und uns mit praktischen Methoden zum Erstellen und Verarbeiten von Flows vertraut machen. <a name="habracut"></a><br><br><h4>  Grafische Darstellung von Threads </h4><br>  Um deutlich zu machen, wie sich ein bestimmter Fluss verhält, verwende ich die im reaktiven Ansatz verwendete Notation.  Erinnern Sie sich an unser Beispiel aus dem vorherigen Artikel: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); });</code> </pre> <br>  So sieht die grafische Darstellung aus: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Die Strömung wird normalerweise als gerade Linie dargestellt.  Wenn der Stream einen Wert ausgibt, wird er in der Zeile als Kreis angezeigt.  Eine gerade Linie im Display ist das Signal zum Beenden des Streams.  Verwenden Sie das Symbol „×“, um den Fehler anzuzeigen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.error(); });</code> </pre><br><img src="https://habrastorage.org/webt/qo/7i/ut/qo7iutxhycufjmujmhhbvjzxz5w.png"><br><br><h4>  Eine Zeile wird gestreamt </h4><br>  In meiner Praxis musste ich selten meine eigenen Observable-Instanzen direkt erstellen.  Die meisten Methoden zum Erstellen von Threads befinden sich bereits in RxJS.  Um einen Stream mit den Werten 1 und 2 zu erstellen, reicht es aus, die of-Methode zu verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Die of-Methode akzeptiert eine beliebige Anzahl von Argumenten und gibt eine fertige Instanz des Observable zurück.  Nach dem Abonnieren werden die empfangenen Werte ausgegeben und Folgendes ausgeführt: <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br>  Wenn Sie das Array als Stream darstellen möchten, können Sie die from-Methode verwenden.  Die from-Methode als Argument erwartet jedes iterierbare Objekt (Array, String usw.) oder Versprechen und projiziert dieses Objekt auf den Stream.  So sieht der aus der Zeichenfolge erhaltene Stream aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/y7/ky/nd/y7kynd1a6oolkik-adnjnriav6e.png"><br><br>  Und so können Sie ein Versprechen in einen Stream einwickeln: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(promise);</code> </pre><br><img src="https://habrastorage.org/webt/rc/us/sr/rcussrgfjolqzykg9ao3lkj_aj4.png"><br><br>  <b>Hinweis:</b> Oft werden Threads mit Versprechen verglichen.  Tatsächlich haben sie nur eines gemeinsam - eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Push-Strategie zur</a> Verbreitung von Veränderungen.  Der Rest sind völlig andere Einheiten.  Versprechen kann nicht mehrere Werte erzeugen.  Es kann nur Auflösung oder Zurückweisung ausführen, d. H.  habe nur zwei Zustände.  Ein Stream kann mehrere Werte übertragen und wiederverwendet werden. <br><br>  Erinnerst du dich an das Beispiel mit dem Intervall vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> ?  Dieser Stream ist ein Timer, der die Zeit in Sekunden ab dem Zeitpunkt des Abonnements zählt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  So können Sie dasselbe in einer Zeile implementieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/yd/ju/ks/ydjuksn4esnkrup6euizzcnqwm8.png"><br><br>  Und schließlich eine Methode, mit der Sie einen Ereignisstrom für DOM-Elemente erstellen können: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = fromEvent(domElementRef, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);</code> </pre><br>  Als Werte empfängt und sendet dieser Stream Keyup-Ereignisobjekte. <br><br><h4>  Rohre &amp; Bediener </h4><br>  Pipe ist eine Observable-Klassenmethode, die in RxJS in Version 5.5 hinzugefügt wurde.  Dank dessen können wir Operatorketten für die sequentielle Verarbeitung der im Stream empfangenen Werte erstellen.  Pipe ist ein unidirektionaler Kanal, der die Bediener miteinander verbindet.  Die Operatoren selbst sind normale Funktionen, die in RxJS beschrieben sind und Werte aus einem Stream verarbeiten. <br><br>  Sie können beispielsweise den Wert konvertieren und weiter an den Stream übergeben, oder sie können als Filter fungieren und keine Werte überspringen, wenn sie die angegebene Bedingung nicht erfüllen. <br><br>  Schauen wir uns die Operatoren in Aktion an.  Multiplizieren Sie jeden Wert aus dem Stream mit 2 mit dem Kartenoperator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value * <span class="hljs-number"><span class="hljs-number">2</span></span>) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  So sieht der Stream aus, bevor Sie den Kartenoperator anwenden: <br><br><img src="https://habrastorage.org/webt/ns/a_/fh/nsa_fhvt6qqz_yktb4yl4jgac-k.png"><br><br>  Nach der Map-Anweisung: <br><br><img src="https://habrastorage.org/webt/5_/vt/ku/5_vtku2aaynipw8jt4gae9iotlc.png"><br><br>  Verwenden wir den Filteroperator.  Diese Anweisung funktioniert genau wie die Filterfunktion in der Array-Klasse.  Die Methode verwendet eine Funktion als erstes Argument, das eine Bedingung beschreibt.  Wenn der Wert aus dem Stream die Bedingung erfüllt, wird er weitergegeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( <span class="hljs-comment"><span class="hljs-comment">//     filter(value =&gt; value % 2 !== 0), map(value = value * 2) ).subscribe({ next: console.log });</span></span></code> </pre><br>  Und so wird das gesamte Schema unseres Streams aussehen: <br><br><img src="https://habrastorage.org/webt/ke/ne/wm/kenewmpioakcrwofit2b2x2k-je.png"><br><br>  Nach dem Filter: <br><br><img src="https://habrastorage.org/webt/l1/xr/z1/l1xrz1kaxs96xuz7t35k_6safny.png"><br><br>  Nach Karte: <br><br><img src="https://habrastorage.org/webt/uv/za/va/uvzavasqypswdfiqk51esahuu0g.png"><br><br>  <b>Hinweis:</b> pipe! == abonnieren.  Die Pipe-Methode deklariert das Fließverhalten, abonniert jedoch nicht.  Bis Sie die Subscribe-Methode aufrufen, funktioniert Ihr Stream nicht. <br><br><h4>  Wir schreiben eine Bewerbung </h4><br>  Nachdem wir herausgefunden haben, was Rohrleitungen und Bediener sind, können Sie mit dem Üben beginnen.  Unsere Anwendung führt eine einfache Aufgabe aus: Anzeigen einer Liste offener Github-Repositorys anhand des eingegebenen Spitznamens des Besitzers. <br><br>  Es wird nur wenige Anforderungen geben: <br><br><ul><li>  Führen Sie keine API-Anforderung aus, wenn die in die Eingabe eingegebene Zeichenfolge weniger als 3 Zeichen enthält. </li><li>  Um die Anforderung für jedes vom Benutzer eingegebene Zeichen nicht zu erfüllen, muss vor dem Zugriff auf die API eine Verzögerung (Entprellen) von 700 Millisekunden festgelegt werden. </li></ul><br>  Um nach Repositorys zu suchen, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Github-API</a> .  Ich empfehle, die Beispiele selbst auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">stackblitz auszuführen</a> .  Dort habe ich die fertige Implementierung angelegt.  Links finden Sie am Ende des Artikels. <br><br>  Beginnen wir mit dem HTML-Markup.  Beschreiben wir die Eingabe- und ul-Elemente: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In der Datei js oder ts erhalten wir dann mithilfe der Browser-API Links zu den aktuellen Elementen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>);</code> </pre><br>  Wir benötigen auch eine Methode, die eine Anforderung an die Github-API ausführt.  Unten finden Sie den Code für die Funktion getUsersRepsFromAPI, die den Spitznamen des Benutzers akzeptiert und eine Ajax-Anforderung mithilfe von fetch ausführt.  Dann gibt es ein Versprechen zurück und wandelt die erfolgreiche Antwort auf dem Weg in json um: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(response.ok) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>); }); }</code> </pre><br>  Als nächstes schreiben wir eine Methode, die die Namen der Repositorys auflistet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> recordRepsToList = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reps.length; i++) { <span class="hljs-comment"><span class="hljs-comment">//    ,    if (!ul.children[i]) { const newEl = document.createElement('li'); ul.appendChild(newEl); } //      const li = ul.children[i]; li.innerHTML = reps[i].name; } //    while (ul.children.length &gt; reps.length) { ul.removeChild(ul.lastChild); } }</span></span></code> </pre><br>  Die Vorbereitungen sind abgeschlossen.  Es ist Zeit, einen Blick auf RxJS in Aktion zu werfen.  Wir müssen uns das Keyup-Ereignis unserer Eingabe anhören.  Zunächst müssen wir verstehen, dass wir in einem reaktiven Ansatz mit Flüssen arbeiten.  Glücklicherweise bietet RxJS bereits eine ähnliche Option.  Denken Sie an die oben erwähnte fromEvent-Methode.  Wir benutzen es: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyUp = fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>); keyUp.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Jetzt wird unsere Veranstaltung als Stream präsentiert.  Wenn wir uns ansehen, was in der Konsole angezeigt wird, sehen wir ein Objekt vom Typ KeyboardEvent.  Wir benötigen jedoch einen vom Benutzer eingegebenen Wert.  Hier bieten sich die Pipe-Methode und der Kartenoperator an: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Wir fahren mit der Umsetzung der Anforderungen fort.  Zunächst führen wir die Abfrage aus, wenn der eingegebene Wert mehr als zwei Zeichen enthält.  Verwenden Sie dazu den Filteroperator: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  Wir haben uns mit der ersten Anforderung befasst.  Wir fahren mit dem zweiten fort.  Wir müssen Debounce implementieren.  RxJS hat eine debounceTime-Anweisung.  Dieser Operator nimmt als erstes Argument die Anzahl der Millisekunden an, in denen der Wert vor der Weitergabe gehalten wird.  In diesem Fall setzt jeder neue Wert den Timer zurück.  Somit erhalten wir am Ausgang den letzten Wert, nach dem 700 Millisekunden vergangen sind. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br>  So könnte unser Stream ohne debounceTime aussehen: <br><br><img src="https://habrastorage.org/webt/c4/tl/lc/c4tllccvfohixydheaohwj2wcvy.png"><br><br>  Und so sieht derselbe Stream aus, der durch diese Anweisung geleitet wird: <br><br><img src="https://habrastorage.org/webt/o0/lg/lx/o0lglx4knoa6ulhkaafuvxyhl1o.png"><br><br>  Mit debounceTime wird die API mit geringerer Wahrscheinlichkeit verwendet, wodurch Datenverkehr gespart und der Server entlastet wird. <br><br>  Für zusätzliche Optimierung schlage ich vor, einen anderen Operator zu verwenden - uniqueUntilChanged.  Diese Methode schützt uns vor Duplikaten.  Es ist am besten, seine Arbeit anhand eines Beispiels zu zeigen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'aaabccc'</span></span>).pipe( distinctUntilChanged() )</code> </pre><br>  Ohne eindeutigeUntilChanged: <br><br><img src="https://habrastorage.org/webt/ti/ng/7j/ting7jpkqbe1bgfb713x5wleaki.png"><br><br>  Mit uniqueUntilChanged: <br><br><img src="https://habrastorage.org/webt/kv/is/-1/kvis-1lx1hwylsyg4dfvuf4tgoa.png"><br><br>  Fügen Sie diese Anweisung unmittelbar nach der debounceTime-Anweisung hinzu.  Daher werden wir nicht auf die API zugreifen, wenn der neue Wert aus irgendeinem Grund mit dem vorherigen übereinstimmt.  Eine ähnliche Situation kann auftreten, wenn der Benutzer neue Zeichen eingegeben und diese dann wieder gelöscht hat.  Da wir eine Verzögerung implementiert haben, fällt nur der letzte Wert in den Stream, auf den wir bereits eine Antwort haben. <br><br><h4>  Gehen Sie zum Server </h4><br>  Bereits jetzt können wir die Logik der Anfrage und die Verarbeitung der Antwort beschreiben.  Wir können zwar nur mit Versprechen arbeiten.  Daher beschreiben wir einen anderen Kartenoperator, der die Methode getUsersRepsFromAPI aufruft.  Im Beobachter beschreiben wir die Verarbeitungslogik unseres Versprechens: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  !     RxJS    promise,      */</span></span> fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> getUsersRepsFromAPI(value)) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function"> =&gt;</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps)) });</code> </pre><br>  Im Moment haben wir alles umgesetzt, was wir wollten.  Unser Beispiel hat jedoch einen großen Nachteil: Es gibt keine Fehlerbehandlung.  Unser Beobachter erhält nur ein Versprechen und hat keine Ahnung, dass etwas schief gehen könnte. <br><br>  Natürlich können wir bei der nächsten Methode das Versprechen einhalten, aber aus diesem Grund wird unser Code immer mehr einer „Rückruf-Hölle“ ähneln.  Wenn wir plötzlich eine weitere Anforderung ausführen müssen, erhöht sich die Komplexität des Codes. <br><br>  <b>Hinweis: Die</b> Verwendung von Versprechen im RxJS-Code wird als Antipattern betrachtet.  Versprechen hat viele Nachteile gegenüber beobachtbar.  Es kann nicht rückgängig gemacht und nicht wiederverwendet werden.  Wenn Sie eine Wahl haben, wählen Sie beobachtbar.  Gleiches gilt für die toPromise-Methode der Observable-Klasse.  Diese Methode wurde aus Gründen der Kompatibilität mit Bibliotheken implementiert, die nicht mit Streams arbeiten können. <br><br>  Wir können die from-Methode verwenden, um ein Versprechen auf einen Stream zu projizieren. Diese Methode ist jedoch mit zusätzlichen Aufrufen der subscribe-Methode behaftet und führt auch zu Wachstum und Komplexität des Codes. <br><br>  Dieses Problem kann mit dem Operator mergeMap gelöst werden: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Jetzt müssen wir keine Versprechen-Verarbeitungslogik schreiben.  Die from-Methode hat einen Versprechen-Stream erstellt und vom mergeMap-Operator verarbeitet.  Wenn das Versprechen erfolgreich erfüllt wird, wird die nächste Methode aufgerufen und unser Beobachter erhält das fertige Objekt.  Wenn ein Fehler auftritt, wird die Fehlermethode aufgerufen und unser Beobachter gibt einen Fehler in der Konsole aus. <br><br>  Der mergeMap-Operator unterscheidet sich geringfügig von den Operatoren, mit denen wir zuvor gearbeitet haben. Er gehört zu den sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Observables höherer Ordnung</a> , auf die ich im nächsten Artikel eingehen werde.  Mit Blick auf die Zukunft werde ich jedoch sagen, dass die mergeMap-Methode selbst den Stream abonniert. <br><br><h4>  Fehlerbehandlung </h4><br>  Wenn unser Thread einen Fehler empfängt, wird er beendet.  Und wenn wir versuchen, nach einem Fehler mit der Anwendung zu interagieren, erhalten wir keine Reaktion, da unser Thread abgeschlossen ist. <br><br>  Hier hilft uns der Operator catchError.  catchError wird nur ausgelöst, wenn im Stream ein Fehler auftritt.  Sie können es abfangen, verarbeiten und den üblichen Wert an den Stream zurückgeben, was nicht zu seiner Fertigstellung führt. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Wir fangen den Fehler in catchError ab und geben stattdessen einen Stream mit einem leeren Array zurück.  Wenn nun ein Fehler auftritt, löschen wir die Liste der Repositorys.  Aber dann endet der Fluss wieder. <br><br>  Die Sache ist, dass catchError unseren ursprünglichen Stream durch einen neuen ersetzt.  Und dann hört unser Beobachter nur auf ihn.  Wenn der of-Stream ein leeres Array ausgibt, wird die vollständige Methode aufgerufen. <br><br>  Um unseren ursprünglichen Thread nicht zu ersetzen, rufen wir den catchError-Operator für den from-Thread innerhalb des mergeMap-Operators auf. <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br>  Somit wird unser ursprünglicher Stream nichts bemerken.  Anstelle eines Fehlers wird ein leeres Array angezeigt. <br><br><h4>  Fazit </h4><br>  Wir haben endlich angefangen zu üben und haben gesehen, wofür Rohrleitungen und Bediener sind.  Wir haben uns angesehen, wie Sie mithilfe der von RxJS bereitgestellten Rich-API Code reduzieren können.  Natürlich ist unsere Bewerbung noch nicht fertig. Im nächsten Teil werden wir analysieren, wie es möglich ist, eine andere in einem Thread zu verarbeiten und unsere http-Anfrage abzubrechen, um noch mehr Verkehr und Ressourcen unserer Bewerbung zu sparen.  Und damit Sie den Unterschied sehen können, habe ich ein Beispiel ohne Verwendung von RxJS erstellt. Sie können es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier sehen</a> .  Unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">diesem Link</a> finden Sie den vollständigen Code der aktuellen Anwendung.  Um die Schaltungen zu erzeugen, habe ich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RxJS-Visualizer verwendet</a> . <br><br>  Ich hoffe, dieser Artikel hat Ihnen geholfen, besser zu verstehen, wie RxJS funktioniert.  Ich wünsche Ihnen viel Erfolg beim Studium! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444290/">https://habr.com/ru/post/de444290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444278/index.html">So bringen Sie Zehntausende dazu, Ihren englischsprachigen Artikel für Habr zu lesen: 3 einfache Tipps</a></li>
<li><a href="../de444282/index.html">7 Chrome-Erweiterungen zum Englischlernen</a></li>
<li><a href="../de444284/index.html">Vervollständigung von Komponisten und Befehlszeilen</a></li>
<li><a href="../de444286/index.html">PTZ-Kamera-Analyse: Was ist drin und wie funktioniert es?</a></li>
<li><a href="../de444288/index.html">Neue mobile Anwendung LampTest.ru</a></li>
<li><a href="../de444294/index.html">Wie die Geschäftsluftfahrt in Russland funktioniert (FBO-Zentren)</a></li>
<li><a href="../de444296/index.html">6 nützliche Ressourcen und Dienstleistungen für potenzielle Auswanderer in die USA, nach Deutschland und Kanada</a></li>
<li><a href="../de444298/index.html">Wissenschaftler sagen, dass sie lebende Dinosaurier für 5 Jahre umgestalten können</a></li>
<li><a href="../de444300/index.html">Die Entwicklung der Architektur des Handels- und Clearingsystems der Moskauer Börse. Teil 1</a></li>
<li><a href="../de444302/index.html">Die Entwicklung der Architektur des Handels- und Clearingsystems der Moskauer Börse. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>