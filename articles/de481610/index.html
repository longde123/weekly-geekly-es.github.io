<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå≤ üë®‚Äçüé® üóø PostgreSQL Antipatterns: Aktualisierung einer gro√üen Tabelle unter Last ‚úã üéπ ‚≠ïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was soll ich tun (und definitiv nicht), wenn Sie eine gro√üe Anzahl von Datens√§tzen in der aktiv genutzten PostgreSQL-Tabelle "multi-million" aktualisi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: Aktualisierung einer gro√üen Tabelle unter Last</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/481610/">  Was soll ich tun (und definitiv nicht), wenn Sie <b>eine gro√üe Anzahl von Datens√§tzen</b> in der aktiv genutzten PostgreSQL-Tabelle "multi-million" <b>aktualisieren</b> m√ºssen - den Wert des neuen Felds initialisieren oder Fehler in vorhandenen Datens√§tzen korrigieren?  Gleichzeitig sparen Sie Zeit und verlieren kein Firmengeld durch Ausfallzeiten. <br><br><img src="https://habrastorage.org/webt/vw/8_/jj/vw8_jjubp0owqcielxtg6gjufng.png"><br><a name="habracut"></a><br>  Bereiten Sie die Testdaten vor: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl(k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, v <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">chr</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ascii</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) + (random() * <span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) k , (random() * <span class="hljs-number"><span class="hljs-number">100</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i; <span class="hljs-comment"><span class="hljs-comment">--  ,   ! CREATE INDEX ON tbl(k, v);</span></span></code> </pre> <br>  Angenommen, wir m√∂chten nur den Wert von v f√ºr alle Datens√§tze mit k im Bereich 'q' .. 'z' um 1 erh√∂hen. <br><br>  Bevor Sie jedoch mit den Experimenten beginnen, speichern Sie den Originaldatensatz, um jedes Mal "saubere" Ergebnisse zu erzielen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl;</code> </pre> <br><h2>  UPDATE: Einer f√ºr alle und alle f√ºr einen </h2><br>  Die einfachste Option, die einem sofort in den Sinn kommt, ist, alles in einem UPDATE zu erledigen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = v + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/zs/0h/nb/zs0hnbsdmvjrctxn_wkia0wr6oy.png"><br>  <a href="https://explain.tensor.ru/archive/explain/197f26d0cedf3abba51a15d4650c897e:0:2019-12-23">[siehe EXPLAIN.TENSOR.RU]</a> <br><br>  Ein recht einfacher Vorgang auf ganz ‚Äûkurzen‚Äú Leitungen dauerte anscheinend l√§nger als 2,5 Sekunden.  Und wenn Ihr Ausdruck komplizierter ist, ist die Linie authentischer, es gibt mehr Aufzeichnungen und sogar einige Ausl√∂ser greifen ein - die Zeit kann sogar bis zu Minuten, aber bis zu Stunden ansteigen.  Angenommen, Sie sind bereit zu warten, und der Rest Ihres Systems ist an diese Basis gebunden, wenn eine aktive OLTP-Last vorliegt. <br><br>  Das Problem ist, dass UPDATE, sobald es zu einem bestimmten Datensatz <b>gelangt, diesen bis zum Ende der Ausf√ºhrung blockiert</b> .  Wenn er gleichzeitig mit demselben Datensatz an einem parallel gestarteten ‚ÄûSpot‚Äú -UPDATE arbeiten m√∂chte, <b>wartet</b> er nach wie <b>vor auf einen Block</b> f√ºr die Aktualisierungsanforderung und setzt sich bis zum Ende seiner Arbeit durch. <br><br><img src="https://habrastorage.org/webt/p7/gx/qu/p7gxqutnt9o8zuwiwjlbmrf4fk8.png"><br>  ¬© <a href="http://wumo.com/wumo">wumo.com/wumo</a> <br><br>  Das schlimmste Szenario sind Web-Systeme, bei denen Verbindungen zur Datenbank nach Bedarf hergestellt werden. Schlie√ülich sammeln sich solche "baumelnden" Verbindungen an und verschlingen die Ressourcen sowohl der Datenbank als auch des Clients, wenn Sie keinen davon getrennten Schutzmechanismus einrichten. <br><br><h2>  Transaktionen aufteilen </h2><br>  Im Allgemeinen ist nicht alles gut, wenn alles auf einmal erledigt wird.  Ja, und selbst wenn wir ein gro√ües UPDATE in mehrere kleine UPDATE aufteilen, aber alles <b>in einer Transaktion</b> funktionieren lassen, bleibt das Problem beim Sperren gleich, da ver√§nderbare Datens√§tze bis zum Ende der gesamten Transaktion gesperrt sind. <br><br>  Wir m√ºssen also eine gro√üe Transaktion in mehrere aufteilen.  Dazu k√∂nnen wir entweder externe Mittel verwenden und eine Art Skript schreiben, das separate Transaktionen generiert, oder die M√∂glichkeiten nutzen, die uns die Datenbank selbst bietet. <br><br><h4>  CALL und Transaktionsmanagement </h4><br>  Ab PostgreSQL 11 k√∂nnen <a href="https://postgrespro.ru/docs/postgresql/11/plpgsql-transactions">Transaktionen</a> direkt im prozeduralen Code verwaltet werden: <br><blockquote>  In Prozeduren, die vom CALL-Befehl aufgerufen werden, sowie in anonymen Codebl√∂cken (im DO-Befehl) k√∂nnen Sie Transaktionen abschlie√üen, indem Sie COMMIT und ROLLBACK ausf√ºhren.  Nachdem die Transaktion mit diesen Befehlen abgeschlossen ist, wird automatisch eine neue gestartet. </blockquote>  Aber diese Version ist bei weitem nicht jedermanns Sache und die Arbeit mit CALL hat ihre Grenzen.  Deshalb werden wir versuchen, unser Problem ohne externe Mittel zu l√∂sen, damit es auf allen aktuellen Versionen und auch mit minimalen √Ñnderungen auf dem Server selbst funktioniert - so dass es nicht notwendig w√§re, irgendetwas zu kompilieren und neu zu starten. <br><br>  Aus dem gleichen Grund werden wir die M√∂glichkeit, <a href="https://blog.dalibo.com/2016/08/19/Autonoumous_transactions_support_in_PostgreSQL.html">autonome Transaktionen √ºber pg_background zu</a> organisieren, nicht in Betracht <a href="https://blog.dalibo.com/2016/08/19/Autonoumous_transactions_support_in_PostgreSQL.html">ziehen</a> . <br><br><h4>  Verwalten von Verbindungen "innerhalb" der Basis </h4><br>  PostgreSQL hat in der <a href="https://postgrespro.ru/docs/postgresql/12/dblink">Vergangenheit</a> verschiedene Methoden verwendet, <a href="https://www.cybertec-postgresql.com/en/implementing-autonomous-transactions-in-postgres/">um autonome Transaktionen</a> zu <a href="https://www.cybertec-postgresql.com/en/implementing-autonomous-transactions-in-postgres/">emulieren</a> und separate zus√§tzliche Verbindungen zu generieren - √ºber zus√§tzliche prozedurale Sprachen oder das Standard- <a href="https://postgrespro.ru/docs/postgresql/12/dblink">Dblink-Modul</a> .  Letzteres hat den Vorteil, dass es standardm√§√üig in den meisten Distributionen enthalten ist und nur ein Befehl erforderlich ist, um es in der Datenbank zu aktivieren: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION dblink;</code> </pre> <br><h2>  "... und viele, viele ekelhafte Kinder mitgebracht" </h2><br>  Bevor Sie jedoch eine dblink-Bindung erstellen, sollten Sie zun√§chst herausfinden, wie ein ‚Äûnormaler Entwickler‚Äú einen gro√üen Datensatz, den er aktualisieren muss, in kleine aufteilt. <br><br><h3>  Naive LIMIT ... OFFSET </h3><br>  Die erste Idee besteht darin, eine "Paginierungs" -Suche durchzuf√ºhren: <i>"</i> W√§hlen <i>wir jedes Mal die <b>n√§chsten tausend Datens√§tze aus</b> ",</i> indem Sie den OFFSET-Wert in jeder neuen Anforderung erh√∂hen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k , v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-comment"><span class="hljs-comment">--       k, v --     ! LIMIT $1 OFFSET $2 * $1 ) S WHERE (Tk, Tv) = (Sk, Sv);</span></span></code> </pre> <br>  Vor dem Testen der Leistung dieser L√∂sung stellen wir den Datensatz wieder her: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl;</code> </pre> <br>  Wie wir im obigen Plan gesehen haben, m√ºssen wir ungef√§hr 384.000 Datens√§tze aktualisieren.  Lassen Sie uns daher gleich sehen, wie die Aktualisierungen n√§her am Ende durchgef√ºhrt werden - <b>im Bereich der 300. Iteration von 1000 Eintr√§gen</b> : <br><br><img src="https://habrastorage.org/webt/j8/h3/ju/j8h3juddfyiwgyg6nxe4yjmp5w4.png"><br>  <a href="https://explain.tensor.ru/archive/explain/922c49ce866d7c879d15c7d144efff86:0:2019-12-23">[siehe EXPLAIN.TENSOR.RU]</a> <br><br>  Oh ... Die Aktualisierung des Samples am Ende der <b>gesamten 1K-Datens√§tze</b> kostet uns fast so viel Zeit wie die <b>gesamte Originalversion</b> ! <br><br>  Dies ist nicht unsere Wahl.  Es kann trotzdem verwendet werden, wenn Sie nur wenige Iterationen und kleine OFFSET-Werte erhalten.  Weil das <b>LIMIT X OFFSET Y</b> f√ºr die Datenbank gleichbedeutend ist mit " <i>subtrahieren / ausw√§hlen / bilden von ersten X + Y-Datens√§tzen und dann werfen Sie das erste Y in den Papierkorb</i> ", was f√ºr gro√üe Werte von Y tragisch aussieht. <br><br>  Tats√§chlich kann diese Methode <b>√ºberhaupt nicht angewendet werden</b> !  Wir verlassen uns nicht nur auf aktualisierte Werte f√ºr die Auswahl, sondern riskieren auch, einen Teil der Datens√§tze zu √ºberspringen und den anderen Teil zweimal zu aktualisieren, wenn Bl√∂cke mit denselben Schl√ºsseln an den Seitenrand gelangen: <br><br><img src="https://habrastorage.org/webt/v0/kh/mn/v0khmnh_afkafan4fvvf4sfgq34.png"><br>  In diesem Beispiel haben wir den gr√ºnen Datensatz zweimal und den roten Datensatz nie aktualisiert.  Nur weil bei gleichen Werten der Sortierschl√ºssel die Reihenfolge der Datens√§tze selbst in einem solchen Block nicht festgelegt ist. <br><br><h3>  Traurig BESTELLEN BEI ... LIMIT </h3><br>  Lassen Sie uns die Aufgabe etwas modifizieren - f√ºgen Sie ein neues Feld hinzu, in das wir unseren Wert v + 1 schreiben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>;</code> </pre> <br>  Bitte beachten Sie, dass dieses Design fast sofort funktioniert, ohne die gesamte Tabelle neu zu schreiben.  Wenn Sie jedoch einen DEFAULT-Wert hinzuf√ºgen, gilt dies - erst <a href="https://www.depesz.com/2018/04/04/waiting-for-postgresql-11-fast-alter-table-add-column-with-a-non-null-default/">ab der 11. Version</a> . <br><br>  Lassen Sie uns sofort einen Index erstellen, in dem nur nicht initialisierte Eintr√§ge verbleiben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl(k, v) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  Der CONCURRENTLY-Index blockiert nicht die Lese- und Schreibarbeit mit der Tabelle, w√§hrend er sich langsam sogar auf einen riesigen Datensatz √ºbertr√§gt. <br><br>  Nun lautet die Idee: <i>"W√§hlen wir jedes Mal <b>nur die ersten tausend Datens√§tze</b> aus diesem Index aus."</i> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-comment"><span class="hljs-comment">--   OFFSET! ) S WHERE (Tk, Tv) = (Sk, Sv) AND Tx IS NULL;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ne/dp/ck/nedpck-lvoeexx1ffpb63v8nd1w.png"><br>  <a href="https://explain.tensor.ru/archive/explain/9a152e5f94595f995599c9c558fc6f37:0:2019-12-23">[siehe EXPLAIN.TENSOR.RU]</a> <br><br>  Schon viel besser - die Dauer jeder einzelnen Transaktion verk√ºrzt sich jetzt um das Sechsfache. <br><br>  Aber lassen Sie uns noch einmal sehen, wie der Plan f√ºr die 200. Iteration aussehen wird: <br><br><pre> <code class="plaintext hljs">Update on tbl t (actual time=530.591..530.591 rows=0 loops=1) Buffers: shared hit=789337 read=1 dirtied=1</code> </pre> <br>  Die Zeit verschlechterte sich erneut (allerdings nur um 25%), und die Puffer nahmen zu - aber warum? <br>  Tatsache ist, dass <a href="https://habr.com/ru/company/postgrespro/blog/445820/">MVCC in PostgreSQL</a> "tote Seelen" im Index hinterl√§sst - Versionen bereits aktualisierter Datens√§tze, die jetzt nicht mehr f√ºr den Index geeignet sind.  Das hei√üt, wir <b>scannen immer noch</b> die ersten 1000 Datens√§tze bei der 200. Iteration, obwohl wir sp√§ter die vorherigen 199K-Versionen von Tupeln verwerfen, die bereits ge√§ndert wurden. <br><br>  Wenn bei uns nicht mehrere Hundert, sondern mehrere Hunderttausend Iterationen erforderlich sind, macht sich die Verschlechterung bei jeder nachfolgenden Abfrageausf√ºhrung st√§rker bemerkbar. <br><br><h2>  UPDATE nach Segment </h2><br>  Warum h√§ngen wir eigentlich so an diesem Wert von ‚Äû1000 Datens√§tzen‚Äú?  Schlie√ülich haben wir <b>keinen Grund, genau 1000</b> oder eine andere bestimmte Zahl <b>zu w√§hlen</b> .  Wir wollten lediglich den gesamten Datensatz in einige, nicht unbedingt gleich gro√üe, nicht <b>zusammenh√§ngende Segmente</b> "schneiden". Verwenden wir also unseren vorhandenen Index f√ºr den beabsichtigten Zweck. <br><br>  Ein <b>indiziertes Paar (k, v) eignet sich</b> hervorragend f√ºr unsere Aufgabe.  Lassen Sie uns eine Abfrage erstellen, damit sie auf dem zuletzt verarbeiteten Paar aufbauen kann: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> kv <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (k, v) &gt; ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) , upd <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (<span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> kv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Tx <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> k, v ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> upd <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Bei der ersten Iteration gen√ºgt es, die Abfrageparameter auf den <b>Wert "Null" ('', 0) zu setzen</b> , und bei jeder n√§chsten Iteration wird das <b>Ergebnis der vorherigen Abfrage abgerufen</b> . <br><br><img src="https://habrastorage.org/webt/ok/ea/fg/okeafgsqia7iejthcmz2wuvsnm0.png"><br>  <a href="https://explain.tensor.ru/archive/explain/2e6ac5867caa6be474c3845dcb7eebcb:0:2019-12-23">[siehe EXPLAIN.TENSOR.RU]</a> <br><br>  Die Transaktions- / Sperrzeit betr√§gt weniger als eine Millisekunde. Die Anzahl der Iterationen wird nicht beeintr√§chtigt. Ein vollst√§ndiger vorl√§ufiger Scan aller Daten in der Tabelle ist nicht erforderlich.  Gro√üartig! <br><br><div class="spoiler">  <b class="spoiler_title">Setzen Sie die endg√ºltige Version mit Dblink</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; v integer = 0; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> PERFORM dblink_connect(<span class="hljs-string"><span class="hljs-string">'dbname='</span></span> || current_database() || <span class="hljs-string"><span class="hljs-string">' port='</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">--  PREPARED STATEMENT,      PERFORM dblink($q$ PREPARE _q(text, integer) AS WITH kv AS ( SELECT k, v FROM tbl WHERE (k, v) &gt; ($1, $2) AND k BETWEEN 'q' AND 'z' AND x IS NULL ORDER BY k, v LIMIT 1 ) , upd AS ( UPDATE tbl T SET x = Tv + 1 WHERE (Tk, Tv) = (TABLE kv) AND Tx IS NULL RETURNING k, v ) TABLE upd LIMIT 1; $q$); -- ,    LOOP SELECT * INTO k, v FROM dblink($p$EXECUTE _q('$p$ || k || $p$',$p$ || v || $p$)$p$) T(k text, v integer); RAISE NOTICE '(k,v) = (''%'',%)', k, v; --   ,     EXIT WHEN (k, v) IS NULL; END LOOP; PERFORM dblink_disconnect(); END; $$ LANGUAGE plpgsql;</span></span></code> </pre> <br></div></div><br>  Ein zus√§tzlicher Vorteil dieser Methode ist die M√∂glichkeit, die Ausf√ºhrung dieses Skripts jederzeit zu unterbrechen und dann an der gew√ºnschten Stelle fortzusetzen. <br><br><h2>  Komplexe Berechnungen in UPDATE </h2><br>  Ich werde die Situation mit der schwierigen Berechnung des zugewiesenen Werts separat erw√§hnen - wenn Sie etwas aus den verkn√ºpften Tabellen berechnen m√ºssen. <br><br>  Die f√ºr die Berechnung aufgewendete Zeit erh√∂ht auch die Dauer der Transaktion.  Daher ist es am besten <b>, diese Werte</b> nach UPDATE zu <b>berechnen</b> . <br><br>  Zum Beispiel m√∂chten wir unser neues Feld x mit der Anzahl der Datens√§tze f√ºllen, die denselben Wert haben (k, v).  Erstellen wir eine "tempor√§re" Tabelle, deren Generierung keine zus√§tzlichen Sperren erfordert: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tmp <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tmp(k, v);</code> </pre> <br>  Nun k√∂nnen wir gem√§√ü dem oben beschriebenen Modell gem√§√ü dieser Tabelle iterieren und das Ziel aktualisieren: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Sx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tmp S <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (Sk, Sv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (Sk, Sv) = ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Wie Sie sehen, sind keine komplizierten Berechnungen erforderlich. <br><br>  Denken Sie daran, die Hilfstabelle sp√§ter zu l√∂schen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481610/">https://habr.com/ru/post/de481610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481596/index.html">Analysieren der ELK 7.5-Einstellungen f√ºr die Mikrotik-Protokollanalyse</a></li>
<li><a href="../de481598/index.html">Ein kleiner Beitrag zum Kampf gegen die Avalonia UI-Zoo-Plattformen</a></li>
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele f√ºr Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481606/index.html">Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</a></li>
<li><a href="../de481612/index.html">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfl√§che f√ºr weniger Plattformen</a></li>
<li><a href="../de481616/index.html">Geod√§tische Kuppel. √úber das Ger√§t und meine Erfahrungen mit Berechnungen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: N√§chste Serie</a></li>
<li><a href="../de481624/index.html">Schreiben einer Anwendung auf Flutter in Verbindung mit Redux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>