<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏼 🎅🏿 👩🏾‍🤝‍👨🏽 Wie ich den Sommer mit C # 8 verbracht habe 💆🏼 👩🏻‍🔧 👩‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einer kürzlich veröffentlichten Version des DotNet & More Blazor-Podcasts, NetCore 3.0 Preview, C # 8, haben wir nicht nur beiläufig ein so brennen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich den Sommer mit C # 8 verbracht habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467655/"><p>  In einer kürzlich veröffentlichten Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNet &amp; More</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blazor-Podcasts, NetCore 3.0 Preview, C # 8, haben</a> wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht nur</a> beiläufig ein so brennendes Thema wie C # 8 erwähnt.  Die Geschichte über die Erfahrung mit C # 8 war nicht groß genug, um ein separates Thema zu behandeln, daher wurde beschlossen, die Mittel des Genres der Pistole mit ihm zu teilen. </p><br><p>  In diesem Artikel möchte ich über meine Erfahrungen mit C # 8 in der Produktion für 4 Monate sprechen.  Nachfolgend finden Sie Antworten auf folgende Fragen: </p><br><ul><li>  Wie man im neuen C # "buchstabiert" </li><li>  Welche Funktionen waren wirklich nützlich </li><li>  Was enttäuscht </li></ul><a name="habracut"></a><br><p>  Eine vollständige Liste der C # 8-Funktionen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation von Microsoft</a> .  In diesem Artikel werde ich die Möglichkeiten auslassen, die ich aus dem einen oder anderen Grund nicht ausprobieren konnte, nämlich: </p><br><ul><li>  Readonly Mitglieder </li><li>  Standardschnittstellenmitglieder </li><li>  Einweg-Ref-Strukturen </li><li>  Asynchrone Streams </li><li>  Indizes und Bereiche </li></ul><br><p>  Ich schlage vor, mit einer der köstlichsten Möglichkeiten zu beginnen, wie es mir vorher schien. </p><br><h3 id="switch-expressions">  Ausdrücke wechseln </h3><br><p>  In unseren Träumen präsentieren wir diese Funktion ziemlich rosig: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; operation <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Operation.Summ =&gt; x + y, Operation.Diff =&gt; x - y, Operation.Mult =&gt; x * y, Operation.Div =&gt; x / y, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException() };</code> </pre> <br><p>  Leider nimmt die Realität ihre eigenen Anpassungen vor. <br>  Erstens gibt es keine Möglichkeit, die Bedingungen zu kombinieren: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrafficLights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Signal signal</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (signal) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Red: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Yellow: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"stop"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Green: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"go"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  In der Praxis bedeutet dies, dass in der Hälfte der Fälle der Schalterausdruck in einen regulären Schalter umgewandelt werden muss, um ein Kopieren und Einfügen zu vermeiden. </p><br><p>  Zweitens unterstützt die neue Syntax keine Anweisungen, d. H.  Code, der keinen Wert zurückgibt.  Es scheint gut, und es ist nicht notwendig, aber ich selbst war überrascht, als mir klar wurde, wie oft Schalter (in Verbindung mit Mustervergleich) für so etwas wie die Behauptung in Tests verwendet werden. </p><br><p>  Drittens unterstützt der Schalterausdruck, der aus dem letzten Absatz folgt, keine mehrzeiligen Handler.  Wie beängstigend wir zum Zeitpunkt des Hinzufügens der Protokolle verstehen: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecFull</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (operation) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Summ: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} + {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Diff: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} - {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Mult: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} * {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Div: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} / {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  Ich möchte nicht sagen, dass der neue Schalter schlecht ist.  Nein, er ist gut, nur nicht gut genug. </p><br><h3 id="property--positional-patterns">  Eigenschafts- und Positionsmuster </h3><br><p>  Vor einem Jahr schienen sie mir die Hauptkandidaten für den Titel "Gelegenheit, die die Entwicklung verändert hat" zu sein.  Und wie erwartet müssen Sie Ihren Entwicklungsansatz ändern, um die volle Leistung von Positions- und Eigenschaftsmustern nutzen zu können.  Es ist nämlich notwendig, algebraische Datentypen zu imitieren. <br>  Es scheint, was ist das Problem: Nehmen Sie die Marker-Oberfläche und gehen Sie.  Leider hat diese Methode in einem großen Projekt einen schwerwiegenden Nachteil: Niemand garantiert, dass die Erweiterung Ihrer algebraischen Typen in der Entwurfszeit verfolgt wird.  Es ist daher sehr wahrscheinlich, dass Änderungen am Code im Laufe der Zeit an den unerwartetsten Stellen zu vielen "Standardfehlern" führen. </p><br><h3 id="tuple-patterns">  Tupelmuster </h3><br><p>  Aber der "jüngere Bruder" der neuen Vergleichsmöglichkeiten mit der Stichprobe erwies sich als wirklich gut gemacht.  Die Sache ist, dass das Tupelmuster keine Änderungen in der bekannten Architektur unseres Codes erfordert, sondern nur einige Fälle vereinfacht: </p><br><pre> <code class="cs hljs"> Player? Play(Gesture left, Gesture right) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (left, right) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Left; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Right; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  Das Beste daran ist jedoch, dass diese Funktion, die vorhersehbar genug ist, mit der Deconstruct-Methode hervorragend funktioniert.  Übergeben Sie einfach eine Klasse mit implementiertem Deconstruct, um die Funktionen des Tupelmusters zu wechseln und zu nutzen. </p><br><h3 id="using-declarations">  Deklarationen verwenden </h3><br><p>  Es scheint eine kleine Chance zu sein, aber es bringt so viel Freude.  In allen Promos spricht Microsoft von einem Aspekt wie der Reduzierung der Verschachtelung.  Aber seien wir ehrlich, nicht so sehr wichtig.  Aber was wirklich ernst ist, sind die Nebenwirkungen des Ausschlusses eines Codeblocks: </p><br><ul><li>  Wenn wir using hinzufügen, müssen wir den Code häufig mit der Copy-Paste-Methode "innerhalb" des Blocks ziehen.  Jetzt denken wir einfach nicht darüber nach </li><li>  Die Variablen, die innerhalb von using deklariert und nach dem Entsorgen des using-Objekts verwendet werden, bereiten echte Kopfschmerzen.  Ein Problem weniger </li><li>  In Klassen, die häufige Dispose-Aufrufe erfordern, wäre jede Methode 2 Zeilen länger.  Es scheint eine Kleinigkeit zu sein, aber unter den Bedingungen vieler kleiner Methoden erlaubt diese Kleinigkeit nicht, eine ausreichende Anzahl dieser Methoden auf einem Bildschirm anzuzeigen </li></ul><br><p>  Infolgedessen ändert eine so einfache Sache wie die Verwendung von Deklarationen das Gefühl der Codierung so sehr, dass Sie einfach nicht zu c # 7.3 zurückkehren möchten. </p><br><h3 id="static-local-functions">  Statische lokale Funktionen </h3><br><p>  Um ehrlich zu sein, würde ich diese Möglichkeit ohne die Hilfe der Code-Analyse nicht einmal bemerken.  Trotzdem hat sie sich fest in meinem Code verankert: Schließlich sind statische lokale Funktionen perfekt für die Rolle kleiner reiner Funktionen geeignet, da sie das Schließen von Methodenvariablen nicht unterstützen können.  Dies schont das Herz, da Sie verstehen, dass Ihr Code einen potenziellen Fehler weniger enthält. </p><br><h3 id="nullable-reference-types">  Nullable Referenztypen </h3><br><p>  Und zum Nachtisch möchte ich das wichtigste Merkmal von C # 8 erwähnen.  In Wahrheit verdient das Parsen von nullbaren Referenztypen einen separaten Artikel.  Ich möchte nur die Empfindungen beschreiben. </p><br><ul><li>  Erstens ist es wunderbar.  Ich hätte früher meine ausdrückliche Absicht beschreiben können, ein Feld oder eine Eigenschaft für nullbar zu erklären, aber jetzt ist diese Funktion in die Sprache integriert. </li><li>  Zweitens wird von NullReferenceException überhaupt nicht gespeichert.  Und ich spreche nicht von dem berüchtigten "Verstopfen" bei Warnungen.  Es ist nur so, dass zur Laufzeit niemand Nullargumentprüfungen für Sie generiert. Beeilen Sie sich also nicht, Code wie throw new ArgumentNullException () zu werfen. </li><li>  Drittens gibt es ein ernstes Problem mit dem DTO.  Beispielsweise kommentieren Sie eine Eigenschaft mit dem Attribut Erforderlich.  Dementsprechend gelangt ein Objekt mit einer Eigenschaft von 100% nicht null in Ihren WebAPI-Controller.  Es ist jedoch nicht möglich, dieses Attribut und alle ähnlichen Attribute mit prüfbaren Referenztypprüfungen zu verknüpfen.  Die Sache ist, dass, wenn Sie Standard <em>MyProperty {get;</em>  Wenn Sie <em>eine</em> Eigenschaft mit einem NotNull-Typ festlegen, erhalten Sie eine Warnung: <em>"[CS8618] Die nicht nullfähige Eigenschaft 'MyProperty' ist nicht initialisiert. Erwägen Sie, die Eigenschaft als nullbar zu deklarieren</em> . <em>"</em>  Das ist fair genug, da Sie während des Initialisierungsprozesses keine Nullsemantik garantieren können.  Das einzige Ergebnis dieser Funktion ist die Unfähigkeit, in einem DTO keine Null-Eigenschaften zu verwenden.  Aber es gibt gute Nachrichten, es gibt eine einfache Problemumgehung - initialisieren Sie Ihr Feld einfach mit dem Standardwert: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MyProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> </li><li>  Viertens sind Attribute, die komplexe Fälle behandeln, wie z. B. TryGetValue, selbst recht komplex.  Infolgedessen ist es sehr wahrscheinlich, dass nicht sehr bewusste Entwickler Operatoren (!) Missbrauchen, wodurch die Fähigkeiten nullbarer Referenztypen ausgeglichen werden.  Eine Hoffnung für Analysatoren. </li><li>  Fünftens und vor allem persönlich hat mich diese Gelegenheit schon oft vor NullReferenceException-Fehlern bewahrt.  Es stellt sich als banale Zeitersparnis heraus - viele Fehler werden beim Kompilieren abgefangen und keine Tests oder Fehlerbehebungen.  Dies gilt insbesondere nicht nur für die Entwicklung komplexer Geschäftslogik, sondern auch für die triviale Arbeit mit externen Bibliotheken, DTO und anderen Abhängigkeiten, die möglicherweise null enthalten. </li></ul><br><h2 id="rezyume">  Zusammenfassung </h2><br><p>  Natürlich erreichen die sich bietenden Möglichkeiten keine vollwertige Revolution, aber es gibt immer weniger Lücken zwischen C # und F # / Scala.  Ob es gut oder schlecht ist, wird die Zeit zeigen. </p><br><p>  Zum Zeitpunkt der Veröffentlichung dieses Artikels hat sich C # 8 möglicherweise bereits in Ihrem Projekt niedergelassen. Ich würde mich also fragen, was Sie von der neuen Version unserer Lieblingssprache halten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467655/">https://habr.com/ru/post/de467655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467633/index.html">Petition: Automatische Meldung und Zahlung von Steuern auf Einkommen von FLP (Ukraine)</a></li>
<li><a href="../de467639/index.html">Sicherheitswoche 38: Verfolgung mobiler Geräte per SIM-Karte</a></li>
<li><a href="../de467645/index.html">Nach Angular Meetup # 15</a></li>
<li><a href="../de467647/index.html">Nicht laden - nicht testen: Wie haben wir Probleme mit dem VTB-Dokumentenverwaltungssystem festgestellt?</a></li>
<li><a href="../de467653/index.html">Habrastatistik: Analyse von Leserkommentaren</a></li>
<li><a href="../de467657/index.html">Inventar von I bis Z. Wir zählen Softwarelizenzen</a></li>
<li><a href="../de467659/index.html">Beschleunigen Sie die Ausführung von Aufgaben am Beispiel einer zusätzlichen Konfiguration des aktualisierten HyperX FURY DDR4-Speichers erheblich</a></li>
<li><a href="../de467661/index.html">Dosimeter für Seryozha. Teil I. Polimaster - Nuklidjäger</a></li>
<li><a href="../de467663/index.html">Unterstützung für hardwarespezifische Anweisungen in .NET Core (jetzt nicht nur SIMD)</a></li>
<li><a href="../de467665/index.html">ROS LKW Wagen. Teil 5. Arbeiten in Rviz und Pavillon: Xacro, neue Sensoren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>