<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏾 👩🏾‍🤝‍👩🏼 💥 Mengumumkan Pratinjau .NET Core 3.0 6 💯 👩🏻‍🤝‍👨🏾 🧒🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, kami mengumumkan .NET Core 3.0 Preview 6 . Ini termasuk pembaruan untuk menyusun rakitan untuk startup yang lebih baik, mengoptimalkan aplik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengumumkan Pratinjau .NET Core 3.0 6</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/456224/"><p>  Hari ini, kami mengumumkan <a href="" rel="nofollow">.NET Core 3.0 Preview 6</a> .  Ini termasuk pembaruan untuk menyusun rakitan untuk startup yang lebih baik, mengoptimalkan aplikasi untuk ukuran dengan tautan dan perbaikan EventPipe.  Kami juga telah merilis gambar Docker baru untuk Alpine di ARM64. </p><br><ul><li><p>  <a href="" rel="nofollow">Unduh .NET Core 3.0 Preview 6</a> sekarang di Windows, macOS dan Linux. </p></li><li><p>  <a href="">Catatan rilis</a> telah dipublikasikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnet / core</a> .  Perbedaan <a href="">API antara Pratinjau 5 dan 6</a> juga tersedia. </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASP.NET Core</a> dan EF Core juga merilis pembaruan hari ini. </p></li><li><p>  Jika Anda melewatkannya, lihat peningkatan yang kami rilis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">.NET Core 3.0 Preview 5</a> , dari bulan lalu. </p></li></ul><br><img src="https://habrastorage.org/webt/m8/il/ym/m8ilymhs6vkajgs1wfbpnzud3lw.jpeg"><a name="habracut"></a><br><br><h2>  Pembaruan WPF dan Windows Forms </h2><br><p>  Tim WPF sekarang telah menyelesaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerbitan sebagian besar basis kode WPF ke GitHub</a> .  Bahkan, mereka hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerbitkan sumber untuk lima belas majelis</a> .  Bagi siapa pun yang akrab dengan WPF, nama-nama majelis harus sangat akrab. </p><br><p>  Dalam beberapa kasus, tes masih di backlog untuk dipublikasikan pada atau sebelum 3,0 GA.  Yang mengatakan, kehadiran semua kode ini harus memungkinkan komunitas WPF untuk sepenuhnya berpartisipasi dalam membuat perubahan di WPF.  Jelas dari membaca beberapa masalah GitHub bahwa komunitas memiliki simpanan sendiri yang telah menunggu untuk disadari.  Tema gelap, mungkin? </p><br><h2>  Gambar buruh pelabuhan Alpine </h2><br><p>  Gambar Docker sekarang tersedia untuk .NET Core dan ASP.NET Core di ARM64.  Mereka sebelumnya hanya tersedia untuk x64. </p><br><p> Gambar-gambar berikut dapat digunakan dalam <code>Dockerfile</code> , atau dengan <code>docker pull</code> , seperti yang ditunjukkan di bawah ini: </p><br><ul><li> <code>docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8</code> </li> <li> <code>docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8</code> </li> </ul><br><h2>  Perbaikan pipa acara </h2><br><p>  Pipa Acara sekarang mendukung beberapa sesi.  Ini berarti bahwa Anda dapat mengkonsumsi acara dengan EventListener di-proc dan secara bersamaan memiliki klien pipa acara yang tidak dalam proses. </p><br><p>  Perf Counters baru ditambahkan: </p><br><ul><li>  % Waktu dalam GC </li><li>  Gen 0 Ukuran Tumpukan </li><li>  Gen 1 Heap Size </li><li>  Gen 2 Heap Size </li><li>  Ukuran Tumpukan LOH </li><li>  Tingkat alokasi </li><li>  Jumlah majelis dimuat </li><li>  Jumlah ThreadPool Threads </li><li>  Tingkat Kontensi Kunci Monitor </li><li>  Antrean Item Pekerjaan ThreadPool </li><li>  Tingkat Item Pekerjaan yang Diselesaikan ThreadPool </li></ul><br><p>  Pasang profiler sekarang diimplementasikan menggunakan infrastruktur Pipa Acara yang sama. </p><br><p>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Bermain dengan penghitung</a> dari David Fowler untuk mendapatkan ide tentang apa yang dapat Anda lakukan dengan event pipe untuk melakukan investigasi kinerja Anda sendiri atau hanya memantau status aplikasi. </p><br><p>  Lihat <a href="">penghitung dotnet</a> untuk menginstal alat penghitung dotnet. </p><br><h2>  Optimalkan aplikasi .NET Core Anda dengan gambar ReadyToRun </h2><br><p>  Anda dapat meningkatkan waktu mulai aplikasi .NET Core Anda dengan mengkompilasi rakitan aplikasi Anda sebagai format ReadyToRun (R2R).  R2R adalah bentuk kompilasi di masa depan (AOT). </p><br><p>  Binari R2R meningkatkan kinerja startup dengan mengurangi jumlah pekerjaan yang perlu dilakukan JIT saat aplikasi Anda memuat.  Binari berisi kode asli yang sama dengan apa yang JIT akan hasilkan, memberikan JIT sedikit liburan ketika kinerja paling penting (saat startup).  Binari R2R lebih besar karena mengandung kode bahasa perantara (IL), yang masih diperlukan untuk beberapa skenario, dan versi asli dari kode yang sama, untuk meningkatkan startup. </p><br><p>  R2R didukung dengan .NET Core 3.0.  Itu tidak dapat digunakan dengan versi .NET Core sebelumnya. </p><br><h3>  Contoh angka kinerja </h3><br><p>  Berikut ini adalah angka kinerja yang dikumpulkan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh aplikasi WPF</a> .  Aplikasi ini diterbitkan sebagai lengkap dan tidak menggunakan tautan tautan (dibahas nanti di pos ini). </p><br><p>  Aplikasi IL-only: </p><br><ul><li>  Waktu mulai: 1,9 detik </li><li>  Penggunaan memori: 69,1 MB </li><li>  Ukuran aplikasi: 150 MB </li></ul><br><p>  Dengan gambar ReadyToRun: </p><br><ul><li>  Waktu mulai: 1,3 detik. </li><li>  Penggunaan memori: 55,7 MB </li><li>  Ukuran aplikasi: 156 MB </li></ul><br><h2>  Gambar ReadyToRun, dijelaskan </h2><br><p>  Anda dapat R2R mengkompilasi perpustakaan dan binari aplikasi.  Saat ini, perpustakaan hanya bisa dikompilasi R2R sebagai bagian dari aplikasi, bukan untuk pengiriman sebagai paket NuGet.  Kami ingin umpan balik lebih lanjut tentang apakah skenario itu penting. </p><br><p>  Kumpulan kompilasi AOT telah tersedia sebagai konsep dengan .NET untuk waktu yang lama, kembali ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">.NET Framework dan NGEN</a> .  NGEN memiliki kelemahan utama, yaitu kompilasi yang harus dilakukan pada mesin klien, menggunakan alat NGEN.  Tidak mungkin untuk menghasilkan gambar NGEN sebagai bagian dari pembuatan aplikasi Anda. </p><br><p>  Masukkan .NET Core.  Muncul dengan <a href="">crossgen</a> , yang menghasilkan gambar asli dalam format yang lebih baru yang disebut <a href="">ReadyToRun</a> .  Nama tersebut menggambarkan proposisi nilai utamanya, yaitu bahwa gambar asli ini dapat dibangun sebagai bagian dari bangunan Anda dan "siap dijalankan" tanpa ada pekerjaan tambahan pada mesin klien.  Itu peningkatan besar, dan juga kemenangan penting bagi perubahan iklim. </p><br><p>  Dalam hal kompatibilitas, gambar ReadyToRun mirip dengan rakitan IL, dengan beberapa perbedaan utama. </p><br><ul><li>  Majelis IL hanya berisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kode IL</a> .  Mereka dapat berjalan pada setiap runtime yang mendukung kerangka target yang diberikan untuk perakitan itu.  Misalnya perakitan <code>netstandard2.0</code> dapat berjalan pada .NET Framework 4.6+ dan .NET Core 2.0+, pada sistem operasi apa pun yang didukung (Windows, macOS, Linux) dan arsitektur (Intel, ARM, 32-bit, 64-bit). </li><li>  Majelis R2R berisi IL dan kode asli.  Mereka dikompilasi untuk versi runtime .NET Core minimum dan lingkungan runtime (RID) minimum.  Misalnya, rakitan <code>netstandard2.0</code> mungkin dikompilasi R2R untuk .NET Core 3.0 dan Linux x64.  Ini hanya akan dapat digunakan dalam konfigurasi yang kompatibel (seperti .NET Core 3.1 atau .NET Core 5.0, di Linux x64), karena berisi kode asli yang hanya dapat digunakan dalam lingkungan runtime tersebut. </li></ul><br><h3>  Instruksi </h3><br><p>  Kompilasi ReadyToRun adalah fitur opt-in yang hanya mempublikasikan.  Kami telah merilis versi pratinjau dengan .NET Core 3.0 Preview 5. </p><br><p>  Untuk mengaktifkan kompilasi ReadyToRun, Anda harus: </p><br><ul><li>  Setel properti <code>PublishReadyToRun</code> menjadi <code>true</code> . </li><li>  Publikasikan menggunakan <code>RuntimeIdentifier</code> eksplisit. </li></ul><br><p>  Catatan: Ketika kumpulan aplikasi dikompilasi, kode asli yang dihasilkan adalah platform dan arsitektur spesifik (itulah sebabnya Anda harus menentukan RuntimeIdentifier yang valid saat penerbitan). </p><br><p>  Ini sebuah contoh: </p><br><pre> <code class="cs hljs">&lt;Project Sdk=<span class="hljs-string"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span>&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3<span class="hljs-number"><span class="hljs-number">.0</span></span>&lt;/TargetFramework&gt; &lt;PublishReadyToRun&gt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>&lt;/PublishReadyToRun&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt;</code> </pre> <br><p>  Dan terbitkan dengan menggunakan perintah berikut: </p><br><pre> <code class="cs hljs">dotnet publish -r win-x64 -c Release</code> </pre> <br><p>  Catatan: <code>RuntimeIdentifier</code> juga dapat diatur dalam file proyek. </p><br><p>  Catatan: ReadyToRun saat ini hanya didukung untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">aplikasi mandiri</a> .  Ini akan diaktifkan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">aplikasi yang bergantung</a> pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kerangka kerja</a> di pratinjau nanti. </p><br><p>  <code>PublishReadyToRunEmitSymbols</code> simbol asli dapat diaktifkan dengan menyetel properti <code>PublishReadyToRunEmitSymbols</code> menjadi <code>true</code> dalam proyek Anda.  Anda tidak perlu membuat simbol asli untuk keperluan debugging.  Simbol-simbol ini hanya berguna untuk keperluan pembuatan profil. </p><br><p>  SDK saat ini mendukung cara untuk mengecualikan majelis tertentu agar tidak dikompilasi ke dalam gambar ReadyToRun.  Ini bisa berguna untuk kasus-kasus ketika majelis tertentu tidak benar-benar perlu dioptimalkan untuk kinerja.  Ini dapat membantu mengurangi ukuran aplikasi.  Ini juga bisa menjadi solusi yang berguna untuk kasus-kasus di mana kompiler ReadyToRun gagal mengkompilasi perakitan tertentu.  Pengecualian dilakukan menggunakan grup item PublishReadyToRunExclude.  Contoh: </p><br><pre> <code class="cs hljs">&lt;ItemGroup&gt; &lt;PublishReadyToRunExclude Include=<span class="hljs-string"><span class="hljs-string">"FilenameOfAssemblyToExclude.dll"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><h2>  Kompilasi lintas platform / arsitektur </h2><br><p>  Kompiler ReadyToRun saat ini tidak mendukung penargetan silang.  Anda perlu mengkompilasi target yang diberikan.  Misalnya, jika Anda ingin gambar R2R untuk Windows x64, Anda harus menjalankan perintah publish pada lingkungan itu. </p><br><p>  Pengecualian untuk ini: </p><br><ul><li>  Windows x64 dapat digunakan untuk mengkompilasi gambar Windows ARM32, ARM64, dan x86. </li><li>  Windows x86 dapat digunakan untuk mengkompilasi gambar Windows ARM32. </li><li>  Linux x64 dapat digunakan untuk mengkompilasi gambar Linux ARM32 dan ARM64. </li></ul><br><h2>  Tautan perakitan </h2><br><p>  .NET core 3.0 SDK hadir dengan alat yang dapat mengurangi ukuran aplikasi dengan menganalisis IL dan memangkas perangkat yang tidak digunakan. </p><br><p>  Dengan .NET Core, selalu memungkinkan untuk menerbitkan aplikasi mandiri yang mencakup semua yang diperlukan untuk menjalankan kode Anda, tanpa memerlukan .NET untuk diinstal pada target penyebaran.  Dalam beberapa kasus, aplikasi hanya membutuhkan sebagian kecil kerangka kerja agar berfungsi dan berpotensi menjadi lebih kecil dengan memasukkan hanya pustaka yang digunakan. </p><br><p>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IL linker</a> untuk memindai IL aplikasi Anda untuk mendeteksi kode mana yang sebenarnya diperlukan, dan kemudian memangkas pustaka kerangka kerja yang tidak digunakan.  Ini secara signifikan dapat mengurangi ukuran beberapa aplikasi.  Biasanya, aplikasi konsol seperti alat kecil paling diuntungkan karena cenderung menggunakan subset kerangka yang cukup kecil dan biasanya lebih mudah menerima pemotongan. </p><br><p>  Untuk menggunakan alat ini, atur <code>PublishTrimmed=true</code> di proyek Anda dan publikasikan aplikasi mandiri: </p><br><pre> <code class="cs hljs">dotnet publish -r &lt;rid&gt; -c Release</code> </pre> <br><p>  Output terbitkan akan mencakup subset dari pustaka framework, tergantung pada apa yang dipanggil kode aplikasi.  Untuk aplikasi helloworld, linker mengurangi ukuran dari ~ 68MB menjadi ~ 28MB. </p><br><p>  Aplikasi atau kerangka kerja (termasuk ASP.NET Core dan WPF) yang menggunakan refleksi atau fitur dinamis terkait akan sering rusak ketika dipangkas, karena linker tidak tahu tentang perilaku dinamis ini dan biasanya tidak dapat menentukan jenis kerangka mana yang akan diperlukan untuk refleksi saat dijalankan.  Untuk memangkas aplikasi semacam itu, Anda perlu memberi tahu tautan tentang jenis apa saja yang dibutuhkan oleh refleksi dalam kode Anda, dan dalam paket atau kerangka kerja apa pun yang Anda andalkan.  Pastikan untuk menguji aplikasi Anda setelah pemotongan. </p><br><p>  Untuk informasi lebih lanjut tentang IL Linker, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dokumentasi</a> , atau kunjungi repo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mono / linker</a> . </p><br><p>  Catatan: Dalam versi .NET Core sebelumnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">ILLink.Tasks</a> dikirimkan sebagai paket NuGet eksternal dan menyediakan banyak fungsi yang sama.  Ini tidak lagi didukung - perbarui ke 3.0 SDK terbaru dan coba pengalaman baru! </p><br><h2>  Menggunakan Linker dan ReadToRun Bersama </h2><br><p>  Linker dan kompiler ReadyToRun dapat digunakan untuk aplikasi yang sama.  Secara umum, tautan membuat aplikasi Anda lebih kecil, dan kemudian kompiler siap-jalankan akan membuatnya sedikit lebih besar lagi, tetapi dengan kemenangan kinerja yang signifikan.  Perlu pengujian dalam berbagai konfigurasi untuk memahami dampak dari setiap opsi. </p><br><p>  Catatan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotnet / sdk # 3257</a> mencegah tautan dan ReadyToRun digunakan bersama untuk aplikasi WPF dan Windows Forms.  Kami sedang berupaya memperbaikinya sebagai bagian dari rilis .NET Core 3.0. </p><br><h2>  Sampel hosting asli </h2><br><p>  Tim baru-baru ini memposting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampel Hosting Asli</a> .  Ini menunjukkan pendekatan praktik terbaik untuk hosting .NET Core dalam aplikasi asli. </p><br><p>  Sebagai bagian dari .NET Core 3.0, kami sekarang mengekspos fungsionalitas umum ke host asli .NET Core yang sebelumnya hanya tersedia untuk aplikasi yang dikelola .NET Core melalui host .NET Core yang disediakan secara resmi.  Fungsionalitas ini terutama terkait dengan memuat perakitan.  Fungsionalitas ini akan membuatnya lebih mudah untuk menghasilkan host asli yang dapat memanfaatkan serangkaian fitur lengkap dari .NET Core. </p><br><h2>  Dukungan HTTP / 2 di HttpClient </h2><br><p>  HTTP / 2 adalah revisi utama dari protokol HTTP.  Beberapa fitur penting dari HTTP / 2 adalah dukungan untuk kompresi header dan stream multiplexing penuh melalui koneksi yang sama.  Sementara HTTP / 2 mempertahankan semantik HTTP (header HTTP, metode, dll) itu adalah perubahan dari HTTP / 1.x dalam cara data dibingkai dan dikirim melalui kabel. </p><br><p>  <code>HttpClient</code> sekarang menambahkan dukungan untuk membuat permintaan HTTP / 2.  Sementara defaultnya tetap HTTP / 1.1, Anda dapat memilih untuk menggunakan HTTP / 2 dengan mengatur versi pada pesan permintaan HTTP Anda. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// HTTP/1.1 request using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); } // HTTP/2 request using (var request = new HttpRequestMessage(HttpMethod.Get, "/") { Version = new Version(2, 0) }) using (var response = await client.SendAsync(request)) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Atau, Anda dapat secara default mengirim permintaan HTTP / 2 dengan mengatur properti <code>DefaultRequestVersion</code> di <code>HttpClient</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>), DefaultRequestVersion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Version(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// Defaults to HTTP/2 using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Sebagai konsekuensi dari perubahan framing ini, server dan klien perlu menegosiasikan versi protokol yang digunakan.  Application-Layer Protocol Negotiation (ALPN) adalah ekstensi TLS yang memungkinkan server dan klien menegosiasikan versi protokol yang digunakan sebagai bagian dari jabat tangan TLS mereka.  Meskipun dimungkinkan untuk memiliki pengetahuan sebelumnya antara server dan klien pada protokol, sebagian besar server hanya mendukung ALPN sebagai satu-satunya cara untuk membuat koneksi HTTP / 2.  Dengan demikian, HTTP / 2 dinegosiasikan oleh <code>HttpClient</code> hanya pada koneksi TLS. </p><br><p>  Dalam skenario pengembangan ketika server dan klien memiliki pengetahuan apriori bahwa keduanya akan berbicara HTTP / 2 tidak terenkripsi, Anda dapat membuat koneksi HTTP / 2 melalui cleartext dengan mengatur sakelar <code>AppContext</code> atau variabel lingkungan ( <code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT=1</code> ). </p><br><pre> <code class="cs hljs">AppContext.SetSwitch(<span class="hljs-string"><span class="hljs-string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><h2>  Penutupan </h2><br><p>  Silakan coba fitur-fitur baru.  Silakan ajukan masalah untuk bug atau pengalaman menantang yang Anda temukan.  Kami ingin umpan baliknya!  Anda juga dapat mengajukan permintaan fitur, tetapi kemungkinan besar mereka harus menunggu untuk diimplementasikan sampai rilis berikutnya pada saat ini. </p><br><p>  Kami sekarang semakin dekat untuk melengkapi fitur untuk .NET Core 3.0, dan sekarang sedang mentransisikan fokus tim ke kualitas rilis.  Kami memiliki beberapa bulan perbaikan bug dan kinerja bekerja di depan.  Kami akan menghargai umpan balik Anda saat kami mengerjakan proses itu juga. </p><br><p>  Pada catatan itu, kami akan segera beralih cabang <code>master</code> pada .NET Core repos ke rilis besar berikutnya, kemungkinan pada atau segera setelah rilis Preview 7 (Juli). </p><br><p>  Terima kasih telah mencoba pratinjau .NET Core 3.0.  Kami menghargai bantuan Anda.  Pada titik ini, kami fokus untuk mendapatkan rilis final di tangan Anda. </p><br><hr><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Richard Lander</a> <br>  PM, Tim NET </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456224/">https://habr.com/ru/post/id456224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456214/index.html">Gunakan __main__.py</a></li>
<li><a href="../id456216/index.html">Membuat game retro dari tahun 80-an atau cara memasak mock-up untuk memotong laser</a></li>
<li><a href="../id456218/index.html">.NET Core 3.0 (Pratinjau 6) Dirilis</a></li>
<li><a href="../id456220/index.html">Generalisasi masalah Brokar</a></li>
<li><a href="../id456222/index.html">Rekayasa genetika embrio manusia akan menjadi aman dan efektif dalam dua tahun</a></li>
<li><a href="../id456226/index.html">Prediksi hasil sepakbola</a></li>
<li><a href="../id456230/index.html">Iobroker mencari petualangan di game realitas</a></li>
<li><a href="../id456232/index.html">Panduan: Memperbarui Antarmuka dengan Anggota Default di C # 8.0</a></li>
<li><a href="../id456234/index.html">Mengapa Cisco tidak membeli Splunk atau berbicara tentang cara kerja platform Cisco untuk berburu ancaman</a></li>
<li><a href="../id456236/index.html">Peter - Insider Dev Tour: Konferensi Orang Dalam untuk Pengembang dari Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>