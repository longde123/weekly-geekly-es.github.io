<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏽 👧🏿 👨🏿‍🚀 Chorda. Essayer de le faire de façon déclarative 👩🏼 🤸🏾 🍺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chaque fois que je dois m'asseoir pour créer une nouvelle application, je tombe dans une stupeur facile. Ma tête tourne de la nécessité de choisir la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chorda. Essayer de le faire de façon déclarative</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480856/"><p>  Chaque fois que je dois m'asseoir pour créer une nouvelle application, je tombe dans une stupeur facile.  Ma tête tourne de la nécessité de choisir la bibliothèque ou le framework à prendre ce temps.  La dernière fois que j'ai écrit sur la bibliothèque X, mais maintenant le framework Y a grandi et a été transféré, et il y a toujours un Kit UI cool Z, et beaucoup de travail a été laissé par les projets précédents. </p><br><p>  À partir d'un certain point, j'ai réalisé que le cadre n'a pas vraiment d'importance - ce dont j'ai besoin, je peux le faire sur n'importe lequel d'entre eux.  Ici, il semble que vous devriez être heureux, prendre quelque chose avec le maximum d'étoiles sur le github et se calmer.  Mais tout de même, un désir irrésistible naît constamment de faire quelque chose de lui-même, son propre vélo.  Eh bien.  Quelques réflexions générales sur ce sujet et un cadre appelé Chorda vous attendent sous la coupe. </p><a name="habracut"></a><br><p>  En fait, le problème n'est pas que la décision de quelqu'un d'autre soit mauvaise ou inefficace.  Non.  Le problème est que la décision de quelqu'un d'autre nous fait penser d'une manière qui peut ne pas nous convenir.  Mais attendez.  Que signifie «pratique-incommode» et comment cela peut-il même affecter le développement?  Rappelons qu'il existe une chose telle que DX, en fait - un ensemble de pratiques personnelles établies et généralement acceptées.  De là, nous pouvons dire que cela nous convient lorsque notre propre DX coïncide avec le DX de l'auteur de la bibliothèque ou du framework.  Et dans le cas où ils divergent, l'inconfort même, l'irritation et la recherche de quelque chose de nouveau surviennent. </p><br><h3 id="nemnozhko-istorii">  Un peu d'histoire </h3><br><p>  Lorsque vous développez une interface utilisateur pour une application d'entreprise, vous êtes confronté à un grand nombre de formulaires utilisateur.  Et un jour, une pensée brillante me vient à l'esprit: pourquoi est-ce que je crée un formulaire Web à chaque fois que je peux simplement lister les champs dans JSON et alimenter la structure résultante au générateur?  Et, bien que dans le monde de l'entreprise sanglante, une telle approche ne fonctionne pas trop bien (pourquoi donc, c'est une conversation séparée), mais l'idée de passer d'un style impératif à un style déclaratif n'est généralement pas mauvaise.  La preuve en est le grand nombre de générateurs de formulaires Web, de pages et même de sites entiers qui peuvent être facilement trouvés sur le Web. </p><br><p>  Donc, à un moment donné, je n'étais pas étranger au désir d'améliorer mon code en raison de la transition vers la déclarativité.  Mais dès que nous avions besoin non seulement d'éléments html standard, mais de composants de widget complexes et interactifs, nous ne pouvions pas nous en sortir avec un simple générateur.  Les exigences de réutilisation, d'intégrabilité, d'extensibilité, etc. du code s'y sont rapidement ajoutées.  Développer votre propre bibliothèque de composants avec une API déclarative ne s'est pas fait attendre. </p><br><p>  Mais ici, le bonheur n'est pas arrivé.  La meilleure situation reflétera probablement l'opinion de mon collègue, qui devait utiliser la bibliothèque créée.  Il a regardé les exemples, la documentation et a dit: "La bibliothèque est cool. Belle, dynamique. Mais comment puis-je faire une application à partir de tout cela?"  Et il avait raison.  Il s'est avéré que fabriquer un composant n'est pas la même chose que combiner plusieurs composants ensemble et les faire fonctionner de manière transparente. </p><br><p>  Beaucoup de temps s'est écoulé depuis lors.  Et quand une fois de plus j'ai été visité par le désir de rassembler les pensées et les développements, j'ai décidé d'agir un peu différemment et de ne pas aller de bas en haut, mais de haut en bas. </p><br><h3 id="upravlenie-prilozheniem--upravlenie-sostoyaniyami">  Gestion des applications == Gestion des états </h3><br><p>  Je suis plus habitué à considérer l'application comme une machine à états finis avec un ensemble d'états clones.  Et le travail de l'application comme un ensemble de transitions d'un état à un autre, dans lequel le changement de modèle conduit à la création d'une nouvelle version de la vue.  À l'avenir <strong>,</strong> j'appellerai certaines <strong>données</strong> fixes (un objet, un tableau, un type primitif, etc.) liées à leur seule représentation - un <strong>document</strong> . </p><br><p>  Il y a un problème évident - pour de nombreuses valeurs du modèle, il est nécessaire de décrire de nombreuses options pour le document.  Deux approches sont généralement utilisées ici: </p><br><ol><li>  Modèles.  Nous utilisons notre langage de balisage préféré et le complétons avec des directives de branchement et de bouclage. </li><li>  Les fonctions  Nous décrivons dans nos fonctions nos branches et boucles dans notre langage de programmation préféré. </li></ol><br><p>  En règle générale, ces deux approches sont déclarées déclaratives.  Le premier est considéré comme déclaratif, car il est basé sur, quoique légèrement développé, mais sur les règles du langage de balisage.  Le second - parce qu'il se concentre sur la composition des fonctions, dont un certain nombre agissent comme des règles.  Ce qui est remarquable, il n'y a pas de frontière claire entre les modèles et les fonctions maintenant. </p><br><p>  D'une part, j'aime les modèles, mais d'autre part, je voulais en quelque sorte utiliser les fonctionnalités de javascript.  Par exemple, quelque chose comme ceci: </p><br><pre><code class="javascript hljs">createFromConfig({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Alice'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">'clickable box'</span></span>, <span class="hljs-attr"><span class="hljs-attr">onClick</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Click'</span></span>) } })</code> </pre> <br><p>  Le résultat est une configuration JS qui décrit un <strong>état</strong> spécifique entier.  Pour décrire les nombreux états, il sera nécessaire de réaliser l'extensibilité de cette configuration.  Et quel est le moyen le plus pratique de rendre un ensemble d'options extensible?  Nous n'inventerons rien ici - les options de surcharge existent depuis longtemps.  Comment cela fonctionne peut être vu dans l'exemple de Vue avec son API Options.  Mais, contrairement à la même Vue, je me demandais si l'état complet, y compris les données et le document, pouvait être décrit de la même manière. </p><br><h3 id="struktura-prilozheniya-i-deklarativnost">  Structure d'application et caractère déclaratif </h3><br><blockquote>  Le terme «composant» est devenu trop vague, surtout après l’apparition de ce que l’on appelle  composants fonctionnels.  Alors que nous passons à la structure de l'application, j'appellerai le composant un <strong>élément structurel</strong> . </blockquote><p>  Très rapidement, je suis arrivé à la conclusion que l'élément structurel (composant) n'est pas un élément de document, mais une entité, qui: </p><br><ol><li>  combine des données et des documents (liaison et événements) </li><li>  connecté à d'autres entités similaires (structure arborescente) </li></ol><br><p>  Comme je l'ai souligné précédemment, si vous percevez l'application comme un ensemble d'états, alors pour ces états, vous devez avoir une méthode de description.  De plus, il est nécessaire de trouver une telle méthode pour qu'elle ne contienne pas d'opérateurs impératifs "faux".  Nous parlons de ces éléments très auxiliaires qui sont introduits dans les modèles - <em>#if</em> , <em>#elsif</em> , <em>v-for</em> , etc.  Je pense que beaucoup de gens connaissent déjà la solution - il est nécessaire de transférer la logique au modèle, en laissant au niveau de la présentation une API qui vous permet de contrôler les éléments structurels à travers des types de données simples. </p><br><p>  Par gestion, je comprends la présence de variabilité et de cyclicité. </p><br><h4 id="variativnost-if-else">  Variabilité (if-else) </h4><br><p>  Voyons comment vous pouvez contrôler les options d'affichage en utilisant l'exemple d'un composant de carte dans Chorda: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isHeaderOnly = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> card = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-attr"><span class="hljs-attr">$header</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> }, <span class="hljs-attr"><span class="hljs-attr">$footer</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> }, <span class="hljs-attr"><span class="hljs-attr">components</span></span>: {<span class="hljs-attr"><span class="hljs-attr">header</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">footer</span></span>: !isHeaderOnly} <span class="hljs-comment"><span class="hljs-comment">//    })</span></span></code> </pre> <br><p>  En définissant la valeur de l'option des <em>composants</em> , vous pouvez contrôler les composants affichés.  Et lors de la liaison des <em>composants</em> avec le stockage réactif, nous obtenons que notre structure passera sous la gestion des données.  Il y a une mise en garde: l'objet est utilisé comme valeur et les clés ne sont pas ordonnées, ce qui impose certaines restrictions sur les <em>composants</em> . </p><br><h4 id="ciklichnost-for">  Cycle (pour) </h4><br><p>  L'utilisation de données dont la quantité n'est connue qu'au moment de l'exécution nécessitera une itération sur les listes. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> drinks = [<span class="hljs-string"><span class="hljs-string">'Coffee'</span></span>, <span class="hljs-string"><span class="hljs-string">'Tea'</span></span>, <span class="hljs-string"><span class="hljs-string">'Milk'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-attr"><span class="hljs-attr">html</span></span>: <span class="hljs-string"><span class="hljs-string">'ul'</span></span>, <span class="hljs-attr"><span class="hljs-attr">css</span></span>: <span class="hljs-string"><span class="hljs-string">'list'</span></span>, <span class="hljs-attr"><span class="hljs-attr">defaultItem</span></span>: { <span class="hljs-attr"><span class="hljs-attr">html</span></span>: <span class="hljs-string"><span class="hljs-string">'li'</span></span>, <span class="hljs-attr"><span class="hljs-attr">css</span></span>: <span class="hljs-string"><span class="hljs-string">'list-item'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: drinks })</code> </pre> <br><p>  La valeur de l'option <em>items</em> est Array, respectivement, nous obtenons un ensemble ordonné de composants.  La liaison d' <em>éléments</em> au stockage, comme dans le cas des <em>composants,</em> transférera le contrôle aux données. </p><br><p>  Les éléments structurels sont connectés les uns aux autres dans une hiérarchie arborescente.  Si nous combinons les exemples précédents, alors pour afficher la liste dans le corps de la carte, nous obtenons ce qui suit: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const state = { struct: { header: true, footer: false, }, drinks: ['Coffee', 'Tea', 'Milk'] } //  const card = new Html({ $header: { /*  */ }, $content: { html: 'ul', css: 'list', defaultItem: { html: 'li', css: 'list-item' }, items: state.drinks }, $footer: { /*  */ }, components: state.struct })</span></span></code> </pre> <br><p>  De cette façon, la structure de données de l'application est créée.  Il suffit d'avoir deux types de générateurs - basés sur Object et basés sur Array.  Il ne reste plus qu'à comprendre comment se produit la transformation des éléments structurels en document. </p><br><h3 id="kogda-vse-uzhe-pridumano-za-nas">  Quand tout est déjà inventé pour nous </h3><br><p>  En général, je suis en faveur du fait que le système de rendu des documents devrait être implémenté au niveau du navigateur (bien qu'au moins le même VDOM).  Et notre tâche ne sera que de le connecter soigneusement à l'arborescence des composants.  Après tout, quelle que soit la vitesse de la bibliothèque, le navigateur l'a de toute façon. </p><br><p>  Honnêtement, j'ai essayé de faire ma fonction de rendu un jour, mais après un certain temps, j'ai abandonné, car je ne peux pas dessiner plus vite que VanillaJS (malheureusement!).  Il est maintenant à la mode d'utiliser VDOM pour le rendu, et ses implémentations sont peut-être même abondantes.  Donc, plus une implémentation de plus de l'arborescence virtuelle, j'ai décidé de ne pas l'ajouter à la tirelire du github - le prochain framework suffit. </p><br><p>  Initialement, un adaptateur pour la bibliothèque Maquette a été créé à Chorda pour le rendu, mais dès que des tâches «du monde réel» ont commencé à apparaître, il s'est avéré qu'il était plus pratique d'avoir un tiroir sur React.  Dans ce cas, par exemple, vous pouvez simplement utiliser les React DevTools existants et ne pas écrire les vôtres. </p><br><p>  Pour connecter VDOM avec des éléments structurels, vous avez besoin d'une telle <strong>disposition</strong> .  Elle peut être appelée fonction documentaire d'un élément structurel.  Ce qui est important, c'est une fonction pure. </p><br><p>  Prenons un exemple avec une carte qui a un en-tête, un corps et un sous-sol.  Il a déjà été mentionné que les composants ne sont pas commandés, c'est-à-dire  si nous commençons à allumer / éteindre les composants pendant le fonctionnement, ils apparaîtront à chaque fois dans une nouvelle commande.  Voyons comment cela est résolu par la mise en page: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orderedByKeyLayout</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h, type, props, components</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h(type, props, components.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a.key - b.key).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.render())) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-attr"><span class="hljs-attr">$header</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">$content</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">$footer</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">layout</span></span>: orderedByKeyLayout <span class="hljs-comment"><span class="hljs-comment">//     })</span></span></code> </pre> <br><p>  La disposition vous permet de configurer le soi-disant  L'élément hôte auquel le composant est associé et ses enfants ( <em>éléments</em> et <em>composants</em> ).  Habituellement, une mise en page standard suffit également, mais dans certains cas, la mise en page nécessite la présence d'éléments wrapper (par exemple, pour les grilles) ou l'affectation de classes spéciales, que nous ne voulons pas prendre au niveau des composants. </p><br><h3 id="schepotka-reaktivnosti">  Une pincée de réactivité </h3><br><p>  Après avoir déclaré et dessiné la structure des composants, nous obtenons un état correspondant à un ensemble de données spécifique.  Ensuite, nous devons décrire les nombreux ensembles de données et la réaction à leur changement. </p><br><p>  Lorsque je travaillais avec des données, je n'aimais pas deux choses: </p><br><ul><li>  Immunité.  Une bonne chose pour suivre les changements est le versioning pour les pauvres, ce qui fonctionne très bien sur les objets primitifs et plats.  Mais dès que la structure devient plus complexe et que le nombre d'investissements augmente, il devient difficile de maintenir l'immunité d'un objet complexe. </li><li>  Remplacement.  Si je mets un objet dans l'entrepôt de données, lorsque je le demande, je peux en renvoyer une copie ou un autre objet ou proxy en général qui a une similitude structurelle avec lui. </li></ul><br><p>  Je voulais avoir un référentiel qui se comporte comme immuable, mais à l'intérieur il contient des données mutables, qui maintiennent également la persistance des liens.  Dans le cas idéal, cela ressemblerait à ceci: je crée un référentiel, j'y écris un objet vide, je commence à saisir des données à partir du formulaire de demande, et après avoir cliqué sur le bouton soumettre, j'obtiens le même objet (le même lien!) Avec les propriétés remplies.  J'appelle ce cas idéal, car il n'arrive pas souvent que le modèle de stockage corresponde au modèle de présentation. </p><br><p>  Une autre tâche qui doit être résolue consiste à fournir des données du stockage aux éléments structurels.  Encore une fois, nous n'inventerons rien et utiliserons l'approche de la connexion à un <strong>contexte</strong> commun.  Dans le cas de Chorda, nous n'avons pas accès au contexte lui-même, mais seulement à son affichage, appelé <strong>le scope</strong> .  De plus, la portée du composant est le contexte de ses composants enfants.  Cette approche vous permet d'affiner, d'étendre ou de remplacer les données connexes à n'importe quel niveau de notre application, et ces modifications seront isolées. </p><br><p>  Un exemple de la façon dont les données contextuelles sont réparties sur une arborescence de composants: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Html({ <span class="hljs-comment"><span class="hljs-comment">//     scope: { drink: 'Coffee' }, $component1: { scope: { cups: 2 }, $content: { $myDrink: { //      ,    drinkChanged: function (v) { //    drink   text this.opt('text', v) } }, $numCups: { cupsChanged: function (v) { this.opt('text', v + ' cups') } } } }, $component2: { scope: { drink: 'Tea' //      drink }, drinkChanged: function (v) { //    drink   text this.opt('text', v) } } }) //    // &lt;div&gt; // &lt;div&gt; // &lt;div&gt; // &lt;div&gt;Coffee&lt;/div&gt; // &lt;div&gt;2 cups&lt;/div&gt; // &lt;/div&gt; // &lt;/div&gt; // &lt;div&gt;Tea&lt;/div&gt; // &lt;/div&gt;</span></span></code> </pre><br><p>  Le moment le plus difficile à comprendre est que chaque composant a son propre contexte, et non celui déclaré tout en haut de la structure, comme nous le faisons habituellement lorsque nous travaillons avec des modèles. </p><br><h3 id="chto-tam-bylo-naschet-peregruzki-opciy">  Qu'en est-il de la surcharge d'options? </h3><br><p>  Vous êtes sûrement confronté à une situation où il y a un grand composant et il est nécessaire de changer un petit composant imbriqué quelque part profondément à l'intérieur.  Ils disent que la granulation et la composition devraient aider ici.  Et aussi, que les composants et l'architecture doivent être conçus tout de suite.  La situation devient très triste si la grande composante n'est pas la vôtre, mais fait partie d'une bibliothèque développée par une autre équipe ou même une communauté indépendante.  Et s'ils pouvaient facilement apporter des modifications au composant de base, même s'ils n'étaient pas initialement prévus? </p><br><p>  Habituellement, les composants des bibliothèques sont conçus comme des classes, puis ils peuvent être utilisés comme base pour créer de nouveaux composants.  Mais voici une petite fonctionnalité cachée que je n'ai jamais aimé: parfois nous créons une classe juste pour l'appliquer en un seul endroit.  C'est bizarre.  Par exemple, j'ai l'habitude d'utiliser des classes pour taper, de créer des relations entre des groupes d'objets et de ne pas les utiliser pour résoudre le problème de décomposition. </p><br><p>  Voyons comment les classes fonctionnent avec la configuration dans Chorda. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      class Card extends Html { config () { return { css: 'box', $header: {}, $content: {}, $footer: {} } } } const html = new Html({ css: 'panel', $card: { as: Card, $header: { //       title $title: { css: 'title', text: 'Card title' } } } })</span></span></code> </pre> <br><p>  J'aime plus cette option que la création d'une classe TitledCard spéciale qui ne sera utilisée qu'une seule fois.  Et si vous devez faire partie des options, vous pouvez utiliser le mécanisme d'impureté.  Eh bien, personne n'a annulé Object.assign. </p><br><p>  À Chorda, une classe est essentiellement un conteneur pour la configuration et joue le rôle d'une sorte spéciale d'impureté. </p><br><h3 id="pochemu-esche-odin-freymvork">  Pourquoi un autre cadre? </h3><br><p>  Je répète qu'à mon avis, le cadre porte davantage sur la façon de penser et l'expérience que sur la technologie.  Mes habitudes et DX ont demandé une déclarativité dans JS, que je n'ai pas pu trouver dans d'autres solutions.  Mais l'implémentation d'une fonctionnalité en a tiré de nouvelles, et après un certain temps, elles ont tout simplement cessé de s'intégrer dans le cadre d'une bibliothèque spécialisée. </p><br><p>  À l'heure actuelle, Chorda est en développement actif.  Les directions principales sont déjà visibles, mais les détails changent constamment. </p><br><p>  Merci d'avoir lu jusqu'au bout.  Je serais ravi de revoir. </p><br><h3 id="gde-mozhno-posmotret">  Où puis-je voir? </h3><br><p>  <a href="https://eliace.github.io/chorda-docs/">La documentation</a> </p><br><p>  <a href="https://github.com/eliace/chorda/tree/master/packages/chorda-core">Sources GitHub</a> </p><br><p>  <a href="https://codepen.io/collection/DkGzvo">Exemples CodePen</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480856/">https://habr.com/ru/post/fr480856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480838/index.html">Les requêtes SQL sont rapides. Partie 1</a></li>
<li><a href="../fr480840/index.html">Cyberattaques contre les systèmes hydroacoustiques: mythes et réalité</a></li>
<li><a href="../fr480844/index.html">Habr Quest {concept}</a></li>
<li><a href="../fr480848/index.html">Kits et constructeurs pour les ingénieurs électroniques débutants âgés de 6 à 10 ans. Ce qui est disponible en magasin</a></li>
<li><a href="../fr480852/index.html">Développement rapide d'applications Web sur Vaadin et Spring Boot</a></li>
<li><a href="../fr480858/index.html">Lancez Linux dans un navigateur - l'émulateur jor1k vous aidera (avec Monkey Island, Doom et Frontier Elite II intégrés)</a></li>
<li><a href="../fr480860/index.html">Théorie de l'antirouille</a></li>
<li><a href="../fr480866/index.html">Une nouvelle ère de développement web ou «tout est déjà là»</a></li>
<li><a href="../fr480870/index.html">Résultats de la décennie</a></li>
<li><a href="../fr480872/index.html">Intel a fermé une faille de sécurité signalée il y a six mois</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>