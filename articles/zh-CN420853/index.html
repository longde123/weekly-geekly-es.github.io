<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛫 👨‍👧‍👧 ▶️ 认识Windows伪控制台（ConPTY） 👩🏿‍🤝‍👨🏽 📥 👋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="文章发表于2018年8月2日 

 这是有关Windows命令行的第二篇文章，我们将在此讨论伪控制台Windows的新基础架构和编程接口，即Windows Pseudo Console（ConPTY）：我们为什么开发它，为什么需要它，如何工作，如何使用它以及更多其他内容。 

 在上一篇文章“过去的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>认识Windows伪控制台（ConPTY）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420853/">  <font color="gray">文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发表</a>于2018年8月2日</font> <br><br> 这是有关Windows命令行的第二篇文章，我们将在此讨论伪控制台Windows的新基础架构和编程接口，即Windows Pseudo Console（ConPTY）：我们为什么开发它，为什么需要它，如何工作，如何使用它以及更多其他内容。 <br><br> 在上一篇文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“过去的严重遗产。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows命令行问题”，</a>我们讨论了终端出现和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows命令行发展</a>的先决条件，并开始研究Windows控制台和Windows命令行基础结构的内部结构。 我们还讨论了Windows控制台的许多优点和主要缺点。 <br><br> 缺点之一是Windows试图“有用”，但它会干扰备用控制台和第三方控制台的开发人员，服务开发人员等。 在创建控制台或服务时，开发人员需要访问其终端/服务与命令行应用程序交换数据或提供对它们的访问的通信通道。 在* NIX世界中，这不是问题，因为* NIX提供了伪终端（PTY）基础结构，可以轻松地为控制台或服务创建通信通道。 但是在Windows上不是... <br><br>  <i><b>...直到现在！</b></i> <br><a name="habracut"></a><br><h1> 从TTY到PTY </h1><br> 在详细介绍我们的开发之前，让我们简要地回到终端的开发。 <br><br><h2> 最初是TTY </h2><br> 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前一篇文章所述</a> ，在计算的早期，用户使用通过某种串行通信通道（通常通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">20 mA电流环路</a> ）连接到计算机的机电式电传打字机（TTY）来控制计算机。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>肯·汤普森（Ken Thompson）和丹尼斯·里奇（Dennis Ritchie）（站立）从事DEC PDP-11电传打字机（无电子显示的消息）的工作</i></font> <br><br><h3> 终端分布 </h3><br> 电传打字机被带电子显示屏（通常为CRT屏幕）的计算机终端所取代。 通常，终端是非常简单的设备（因此称为“哑终端”），仅包含以下任务所需的电子设备和处理能力： <br><br><ol><li> 接收来自键盘的文本输入。 </li><li> 将输入的文本缓冲在一行上（包括发送前的本地编辑）。 </li><li> 在串行通道上发送/接收文本（通常通过曾经广泛使用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RS-232接口</a> ）。 </li><li> 在终端显示屏上显示接收到的文本。 </li></ol><br> 尽管它简单（或可能要归功于它），但是终端迅速成为管理小型计算机，大型机和服务器的主要手段：大多数数据输入操作员，计算机操作员，系统管理员，科学家，研究人员，软件开发商和行业专家都在DEC终端上工作， IBM，Wyse和许多其他公司。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">海军上将格蕾丝·霍珀（Grace Hopper）在他的办公室，办公桌上装有DEC VT220终端</font></i> <br><br><h3> 分发软件终端 </h3><br> 从1980年代中期开始，通用计算机取代了专用终端，逐渐开始被使用，它们变得更加实惠，流行和强大。  80年代的许多早期PC和其他计算机都有终端应用程序，这些应用程序打开了与PC的RS-232连接，并与连接另一端的任何人交换数据。 <br><br> 随着通用计算机变得越来越复杂，图形用户界面（GUI）和并发应用程序的全新世界出现了，包括终端应用程序。 <br><br> 但是有一个问题：终端应用程序如何与在同一台计算机上运行的另一个命令行应用程序进行交互？ 以及如何在同一台计算机上运行的两个应用程序之间物理连接串行电缆？ <br><br><h2> 伪终端外观（PTY） </h2><br> 在* NIX世界中，通过引入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伪终端（PTY）</a>解决了该问题。 <br><br>  PTY通过暴露主机和从机伪设备（“主机”和“从机”）来模拟计算机中的串行电信设备：终端应用程序连接到主机伪设备，命令行应用程序（例如，诸如cmd，PowerShell和bash之类的外壳）连接到从机伪设备。 当终端客户端将文本和/或控制命令（编码为文本）传输到主伪设备时，该文本将转换为与其关联的从设备。 来自应用程序的文本被发送到从属伪设备，然后返回至主设备，进而发送至终端。 数据总是异步发送/接收。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">伪终端应用程序/ Shell</font></i> <br><br> 重要的是要注意，“从”伪设备模拟物理终端的行为，并将命令字符转换为POSIX信号。 例如，如果用户在终端中输入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CTRL + C</a> ，则CTRL + C的ASCII值（0x03）通过主机发送。 当在从属伪设备上接收到时，从输入流中删除值0x03，并生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SIGINT信号</a> 。 <br><br>  * NIX终端应用程序，文本面板管理器（例如，屏幕，tmux）等广泛使用这种PTY基础结构。 这些应用程序调用<code>openpty()</code> ，该<code>openpty()</code>返回PTY主从服务器的一对文件描述符（fd）。 然后，该应用程序可以派生/执行一个子命令行应用程序（例如bash），该应用程序使用其fd从站侦听并将文本返回给连接的终端。 <br><br> 这种机制允许终端应用程序直接与本地运行的命令行应用程序“对话”，就像终端机通过串行/网络连接与远程计算机对话一样。 <br><br><h2> 什么，没有伪控制台Windows？ </h2><br> 正如我们在上一篇文章中讨论的那样，尽管Windows控制台在概念上类似于传统的* NIX终端，但是它在几个关键方面有所不同，尤其是在最低级别上，这可能会给Windows命令行应用程序，第三方终端/控制台和服务器的开发人员带来问题应用范围： <br><br><ol><li>  <b>Windows没有PTY基础结构</b> ：当用户启动命令行应用程序（例如Cmd，PowerShell，wsl，ipconfig等）时，Windows本身会将新的或现有的控制台实例“连接”到该应用程序。 </li><li>  <b>Windows会干扰第三方控制台和服务器应用程序</b> ：Windows（当前）没有为终端提供一种提供通信渠道的方式，他们希望通过这些渠道与命令行应用程序进行交互。 第三方终端必须在屏幕之外创建控制台，将用户输入的数据发送到屏幕上，并通过在第三方控制台自己的显示器上重新绘制输出来废弃输出！ </li><li>  <b>仅Windows具有控制台API</b> ：Windows命令行应用程序依赖Win32 Consol API，这会降低代码的可移植性，因为所有其他平台都支持text / VT，而不是API。 </li><li>  <b>非标准的远程访问</b> ：命令行应用程序对Consol API的依赖性使交互和远程访问脚本大大复杂化。 </li></ol><br><h2> 怎么办 </h2><br> 许多<b>很多</b>开发人员经常要求在Windows下使用类似PTY的机制，特别是那些使用ConEmu / Cmder，Console2 / ConsoleZ，Hyper，VSCode，Visual Studio，WSL，Docker和OpenSSH工具的机制。 <br><br> 几天后，甚至当我开始在Console团队中工作时，甚至Ars Technica的技术编辑Peter Bright也要求我实施PTY机制： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br> 最近又一次： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br> 好吧，我们终于做到了： <b>我们为Windows创建了一个伪控制台</b> ： <br><br><h1> 欢迎使用Windows伪控制台（ConPTY） </h1><br> 自大约四年前成立控制台团队以来，该小组一直在进行Windows控制台和命令行内部机制的大修。 同时，我们定期并认真考虑了上述问题以及许多其他相关问题。 但是直到现在，基础设施和代码还没有准备好使伪控制台的发布成为可能！ <br><br> 新的Windows伪控制台（ConPTY）基础结构，API和其他一些相关更改将消除/减轻整个问题， <b>而不会破坏与现有命令行应用程序的向后兼容性</b> ！ <br><br><blockquote> 新的Win32 ConPTY API（官方文档即将发布）现已在Windows 10的最新内部版本和相应的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows 10 Insider Preview SDK中提供</a> 。 它们将出现在Windows 10的下一个主要版本中（在2018年秋/冬某个时候）。 </blockquote><br><h2> 控制台/ ConHost体系结构 </h2><br> 要了解ConPTY，您需要研究Windows控制台的体系结构，或者更确切地说是ConHost！ <br><br> 重要的是要理解，尽管ConHost实现了您作为Windows控制台应用程序看到和了解的所有内容，但ConHost还包含并实现了大多数Windows命令行基础结构！ 从现在开始， <b>ConHost成为真正的“控制台节点”</b> ，支持所有命令行应用程序和/或与命令行应用程序交互的GUI应用程序！ <br><br>  <b>怎么了</b>  <b>怎么了</b>  <b>什么啊</b> 让我们仔细看看。 <br><br> 这是内部控制台体系结构/ ConHost的高级视图： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br> 与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章</a>的体系结构相比，ConHost现在包含几个用于VT处理的附加模块，以及新的实现开放API的ConPTY模块： <br><br><ul><li>  <b>ConPTY API</b> ：新的Win32 ConPTY API提供类似于POSIX PTY模型的机制，但在Windows折射中。 </li><li>  <b>VT交互性</b> ：接收UTF-8编码的输入文本，将每个显示的文本字符转换为相应的<code>INPUT_RECORD</code>记录，并将其保存在输入缓冲区中。 它还处理转义序列，例如0x03（CTRL + C），将其转换为<code>KEY_EVENT_RECORDS</code> ，从而产生适当的转义动作。 </li><li>  <b>VT Renderer</b> ：生成移动光标并在输出缓冲区的与上一帧有所不同的区域中渲染文本和样式所必需的VT序列。 </li></ul><br> 好的，但这到底是什么意思？ <br><br><h2>  Windows命令行应用程序如何工作？ </h2><br> 为了更好地了解新的ConPTY基础架构的影响，让我们看一下到目前为止Windows控制台和命令行应用程序是如何工作的。 <br><br> 每当用户启动命令行应用程序（例如Cmd，PowerShell或ssh）时，Windows都会创建一个新的Win32进程，该进程将应用程序的可执行二进制文件及其任何依赖项（资源或库）加载到其中。 <br><br> 新创建的进程通常从其父级继承stdin和stdout描述符。 如果父进程是Windows GUI进程，则缺少stdin和stdout描述符，因此Windows将部署新应用程序并将其附加到新的控制台实例。 命令行应用程序及其控制台之间的通信通过ConDrv传输。 <br><br> 例如，当从没有提升特权的PowerShell实例启动时，新的应用程序进程将继承stdin / stdout父级描述符，因此，将接收输入数据并将输出输出到与父级相同的控制台。 <br><br><blockquote> 这里我们需要进行保留，因为在某些情况下，命令行应用程序是附加到控制台的<i>新</i>实例启动的，特别是出于安全原因，但是上面的描述通常是正确的。 </blockquote><br> 最终，当命令行/ shell应用程序启动时，Windows通过ConDrv将其连接到控制台实例（ConHost.exe）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  ConHost如何工作？ </h2><br> 每当运行命令行应用程序时，Windows就会将应用程序连接到新的或现有的ConHost实例。 该应用程序及其控制台实例通过内核模式控制台驱动程序（ConDrv）连接，该驱动程序发送/接收包含序列化API调用请求和/或文本数据的IOCTL消息。 <br><br> 从历史上看，如前一篇文章所述，如今，ConHost的工作相对简单： <br><br><ul><li> 用户通过键盘/鼠标/笔/触摸板生成输入，并将其转换为<code>KEY_EVENT_RECORD</code>或<code>MOUSE_EVENT_RECORD</code>并存储在输入缓冲区中。 </li><li> 输入缓冲区一次清空一个记录，执行请求的输入操作，例如在屏幕上显示文本，移动光标，复制/粘贴文本等。 其中许多操作都会更改输出缓冲区的内容。 这些更改的区域由ConHost状态引擎记录。 </li><li> 在每一帧中，控制台都会显示输出缓冲区的更改区域。 </li></ul><br> 当命令行应用程序调用Windows控制台API时，API调用被序列化为IOCTL消息并通过ConDrv驱动程序发送。 然后，它将IOCTL消息传递到附加的控制台，该控制台解码并执行请求的API调用。 返回的/输出值被序列化回IOCTL消息，并通过ConDrv发送回应用程序。 <br><br><h2>  ConHost：为过去做出贡献 </h2><br>  Microsoft努力尽可能保持与现有应用程序和工具的向后兼容性。 特别是对于命令行。 实际上，Windows 10的32位版本仍然可以运行许多/大多数16位Win16应用程序和可执行文件！ <br><br> 如上所述，ConHost的关键角色之一是为其命令行应用程序提供服务，尤其是调用和依赖Win32控制台API的旧应用程序。 现在，ConHost提供了新的服务： <br><br><ul><li> 无缝的类似PTY的基础架构，可与现代控制台和终端进行通信 </li><li> 升级旧版/传统命令行应用程序 <br><ul><li> 接收UTF-8文本/ VT并将其转换为输入记录（就像用户输入的一样） </li><li> 控制台API调用托管应用程序，并相应地更新其输出缓冲区 </li><li> 以UTF-8编码，文本/ VT显示输出缓冲区的修改区域 </li></ul></li></ul><br> 以下是现代控制台应用程序如何通过ConPTY ConHost与命令行应用程序通信的示例。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br> 在这个新模型中： <br><br><ol><li> 控制台： <br><ol><li> 建立自己的沟通渠道 </li><li> 调用ConPTY API创建ConPTY，从而强制Windows运行连接到通道另一端的ConHost实例 </li><li> 照常创建连接到ConHost的命令行应用程序（例如PowerShell）的实例 </li></ol></li><li> 主持人： <br><ol><li> 在输入处读取UTF-8文本/ VT并将其转换为<code>INPUT_RECORD</code>记录，然后将其发送到命令行应用程序 </li><li> 从可以修改输出缓冲区内容的命令行应用程序进行API调用 </li><li> 以UTF-8编码（文本/ VT）显示输出缓冲区中的更改，并将接收到的文本发送到其控制台 </li></ol></li><li> 命令行应用程序： <br><ol><li> 它像往常一样工作，读取输入并调用控制台API，却不知道其ConPTY ConHost会将输入和输出从/转换为UTF-8！ </li></ol></li></ol><br> 最后一刻很重要！ 当旧的命令行应用程序使用对控制台API的调用<code>WriteConsoleOutput(...)</code>如<code>WriteConsoleOutput(...)</code> ， <code>WriteConsoleOutput(...)</code>指定的文本写入相应的ConHost输出缓冲区。  ConHost会定期将输出缓冲区的更改区域显示为text / VT，并通过stdout发送回控制台。 <br><br> 最终，即使是传统的命令行应用程序也可以从外部“说”文本/ VT， <b>而无需进行任何更改</b> ！ <br><br> 使用新的ConPTY基础架构，第三方控制台现在可以直接与现代和传统的命令行应用程序进行交互，并以文本/ VT的形式交换它们。 <br><br><h2> 与Windows命令行应用程序进行远程交互 </h2><br> 上述机制在一台计算机上运行良好，但是在与远程Windows计算机或容器中的PowerShell实例进行交互时也很有用。 <br><br> 远程启动命令行应用程序时存在问题（即在远程计算机，服务器或容器上）。 事实是，远程计算机上的命令行应用程序与本地ConHost实例进行通信，因为IOCTL消息并非旨在通过网络传输。 如何将输入从本地控制台传输到远程计算机，以及如何从在此运行的应用程序获取输出？ 此外，如果Mac和Linux机器有终端，却没有Windows兼容的控制台，该怎么办？ <br><br> 因此，为了远程控制Windows计算机，我们需要某种通信代理，他们可以通过网络透明地序列化数据，管理应用程序实例的生存期等。 <br><br> 也许像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SSH</a>一样？ <br><br> 幸运的是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenSSH</a>最近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">被移植到Windows，</a>并作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows 10的附加选项</a>添加。  PowerShell Core还使用ssh作为受支持的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PowerShell Core Remoting远程</a>协议之一。 对于运行Windows PowerShell的用户， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">远程Windows PowerShell Remoting</a>仍然是可接受的选项。 <br><br> 让我们看看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows的OpenSSH现在</a>如何允许您远程控制<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows</a> Shell和命令行应用程序： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  OpenSSH当前包括一些不需要的并发症： <br><br><ol><li> 使用者： <br><ol><li> 启动ssh客户端，Windows照常连接控制台实例 </li><li> 在控制台中输入文本，该控制台将击键发送到ssh客户端 </li></ol></li><li>  ssh客户端： <br><ol><li> 读取输入为文本数据的字节 </li><li> 通过网络将文本数据发送到sshd侦听服务 </li></ol></li><li>  sshd服务经历几个阶段： <br><ol><li> 启动默认外壳程序（例如，Cmd），该外壳程序将强制Windows创建并连接控制台的新实例 </li><li> 查找并连接到Cmd实例的控制台 </li><li> 将控制台移出屏幕（和/或隐藏它） </li><li> 将从ssh客户端接收的输入发送到屏幕外的控制台作为输入 </li></ol></li><li>  cmd实例照常工作： <br><ol><li> 从sshd服务收集输入 </li><li> 工作吗 </li><li> 调用控制台API渲染/设置文本样式，移动光标等。 </li></ol></li><li> 附加的[屏幕外]控制台： <br><ol><li> 通过更新输出缓冲区进行API调用。 </li></ol></li><li>  Sshd服务： <br><ol><li> 报废屏幕外控制台的输出缓冲区，找到差异，将其编码为文本/ VT，然后发送回... </li></ol></li><li> 一个发送文本的ssh客户端... </li><li> 显示文字的控制台 </li></ol><br>  <b>好玩吧</b>  <b>一点都不！</b> 在这种情况下，可能会出现很多问题，尤其是在模拟和发送用户输入以及刷新屏幕外控制台的输出缓冲区的过程中。 这会导致不稳定，崩溃，数据损坏，过多的能耗等。 此外，并非所有应用程序都可以删除文本本身，还可以删除其属性，这就是为什么格式和颜色会丢失的原因！ <br><br><h3> 使用现代ConHost和ConPTY进行远程工作 </h3><br>  <b>当然可以改善情况吗？</b> 是的，我们当然可以-让我们进行一些体系结构更改并应用我们的新ConPTY： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br> 该图显示电路已更改如下： <br><br><ol><li> 使用者： <br><ol><li> 启动ssh客户端，Windows照常连接控制台实例 </li><li> 在控制台中输入文本，该控制台将击键发送到ssh客户端 </li></ol></li><li>  ssh客户端： <br><ol><li> 读取输入为文本数据的字节 </li><li> 通过网络将文本数据发送到sshd侦听服务 </li></ol></li><li>  Sshd服务： <br><ol><li> 创建标准输入/标准输出通道 </li><li> 调用ConPTY API来启动ConPTY </li><li> 启动连接到ConPTY另一端的Cmd实例。  Windows启动并安装一个新的ConHost实例 </li></ol></li><li>  cmd实例照常工作： <br><ol><li> 从sshd服务收集输入 </li><li> 工作吗 </li><li> 调用控制台API渲染/设置文本样式，移动光标等。 </li></ol></li><li> 实例ConPTY ConHost： <br><ol><li> 通过更新输出缓冲区进行API调用。 </li><li> 将输出缓冲区的更改区域显示为UTF-8编码的文本/ VT，并通过ssh发送回控制台/终端 </li></ol></li></ol><br> 对于sshd服务，使用ConPTY的这种方法显然更干净，更简单。  Windows控制台API的调用完全在命令行应用程序的ConHost实例中进行，该实例将所有可见的更改都转换为文本/ VT。 无论连接到ConHost的人是谁，他都不需要知道那里的应用程序会调用控制台API，并且不会生成文本/ VT！ <br><br> 同意这种新的ConPTY远程处理机制可以带来优雅，一致且简单的体系结构。 新的ConHost和ConPTY基础结构与ConHost内置的强大功能，对较旧的应用程序的支持以及对调用控制台控制台API的应用程序的更改（以文本/ VT形式显示）的显示相结合，可以帮助我们将过去推向未来。 <br><br><h1>  ConPTY API及其使用方法 </h1><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows 10 Insider Preview SDK</a>的当前版本中提供了ConPTY API。 </blockquote><br> 现在，我确定您已经迫不及待想要查看一些代码；） <br><br> 看一下API声明： <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br> 上面的API ConPTY本质上公开了三个新功能供使用： <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li> 使用调用者创建的通道在<code>w</code>列和<code>h</code>行中创建尺寸为pty的行： <br><ul><li>  <code>size</code> ：ConPTY缓冲区的宽度和高度（以字符为单位） </li><li>  <code>hInput</code> ：用于以UTF-8编码将输入数据作为文本/ VT序列写入PTY </li><li>  <code>hOutput</code> ：以UTF-8编码从PTY以文本/ VT序列的形式读取输出 </li><li>  <code>dwFlags</code> ：可能的值： <br><ul><li>  PSEUDOCONSOLE_INHERIT_CURSOR：创建的ConPTY将尝试继承父终端应用程序的光标位置 </li></ul></li><li>  <code>phPC</code> ：ConPty生成的控制台句柄 </li></ul></li><li>  <b>返回</b> ：成功/失败。 如果成功，则phPC将包含新ConPty的句柄 </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li> 调整内部ConPTY缓冲区的大小以显示特定的宽度和高度 </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   —   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API — ,       ,     Windows   …   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ConEmuMaximus5</a> —    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    —  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  «  VT»     ,      Console API (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    …   !  ,       , <b></b> !  ：D <br><br>       ,   , <i></i>    ,   <i></i>  .   —            ,          Windows  ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> Windows Console  GitHub</a> .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420853/">https://habr.com/ru/post/zh-CN420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420837/index.html">使用SNIA方法测试NVMe设备的软件RAID阵列</a></li>
<li><a href="../zh-CN420841/index.html">院前修复程序或“嘿招摇！ 我的错误在哪里？”</a></li>
<li><a href="../zh-CN420843/index.html">9月7日，叶卡捷琳堡-.NET开发人员会议</a></li>
<li><a href="../zh-CN420845/index.html">使用拐杖驯服顽固的家伙：Wi-Fi适配器WF2190（Realtek8812AU无线LAN 802.11ac USB）的孔</a></li>
<li><a href="../zh-CN420847/index.html">布局着色器编程简介</a></li>
<li><a href="../zh-CN420857/index.html">无缝的Wi-Fi漫游：实践中的理论</a></li>
<li><a href="../zh-CN420859/index.html">关于维尔斯和铁链的问题</a></li>
<li><a href="../zh-CN420861/index.html">为C ++做准备20。 协程TS真实案例研究</a></li>
<li><a href="../zh-CN420863/index.html">当我们制作第一部俄罗斯智能手机时，继续</a></li>
<li><a href="../zh-CN420865/index.html">最少动作的原则。 第一部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>