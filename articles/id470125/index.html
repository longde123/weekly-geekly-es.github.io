<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📊 🗝️ 🕝 Jangan menilai kode orang lain dengan ketat 🔳 🏦 🧜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kebetulan sebagian besar hidup saya yang saya program di PHP. Otak kita, memahami informasi dari sumber mana pun, melakukan ini tanpa gangguan dari ot...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jangan menilai kode orang lain dengan ketat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470125/"> Kebetulan sebagian besar hidup saya yang saya program di PHP.  Otak kita, memahami informasi dari sumber mana pun, melakukan ini tanpa gangguan dari otoritas sumber ini.  Secara kasar, jika Anda menyukai PHP - Anda secara otomatis menambahkan poin kredibilitas ke penulis artikel ini, dan jika Anda tidak suka - mereka secara otomatis mengambilnya.  Proses ini terjadi pada tingkat bawah sadar dan pada dasarnya adalah prisma persepsi, yang di satu sisi melindungi kita dari jatuh ke dalam analisis informasi tanpa batas dari setiap tingkat otoritas, tetapi di sisi lain membatasi kita dalam mencari informasi baru yang lebih relevan.  Yang terburuk adalah bahwa kredibilitas sumber jarang diperiksa pada tingkat yang disadari (karena butuh waktu dan sumber daya dalam bentuk kalori yang berharga), saya bisa dengan probabilitas yang sama dengan pengembang plus, ibu rumah tangga-juru masak, tukang ledeng tanpa putri, atau rekayasa genetika. kucing  Jangan menilai artikel saya dengan ketat, saya punya cakar. <br><br>  Hal yang sama berlaku untuk membaca kode orang lain: jika penulisnya duduk di sebelah kiri tahta Anda, telah bekerja di perusahaan Anda selama 10+ tahun dan menghasilkan satu nol lebih banyak dari Anda, ini sama sekali tidak sama dengan penulis yang dipecat karena sesuatu- itu buruk, dan Anda dipekerjakan di tempatnya.  Namun pada kenyataannya, kode di sana-sini hanya satu set byte yang akan berguna untuk dievaluasi tanpa mengacu pada otoritas sumber. <br><a name="habracut"></a><br>  Ketika kita membaca kode orang lain, berbagai macam emosi dapat mengunjungi kita: kekaguman, tawa, kejengkelan, kekecewaan, penolakan total.  Berguna untuk mengetahui bahwa manifestasi emosi apa pun dalam konteks apa pun adalah respons otomatis dari tingkat yang lebih rendah (pertama) dari sistem saraf, yang dibentuk secara evolusioner, diperlukan dalam lingkungan primitif.  Tugas utama dari jawaban semacam itu, dalam kasus emosi "negatif", adalah meluncurkan mekanisme aksi "pukul atau lari" dengan satu tujuan tunggal - untuk bertahan hidup.  Di lingkungan kantor kami saat ini, ketika menganalisis kode orang lain, jawaban seperti itu menjadi agak tidak berguna dan bahkan berbahaya, karena Anda menghabiskan waktu dan sumber daya yang berharga di atasnya, ditambah Anda mencemari otak Anda dengan neurotransmiter yang menurunkan kecerdasan Anda untuk kecepatan reaksi.  Berita baiknya adalah bahwa jawaban ini dapat diprogram ulang.  Anda dapat menekan reaksi emosional negatif, atau Anda dapat menginventarisasinya, misalnya, tertawa di tempat Anda dulu marah.  Tawa, tidak seperti amarah, mengeluarkan neurotransmiter yang baik, enak, bermanfaat yang memberikan kesenangan, memperkuat pengalaman dan memotivasi Anda untuk terus bekerja. <br><br>  Untuk memprogram ulang emosi, Anda perlu secara mental memasuki meta-posisi untuk mengevaluasi situasi Anda sendiri dan mengevaluasi diri sendiri alih-alih mengutuk kode orang lain.  Mengapa potongan kode orang lain ini membuat saya jijik?  Benarkah sang amatir yang menulisnya, dan sekarang saya harus menderita begitu baik dan berpengalaman?  Jika saya sangat baik dan berpengalaman, lalu mengapa saya mengalami masalah untuk memahami kode orang lain dan menulis ulang sesuai keinginan saya?  Mungkin saya tidak punya cukup RAM untuk mewujudkan mie ini?  Mungkin penulis artikel ini tahu sesuatu yang tidak saya ketahui? <br><br>  Alat pengembangan modern memungkinkan Anda mengubah kode orang lain menjadi struktur yang lebih mudah dimengerti dan menyenangkan.  Sebuah fungsi atau variabel tidak bernama - ctrl + shift + R dan dalam beberapa detik ini disebut baik.  Tab alih-alih spasi, lekukan yang tidak nyaman, lekukan yang tak biasa dan membuka kawat gigi dalam gaya Mesir - ctrl + shift + F dan pemformatan dipulihkan!  Komentar redundan atau ketinggalan jaman - ctrl + D dan tidak.  Jika Anda mengubah prisma persepsi, membaca kode orang lain dapat berubah menjadi permainan detektif interaktif yang menyenangkan. <br><br>  Kode hanyalah alat.  Tidak peduli betapa buruk dan buruknya ia ditulis, pada waktu tertentu dan di tempat tertentu ia berhasil memecahkan masalah tertentu, yang berarti ia sudah "dibenarkan."  Sesuatu telah berubah dalam persyaratan bisnis, sesuatu belum diperhitungkan - kode telah rusak atau menjadi usang, dan ini normal.  Kode memiliki kemampuan untuk berkembang dalam berbagai cara: dan secara bertahap, ditumbuhi lapisan dan revolusioner, menulis dari awal.  Tentu saja, ada baiknya ketika programmer melihat masa depan dan pada tahap awal ada kemungkinan pengembangan lebih lanjut.  Tapi kapak ini tajam di dua sisi, Anda dapat membuat kesalahan dengan memprediksi masa depan, masa depan mungkin tidak datang sama sekali, dan waktu dan sumber daya akan hilang.  Penting untuk memahami kode sampai tingkat kualitas apa yang dituntut dari Anda.  Jika ini adalah sistem terdistribusi besar, modul yang diprogram oleh kolega Anda dari seluruh dunia di perusahaan yang terhubung dengan Anda, maka ya, masuk akal untuk menggunakan pola modis, untuk membungkus modul dalam wadah layanan bahkan di mana Anda tidak dapat membayangkan mengapa ini perlu.  Tetapi jika ini adalah CRM lokal kecil untuk satu perusahaan, modul yang sangat saling tergantung satu sama lain sehingga menonaktifkan modul apa pun pada dasarnya menghentikan seluruh sistem dari bekerja ... dalam hal ini, dapat dibenarkan untuk memanggil metode orang lain secara langsung, ini akan mengurangi jumlah kelas dan memfasilitasi operasional Anda memori dan mengurangi waktu untuk men-debug masalah.  Tapi di sini muncul situasi ketika CRM lokal kecil berubah menjadi sesuatu yang dapat diperluas yang ingin dimasukkan perusahaan Anda ke domain publik dan dijual.  Persyaratan bisnis telah berubah.  Haruskah programmer disalahkan karena tidak melihat ini? <br><br><h2>  Standarisasi </h2><br>  Kode hanyalah alat, tetapi penciptaannya adalah kreativitas murni.  Masalah apa pun dapat diselesaikan dengan jumlah tak terbatas dari cara yang paling beragam.  Beberapa dari mereka lebih produktif daripada yang lain - contoh penilaian obyektif.  Beberapa dari mereka lebih mudah dibaca daripada yang lain - contoh penilaian subyektif.  Bahkan jika Anda meyakinkan seluruh kantor bahwa beberapa kode tidak dapat dibaca, masih ada setidaknya satu penulis yang tidak setuju dengan Anda.  Standarisasi kode ini bertujuan untuk mengubah kreativitas murni ke dalam serangkaian tindakan paling rutin sehingga lebih mudah bagi programmer lain untuk memahami kode Anda.  Itu sebenarnya, sehingga Anda dapat digantikan oleh spesialis lain, lebih patuh dan lebih murah.  Dan setelah beberapa dekade, itu sepenuhnya kecerdasan buatan.  Perlu diingat bahwa jika beberapa standar bertentangan dengan akal sehat, mungkin masuk akal untuk melanggarnya di beberapa tempat, atau bahkan sepenuhnya meninggalkannya atau menggantinya dengan yang lain, yang lebih cocok. <br><br>  Standar dewasa menjual diri mereka dari posisi "ketika memilih standar, perhatikan popularitas komunitas."  Saya bertanya-tanya bagaimana mereka menjual diri mereka ketika mereka baru saja keluar.  Gagasan utamanya adalah bahwa popularitas suatu standar tertentu bukanlah faktor yang ingin Anda pertimbangkan pertama-tama ketika memilih.  Popularitas dan komunitas sangat lembam dan selama beberapa dekade dapat menolak standar baru yang lebih baik.  Apalagi jika mereka revolusioner. <br><br>  Perhatian khusus diberikan pada standar yang telah benar-benar memantapkan diri mereka dalam budaya hanya karena standar tersebut muncul lebih awal dari standar serupa lainnya.  Contoh kanonik adalah perang suci antara tata letak QUERTY dan Dvorak.  Yang kedua, tentu saja, lebih baik, tetapi yang pertama memiliki pukulan (tetap lebih populer) hanya karena massa pengguna yang kritis yang tidak ingin berlatih kembali dengan yang baru. <br><br>  Contoh serupa ditemukan sepanjang dan dalam budaya pemrograman.  Standar PSR singkatan dari 4 spasi daripada tab, mengabaikan fakta yang jelas: lingkungan pengembangan sebagian besar programmer PHP telah berubah dari editor konsol ke IDE penuh, di mana menabrak lebih nyaman dalam banyak cara: lebih mudah untuk menghapusnya dengan menekan Backspace sekali, dan Anda dapat mengonfigurasi panjang masing-masing Tab sesuai selera. <br><br>  Saat menerapkan standar ini atau itu, ajukan pertanyaan: kepada siapa Anda membuatnya lebih nyaman?  Siapa yang lebih tidak nyaman?  Siapa yang akan mendapat manfaat dari aturan "nama nama-nama metode lowerKamelKeysom"?  Jelas hanya untuk mereka yang terbiasa memanggil mereka seperti itu.  Semua orang akan menjadi tidak nyaman, mereka harus beradaptasi, dan kehilangan waktu dan sumber daya ini benar-benar dari awal, mengingat kenyataan itu <br>  a) sekarang kami memiliki IDE ajaib yang menyoroti berbagai elemen kode dalam warna yang berbeda, <br>  b) programmer memiliki kemampuan untuk melompat dari proyek ke proyek, standar pengkodean yang dapat bervariasi. <br><br>  Secara pribadi, ketika mengembangkan proyek saya, saya menggunakan: <br><br><ul><li>  CamelCase untuk penamaan kelas dan metode </li><li>  $ CamelCase untuk variabel penamaan yang berisi instance dari objek </li><li>  $ snake_case untuk variabel penamaan yang berisi tipe sederhana </li></ul><br>  Saya tidak punya masalah membedakan nama kelas dari nama metode karena yang pertama adalah kata benda dan yang kedua adalah kata kerja.  Selain itu, lampu latar membantu.  Tapi ini selera pribadi saya, saya tidak memaksakannya pada siapa pun.  Ini adalah prisma persepsi pribadi, itu adalah individu untuk setiap kepala individu.  Seseorang “beruntung” untuk segera terjun ke standar populer, seseorang “tidak beruntung” memulai karir mereka dengan yang alternatif, dan seseorang umumnya mengembangkan sendiri.  Saya mengarahkan Anda pada fakta bahwa alih-alih melatih kembali orang lain, mungkin masuk akal untuk melatih diri untuk memahami kode dalam standar apa pun.  Atau bahkan di luar standar. <br>  Tentu saja, para penganut standardisasi di tempat ini akan marah dan melemparkan banyak alasan kepada saya.  Artikel ini bukan untuk mereka, saya menulisnya untuk mereka yang tertarik untuk memahami esensi hal-hal, mencoba membayangkan apa yang sebenarnya ada dalam pikiran penulis dan tujuan apa yang dia kejar. <br><br><h2>  Kemampuan untuk memahami kode orang lain </h2><br>  Pemicu yang menyebabkan impuls muntah di sebagian besar programer (contoh penilaian subyektif).  Tampaknya tidak pernah aneh bagi Anda bahwa sering kali lebih mudah bagi kami untuk menulis ulang semua kode dari awal daripada memahami orang lain?  Dalam industri lain, kita bertindak berbeda: pertama kita belajar membaca, lalu menulis;  penggunaan pertama (peralatan listrik, bangunan), kemudian desain mereka.  Sepertinya bagi saya intinya adalah dalam pendidikan kita (khususnya di bidang pemrograman).  Kami diajarkan untuk mencapai tujuan dengan cara yang paling langsung dan cepat, menggunakan pengetahuan yang baru diperoleh.  Sebagai hasilnya, kami menggabungkan mereka (pengetahuan) persis sampai "itu" bekerja, menguji sedikit dan mengirimkannya ke guru untuk moderasi.  Menurut pendapat saya, akan menyenangkan untuk menambahkan langkah tambahan untuk proses ini, di mana kami membandingkan kode kami dengan kode master, yang meskipun tidak ideal dan satu-satunya yang benar, tetapi memberikan solusi alternatif, seringkali lebih optimal dan dapat dibaca. <br><br>  Adapun pemicunya, untuk mematikannya, cukup dengan menempatkan diri Anda secara mental di tempat pelanggan, yang telah menyaksikan para programmer yang akan datang sepanjang hidupnya, mengklaim bahwa pekerjaan para pendahulu mereka adalah kotoran dan Anda perlu menulis ulang semuanya untuk menjadikannya baik.  Pelanggan tidak memiliki kompetensi untuk mengetahui apakah Anda mengatakan yang sebenarnya atau hanya malas untuk memahami kode orang lain.  Untuk mendapatkan kepercayaannya dalam masalah seperti itu, Anda harus mempelajari kode orang lain dan menemukan beberapa lubang keamanan raksasa dan menunjukkannya kepada pelanggan.  Tetapi bahkan dalam situasi ini, dari sudut pandang bisnis, mungkin lebih menguntungkan untuk "mengeras".  Terutama jika itu adalah outsourcing dengan tenggat waktu dan uang tertentu.  Haruskah programmer disalahkan untuk ini? <br><br><h2>  Kesimpulan </h2><br>  Wha, shcha menulis dengan huruf I.  Alih-alih sarapan, minum kopi dan mentega melalui blender. <br>  Lihat lebih dalam, pikirkan lebih luas, cari alternatif.  Jangan pernah berhenti berkembang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470125/">https://habr.com/ru/post/id470125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470109/index.html">@Pythonetc September 2019</a></li>
<li><a href="../id470113/index.html">Bagaimana teknologi di dalam memori telah mengubah kecerdasan bisnis</a></li>
<li><a href="../id470117/index.html">Bersiap untuk Berkombinasi</a></li>
<li><a href="../id470121/index.html">Perusahaan sekolah pemrograman atau cara memasukkan TI</a></li>
<li><a href="../id470123/index.html">Perangkap keuangan Yandex.Money</a></li>
<li><a href="../id470127/index.html">Komposer dengan memori jangka pendek yang panjang</a></li>
<li><a href="../id470129/index.html">Manajemen memori deklaratif</a></li>
<li><a href="../id470133/index.html">Cara mengumpulkan metrik yang tidak terdistorsi berdasarkan referensi waktu dengan Prometheus</a></li>
<li><a href="../id470135/index.html">Aplikasi web interaktif tanpa pemrograman? Mudah! Mavo di tangan Anda</a></li>
<li><a href="../id470139/index.html">2 life hacks: alternatif pencarian klasik di Microsoft SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>