<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÅ üí∑ ‚ÜñÔ∏è Anwendungskoordinator in iOS-Apps üò§ ‚¨ÖÔ∏è ‚è∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die iOS-Plattform wird jedes Jahr vielen √Ñnderungen unterzogen. Dar√ºber hinaus arbeiten Bibliotheken von Drittanbietern regelm√§√üig an der Arbeit mit d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anwendungskoordinator in iOS-Apps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423299/">  Die iOS-Plattform wird jedes Jahr vielen √Ñnderungen unterzogen. Dar√ºber hinaus arbeiten Bibliotheken von Drittanbietern regelm√§√üig an der Arbeit mit dem Netzwerk, dem Zwischenspeichern von Daten, dem Rendern der Benutzeroberfl√§che √ºber JavaScript und vielem mehr.  Im Gegensatz zu all diesen Trends sprach <strong>Pavel Gurov</strong> √ºber eine Architekturl√∂sung, die unabh√§ngig von den Technologien, die Sie jetzt oder in einigen Jahren verwenden, relevant sein wird. <br><br>  Mit ApplicationCoordinator k√∂nnen Sie die Navigation zwischen Bildschirmen erstellen und gleichzeitig eine Reihe von Problemen l√∂sen.  Unter der Katzendemo und Anweisungen zur schnellsten Umsetzung dieses Ansatzes. <br><br><img src="https://habrastorage.org/webt/xx/ok/ti/xxoktiysvlvnzl1zbhvivxccrry.jpeg"><br><br>  <strong>√úber den Sprecher:</strong> Pavel Gurov entwickelt iOS-Anwendungen in Avito. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  Navigation <br></h2><br><br><img src="https://habrastorage.org/webt/9d/dp/od/9ddpodzty4uclncm046g1ms9nvy.jpeg"><br><br>  Das Navigieren zwischen Bildschirmen ist eine Aufgabe, mit der 100% von Ihnen konfrontiert sind, egal was Sie tun - ein soziales Netzwerk, ein Taxi oder eine Online-Bank.  So beginnt die Anwendung bereits im Prototypenstadium, wenn Sie nicht einmal genau wissen, wie die Bildschirme aussehen, wie Animationen aussehen und ob die Daten zwischengespeichert werden.  Die Bildschirme k√∂nnen leere oder statische Bilder sein, aber <strong>die Navigationsaufgabe wird in der Anwendung angezeigt, sobald mehr als einer dieser Bildschirme vorhanden ist</strong> .  Das hei√üt, fast sofort. <br><br><img src="https://habrastorage.org/webt/um/r-/qo/umr-qogrmhhn58yvlaseyxqyrre.jpeg"><br><br>  Die g√§ngigsten Methoden zum Erstellen der Architektur von iOS-Anwendungen: MVc, MVVm und MVp beschreiben das Erstellen eines einzelnen Bildschirmmoduls.  Es hei√üt auch, dass die Module voneinander wissen, miteinander kommunizieren usw. k√∂nnen.  Es wird jedoch nur sehr wenig darauf geachtet, wie √úberg√§nge zwischen diesen Modulen vorgenommen werden, wer √ºber diese √úberg√§nge entscheidet und wie Daten √ºbertragen werden. <br><br><h2>  UlStoryboard + Segues <br></h2><br>  iOS out of the box bietet verschiedene M√∂glichkeiten, um das folgende Bildschirmszenario anzuzeigen: <br><br><ol><li>  Das bekannte <strong>UlStoryboard + wechselt</strong> , wenn wir alle √úberg√§nge zwischen Bildschirmen in einer Metadatei <strong>festlegen</strong> und sie dann aufrufen.  Alles ist sehr praktisch und gro√üartig. </li><li>  Container - wie der UINavigationController.  UITabBarController, UIPageController oder m√∂glicherweise selbstgeschriebene Container, die sowohl programmgesteuert als auch zusammen mit StoryBoards verwendet werden k√∂nnen. </li><li>  Methode vorhanden (_: animiert: Vervollst√§ndigung :).  Dies ist nur eine Methode der UIController-Klasse. </li></ol><br>  Es gibt keine Probleme mit diesen Tools.  Das Problem ist genau, wie sie h√§ufig verwendet werden.  UINavigationController, performSegue, prepareForSegue und presentViewController sind alle Eigenschaftsmethoden der UIViewController-Klasse.  Apple schl√§gt vor, diese Tools im UIViewController selbst zu verwenden. <br><br><img src="https://habrastorage.org/webt/gy/_n/vb/gy_nvb7uettqb7xdoillr3ud3m4.jpeg"><br><br>  Der Beweis daf√ºr ist der folgende. <br><br><img src="https://habrastorage.org/webt/hv/cq/6p/hvcq6prwv2si1cyrpqkiwchlwds.jpeg"><br><br>  Dies sind Kommentare, die in Ihrem Projekt angezeigt werden, wenn Sie eine neue Unterklasse von UIViewController mithilfe einer Standardvorlage erstellen.  Es wird direkt geschrieben. Wenn Sie Segues verwenden und Daten entsprechend dem Szenario auf den n√§chsten Bildschirm √ºbertragen m√ºssen, sollten Sie: diesen ViewController von Segues abrufen;  wissen, welcher Typ es sein wird;  Wirf es auf diesen Typ und gib deine Daten dort weiter. <br><br>  Dieser Ansatz f√ºr Probleme bei der Geb√§udenavigation. <br><br>  <strong>1. Starre Konnektivit√§t von Bildschirmen</strong> <br><br>  Dies bedeutet, dass Bildschirm 1 √ºber die Existenz von Bildschirm 2 Bescheid wei√ü. Er wei√ü nicht nur √ºber seine Existenz Bescheid, er erstellt ihn m√∂glicherweise auch oder nimmt ihn aus dem √úbergang, wei√ü, um welchen Typ es sich handelt, und √ºbertr√§gt einige Daten an ihn. <br><br>  Wenn wir unter bestimmten Umst√§nden Bildschirm 3 anstelle von Bildschirm 2 anzeigen m√ºssen, m√ºssen wir den neuen Bildschirm 3 auf die gleiche Weise kennen, um ihn in Bildschirmcontroller 1 zu integrieren. Alles wird noch schwieriger, wenn die Controller 2 und 3 nicht nur von mehreren Stellen aus aufgerufen werden k√∂nnen von Bildschirm 1. Es stellt sich heraus, dass das Wissen √ºber Bildschirm 2 und 3 an jeder dieser Stellen zusammengen√§ht werden muss. <br><br>  Um dies zu tun, ist eine weitere H√§lfte des Problems. Die Hauptprobleme beginnen, wenn √Ñnderungen an diesen √úberg√§ngen vorgenommen oder all dies unterst√ºtzt werden m√ºssen. <br><br><img src="https://habrastorage.org/webt/nx/34/yw/nx34ywvotea8yovx9xuuaxp2lro.jpeg"><br><br>  <strong>2. Ordnen Sie die Skript-Controller neu an</strong> <br><br>  Dies ist auch wegen der Verbindung nicht so einfach.  Um zwei ViewController auszutauschen, reicht es nicht aus, in das UlStoryboard zu wechseln und zwei Bilder auszutauschen.  Sie m√ºssen den Code f√ºr jeden dieser Bildschirme √∂ffnen, ihn auf die Einstellungen des n√§chsten √ºbertragen und seine Positionen √§ndern, was nicht sehr praktisch ist. <br><br><img src="https://habrastorage.org/webt/lz/_g/n6/lz_gn6x_emphixjobmg-cezayqa.jpeg"><br><br>  <strong>3. Daten√ºbertragung gem√§√ü Szenario</strong> <br><br>  Wenn Sie beispielsweise etwas auf Bildschirm 3 ausw√§hlen, m√ºssen Sie die Ansicht auf Bildschirm 1 aktualisieren. Da wir anfangs nur einen ViewController haben, m√ºssen wir die beiden ViewController - egal wie - irgendwie durch Delegierung oder irgendwie verbinden noch.  Es wird noch schwieriger, wenn gem√§√ü der Aktion auf Bildschirm 3 nicht ein Bildschirm, sondern mehrere gleichzeitig aktualisiert werden m√ºssen, beispielsweise der erste und der zweite. <br><br><img src="https://habrastorage.org/webt/wy/gz/gr/wygzgrppqbr4dc6tszklinog714.jpeg"><br><br>  In diesem Fall kann auf die Delegierung nicht verzichtet werden, da die Delegierung eine Eins-zu-Eins-Beziehung ist.  Jemand wird sagen, verwenden wir die Benachrichtigung, jemand - √ºber einen gemeinsamen Status.  All dies macht es schwierig, Datenfl√ºsse in unserer Anwendung zu debuggen und zu verfolgen. <br><br>  Wie sie sagen, ist es besser, einmal zu sehen als 100 Mal zu h√∂ren.  Schauen wir uns ein spezielles Beispiel aus dieser Avito Services Pro-Anwendung an.  Diese Anwendung richtet sich an Fachleute im Dienstleistungssektor, in denen es bequem ist, Ihre Bestellungen zu verfolgen, mit Kunden zu kommunizieren und nach neuen Bestellungen zu suchen. <br><br>  Szenario - Auswahl einer Stadt beim Bearbeiten eines Benutzerprofils. <br><br><img src="https://habrastorage.org/webt/0j/cd/zn/0jcdznc3-8b7fy9lliaairh1s_u.jpeg"><br><br>  Hier ist ein Profilbearbeitungsbildschirm, wie er in vielen Anwendungen verwendet wird.  Wir sind an einer Stadt interessiert. <br><br>  Was ist hier los? <br><br><ul><li>  Der Benutzer klickt auf die Zelle mit der Stadt und der erste Bildschirm entscheidet, dass es Zeit ist, den folgenden Bildschirm zum Navigationsstapel hinzuzuf√ºgen.  Dies ist ein Bildschirm mit einer Liste der Bundesst√§dte (Moskau und St. Petersburg) und einer Liste der Regionen. </li><li>  Wenn der Benutzer auf dem zweiten Bildschirm eine Bundesstadt ausw√§hlt, versteht der zweite Bildschirm, dass das Skript abgeschlossen wurde, leitet die ausgew√§hlte Stadt an die erste weiter und der Navigationsstapel rollt zur√ºck zum ersten Bildschirm.  Das Skript wird als vollst√§ndig betrachtet. </li><li>  Wenn der Benutzer einen Bereich auf dem zweiten Bildschirm ausw√§hlt, entscheidet der zweite Bildschirm, dass ein dritter Bildschirm vorbereitet werden muss, in dem eine Liste der St√§dte in diesem Bereich angezeigt wird.  Wenn der Benutzer eine Stadt ausw√§hlt, wird diese Stadt zum ersten Bildschirm gesendet, rollt den Navigationsstapel und das Skript wird als vollst√§ndig betrachtet. </li></ul><br>  In diesem Diagramm werden die zuvor erw√§hnten Konnektivit√§tsprobleme als Pfeile zwischen dem ViewController angezeigt.  Wir werden diese Probleme jetzt loswerden. <br><br>  <strong>Wie machen wir das?</strong> <br><br><ol><li>  Wir <strong>verbieten uns im UIViewController, auf Container</strong> zuzugreifen, dh auf self.navigationController, self.tabBarController oder andere benutzerdefinierte Container, die Sie als Eigenschaftserweiterung erstellt haben.  Jetzt k√∂nnen wir unseren Container nicht mehr aus dem Bildschirmcode nehmen und ihn bitten, etwas zu tun. <br><br><img src="https://habrastorage.org/webt/av/ci/0x/avci0xx4juu-sitqkcidwmo5woi.jpeg"><br></li><li>  <strong>Wir verbieten uns im UIViewController, die performSegue-Methode aufzurufen</strong> und Code in die prepareForSegue-Methode zu schreiben, wodurch der Bildschirm, der dem Skript folgt, konfiguriert wird.  Das hei√üt, wir arbeiten nicht mehr mit Segue (mit √úberg√§ngen zwischen Bildschirmen) im UIViewController. <br><br><img src="https://habrastorage.org/webt/xp/lh/kq/xplhkqdhp61csbpdmvaulmonqra.jpeg"><br></li><li>  Wir <strong>verbieten</strong> auch <strong>die Erw√§hnung anderer Controller in unserem spezifischen Controller</strong> : keine Initialisierungen, Daten√ºbertragungen und das ist alles. <br><br><img src="https://habrastorage.org/webt/cr/0_/j9/cr0_j999w13tkk8szf2wh1xbjsm.jpeg"><br></li></ol><br><br><h2>  Koordinator <br></h2><br>  Da wir alle diese Verantwortlichkeiten aus dem UIViewController entfernen, ben√∂tigen wir eine neue Entit√§t, die sie ausf√ºhrt.  Erstellen Sie eine neue Klasse von Objekten und nennen Sie sie den Koordinator. <br><br><img src="https://habrastorage.org/webt/ta/ub/t6/taubt6cqzz4_lviz88jbgih3jf4.jpeg"><br><br>  Der Koordinator ist nur ein gew√∂hnliches Objekt, an das wir zu Beginn des NavigationControllers √ºbergeben und die Start-Methode aufrufen.  Denken Sie jetzt nicht dar√ºber nach, wie es implementiert wird, sondern schauen Sie sich an, wie sich das Szenario f√ºr die Auswahl einer Stadt in diesem Fall √§ndern wird. <br><br>  Jetzt beginnt es nicht damit, dass wir den √úbergang zu einem bestimmten NavigationController-Bildschirm vorbereiten, sondern wir rufen die Start-Methode beim Koordinator auf und √ºbergeben sie zuvor im NavigationController-Initialisierer.  Der Koordinator versteht, dass es Zeit f√ºr den NavigationController ist, den ersten Bildschirm zu starten, was er auch tut. <br><br>  Wenn der Benutzer eine Zelle mit einer Stadt ausw√§hlt, wird dieses Ereignis an den Koordinator weitergeleitet.  Das hei√üt, der Bildschirm selbst wei√ü nichts - danach, wie man so sagt, zumindest eine Flut.  Er sendet diese Nachricht an den Koordinator, und der Koordinator reagiert darauf mit (da er √ºber einen Navigationscontroller verf√ºgt), der den n√§chsten Schritt an ihn sendet - dies ist die Auswahl der Regionen. <br><br>  Als n√§chstes klickt der Benutzer auf "Region" - genau das gleiche Bild - der Bildschirm selbst l√∂st nichts, teilt dem Koordinator nur mit, dass der n√§chste Bildschirm ge√∂ffnet wird. <br><br>  Wenn der Benutzer auf dem dritten Bildschirm eine bestimmte Stadt ausw√§hlt, wird diese Stadt √ºber den Koordinator auch auf den ersten Bildschirm √ºbertragen.  Das hei√üt, eine Nachricht wird an den Koordinator gesendet, dass eine Stadt ausgew√§hlt wurde.  Der Koordinator sendet diese Nachricht an den ersten Bildschirm und rollt den Navigationsstapel auf den ersten Bildschirm. <br><br>  Beachten Sie, dass die <strong>Controller nicht mehr miteinander kommunizieren</strong> , entscheiden, wer als n√§chstes kommt, und keine Daten untereinander √ºbertragen.  Au√üerdem wissen sie nichts √ºber ihre Umgebung. <br><br><img src="https://habrastorage.org/webt/uz/sy/uo/uzsyuorkw837chi1zn8s39hdkw0.jpeg"><br><br>  Wenn wir die Anwendung im Rahmen einer dreischichtigen Architektur betrachten, sollte der ViewController idealerweise vollst√§ndig in die Pr√§sentationsschicht passen und die Anwendungslogik so wenig wie m√∂glich enthalten. <br><br>  In diesem Fall verwenden wir den Koordinator, um die Logik der √úberg√§nge in die dar√ºber liegende Ebene herauszuholen und dieses Wissen aus dem ViewController zu entfernen. <br><br><h2>  Demo <br></h2><br>  Ein Pr√§sentations- und Demo- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> ist auf Github verf√ºgbar. Nachfolgend finden Sie eine Demonstration w√§hrend des Vortrags. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dies ist das gleiche Szenario: Bearbeiten eines Profils und Ausw√§hlen einer Stadt darin. <br><br>  Der erste Bildschirm ist der Benutzerbearbeitungsbildschirm.  Es werden Informationen zum aktuellen Benutzer angezeigt: Name und ausgew√§hlte Stadt.  Es gibt eine Schaltfl√§che "W√§hlen Sie eine Stadt."  Wenn wir darauf klicken, gelangen wir zum Bildschirm mit einer Liste der St√§dte.  Wenn wir dort eine Stadt ausw√§hlen, erh√§lt der erste Bildschirm diese Stadt. <br><br>  Mal sehen, wie das im Code funktioniert.  Beginnen wir mit dem Modell. <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">City?</span></span> }</code> </pre> <br>  <strong>Die Modelle sind</strong> einfach: <br><br><ol><li>  Eine Stadtstruktur mit einem Feldnamen, einer Zeichenfolge; </li><li>  Ein Benutzer, der auch einen Namen und eine Eigentumsstadt hat. </li></ol><br>  Als n√§chstes kommt <strong>StoryBoard</strong> .  Es beginnt mit einem NavigationController.  Im Prinzip sind hier dieselben Bildschirme wie im Simulator: ein Benutzerbearbeitungsbildschirm mit einer Beschriftung und einer Schaltfl√§che sowie ein Bildschirm mit einer Liste von St√§dten, auf dem ein Tablet mit St√§dten angezeigt wird. <br><br><h4>  Benutzerbearbeitungsbildschirm <br></h4><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditViewController: UIViewController, UpdateableWithUser { // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> - var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { didSet { updateView() } } // MARK: - Output - var onSelectCity: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? @IBOutlet private weak var userLabel: UILabel? @IBAction private func selectCityTap(_ sender: UIButton) { onSelectCity?() } override func viewWillAppear(_ animated: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) { super.viewWillAppear(animated) updateView() } private func updateView() { userLabel?.text = "User: \(user?.name ?? ""), \n" + "City: \(user?.city?.name ?? "")" } }</code> </pre><br>  Hier gibt es eine Eigenschaft Benutzer - dies ist der Benutzer, der au√üerhalb √ºbertragen wird - der Benutzer, den wir bearbeiten werden.  Wenn Sie hier den Benutzer festlegen, wird der didSet-Block aufgerufen, was zu einem Aufruf der lokalen updateView () -Methode f√ºhrt.  Alles, was diese Methode tut, ist einfach Informationen √ºber den Benutzer auf das Etikett zu setzen, dh seinen Namen und den Namen der Stadt anzuzeigen, in der dieser Benutzer lebt. <br><br>  Das gleiche passiert in der viewWillAppear () -Methode. <br><br>  Der interessanteste Ort ist der Handler zum Klicken auf die Schaltfl√§che Stadtauswahl selectCityTap ().  <strong>Hier l√∂st der Controller selbst nichts</strong> : Er erstellt keine Controller, ruft keinen Segue auf.  Alles, was er tut, ist ein R√ºckruf - dies ist die zweite Eigenschaft unseres ViewControllers.  Der onSelectCity-R√ºckruf hat keine Parameter.  Wenn der Benutzer auf die Schaltfl√§che klickt, wird dieser R√ºckruf aufgerufen. <br><br><h4>  Stadtauswahlbildschirm <br></h4><br><pre> <code class="hljs powershell">import UIKit final <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CitiesViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span></span> { // MARK: - Output - var onCitySelected: ((City) -&gt; Void)? // MARK: - Private variables - private let cities: [<span class="hljs-type"><span class="hljs-type">City</span></span>] = [<span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Moscow"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ulyanovsk"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"New York"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span>)] // MARK: - Table - override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cities.count } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-string"><span class="hljs-string">"cell"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) cell.textLabel?.text = cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>].name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { onCitySelected?(cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>]) } }</code> </pre><br>  Dieser Bildschirm ist ein UITableViewController.  Die Liste der St√§dte hier ist festgelegt, kann aber von einem anderen Ort stammen.  Weiter (// MARK: - Table -) ist ein ziemlich trivialer Tabellencode, der eine Liste von St√§dten in Zellen anzeigt. <br><br>  Der interessanteste Ort hier ist der didSelectRowAt IndexPath-Handler, eine bekannte Methode f√ºr alle.  Hier l√∂st der Bildschirm selbst wieder nichts.  Was passiert nach Auswahl der Stadt?  Es ruft einfach einen R√ºckruf mit einem einzelnen Parameter "Stadt" auf. <br><br>  Dies beendet den Code f√ºr die Bildschirme selbst.  Wie wir sehen, wissen sie nichts √ºber ihre Umgebung. <br><br><h4>  Koordinator <br></h4><br>  Kommen wir zum Link zwischen diesen Bildschirmen. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol UpdateableWithUser: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } } final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditCoordinator { // MARK: - Properties private var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> { didSet { updateInterfaces() } } private weak var navigationController: UINavigationController? // MARK: - Init init(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, navigationController: UINavigationController) { self.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> self.navigationController = navigationController } func <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() { showUserEditScreen() } // MARK: - Private implementation private func showUserEditScreen() { let controller = UIStoryboard.makeUserEditController() controller.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> controller.onSelectCity = { [weak self] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.showCitiesScreen() } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } private func showCitiesScreen() { let controller = UIStoryboard.makeCitiesController() controller.onCitySelected = { [weak self] city <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.city = city _ = self?.navigationController?.popViewController(animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } private func updateInterfaces() { navigationController?.viewControllers.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { (<span class="hljs-meta"><span class="hljs-meta">$0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UpdateableWithUser)?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> } } }</code> </pre><br>  Der Koordinator hat zwei Eigenschaften: <br><br><ol><li>  Benutzer - der Benutzer, den wir bearbeiten werden; </li><li>  Der NavigationController, an den beim Start √ºbergeben werden soll. </li></ol><br>  Es gibt ein einfaches init (), das diese Eigenschaft auff√ºllt. <br><br>  Als n√§chstes folgt die Methode start (), mit der die Methode <strong>ShowUserEditScreen () aufgerufen wird</strong> .  Lassen Sie uns n√§her darauf eingehen.  Diese Methode nimmt den Controller aus UIStoryboard und √ºbergibt ihn an unseren lokalen Benutzer.  Dann setzt er den SelectCity-R√ºckruf ein und schiebt diesen Controller in den Navigationsstapel. <br><br>  Nachdem der Benutzer auf die Schaltfl√§che geklickt hat, wird der onSelectCity-R√ºckruf ausgel√∂st, wodurch die folgende private <strong>ShowCitiesScreen ()</strong> -Methode <strong>aufgerufen wird</strong> . <br><br>  Tats√§chlich macht es fast dasselbe - es hebt einen etwas anderen Controller vom UIStoryboard ab, setzt den onCitySelected-R√ºckruf darauf und schiebt ihn in den Navigationsstapel - das ist alles, was passiert.  Wenn der Benutzer eine bestimmte Stadt ausw√§hlt, wird dieser R√ºckruf ausgel√∂st, der Koordinator aktualisiert das Feld "Stadt" unseres lokalen Benutzers und rollt den Navigationsstapel zum ersten Bildschirm. <br><br>  Da User eine Struktur ist, f√ºhrt das Aktualisieren des Feldes "city" dazu, dass der didSet-Block aufgerufen wird bzw. die private Methode <strong>updateInterfaces ()</strong> aufgerufen wird.  Diese Methode durchl√§uft den gesamten Navigationsstapel und versucht, jeden ViewController als UpdateableWithUser-Protokoll bereitzustellen.  Dies ist das einfachste Protokoll, das nur eine Eigenschaft hat - Benutzer.  Wenn dies erfolgreich ist, wirft er es an den aktualisierten Benutzer.  Somit stellt sich heraus, dass unser ausgew√§hlter Benutzer auf dem zweiten Bildschirm automatisch zum ersten Bildschirm springt. <br><br>  Mit dem Koordinator ist alles klar, und das einzige, was hier noch zu zeigen ist, ist der Einstiegspunkt in unsere Bewerbung.  Hier f√§ngt alles an.  In diesem Fall ist dies die didFinishLaunchingWithOptions-Methode unseres AppDelegate. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit @UIApplicationMain <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppDelegate: UIResponder, UIApplicationDelegate { var <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: UIWindow? var coordinator: UserEditCoordinator! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]?) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { guard let navigationController = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>?.rootViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UINavigationController <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Pavel Gurov", city: City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Moscow")) coordinator = UserEditCoordinator(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, navigationController: navigationController) coordinator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } }</code> </pre><br>  Hier wird der Navigationscontroller aus dem UIStoryboard entnommen, ein Benutzer erstellt, den wir bearbeiten, mit einem Namen und einer bestimmten Stadt.  Als n√§chstes erstellen wir unseren Koordinator mit User und NavigationController.  Es ruft die start () -Methode auf.  Der Koordinator wird auf das lokale Grundst√ºck √ºbertragen - das ist im Grunde alles.  Das Schema ist recht einfach. <br><br><h4>  Ein- und Ausg√§nge <br></h4><br>  Es gibt einige Punkte, auf die ich n√§her eingehen m√∂chte.  Sie haben wahrscheinlich bemerkt, dass die Eigenschaft in userEditViewController mit einem Kommentar als Eingabe markiert ist und die R√ºckrufe dieser Controller als Ausgabe markiert sind. <br><br><img src="https://habrastorage.org/webt/xs/_v/kr/xs_vkrwlnwgvdyneeeijb2xsrm0.jpeg"><br><br>  <strong>Eine Eingabe</strong> sind alle Daten, die sich im Laufe der Zeit √§ndern k√∂nnen, sowie einige ViewController-Methoden, die von au√üen aufgerufen werden k√∂nnen.  In UserEditViewController ist dies beispielsweise eine User-Eigenschaft - der Benutzer selbst oder sein City-Parameter k√∂nnen sich √§ndern. <br><br>  <strong>Ein Exit</strong> ist ein Ereignis, das der Controller mit der Au√üenwelt kommunizieren m√∂chte.  In UserEditViewController ist dies ein Klick auf die Schaltfl√§che onSelectCity und auf dem Bildschirm zur Stadtauswahl ein Klick auf eine Zelle mit einer bestimmten Stadt.  Ich wiederhole, die Hauptidee hier ist, dass der Controller nichts wei√ü und nichts gegen diese Ereignisse unternimmt.  Er delegiert, um zu entscheiden, was zu tun ist, an jemand anderen. <br><br>  In Objective-C habe ich es wegen ihrer schrecklichen Syntax nicht wirklich gemocht, Save Callbacks zu schreiben.  In Swift ist dies jedoch viel einfacher.  Die Verwendung von R√ºckrufen ist in diesem Fall eine Alternative zum bekannten Delegierungsmuster in iOS.  Nur hier k√∂nnen wir, anstatt Methoden im Protokoll zu bestimmen und zu sagen, dass der Koordinator diesem Protokoll entspricht, und diese Methoden dann irgendwo separat schreiben, sofort sehr bequem eine Entit√§t an einem Ort erstellen, einen R√ºckruf darauf setzen und alles tun. <br><br>  Bei diesem Ansatz besteht im Gegensatz zur Delegierung zwar eine enge Verbindung zwischen dem Wesen des Koordinators und dem Bildschirm, da der Koordinator wei√ü, dass es ein bestimmtes Wesen des Bildschirms gibt. <br><br>  Sie k√∂nnen dies auf die gleiche Weise wie bei der Delegierung mithilfe von Protokollen beseitigen. <br><br><img src="https://habrastorage.org/webt/a-/nm/aa/a-nmaaf8uwdvujtzcvhjmfz0k2c.jpeg"><br><br>  Um Konnektivit√§t zu vermeiden, k√∂nnen wir <strong>den</strong> <strong>Ein- und</strong> <strong>Ausgang unseres Controllers mit einem Protokoll schlie√üen</strong> . <br><br>  Oben ist das CitiesOutput-Protokoll aufgef√ºhrt, f√ºr das genau eine Anforderung gilt: der onCitySelected-R√ºckruf.  Links ist ein Analogon dieses Schemas auf Swift.  Unser Controller h√§lt dieses Protokoll ein und ermittelt den erforderlichen R√ºckruf.  Wir tun dies, damit der Koordinator nichts √ºber die Existenz der CitiesViewController-Klasse wei√ü.  Aber irgendwann muss er den Ausgang dieses Controllers konfigurieren.  Um alles anzukurbeln, f√ºgen wir dem Koordinator eine Fabrik hinzu. <br><br><img src="https://habrastorage.org/webt/vx/hl/0v/vxhl0vp5g0pybl5_6pbasirpfby.jpeg"><br><br>  Die Factory verf√ºgt √ºber eine cityOutput () -Methode.  Es stellt sich heraus, dass unser Koordinator keinen Controller erstellt und ihn nicht von irgendwoher erh√§lt.  Eine Fabrik wirft es auf ihn, das ein Objekt zur√ºckgibt, das durch das Protokoll in der Methode geschlossen wurde, und er wei√ü nichts dar√ºber, welche Klasse dieses Objekt ist. <br><br>  Nun das Wichtigste - warum das alles?  <strong>Warum m√ºssen wir ein weiteres zus√§tzliches Level einbauen, wenn es sowieso keine Probleme gab?</strong> <br><br>  Man kann sich diese Situation vorstellen: Ein Manager wird zu uns kommen und Sie bitten, A / B-Tests durchzuf√ºhren, um festzustellen, dass wir anstelle einer Liste von St√§dten die Wahl einer Stadt auf der Karte haben w√ºrden.  Wenn in unserer Anwendung die Wahl der Stadt nicht an einem Ort, sondern in verschiedenen Koordinatoren, in verschiedenen Szenarien getroffen wurde, mussten wir an jedem Ort eine Flagge n√§hen, sie nach drau√üen werfen und auf dieser Flagge entweder den einen oder den anderen ViewController hissen.  Dies ist nicht sehr praktisch. <br><br>  Wir m√∂chten dieses Wissen vom Koordinator entfernen.  Daher k√∂nnte man dies an einem Ort tun.  In der Fabrik selbst w√ºrden wir einen Parameter erstellen, mit dem die Fabrik entweder den einen oder den anderen vom Protokoll geschlossenen Controller zur√ºckgibt.  Beide h√§tten einen R√ºckruf bei CitySelected, und dem Koordinator w√§re es im Prinzip egal, mit welchem ‚Äã‚Äãdieser Bildschirme er arbeiten m√∂chte - einer Karte oder einer Liste. <br><br><h2>  Zusammensetzung VS Vererbung <br></h2><br>  Der n√§chste Punkt, auf den ich eingehen wollte, ist die Komposition gegen Vererbung. <br><br><img src="https://habrastorage.org/webt/l5/9m/qg/l59mqgla1anz9rqv3sla16adtiw.jpeg"><br><br><ol><li>  Die erste Methode, wie unser Koordinator ausgef√ºhrt werden kann, besteht darin <strong>, die Komposition zu</strong> erstellen, wenn der NavigationController von au√üen an ihn √ºbergeben und lokal als Eigenschaft gespeichert wird.  Dies ist wie eine Komposition - wir haben einen NavigationController als Eigenschaft hinzugef√ºgt. </li><li>  Auf der anderen Seite gibt es die Meinung, dass alles im UI-Kit enthalten ist und wir das Rad nicht neu erfinden m√ºssen.  Sie k√∂nnen <strong>den UI</strong> <strong>NavigationController</strong> einfach √ºbernehmen und <strong>erben</strong> . </li></ol><br>  Jede Option hat ihre Vor- und Nachteile, aber pers√∂nlich scheint mir die <strong>Zusammensetzung in diesem Fall besser geeignet zu sein</strong> als die Vererbung.  Vererbung ist im Allgemeinen ein weniger flexibles Schema.  Wenn wir beispielsweise die Navigation beispielsweise in UIPageController √§ndern m√ºssen, k√∂nnen wir sie im ersten Fall einfach mit einem gemeinsamen Protokoll schlie√üen, z. B. "N√§chsten Bildschirm anzeigen", und den ben√∂tigten Container bequem ersetzen. <br><br>  Aus meiner Sicht ist das wichtigste Argument, dass Sie alle unn√∂tigen Methoden vor dem Endbenutzer in der Komposition verbergen.  Es stellt sich heraus, dass er weniger wahrscheinlich stolpert.  Sie belassen <strong>nur die</strong> <strong>API, die ben√∂tigt wird</strong> , z. B. die Start-Methode - und das ist alles.  Er hat keine M√∂glichkeit, den PushViewController, die PopViewController-Methode, aufzurufen, dh die Aktivit√§ten des Koordinators irgendwie zu st√∂ren.  Alle Methoden der √ºbergeordneten Klasse sind ausgeblendet. <br><br><h2>  Storyboards <br></h2><br>  Ich glaube, dass sie neben Segues besondere Aufmerksamkeit verdienen.  Pers√∂nlich unterst√ºtze <strong>ich</strong> <strong>Segues</strong> , da Sie sich so schnell mit dem Skript vertraut machen k√∂nnen.  Wenn ein neuer Entwickler eintrifft, muss er den Code nicht erklimmen. Storyboards helfen dabei.  Selbst wenn Sie eine Schnittstelle mit dem Code erstellen, k√∂nnen Sie den leeren ViewController verlassen und die Schnittstelle mit dem Code erstellen, aber mindestens die √úberg√§nge und den ganzen Punkt belassen.  Die gesamte Essenz von Storyboards liegt in den √úberg√§ngen selbst und nicht im Layout der Benutzeroberfl√§che. <br><br>  Gl√ºcklicherweise <strong>schr√§nkt</strong> der <strong>Koordinatoransatz die Auswahl der Werkzeuge nicht ein</strong> .  Wir k√∂nnen sicher Koordinatoren zusammen mit Segues verwenden.  Aber wir m√ºssen uns daran erinnern, dass wir jetzt nicht mehr mit Segues im UIViewController arbeiten k√∂nnen. <br><br><img src="https://habrastorage.org/webt/hp/sl/qp/hpslqpf2-het-coms7wczezguo8.jpeg"><br><br>  Daher m√ºssen wir die onPrepareForSegue-Methode in unserer Klasse √ºberschreiben.  Anstatt etwas innerhalb des Controllers zu tun, werden wir diese Aufgaben √ºber den R√ºckruf erneut an den Koordinator delegieren.  Die onPrepareForSegue-Methode wird aufgerufen. Sie tun nichts selbst. Sie wissen nicht, um welche Art von Segue es sich handelt, um welchen Ziel-Controller es sich handelt. Es spielt f√ºr Sie keine Rolle.  Sie werfen einfach alles in einen R√ºckruf, und der Koordinator wird es herausfinden.  Er hat dieses Wissen, du brauchst dieses Wissen nicht. <br><br>  Um alles einfacher zu machen, k√∂nnen Sie dies in einer bestimmten Basisklasse tun, um es nicht in jedem Controller einzeln zu √ºberschreiben.  In diesem Fall ist es f√ºr den Koordinator bequemer, mit Ihren Segues zu arbeiten. <br><br>  Eine andere Sache, die ich mit dem Storyboard bequem finde, ist die Einhaltung der Regel, dass <strong>ein</strong> <strong>Storyboard einem Koordinator entspricht</strong> .  Dann k√∂nnen Sie alles erheblich vereinfachen, eine Klasse im Allgemeinen erstellen - den StoryboardCoordinator - und den RootType-Parameter darin generieren, den anf√§nglichen Navigationscontroller im Storyboard erstellen und das gesamte Skript darin einschlie√üen. <br><br><img src="https://habrastorage.org/webt/sm/v2/wz/smv2wzspn7ykrajsui8npmfvcls.jpeg"><br><br>  Wie Sie sehen k√∂nnen, hat der Koordinator hier 2 Eigenschaften: navigationController;  Der rootViewController unseres RootType ist generisch.  W√§hrend der Initialisierung √ºbergeben wir ihm keinen bestimmten Navigationscontroller, sondern ein Storyboard, von dem unsere Root-Navigation und sein erster Controller stammen.  Auf diese Weise m√ºssen wir nicht einmal Startmethoden aufrufen.  Das hei√üt, Sie haben einen Koordinator erstellt, er hat sofort Navigation und sofort Root.  Sie k√∂nnen die Navigation entweder modal anzeigen oder Root √ºbernehmen und in die vorhandene Navigation verschieben und weiterarbeiten. <br><br>  Unser UserEditCoordinator wird in diesem Fall einfach zu Typealias und ersetzt den Typ seines RootViewControllers durch den generischen Parameter. <br><br><h2>  Skriptdaten√ºbertragung zur√ºck <br></h2><br>  Lassen Sie uns √ºber die L√∂sung des letzten Problems sprechen, das ich am Anfang skizziert habe.  Dies ist die √úbertragung von Daten zur√ºck zum Skript. <br><br><img src="https://habrastorage.org/webt/i6/i9/el/i6i9el9jdxqnjqp2pe80epk27iy.jpeg"><br><br>  Stellen Sie sich dasselbe Szenario f√ºr die Auswahl einer Stadt vor, aber jetzt k√∂nnen Sie nicht eine Stadt, sondern mehrere ausw√§hlen.  Um dem Benutzer anzuzeigen, dass er mehrere St√§dte innerhalb derselben Region ausgew√§hlt hat, wird auf dem Bildschirm mit einer Liste von Regionen eine kleine Zahl neben dem Namen der Region angezeigt, die die Anzahl der in dieser Region ausgew√§hlten St√§dte anzeigt. <br><br>  Es stellt sich heraus, dass die Aktion auf einem Controller (auf dem dritten) zu einer √Ñnderung des Erscheinungsbilds mehrerer anderer gleichzeitig f√ºhren sollte.  Das hei√üt, im ersten m√ºssen wir in der Zelle mit der Stadt anzeigen, und im zweiten m√ºssen wir alle Nummern in den ausgew√§hlten Regionen aktualisieren. <br><br>  Der Koordinator vereinfacht diese Aufgabe, indem er Daten zur√ºck in das Skript √ºbertr√§gt. Dies ist jetzt so einfach wie das Weiterleiten von Daten gem√§√ü dem Skript. <br><br>  Was ist hier los?  Der Benutzer w√§hlt eine Stadt aus.  Diese Nachricht wird an den Koordinator gesendet.  Der Koordinator durchl√§uft, wie ich bereits in der Demo gezeigt habe, den gesamten Navigationsstapel und sendet aktualisierte Daten an alle interessierten Parteien.  Dementsprechend kann ViewController seine Ansicht mit diesen Daten aktualisieren. <br><br><h2>  Refactoring von vorhandenem Code <br></h2><br>  Wie kann ich vorhandenen Code umgestalten, wenn Sie diesen Ansatz in eine vorhandene Anwendung mit MVc, MVVm oder MVp einbetten m√∂chten? <br><br><img src="https://habrastorage.org/webt/dd/_h/ss/dd_hssepys-qb1ybs9tg6qhnlqo.jpeg"><br><br>  Sie haben eine Reihe von ViewController.  Das erste, was zu tun ist, ist, sie in Szenarien zu unterteilen, an denen sie teilnehmen.  In unserem Beispiel gibt es drei Szenarien: Autorisierung, Profilbearbeitung, Band. <br><br><img src="https://habrastorage.org/webt/nb/gy/yq/nbgyyqm1qsj1jb_nasqr5wdtdnk.jpeg"><br><br>  Wir wickeln nun jedes Szenario in unseren Koordinator ein.  Wir sollten in der Lage sein, diese Skripte tats√§chlich von einer beliebigen Stelle in unserer Anwendung aus zu starten.  Dies sollte flexibel sein - der <strong>Koordinator muss v√∂llig autark sein</strong> . <br><br>  Dieser Entwicklungsansatz bietet zus√§tzlichen Komfort.  Es besteht darin, dass Sie, wenn Sie gerade mit einem bestimmten Szenario arbeiten, nicht jedes Mal darauf klicken m√ºssen, wenn Sie es starten.  Sie k√∂nnen es schnell beim Start starten, etwas darin bearbeiten und dann diesen tempor√§ren Start entfernen. <br><br>  Nachdem wir uns f√ºr unsere Koordinatoren entschieden haben, m√ºssen wir bestimmen, welches Szenario zum Start eines anderen f√ºhren kann, und aus diesen Szenarien einen Baum erstellen. <br><br><img src="https://habrastorage.org/webt/ya/y0/dn/yay0dneeqirzezm667lwklnkux0.jpeg"><br><br>  In unserem Fall ist der Baum einfach: LoginCoordinator kann den Profilbearbeitungskoordinator starten.  Hier passt fast alles zusammen, aber ein sehr wichtiges Detail bleibt - unserem Schema fehlt ein Einstiegspunkt. <br><br><img src="https://habrastorage.org/webt/38/-0/no/38-0nolfpsqej62yytkzqp-ux6s.jpeg"><br><br>  Dieser Einstiegspunkt ist ein spezieller Koordinator - <strong>ApplicationCoordinator</strong> .  Es wird von <strong>AppDelegate</strong> erstellt und gestartet und steuert dann bereits die Logik auf Anwendungsebene, <strong>dh</strong> welcher Koordinator startet gerade. <br><br>  Wir haben uns nur eine sehr √§hnliche Schaltung angesehen, nur ViewController anstelle von Koordinatoren, und wir haben sie so gestaltet, dass ViewController nichts voneinander wusste und keine Daten aneinander weitergab.  Grunds√§tzlich kann das auch mit den Koordinatoren gemacht werden.  Wir k√∂nnen in ihnen eine bestimmte Eingabe (Startmethode) und Ausgabe (onFinish-R√ºckruf) festlegen.  <strong>Koordinatoren werden unabh√§ngig, wiederverwendbar und leicht testbar</strong> .  Die Koordinatoren kennen sich nicht mehr und kommunizieren beispielsweise nur noch mit ApplicationCoordinator. <br><br>  Sie m√ºssen vorsichtig sein, denn wenn Ihre Anwendung √ºber gen√ºgend dieser Skripte verf√ºgt, kann sich ApplicationCoordinator in ein riesiges Gottobjekt verwandeln, das alle vorhandenen Skripte kennt - dies ist auch nicht sehr cool.  Hier m√ºssen wir schon schauen - vielleicht die Koordinatoren in Unterkoordinatoren unterteilen, dh √ºber eine solche Architektur nachdenken, damit diese Objekte nicht zu unglaublichen Gr√∂√üen wachsen.  <strong>Obwohl die Gr√∂√üe nicht immer ein Grund f√ºr das Refactoring ist</strong> . <br><br><h3>  Wo soll ich anfangen? <br></h3><br>  Ich empfehle, von unten nach oben zu beginnen - implementieren Sie zuerst einzelne Skripte. <br><br><img src="https://habrastorage.org/webt/rw/tw/al/rwtwalrny6uxjzbpfhcjzxybzse.jpeg"><br><br>  Um dieses Problem zu umgehen, k√∂nnen sie im UIViewController gestartet werden.  Das hei√üt, solange Sie nicht √ºber Root oder andere Koordinatoren verf√ºgen, k√∂nnen Sie einen Koordinator erstellen und als tempor√§re L√∂sung vom UIViewController aus starten und ihn lokal in der Eigenschaft speichern (wie nextCoordinator oben).  Wenn ein Ereignis eintritt, erstellen Sie, wie in der Demo gezeigt, eine lokale Eigenschaft, platzieren den Koordinator dort und rufen die Start-Methode auf.  Alles ist sehr einfach. <br><br>  Wenn dann alle diese Koordinatoren bereits fertig sind, sieht der Anfang von einem in dem anderen genau gleich aus.  Haben Sie eine lokale Eigenschaft oder eine Art von Abh√§ngigkeiten wie den Koordinator, f√ºgen Sie all dies dort ein, damit es nicht wegl√§uft, und rufen Sie die Start-Methode auf. <br><br><h2>  Zusammenfassung <br></h2><br><ul><li>  <strong>Unabh√§ngige Bildschirme und Skripte</strong> , die nichts voneinander wissen, kommunizieren nicht miteinander.  Wir haben versucht, dies zu erreichen. <br></li><li>  <strong>Es ist einfach, die Reihenfolge der</strong> Bildschirme in der Anwendung zu √§ndern, ohne die Bildschirmcodes zu √§ndern.  Wenn alles so gemacht wird, wie es sollte, sollte sich in der Anwendung nur der Bildschirmcode √§ndern, wenn sich das Skript √§ndert, sondern der Koordinatorcode. <br></li><li>  <strong>Vereinfachte Daten√ºbertragung zwischen Bildschirmen</strong> und anderen Aufgaben, die eine Verbindung zwischen Bildschirmen implizieren. <br></li><li>      ‚Äî    ,       <strong>  </strong>     . <br></li></ul><br><blockquote> AppsConf 2018  8  9  ‚Äî  !   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .      ‚Äî iOS  Android,      ,       ,     ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423299/">https://habr.com/ru/post/de423299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423285/index.html">Social Engineering: Der schwer fassbare Feind in der Welt der Cybersicherheit</a></li>
<li><a href="../de423291/index.html">Die Russen stellten einen Rekord auf: 110 Raubkopien pro Person</a></li>
<li><a href="../de423293/index.html">Wie man sich nicht mit einer Zustandsmaschine ins Bein schie√üt</a></li>
<li><a href="../de423295/index.html">N√ºtzlichste Konferenz f√ºr mobile Entwicklung</a></li>
<li><a href="../de423297/index.html">Vom Android-Entwickler zu DevOps</a></li>
<li><a href="../de423303/index.html">KI, praktischer Kurs. Emotionsbasierte Musiktransformation</a></li>
<li><a href="../de423305/index.html">Leistung ruinieren</a></li>
<li><a href="../de423307/index.html">GitHub-Pull-Anforderungen in Visual Studio-Code</a></li>
<li><a href="../de423309/index.html">DBMS-Transaktionen</a></li>
<li><a href="../de423311/index.html">Partnerschaft Naviaddress und ACTUM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>