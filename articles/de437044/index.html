<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∏ ü¶ä üöÇ So besiegen Sie den Drachen: Schreiben Sie Ihr Programm auf Golang neu üõ∂ üé™ üë©‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So kam es, dass Ihr Programm in einer Skriptsprache geschrieben wurde - zum Beispiel in Ruby - und dass es in Golang neu geschrieben werden musste. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So besiegen Sie den Drachen: Schreiben Sie Ihr Programm auf Golang neu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/437044/"><p>  So kam es, dass Ihr Programm in einer Skriptsprache geschrieben wurde - zum Beispiel in Ruby - und dass es in Golang neu geschrieben werden musste. </p><br><p>  Eine vern√ºnftige Frage: <strong>Warum</strong> m√ºssen Sie m√∂glicherweise ein Programm schreiben, das bereits geschrieben wurde und einwandfrei funktioniert? </p><br><p><img src="https://habrastorage.org/webt/b7/a0/ho/b7a0hogmqu_sytkfqkhaqbmwbz0.jpeg"><a name="habracut"></a></p><br><p>  Nehmen wir zun√§chst an, das Programm <strong>ist einem bestimmten √ñkosystem zugeordnet</strong> - in unserem Fall sind dies Docker und Kubernetes.  Die gesamte Infrastruktur dieser Projekte ist in Golang geschrieben.  Dies er√∂ffnet den Zugriff auf Bibliotheken, die Docker, Kubernetes und andere verwenden.  Unter dem Gesichtspunkt der Unterst√ºtzung, Entwicklung und Verfeinerung Ihres Programms ist es rentabler, dieselbe Infrastruktur zu verwenden, die die Hauptprodukte verwenden.  In diesem Fall sind alle neuen Funktionen sofort verf√ºgbar und Sie m√ºssen sie nicht erneut in einer anderen Sprache implementieren.  Nur diese Bedingung <strong>in unserer spezifischen Situation</strong> reichte aus, um eine Entscheidung sowohl √ºber die Notwendigkeit einer grunds√§tzlichen √Ñnderung der Sprache als auch √ºber die Art der Sprache zu treffen.  Es gibt jedoch noch andere Vorteile ... </p><br><p>  Zweitens die <strong>einfache Installation von</strong> Anwendungen auf Golang.  Sie m√ºssen Rvm, Ruby, eine Reihe von Edelsteinen usw. nicht im System installieren. Sie m√ºssen eine statische Bin√§rdatei herunterladen und verwenden. </p><br><p> Drittens ist die <strong>Geschwindigkeit der</strong> Programme auf Golang h√∂her.  Dies ist keine signifikante systemische Geschwindigkeitssteigerung, die durch die Verwendung der richtigen Architektur und Algorithmen in einer beliebigen Sprache erzielt wird.  Dies ist jedoch eine solche Zunahme, die sich bemerkbar macht, wenn Sie Ihr Programm von der Konsole aus starten.  Zum Beispiel kann <code>--help</code> in Ruby in 0,8 Sekunden und in Golang in 0,02 Sekunden funktionieren.  Es verbessert die Benutzererfahrung bei der Verwendung des Programms nur merklich. </p><br><p>  <em><strong>NB</strong> : Wie die regelm√§√üigen Leser unseres Blogs h√§tten erraten k√∂nnen, basiert der Artikel auf der Erfahrung beim Umschreiben unseres <strong>dapp-</strong> Produkts, das jetzt - noch nicht ganz offiziell (!) - als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf bekannt ist</a> .</em>  <em>Weitere Informationen hierzu finden Sie am Ende des Artikels.</em> </p><br><p>  Gut: Sie k√∂nnen einfach einen neuen Code aufnehmen und schreiben, der vollst√§ndig vom alten Skriptcode isoliert ist.  Es treten jedoch sofort einige <strong>Schwierigkeiten und Einschr√§nkungen</strong> bei den f√ºr die Entwicklung bereitgestellten Ressourcen und Zeit auf: </p><br><ul><li>  Die aktuelle Version des Programms in Ruby ben√∂tigt st√§ndig Verbesserungen und Korrekturen: <br><ul><li>  Fehler treten bei der Verwendung auf und sollten umgehend behoben werden. </li><li>  Sie k√∂nnen das Hinzuf√ºgen neuer Funktionen sechs Monate lang nicht einfrieren, da  Diese Funktionen werden h√§ufig von Clients / Benutzern ben√∂tigt. </li></ul></li><li>  Die gleichzeitige Pflege von 2 Codebasen ist schwierig und teuer: <br><ul><li>  Es gibt nur wenige Teams mit 2-3 Personen, da neben diesem Ruby-Programm noch andere Projekte vorhanden sind. </li></ul></li><li>  Einf√ºhrung der neuen Version: <br><ul><li>  Es sollte keine signifikante Verschlechterung der Funktion geben; </li><li>  Idealerweise sollte dies nahtlos und nahtlos sein. </li></ul></li></ul><br><p>  Ein kontinuierlicher Portierungsprozess ist erforderlich.  Aber wie kann ich das tun, wenn die Golang-Version als eigenst√§ndiges Programm entwickelt wird? </p><br><h2 id="pishem-srazu-na-dvuh-yazykah">  Wir schreiben in zwei Sprachen gleichzeitig </h2><br><p>  Aber was ist, wenn Sie Komponenten von unten nach oben auf Golang √ºbertragen?  Wir beginnen mit einfachen Dingen und gehen dann die Abstraktionen hoch. </p><br><p>  Stellen Sie sich vor, Ihr Programm besteht aus folgenden Komponenten: </p><br><pre> <code class="plaintext hljs">lib/ config.rb build/ image.rb git_repo/ base.rb local.rb remote.rb docker_registry.rb builder/ base.rb shell.rb ansible.rb stage/ base.rb from.rb before_install.rb git.rb install.rb before_setup.rb setup.rb deploy/ kubernetes/ client.rb manager/ base.rb job.rb deployment.rb pod.rb</code> </pre> <br><h3 id="portirovat-komponent-s-funkciyami">  Portkomponente mit Funktionen </h3><br><p>  Ein einfacher Fall.  Wir nehmen eine vorhandene Komponente, die vom Rest ziemlich isoliert ist - zum Beispiel <code>config</code> ( <code>lib/config.rb</code> ).  In dieser Komponente ist nur die Funktion <code>Config::parse</code> definiert, die den Pfad zur Konfiguration √ºbernimmt, ihn liest und eine aufgef√ºllte Struktur erstellt.  Eine separate Bin√§rdatei in der Golang- <code>config</code> und der entsprechenden Paketkonfiguration ist f√ºr die Implementierung verantwortlich: </p><br><pre> <code class="plaintext hljs">cmd/ config/ main.go pkg/ config/ config.go</code> </pre> <br><p>  Die Golang-Bin√§rdatei empf√§ngt die Argumente aus der JSON-Datei und gibt das Ergebnis in die JSON-Datei aus. </p><br><pre> <code class="plaintext hljs">config -args-from-file args.json -res-to-file res.json</code> </pre> <br><p>  Es wird <code>config</code> dass <code>config</code> Nachrichten an stdout / stderr ausgeben kann (in unserem Ruby-Programm geht die Ausgabe <em>immer</em> an stdout / stderr, daher ist diese Funktion nicht parametrisiert). </p><br><p>  Das Aufrufen der <code>config</code> entspricht dem Aufrufen einer Funktion der <code>config</code> .  Die Argumente in der Datei <code>args.json</code> geben den Namen der Funktion und ihre Parameter an.  Bei der Ausgabe √ºber die Datei <code>res.json</code> das Ergebnis der Funktion.  Wenn die Funktion ein Objekt einer Klasse zur√ºckgeben soll, werden die Daten des <em>Objekts</em> dieser Klasse in serialisierter JSON-Form zur√ºckgegeben. </p><br><p>  <code>args.json</code> Sie beispielsweise die folgende <code>args.json</code> , um die Funktion <code>Config::parse</code> <code>args.json</code> : </p><br><pre> <code class="plaintext hljs">{ "command": "Parse", "configPath": "path-to-config.yaml" }</code> </pre> <br><p>  Wir <code>res.json</code> Ergebnis in <code>res.json</code> : </p><br><pre> <code class="plaintext hljs">{ "config": { "Images": [{"Name": "nginx"}, {"Name": "rails"}], "From": "ubuntu:16.04" }, }</code> </pre> <br><p>  Im <code>config</code> wir den Status des in JSON serialisierten <code>Config::Config</code> Objekts.  Ab diesem Status m√ºssen Sie auf dem Aufrufer in Ruby ein <code>Config::Config</code> Objekt <code>Config::Config</code> . </p><br><p>  Im Falle des <em>bereitgestellten</em> Fehlers kann die Bin√§rdatei den folgenden JSON zur√ºckgeben: </p><br><pre> <code class="plaintext hljs">{ "error": "no such file path-to-config.yaml" }</code> </pre> <br><p>  Das <code>error</code> muss vom Anrufer behandelt werden. </p><br><h4 id="vyzyvaem-golang-iz-ruby">  Golang von Ruby aus anrufen </h4><br><p>  Auf der Ruby-Seite verwandeln wir die Funktion <code>Config::parse(config_path)</code> in einen Wrapper, der unsere <code>config</code> aufruft, das Ergebnis erh√§lt und alle m√∂glichen Fehler verarbeitet.  Hier ist ein Beispiel f√ºr einen Ruby-Pseudocode mit Vereinfachungen: </p><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config_path</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call_id</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_random_number</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args_file</span></span></span><span class="hljs-class"> = "</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#{get_tmp_dir}/args.#{call_id}.json" res_file = "#{get_tmp_dir}/res.#{call_id}.json" args_file.write(JSON.dump( "command" =&gt; "Parse", "configPath" =&gt; config_path, )) system("config -args-from-file #{args_file} -res-to-file #{res_file}") raise "config failed with unknown error" if $?.exitstatus != 0 res = JSON.load_file(res_file) raise ParseError, res["error"] if res["error"] return Config.new_from_state(res["config"]) end end</span></span></span></span></code> </pre> <br><p>  Die Bin√§rdatei kann mit unerwartetem Code ungleich Null abst√ºrzen - dies ist eine Ausnahmesituation.  Oder mit den bereitgestellten Codes - in diesem Fall <code>res.json</code> wir die Datei <code>res.json</code> auf das Vorhandensein der <code>error</code> und <code>config</code> und geben als Ergebnis das <code>Config::Config</code> Objekt aus dem serialisierten <code>config</code> zur√ºck. </p><br><p>  Aus Sicht des Benutzers hat sich die Funktion <code>Config::Parse</code> nicht ge√§ndert. </p><br><h3 id="portirovat-komponent-klass">  Port-Komponentenklasse </h3><br><p>  Nehmen Sie zum Beispiel die Klassenhierarchie <code>lib/git_repo</code> .  Es gibt 2 Klassen: <code>GitRepo::Local</code> und <code>GitRepo::Remote</code> .  Es ist sinnvoll, ihre Implementierung in einer einzigen <code>git_repo</code> Bin√§rdatei zu kombinieren und dementsprechend <code>git_repo</code> in Golang zu verpacken. </p><br><pre> <code class="plaintext hljs">cmd/ git_repo/ main.go pkg/ git_repo/ base.go local.go remote.go</code> </pre> <br><p>  Ein Aufruf der Bin√§rdatei <code>git_repo</code> entspricht einem Aufruf einer Methode des <code>GitRepo::Local</code> <code>GitRepo::Remote</code> oder <code>GitRepo::Remote</code> Objekts.  Das Objekt hat einen Status und kann sich nach einem Methodenaufruf √§ndern.  Daher √ºbergeben wir in den Argumenten den in JSON serialisierten aktuellen Status.  Und bei der Ausgabe erhalten wir immer den neuen Status des Objekts - auch in JSON. </p><br><p>  Um beispielsweise die Methode <code>local_repo.commit_exists?(commit)</code> , geben Sie die folgenden <code>args.json</code> : </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "method": "IsCommitExists", "commit": "e43b1336d37478282693419e2c3f2d03a482c578" }</code> </pre> <br><p>  Die Ausgabe ist <code>res.json</code> : </p><br><pre> <code class="plaintext hljs">{ "localGitRepo": { "name": "my_local_git_repo", "path": "path/to/git" }, "result": true, }</code> </pre> <br><p>  Im Feld <code>localGitRepo</code> wird ein neuer Status des Objekts empfangen (der sich m√∂glicherweise nicht √§ndert).  Wir m√ºssen diesen Zustand sowieso in das aktuelle Ruby-Objekt <code>local_git_repo</code> . </p><br><h4 id="vyzyvaem-golang-iz-ruby-1">  Golang von Ruby aus anrufen </h4><br><p>  Auf der Ruby-Seite <code>GitRepo::Base</code> wir jede Methode der <code>GitRepo::Base</code> , <code>GitRepo::Local</code> , <code>GitRepo::Remote</code> in Wrapper um, die unser <code>git_repo</code> , das Ergebnis <code>git_repo</code> und den neuen Status des Objekts der Klasse <code>GitRepo::Local</code> oder <code>GitRepo::Remote</code> . </p><br><p>  Ansonsten √§hnelt alles dem Aufrufen einer einfachen Funktion. </p><br><h4 id="kak-byt-s-polimorfizmom-i-bazovymi-klassami">  Umgang mit Polymorphismus und Basisklassen </h4><br><p>  Der einfachste Weg ist, den Polymorphismus von Golang nicht zu unterst√ºtzen.  Das hei√üt,  <code>git_repo</code> sicher, dass die Aufrufe der Bin√§rdatei <code>git_repo</code> immer explizit an eine bestimmte Implementierung adressiert sind (wenn <code>localGitRepo</code> in den Argumenten angegeben wurde, kam der Aufruf von einem <code>GitRepo::Local</code> Klassenobjekt; wenn <code>remoteGitRepo</code> angegeben wurde - dann von <code>GitRepo::Remote</code> ) und kopieren Sie eine kleine Menge von boilerplate- Code in cmd.  Schlie√ülich wird <strong>dieser Code</strong> ohnehin verworfen <strong>, sobald</strong> der Umzug nach Golang abgeschlossen ist. </p><br><h4 id="kak-menyat-sostoyanie-drugogo-obekta">  So √§ndern Sie den Status eines anderen Objekts </h4><br><p>  Es gibt Situationen, in denen ein Objekt ein anderes Objekt als Parameter empf√§ngt und eine Methode aufruft, die implizit den Status dieses zweiten Objekts √§ndert. </p><br><p>  In diesem Fall m√ºssen Sie: </p><br><ol><li>  Wenn eine Bin√§rdatei aufgerufen wird, √ºbertragen Sie zus√§tzlich zum serialisierten Status des Objekts, zu dem die Methode aufgerufen wird, den serialisierten Status aller Parameterobjekte. </li><li>  Setzen Sie nach dem Aufruf den Status des Objekts zur√ºck, an das die Methode aufgerufen wurde, und setzen Sie auch den Status aller Objekte zur√ºck, die als Parameter √ºbergeben wurden. </li></ol><br><p>  Ansonsten ist alles √§hnlich. </p><br><h3 id="chto-poluchaetsya">  Was ist das </h3><br><p>  Wir nehmen eine Komponente, portieren nach Golang, ver√∂ffentlichen eine neue Version. </p><br><p>  Wenn die zugrunde liegenden Komponenten bereits portiert sind und eine √ºbergeordnete Komponente, die sie verwendet, √ºbertragen wird, kann diese <strong>Komponente diese zugrunde liegenden Komponenten ‚Äûaufnehmen‚Äú</strong> .  In diesem Fall werden die entsprechenden zus√§tzlichen Bin√§rdateien m√∂glicherweise bereits als unn√∂tig gel√∂scht. </p><br><p>  Und das geht so weiter, bis wir zur obersten Ebene gelangen, die <strong>alle zugrunde liegenden Abstraktionen zusammenklebt</strong> .  Damit ist die erste Phase der Portierung abgeschlossen.  Die oberste Ebene ist die CLI.  Er kann noch eine Weile von Ruby leben, bevor er komplett zu Golang wechselt. </p><br><h2 id="kak-rasprostranyat-etogo-monstra">  Wie verteile ich dieses Monster? </h2><br><p>  Gut: Jetzt haben wir einen Ansatz, um alle Komponenten schrittweise zu portieren.  Frage: Wie verteilt man ein solches Programm in zwei Sprachen? </p><br><p>  Im Fall von Ruby ist das Programm weiterhin als Gem installiert.  Sobald die Bin√§rdatei aufgerufen wird, kann sie diese Abh√§ngigkeit auf eine bestimmte URL herunterladen (sie ist fest codiert) und lokal im System (irgendwo in den Servicedateien) zwischenspeichern. </p><br><p>  Wenn wir unser Programm in zwei Sprachen neu ver√∂ffentlichen, m√ºssen wir: </p><br><ol><li>  Sammeln Sie alle bin√§ren Abh√§ngigkeiten und laden Sie sie auf ein bestimmtes Hosting hoch. </li><li>  Erstellen Sie eine neue Ruby Gem-Version. </li></ol><br><p>  Die Bin√§rdateien f√ºr jede nachfolgende Version werden separat erfasst, auch wenn sich eine Komponente nicht ge√§ndert hat.  Man k√∂nnte eine separate Versionierung aller abh√§ngigen Bin√§rdateien vornehmen.  Dann w√§re es nicht notwendig, f√ºr jede neue Version des Programms neue Bin√§rdateien zu sammeln.  In unserem Fall gingen wir jedoch davon aus, dass wir keine Zeit haben, etwas extrem Kompliziertes zu tun und den Zeitcode zu optimieren. Der Einfachheit halber haben wir f√ºr jede Version des Programms separate Bin√§rdateien gesammelt, um Platz und Zeit f√ºr das Herunterladen zu sparen. </p><br><h2 id="nedostatki-podhoda">  Nachteile des Ansatzes </h2><br><p>  Offensichtlich entsteht der Aufwand f√ºr das st√§ndige Aufrufen externer Programme √ºber <code>system</code> / <code>exec</code> . </p><br><p>  Es ist schwierig, <strong>globale Daten auf Golang-Ebene zwischenzuspeichern.</strong> Schlie√ülich werden alle Daten in Golang (z. B. Paketvariablen) erstellt, wenn eine Methode aufgerufen wird, und sterben nach Abschluss ab.  Dies muss immer ber√ºcksichtigt werden.  Das Caching ist jedoch weiterhin <strong>auf Klasseninstanzebene</strong> oder <strong>durch explizite √úbergabe von Parametern</strong> an eine externe Komponente m√∂glich. </p><br><p>  Wir d√ºrfen nicht vergessen, den <strong>Status von Objekten nach Golang zu √ºbertragen</strong> und ihn nach einem Aufruf korrekt wiederherzustellen. </p><br><p>  Bin√§re Abh√§ngigkeiten von Golang <strong>nehmen viel Platz ein</strong> .  Es ist eine Sache, wenn es eine einzelne 30-MB-Bin√§rdatei gibt - ein Programm auf Golang.  Eine andere Sache, wenn Sie ~ 10 Komponenten portiert haben, von denen jede 30 MB wiegt, erhalten wir 300 MB Dateien <strong>f√ºr jede Version</strong> .  Aus diesem Grund wird der Speicherplatz auf dem Bin√§rhosting und auf dem Hostcomputer, auf dem Ihr Programm funktioniert und st√§ndig aktualisiert wird, schnell verlassen.  Das Problem ist jedoch nicht signifikant, wenn Sie regelm√§√üig alte Versionen l√∂schen. </p><br><p>  Beachten Sie auch, dass das Herunterladen von bin√§ren Abh√§ngigkeiten bei jedem Update des Programms einige Zeit in Anspruch nimmt. </p><br><h2 id="preimuschestva-podhoda">  Vorteile des Ansatzes </h2><br><p>  Trotz aller genannten Nachteile k√∂nnen Sie mit diesem Ansatz einen <strong>kontinuierlichen Portierungsprozess in eine andere Sprache organisieren</strong> und mit einem Entwicklungsteam auskommen. </p><br><p>  Der wichtigste Vorteil ist die M√∂glichkeit, <strong>schnelles Feedback</strong> zum neuen Code zu erhalten, ihn zu testen und zu stabilisieren. </p><br><p>  In diesem Fall k√∂nnen Sie Ihrem Programm unter anderem neue Funktionen hinzuf√ºgen und Fehler in der aktuellen Version beheben. </p><br><h2 id="kak-sdelat-okonchatelnyy-perevorot-na-golang">  Wie man einen letzten Coup auf Golang macht </h2><br><p>  Zu dem Zeitpunkt, an dem alle Hauptkomponenten an Golang √ºbergeben und bereits in der Produktion getestet werden, m√ºssen Sie nur noch die obere Schnittstelle Ihres Programms (CLI) in Golang umschreiben und den gesamten alten Ruby-Code wegwerfen. </p><br><p>  Derzeit m√ºssen nur noch die Kompatibilit√§tsprobleme Ihrer neuen CLI mit der alten CLI gel√∂st werden. </p><br><p>  Hurra, Genossen!  Die Revolution ist wahr geworden. </p><br><h2 id="kak-my-perepisali-dapp-na-golang">  Wie wir dapp auf Golang umgeschrieben haben </h2><br><p>  Dapp ist ein von Flant entwickeltes Dienstprogramm zur Organisation des CI / CD-Prozesses.  Es wurde aus historischen Gr√ºnden in Ruby geschrieben: </p><br><ul><li>  Umfangreiche Erfahrung in der Entwicklung von Programmen in Ruby. </li><li>  Gebrauchter Koch (Rezepte daf√ºr sind in Ruby geschrieben). </li><li>  Tr√§gheit, Widerstand gegen die Verwendung einer neuen Sprache f√ºr uns f√ºr etwas Ernstes. </li></ul><br><p>  Der im Artikel beschriebene Ansatz wurde angewendet, um dapp auf Golang neu zu schreiben.  Die folgende Grafik zeigt die Chronologie des Kampfes zwischen Gut (Golang, Blau) und B√∂se (Rubin, Rot): </p><br><img src="https://habrastorage.org/webt/xc/qg/gy/xcqggyavhbvkewruasv-pgcxbfa.png"><br><p>  <em>Codemenge in einem dapp / werf-Projekt in Ruby vs. Sprachen</em>  <em>Golang im Laufe der Ver√∂ffentlichungen</em> </p><br><p>  Im Moment k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Alpha-Version 1.0 herunterladen</a> , die Ruby nicht enth√§lt.  Wir haben auch dapp in werf umbenannt, aber das ist eine andere Geschichte ... <strong>Warten Sie auf die vollst√§ndige Ver√∂ffentlichung von werf 1.0 bald!</strong> </p><br><p>  Als zus√§tzliche Vorteile dieser Migration und als Beispiel f√ºr die Integration in das ber√ºchtigte Kubernetes-√ñkosystem stellen wir fest, dass wir durch das Umschreiben von dapp auf Golang die M√∂glichkeit hatten, ein weiteres Projekt zu erstellen - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubedog</a></strong> .  So konnten wir den Code f√ºr die Verfolgung der K8-Ressourcen in ein separates Projekt aufteilen, was <strong>nicht nur</strong> in werf, sondern auch in anderen Projekten n√ºtzlich sein kann.  Es gibt andere L√∂sungen f√ºr dieselbe Aufgabe <em>(siehe unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">j√ºngste Ank√ºndigung</a> f√ºr Details)</em> , aber mit ihnen (in Bezug auf die Popularit√§t) ohne Go zu ‚Äûkonkurrieren‚Äú, da ihre Grundlage kaum m√∂glich geworden w√§re. </p><br><h2 id="ps">  PS </h2><br><p>  Lesen Sie auch in unserem Blog: </p><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung der Kubedog-Bibliothek zur Verfolgung von Kubernetes-Ressourcen.</a> " </li><li>  "Wir f√ºhren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziell das Dienstprogramm dapp - DevOps zur Wartung von CI / CD ein</a> ." </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warten Sie: Unterst√ºtzung f√ºr YAML und Ansible (keine K√ºhe) in dapp</a> ." </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen und installieren Sie Anwendungen in Kubernetes mit dapp und GitLab CI</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437044/">https://habr.com/ru/post/de437044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437032/index.html">Installationsanleitung f√ºr NGINX ModSecurity</a></li>
<li><a href="../de437034/index.html">Universal Whistles: Snom A230 und A210 USB Dongle Review</a></li>
<li><a href="../de437036/index.html">SAPUI5 f√ºr Dummies Teil 2: Eine vollst√§ndige Schritt-f√ºr-Schritt-√úbung</a></li>
<li><a href="../de437038/index.html">Benjamin Winterberg Stream API Guide √úbersetzung</a></li>
<li><a href="../de437040/index.html">In Russland begann der Test der inl√§ndischen neuronalen Schnittstelle "Neurochat"</a></li>
<li><a href="../de437050/index.html">Das Buch "Python. Expresskurs. 3rd ed.</a></li>
<li><a href="../de437052/index.html">Verpassen Sie nicht zu lernen: Braucht ein Universit√§ts-IT-Spezialist</a></li>
<li><a href="../de437054/index.html">Neue Intel Prozessoren der 9. Generation: Core minus GPU</a></li>
<li><a href="../de437056/index.html">Die Zimbra Collaboration Suite und die Zextras Suite sind vollst√§ndig mit dem inl√§ndischen RED-Betriebssystem kompatibel</a></li>
<li><a href="../de437062/index.html">Die Auswirkung der Verz√∂gerung und die L√§nge der Schlussfolgerungen des Chips und der Software auf die Berechnung der Gesamtl√§nge / Verz√∂gerung der Leiter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>