<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💖 👆🏾 🍥 Referencia de origen de evento de Rx 👉🏾 ☎️ 🧘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RxJava se usa en una gran cantidad de aplicaciones de Android, pero al mismo tiempo muchas no conocen otras fuentes de eventos, excepto Observable y q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Referencia de origen de evento de Rx</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/459174/"><img src="https://habrastorage.org/webt/5u/bh/bo/5ubhboeipdbjg8iw7pwxhhbnyhy.png"><br><br>  RxJava se usa en una gran cantidad de aplicaciones de Android, pero al mismo tiempo muchas no conocen otras fuentes de eventos, excepto Observable y quizás Flowable.  Se olvidan de las clases especializadas Individual, Quizás y Completable, que a menudo pueden agregar más claridad al código. <br><br>  Debajo del gato encontrará una hoja de trucos sobre las fuentes de eventos que existen en RxJava. <br><a name="habracut"></a><br>  <u>Completable es en</u> realidad un análogo Rx de Runnable.  Es una operación que se puede realizar o no.  Si dibujamos una analogía con Kotlin, entonces esto es <i>divertido completable ()</i> del mundo de Rx.  En consecuencia, para suscribirse, debe implementar onComplete y onError.  No se puede crear a partir del valor (Observable # solo, ...) porque no está diseñado para esto. <br><br>  Llamable reactiva simple, porque aquí es posible devolver el resultado de la operación.  Continuando la comparación con Kotlin, podemos decir que Single es divertido single (): T {}.  Por lo tanto, para suscribirse, debe implementar onSuccess (T) y onError. <br><br>  <u>Quizás</u> : un cruce entre Single y Completable, porque admite un valor, sin valores y error.  Es más difícil trazar un paralelo inequívoco con los métodos, pero creo que Quizás es divertido, quizás (): T?  {}, que devuelve nulo cuando no hay resultado.  Es fácil adivinar que para una suscripción debe definir onSuccess (T), onComplete y onError. <br><blockquote>  Es importante tener en cuenta que onSuccess (T) y onComplete son mutuamente excluyentes.  Es decir  en caso de llamar al primero, no puede esperar al segundo. </blockquote>  <u>Observable</u> es la fuente más común, debido a su versatilidad.  Él sabe cómo no producir eventos y generar muchos de ellos, por lo que puede usarse siempre que otras opciones no sean adecuadas.  A pesar de esto, Observable tiene un inconveniente: no sabe cómo manejar la contrapresión.  Para suscribirse, necesita onNext (T), onError y onComplete. <br><br><blockquote>  Contrapresión: una situación en la que los nuevos eventos llegan mucho más rápido de lo que tienen tiempo para procesar y comienzan a acumularse en el búfer, desbordándolo.  Esto puede generar problemas como OutOfMemoryError.  Más detalles se pueden encontrar <a href="">aquí</a> . </blockquote><br>  <u>ConnectableObservable</u> : una versión calentada de Observable.  Todas las fuentes de datos comienzan a emitir su flujo de eventos al momento de la suscripción.  Pero no este chico.  Para hacer esto, ConnectableObservable espera una llamada para conectarse.  Esto se hace para que varios observadores puedan revisar una secuencia de eventos sin reiniciarla en cada suscripción.  Para ilustrar, le daré el siguiente fragmento: <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> observable = Observable.fromCallable { Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, <span class="hljs-string"><span class="hljs-string">"observable fromCallable executed"</span></span>) Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>) }.subscribeOn(Schedulers.computation()) observable.subscribe() observable.subscribe() observable.subscribe() observable.subscribe()</code> </pre>  En la consola estará: <br>  observable desde Callable ejecutado <br>  observable desde Callable ejecutado <br>  observable desde Callable ejecutado <br>  observable desde Callable ejecutado <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connectedObservable = Observable.fromCallable { Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, <span class="hljs-string"><span class="hljs-string">"connectedObservable fromCallable executed"</span></span>) Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>) }.subscribeOn(Schedulers.computation()) .publish() connectedObservable.subscribe() connectedObservable.subscribe() connectedObservable.subscribe() connectedObservable.subscribe() connectedObservable.connect()</code> </pre><br>  Y en este caso: observable desde Callable ejecutado <br><br>  <u>Fluible</u> : una fuente que proporciona operadores adicionales para procesar la contrapresión.  Cuando necesite manejar más de 10,000 eventos que ocurren rápidamente uno tras otro, se recomienda usarlo en lugar de Observable. <br><br>  Este último puede crear un ConnectableFlowable, abriendo las mismas posibilidades que ConnectableObservable. <br><br>  Hablando de generadores de eventos, uno no puede dejar de mencionar Asunto y Procesador. <br><br>  <u>Asunto</u> : una clase que puede ser tanto una fuente como un navegador.  Esto le permite usarlo, por ejemplo, en varios tipos de controladores que lo enviarán al exterior como un Observable y dentro lo notificarán como un Observador.  A continuación, veremos diferentes implementaciones de esta clase. <br><br>  <u>AsyncSubject / AsyncProcessor</u> retiene el último evento hasta que el subproceso finaliza correctamente y luego lo envía a los suscriptores.  Si se produce un error, no se reenviarán eventos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/424/6ad/e034246ad488aa7f1309ee9870f2243c.png" alt="imagen"><br><br>  <u>PublishSubject / PublishProcessor reenvía los</u> eventos que entran más allá hasta que llega una señal de terminal.  Después del final de la secuencia o error, devuelve los eventos apropiados. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d7/5b5/399/6d75b53991a4ae2e84818b64149a01db.png" alt="imagen"><br><br>  <u>BehaviorSubject / BehaviorProcessor</u> funciona de manera similar a PublishSubject / PublishProcessor, pero al suscribirse devuelve el último evento, si lo hay, y si el Asunto no ha pasado al estado terminal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/540/bfd/11b540bfdda812ae611cac4bbcdbee6c.png" alt="imagen"><br><br>  <u>ReplaySubject / ReplayProcessor</u> - BehaviourSubject / BehaviorProcessor en esteroides.  No devuelve un último evento, sino todo lo que el alma desea.  Si se suscribe a un ReplaySubject o ReplayProcessor completado, se recibirán todos los datos acumulados. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/4b5/19e/c754b519e08d98fed504fac2cf637d61.png" alt="imagen"><br><blockquote>  Por lo tanto, ReplaySubject.createWithSize (1) y BehaviourSubject.create () funcionan de manera diferente después de la transición al estado terminal.  Durante la suscripción, el primero devolverá el último evento y el segundo no.  También es cierto para ReplayProcessor. </blockquote>  <u>CompletableSubject</u> , <u>MaybeSubject</u> y <u>SingleSubject</u> funcionan de manera similar a PublishSubject, solo diseñado para usarse con Completable, Maybe y Single, respectivamente. <br><br>  <u>UnicastSubject / UnicastProcessor</u> es en realidad un ReplaySubject que garantiza que solo tiene un suscriptor.  Lanza una IllegalStateException cuando intenta volver a suscribirse. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6b/f38/46a/e6bf3846a454ef45c5b217bb58568f85.png" alt="imagen"><br><br>  Es decir  siguiente fragmento <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> subject = UnicastSubject.create&lt;String&gt;(<span class="hljs-number"><span class="hljs-number">3</span></span>) repeat(<span class="hljs-number"><span class="hljs-number">3</span></span>) { subject.onNext(it.toString()) } subject.onComplete() subject.subscribe({ Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, it) }, { }, { Log.d(<span class="hljs-string"><span class="hljs-string">"RxLogs"</span></span>, <span class="hljs-string"><span class="hljs-string">"complete"</span></span>) })</code> </pre><br>  saldrá al registro <br>  0 0 <br>  1 <br>  2 <br>  completar <br><br>  <u>MulticastProcessor</u> funciona de manera similar a PublishProcessor, con la excepción de una pequeña característica.  Él sabe cómo manejar la contrapresión para la transmisión entrante.  MulticastProcessor le permite establecer el tamaño del búfer en el que realizará una preconsulta de elementos ascendentes para futuros suscriptores. <br><br>  En el siguiente diagrama, se crea un procesador con almacenamiento para 2 elementos, que solicita inmediatamente de su fuente.  Por lo tanto, cuando el primer observador se suscribe, emite inmediatamente el contenido del búfer, que se llena instantáneamente con nuevos eventos.  Después del evento terminal, MulticastProcessor borra su almacenamiento y los nuevos suscriptores reciben de inmediato la finalización de la transmisión. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce5/28c/d0f/ce528cd0fa322e90765069652321a57c.png" alt="imagen"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459174/">https://habr.com/ru/post/459174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459160/index.html">¿Cómo eliges productos en las tiendas?</a></li>
<li><a href="../459162/index.html">"Para ganar los campeonatos, el equipo debe respirar al unísono". Entrevista con Talleres de Moscú Entrenador ICPC</a></li>
<li><a href="../459166/index.html">¿Qué eres, cierres en JavaScript?</a></li>
<li><a href="../459168/index.html">Cómo moverse por Windows Defender de forma económica y alegre: sesión de meterpreter a través de python</a></li>
<li><a href="../459172/index.html">Las 13 mejores bibliotecas de Scala para análisis de datos</a></li>
<li><a href="../459176/index.html">Fuente de alimentación estable de alto voltaje para PMT</a></li>
<li><a href="../459180/index.html">TheOutloud - Expresa y comparte tus artículos e historias favoritas. Parte 2</a></li>
<li><a href="../459182/index.html">GitLab: con el lanzamiento de la versión 12.1, dejamos de admitir MySQL</a></li>
<li><a href="../459184/index.html">Habilidades de unidad básica</a></li>
<li><a href="../459188/index.html">Debian 10 Buster y Linux 5.2 lanzados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>