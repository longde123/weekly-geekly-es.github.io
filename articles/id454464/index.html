<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè• üë©üèΩ‚Äçüî¨ üîÆ Pengembangan tes visual berdasarkan Gemini dan Storybook ‚òπÔ∏è ü§µüèΩ üôáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Dalam artikel ini saya ingin berbagi pengalaman mengembangkan tes visual di tim kami. 

 Kebetulan kami tidak langsung berpikir tentang pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan tes visual berdasarkan Gemini dan Storybook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454464/">  Halo, Habr!  Dalam artikel ini saya ingin berbagi pengalaman mengembangkan tes visual di tim kami. <br><br>  Kebetulan kami tidak langsung berpikir tentang pengujian tata letak.  Nah, beberapa frame akan bergerak beberapa piksel, ya, perbaiki.  Pada akhirnya, ada penguji - lalat tidak akan terbang melewati mereka.  Tetapi faktor manusia masih tidak bisa dibohongi - untuk mendeteksi perubahan kecil pada antarmuka pengguna jauh dari selalu mungkin secara fisik bahkan untuk tester.  Pertanyaan muncul ketika optimalisasi tata letak dan transisi ke BEM dimulai.  Di sini, itu pasti tidak akan rugi, dan kami sangat membutuhkan cara otomatis untuk mendeteksi situasi ketika, sebagai hasil edit, sesuatu di UI mulai berubah tidak seperti yang dimaksudkan, atau tidak di tempat yang dimaksudkan. <br><a name="habracut"></a><br>  Setiap pengembang tahu tentang pengujian kode unit.  Tes unit memberikan keyakinan bahwa perubahan kode tidak merusak apa pun.  Yah, setidaknya mereka tidak mematahkan bagian yang ada tes.  Prinsip yang sama dapat diterapkan pada antarmuka pengguna.  Sama seperti tes unit test kelas, tes visual menguji komponen visual yang membentuk antarmuka pengguna suatu aplikasi. <br><br>  Untuk komponen visual, Anda dapat menulis tes unit "klasik", yang, misalnya, memulai rendering komponen dengan nilai parameter input yang berbeda dan memeriksa keadaan yang diharapkan dari pohon DOM menggunakan pernyataan tegas, membandingkan elemen individual atau potret pohon DOM komponen dengan referensi secara umum.  Tes visual juga didasarkan pada foto, tetapi sudah pada foto tampilan visual komponen (tangkapan layar).  Inti dari tes visual adalah untuk membandingkan gambar yang diambil selama tes dengan yang referensi dan, jika perbedaan ditemukan, baik menerima gambar baru sebagai referensi atau memperbaiki bug yang menyebabkan perbedaan ini. <br><br>  Tentu saja, "menyaring" komponen visual individual tidak terlalu efektif.  Komponen tidak hidup dalam ruang hampa dan tampilannya mungkin tergantung pada komponen tingkat atas atau yang berdekatan.  Tidak masalah bagaimana kita menguji komponen individu, gambar secara keseluruhan mungkin memiliki cacat.  Di sisi lain, jika Anda mengambil gambar dari seluruh jendela aplikasi, maka banyak gambar akan berisi komponen yang sama, yang berarti bahwa jika Anda mengubah satu komponen, kami akan dipaksa untuk memperbarui semua gambar di mana komponen ini ada. <br><br>  Kebenarannya, seperti biasa, ada di suatu tempat di tengah - Anda dapat menggambar seluruh halaman aplikasi, tetapi mengambil gambar hanya satu area di mana tes dibuat, dalam kasus tertentu area ini mungkin bertepatan dengan area komponen tertentu, tetapi ini tidak akan menjadi komponen dalam kekosongan, tetapi dalam lingkungan yang sangat nyata.  Dan ini sudah akan mirip dengan uji visual unit, meskipun kita tidak dapat berbicara tentang modularitas jika "unit" tahu sesuatu tentang lingkungan.  Baiklah, oke, tidak terlalu penting apakah kategori tes termasuk tes visual - modular atau integrasi.  Seperti kata pepatah, "Anda memeriksa atau pergi?" <br><br><h2>  Pemilihan alat </h2><br>  Untuk mempercepat pelaksanaan tes, rendering halaman dapat dilakukan di beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">browser tanpa kepala</a> yang melakukan semua pekerjaan di memori tanpa ditampilkan di layar dan memastikan kinerja maksimum.  Tetapi dalam kasus kami, sangat penting untuk memastikan bahwa aplikasi berfungsi di Internet Explorer (IE), yang tidak memiliki mode tanpa kepala, dan kami membutuhkan alat untuk mengelola browser secara terprogram.  Untungnya, semuanya telah ditemukan sebelum kita dan ada instrumen seperti itu - disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Selenium</a> .  Sebagai bagian dari proyek Selenium, driver sedang dikembangkan untuk mengelola berbagai browser, termasuk driver untuk IE.  Server selenium dapat mengelola browser tidak hanya secara lokal, tetapi juga dari jarak jauh, membentuk sekelompok server selenium, yang disebut jaringan selenium. <br><br>  Selenium adalah alat yang ampuh, tetapi ambang untuk memasukkannya cukup tinggi.  Kami memutuskan untuk mencari alat yang siap pakai untuk pengujian visual berdasarkan Selenium dan menemukan produk hebat dari Yandex bernama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gemini</a> .  Gemini dapat mengambil gambar, termasuk gambar dari area halaman tertentu, membandingkan gambar dengan yang referensi, memvisualisasikan perbedaan dan memperhitungkan momen-momen seperti anti-aliasing atau kursor yang berkedip.  Selain itu, Gemini dapat melakukan tayangan ulang tes jatuh, memparalelkan pelaksanaan tes, dan banyak barang lainnya.  Secara umum, kami memutuskan untuk mencoba. <br><br>  Tes Gemini mudah ditulis.  Pertama, Anda perlu menyiapkan infrastruktur - instal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selenium-standalone</a> dan mulai server selenium.  Kemudian konfigurasikan gemini, tentukan alamat aplikasi yang sedang diuji (rootUrl), alamat server selenium (gridUrl), komposisi dan konfigurasi browser, serta plugin yang diperlukan untuk menghasilkan laporan, mengoptimalkan kompresi gambar.  Contoh Konfigurasi: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//.gemini.js module.exports = { rootUrl: 'http://my-app.ru', gridUrl: 'http://127.0.0.1:4444/wd/hub', browsers: { chrome: { windowSize: '1920x1080', screenshotsDir:'gemini/screens/1920x1080' desiredCapabilities: { browserName: 'chrome' } } }, system: { projectRoot: '', plugins: { 'html-reporter/gemini': { enabled: true, path: './report' }, 'gemini-optipng': true }, exclude: [ '**/report/*' ], diffColor: '#EC041E' } };</span></span></code> </pre> <br>  Tes itu sendiri adalah kumpulan suite, di mana masing-masing satu atau lebih gambar (negara bagian) diambil.  Sebelum mengambil metode snapshot (tangkap ()), Anda dapat mengatur area halaman yang akan diambil menggunakan metode setCaptureElements (), dan juga melakukan beberapa tindakan persiapan jika perlu dalam konteks browser menggunakan metode objek tindakan atau menggunakan kode JavaScript acak - untuk ini dalam tindakan memiliki metode executeJS (). <br><br>  Contoh: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'login-dialog'</span></span>, suite =&gt; { suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.login__form'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'default'</span></span>); .capture(<span class="hljs-string"><span class="hljs-string">'focused'</span></span>, actions =&gt; actions.focus(<span class="hljs-string"><span class="hljs-string">'.login__editor'</span></span>)); });</code> </pre> <br><h2>  Uji data </h2><br>  Alat uji dipilih, tetapi masih jauh dari solusi akhir.  Itu perlu untuk memahami apa yang harus dilakukan dengan data yang ditampilkan dalam gambar.  Biarkan saya mengingatkan Anda bahwa dalam tes kami memutuskan untuk tidak menggambar komponen individu, tetapi seluruh halaman aplikasi, untuk menguji komponen visual tidak dalam ruang hampa, tetapi dalam lingkungan nyata komponen lainnya.  Jika Anda perlu mentransfer data uji yang diperlukan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat peraga</a> (saya berbicara tentang komponen reaksi) untuk membuat komponen individual, lebih banyak yang diperlukan untuk membuat seluruh halaman aplikasi, dan mempersiapkan lingkungan untuk pengujian semacam itu bisa menjadi sakit kepala. <br><br>  Tentu saja, Anda dapat meninggalkan aplikasi itu sendiri untuk menerima data sehingga selama pengujian itu akan mengeksekusi permintaan ke backend, yang, pada gilirannya, akan menerima data dari beberapa jenis database referensi, tetapi bagaimana dengan versi?  Anda tidak bisa meletakkan basis data di repositori git.  Tidak, tentu saja Anda bisa, tetapi ada beberapa kesopanan. <br><br>  Atau, untuk menjalankan tes, Anda dapat mengganti server backend nyata dengan yang palsu, yang akan memberikan aplikasi web bukan data dari database, tetapi data statis yang disimpan, misalnya, dalam format json, sudah dengan sumber.  Namun, persiapan data tersebut juga tidak terlalu sepele.  Kami memutuskan untuk pergi dengan cara yang lebih mudah - bukan untuk menarik data dari server, tetapi hanya untuk mengembalikan keadaan aplikasi (dalam kasus kami, keadaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan redux</a> ), yang ada dalam aplikasi pada saat gambar referensi diambil, sebelum menjalankan tes. <br><br>  Untuk membuat cerita bersambung keadaan saat ini dari toko redux, metode snapshot () telah ditambahkan ke objek jendela: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snapshotStore = (store: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">fileName</span></span>: string): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = store.getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob( [ <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(state, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } ); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); a.href = URL.createObjectURL(file); a.download = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${fileName}</span></span></span><span class="hljs-string">.testdata.json`</span></span>; a.click(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`State downloaded to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a.download}</span></span></span><span class="hljs-string">`</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.snapshot = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> snapshotStore(store, fileName); };</code> </pre><br>  Menggunakan metode ini, menggunakan baris perintah konsol browser, Anda dapat menyimpan kondisi penyimpanan redux saat ini ke file: <br><br><img src="https://habrastorage.org/webt/qf/t0/yq/qft0yqppzfe_issnjy74jon-vbs.png" alt="gambar"><br><br>  Sebagai infrastruktur untuk tes visual, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Storybook</a> dipilih - alat untuk pengembangan interaktif perpustakaan komponen visual.  Gagasan utamanya adalah alih-alih berbagai status komponen di pohon cerita, perbaiki berbagai status aplikasi kita dan gunakan status ini untuk mengambil tangkapan layar.  Pada akhirnya, tidak ada perbedaan mendasar antara komponen sederhana dan kompleks, kecuali dalam persiapan lingkungan. <br><br>  Jadi, setiap tes visual adalah sebuah cerita, sebelum rendering, kondisi penyimpanan redux yang sebelumnya disimpan dalam file dipulihkan.  Ini dilakukan dengan menggunakan komponen Penyedia dari pustaka reaksi-redux, ke properti toko yang status deserialisasinya dikembalikan dari file yang disimpan sebelumnya dilewatkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preloadedState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./incoming-letter.testdata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(rootReducer, preloadedState); storiesOf(<span class="hljs-string"><span class="hljs-string">'regression/Cards'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) .add(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContextContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...dummyProps</span></span></span></span><span class="xml"><span class="hljs-tag">}/&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); });</span></span></code> </pre><br>  Pada contoh di atas, ContextContainer adalah komponen yang mencakup "kerangka" aplikasi - pohon navigasi, header, dan area konten.  Di area konten, berbagai komponen dapat ditampilkan (daftar, kartu, dialog, dll.) Tergantung pada kondisi penyimpanan redux saat ini.  Agar komponen tidak memenuhi permintaan yang tidak perlu ke backend untuk input, properti rintisan yang sesuai dilewatkan ke sana. <br><br>  Dalam konteks Buku Cerita, itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/jx/0m/ux/jx0muxytucrqrwzpvtnskjuqs1a.png" alt="gambar"><br><br><h2>  Gemini + buku cerita </h2><br>  Jadi, kami menemukan data untuk tes.  Tugas selanjutnya adalah berteman dengan Gemini dan Storybook.  Sekilas, semuanya sederhana - dalam konfigurasi Gemini kami menentukan alamat aplikasi yang sedang diuji.  Dalam kasus kami, ini adalah alamat server Storybook.  Anda hanya perlu menaikkan server buku cerita sebelum memulai tes gemini.  Anda dapat melakukan ini langsung dari kode menggunakan berlangganan acara Gemini START_RUNNER dan END_RUNNER: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">6006</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cofiguration = { <span class="hljs-attr"><span class="hljs-attr">rootUrl</span></span>:<span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">gridUrl</span></span>: seleniumGridHubUrl, <span class="hljs-attr"><span class="hljs-attr">browsers</span></span>: { <span class="hljs-string"><span class="hljs-string">'chrome'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">screenshotsDir</span></span>:<span class="hljs-string"><span class="hljs-string">'gemini/screens'</span></span>, <span class="hljs-attr"><span class="hljs-attr">desiredCapabilities</span></span>: chromeCapabilities } } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Gemini = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HttpServer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http-server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> runner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gemini(cofiguration); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = HttpServer.createServer({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: <span class="hljs-string"><span class="hljs-string">'./storybook-static'</span></span>}); runner.on(runner.events.START_RUNNER, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`storybook server is listening on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">...`</span></span>); server.listen(port); }); runner.on(runner.events.END_RUNNER, () =&gt; { server.close(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'storybook server is closed'</span></span>); }); runner .readTests(path) .done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests));</code> </pre> <br>  Sebagai server untuk pengujian, kami menggunakan http-server, yang mengembalikan konten folder dengan buku cerita rakitan statis (untuk membangun buku cerita statis, gunakan perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">build-storybook</a> ). <br><br>  Sejauh ini, semuanya berjalan lancar, tetapi masalah belum membuat mereka menunggu.  Faktanya adalah bahwa buku cerita menampilkan cerita di dalam bingkai.  Awalnya, kami ingin dapat mengatur wilayah selektif dari gambar menggunakan setCaptureElements (), tetapi ini hanya dapat dilakukan jika Anda menentukan alamat bingkai sebagai alamat untuk suite, sesuatu seperti ini: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'http://localhost:6006/iframe.html?selectedKind=regression%2Fcards&amp;selectedStory=IncomingLetter'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.some-component'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>) );</code> </pre><br>  Tapi kemudian ternyata untuk setiap shot kita harus membuat suite sendiri, karena  URL dapat ditetapkan untuk suite secara keseluruhan, tetapi tidak untuk snapshot tunggal di dalam suite.  Harus dipahami bahwa setiap suite berjalan dalam sesi browser yang terpisah.  Ini, pada prinsipnya, benar - tes tidak boleh saling bergantung, tetapi membuka sesi browser terpisah dan memuat Storybook selanjutnya membutuhkan waktu yang cukup banyak, lebih dari sekadar menelusuri cerita dalam kerangka Storybook yang sudah terbuka.  Oleh karena itu, dengan sejumlah besar suite, waktu pelaksanaan tes sangat lambat.  Bagian dari masalah dapat diselesaikan dengan memparalelkan pelaksanaan tes, tetapi paralelisasi menghabiskan banyak sumber daya (memori, prosesor).  Oleh karena itu, setelah memutuskan untuk menghemat sumber daya dan pada saat yang sama tidak kehilangan terlalu banyak dalam durasi uji coba, kami menolak untuk membuka bingkai di jendela browser yang terpisah.  Tes dilakukan dalam satu sesi browser, tetapi sebelum setiap pengambilan gambar, cerita selanjutnya dimuat ke dalam bingkai seolah-olah kita baru saja membuka buku cerita dan mengklik pada masing-masing node di pohon cerita.  Area gambar - seluruh bingkai: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'ProjectDocument'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'ProjectDocumentAccess'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>, actions =&gt; { openStory(actions, <span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>); hover(actions, <span class="hljs-string"><span class="hljs-string">'.related-documents-tree-item__title'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }) );</code> </pre> <br>  Sayangnya, dalam opsi ini, selain kemampuan untuk memilih area gambar, kami juga kehilangan kemampuan untuk menggunakan tindakan standar dari mesin Gemini untuk bekerja dengan elemen-elemen dari pohon DOM (mouseDown (), mouseMove (), mouseMove (), fokus (), dll), dll. untuk.  Elemen-elemen dalam bingkai Gemini tidak "melihat."  Tetapi kami masih memiliki kesempatan untuk menggunakan fungsi executeJS (), yang dengannya Anda dapat mengeksekusi kode JavaScript dalam konteks browser.  Berdasarkan fungsi ini, kami mengimplementasikan analog dari tindakan standar yang kami butuhkan, yang sudah bekerja dalam konteks bingkai Storybook.  Di sini kami harus "menyulap" sedikit untuk mentransfer nilai parameter dari konteks pengujian ke konteks browser - mengeksekusi JS (), sayangnya, tidak memberikan kesempatan seperti itu.  Oleh karena itu, pada pandangan pertama, kode tampak sedikit aneh - fungsi diterjemahkan ke dalam string, bagian dari kode diganti dengan nilai parameter, dan dalam ExecuteJs () fungsi dikembalikan dari string menggunakan eval (): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openStory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, storyName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> storyNameLowered = storyName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickTo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).filter( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.textContent.toLowerCase() === <span class="hljs-string"><span class="hljs-string">'storyNameLowered'</span></span>; })[<span class="hljs-number"><span class="hljs-number">0</span></span>].click(); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clickTo.toString().replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'storyNameLowered'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, storyNameLowered)}</span></span></span><span class="hljs-string">)`</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, targets, index, events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelector(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>).contentWindow.document; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'targets'</span></span>)[index || <span class="hljs-number"><span class="hljs-number">0</span></span>]; events.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickEvent = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent(<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>); clickEvent.initEvent(event, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); target.dispatchEvent(clickEvent); }); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dispatch.toString() .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'targets'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, targets) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'index'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, index) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'events'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`["</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${events.join(</span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'","'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">)}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"]`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">)`</span></span> )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hover</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, selectors, index</span></span></span><span class="hljs-function">) </span></span>{ dispatchEvents(actions, selectors, index, [ <span class="hljs-string"><span class="hljs-string">'mouseenter'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseover'</span></span> ]); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">openStory</span></span>: openStory, <span class="hljs-attr"><span class="hljs-attr">hover</span></span>: hover };</code> </pre><br><h2>  Pengulangan eksekusi </h2><br>  Setelah tes visual ditulis dan mulai bekerja, ternyata beberapa tes tidak terlalu stabil.  Di suatu tempat, ikon tidak akan punya waktu untuk menggambar, di suatu tempat pemilihan tidak akan dihapus dan kami mendapatkan ketidakcocokan dengan gambar referensi.  Oleh karena itu, diputuskan untuk memasukkan pengujian ulang pelaksanaan tes.  Namun, di Gemini, coba ulangi pekerjaan untuk seluruh rangkaian, dan seperti yang disebutkan di atas, kami mencoba menghindari situasi di mana rangkaian dibuat untuk setiap tembakan - ini memperlambat pelaksanaan tes terlalu banyak.  Di sisi lain, semakin banyak bidikan yang diambil dalam kerangka satu suite, semakin besar kemungkinan eksekusi berulang suite dapat jatuh serta yang sebelumnya.  Oleh karena itu, perlu dilakukan retries.  Dalam skema kami, pengulangan eksekusi tidak dilakukan untuk seluruh rangkaian, tetapi hanya untuk gambar-gambar yang tidak lulus pada kegagalan sebelumnya.  Untuk melakukan ini, di pengendali event TEST_RESULT, kami menganalisis hasil membandingkan snapshot dengan referensi, dan untuk snapshot yang tidak lulus perbandingan, dan hanya untuk mereka, kami membuat suite baru: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SuiteCollection = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite-collection'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Suite = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retrySuiteCollection; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; runner.on(runner.events.BEGIN, () =&gt; { retrySuiteCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuiteCollection(); }); runner.on(runner.events.TEST_RESULT, args =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testId = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.state.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.suite.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.browserId}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.equal) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.yellow(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suite = retrySuiteCollection.topLevelSuites().find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.suite.name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite) { suite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Suite(args.suite.name); suite.url = args.suite.url; suite.file = args.suite.file; suite.path = args.suite.path; suite.captureSelectors = [ ...args.suite.captureSelectors ]; suite.browsers = [ ...args.suite.browsers ]; suite.skipped = [ ...args.suite.skipped ]; suite.beforeActions = [ ...args.suite.beforeActions ]; retrySuiteCollection.add(suite); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite.states.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.state.name)) { suite.addState(args.state.clone()); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(<span class="hljs-string"><span class="hljs-string">`passed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); });</code> </pre> <br>  Omong-omong, acara TEST_RESULT juga berguna untuk memvisualisasikan kemajuan tes saat mereka lulus.  Sekarang pengembang tidak perlu menunggu sampai semua tes selesai, ia dapat menghentikan eksekusi jika ia melihat ada sesuatu yang salah.  Jika eksekusi pengujian terputus, Gemini akan menutup sesi browser dengan benar yang dibuka oleh server selenium. <br><br>  Setelah menyelesaikan uji coba, jika suite baru tidak kosong, jalankan uji coba hingga jumlah pengulangan maksimum habis: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((retryCount--) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; result.failed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; retrySuiteCollection.topLevelSuites().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { runner.test(retrySuiteCollection, {}).done(onComplete); } } runner.readTests(path).done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests).done(onComplete));</code> </pre> <br><h2>  Ringkasan </h2><br>  Hari ini kami memiliki sekitar lima puluh tes visual yang mencakup keadaan visual utama aplikasi kami.  Tentu saja, tidak perlu berbicara tentang cakupan penuh tes UI, tetapi kami belum menetapkan tujuan seperti itu.  Tes bekerja dengan sukses baik di workstation pengembang dan di build agent.  Sementara pengujian dilakukan hanya dalam konteks Chrome dan Internet Explorer, tetapi di masa depan dimungkinkan untuk menghubungkan browser lain.  Semua ekonomi ini melayani jaringan Selemium dengan dua node yang digunakan pada mesin virtual. <br><br>  Dari waktu ke waktu, kita dihadapkan dengan fakta bahwa setelah rilis versi baru Chrome, perlu memperbarui gambar referensi karena fakta bahwa beberapa elemen mulai ditampilkan sedikit berbeda (misalnya, gulir), tetapi tidak ada yang bisa dilakukan mengenai hal itu.  Ini jarang terjadi, tetapi ketika Anda mengubah struktur toko redux, Anda harus mengambil kembali status yang disimpan untuk pengujian.  Untuk mengembalikan keadaan yang persis sama dengan yang di tes pada saat penciptaannya, tentu saja, tidak mudah.  Sebagai aturan, tidak ada yang sudah mengingat di database mana foto-foto ini diambil dan Anda harus mengambil gambar baru pada data lain.  Ini masalah, tapi bukan masalah besar.  Untuk mengatasinya, Anda dapat mengambil gambar dengan basis demo, karena kami memiliki skrip untuk generasinya dan selalu diperbarui. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454464/">https://habr.com/ru/post/id454464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454452/index.html">Kami menampilkan konten pada gambar yang dikenali berdasarkan aturan tertentu</a></li>
<li><a href="../id454456/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 7. FAQ</a></li>
<li><a href="../id454458/index.html">Pengujian metamorf: mengapa hampir tidak ada yang tahu tentang teknik yang menjanjikan ini</a></li>
<li><a href="../id454460/index.html">Intisari materi menarik untuk pengembang ponsel # 300 (27 Mei - 2 Juni)</a></li>
<li><a href="../id454462/index.html">Fotogram tanpa kertas foto</a></li>
<li><a href="../id454470/index.html">Hidup sebelum runtime. Laporan Yandex</a></li>
<li><a href="../id454472/index.html">Yang Perlu Anda Ketahui Tentang Patch Router Terbaru Cisco</a></li>
<li><a href="../id454474/index.html">Acara digital di Moskow dari 3 hingga 9 Juni</a></li>
<li><a href="../id454476/index.html">Praktik Terbaik Node.js - Tip Struktur Proyek</a></li>
<li><a href="../id454478/index.html">Ekstensi Azure IoT Edge Tools (Pratinjau) diumumkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>