<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë üèº üö¥üèø EBA-Architektur, auch bekannt als Vollreaktivit√§t üê¢ ü§öüèº üö£üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin vor ein paar Jahren zu Tinkoff gekommen, und zwar wegen eines neuen Projekts, Kunden und Projekte , das gerade in den Startl√∂chern war. 
 Jetz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EBA-Architektur, auch bekannt als Vollreaktivit√§t</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/474612/"><p>  Ich bin vor ein paar Jahren zu Tinkoff gekommen, und zwar wegen eines neuen Projekts, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kunden und Projekte</a> , das gerade in den Startl√∂chern war. <br>  Jetzt kann ich mich nicht mehr an meine Gef√ºhle aus der damals neuen Architektur erinnern.  Aber ich erinnere mich sicher: Es war ungew√∂hnlich, dass Rx au√üerhalb der √ºblichen Fahrten zum Netzwerk und zur Basis woanders verwendet wird.  Jetzt, da diese Architektur bereits einen evolution√§ren Entwicklungspfad durchlaufen hat, m√∂chte ich endlich dar√ºber sprechen, was passiert ist und was dazu gekommen ist. </p><br><p><img src="https://habrastorage.org/webt/gk/ru/ve/gkruveswoxzhqfxjfasm_vaf2qq.png"></p><br><p>  Meiner Meinung nach sind alle derzeit g√§ngigen Architekturen - MVP, MVVM und sogar MVI - schon lange in der Arena und nicht immer verdient.  Haben sie keine M√§ngel?  Ich sehe viele von ihnen.  Wir haben an unserer Stelle entschieden, dass es ausreicht, um es auszuhalten, und haben eine neue, asynchrone Architektur (neu) erfunden. </p><a name="habracut"></a><br><p>  Ich werde kurz beschreiben, was mir an aktuellen Architekturen nicht gef√§llt.  Einige Punkte k√∂nnen kontrovers sein.  Vielleicht haben Sie das noch nie erlebt, Sie schreiben perfekte und allgemein Jedi-Programmierung.  Dann vergib mir, ein S√ºnder. <br>  Also mein Schmerz ist: </p><br><ul><li>  Riesiger Moderator / ViewModel. </li><li>  Eine riesige Menge an Switch-Case in MVI. </li><li>  Die Unf√§higkeit, Teile von Presenter / ViewModel wiederzuverwenden, und folglich die Notwendigkeit, Code zu duplizieren. </li><li>  Viele ver√§nderbare Variablen, die von √ºberall ge√§ndert werden k√∂nnen.  Dementsprechend ist ein solcher Code schwierig zu warten und zu modifizieren. </li><li>  Nicht zerlegte Bildschirmaktualisierung. </li><li>  Es ist schwer, Tests zu schreiben. </li></ul><br><h2 id="problematika">  <strong>Problem</strong> </h2><br><blockquote>  Zu jedem Zeitpunkt hat die Anwendung einen bestimmten Status, der ihr Verhalten und das, was der Benutzer sieht, definiert.  Dieser Status enth√§lt alle Werte von Variablen - von einfachen Flags bis zu einzelnen Objekten.  Jede dieser Variablen lebt ihr eigenes Leben und wird von verschiedenen Teilen des Codes gesteuert.  Sie k√∂nnen den aktuellen Status der Anwendung nur ermitteln, indem Sie alle nacheinander √ºberpr√ºfen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Artikel zur modernen Kotlin MVI-Architektur</a> <br><cut></cut><br></blockquote><br><h2 id="glava-1-evolyuciya--nashe-vsyo">  <strong>Kapitel 1. Evolution ist unser Alles</strong> </h2><br><p>  Anfangs haben wir √ºber MVP geschrieben, aber ein wenig mutiert.  Es war eine Mischung aus MVP und MVI.  Es gab Entit√§ten von MVP in Form eines Presenters und einer View-Oberfl√§che: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewTaskView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newTaskAction: Observable&lt;NewTaskAction&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> taskNameChangeAction: Observable&lt;String&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onChangeState: Consumer&lt;SomeViewState&gt; }</code> </pre> <br><p>  Bereits hier k√∂nnen Sie den Haken bemerken: Ansicht hier ist sehr weit von den Kanonen von MVP entfernt.  Es gab eine Methode im Moderator: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeView</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Disposable</code> </pre> <br><p>  Drau√üen wurde eine Schnittstellenimplementierung √ºbergeben, die √Ñnderungen an der Benutzeroberfl√§che reaktiv abonnierte.  Und es riecht schon nach MVI! </p><br><p>  Mehr ist mehr.  In Presenter wurden verschiedene Interaktoren erstellt und abonniert, die die Ansichts√§nderungen jedoch nicht direkt aufriefen, sondern einen globalen Status zur√ºckgaben, in dem alle m√∂glichen Bildschirmzust√§nde vorhanden waren: </p><br><pre> <code class="kotlin hljs">compositeDisposable.add( Observable.merge(firstAction, secondAction) .observeOn(AndroidSchedulers.mainThread()) .subscribe(view.onChangeState)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compositeDisposable</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewState</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> progress: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> error: Throwable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage: String? = error?.message, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result: TaskUi? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre><br><p>  Die Aktivit√§t war der Nachkomme der SomeViewStateMachine-Schnittstelle: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSuccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeUiModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toProgress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buttonEnabled: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Wenn der Benutzer auf etwas auf dem Bildschirm klickte, kam ein Ereignis in den Pr√§sentator und er erstellte ein neues Modell, das von einer speziellen Klasse gezeichnet wurde: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateResolver</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateMachine: SomeViewStateMachine) : Consumer&lt;SomeViewState&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stateUpdate: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeViewState</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.toSuccess(stateUpdate.result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.error != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { stateMachine.toError(stateUpdate.errorMessage) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { stateMachine.toProgress() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.someButtonEnabled != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.changeSomeButton(stateUpdate.someButtonEnabled) } } }</code> </pre> <br><p>  Stimmen Sie zu, ein seltsamer MVP und sogar weit weg von MVI.  Auf der Suche nach Inspiration. </p><br><h2 id="glava-2-redux">  <strong>Kapitel 2. Redux</strong> </h2><br><p><img src="https://habrastorage.org/webt/sw/bm/pf/swbmpfddkyjohcxemag4a0zdatm.jpeg"></p><br><p>  Als unser (damals noch) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chef Sergey Boishtyan</a> √ºber seine Probleme mit anderen Entwicklern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sprach,</a> erfuhr er von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux</a> . </p><br><p>  Nachdem wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dorfmans Vortrag √ºber alle Architekturen gesehen</a> und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux gespielt hatten</a> , beschlossen wir, ihn zur Aktualisierung unserer Architektur zu verwenden. <br>  Aber schauen wir uns zuerst die Architektur genauer an und betrachten ihre Vor- und Nachteile. </p><br><p>  <strong>Aktion</strong> <br>  Beschreibt die Aktion. </p><br><p>  <strong>Actioncreator</strong> <br>  Er ist wie ein Systemanalytiker: Formate, erg√§nzt die Kundenanforderungsspezifikation, damit Programmierer ihn verstehen. <br>  Wenn der Benutzer auf den Bildschirm klickt, bildet ActionsCreator eine Aktion, die zur Middleware wechselt (eine Art Gesch√§ftslogik).  Die Gesch√§ftslogik gibt uns neue Daten, die ein bestimmter Reduzierer empf√§ngt und zeichnet. </p><br><p>  Wenn Sie sich das Bild noch einmal ansehen, bemerken Sie m√∂glicherweise ein Objekt wie Speichern.  Store speichert Reduzierer.  Das hei√üt, wir sehen, dass die Front-End-Br√ºder - ungl√ºckliche Br√ºder - vermutet haben, dass ein gro√ües Objekt in viele kleine zers√§gt werden kann, von denen jedes f√ºr seinen eigenen Teil des Bildschirms verantwortlich ist.  Und das ist einfach ein wunderbarer Gedanke! </p><br><p>  Beispielcode f√ºr einfache ActionCreators (vorsichtig, JavaScript!): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ADD_TODO, text } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggleTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: TOGGLE_TODO, index } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setVisibilityFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: SET_VISIBILITY_FILTER, filter } }</code> </pre> <br><p>  <strong>Reduzierst√ºck</strong> </p><br><blockquote>  Aktionen beschreiben die Tatsache, dass etwas passiert ist, geben jedoch nicht an, wie sich der Status der Anwendung als Reaktion √§ndern soll. Dies funktioniert f√ºr Reducer. </blockquote><p>  Kurz gesagt, Reducer wei√ü, wie der / view-Bildschirm zerlegt aktualisiert wird. </p><br><p>  Vorteile: </p><br><ul><li>  Zerlegte Bildschirmaktualisierung. </li><li>  Unidirektionaler Datenstrom. </li></ul><br><p>  Nachteile: </p><br><ul><li>  Lieblingsschalter wieder. <br><pre> <code class="kotlin hljs">function todoApp(state = initialState, action) { switch (action.type) { case SET_VISIBILITY_FILTER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { visibilityFilter: action.filter }) case ADD_TODO: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { todos: [ ...state.todos, { text: action.text, completed: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] }) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state }</code> </pre> </li><li>  Eine Reihe von Staatsobjekten. </li><li>  Trennung der Logik in ActionCreator und Reducer. </li></ul><br><p>  Ja, es schien uns, dass die Trennung von ActionCreator und Reducer nicht die beste Option ist, um das Modell und den Bildschirm zu verbinden, da das Schreiben einer Instanz von (is) ein schlechter Ansatz ist.  Und hier haben wir UNSERE Architektur erfunden! </p><br><h2 id="glava-3-eba">  <strong>Kapitel 3. EBA</strong> </h2><br><p><img src="https://habrastorage.org/webt/os/6w/7_/os6w7_sgmegw6nsh7lyebs_o9de.jpeg"></p><br><p>  Was ist Action und ActionCreator im Kontext von EBA: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionCreator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"></span></span><span class="hljs-class"><span class="hljs-type"></span></span>(T) -&gt; (Observable&lt;Action&gt;)</code> </pre> <br><p>  Ja, die H√§lfte der Architektur besteht aus Typealias und einer Schnittstelle.  Einfachheit ist gleich Eleganz! </p><br><p>  Es sind Ma√ünahmen erforderlich, um etwas aufzurufen, ohne Daten zu √ºbertragen.  Da ActionCreator ein Observable zur√ºckgibt, mussten wir Action in ein anderes Lambda einbinden, um einige Daten zu √ºbertragen.  Und so stellte sich heraus, dass ActionMapper eine typisierte Aktion ist, durch die wir alles √ºbergeben k√∂nnen, was wir zum Aktualisieren des Bildschirms / der Ansicht ben√∂tigen. <br><br>  <strong>Grund Postulate:</strong> <br></p><div class="spoiler">  <b class="spoiler_title">Ein ActionCreator - ein Teil des Bildschirms</b> <div class="spoiler_text"><p>  Mit dem ersten Absatz ist alles klar: Damit unverst√§ndliche Cross-Updates nichts anhaben k√∂nnen, haben wir uns darauf geeinigt, dass ein ActionCreator nur seinen Teil des Bildschirms aktualisieren kann.  Wenn es sich um eine Liste handelt, wird nur die Liste aktualisiert, wenn nur die Schaltfl√§che angezeigt wird. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Dolch wird nicht ben√∂tigt</b> <div class="spoiler_text"><p>  Aber man fragt sich, warum hat uns Dolch nicht gefallen?  Ich sage es dir. <br>  Eine typische Geschichte ist, wenn ein abstrakter Sergey alias Dolchmeister alias ‚ÄûWas macht dieser abstrakte?‚Äú Am Projekt ist. </p><br><p>  Es stellt sich heraus, dass Sie, wenn Sie mit einem Dolch experimentiert haben, jedes Mal jedem neuen (und nicht nur neuen) Entwickler erkl√§ren m√ºssen.  Oder vielleicht haben Sie selbst bereits vergessen, was diese Anmerkung bewirkt, und Sie gehen auf Google. </p><br><p>  All dies erschwert das Erstellen von Features erheblich, ohne viel Komfort zu bieten.  Aus diesem Grund haben wir uns entschlossen, die ben√∂tigten Elemente mit unseren H√§nden zu erstellen, damit der Zusammenbau schneller vonstatten geht, da keine Codegenerierung erfolgt.  Ja, wir werden zus√§tzliche f√ºnf Minuten damit verbringen, alle Abh√§ngigkeiten mit unseren H√§nden zu schreiben, aber wir werden viel Zeit beim Kompilieren sparen.  Ja, wir haben den Dolch nicht √ºberall aufgegeben, er wird auf globaler Ebene verwendet, er schafft einige gemeinsame Dinge, aber wir schreiben sie zur besseren Optimierung in Java, um kapt nicht anzulocken. </p></div></div><br><p>  <strong>Architekturschema</strong> : </p><br><p><img src="https://habrastorage.org/webt/1w/m6/1a/1wm61atrwg2dmy4hkzfherwsbqc.png"></p><br><p>  Komponente ist ein Analogon derselben Komponente von Dagger, nur ohne Dolch.  Seine Aufgabe ist es, einen Ordner zu erstellen.  Binder bindet ActionCreators zusammen.  Von Ansicht zu Ordner Ereignisse werden durch Ereignisse ausgel√∂st, und von Ordner zu Ansicht werden Aktionen gesendet, die den Bildschirm aktualisieren. </p><br><p>  <strong>Actioncreator</strong> </p><br><p><img src="https://habrastorage.org/webt/8v/nw/3p/8vnw3p52mcfzyyhegcxtkexgokm.png"></p><br><p>  Nun wollen wir sehen, was das ist - ActionCreator.  Im einfachsten Fall wird die Aktion einfach unidirektional verarbeitet.  Angenommen, es gibt ein solches Szenario: Der Benutzer hat auf die Schaltfl√§che "Aufgabe erstellen" geklickt.  Ein weiterer Bildschirm sollte sich √∂ffnen, wo wir ihn beschreiben werden, ohne zus√§tzliche Anforderungen. </p><br><p>  Dazu abonnieren wir einfach den Button mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxBinding</a> von unserem geliebten Jake und warten, bis der Benutzer darauf klickt.  Sobald ein Klick erfolgt, sendet Binder das Ereignis an einen bestimmten ActionCreator, der unsere Aktion aufruft und einen neuen Bildschirm f√ºr uns √∂ffnet.  Beachten Sie, dass es keine Schalter gab.  Als n√§chstes werde ich im Code zeigen, warum das so ist. <br>  Wenn wir pl√∂tzlich zum Netzwerk oder zur Datenbank gehen m√ºssen, stellen wir diese Anforderungen genau dort, aber √ºber die Interaktoren, die wir √ºber die Schnittstelle an den ActionCreator-Konstruktor √ºbergeben haben, um sie aufzurufen: </p><br><blockquote>  Haftungsausschluss: Die Formatierung des Codes stimmt hier nicht ganz, ich habe seine Regeln f√ºr den Artikel, damit der Code gut gelesen wird. </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadItemsActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> getItems: () -&gt; Observable&lt;List&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> showLoadedItems: ActionMapper&lt;DiffResult&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diffCalculator: DiffCalculator&lt;ViewTyped&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorItem: ErrorView, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> emptyItem: ViewTyped? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) : ActionOnEvent</code> </pre> <br><p>  Mit den Worten "√ºber die Schnittstelle ihres Aufrufs" habe ich genau gemeint, wie getItems deklariert wird (hier ist ViewTyped unsere Schnittstelle zum Arbeiten mit Listen).  √úbrigens haben wir diesen ActionCreator in acht verschiedenen Teilen der Anwendung wiederverwendet, da er so vielseitig wie m√∂glich geschrieben ist. </p><br><p>  Da Ereignisse reaktiver Natur sind, k√∂nnen wir eine Kette zusammenstellen, indem wir andere Operatoren hinzuf√ºgen, z. B. startWith (showLoadingAction), um das Laden anzuzeigen, und onErrorReturn (errorAction), um einen Bildschirmstatus mit einem Fehler anzuzeigen. <br>  Und das alles ist reaktiv! </p><br><h2 id="primer-">  <strong>Beispiel</strong> </h2><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompositionFragment</span></span></span></span>(R.layout.fragment_about) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.clicks(), openProcessingPersDataEvent = personalDataProtection.clicks(), unbindEvent = unBindEvent) component.binder().bind(events) }</code> </pre> <br><p>  Schauen wir uns zum Schluss die Architektur am Beispiel von Code an.  Zu Beginn habe ich einen der einfachsten Bildschirme ausgew√§hlt - √ºber die Anwendung, da es sich um einen statischen Bildschirm handelt. <br>  Erw√§gen Sie das Erstellen einer Komponente: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } } )</code> </pre> <br><p>  Komponentenargumente - Actions / ActionMappers - helfen dabei, View mit ActionCreators zu verkn√ºpfen.  In ActionMapper'e setVersionName √ºbergeben wir die Version des Projekts und weisen diesen Wert dem Text auf dem Bildschirm zu.  In openPdfAction ein Linkpaar zu einem Dokument und ein Name, um den n√§chsten Bildschirm zu √∂ffnen, in dem der Benutzer dieses Dokument lesen kann. </p><br><p>  Hier ist die Komponente selbst: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionMapper&lt;String&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, someUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, anotherUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName = setVersionName.toSimpleActionCreator( moreComponent::currentVersionName ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AboutEventsBinder(setVersionName, openPolicyPrivacy, openProcessingPersonalData) } }</code> </pre> <br><p>  Ich m√∂chte Sie daran erinnern, dass: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action</code> </pre> <br><p>  OK, lass uns weitermachen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder</code> </pre> <br><p>  Schauen wir uns AboutEventsBinder genauer an. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEventsBinder</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData: ActionOnEvent) : BaseEventsBinder&lt;AboutEvents&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AboutEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.merge( setVersionName(events.bindEvent), openPolicyPrivacy(events.openPolicyPrivacyEvent), openProcessingPersonalData(events.openProcessingPersDataEvent)) } }</code> </pre> <br><p>  ActionOnEvent ist ein weiterer Typealias, um nicht jedes Mal zu schreiben. </p><br><pre> <code class="kotlin hljs">ActionCreator&lt;Observable&lt;*&gt;&gt;</code> </pre> <br><p>  In AboutEventsBinder √ºbergeben wir ActionCreators und binden sie beim Aufrufen an ein bestimmtes Ereignis.  Um zu verstehen, wie all dies zusammenh√§ngt, schauen wir uns die Basisklasse BaseEventsBinder an. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread() ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(events).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  Wir sehen die bekannte bindInternal-Methode, die wir im Nachfolger neu definiert haben.  Betrachten Sie nun die Bindemethode.  Die ganze Magie ist hier.  Wir akzeptieren den Erben der BaseEvents-Schnittstelle und √ºbergeben ihn an bindInternal, um Ereignisse und Aktionen zu verbinden.  Sobald wir das sagen, was auch immer kommt, f√ºhren wir den UI-Stream aus und abonnieren ihn.  Wir sehen auch einen interessanten Hack - takeUntil. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEvents</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable }</code> </pre> <br><p>  Nachdem wir das Feld unbindEvent in BaseEvents definiert haben, um das Abbestellen zu steuern, m√ºssen wir es in allen Erben implementieren.  In diesem wunderbaren Feld k√∂nnen Sie sich automatisch von der Kette abmelden, sobald dieses Ereignis abgeschlossen ist.  Es ist einfach toll!  Jetzt k√∂nnen Sie nicht folgen und sorgen sich nicht um den Lebenszyklus und schlafen friedlich. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, policyPrivacyUrl) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, personalDataUrl)</code> </pre> <br><p>  Zur√ºck zur Komponente.  Und hier sehen Sie bereits die Methode der Wiederverwendung.  Wir haben eine Klasse geschrieben, die den PDF-Bildschirm √∂ffnen kann, und es ist uns egal, um welche URL es sich handelt.  Keine Codeduplizierung. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenPdfActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pdfUrl: String) : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { openPdfAction(pdfUrl to pdfUrl.substringAfterLast(FILE_NAME_DELIMITER)) } } }</code> </pre> <br><p>  Der ActionCreator-Code ist auch so einfach wie m√∂glich. Hier f√ºhren wir nur einige Zeichenfolgenmanipulationen durch. </p><br><p>  Kehren wir zur Komponente zur√ºck und betrachten den folgenden ActionCreator: </p><br><pre> <code class="kotlin hljs">setVersionName.toSimpleActionCreator(moreComponent::currentVersionName)</code> </pre> <br><p>  Einmal wurden wir zu faul, um dieselben und von Natur aus einfachen ActionCreators zu schreiben.  Wir haben die Kraft von Kotlin genutzt und die Erweiterung geschrieben.  In diesem Fall mussten wir beispielsweise nur eine statische Zeichenfolge an ActionMapper √ºbergeben. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function"> ActionMapper</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSimpleActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( mapper: ()</span></span></span></span> -&gt; R): ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observable</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toSimpleActionCreator</span></span>(mapper()) } } } }</code> </pre> <br><p>  Es gibt Zeiten, in denen wir √ºberhaupt nichts senden m√ºssen, sondern nur eine Aktion aufrufen, um beispielsweise den folgenden Bildschirm zu √∂ffnen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Action.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toActionCreator</span></span> } } } }</code> </pre> <br><p>  Kehren Sie mit der Komponente zum Fragment zur√ºck: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.throttleFirstClicks(), openProcessingPersDataEvent = personalDataProtection.throttleFirstClicks(), unbindEvent = unBindEvent)</code> </pre> <br><p>  Hier sehen wir die Erstellung einer Klasse, die f√ºr den Empfang von Ereignissen vom Benutzer verantwortlich ist.  Und das Aufheben und Binden sind nur Bildschirmlebenszyklusereignisse, die wir mithilfe der Navi-Bibliothek von Trello erfassen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;T&gt; NaviComponent.observe(event: Event&lt;T&gt;): Observable&lt;T&gt; = RxNavi.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this, event)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unBindEvent: Observable&lt;*&gt; = observe(Event.DESTROY_VIEW) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: Observable&lt;*&gt; = Observable.just(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)  <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent = observe(Event.POST_CREATE)</code> </pre> <br><p>  Die Ereignisschnittstelle beschreibt die Ereignisse eines bestimmten Bildschirms und muss BaseEvents erben.  Das Folgende ist immer eine Implementierung der Schnittstelle.  In diesem Fall stellte sich heraus, dass die Ereignisse eins zu eins mit den Ereignissen auf dem Bildschirm waren. Es kommt jedoch vor, dass Sie zwei Ereignisse zusammenhalten m√ºssen. </p><br><p>  Zum Beispiel sollten Ereignisse des Bildschirmladens beim √ñffnen und erneuten Laden im Fehlerfall zu einem zusammengefasst werden - nur das Laden des Bildschirms. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseEvents { val bindEvent: EventObservable val openPolicyPrivacyEvent: EventObservable val openProcessingPersDataEvent: EventObservable } class AboutEventsImpl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacyEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersDataEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable) : AboutEvents</code> </pre> <br><p>  Wir kehren zum Fragment zur√ºck und kombinieren alles miteinander!  Wir bitten die Komponente, den Ordner zu erstellen und an uns zur√ºckzugeben, und rufen dann die Bindemethode auf, bei der wir das Objekt √ºbergeben, das die Bildschirmereignisse √ºberwacht. </p><br><pre> <code class="kotlin hljs">component.binder().bind(events)</code> </pre> <br><p>  Wir schreiben seit ungef√§hr zwei Jahren ein Projekt zu dieser Architektur.  Und das Gl√ºck der Manager in Bezug auf die Geschwindigkeit des Feature-Sharing ist unbegrenzt!  Sie haben keine Zeit, sich eine neue auszudenken, da wir die alte bereits fertigstellen.  Die Architektur ist sehr flexibel und erm√∂glicht es Ihnen, viel Code wiederzuverwenden. <br>  Der Nachteil dieser Architektur kann als Nichtkonservierung des Zustands bezeichnet werden.  Wir haben kein ganzes Modell, das den Status des Bildschirms beschreibt, wie in MVI, aber wir k√∂nnen damit umgehen.  Like - siehe unten. </p><br><h2 id="glava-4-bonus">  <strong>Kapitel 4. Bonus</strong> </h2><br><p>  Ich denke, jeder kennt das Problem der Analytik: Niemand schreibt es gerne, weil es durch alle Ebenen kriecht und Herausforderungen entstellt.  Vor einiger Zeit, und wir mussten uns dem stellen.  Dank unserer Architektur konnte jedoch eine sehr sch√∂ne Umsetzung erzielt werden. </p><br><p>  Also, was war meine Idee: Analytics geht normalerweise als Reaktion auf Benutzeraktionen.  Und wir haben nur eine Klasse, die Benutzeraktionen sammelt.  Ok, lass uns anfangen. </p><br><p>  <strong>Schritt 1</strong>  Wir √§ndern die BaseEventsBinder-Basisklasse geringf√ºgig, indem wir Ereignisse in trackAnalytics einschlie√üen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> trackAnalytics: TrackAnalytics&lt;EVENTS&gt; = EmptyAnalyticsTracker(), <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread()) { <span class="hljs-meta"><span class="hljs-meta">@SuppressLint(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CheckResult"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(trackAnalytics(events)).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  <strong>Schritt 2</strong>  Wir erstellen eine stabile Implementierung der Variablen trackAnalytics, um die Abw√§rtskompatibilit√§t aufrechtzuerhalten und die Erben, die noch keine Analyse ben√∂tigen, nicht zu brechen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyAnalyticsTracker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS = events }</code> </pre> <br><p>  <strong>Schritt 3</strong>  Wir schreiben die Implementierung der TrackAnalytics-Oberfl√§che f√ºr den gew√ºnschten Bildschirm - zum Beispiel f√ºr den Projektlistenbildschirm: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackProjectsEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ProjectsEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ProjectsEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ProjectsEvents { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ProjectsEvents <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> events { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boardClickEvent = events.boardClickEvent.trackTypedEvent { allProjectsProjectClick(it.title) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoardCreationEvent = events.openBoardCreationEvent.trackEvent { allProjectsAddProjectClick() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardsSearchEvent = events.openCardsSearchEvent.trackEvent { allProjectsSearchBarClick() } } } }</code> </pre> <br><p>  Auch hier nutzen wir die Macht von Kotlin in Form von Delegierten.  Wir haben bereits einen von uns erstellten Schnittstellenvererb - in diesem Fall ProjectsEvents.  Bei einigen Ereignissen m√ºssen Sie jedoch den Ablauf von Ereignissen neu definieren und beim Senden von Analysen eine Bindung hinzuf√ºgen.  Tats√§chlich ist trackEvent nur doOnNext: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec) } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackTypedEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec, it) }</code> </pre> <br><p>  <strong>Schritt 4</strong>  Dies muss noch an Binder weitergegeben werden.  Da wir es in einer Komponente erstellen, haben wir die M√∂glichkeit, dem Konstruktor bei Bedarf pl√∂tzlich zus√§tzliche Abh√§ngigkeiten hinzuzuf√ºgen.  Jetzt sieht der ProjectsEventsBinder-Konstruktor folgenderma√üen aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectsEventsBinder</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loadItems: LoadItemsActionCreator, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshBoards: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoard: ActionCreator&lt;Observable&lt;BoardId&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openScreen: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardSearch: ActionOnEvent, trackAnalytics: TrackAnalytics&lt;ProjectsEvents&gt;) : BaseEventsBinder&lt;ProjectsEvents&gt;(trackAnalytics)</code> </pre> <br><p>  Sie k√∂nnen sich andere Beispiele auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>GitHub</strong></a> ansehen. </p><br><h2 id="voprosy-i-otvety">  <strong>Fragen und Antworten</strong> </h2><br><div class="spoiler">  <b class="spoiler_title">Wie beh√§lt man den Bildschirmstatus bei?</b> <div class="spoiler_text"><p>  Auf keinen Fall.  Wir blockieren die Orientierung.  Wir verwenden aber auch Argumente / Intent und speichern dort die Variable OPENED_FROM_BACKSTACK.  Und wenn wir Binder entwerfen, sehen wir uns das an.  Wenn dies falsch ist, laden Sie die Daten aus dem Netzwerk.  Wenn wahr - aus dem Cache.  Auf diese Weise k√∂nnen Sie den Bildschirm schnell neu erstellen. </p><br><p>  F√ºr alle, die gegen das Blockieren der Ausrichtung sind: Versuchen Sie, Analysen zu testen und zu hinterlegen, wie oft Ihre Benutzer das Telefon umdrehen und wie viele sich in einer anderen Ausrichtung befinden.  Die Ergebnisse k√∂nnen √ºberraschen. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Ich m√∂chte keine Komponenten schreiben. Wie kann ich mich mit dem Dolch anfreunden?</b> <div class="spoiler_text"><p>  Ich rate nicht, aber wenn Ihnen die Kompilierungszeit nichts ausmacht, k√∂nnen Sie die Komponente auch mit einem Dolch erstellen.  Aber wir haben es nicht versucht. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Ich schreibe nicht in Kotlin. Was sind die Schwierigkeiten bei der Implementierung in Java?</b> <div class="spoiler_text"><p>  Trotzdem kann in Java geschrieben werden, nur wird es nicht so sch√∂n aussehen. </p></div></div><br><p>  Wenn Ihnen der Artikel gef√§llt, wird im n√§chsten Teil erl√§utert, wie Sie Tests f√ºr eine solche Architektur schreiben (dann wird klar, warum es so viele Schnittstellen gibt).  Spoiler - Das Schreiben ist einfach und Sie k√∂nnen auf allen Ebenen au√üer der Komponente schreiben, m√ºssen es jedoch nicht testen, sondern erstellen lediglich ein Binderobjekt. </p><br><p>  Vielen Dank an die Kollegen vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tinkoff Business</a> Mobile Development Team f√ºr ihre Hilfe beim Schreiben dieses Artikels. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474612/">https://habr.com/ru/post/de474612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474596/index.html">Anwendung auf TSD und Kommunikation mit 1C: Enterprise 8.3 √ºber HTTP-Service. Teil 5 (Men√º, Begleitobjekt)</a></li>
<li><a href="../de474598/index.html">So erhalten Sie ein Interview mit einem QS-Ingenieur ohne Berufserfahrung</a></li>
<li><a href="../de474602/index.html">L√∂sen Sie die Gleichung der einfachen linearen Regression</a></li>
<li><a href="../de474606/index.html">So funktioniert Blogspam</a></li>
<li><a href="../de474610/index.html">NUC-basiertes Mediensystem - Home Experience</a></li>
<li><a href="../de474618/index.html">Erstellen eines 3D-Konfigurators f√ºr WooCommerce</a></li>
<li><a href="../de474620/index.html">Informationssicherheit im Rechenzentrum</a></li>
<li><a href="../de474622/index.html">34 Open Source Python-Bibliotheken (2019)</a></li>
<li><a href="../de474626/index.html">Google Analytics- und Yandex.Metrica-Terminologie: So verwechseln Sie nicht all diese Daten</a></li>
<li><a href="../de474628/index.html">Einf√ºhrung in New Microsoft Edge und Bing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>