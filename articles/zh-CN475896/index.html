<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍⚖️ 🤽🏿 🧕🏼 全I / O裸C反应器 👼🏽 👲🏻 🥓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 I / O反应器 （单线程事件循环 ）是一种模式，用于编写在许多流行的解决方案中使用的高负载软件： 


- Node.js 
- 托尔 
- 传输方式 
- 铬色 
- 记忆快取 
- ... 


 在本文中，我们将考虑I / O反应器的来龙去脉及其操作原理，编写少于200行代码的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>全I / O裸C反应器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475896/"><p><img src="https://habrastorage.org/webt/2g/w7/vr/2gw7vrlwgzkro-gf3hkbj7jxqzu.png"></p><br><h1 id="vvedenie"> 引言 </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">I / O反应器</a> （单线程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">事件循环</a> ）是一种模式，用于编写在许多流行的解决方案中使用的高负载软件： </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Node.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">托尔</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">传输方式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">铬色</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">记忆快取</a> </li><li>  ... </li></ul><br><p> 在本文中，我们将考虑I / O反应器的来龙去脉及其操作原理，编写少于200行代码的实现，并强制一个简单的HTTP服务器每分钟处理超过4000万个请求。 </p><a name="habracut"></a><br><h1 id="predislovie"> 前言 </h1><br><ul><li> 撰写本文的目的是帮助理解I / O反应器的功能，从而认识使用I / O反应器的风险。 </li><li> 要掌握本文，您需要了解<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">C语言</a>的基础知识<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">，</a>并且需要很少的开发网络应用程序的经验。 </li><li> 所有代码均由C（严格<strong>地为长PDF</strong> ）严格地用C编写的Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">C11标准</a> ，并且可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">GitHub上获得</a> 。 </li></ul><br><h1 id="zachem-eto-nuzhno"> 为什么需要这个？ </h1><br><p> 随着Internet的日益普及，Web服务器需要同时处理大量连接，因此尝试了两种方法：阻止大量OS线程上的I / O和与事件通知系统（也称为“系统”）组合使用非阻止I / O。选择器”（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">epoll</a> / <a href="" rel="nofollow">kqueue</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">IOCP</a>等）。 </p><br><p> 第一种方法涉及为每个传入连接创建一个新的OS线程。 它的缺点是可伸缩性差：操作系统将不得不进行许多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">上下文转换</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">系统调用</a> 。 它们是昂贵的操作，并且会导致大量连接导致缺少可用RAM。 </p><br><p> 修改后的版本分配了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">固定数量的线程</a> （线程池），从而防止了系统异常停止执行，但是同时引入了一个新的问题：如果在给定的时刻线程池被长时间的读取操作阻塞，那么其他已经能够接收数据的套接字将无法执行此操作。 </p><br><p> 第二种方法使用操作系统提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">的事件通知系统</a> （系统选择器）。 本文根据有关I / O操作准备就绪的警报（事件，通知），而不是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">有关其完成情况的警报</a> ，讨论最常见的系统选择器类型。 下面的流程图可以表示其用法的简化示例： </p><br><p><img src="https://habrastorage.org/webt/rw/kb/yo/rwkbyokmirpu7hpd6yzc47-k4va.png"></p><br><p> 这些方法之间的区别如下： </p><br><ul><li> 阻塞的I / O操作会<strong>挂起</strong>用户流， <strong>直到</strong>操作系统<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">将</a>进入的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">IP数据包</a>正确<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">整理</a>到字节流（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">TCP</a> ，接收数据）或释放内部写缓冲区中的足够空间，以便随后通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">NIC</a>发送（发送数据）为止。 </li><li>  <strong>稍后，</strong>系统选择器会通知程序OS <strong>已对</strong> IP数据包进行碎片整理（TCP，正在接收数据）或内部记录缓冲区中的足够空间（发送数据）。 </li></ul><br><p> 总而言之，为每个I / O保留OS线程是在浪费计算能力，因为实际上，线程并不忙于有用的工作（术语<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">“软件中断”</a>植根<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">于其中</a> ）。 系统选择器通过允许用户程序更经济地消耗CPU资源来解决此问题。 </p><br><h1 id="model-io-reaktora"> 反应堆I / O型号 </h1><br><p>  I / O反应器充当系统选择器和用户代码之间的一层。 下面的流程图描述了其操作原理： </p><br><p><img src="https://habrastorage.org/webt/6j/v9/-m/6jv9-mplsvirwimvaej1zzyu2oa.png"></p><br><ul><li> 让我提醒您，事件是对某个套接字能够执行非阻塞I / O操作的通知。 </li><li> 事件处理程序是接收到事件后由I / O反应器调用的函数，然后该函数执行无阻塞的I / O操作。 </li></ul><br><p> 重要的是要注意，根据定义，I / O反应器是单线程的，但是没有什么可以阻止在多线程环境中针对1个流：1个反应器使用此概念，从而利用了所有CPU内核。 </p><br><h1 id="realizaciya"> 实作 </h1><br><p>我们将公共接口放在<a href="" rel="nofollow"><code>reactor.h</code></a>文件中，并将实现放在反应器<a href="" rel="nofollow"><code>reactor.c</code></a> 。  <code>reactor.h</code>将包含以下声明： </p><br><div class="spoiler">  <b class="spoiler_title">在reactor.h中显示广告</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reactor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reactor</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *   ,    I/O    *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Callback)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> events)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *  `NULL`   , -`NULL`   `Reactor`  *  . */</span></span> <span class="hljs-function"><span class="hljs-function">Reactor *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactor_new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *   ,       *    I/O . * *    -1   , 0   . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactor_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reactor *reactor)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactor_register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reactor *reactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interest, Callback callback, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *callback_arg)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactor_deregister</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reactor *reactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactor_reregister</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reactor *reactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interest, Callback callback, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *callback_arg)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *     - `timeout`. * *           * /    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactor_run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reactor *reactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">time_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span></span>;</code> </pre> </div></div><br><p> 反应器的I / O结构由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">epoll</a>选择器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">文件描述符</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>GHashTable</code></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">哈希表组成</a> ，每个套接字都将其映射到<code>CallbackData</code> （事件处理程序的结构和用户参数）。 </p><br><div class="spoiler">  <b class="spoiler_title">显示Reactor和CallbackData</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reactor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> epoll_fd; GHashTable *table; <span class="hljs-comment"><span class="hljs-comment">// (int, CallbackData) }; typedef struct { Callback callback; void *arg; } CallbackData;</span></span></code> </pre> </div></div><br><p> 请注意，我们使用了通过指针处理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">不完整类型</a>的功能。 在<code>reactor.h</code>我们声明了<code>reactor</code>的结构，在<code>reactor.c</code>定义了它的结构，从而防止了用户显式更改其字段。 这是有机地适合C语义的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">数据隐藏</a>模式之一。 </p><br><p>  <code>reactor_register</code> ， <code>reactor_deregister</code>和<code>reactor_reregister</code>更新目标选择器的列表以及系统选择器和哈希表中的相应事件处理程序。 </p><br><div class="spoiler">  <b class="spoiler_title">显示注册功能</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REACTOR_CTL(reactor, op, fd, interest) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (epoll_ctl(reactor-&gt;epoll_fd, op, fd, \ &amp;(struct epoll_event){.events = interest, \ .data = {.fd = fd}}) == -1) { \ perror(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"epoll_ctl"</span></span></span><span class="hljs-meta">); \ return -1; \ } int reactor_register(const Reactor *reactor, int fd, uint32_t interest, Callback callback, void *callback_arg) { REACTOR_CTL(reactor, EPOLL_CTL_ADD, fd, interest) g_hash_table_insert(reactor-&gt;table, int_in_heap(fd), callback_data_new(callback, callback_arg)); return 0; } int reactor_deregister(const Reactor *reactor, int fd) { REACTOR_CTL(reactor, EPOLL_CTL_DEL, fd, 0) g_hash_table_remove(reactor-&gt;table, &amp;fd); return 0; } int reactor_reregister(const Reactor *reactor, int fd, uint32_t interest, Callback callback, void *callback_arg) { REACTOR_CTL(reactor, EPOLL_CTL_MOD, fd, interest) g_hash_table_insert(reactor-&gt;table, int_in_heap(fd), callback_data_new(callback, callback_arg)); return 0; }</span></span></code> </pre> </div></div><br><p>  I / O反应器使用<code>fd</code>描述符拦截事件后，将调用相应的事件处理程序，将<code>fd</code> ，生成的事件的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">位掩码</a>以及指向<code>void</code>的用户指针传递到该事件处理程序中。 </p><br><div class="spoiler">  <b class="spoiler_title">显示reactor_run（）函数</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactor_run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reactor *reactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">time_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">events</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((events = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(MAX_EVENTS, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*events))) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> start = time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> passed = time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) - start; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nfds = epoll_wait(reactor-&gt;epoll_fd, events, MAX_EVENTS, timeout - passed); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (nfds) { <span class="hljs-comment"><span class="hljs-comment">//  case -1: perror("epoll_wait"); result = -1; goto cleanup; //   case 0: result = 0; goto cleanup; //   default: //    for (int i = 0; i &lt; nfds; i++) { int fd = events[i].data.fd; CallbackData *callback = g_hash_table_lookup(reactor-&gt;table, &amp;fd); callback-&gt;callback(callback-&gt;arg, fd, events[i].events); } } } cleanup: free(events); return result; }</span></span></code> </pre> </div></div><br><p> 总而言之，用户代码中的函数调用链将采用以下形式： </p><br><p><img src="https://habrastorage.org/webt/5r/zj/wu/5rzjwuyiu4e3f-wfvtumltvuz3i.png"></p><br><h1 id="odnopotochnyy-server"> 单线程服务器 </h1><br><p> 为了测试高负载下的I / O反应器，我们将编写一个简单的HTTP Web服务器来响应带有图像的任何请求。 </p><br><div class="spoiler">  <b class="spoiler_title">HTTP协议快速参考</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">HTTP</a>是一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">应用程序级</a>协议，主要用于服务器与浏览器的交互。 </p><br><p>  HTTP可以很容易地在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">TCP</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">传输</a>协议之上使用，发送和接收<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范</a>定义的格式的消息。 </p><br><h3 id="format-zaprosa"> 要求格式 </h3><br><pre> <code class="plaintext hljs">&lt;&gt; &lt;URI&gt; &lt; HTTP&gt;CRLF &lt; 1&gt;CRLF &lt; 2&gt;CRLF &lt; N&gt;CRLF CRLF &lt;&gt;</code> </pre> <br><ul><li>  <code>CRLF</code>是两个字符的序列： <code>\r</code>和<code>\n</code> ，分隔查询的第一行，标头和数据。 </li><li>  <code>&lt;&gt;</code>是<code>CONNECT</code> ， <code>DELETE</code> ， <code>GET</code> ， <code>HEAD</code> ， <code>OPTIONS</code> ， <code>PATCH</code> ， <code>POST</code> ， <code>PUT</code> ， <code>TRACE</code> 。 浏览器将向我们的服务器发送<code>GET</code>命令，意思是“向我发送文件内容”。 </li><li>  <code>&lt;URI&gt;</code>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一资源标识符</a> 。 例如，如果URI = <code>/index.html</code> ，则客户端将请求网站的主页。 </li><li>  <code>&lt; HTTP&gt;</code> -HTTP协议版本， <code>HTTP/XY</code>格式。 迄今为止，最常用的版本是<code>HTTP/1.1</code> 。 </li><li>  <code>&lt; N&gt;</code>是格式为<code>&lt;&gt;: &lt;&gt;</code>的键值对，已发送到服务器以进行进一步分析。 </li><li>  <code>&lt;&gt;</code> -服务器完成操作所需的数据。 通常它只是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">JSON</a>或任何其他格式。 </li></ul><br><h3 id="format-otveta"> 回应格式 </h3><br><pre> <code class="plaintext hljs">&lt; HTTP&gt; &lt; &gt; &lt; &gt;CRLF &lt; 1&gt;CRLF &lt; 2&gt;CRLF &lt; N&gt;CRLF CRLF &lt;&gt;</code> </pre> <br><ul><li>  <code>&lt; &gt;</code>是表示操作结果的数字。 我们的服务器将始终返回状态200（成功操作）。 </li><li>  <code>&lt; &gt;</code> -状态代码的字符串表示形式。 对于状态码200，这<code>OK</code> 。 </li><li>  <code>&lt; N&gt;</code> -与请求中的格式相同的标头。 我们将返回<code>Content-Length</code> （文件大小）和<code>Content-Type: text/html</code> （返回类型数据）标题。 </li><li>  <code>&lt;&gt;</code> -用户请求的数据。 在我们的例子中，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">HTML中</a>图像的路径。 </li></ul></div></div><br><p>  <a href="https://github.com/Hippolot/reactor-c/blob/master/" rel="nofollow"><code>http_server.c</code></a> （单线程服务器）文件包括<a href="" rel="nofollow"><code>common.h</code></a>文件，该文件包含以下函数原型： </p><br><div class="spoiler">  <b class="spoiler_title">显示common.h中的函数原型</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *  ,    ,    *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> events)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *  ,    ,    *   HTTP . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> events)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *  ,    ,    *    HTTP . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_recv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> events)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_nonblocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *     stderr      *  `EXIT_FAILURE`. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> noreturn </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *    ,    * TCP . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reuse_port)</span></span></span></span>;</code> </pre> </div></div><br><p> 还描述了函数宏<code>SAFE_CALL()</code>并定义了<code>fail()</code>函数。 宏将表达式的值与错误进行比较，如果满足条件，它将调用<code>fail()</code>函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAFE_CALL(call, </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((call) == </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">) { \ fail(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, #call); \ } \ } while (false)</span></span></code> </pre> <br><p>  <code>fail()</code>函数将传递的参数打印到终端（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>printf()</code></a> ），并使用<code>EXIT_FAILURE</code>代码终止程序： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> noreturn </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span><span class="hljs-function"> </span></span>{ va_list args; va_start(args, format); <span class="hljs-built_in"><span class="hljs-built_in">vfprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, format, args); va_end(args); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">": %s\n"</span></span>, strerror(errno)); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); }</code> </pre> <br><p>  <code>new_server()</code>函数返回系统调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>socket()</code></a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>bind()</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>listen()</code></a>创建的“服务器”套接字的文件描述符，并能够以非阻塞模式接受传入的连接。 </p><br><div class="spoiler">  <b class="spoiler_title">显示函数new_server（）</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reuse_port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; SAFE_CALL((fd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP)), <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reuse_port) { SAFE_CALL( setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &amp;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>){<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)), <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr</span></span></span><span class="hljs-class"> = {</span></span>.sin_family = AF_INET, .sin_port = htons(SERVER_PORT), .sin_addr = {.s_addr = inet_addr(SERVER_IPV4)}, .sin_zero = {<span class="hljs-number"><span class="hljs-number">0</span></span>}}; SAFE_CALL(bind(fd, (struct sockaddr *)&amp;addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)), <span class="hljs-number"><span class="hljs-number">-1</span></span>); SAFE_CALL(listen(fd, SERVER_BACKLOG), <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fd; }</code> </pre> </div></div><br><ul><li> 请注意，套接字最初是使用<code>SOCK_NONBLOCK</code>标志以非阻塞模式创建的，因此在<code>on_accept()</code>函数（了解更多）中， <code>accept()</code>系统调用不会停止流的执行。 </li><li> 如果<code>reuse_port</code>为<code>true</code> ，则此函数将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>setsockopt()</code></a>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>SO_REUSEPORT</code></a>选项配置套接字，以在多线程环境中使用相同的端口（请参阅“多线程服务器”一节）。 </li></ul><br><p> 在操作系统生成<code>EPOLLIN</code>事件之后，将调用<code>on_accept()</code>事件处理程序，在这种情况下，这意味着可以接受新的连接。  <code>on_accept()</code>接受一个新的连接，将其切换为非阻塞模式，并在I / O反应器中向<code>on_recv()</code>事件处理程序注册。 </p><br><div class="spoiler">  <b class="spoiler_title">显示on_accept（）函数</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> events)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> incoming_conn; SAFE_CALL((incoming_conn = accept(fd, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)), <span class="hljs-number"><span class="hljs-number">-1</span></span>); set_nonblocking(incoming_conn); SAFE_CALL(reactor_register(reactor, incoming_conn, EPOLLIN, on_recv, request_buffer_new()), <span class="hljs-number"><span class="hljs-number">-1</span></span>); }</code> </pre> </div></div><br><p> 在操作系统生成<code>EPOLLIN</code>事件之后，将调用<code>on_recv()</code>事件处理程序，在这种情况下，这意味着注册的<code>on_accept()</code>连接已准备好接收数据。 </p><br><p>  <code>on_recv()</code>从连接中读取数据，直到收到完整的HTTP请求为止，然后它注册<code>on_send()</code>处理函数以发送HTTP响应。 如果客户端断开连接，套接字将注销并使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>close()</code></a>关闭。 </p><br><div class="spoiler">  <b class="spoiler_title">显示on_recv（）函数</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_recv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> events)</span></span></span><span class="hljs-function"> </span></span>{ RequestBuffer *buffer = arg; <span class="hljs-comment"><span class="hljs-comment">//      ,  recv  0   ssize_t nread; while ((nread = recv(fd, buffer-&gt;data + buffer-&gt;size, REQUEST_BUFFER_CAPACITY - buffer-&gt;size, 0)) &gt; 0) buffer-&gt;size += nread; //    if (nread == 0) { SAFE_CALL(reactor_deregister(reactor, fd), -1); SAFE_CALL(close(fd), -1); request_buffer_destroy(buffer); return; } // read  ,   ,     //  if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) { request_buffer_destroy(buffer); fail("read"); } //   HTTP   .    //     if (request_buffer_is_complete(buffer)) { request_buffer_clear(buffer); SAFE_CALL(reactor_reregister(reactor, fd, EPOLLOUT, on_send, buffer), -1); } }</span></span></code> </pre> </div></div><br><p> 在操作系统生成<code>EPOLLOUT</code>事件之后，将调用<code>on_send()</code>事件处理程序，这意味着由<code>on_recv()</code>注册的连接已准备好发送数据。 此函数将包含HTML和图像的HTTP响应发送到客户端，然后将事件处理程序再次更改为<code>on_recv()</code> 。 </p><br><div class="spoiler">  <b class="spoiler_title">显示on_send（）函数</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> events)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *content = <span class="hljs-string"><span class="hljs-string">"&lt;img "</span></span> <span class="hljs-string"><span class="hljs-string">"src=\"https://habrastorage.org/webt/oh/wl/23/"</span></span> <span class="hljs-string"><span class="hljs-string">"ohwl23va3b-dioerobq_mbx4xaw.jpeg\"&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> response[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(response, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 200 OK"</span></span> CRLF <span class="hljs-string"><span class="hljs-string">"Content-Length: %zd"</span></span> CRLF <span class="hljs-string"><span class="hljs-string">"Content-Type: "</span></span> <span class="hljs-string"><span class="hljs-string">"text/html"</span></span> DOUBLE_CRLF <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(content), content); SAFE_CALL(send(fd, response, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(response), <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>); SAFE_CALL(reactor_reregister(reactor, fd, EPOLLIN, on_recv, arg), <span class="hljs-number"><span class="hljs-number">-1</span></span>); }</code> </pre> </div></div><br><p> 最后，在文件<code>http_server.c</code>的<code>main()</code>函数中，我们使用<code>reactor_new()</code>创建一个I / O反应器，创建一个服务器套接字并注册它，并使用<code>reactor_run()</code>启动反应器一分钟，然后释放资源并退出从程序。 </p><br><div class="spoiler">  <b class="spoiler_title">显示http_server.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"reactor.h"</span></span></span><span class="hljs-meta"> static Reactor *reactor; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"common.h"</span></span></span><span class="hljs-meta"> int main(void) { SAFE_CALL((reactor = reactor_new()), NULL); SAFE_CALL( reactor_register(reactor, new_server(false), EPOLLIN, on_accept, NULL), -1); SAFE_CALL(reactor_run(reactor, SERVER_TIMEOUT_MILLIS), -1); SAFE_CALL(reactor_destroy(reactor), -1); }</span></span></code> </pre> </div></div><br><p> 检查一切是否按预期进行。 我们进行编译（在项目的根目录中为<code>chmod a+x compile.sh &amp;&amp; ./compile.sh</code> ）并启动自写服务器，在浏览器中打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">http://127.0.0.1:18470</a>并观察预期的结果： </p><br><p><img src="https://habrastorage.org/webt/i0/za/5u/i0za5um7tbcnzqt2x7sp_vey0p8.png"></p><br><h1 id="zamer-proizvoditelnosti"> 绩效评估 </h1><br><div class="spoiler">  <b class="spoiler_title">展示我的车的特点</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ screenfetch MMMMMMMMMMMMMMMMMMMMMMMMMmds+. OS: Mint 19.1 tessa MMm----::-://////////////oymNMd+` Kernel: x86_64 Linux 4.15.0-20-generic MMd /++ -sNMd: Uptime: 2h 34m MMNso/` dMM `.::-. .-::.` .hMN: Packages: 2217 ddddMMh dMM :hNMNMNhNMNMNh: `NMm Shell: bash 4.4.20 NMm dMM .NMN/-+MMM+-/NMN` dMM Resolution: 1920x1080 NMm dMM -MMm `MMM dMM. dMM DE: Cinnamon 4.0.10 NMm dMM -MMm `MMM dMM. dMM WM: Muffin NMm dMM .mmd `mmm yMM. dMM WM Theme: Mint-Y-Dark (Mint-Y) NMm dMM` ..` ... ydm. dMM GTK Theme: Mint-Y [GTK2/3] hMM- +MMd/-------...-:sdds dMM Icon Theme: Mint-Y -NMm- :hNMNNNmdddddddddy/` dMM Font: Noto Sans 9 -dMNs-``-::::-------.`` dMM CPU: Intel Core i7-6700 @ 8x 4GHz [52.0°C] `/dMNmy+/:-------------:/yMMM GPU: NV136 ./ydNMMMMMMMMMMMMMMMMMMMMM RAM: 2544MiB / 7926MiB \.MMMMMMMMMMMMMMMMMMM</code> </pre> </div></div><br><p> 我们评估单线程服务器的性能。 让我们打开两个终端：在其中一个中，我们运行<code>./http_server</code> ，在另一个中<code>./http_server</code> 。 一分钟后，第二个终端将显示以下统计信息： </p><br><pre> <code class="plaintext hljs">$ wrk -c100 -d1m -t8 http://127.0.0.1:18470 -H "Host: 127.0.0.1:18470" -H "Accept-Language: en-US,en;q=0.5" -H "Connection: keep-alive" Running 1m test @ http://127.0.0.1:18470 8 threads and 100 connections Thread Stats Avg Stdev Max +/- Stdev Latency 493.52us 76.70us 17.31ms 89.57% Req/Sec 24.37k 1.81k 29.34k 68.13% 11657769 requests in 1.00m, 1.60GB read Requests/sec: 193974.70 Transfer/sec: 27.19MB</code> </pre> <br><p> 我们的单线程服务器每分钟能够处理100万个连接中的1100万个请求。 结果不错，但是可以改善吗？ </p><br><h1 id="mnogopotochnyy-server"> 多线程服务器 </h1><br><p> 如上所述，可以在单独的流中创建I / O反应器，从而利用所有CPU内核。 让我们在实践中应用这种方法： </p><br><div class="spoiler">  <b class="spoiler_title">显示http_server_multithreaded.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"reactor.h"</span></span></span><span class="hljs-meta"> static Reactor *reactor; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp threadprivate(reactor) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"common.h"</span></span></span><span class="hljs-meta"> int main(void) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel { SAFE_CALL((reactor = reactor_new()), NULL); SAFE_CALL(reactor_register(reactor, new_server(true), EPOLLIN, on_accept, NULL), -1); SAFE_CALL(reactor_run(reactor, SERVER_TIMEOUT_MILLIS), -1); SAFE_CALL(reactor_destroy(reactor), -1); } }</span></span></code> </pre> </div></div><br><p> 现在，每个线程都<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">拥有自己的</a>反应堆： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Reactor *reactor; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp threadprivate(reactor)</span></span></code> </pre> <br><p> 请注意， <code>new_server()</code>的参数为<code>true</code> 。 这意味着我们将服务器套接字设置为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>SO_REUSEPORT</code></a>选项，以在多线程环境中使用它。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在这里</a>阅读更多内容。 </p><br><h1 id="vtoroy-zahod"> 第二次 </h1><br><p> 现在，我们将评估多线程服务器的性能： </p><br><pre> <code class="plaintext hljs">$ wrk -c100 -d1m -t8 http://127.0.0.1:18470 -H "Host: 127.0.0.1:18470" -H "Accept-Language: en-US,en;q=0.5" -H "Connection: keep-alive" Running 1m test @ http://127.0.0.1:18470 8 threads and 100 connections Thread Stats Avg Stdev Max +/- Stdev Latency 1.14ms 2.53ms 40.73ms 89.98% Req/Sec 79.98k 18.07k 154.64k 78.65% 38208400 requests in 1.00m, 5.23GB read Requests/sec: 635876.41 Transfer/sec: 89.14MB</code> </pre> <br><p>  1分钟内处理的请求数量增加了约3.28倍！ 但是到整数为止，仅200万是不够的，让我们尝试对其进行修复。 </p><br><p> 首先，查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">perf</a>生成的统计信息： </p><br><pre> <code class="plaintext hljs">$ sudo perf stat -B -e task-clock,context-switches,cpu-migrations,page-faults,cycles,instructions,branches,branch-misses,cache-misses ./http_server_multithreaded Performance counter stats for './http_server_multithreaded': 242446,314933 task-clock (msec) # 4,000 CPUs utilized 1 813 074 context-switches # 0,007 M/sec 4 689 cpu-migrations # 0,019 K/sec 254 page-faults # 0,001 K/sec 895 324 830 170 cycles # 3,693 GHz 621 378 066 808 instructions # 0,69 insn per cycle 119 926 709 370 branches # 494,653 M/sec 3 227 095 669 branch-misses # 2,69% of all branches 808 664 cache-misses 60,604330670 seconds time elapsed</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">使用CPU亲和力</a> ，使用<code>-march=native</code> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">PGO进行</a>编译，增加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">高速缓存中</a>的命中次数，增加<code>MAX_EVENTS</code>以及使用<code>EPOLLET</code>不会显着提高性能。 但是，如果增加同时连接的数量会怎样？ </p><br><p>  352个同时连接的统计信息： </p><br><pre> <code class="plaintext hljs">$ wrk -c352 -d1m -t8 http://127.0.0.1:18470 -H "Host: 127.0.0.1:18470" -H "Accept-Language: en-US,en;q=0.5" -H "Connection: keep-alive" Running 1m test @ http://127.0.0.1:18470 8 threads and 352 connections Thread Stats Avg Stdev Max +/- Stdev Latency 2.12ms 3.79ms 68.23ms 87.49% Req/Sec 83.78k 12.69k 169.81k 83.59% 40006142 requests in 1.00m, 5.48GB read Requests/sec: 665789.26 Transfer/sec: 93.34MB</code> </pre> <br><p> 获得了期望的结果，它带有一个有趣的图表，显示了1分钟内处理的请求数与连接数的关系： </p><br><p><img src="https://habrastorage.org/webt/od/8c/lv/od8clvvdlprsdcmslba9fz_rmmq.png"></p><br><p> 我们看到，经过数百次连接后，两台服务器处理的请求数量都急剧下降（在多线程版本中，这一点更加明显）。 这与Linux TCP / IP堆栈实现有关吗？ 请在注释中随意编写关于这种图形行为以及多线程和单线程选项优化的假设。 </p><br><hr><br><p> 如评论中所述，此性能测试未显示实际负载下I / O反应器的行为，因为几乎总是服务器与数据库交互，显示日志，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">TLS</a>加密等，因此负载变得异构（动态）。 有关第三方组件的测试将在有关I / O proactor的文章中进行。 </p><br><h1 id="nedostatki-io-reaktora">  I / O Reactor的缺点 </h1><br><p> 您需要了解，I / O反应器并非没有缺点，即： </p><br><ul><li> 在多线程环境中使用I / O反应器要困难一些，因为 您必须手动管理流程。 </li><li> 实践表明，在大多数情况下，负载是异构的，这可能导致以下事实：一个线程将被放下，而另一个线程将被加载。 </li><li> 如果一个事件处理程序阻止了流，则系统选择器本身也将被阻止，这可能导致难以捕获的错误。 </li></ul><br><p> 这些问题由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">I / O代理</a>解决，通常使用调度程序将负载平均分配给线程池，并且还具有更方便的API。 稍后将在我的另一篇文章中讨论。 </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><p> 至此，我们从理论直接进入排气分析仪的旅程结束了。 </p><br><p> 不要赘述，因为还有许多其他同样有趣的方法来编写具有不同级别的便利性和速度的网络软件。 我认为有趣的是，下面给出了链接。 </p><br><p> 待会见！ </p><br><h1 id="interesnye-proekty"> 有趣的项目 </h1><br><ul><li> 乙 <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">libevent</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">利贝夫</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">libuv</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">libevhtp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">解放</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">DPDK</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">网图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Pf_ring</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">铁锈</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">宇达电通</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">时雄</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">smoltcp</a> </li></ul></li></ul><br><h1 id="chto-eschyo-pochitat"> 还有什么要读的？ </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://linux.die.net/man/7/socket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">http://www.kegel.com/c10k.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://kernel.dk/io_uring.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://aturon.github.io/blog/2016/09/07/futures-design/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://tokio.rs/blog/2019-10-scheduler/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://www.artima.com/articles/io_design_patterns.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/cn/post/183832/</a> </li></ul><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN475896/">https://habr.com/ru/post/zh-CN475896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN475884/index.html">解决渐变中锯齿线的问题</a></li>
<li><a href="../zh-CN475886/index.html">Amazon AI可轻松解决用户淫秽内容</a></li>
<li><a href="../zh-CN475888/index.html">云人脸识别的好处</a></li>
<li><a href="../zh-CN475892/index.html">我们如何改善办公室午餐的顺序（无法访问服务器）</a></li>
<li><a href="../zh-CN475894/index.html">三阶段协议</a></li>
<li><a href="../zh-CN475900/index.html">6门最新的Azure课程</a></li>
<li><a href="../zh-CN475902/index.html">Workflow Core-.Net Core的业务流程引擎</a></li>
<li><a href="../zh-CN475904/index.html">给新经理的5条笔记</a></li>
<li><a href="../zh-CN475908/index.html">十个最受欢迎的俄语俄语课程</a></li>
<li><a href="../zh-CN475912/index.html">如何评估和比较以太网的加密设备</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>