<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“¼ ğŸŒ ğŸ¢ Hari dimana aku jatuh cinta pada bulu mata ğŸš– ğŸ“„ ğŸ‘©ğŸ¾â€âš–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 2007, saya menulis beberapa alat modding untuk simulator ruang Freelancer . Sumber daya game disimpan dalam format "binary INI" atau "BINI". Mung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hari dimana aku jatuh cinta pada bulu mata</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438662/"> Pada 2007, saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa alat</a> modding untuk simulator ruang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Freelancer</a> .  Sumber daya game disimpan dalam format "binary INI" atau "BINI".  Mungkin, format biner dipilih demi kinerja: file seperti itu lebih cepat untuk memuat dan membaca daripada teks sewenang-wenang dalam format INI. <br><br>  Sebagian besar konten game dapat diedit langsung dari file-file ini, mengubah nama, harga produk, statistik pesawat ruang angkasa, atau bahkan menambahkan kapal baru.  File biner sulit untuk dimodifikasi secara langsung, jadi pendekatan alami adalah mengonversinya menjadi teks INI, membuat perubahan dalam editor teks, kemudian mengonversi kembali ke format BINI dan mengganti file dalam direktori game. <br><a name="habracut"></a><br>  Saya tidak menganalisis format BINI, dan saya bukan orang pertama yang belajar mengeditnya.  Tetapi saya tidak menyukai alat-alat yang ada, dan saya memiliki visi saya sendiri tentang bagaimana mereka harus bekerja.  Saya lebih suka antarmuka bergaya Unix, meskipun gim itu sendiri berjalan di Windows. <br><br>  Pada waktu itu, saya baru saja berkenalan dengan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yacc</a> (sebenarnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bison</a> ) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lex</a> (sebenarnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flex</a> ), serta Autoconf, jadi saya menggunakannya dengan tepat.  Sangat menarik untuk mencoba utilitas ini dalam praktiknya, walaupun saya dengan kasar meniru proyek open source lainnya, tidak memahami mengapa semuanya dilakukan dengan cara ini, tidak dengan cara lain.  Karena penggunaan yacc / lex dan pembuatan skrip konfigurasi, diperlukan sistem mirip Unix.  Ini semua terlihat dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi asli program</a> . <br><br>  Proyek ini ternyata cukup sukses: Saya sendiri berhasil menggunakan alat-alat ini, dan mereka muncul di koleksi berbeda untuk modding Freelancer. <br><br><h1>  Refactoring </h1><br>  Pada pertengahan 2018, saya kembali ke proyek ini.  Pernahkah Anda melihat kode lama Anda dengan pemikiran: apa yang Anda pikirkan?  Format INI saya ternyata jauh lebih kaku dan ketat dari yang diperlukan, biner direkam dengan cara yang meragukan, dan perakitan bahkan tidak bekerja secara normal. <br><br>  Berkat sepuluh tahun pengalaman ekstra, saya tahu pasti bahwa saya akan menulis alat ini jauh lebih baik sekarang.  Dan saya melakukannya dalam beberapa hari, menulis ulang dari awal.  Kode baru ini sekarang berada di utas utama di Github. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya suka membuat semuanya sesederhana mungkin</a> , jadi saya menyingkirkan autoconf yang mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Makefile yang lebih sederhana dan lebih portabel</a> .  Tidak ada lagi yacc atau lex, tetapi parser ditulis dengan tangan.  Hanya yang sesuai, portable C yang digunakan. Hasilnya sangat sederhana sehingga saya merakit proyek dengan satu perintah pendek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari Visual Studio</a> , sehingga Makefile tidak benar-benar diperlukan.  Jika Anda mengganti <code>stdint.h</code> dengan <code>typedef</code> , Anda bahkan dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membangun dan menjalankan binitools di bawah DOS</a> . <br><br>  Versi baru ini lebih cepat, lebih kompak, lebih bersih dan lebih mudah.  Ini jauh lebih fleksibel sehubungan dengan input INI, sehingga lebih mudah digunakan.  Tetapi apakah itu benar? <br><br><h1>  Fuzzing </h1><br>  Saya telah tertarik pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fuzzing selama</a> bertahun-tahun, terutama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">afl</a> (amerika fuzzy lop).  Tapi dia tidak pernah menguasainya, meskipun dia menguji beberapa alat yang saya gunakan secara teratur.  Tetapi fuzzing tidak menemukan sesuatu yang luar biasa, setidaknya sebelum saya menyerah.  Saya menguji perpustakaan JSON saya dan untuk beberapa alasan juga tidak menemukan apa pun.  Jelas bahwa parser JSON saya tidak dapat diandalkan, bukan?  Tetapi fuzzing tidak menunjukkan apa-apa.  (Ternyata, perpustakaan JSON saya cukup dapat diandalkan, sebagian besar berkat upaya masyarakat!) <br><br>  Tapi sekarang saya memiliki parser INI yang relatif baru.  Meskipun berhasil menganalisis dan merakit dengan benar set asli file BINI dalam game, fungsinya belum <i>benar</i> - <i>benar</i> diuji.  Tentunya di sini fuzzing akan menemukan sesuatu.  Selain itu, Anda tidak perlu menulis satu baris untuk menjalankan afl pada kode ini.  Alat default berfungsi dengan input standar, yang ideal. <br><br>  Dengan asumsi Anda memiliki alat yang diperlukan diinstal (make, gcc, afl), di sini adalah bagaimana fuzzing binitools dimulai dengan mudah: <br><br><pre> <code class="bash hljs">$ make CC=afl-gcc $ mkdir <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> out $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[x]'</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>/empty $ afl-fuzz -i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> -o out -- ./bini</code> </pre> <br>  Utilitas <code>bini</code> menerima INI pada input dan mengeluarkan BINI, jadi jauh lebih menarik untuk memeriksanya daripada prosedur <code>unbini</code> terbalik.  Karena <code>unbini</code> menganalisis data biner yang relatif sederhana, fuzzer (mungkin) tidak perlu dicari.  Namun, untuk berjaga-jaga, saya tetap memeriksanya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/483/089/6dc/4830896dc68da2e5559c899429235f95.png"><br><br>  Dalam contoh ini, saya mengubah kompiler default ke shell GCC untuk afl ( <code>CC=afl-gcc</code> ).  Di sini afl memanggil GCC di latar belakang, tetapi menambahkan toolkit sendiri ke biner.  Saat fuzzing, <code>afl-fuzz</code> menggunakan toolkit ini untuk memantau jalur eksekusi suatu program.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi afl</a> menjelaskan rincian teknis. <br><br>  Saya juga membuat direktori input dan output dengan menempatkan dalam direktori input contoh kerja minimal yang memberikan titik awal.  Ketika mulai, itu memutasi antrian data input dan mengawasi perubahan selama eksekusi program.  Direktori output berisi hasil dan, yang lebih penting, badan input data yang menyebabkan jalur eksekusi yang unik.  Dengan kata lain, banyak input diproses pada keluaran fuzzer, memeriksa banyak skenario perbatasan yang berbeda. <br><br>  Hasil paling menarik dan menakutkan adalah crash program yang lengkap.  Ketika saya pertama kali memulai fuzzer untuk binitools, <code>bini</code> menunjukkan <i>banyak</i> crash seperti itu.  Dalam beberapa menit, afl menemukan sejumlah kesalahan halus dan menarik dalam program saya, yang sangat berguna.  Fazzer bahkan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug yang</a> tidak biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari pointer usang</a> , memeriksa urutan berbeda alokasi memori yang berbeda.  Bug khusus ini adalah titik balik yang membuat saya menyadari nilai fuzzing. <br><br>  Tidak semua kesalahan ditemukan menyebabkan kegagalan.  Saya juga mempelajari output dan melihat input mana yang memberikan hasil yang sukses dan mana yang tidak, dan menyaksikan bagaimana program menangani berbagai kasus ekstrem.  Dia menolak beberapa masukan yang saya pikir akan dia proses.  Dan sebaliknya, dia memproses beberapa data yang saya anggap tidak benar, dan menafsirkan beberapa data dengan cara yang tidak terduga bagi saya.  Jadi, bahkan setelah memperbaiki bug dengan crash program, saya masih mengubah pengaturan parser untuk memperbaiki masing-masing kasus yang tidak menyenangkan ini. <br><br><h1>  Buat suite uji </h1><br>  Segera setelah saya memperbaiki semua kesalahan yang terdeteksi oleh fuzzer dan menyesuaikan parser di semua situasi perbatasan, saya membuat serangkaian tes dari paket data fuzzer - meskipun tidak secara langsung. <br><br>  Pertama, saya menjalankan fuzzer secara paralel - proses ini dijelaskan dalam dokumentasi afl - jadi saya mendapat banyak input berlebihan.  Dengan redundansi, maksud saya bahwa input berbeda tetapi memiliki jalur eksekusi yang sama.  Untungnya, afl memiliki alat untuk mengatasi hal ini: <code>afl-cmin</code> , alat untuk meminimalkan shell.  Ini menghilangkan input yang tidak perlu. <br><br>  Kedua, banyak dari input ini lebih lama dari yang dibutuhkan untuk menjalankan jalur eksekusi unik mereka.  <code>afl-tmin</code> , <code>afl-tmin</code> test case yang mengurangi test case, membantu di <code>afl-tmin</code> . <br><br>  Saya memisahkan input yang valid dan tidak valid - dan memeriksanya di repositori.  Lihatlah semua pintu masuk bodoh yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan oleh fuzzer ini</a> berdasarkan pada input minimal: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">input yang valid</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">input tidak valid</a> </li></ul><br>  Bahkan, di sini pengurai dibekukan dalam satu keadaan, dan serangkaian tes memastikan bahwa bangunan tertentu berperilaku dengan cara yang <i>sangat</i> spesifik.  Ini sangat berguna untuk memastikan bahwa rakitan yang dibuat oleh kompiler lain pada platform lain berperilaku sama sehubungan dengan output mereka.  Suite tes saya bahkan mendeteksi kesalahan di perpustakaan dietlibc karena binitools tidak lulus tes setelah menautkannya.  Jika Anda harus membuat perubahan non-sepele untuk parser, maka pada dasarnya Anda harus meninggalkan set tes saat ini dan mulai dari awal lagi sehingga afl akan menghasilkan seluruh tubuh baru untuk parser baru. <br><br>  Tentu saja, fuzzing telah memantapkan dirinya sebagai teknik yang kuat.  Dia menemukan sejumlah kesalahan yang tidak mungkin saya temukan sendiri.  Sejak itu, saya mulai menggunakannya secara lebih kompeten untuk menguji program lain - bukan hanya milik saya - dan menemukan banyak bug baru.  Sekarang fuzzer telah mengambil tempat permanen di antara alat-alat dalam kit pengembangan saya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438662/">https://habr.com/ru/post/id438662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438648/index.html">Perbandingan sistem BI (Tableau, Power BI, Oracle, Qlik)</a></li>
<li><a href="../id438650/index.html">Roket 9M729. Beberapa kata tentang "pelanggar" Perjanjian INF</a></li>
<li><a href="../id438652/index.html">Portabelisasi IDA</a></li>
<li><a href="../id438654/index.html">OpenSceneGraph: Integrasi dengan Qt Framework</a></li>
<li><a href="../id438658/index.html">Cara belajar belajar</a></li>
<li><a href="../id438664/index.html">Perangkat kompiler Swift. Bagian 2</a></li>
<li><a href="../id438666/index.html">Manajer vs Programmer</a></li>
<li><a href="../id438668/index.html">"Cari cerita yang mendorong": podcast tentang podcast, pekerjaan editorial, dan karier media</a></li>
<li><a href="../id438670/index.html">Penyerang menggunakan serangan hak cipta YouTube untuk memeras uang dari penulis</a></li>
<li><a href="../id438672/index.html">Pengkodean UTF-8 dalam nama dan kata sandi Wi-Fi (Emoji)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>