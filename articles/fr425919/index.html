<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíª üì∂ üåÅ Cartes hexagonales dans Unity: enregistrement et chargement, textures, distances üí∫ üèØ üë©üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivi√®res et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes hexagonales dans Unity: enregistrement et chargement, textures, distances</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivi√®res et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, √©quipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, √©rosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 12: enregistrer et charger </h1><br><ul><li>  Suivez le type de terrain au lieu de la couleur. </li><li>  Cr√©ez un fichier. </li><li>  Nous √©crivons les donn√©es dans un fichier, puis les lisons. </li><li>  Nous s√©rialisons les donn√©es des cellules. </li><li>  R√©duisez la taille du fichier. </li></ul><br>  Nous savons d√©j√† comment cr√©er des cartes assez int√©ressantes.  Vous devez maintenant apprendre √† les enregistrer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>Charg√© √† partir <a href="">du</a> fichier <a href="">test.map</a> .</i> <br><br><h2>  Type de terrain </h2><br>  Lors de l'enregistrement d'une carte, nous n'avons pas besoin de stocker toutes les donn√©es que nous suivons pendant l'application.  Par exemple, nous devons seulement nous souvenir du niveau de hauteur de cellule.  Sa position verticale elle-m√™me est prise √† partir de ces donn√©es, vous n'avez donc pas besoin de les stocker.  En fait, c'est mieux si nous ne stockons pas ces statistiques calcul√©es.  Ainsi, les donn√©es cartographiques resteront correctes, m√™me si plus tard nous d√©cidons de changer le d√©calage de hauteur.  Les donn√©es sont distinctes de leur pr√©sentation. <br><br>  De m√™me, nous n'avons pas besoin de stocker la couleur exacte de la cellule.  Vous pouvez √©crire que la cellule est verte.  Mais la nuance exacte du vert peut changer avec un changement de style visuel.  Pour ce faire, nous pouvons enregistrer l'index des couleurs, pas les couleurs elles-m√™mes.  En fait, il peut √™tre suffisant pour nous de stocker cet index au lieu de vraies couleurs dans les cellules lors de l'ex√©cution.  Cela permettra plus tard de passer √† une visualisation plus complexe du relief. <br><br><h3>  D√©placer un tableau de couleurs </h3><br>  Si les cellules n'ont plus de donn√©es de couleur, elles doivent √™tre stock√©es ailleurs.  Il est plus pratique de le stocker dans <code>HexMetrics</code> .  Ajoutons-y donc un tableau de couleurs. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  Comme toutes les autres donn√©es globales, telles que le bruit, nous pouvons initialiser ces couleurs avec <code>HexGrid</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  Et puisque maintenant nous n'affectons pas de couleurs directement aux cellules, nous nous d√©barrasserons de la couleur par d√©faut. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; ‚Ä¶ void CreateCell (int x, int z, int i) { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; ‚Ä¶ }</span></span></code> </pre> <br>  D√©finissez les nouvelles couleurs pour qu'elles correspondent au tableau g√©n√©ral de l'√©diteur de carte hexagonal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>Couleurs ajout√©es √† la grille.</i> <br><br><h3>  Refactoring cellulaire </h3><br>  Supprimez le champ de couleur de <code>HexCell</code> .  Au lieu de cela, nous stockons l'index.  Au lieu d'un indice de couleur, nous utilisons un indice de type de relief plus g√©n√©ral. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  La propri√©t√© color ne peut utiliser cet index que pour obtenir la couleur correspondante.  Maintenant, il n'est pas d√©fini directement, supprimez cette partie.  Dans ce cas, nous obtenons une erreur de compilation, que nous corrigerons bient√¥t. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // ‚Ä¶ // } }</span></span></code> </pre> <br>  Ajoutez une nouvelle propri√©t√© pour obtenir et d√©finir un nouvel index de type d'√©l√©vation. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3>  Refactorisation de l'√©diteur </h3><br>  Dans <code>HexMapEditor</code> tout le code concernant les couleurs.  Cela corrigera l'erreur de compilation. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ // Color activeColor; ‚Ä¶ // bool applyColor; ‚Ä¶ // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } ‚Ä¶ // void Awake () { // SelectColor(0); // } ‚Ä¶ void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } ‚Ä¶ } }</span></span></code> </pre> <br>  Ajoutez maintenant un champ et une m√©thode pour contr√¥ler l'index de type d'√©l√©vation actif. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  Nous utilisons cette m√©thode en remplacement de la m√©thode <code>SelectColor</code> manque maintenant.  Connectez les widgets de couleur dans l'interface utilisateur avec <code>SetTerrainTypeIndex</code> , en laissant tout le reste inchang√©.  Cela signifie qu'un indice n√©gatif est toujours utilis√© et que la couleur ne doit pas changer. <br><br>  Modifiez <code>EditCell</code> pour que l'index de type d'√©l√©vation soit affect√© √† la cellule en cours de modification. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } ‚Ä¶ } }</code> </pre> <br>  Bien que nous ayons supprim√© les donn√©es de couleur des cellules, la carte devrait fonctionner de la m√™me mani√®re qu'auparavant.  La seule diff√©rence est que la couleur par d√©faut est d√©sormais la premi√®re du tableau.  Dans mon cas, c'est jaune. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>Le jaune est la nouvelle couleur par d√©faut.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Enregistrement de donn√©es dans un fichier </h2><br>  Pour contr√¥ler l'enregistrement et le chargement de la carte, nous utilisons <code>HexMapEditor</code> .  Nous allons cr√©er deux m√©thodes pour ce faire et les laisser pour l'instant vides. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Ajoutez deux boutons √† l'interface utilisateur ( <em>GameObject / UI / Button</em> ).  Connectez-les aux boutons et donnez les √©tiquettes appropri√©es.  Je les ai plac√©s en bas du panneau de droite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>Boutons Enregistrer et Charger.</i> <br><br><h3>  Emplacement du fichier </h3><br>  Pour stocker une carte, vous devez l'enregistrer quelque part.  Comme c'est le cas dans la plupart des jeux, nous stockons les donn√©es dans un fichier.  Mais o√π placer ce fichier dans le syst√®me de fichiers?  La r√©ponse d√©pend du syst√®me d'exploitation sur lequel le jeu fonctionne.  Chaque syst√®me d'exploitation a ses propres normes de stockage des fichiers li√©s aux applications. <br><br>  Nous n'avons pas besoin de conna√Ætre ces normes.  Unity conna√Æt le bon chemin que nous pouvons obtenir avec <code>Application.persistentDataPath</code> .  Vous pouvez v√©rifier comment ce sera avec vous, dans la m√©thode <code>Save</code> , l'afficher dans la console et appuyer sur le bouton en mode Play. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  Sur les syst√®mes de bureau, le chemin d'acc√®s contiendra le nom de l'entreprise et du produit.  Ce chemin est utilis√© √† la fois par l'√©diteur et par l'assembly.  Les noms peuvent √™tre configur√©s dans <em>Edition / Param√®tres du projet / Lecteur</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>Nom de l'entreprise et du produit.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi ne puis-je pas trouver le dossier Biblioth√®que sur Mac?</b> <div class="spoiler_text">  Le dossier <em>Biblioth√®que</em> est souvent masqu√©.  La fa√ßon dont il peut √™tre affich√© d√©pend de la version d'OS X. Si vous ne disposez pas d'une ancienne version, s√©lectionnez le dossier de d√©part dans le Finder et acc√©dez √† <em>Afficher les options d'affichage</em> .  Il y a une case √† cocher pour le dossier <em>Biblioth√®que</em> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Et WebGL?</b> <div class="spoiler_text">  Les jeux WebGL ne peuvent pas acc√©der au syst√®me de fichiers de l'utilisateur.  Au lieu de cela, toutes les op√©rations sur les fichiers sont redirig√©es vers un syst√®me de fichiers situ√© en m√©moire.  Elle est transparente pour nous.  Cependant, pour enregistrer les donn√©es, vous devrez commander manuellement la page Web pour vider les donn√©es dans le stockage du navigateur. </div></div><br><h3>  Cr√©ation de fichiers </h3><br>  Pour cr√©er un fichier, nous devons utiliser des classes de l'espace de noms <code>System.IO</code> .  Par cons√©quent, nous ajoutons une instruction <code>using</code> pour cela sur la classe <code>HexMapEditor</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br>  Nous devons d'abord cr√©er le chemin d'acc√®s complet au fichier.  Nous utilisons <em>test.map</em> comme <em>nom de</em> fichier.  Il doit √™tre ajout√© au chemin des donn√©es stock√©es.  Que vous ayez besoin d'ins√©rer une barre oblique ou une barre oblique inverse (barre oblique ou barre oblique invers√©e) d√©pend de la plate-forme.  La m√©thode <code>Path.Combine</code> fera <code>Path.Combine</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  Ensuite, nous devons acc√©der au fichier √† cet emplacement.  Nous le faisons en utilisant la m√©thode <code>File.Open</code> .  Puisque nous voulons √©crire des donn√©es dans ce fichier, nous devons utiliser son mode de cr√©ation.  Dans ce cas, soit un nouveau fichier sera cr√©√© sur le chemin sp√©cifi√©, soit un fichier existant sera remplac√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  Le r√©sultat de l'appel de cette m√©thode sera un flux de donn√©es ouvert associ√© √† ce fichier.  Nous pouvons l'utiliser pour √©crire des donn√©es dans un fichier.  Et nous ne devons pas oublier de fermer le flux lorsque nous n'en avons plus besoin. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  √Ä ce stade, lorsque vous cliquez sur le bouton <em>Enregistrer</em> , le fichier <em>test.map</em> est cr√©√© dans le dossier sp√©cifi√© comme chemin d'acc√®s aux donn√©es stock√©es.  Si vous √©tudiez ce fichier, il sera vide et aura une taille de 0 octet, car jusqu'√† pr√©sent nous n'y avons rien √©crit. <br><br><h3>  √âcrire dans un fichier </h3><br>  Pour √©crire des donn√©es dans un fichier, nous avons besoin d'un moyen pour y diffuser des donn√©es.  La fa√ßon la plus simple de le faire est d' <code>BinaryWriter</code> .  Ces objets vous permettent d'√©crire des donn√©es primitives dans n'importe quel flux. <br><br>  Cr√©ez un nouvel objet <code>BinaryWriter</code> , et notre flux de fichiers sera son argument.  L'√©crivain de fermeture ferme le flux qu'il utilise.  Par cons√©quent, nous n'avons plus besoin de stocker un lien direct vers le flux. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  Pour transf√©rer des donn√©es vers un flux, nous pouvons utiliser la m√©thode <code>BinaryWriter.Write</code> .  Il existe une variante de la m√©thode <code>Write</code> pour tous les types primitifs, tels que entier et flottant.  Il peut √©galement enregistrer des lignes.  Essayons d'√©crire un entier 123. <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  Cliquez sur le bouton <em>Enregistrer</em> et examinez √† nouveau <em>test.map</em> .  Maintenant, sa taille est de 4 octets, car la taille enti√®re est de 4 octets. <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi mon gestionnaire de fichiers montre-t-il que le fichier occupe plus d'espace?</b> <div class="spoiler_text">  Parce que les syst√®mes de fichiers divisent l'espace en blocs d'octets.  Ils ne suivent pas les octets individuels.  Comme <em>test.map</em> ne prend que quatre octets jusqu'√† pr√©sent, il n√©cessite un bloc d'espace de stockage. </div></div><br>  Notez que nous stockons des donn√©es binaires, pas du texte lisible par l'homme.  Par cons√©quent, si nous ouvrons le fichier dans un √©diteur de texte, nous verrons un ensemble de caract√®res indistincts.  Vous verrez probablement le symbole <em>{</em> suivi de rien ou de quelques espaces r√©serv√©s. <br><br>  Vous pouvez ouvrir le fichier dans un √©diteur hexad√©cimal.  Dans ce cas, nous verrons <em>7b 00 00 00</em> .  Ce sont quatre octets de notre entier, mapp√©s en notation hexad√©cimale.  En nombres d√©cimaux ordinaires, c'est <em>123 0 0 0</em> .  En binaire, le premier octet ressemble √† <em>01111011</em> . <br><br>  Le code ASCII pour <em>{</em> est 123, ce caract√®re peut donc √™tre affich√© dans un √©diteur de texte.  ASCII 0 est un caract√®re nul qui ne correspond √† aucun caract√®re visible. <br><br>  Les trois octets restants sont √©gaux √† z√©ro, car nous avons √©crit un nombre inf√©rieur √† 256. Si nous √©crivions 256, nous verrions <em>00 01 00 00</em> dans l'√©diteur hexad√©cimal. <br><br><div class="spoiler">  <b class="spoiler_title">Le 123 ne doit-il pas √™tre enregistr√© sous 00 00 00 7b?</b> <div class="spoiler_text">  <code>BinaryWriter</code> utilise le format little-endian pour enregistrer les nombres.  Cela signifie que les octets les moins significatifs sont √©crits en premier.  Ce format a √©t√© utilis√© par Microsoft dans le d√©veloppement du framework .Net.  Il a probablement √©t√© choisi car le processeur Intel utilise le format little-endian. <br><br>  Une alternative est le big-endian, dans lequel les octets les plus significatifs sont stock√©s en premier.  Cela correspond √† l'ordre habituel des nombres en nombres.  123 est cent vingt-trois parce que nous voulons dire le record du big-endian.  S'il s'agissait d'un petit endian, alors 123 signifierait trois cent vingt et un. </div></div><br><h3>  Nous rendons les ressources gratuites </h3><br>  Il est important que nous fermions l'auteur.  Lorsqu'il est ouvert, le syst√®me de fichiers verrouille le fichier, emp√™chant d'autres processus d'y √©crire.  Si nous oublions de le fermer, nous nous bloquerons aussi.  Si nous appuyons deux fois sur le bouton Enregistrer, la deuxi√®me fois, nous ne pourrons pas ouvrir le flux. <br><br>  Au lieu de fermer le r√©dacteur manuellement, nous pouvons cr√©er un bloc <code>using</code> pour cela.  Il d√©finit la port√©e dans laquelle le r√©dacteur est valide.  Lorsque le code ex√©cutable d√©passe cette port√©e, le r√©dacteur est supprim√© et le thread est ferm√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  Cela fonctionnera car les classes d'√©criture et de flux de fichiers impl√©mentent l'interface <code>IDisposable</code> .  Ces objets ont une m√©thode <code>Dispose</code> , qui est indirectement appel√©e lorsqu'ils d√©passent le cadre de l' <code>using</code> . <br><br>  Le gros avantage de l' <code>using</code> est qu'elle fonctionne quelle que soit la fa√ßon dont le programme est hors de port√©e.  Les retours pr√©coces, les exceptions et les erreurs ne le d√©rangent pas.  De plus, il est tr√®s concis. <br><br><h3>  R√©cup√©ration de donn√©es </h3><br>  Pour lire des donn√©es √©crites pr√©c√©demment, nous devons ins√©rer le code dans la m√©thode <code>Load</code> .  Comme dans le cas de l'enregistrement, nous devons cr√©er un chemin d'acc√®s et ouvrir le flux de fichiers.  La diff√©rence est que maintenant nous ouvrons le fichier en lecture et non en √©criture.  Et au lieu d'√©crivain, nous avons besoin de <code>BinaryReader</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  Dans ce cas, nous pouvons utiliser la m√©thode <code>File.OpenRead</code> pour ouvrir le fichier en lecture. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Pourquoi ne pouvons-nous pas utiliser File.OpenWrite lors de l'√©criture?</b> <div class="spoiler_text">  Cette m√©thode cr√©e un flux qui ajoute des donn√©es aux fichiers existants, plut√¥t que de les remplacer. </div></div><br>  Lors de la lecture, nous devons indiquer explicitement le type de donn√©es re√ßues.  Pour lire un entier dans un flux, nous devons utiliser <code>BinaryReader.ReadInt32</code> .  Cette m√©thode lit un entier 32 bits, c'est-√†-dire quatre octets. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  Il est √† noter que lors de la r√©ception de <em>123,</em> il nous suffira de lire un octet.  Mais en m√™me temps, trois octets appartenant √† cet entier resteront dans le flux.  De plus, cela ne fonctionnera pas pour les nombres en dehors de l'intervalle 0‚Äì255.  Par cons√©quent, ne le faites pas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  √âcriture et lecture de donn√©es cartographiques </h2><br>  Lors de l'enregistrement des donn√©es, une question importante est de savoir s'il faut utiliser un format lisible par l'homme.  En r√®gle g√©n√©rale, les formats lisibles par l'homme sont JSON, XML et ASCII ordinaire avec une sorte de structure.  Ces fichiers peuvent √™tre ouverts, interpr√©t√©s et modifi√©s dans des √©diteurs de texte.  De plus, ils simplifient l'√©change de donn√©es entre diff√©rentes applications. <br><br>  Cependant, ces formats ont leurs propres exigences.  Les fichiers prendront plus d'espace (parfois beaucoup plus) que l'utilisation de donn√©es binaires.  Ils peuvent √©galement augmenter consid√©rablement le co√ªt de l'encodage et du d√©codage des donn√©es, tant en termes d'ex√©cution que d'empreinte m√©moire. <br><br>  En revanche, les donn√©es binaires sont compactes et rapides.  Ceci est important lors de l'enregistrement de grandes quantit√©s de donn√©es.  Par exemple, lors de l'enregistrement automatique d'une grande carte √† chaque tour de jeu.  Par cons√©quent <br>  nous utiliserons le format binaire.  Si vous pouvez g√©rer cela, vous pouvez travailler avec des formats plus d√©taill√©s. <br><br><div class="spoiler">  <b class="spoiler_title">Qu'en est-il de la s√©rialisation automatique?</b> <div class="spoiler_text">  Imm√©diatement pendant le processus de s√©rialisation des donn√©es Unity, nous pouvons directement √©crire des classes s√©rialis√©es dans le flux.  Les d√©tails de l'enregistrement des champs individuels nous seront cach√©s.  Cependant, nous ne pouvons pas s√©rialiser directement les cellules.  Ce sont des classes <code>MonoBehaviour</code> qui contiennent des donn√©es que nous n'avons pas besoin de sauvegarder.  Par cons√©quent, nous devons utiliser une hi√©rarchie d'objets distincte, ce qui d√©truit la simplicit√© de la s√©rialisation automatique.  En outre, il sera plus difficile de prendre en charge les modifications de code futures.  Par cons√©quent, nous conserverons un contr√¥le total avec la s√©rialisation manuelle.  De plus, cela nous fera vraiment comprendre ce qui se passe. </div></div><br>  Pour s√©rialiser la carte, nous devons stocker les donn√©es de chaque cellule.  Pour enregistrer et charger une seule cellule, ajoutez les m√©thodes <code>Save</code> et <code>Load</code> √† <code>HexCell</code> .  Puisqu'ils ont besoin d'un √©crivain ou d'un lecteur pour fonctionner, nous les ajouterons comme param√®tres. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Ajoutez des m√©thodes <code>Save</code> et <code>Load</code> √† <code>HexGrid</code> .  Ces m√©thodes contournent simplement toutes les cellules en appelant leurs m√©thodes <code>Load</code> et <code>Save</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  Si nous t√©l√©chargeons une carte, elle doit √™tre mise √† jour apr√®s la modification des donn√©es de la cellule.  Pour ce faire, il suffit de mettre √† jour tous les fragments. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  Enfin, nous rempla√ßons notre code de test dans <code>HexMapEditor</code> par des appels aux m√©thodes <code>Save</code> et <code>Load</code> de la grille, en passant l'√©crivain ou le lecteur avec eux. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3>  Enregistrement d'un type de relief </h3><br>  Au stade actuel, la r√©enregistrement cr√©e un fichier vide et le t√©l√©chargement ne fait rien.  Commen√ßons progressivement en enregistrant et en chargeant uniquement l'index de type d'√©l√©vation <code>HexCell</code> . <br><br>  Attribuez la valeur directement au champ terrainTypeIndex.  Nous n'utiliserons pas de propri√©t√©s.  Comme nous mettons √† jour explicitement tous les fragments, les appels aux propri√©t√©s <code>Refresh</code> ne sont pas n√©cessaires.  De plus, puisque nous enregistrons uniquement les cartes correctes, nous supposerons que toutes les cartes t√©l√©charg√©es sont √©galement correctes.  Par cons√©quent, par exemple, nous ne v√©rifierons pas si la rivi√®re ou la route est autoris√©e. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  Lors de l'enregistrement dans ce fichier, l'un apr√®s l'autre, l'index du type de relief de toutes les cellules sera √©crit.  √âtant donn√© que l'index est un entier, sa taille est de quatre octets.  Ma carte contient 300 cellules, c'est-√†-dire que la taille du fichier sera de 1200 octets. <br><br>  La charge lit les index dans le m√™me ordre dans lequel ils sont √©crits.  Si vous avez chang√© les couleurs des cellules apr√®s l'enregistrement, le chargement de la carte ram√®nera les couleurs √† l'√©tat lors de l'enregistrement.  Puisque nous n'enregistrons plus rien, le reste des donn√©es de cellule restera le m√™me.  Autrement dit, le chargement changera le type de terrain, mais pas sa hauteur, le niveau de l'eau, les caract√©ristiques du terrain, etc. <br><br><h3>  Sauver tout entier </h3><br>  Enregistrer un index de type de relief ne nous suffit pas.  Vous devez enregistrer toutes les autres donn√©es.  Commen√ßons par tous les champs entiers.  Il s'agit d'un indice du type de relief, de la hauteur des cellules, du niveau de l'eau, du niveau de la ville, du niveau de la ferme, du niveau de v√©g√©tation et de l'indice des objets sp√©ciaux.  Ils devront √™tre lus dans le m√™me ordre dans lequel ils ont √©t√© enregistr√©s. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  Essayez maintenant d'enregistrer et de charger la carte, en apportant des modifications entre ces op√©rations.  Tout ce que nous avons inclus dans les donn√©es stock√©es a √©t√© restaur√© du mieux que nous pouvions, √† l'exception de la hauteur de la cellule.  Cela est d√ª au fait que lorsque vous modifiez le niveau de hauteur, vous devez mettre √† jour la position verticale de la cellule.  Cela peut √™tre fait en l'attribuant √† la propri√©t√©, et non au champ, la valeur de la hauteur charg√©e.  Mais cette propri√©t√© fait un travail suppl√©mentaire dont nous n'avons pas besoin.  Par cons√©quent, extrayons le code mettant √† jour la position de la cellule √† partir du <code>RefreshPosition</code> <code>Elevation</code> et ins√©rons-le dans une m√©thode <code>RefreshPosition</code> distincte.  La seule modification que vous devez effectuer ici est de remplacer la <code>value</code> r√©f√©rence au champ d' <code>elevation</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  Nous pouvons maintenant appeler la m√©thode lors de la d√©finition de la propri√©t√©, ainsi qu'apr√®s le chargement des donn√©es de hauteur. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); ‚Ä¶ } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); ‚Ä¶ }</code> </pre> <br>  Apr√®s ce changement, les cellules changeront correctement leur hauteur apparente lors du chargement. <br><br><h3>  Sauvegarde de toutes les donn√©es </h3><br>  La pr√©sence de murs et de rivi√®res entrantes / sortantes dans la cellule est stock√©e dans des champs bool√©ens.  Nous pouvons les √©crire simplement sous forme d'entier.  De plus, les donn√©es routi√®res sont un tableau de six valeurs bool√©ennes que nous pouvons √©crire avec une boucle. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  Les directions des rivi√®res entrantes et sortantes sont stock√©es dans les champs <code>HexDirection</code> .  Le type <code>HexDirection</code> est une √©num√©ration qui est stock√©e en interne sous forme de plusieurs valeurs enti√®res.  Par cons√©quent, nous pouvons √©galement les s√©rialiser sous forme d'entier √† l'aide d'une conversion explicite. <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  Les valeurs bool√©ennes sont lues √† l'aide de la m√©thode <code>BinaryReader.ReadBoolean</code> .  Les directions des rivi√®res sont enti√®res, que nous devons reconvertir en <code>HexDirection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  Nous sauvegardons maintenant toutes les donn√©es de cellule n√©cessaires √† la sauvegarde et √† la restauration compl√®tes de la carte.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela n√©cessite neuf entiers et neuf valeurs bool√©ennes par cellule. </font><font style="vertical-align: inherit;">Chaque valeur bool√©enne prend un octet, nous utilisons donc un total de 45 octets par cellule. </font><font style="vertical-align: inherit;">Autrement dit, une carte avec 300 cellules n√©cessite un total de 13 500 octets. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©duisez la taille du fichier </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien qu'il semble que 13 500 octets ne soit pas beaucoup pour 300 cellules, nous pouvons peut-√™tre faire avec une plus petite quantit√©. </font><font style="vertical-align: inherit;">En fin de compte, nous avons un contr√¥le total sur la fa√ßon dont les donn√©es sont s√©rialis√©es. </font><font style="vertical-align: inherit;">Voyons s'il existe un moyen plus compact de les stocker.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©duction de l'intervalle num√©rique </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diff√©rents niveaux et indices de cellule sont stock√©s sous forme d'entier. </font><font style="vertical-align: inherit;">Cependant, ils n'utilisent qu'une petite plage de valeurs. </font><font style="vertical-align: inherit;">Chacun d'eux restera certainement dans la plage de 0 √† 255. </font><font style="vertical-align: inherit;">Cela signifie que seul le premier octet de chaque entier sera utilis√©. </font><font style="vertical-align: inherit;">Les trois autres seront toujours nuls. </font><font style="vertical-align: inherit;">Cela n'a aucun sens de stocker ces octets vides. </font><font style="vertical-align: inherit;">Nous pouvons les √©liminer en √©crivant un entier en octets avant d'√©crire dans le flux.</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, pour renvoyer ces num√©ros, nous devons utiliser </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La conversion d'octet en entier se fait implicitement, nous n'avons donc pas besoin d'ajouter de conversions explicites.</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On se d√©barrasse donc de trois octets par entier, ce qui √©conomise 27 octets par cellule. Maintenant, nous d√©pensons 18 octets par cellule et seulement 5 400 octets pour 300 cellules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de noter que les anciennes donn√©es de la carte perdent leur sens √† ce stade. Lors du chargement de l'ancienne sauvegarde, les donn√©es sont m√©lang√©es et nous obtenons des cellules confuses. C'est parce que nous lisons maintenant moins de donn√©es. Si nous lisons plus de donn√©es qu'auparavant, nous obtiendrons une erreur en essayant de lire au-del√† de la fin du fichier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'incapacit√© √† traiter les anciennes donn√©es nous convient, car nous sommes en train de d√©terminer le format. </font><font style="vertical-align: inherit;">Mais lorsque nous d√©ciderons du format de sauvegarde, nous devrons nous assurer que le futur code pourra toujours le lire. </font><font style="vertical-align: inherit;">M√™me si nous changeons le format, nous devrions id√©alement pouvoir lire l'ancien format.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Byte Union </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, nous utilisons quatre octets pour stocker les donn√©es fluviales, deux par direction. </font><font style="vertical-align: inherit;">Pour chaque direction, nous m√©morisons la pr√©sence de la rivi√®re et la direction dans laquelle elle coule, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il semble √©vident que nous n'avons pas besoin de m√©moriser la direction de la rivi√®re sinon. </font><font style="vertical-align: inherit;">Cela signifie que les cellules sans rivi√®re ont besoin de deux octets de moins. </font><font style="vertical-align: inherit;">En fait, un octet en direction de la rivi√®re nous suffira, quelle que soit son existence.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons six directions possibles, qui sont stock√©es sous forme de nombres dans l'intervalle 0‚Äì5. </font><font style="vertical-align: inherit;">Trois bits suffisent pour cela, car sous forme binaire, les nombres de 0 √† 5 ressemblent √† 000, 001, 010, 011, 100, 101 et 110. Autrement dit, un octet de plus reste inutilis√© cinq bits de plus. </font><font style="vertical-align: inherit;">Nous pouvons utiliser l'un d'eux pour indiquer s'il existe une rivi√®re. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez utiliser le huiti√®me bit, correspondant au nombre 128. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, nous y ajouterons 128 avant de convertir la direction en octets. Autrement dit, si une rivi√®re coule vers le nord-ouest, nous √©crirons 133, qui sous la forme binaire est 10000101. Et s'il n'y a pas de rivi√®re, alors nous √©crivons simplement un octet z√©ro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le m√™me temps, quatre bits suppl√©mentaires restent inutilis√©s, mais cela est normal. </font><font style="vertical-align: inherit;">Nous pouvons combiner les deux directions de la rivi√®re en un seul octet, mais cela sera d√©j√† trop d√©routant.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©coder les donn√©es fluviales, nous devons d'abord lire l'octet. </font><font style="vertical-align: inherit;">Si sa valeur n'est pas inf√©rieure √† 128, cela signifie qu'il y a une rivi√®re. </font><font style="vertical-align: inherit;">Pour obtenir sa direction, soustrayez 128, puis convertissez en </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence, nous avons obtenu 16 octets par cellule. </font><font style="vertical-align: inherit;">L'am√©lioration ne semble pas grande, mais c'est l'une de ces astuces qui sont utilis√©es pour r√©duire la taille des donn√©es binaires.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrer les routes en un octet </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser une astuce similaire pour compresser les donn√©es routi√®res. </font><font style="vertical-align: inherit;">Nous avons six valeurs bool√©ennes qui peuvent √™tre stock√©es dans les six premiers bits d'un octet. </font><font style="vertical-align: inherit;">Autrement dit, chaque direction de la route est repr√©sent√©e par un nombre qui est une puissance de deux. </font><font style="vertical-align: inherit;">Ce sont 1, 2, 4, 8, 16 et 32, ou sous forme binaire 1, 10, 100, 1000, 10000 et 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er un octet fini, nous devons d√©finir les bits qui correspondent aux directions utilis√©es des routes. </font><font style="vertical-align: inherit;">Pour obtenir la bonne direction pour la direction, nous pouvons utiliser l'op√©rateur </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Combinez-les ensuite √† l'aide de l'op√©rateur OR au niveau du bit. </font><font style="vertical-align: inherit;">Par exemple, si les premi√®re, deuxi√®me, troisi√®me et sixi√®me routes sont utilis√©es, alors l'octet fini sera 100111.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne &lt;&lt;</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©cup√©rer la valeur bool√©enne de la route, vous devez v√©rifier si le bit est d√©fini. </font><font style="vertical-align: inherit;">Si c'est le cas, masquez tous les autres bits √† l'aide de l'op√©rateur ET au niveau du bit avec le num√©ro appropri√©. </font><font style="vertical-align: inherit;">Si le r√©sultat n'est pas √©gal √† z√©ro, alors le bit est activ√© et la route existe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir comprim√© six octets en un, nous avons re√ßu 11 octets par cellule. </font><font style="vertical-align: inherit;">Avec 300 cellules, cela ne repr√©sente que 3 300 octets. </font><font style="vertical-align: inherit;">Autrement dit, apr√®s avoir travaill√© un peu avec les octets, nous avons r√©duit la taille du fichier de 75%.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se pr√©parer pour l'avenir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de d√©clarer notre format de sauvegarde termin√©, nous ajoutons un d√©tail suppl√©mentaire. </font><font style="vertical-align: inherit;">Avant d'enregistrer les donn√©es de la carte, nous allons forcer √† </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©crire un z√©ro entier.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ajoutera quatre octets vides au d√©but de nos donn√©es. </font><font style="vertical-align: inherit;">Autrement dit, avant de charger la carte, nous devons lire ces quatre octets.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que ces octets soient jusqu'√† pr√©sent inutiles, ils sont utilis√©s comme en-t√™te qui fournira une compatibilit√© descendante √† l'avenir. </font><font style="vertical-align: inherit;">Si nous n'avions pas ajout√© ces octets nuls, le contenu des premiers octets d√©pendait de la premi√®re cellule de la carte. </font><font style="vertical-align: inherit;">Par cons√©quent, √† l'avenir, il nous sera plus difficile de d√©terminer la version du format de sauvegarde avec laquelle nous avons affaire. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons simplement v√©rifier les quatre premiers octets. </font><font style="vertical-align: inherit;">S'ils sont vides, alors nous avons affaire √† une version de format 0. Dans les futures versions, il sera possible d'y ajouter autre chose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, si le titre est diff√©rent de z√©ro, nous avons affaire √† une version inconnue. </font><font style="vertical-align: inherit;">Comme nous ne pouvons pas savoir quelles donn√©es il y a, nous devons refuser de t√©l√©charger la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 13: gestion des cartes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous cr√©ons de nouvelles cartes en mode Play. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez la prise en charge de diff√©rentes tailles de cartes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez la taille de la carte aux donn√©es enregistr√©es. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrez et chargez des cartes arbitraires. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichez une liste de cartes. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette partie, nous ajouterons la prise en charge de diff√©rentes tailles de cartes, ainsi que l'enregistrement de diff√©rents fichiers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä partir de cette partie, des didacticiels seront cr√©√©s dans Unity 5.5.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le d√©but de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la biblioth√®que de cartes.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©er de nouvelles cartes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous n'avons cr√©√© la grille hexagonale qu'une seule fois - lors du chargement de la sc√®ne. </font><font style="vertical-align: inherit;">Nous allons maintenant pouvoir d√©marrer une nouvelle carte √† tout moment. </font><font style="vertical-align: inherit;">La nouvelle carte remplacera simplement la carte actuelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Awake </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, certaines m√©triques sont initialis√©es, puis le nombre de cellules est d√©termin√© et les fragments et cellules n√©cessaires sont cr√©√©s. </font><font style="vertical-align: inherit;">En cr√©ant un nouvel ensemble de fragments et de cellules, nous cr√©ons une nouvelle carte. </font><font style="vertical-align: inherit;">Divisons-nous </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en deux parties - le code source d'initialisation et la m√©thode g√©n√©rale </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un bouton dans l'interface utilisateur pour cr√©er une nouvelle carte. </font><font style="vertical-align: inherit;">Je l'ai fait grand et l'ai plac√© sous les boutons d'enregistrement et de chargement.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouveau bouton de carte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connectons l'√©v√©nement </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">ce bouton avec la m√©thode de </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notre objet </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Autrement dit, nous ne passerons pas par l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©diteur de carte hexad√©cimale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais nous appellerons directement la m√©thode objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grille hexad√©cimale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez une carte en cliquant sur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Effacement des anciennes donn√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque vous cliquez sur le bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un nouvel ensemble de fragments et de cellules sera cr√©√©. </font><font style="vertical-align: inherit;">Cependant, les anciens ne sont pas supprim√©s automatiquement. </font><font style="vertical-align: inherit;">Par cons√©quent, nous obtenons plusieurs maillages de carte superpos√©s les uns aux autres. </font><font style="vertical-align: inherit;">Pour √©viter cela, nous devons d'abord nous d√©barrasser des vieux objets. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en d√©truisant tous les fragments actuels au d√©but </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peut-on r√©utiliser des objets existants?</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    ‚Äî    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est-il possible de d√©truire des √©l√©ments enfants comme celui-ci en boucle?</font></font></b> <div class="spoiler_text">  Bien s√ªr.         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sp√©cifiez la taille en cellules au lieu de fragments </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors que nous d√©finissons la taille de la carte √† travers les champs </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l' </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objet </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais il sera beaucoup plus pratique d'indiquer la taille de la carte en cellules. </font><font style="vertical-align: inherit;">Dans le m√™me temps, nous pouvons m√™me changer la taille du fragment √† l'avenir sans changer la taille des cartes. </font><font style="vertical-align: inherit;">Par cons√©quent, √©changeons les r√¥les du nombre de cellules et du nombre de champs de fragments.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; ‚Ä¶ // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; ‚Ä¶ public void CreateMap () { ‚Ä¶ // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela entra√Ænera une erreur de compilation, car il </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise des tailles de fragments </font><font style="vertical-align: inherit;">pour limiter sa position </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Changez </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il utilise directement le nombre de cellules dont il a encore besoin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un fragment a une taille de 5 par 5 cellules, et les cartes par d√©faut ont une taille de 4 par 3 fragments. </font><font style="vertical-align: inherit;">Par cons√©quent, pour garder les cartes identiques, nous devrons utiliser une taille de 20 par 15 cellules. </font><font style="vertical-align: inherit;">Et bien que nous ayons attribu√© des valeurs par d√©faut dans le code, l'objet de grille ne les utilisera toujours pas automatiquement, car les champs existaient d√©j√† et par d√©faut √† 0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par d√©faut, la carte a une taille de 20 par 15.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tailles de cartes personnalis√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prochaine √©tape consistera √† prendre en charge la cr√©ation de cartes de toute taille, pas seulement la taille par d√©faut. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X et Z </font><font style="vertical-align: inherit;">aux </font><font style="vertical-align: inherit;">param√®tres qui remplaceront le nombre de cellules existant. </font><font style="vertical-align: inherit;">√Ä l'int√©rieur, </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous les appellerons simplement avec le nombre actuel de cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cela ne fonctionnera correctement qu'avec le nombre de cellules qui est un multiple de la taille du fragment. </font><font style="vertical-align: inherit;">Sinon, la division enti√®re cr√©era trop peu de fragments. </font><font style="vertical-align: inherit;">Bien que nous puissions ajouter la prise en charge de fragments partiellement remplis de cellules, interdisons simplement l'utilisation de tailles qui ne correspondent pas √† des fragments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser l'op√©rateur </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour calculer le reste de la division du nombre de cellules par le nombre de fragments. </font><font style="vertical-align: inherit;">S'il n'est pas √©gal √† z√©ro, alors il y a un √©cart et nous ne cr√©erons pas de nouvelle carte. </font><font style="vertical-align: inherit;">Et pendant ce temps, ajoutons une protection contre les tailles nulles et n√©gatives.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nouveau menu de carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'√©tape actuelle, le bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne fonctionne plus, car la m√©thode a </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant deux param√®tres. Nous ne pouvons pas connecter directement les √©v√©nements Unity √† de telles m√©thodes. De plus, pour prendre en charge diff√©rentes tailles de cartes, nous avons besoin de quelques boutons. Au lieu d'ajouter tous ces boutons √† l'interface utilisateur principale, cr√©ons un menu contextuel distinct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un nouveau canevas √† la sc√®ne ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Nous utiliserons les m√™mes param√®tres que le canevas existant, sauf que son </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordre de tri</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit √™tre √©gal √† 1. Gr√¢ce √† cela, il sera au-dessus de l'interface utilisateur de l'√©diteur principal. J'ai fait √† la fois le canevas et le syst√®me d'√©v√©nements un enfant du nouvel objet d'interface utilisateur afin que la hi√©rarchie des sc√®nes reste propre.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Canvas Nouvelle carte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un </font><font style="vertical-align: inherit;">panneau </font><font style="vertical-align: inherit;">au </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui ferme tout l'√©cran. </font><font style="vertical-align: inherit;">Il est n√©cessaire d'assombrir l'arri√®re-plan et de ne pas permettre au curseur d'interagir avec tout le reste lorsque le menu est ouvert. </font><font style="vertical-align: inherit;">Je lui ai donn√© une couleur uniforme, effa√ßant son </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image source</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font><font style="vertical-align: inherit;">d√©fini (0, 0, 0, 200) </font><font style="vertical-align: inherit;">comme </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">couleur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Param√®tres d'image d'arri√®re-plan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une barre de menus au centre du canevas, semblable aux panneaux de l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©diteur de cartes hexad√©cimales</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cr√©ons une √©tiquette claire et des boutons pour ses petites, moyennes et grandes cartes. </font><font style="vertical-align: inherit;">Nous lui ajouterons √©galement un bouton d'annulation au cas o√π le joueur changerait d'avis. </font><font style="vertical-align: inherit;">Une fois la cr√©ation du dessin termin√©e, d√©sactivez l'int√©gralit√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">du menu Nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nouveau menu de carte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour g√©rer le menu, cr√©ez un composant </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutez-le √† l'objet Canvas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pour cr√©er une nouvelle carte, nous devons avoir acc√®s √† l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Par cons√©quent, nous lui ajoutons un champ commun et le connectons.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composant du nouveau menu de carte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ouverture et fermeture </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons ouvrir et fermer le menu contextuel en activant et d√©sactivant simplement l'objet de canevas. </font><font style="vertical-align: inherit;">Ajoutons </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux m√©thodes courantes pour ce faire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connectez maintenant le bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font><font style="vertical-align: inherit;">de l' </font><font style="vertical-align: inherit;">√©diteur √† la m√©thode </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouverture du menu en appuyant sur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connectez √©galement le bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annuler</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† la m√©thode </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela nous permettra d'ouvrir et de fermer le menu contextuel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©er de nouvelles cartes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er de nouvelles cartes, nous devons appeler la </font><font style="vertical-align: inherit;">m√©thode </font><font style="vertical-align: inherit;">dans l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De plus, apr√®s cela, nous devons fermer le menu contextuel. </font><font style="vertical-align: inherit;">Ajoutez √† la </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode qui traitera cela, en tenant compte d'une taille arbitraire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette m√©thode ne doit pas √™tre g√©n√©rale, car nous ne pouvons toujours pas la connecter directement aux √©v√©nements de bouton. </font><font style="vertical-align: inherit;">√Ä la place, cr√©ez une m√©thode par bouton qui appellera </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec la taille sp√©cifi√©e. </font><font style="vertical-align: inherit;">Pour une petite carte, j'ai utilis√© une taille de 20 par 15, correspondant √† la taille par d√©faut de la carte. </font><font style="vertical-align: inherit;">Pour la carte du milieu, j'ai d√©cid√© de doubler cette taille, obtenant 40 par 30, et de la doubler √† nouveau pour la grande carte. </font><font style="vertical-align: inherit;">Connectez les boutons avec les m√©thodes appropri√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verrouillage de l'appareil photo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser le menu local pour cr√©er de nouvelles cartes avec trois tailles diff√©rentes! Tout fonctionne bien, mais nous devons prendre soin d'un petit d√©tail. Lorsque le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau menu de carte est</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actif, nous ne pouvons plus interagir avec l'interface utilisateur de l'√©diteur et modifier les cellules. Cependant, nous pouvons toujours contr√¥ler la cam√©ra. Id√©alement, avec le menu ouvert, l'appareil photo devrait se verrouiller. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous n'avons qu'une seule cam√©ra, une solution rapide et pragmatique consiste simplement √† lui ajouter une propri√©t√© statique </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pour une utilisation g√©n√©ralis√©e, cette solution n'est pas tr√®s adapt√©e, mais pour notre interface simple elle suffit. Cela n√©cessite que nous suivions l'instance statique √† l'int√©rieur </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est d√©finie lorsque la cam√©ra Awake.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une propri√©t√© </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut √™tre une simple propri√©t√© bool√©enne statique qu'avec un setter. </font><font style="vertical-align: inherit;">Il ne fait que d√©sactiver l'instance </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'elle est verrouill√©e et l'activer lorsqu'elle est d√©verrouill√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut bloquer l'appareil photo et </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- le d√©verrouiller.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenir la position correcte de la cam√©ra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a un autre probl√®me probable avec l'appareil photo. </font><font style="vertical-align: inherit;">Lors de la cr√©ation d'une nouvelle carte plus petite que la carte actuelle, la cam√©ra peut appara√Ætre en dehors des bordures de la carte. </font><font style="vertical-align: inherit;">Elle y restera jusqu'√† ce que le joueur essaie de d√©placer la cam√©ra. </font><font style="vertical-align: inherit;">Et c'est seulement alors qu'il sera limit√© par les limites de la nouvelle carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, nous pouvons ajouter √† la </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode statique </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'appel d'une m√©thode d' </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instance avec un d√©calage nul forcera la cam√©ra √† se d√©placer vers les limites de la carte. </font><font style="vertical-align: inherit;">Si la cam√©ra est d√©j√† √† l'int√©rieur des limites de la nouvelle carte, elle restera en place.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez la m√©thode √† l'int√©rieur </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apr√®s avoir cr√©√© une nouvelle carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrement de la taille de la carte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions cr√©er des cartes de diff√©rentes tailles, elles ne sont pas prises en compte lors de l'enregistrement et du chargement. </font><font style="vertical-align: inherit;">Cela signifie que le chargement d'une carte entra√Ænera une erreur ou une carte incorrecte si la taille de la carte actuelle ne correspond pas √† la taille de la carte charg√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, avant de charger les donn√©es de cellule, nous devons cr√©er une nouvelle carte de la taille appropri√©e. </font><font style="vertical-align: inherit;">Disons que nous avons enregistr√© une petite carte. </font><font style="vertical-align: inherit;">Dans ce cas, tout ira bien si nous cr√©ons </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une carte 20 x 15 </font><font style="vertical-align: inherit;">au d√©but </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stockage de la taille de la carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, nous pouvons stocker une carte de n'importe quelle taille. </font><font style="vertical-align: inherit;">Par cons√©quent, une solution g√©n√©ralis√©e consistera √† enregistrer la taille de la carte devant ces cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous pouvons obtenir la vraie taille et l'utiliser pour cr√©er une carte avec les bonnes tailles. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous pouvons maintenant charger des cartes de diff√©rentes tailles, nous sommes de nouveau confront√©s au probl√®me de la position de la cam√©ra. </font><font style="vertical-align: inherit;">Nous allons le r√©soudre en v√©rifiant sa position </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apr√®s avoir charg√© la carte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nouveau format de fichier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que cette approche fonctionne avec les cartes que nous conserverons √† l'avenir, elle ne fonctionnera pas avec les anciennes. </font><font style="vertical-align: inherit;">Et vice versa - le code de la partie pr√©c√©dente du tutoriel ne pourra pas charger correctement les nouveaux fichiers de carte. </font><font style="vertical-align: inherit;">Pour distinguer les anciens et les nouveaux formats, nous augmenterons la valeur enti√®re de l'en-t√™te. </font><font style="vertical-align: inherit;">L'ancien format de sauvegarde sans taille de carte avait la version 0. Le nouveau format avec une taille de carte aura la version 1. Par cons√©quent, lors de l'enregistrement, il </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait √©crire 1 au lieu de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dor√©navant, les cartes seront enregistr√©es en version 1. Si nous essayons de les ouvrir dans l'assemblage du tutoriel pr√©c√©dent, elles refuseront de charger et de signaler un format de carte inconnu. </font><font style="vertical-align: inherit;">En fait, cela se produira si nous essayons d√©j√† de charger une telle carte. </font><font style="vertical-align: inherit;">Vous devez modifier la m√©thode </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'elle accepte la nouvelle version.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compatibilit√© descendante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, si nous le voulons, nous pouvons toujours t√©l√©charger des cartes de la version 0, en supposant qu'elles ont toutes la m√™me taille 20 par 15. Autrement dit, le titre n'a pas besoin d'√™tre 1, il peut √©galement √™tre z√©ro. </font><font style="vertical-align: inherit;">√âtant donn√© que chaque version n√©cessite sa propre approche, elle </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit transmettre l'en-t√™te √† la m√©thode </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">titre </font><font style="vertical-align: inherit;">au </font><font style="vertical-align: inherit;">param√®tre et utilisez-le pour prendre des d√©cisions sur d'autres actions. </font><font style="vertical-align: inherit;">Si l'en-t√™te n'est pas inf√©rieur √† 1, vous devez lire les donn√©es de taille de carte. </font><font style="vertical-align: inherit;">Sinon, nous utilisons l'ancienne taille de carte fixe de 20 par 15 et sautons la lecture des donn√©es de taille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); ‚Ä¶ }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version 0 du fichier de carte</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V√©rification de la taille de la carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour la cr√©ation d'une nouvelle carte, il est th√©oriquement possible de devoir charger une carte incompatible avec la taille du fragment. </font><font style="vertical-align: inherit;">Lorsque cela se produit, nous devons interrompre le t√©l√©chargement de la carte. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refuse d√©j√† de cr√©er une carte et affiche une erreur dans la console. </font><font style="vertical-align: inherit;">Pour le dire √† l'appelant de la m√©thode, retournons un bool√©en indiquant si la carte a √©t√© cr√©√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sormais, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il peut √©galement arr√™ter l'ex√©cution lorsque la cr√©ation de la carte √©choue.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que le chargement √©crase toutes les donn√©es dans les cellules existantes, nous n'avons pas besoin de cr√©er une nouvelle carte si une carte de la m√™me taille est charg√©e. </font><font style="vertical-align: inherit;">Par cons√©quent, cette √©tape peut √™tre ignor√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gestion des fichiers </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons enregistrer et charger des cartes de diff√©rentes tailles, mais toujours √©crire et lire </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous allons maintenant ajouter la prise en charge de diff√©rents fichiers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu d'enregistrer ou de charger directement la carte, nous utilisons un autre menu local qui fournit une gestion avanc√©e des fichiers. </font><font style="vertical-align: inherit;">Cr√©ez un autre canevas, comme dans le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais cette fois nous l'appellerons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer le menu de chargement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce menu enregistre et charge les cartes, selon le bouton enfonc√© pour l'ouvrir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons cr√©er la conception du </font><em><font style="vertical-align: inherit;">menu Save Load</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme si c'√©tait un menu de sauvegarde. Plus tard, nous le transformerons dynamiquement en un menu de d√©marrage. Comme un autre menu, il doit avoir un arri√®re-plan et une barre de menus, une √©tiquette de menu et un bouton d'annulation. Ajoutez ensuite une vue de d√©filement ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) au menu pour afficher une liste de fichiers. Ci-dessous, nous ins√©rons le champ de saisie ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Champ de saisie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) pour indiquer les noms des nouvelles cartes. Nous avons √©galement besoin d'un bouton d'action pour enregistrer la carte. Et enfin. ajoutez un bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour supprimer les cartes inutiles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design Save Load Menu.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par d√©faut, la vue de d√©filement permet le d√©filement horizontal et vertical, mais nous n'avons besoin que d'une liste avec d√©filement vertical. Par </font><font style="vertical-align: inherit;">cons√©quent, le </font><font style="vertical-align: inherit;">d√©filement disable </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et d√©branchez la barre de </font><font style="vertical-align: inherit;">d√©filement horizontale. Nous avons √©galement d√©fini le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type de mouvement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur bloqu√© et d√©sactiv√© l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inertie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour rendre la liste plus restrictive.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options de liste de fichiers. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons supprimer l'enfant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la </font><em><font style="vertical-align: inherit;">barre de d√©filement</font></em><font style="vertical-align: inherit;"> de l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste de fichiers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car nous n'en avons pas besoin. </font><font style="vertical-align: inherit;">Redimensionnez ensuite la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barre de d√©filement verticale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour qu'elle </font><em><font style="vertical-align: inherit;">atteigne le</font></em><font style="vertical-align: inherit;"> bas de la liste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placeholder objet texte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nom d' </font><font style="vertical-align: inherit;">entr√©e</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut √™tre modifi√©e dans ses enfants </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placeholder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">J'ai utilis√© un texte descriptif, mais vous pouvez simplement le laisser vide et vous d√©barrasser de l'espace r√©serv√©.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conception de menu modifi√©e. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous en avons fini avec le design, et d√©sactivons maintenant le menu pour qu'il soit masqu√© par d√©faut.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gestion des menus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que le menu fonctionne, nous avons besoin d'un autre script, dans ce cas - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comme </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il a besoin d'un lien vers la grille, ainsi que des m√©thodes </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez ce composant √† </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et donnez-lui un lien vers l'objet de grille.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composant SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un menu s'ouvrira pour enregistrer ou charger. </font><font style="vertical-align: inherit;">Pour simplifier le travail, ajoutez un </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tre bool√©en </font><font style="vertical-align: inherit;">√† la m√©thode </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il d√©termine si le menu doit √™tre en mode sauvegarde. </font><font style="vertical-align: inherit;">Nous allons suivre ce mode sur le terrain pour savoir quelle action effectuer plus tard.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant , </font><font style="vertical-align: inherit;">combiner les boutons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charger</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l' objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec la m√©thode </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer Charger le menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">V√©rifiez le param√®tre bool√©en pour le bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uniquement </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouverture du menu en mode sauvegarde. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous ne l'avez pas d√©j√† fait, connectez l'√©v√©nement du bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annuler</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† la m√©thode </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer Menu Charger</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut √™tre ouvert et ferm√©.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changement d'apparence </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons cr√©√© le menu comme un menu de sauvegarde, mais son mode est d√©termin√© par le bouton enfonc√© pour ouvrir. </font><font style="vertical-align: inherit;">Nous devons changer l'apparence du menu en fonction du mode. </font><font style="vertical-align: inherit;">En particulier, nous devons changer l'√©tiquette du menu et l'√©tiquette du bouton d'action. </font><font style="vertical-align: inherit;">Cela signifie que nous aurons besoin de liens vers ces balises.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion avec des balises. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque le menu s'ouvre en mode d'enregistrement, nous utilisons les √©tiquettes existantes, c'est-√†-dire </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer la carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le menu et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le bouton d'action. </font><font style="vertical-align: inherit;">Sinon, nous sommes en mode chargement, c'est-√†-dire que nous utilisons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entrez le nom de la carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laissons pour l'instant la liste des fichiers. </font><font style="vertical-align: inherit;">L'utilisateur peut sp√©cifier le fichier enregistr√© ou t√©l√©charg√© en entrant le nom de la carte dans le champ de saisie. </font><font style="vertical-align: inherit;">Pour obtenir ces donn√©es, nous avons besoin d'une r√©f√©rence au composant </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion au champ de saisie. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisateur n'a pas besoin d'√™tre oblig√© de saisir le chemin d'acc√®s complet au fichier de carte. </font><font style="vertical-align: inherit;">Il suffira seulement du nom de la carte sans l'extension </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ajoutons une m√©thode qui prend la saisie de l'utilisateur et cr√©e le bon chemin pour cela. </font><font style="vertical-align: inherit;">Ce n'est pas possible lorsque l'entr√©e est vide, donc dans ce cas, nous reviendrons </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il si l'utilisateur entre des caract√®res invalides?</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sauvegarde et chargement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, il sera engag√© dans la sauvegarde et le chargement </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par cons√©quent, nous d√©pla√ßons les m√©thodes </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ils ne doivent plus √™tre partag√©s et fonctionneront avec le param√®tre path au lieu du chemin fixe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous t√©l√©chargeons maintenant des fichiers arbitraires, il serait bon de v√©rifier que le fichier existe r√©ellement et d'essayer de le lire ensuite. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, nous lan√ßons une erreur et terminons l'op√©ration.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez maintenant la m√©thode g√©n√©rale </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela commence par l'obtention du chemin s√©lectionn√© par l'utilisateur. </font><font style="vertical-align: inherit;">S'il existe un chemin, enregistrez-le ou chargez-le. </font><font style="vertical-align: inherit;">Fermez ensuite le menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attachant un √©v√©nement de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bouton d'action</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† cette m√©thode </font><font style="vertical-align: inherit;">, nous pouvons enregistrer et charger en utilisant des noms de carte arbitraires. </font><font style="vertical-align: inherit;">Comme nous ne r√©initialisons pas le champ de saisie, le nom s√©lectionn√© restera jusqu'√† la prochaine sauvegarde ou charge. </font><font style="vertical-align: inherit;">C'est pratique pour enregistrer ou charger un fichier plusieurs fois de suite, donc nous ne changerons rien.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âl√©ments de la liste des cartes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous remplirons la liste des fichiers avec toutes les cartes qui se trouvent sur le chemin de stockage des donn√©es. </font><font style="vertical-align: inherit;">Lorsque vous cliquez sur l'un des √©l√©ments de la liste, il sera utilis√© comme texte dans la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saisie de nom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ajoutez une </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode g√©n√©rale pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons besoin d'un √©l√©ment de liste. </font><font style="vertical-align: inherit;">Le bouton habituel fera l'affaire. </font><font style="vertical-align: inherit;">Cr√©ez-le et r√©duisez la hauteur √† 20 unit√©s afin qu'il n'occupe pas beaucoup d'espace verticalement. </font><font style="vertical-align: inherit;">Il ne doit pas ressembler √† un bouton. Nous allons donc supprimer le lien </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image source</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">son composant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans ce cas, il deviendra compl√®tement blanc. </font><font style="vertical-align: inherit;">De plus, nous nous assurerons que l'√©tiquette est align√©e √† gauche et qu'il y a de l'espace entre le texte et le c√¥t√© gauche du bouton. </font><font style="vertical-align: inherit;">Apr√®s avoir termin√© la conception du bouton, nous le transformons en un pr√©fabriqu√©.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le bouton est un √©l√©ment de liste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas connecter directement l'√©v√©nement de bouton au </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menu Nouvelle carte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car il s'agit d'un pr√©fabriqu√© et il n'existe pas encore dans la sc√®ne. </font><font style="vertical-align: inherit;">Par cons√©quent, un √©l√©ment de menu a besoin d'un lien vers le menu pour pouvoir invoquer une m√©thode lorsqu'il est cliqu√© </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il doit √©galement garder une trace du nom de la carte qu'il repr√©sente et d√©finir son texte. </font><font style="vertical-align: inherit;">Cr√©ons un petit composant pour cela </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un composant √† l'√©l√©ment de menu et faites en sorte que le bouton appelle sa m√©thode </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composant d'article.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remplir la liste </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour remplir la liste, vous avez </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besoin d'un lien vers </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fen√™tre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d' </font><em><font style="vertical-align: inherit;">affichage</font></em><font style="vertical-align: inherit;"> de l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste de fichiers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il a √©galement besoin d'un lien vers l'√©l√©ment pr√©fabriqu√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©langez le contenu d'une liste et d'un pr√©fabriqu√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons une nouvelle m√©thode pour remplir cette liste. </font><font style="vertical-align: inherit;">La premi√®re √©tape consiste √† identifier les fichiers de carte existants. </font><font style="vertical-align: inherit;">Pour obtenir un tableau de tous les chemins de fichiers √† l'int√©rieur du r√©pertoire, nous pouvons utiliser la m√©thode </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette m√©thode a un deuxi√®me param√®tre qui vous permet de filtrer les fichiers. </font><font style="vertical-align: inherit;">Dans notre cas, seuls les fichiers correspondant au masque </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont requis </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, l'ordre des fichiers n'est pas garanti. </font><font style="vertical-align: inherit;">Pour les afficher par ordre alphab√©tique, nous devons trier le tableau avec </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous allons cr√©er des instances pr√©fabriqu√©es pour chaque √©l√©ment du tableau. </font><font style="vertical-align: inherit;">Liez l'√©l√©ment au menu, d√©finissez son nom de carte et faites-en un enfant du contenu de la liste.</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie les chemins d'acc√®s complets aux fichiers, nous devons les effacer. </font><font style="vertical-align: inherit;">Heureusement, c'est exactement ce qui rend la m√©thode pratique </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant d'afficher le menu, nous devons remplir une liste. </font><font style="vertical-align: inherit;">Et comme les fichiers sont susceptibles de changer, nous devons le faire chaque fois que nous ouvrons le menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lors du remplissage de la liste, nous devons supprimer tous les anciens avant d'ajouter de nouveaux √©l√©ments. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Articles sans arrangement.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disposition des points </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, la liste affichera des √©l√©ments, mais ils se chevaucheront et seront dans une mauvaise position. Pour les transformer en liste verticale, ajoutez le </font><font style="vertical-align: inherit;">composant </font><em><font style="vertical-align: inherit;">Groupe de disposition verticale</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">Composant / Pr√©sentation / Groupe de pr√©sentation verticale</font></em><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">√† l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><font style="vertical-align: inherit;">liste </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour que la disposition fonctionne correctement, activez la </font><em><font style="vertical-align: inherit;">largeur</font></em><font style="vertical-align: inherit;"> de </font><em><font style="vertical-align: inherit;">la taille du contr√¥le </font></em><em><font style="vertical-align: inherit;">enfant</font></em><font style="vertical-align: inherit;"> et de l' </font><em><font style="vertical-align: inherit;">expansion de la force enfant</font></em><font style="vertical-align: inherit;"> . Les deux options de </font><em><font style="vertical-align: inherit;">hauteur</font></em><font style="vertical-align: inherit;"> doivent √™tre d√©sactiv√©es.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation du groupe de disposition verticale. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons obtenu une belle liste d'articles. </font><font style="vertical-align: inherit;">Cependant, la taille du contenu de la liste ne s'adapte pas au nombre r√©el d'√©l√©ments. </font><font style="vertical-align: inherit;">Par cons√©quent, la barre de d√©filement ne change jamais de taille. </font><font style="vertical-align: inherit;">Nous pouvons forcer le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenu √†</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se redimensionner automatiquement en lui ajoutant un composant d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajustement de la taille du contenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">composant / mise en page / ajustement de la taille du contenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Son mode d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajustement vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doit √™tre d√©fini sur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taille pr√©f√©r√©e</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'un ajusteur de taille de contenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, avec un petit nombre de points, la barre de d√©filement dispara√Ætra. </font><font style="vertical-align: inherit;">Et lorsqu'il y a trop d'√©l√©ments dans la liste qui ne tiennent pas dans la fen√™tre, la barre de d√©filement appara√Æt et a une taille appropri√©e.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une barre de d√©filement appara√Æt.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suppression de la carte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons facilement travailler avec de nombreux fichiers de carte. </font><font style="vertical-align: inherit;">Cependant, il est parfois n√©cessaire de se d√©barrasser de certaines cartes. </font><font style="vertical-align: inherit;">Pour ce faire, vous pouvez utiliser le bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cr√©ons une m√©thode pour cela et faisons que le bouton l'appelle. </font><font style="vertical-align: inherit;">S'il y a un chemin s√©lectionn√©, supprimez-le simplement avec </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous devons √©galement v√©rifier que nous travaillons avec un fichier r√©ellement existant. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, nous ne devons pas essayer de le supprimer, mais cela ne conduit pas √† une erreur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir retir√© la carte, nous n'avons pas besoin de fermer le menu. </font><font style="vertical-align: inherit;">Cela facilite la suppression de plusieurs fichiers √† la fois. </font><font style="vertical-align: inherit;">Cependant, apr√®s la suppression, nous devons effacer l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entr√©e de nom</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi que mettre √† jour la liste des fichiers.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 14: textures en relief </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisez les couleurs des sommets pour cr√©er une carte splat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation d'une ressource de texture de tableau. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout d'indices d'√©l√©vation aux maillages. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transitions entre textures en relief. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† ce moment, nous utilisions des couleurs unies pour colorier les cartes. </font><font style="vertical-align: inherit;">Nous allons maintenant appliquer la texture.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dessin de textures.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un m√©lange de trois types </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que les couleurs uniformes soient clairement reconnaissables et assez adapt√©es √† la t√¢che, elles ne semblent pas tr√®s int√©ressantes. </font><font style="vertical-align: inherit;">L'utilisation de textures augmentera consid√©rablement l'attrait des cartes. </font><font style="vertical-align: inherit;">Bien s√ªr, pour cela, nous devons m√©langer les textures, pas seulement les couleurs. </font><font style="vertical-align: inherit;">Dans le didacticiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu 3, Combinaison de textures,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'ai expliqu√© comment m√©langer plusieurs textures √† l'aide de la carte de splat. </font><font style="vertical-align: inherit;">Dans nos cartes hexagonales, vous pouvez utiliser une approche similaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le didacticiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seules quatre textures sont m√©lang√©es, et avec une carte splat, nous pouvons prendre en charge jusqu'√† cinq textures. </font><font style="vertical-align: inherit;">Pour le moment, nous utilisons cinq couleurs diff√©rentes, donc cela nous convient parfaitement. </font><font style="vertical-align: inherit;">Cependant, plus tard, nous pouvons ajouter d'autres types. </font><font style="vertical-align: inherit;">Par cons√©quent, la prise en charge d'un nombre arbitraire de types de relief est n√©cessaire. </font><font style="vertical-align: inherit;">Lorsque vous utilisez des propri√©t√©s de texture d√©finies explicitement, cela n'est pas possible, vous devez donc utiliser un tableau de textures. </font><font style="vertical-align: inherit;">Plus tard, nous le cr√©erons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous utilisez des tableaux de textures, nous devons en quelque sorte dire au shader quelles textures m√©langer. </font><font style="vertical-align: inherit;">Le m√©lange le plus difficile est n√©cessaire pour les triangles angulaires, qui peuvent √™tre entre trois cellules avec leur propre type de terrain. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons m√©langer le support entre les trois types par triangle.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation des couleurs de sommets comme Splat Maps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En supposant que nous pouvons vous dire quelles textures m√©langer, nous pouvons utiliser les couleurs des sommets pour cr√©er une carte splat pour chaque triangle. </font><font style="vertical-align: inherit;">Puisque dans chaque cas, un maximum de trois textures est utilis√©, nous n'avons besoin que de trois canaux de couleur. </font><font style="vertical-align: inherit;">Le rouge repr√©sentera la premi√®re texture, le vert - la seconde et le bleu - la troisi√®me.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte Triangle Splat.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La somme de la carte splat triangle est-elle toujours √©gale √† un?</font></font></b> <div class="spoiler_text">  Oui         .     . ,        (1, 0, 0)  ,  (¬Ω, ¬Ω, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si un triangle n'a besoin que d'une seule texture, nous utilisons uniquement le premier canal. </font><font style="vertical-align: inherit;">Autrement dit, sa couleur sera compl√®tement rouge. </font><font style="vertical-align: inherit;">Dans le cas d'un mixage entre deux types diff√©rents, nous utilisons les premier et deuxi√®me canaux. </font><font style="vertical-align: inherit;">Autrement dit, la couleur du triangle sera un m√©lange de rouge et de vert. </font><font style="vertical-align: inherit;">Et lorsque les trois types seront trouv√©s, ce sera un m√©lange de rouge, de vert et de bleu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trois configurations de carte splat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utiliserons ces configurations de splat map quelles que soient les textures r√©ellement m√©lang√©es. </font><font style="vertical-align: inherit;">Autrement dit, la carte splat sera toujours la m√™me. </font><font style="vertical-align: inherit;">Seules les textures changeront. </font><font style="vertical-align: inherit;">Comment faire cela, nous le saurons plus tard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons changer </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il cr√©e ces cartes splat, plut√¥t que d'utiliser des couleurs de cellule. </font><font style="vertical-align: inherit;">Comme nous utiliserons souvent trois couleurs, nous leur cr√©erons des champs statiques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centres cellulaires </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par remplacer la couleur du centre des cellules par d√©faut. </font><font style="vertical-align: inherit;">Aucun m√©lange n'est effectu√© ici, nous utilisons donc uniquement la premi√®re couleur, c'est-√†-dire le rouge.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Centres rouges des cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les centres cellulaires deviennent maintenant rouges. </font><font style="vertical-align: inherit;">Ils utilisent tous la premi√®re des trois textures, quelle que soit la texture. </font><font style="vertical-align: inherit;">Leurs splat maps sont les m√™mes, quelle que soit la couleur avec laquelle nous colorisons les cellules.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quartier de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons chang√© les segments uniquement √† l'int√©rieur des cellules sans que des rivi√®res ne coulent le long de celles-ci. </font><font style="vertical-align: inherit;">Nous devons faire de m√™me pour les segments adjacents aux rivi√®res. </font><font style="vertical-align: inherit;">Dans notre cas, il s'agit √† la fois d'une bande de c√¥tes et d'un √©ventail de triangles de la c√¥te. </font><font style="vertical-align: inherit;">Ici aussi, seul le rouge nous suffit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segments rouges adjacents aux rivi√®res.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivi√®res </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons prendre soin de la g√©om√©trie des rivi√®res √† l'int√©rieur des cellules. </font><font style="vertical-align: inherit;">Tous devraient √©galement devenir rouges. </font><font style="vertical-align: inherit;">Pour commencer, regardons le d√©but et la fin des rivi√®res.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et puis la g√©om√©trie qui compose les berges et le lit de la rivi√®re. </font><font style="vertical-align: inherit;">J'ai regroup√© les appels de m√©thode de couleur pour rendre le code plus facile √† lire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivi√®res rouges le long des cellules.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√¥tes lev√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les bords sont diff√©rents car ils sont entre des cellules qui peuvent avoir diff√©rents types de terrain. </font><font style="vertical-align: inherit;">Nous utilisons la premi√®re couleur pour le type de cellule actuel et la deuxi√®me couleur pour le type voisin. </font><font style="vertical-align: inherit;">En cons√©quence, la carte splat deviendra un d√©grad√© rouge-vert, m√™me si les deux cellules sont du m√™me type. </font><font style="vertical-align: inherit;">Si les deux cellules utilisent la m√™me texture, cela devient simplement un m√©lange de la m√™me texture des deux c√¥t√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¥tes rouge-vert, √† l'exclusion des rebords.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transition abrupte entre le rouge et le vert ne causerait-elle pas des probl√®mes?</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les bords avec les rebords sont un peu plus compliqu√©s, car ils ont des sommets suppl√©mentaires. </font><font style="vertical-align: inherit;">Heureusement, le code d'interpolation existant fonctionne tr√®s bien avec les couleurs de la carte splat. </font><font style="vertical-align: inherit;">Utilisez simplement les premi√®re et deuxi√®me couleurs, pas les couleurs des cellules du d√©but et de la fin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rebords de c√¥tes rouge-vert.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Angles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les angles de cellule sont les plus difficiles car ils doivent m√©langer trois textures diff√©rentes. </font><font style="vertical-align: inherit;">Nous utilisons du rouge pour le pic du bas, du vert pour la gauche et du bleu pour la droite. </font><font style="vertical-align: inherit;">Commen√ßons par les coins d'un triangle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coins rouge-vert-bleu, √† l'exception des rebords. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous pouvons √† nouveau utiliser le code d'interpolation de couleur existant pour les coins avec des rebords. </font><font style="vertical-align: inherit;">L'interpolation se fait uniquement entre trois, pas deux couleurs. </font><font style="vertical-align: inherit;">Tout d'abord, consid√©rez les corniches qui ne sont pas pr√®s des falaises.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corniches d'angle rouge-vert-bleu, √† l'exception des corniches le long des falaises. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ce qui concerne les falaises, nous devons utiliser une m√©thode </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette m√©thode a re√ßu les cellules de d√©part et de gauche comme param√®tres. </font><font style="vertical-align: inherit;">Cependant, nous avons maintenant besoin des couleurs de splat appropri√©es, qui peuvent varier en fonction de la topologie. </font><font style="vertical-align: inherit;">Par cons√©quent, nous rempla√ßons ces param√®tres par des couleurs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changez-le </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il utilise les bonnes couleurs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et faites de m√™me pour </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte en relief pleine splat. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tableaux de texture </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que notre terrain a une carte splat, nous pouvons passer la collection de textures au shader. </font><font style="vertical-align: inherit;">Nous ne pouvons pas simplement affecter un shader √† un tableau de textures C #, car le tableau doit exister dans la m√©moire du GPU en tant qu'entit√© unique. </font><font style="vertical-align: inherit;">Nous devrons utiliser un objet sp√©cial </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui est pris en charge dans Unity depuis la version 5.4.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les GPU prennent-ils en charge les tableaux de textures?</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li>  Playstation 4 </li></ul></div></div><br><br><h3>  Le ma√Ætre </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, la prise en charge par Unity des tableaux de texture dans la version 5.5 est minime. </font><font style="vertical-align: inherit;">Nous ne pouvons pas simplement cr√©er un √©l√©ment de tableau de textures et lui affecter des textures. </font><font style="vertical-align: inherit;">Nous devons le faire manuellement. </font><font style="vertical-align: inherit;">Nous pouvons soit cr√©er un tableau de textures en mode Play, soit cr√©er un √©l√©ment dans l'√©diteur. </font><font style="vertical-align: inherit;">Cr√©ons un atout.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi cr√©er un atout?</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er un tableau de textures, nous assemblerons notre propre ma√Ætre. </font><font style="vertical-align: inherit;">Cr√©ez un script </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et placez-le dans le dossier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Au lieu de cela, </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il doit √©tendre le type √† </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir de l'espace de noms </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons ouvrir l'assistant via une m√©thode statique g√©n√©ralis√©e </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ses param√®tres sont les noms de la fen√™tre de l'assistant et son bouton de cr√©ation. </font><font style="vertical-align: inherit;">Nous appellerons cette m√©thode dans une m√©thode statique </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour acc√©der √† l'assistant via l'√©diteur, nous devons ajouter cette m√©thode au menu Unity. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en ajoutant un attribut √† la m√©thode </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutons-le au menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et plus sp√©cifiquement au </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableau Assets / Create / Texture</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre assistant personnalis√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant le nouvel √©l√©ment de menu, vous pouvez ouvrir le menu contextuel de notre assistant personnalis√©. </font><font style="vertical-align: inherit;">Ce n'est pas tr√®s beau, mais adapt√© pour r√©soudre le probl√®me. </font><font style="vertical-align: inherit;">Cependant, il est toujours vide. </font><font style="vertical-align: inherit;">Pour cr√©er un tableau de textures, nous avons besoin d'un tableau de textures. </font><font style="vertical-align: inherit;">Ajoutez-y un champ g√©n√©ral pour le ma√Ætre. </font><font style="vertical-align: inherit;">L'interface graphique standard de l'assistant l'affiche comme le fait un inspecteur standard.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ma√Ætrisez les textures.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ons quelque chose </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous cliquez sur le bouton </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©er</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l' </font><font style="vertical-align: inherit;">assistant, il dispara√Æt. </font><font style="vertical-align: inherit;">De plus, Unity se plaint de l'absence de m√©thode </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit de la m√©thode qui est appel√©e lorsque le bouton de cr√©ation est cliqu√©, nous devons donc l'ajouter √† l'assistant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous allons cr√©er notre tableau de textures. </font><font style="vertical-align: inherit;">Au moins si l'utilisateur a ajout√© des textures au ma√Ætre. </font><font style="vertical-align: inherit;">Sinon, il n'y a rien √† cr√©er et le travail doit √™tre arr√™t√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©tape suivante consiste √† demander l'emplacement pour enregistrer l'actif du tableau de textures. </font><font style="vertical-align: inherit;">Le panneau d'enregistrement de fichier peut √™tre ouvert √† l'aide de la m√©thode </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ses param√®tres d√©finissent le nom du panneau, le nom de fichier par d√©faut, l'extension de fichier et la description. </font><font style="vertical-align: inherit;">Les tableaux de texture utilisent l'extension de fichier d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actif</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> g√©n√©rale </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie le chemin du fichier s√©lectionn√© par l'utilisateur. </font><font style="vertical-align: inherit;">Si l'utilisateur a cliqu√© sur Annuler sur ce panneau, le chemin d'acc√®s sera une cha√Æne vide. </font><font style="vertical-align: inherit;">Par cons√©quent, dans ce cas, nous devons interrompre le travail.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation d'un tableau de textures </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons le bon chemin, nous pouvons continuer et cr√©er un nouvel objet </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sa m√©thode constructeur n√©cessite de sp√©cifier la largeur et la hauteur de la texture, la longueur du tableau, le format des textures et la n√©cessit√© de texturer le mip. </font><font style="vertical-align: inherit;">Ces param√®tres doivent √™tre les m√™mes pour toutes les textures du tableau. </font><font style="vertical-align: inherit;">Pour configurer l'objet, nous utilisons la premi√®re texture. </font><font style="vertical-align: inherit;">L'utilisateur doit v√©rifier que toutes les textures ont le m√™me format.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que le tableau de textures est une ressource GPU unique, il utilise les m√™mes modes de filtrage et de pliage pour toutes les textures. </font><font style="vertical-align: inherit;">Ici, nous utilisons √† nouveau la premi√®re texture pour tout configurer.</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons copier les textures dans un tableau en utilisant la m√©thode </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La m√©thode copie les donn√©es brutes de texture, un niveau de mip √† la fois. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons parcourir toutes les textures et leurs niveaux de mip. </font><font style="vertical-align: inherit;">Les param√®tres de m√©thode sont deux ensembles compos√©s d'une ressource de texture, d'un index et d'un niveau mip. </font><font style="vertical-align: inherit;">Comme les textures d'origine ne sont pas des tableaux, leur index est toujours nul.</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, nous avons en m√©moire la bonne gamme de textures, mais ce n'est pas encore un atout. </font><font style="vertical-align: inherit;">La derni√®re √©tape consistera √† appeler </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le tableau et son chemin. </font><font style="vertical-align: inherit;">Dans ce cas, les donn√©es seront √©crites dans un fichier de notre projet et elles appara√Ætront dans la fen√™tre du projet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { ‚Ä¶ } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textures </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er un v√©ritable tableau de textures, nous avons besoin des textures d'origine. Voici cinq textures qui correspondent aux couleurs que nous utilisions jusqu'√† pr√©sent. Le jaune devient sable, le vert devient herbe, le bleu devient terre, l'orange devient pierre et le blanc devient neige.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textures de sable, d'herbe, de terre, de pierre et de neige. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que ces textures ne sont pas des photographies de ce relief. </font><font style="vertical-align: inherit;">Ce sont les mod√®les pseudo-al√©atoires faciles que j'ai cr√©√©s √† l'aide de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Je me suis efforc√© de cr√©er des types et des d√©tails de relief reconnaissables qui n'entrent pas en conflit avec le relief polygonal abstrait. </font><font style="vertical-align: inherit;">Le photor√©alisme s'est r√©v√©l√© inadapt√© √† cela. </font><font style="vertical-align: inherit;">En outre, bien que les mod√®les ajoutent de la variabilit√©, ils contiennent peu de caract√©ristiques distinctes qui rendraient les r√©p√©titions imm√©diatement perceptibles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez ces textures au tableau principal, en vous assurant que leur ordre correspond aux couleurs. </font><font style="vertical-align: inherit;">C'est-√†-dire d'abord du sable, puis de l'herbe, de la terre, de la pierre et enfin de la neige.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ation d'un tableau de textures. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir cr√©√© l'√©l√©ment de tableau de textures, s√©lectionnez-le et examinez-le dans l'inspecteur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspecteur de tableau de texture.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il s'agit de l'affichage le plus simple d'un morceau de donn√©es de tableau de texture. Notez qu'il existe un commutateur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui est initialement activ√©. Comme nous n'avons pas besoin de lire les donn√©es de pixels du tableau, d√©sactivez-le. Nous ne pouvons pas le faire dans l'assistant car il n'existe </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aucune m√©thode ou propri√©t√© pour acc√©der √† ce param√®tre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Dans Unity 5.6, il y a un bogue qui g√¢che les tableaux de texture dans les assemblys sur plusieurs plates-formes. Vous pouvez le contourner sans d√©sactiver </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est lisible</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient √©galement de noter qu'il existe un champ </font><em><font style="vertical-align: inherit;">Espace</font></em><font style="vertical-align: inherit;"> colorim√©trique</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auquel est affect√©e la valeur 1. Cela signifie que les textures sont suppos√©es √™tre dans l'espace gamma, ce qui est vrai. </font><font style="vertical-align: inherit;">S'ils √©taient cens√©s √™tre dans un espace lin√©aire, le champ devait √™tre d√©fini sur 0. En fait, le concepteur </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un param√®tre suppl√©mentaire pour sp√©cifier l'espace colorim√©trique, mais il </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne montre pas s'il se trouve dans l'espace lin√©aire ou non, par cons√©quent, dans tous les cas, vous devez d√©finir manuellement.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons un √©ventail de textures, nous devons apprendre au shader √† travailler avec. </font><font style="vertical-align: inherit;">Pour l'instant, nous utilisons le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour rendre le terrain </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque maintenant nous utiliserons des textures au lieu de couleurs, renommez-le en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ensuite, nous transformons son param√®tre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en un tableau de textures et lui </font><em><font style="vertical-align: inherit;">attribuons</font></em><font style="vertical-align: inherit;"> un atout.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mat√©riau en relief avec un √©ventail de textures. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour activer les tableaux de textures sur toutes les plates-formes les prenant en charge, vous devez augmenter le niveau cible du shader de 3,0 √† 3,5.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que la variable </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait d√©sormais r√©f√©rence √† un tableau de textures, nous devons changer son type. </font><font style="vertical-align: inherit;">Le type d√©pend de la plate-forme cible et la macro s'en chargera </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans d'autres shaders, pour √©chantillonner la texture du relief, nous avons besoin des coordonn√©es du monde XZ. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajouterons une position dans le monde √† la structure d'entr√©e du shader de surface. </font><font style="vertical-align: inherit;">Nous supprimons √©galement les coordonn√©es UV par d√©faut, car nous n'en avons pas besoin.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©chantillonner un tableau de textures, nous devons utiliser une macro </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour √©chantillonner un tableau, il a besoin de trois coordonn√©es. </font><font style="vertical-align: inherit;">Les deux premiers sont des coordonn√©es UV r√©guli√®res. </font><font style="vertical-align: inherit;">Nous utiliserons les coordonn√©es du monde XZ mises √† l'√©chelle √† 0,02. </font><font style="vertical-align: inherit;">Nous obtenons donc une bonne r√©solution de texture √† plein grossissement. </font><font style="vertical-align: inherit;">Les textures seront r√©p√©t√©es environ toutes les quatre cellules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La troisi√®me coordonn√©e est utilis√©e comme index du tableau de textures, comme dans un tableau r√©gulier. </font><font style="vertical-align: inherit;">Comme les coordonn√©es sont flottantes, avant d'indexer le tableau GPU les arrondit. </font><font style="vertical-align: inherit;">Puisque jusqu'√† ce que nous sachions quelle texture est n√©cessaire, utilisons toujours la premi√®re. </font><font style="vertical-align: inherit;">De plus, la couleur du sommet n'affectera pas le r√©sultat final, car il s'agit d'une carte splat.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout est devenu sable. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S√©lection de texture </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons besoin d'une carte de relief en relief qui m√©lange les trois types dans un triangle. </font><font style="vertical-align: inherit;">Nous avons une gamme de textures avec une texture pour chaque type de terrain. </font><font style="vertical-align: inherit;">Nous avons un shader qui √©chantillonne un tableau de textures. </font><font style="vertical-align: inherit;">Mais pour l'instant, nous n'avons aucun moyen de dire au shader quelles textures choisir pour chaque triangle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que chaque triangle m√©lange jusqu'√† trois types, nous devons associer trois indices √† chaque triangle. </font><font style="vertical-align: inherit;">Nous ne pouvons pas stocker d'informations pour les triangles, nous devons donc stocker des index pour les sommets. </font><font style="vertical-align: inherit;">Les trois sommets du triangle enregistreront simplement les m√™mes indices qu'avec la couleur unie.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Donn√©es de maillage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser l'un des ensembles du maillage UV pour stocker des indices. </font><font style="vertical-align: inherit;">√âtant donn√© que trois index sont stock√©s sur chaque sommet, les ensembles UV 2D existants ne seront pas suffisants. </font><font style="vertical-align: inherit;">Heureusement, les ensembles UV peuvent contenir jusqu'√† quatre coordonn√©es. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajoutons √† la </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deuxi√®me liste </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √† laquelle nous ferons r√©f√©rence en tant que types de relief.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activez les types de terrain pour l' </font><font style="vertical-align: inherit;">enfant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du pr√©fabriqu√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons des types de relief. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si n√©cessaire, nous prendrons une autre liste </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les types de relief lors du nettoyage de la maille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'application des donn√©es de maillage, nous enregistrons les types de relief dans le troisi√®me ensemble UV. </font><font style="vertical-align: inherit;">Pour cette raison, ils n'entreront pas en conflit avec deux autres ensembles, si jamais nous d√©cidons de les utiliser ensemble.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©finir les types de relief du triangle, nous utiliserons </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque ceux-ci sont les m√™mes pour tout le triangle, nous ajoutons simplement les m√™mes donn√©es trois fois.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mixage en quad fonctionne de la m√™me mani√®re. </font><font style="vertical-align: inherit;">Les quatre sommets sont du m√™me type.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ils Aiment Triangles of Ribs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons ajouter des types aux donn√©es de maillage dans </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Commen√ßons par </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, pour une meilleure lisibilit√©, nous s√©parerons les appels aux m√©thodes vertex et color. </font><font style="vertical-align: inherit;">Rappelons qu'√† chaque appel √† cette m√©thode, nous la lui transmettons </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, afin que nous puissions utiliser cette couleur directement, et non appliquer le param√®tre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s les couleurs, nous ajoutons des types de relief. </font><font style="vertical-align: inherit;">√âtant donn√© que les types dans le triangle peuvent √™tre diff√©rents, cela devrait √™tre un param√®tre qui remplace la couleur. </font><font style="vertical-align: inherit;">Utilisez ce type simple pour cr√©er </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seuls les quatre premiers canaux sont importants pour nous, car dans ce cas, la carte de r√©partition est toujours rouge. </font><font style="vertical-align: inherit;">√âtant donn√© que les trois composants du vecteur doivent √™tre attribu√©s, attribuons-leur un type.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons changer tous les appels √† cette m√©thode, en rempla√ßant l'argument couleur par un index du type de terrain de la cellule. </font><font style="vertical-align: inherit;">Nous allons effectuer ce changement dans </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, lorsque vous d√©marrez le mode Lecture, des erreurs appara√Ætront vous informant que les troisi√®mes ensembles de maillages UV sont hors limites. </font><font style="vertical-align: inherit;">Cela s'est produit parce que nous n'ajoutons pas encore de types de relief √† chaque triangle et quadruple. </font><font style="vertical-align: inherit;">Continuons donc √† changer </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rayures c√¥tel√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lors de la cr√©ation d'une bande de chant, nous devons savoir quels types de terrain se trouvent des deux c√¥t√©s. </font><font style="vertical-align: inherit;">Par cons√©quent, nous les ajoutons en tant que param√®tres, puis cr√©ons un vecteur de types dont les deux canaux sont affect√©s √† ces types. </font><font style="vertical-align: inherit;">Le troisi√®me canal n'est pas important, il suffit donc de l'√©galer au premier. </font><font style="vertical-align: inherit;">Apr√®s avoir ajout√© les couleurs, ajoutez les types au quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons changer les d√©fis </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit utiliser le type de cellule pour les deux c√¥t√©s de la bande de c√¥tes.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, le cas le plus simple d'une ar√™te </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit utiliser le type de cellule pour l'ar√™te la plus proche et le type voisin pour l'ar√™te √©loign√©e. </font><font style="vertical-align: inherit;">Ils peuvent √™tre identiques ou diff√©rents.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√™me chose s'applique √† </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce qui d√©clenche trois fois </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les types de corniches sont les m√™mes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Angles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cas le plus simple d'un angle est un simple triangle. </font><font style="vertical-align: inherit;">La cellule du bas transf√®re le premier type, celle de gauche la seconde et celle de droite le troisi√®me. </font><font style="vertical-align: inherit;">En les utilisant, cr√©ez un vecteur de types et ajoutez-le au triangle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons la m√™me approche dans </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seulement ici nous cr√©ons un groupe de quads.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du m√©lange des rebords et des falaises, nous devons utiliser </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Donnez-lui simplement un param√®tre de type vecteur et ajoutez-le √† tous ses triangles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr√©er un vecteur de types bas√© sur les cellules transf√©r√©es. </font><font style="vertical-align: inherit;">Ajoutez-le ensuite √† un triangle et passez </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il en va de m√™me </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivi√®res </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re m√©thode √† changer est la suivante </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque nous sommes ici au centre de la cellule, nous ne traitons que du type de cellule actuelle. </font><font style="vertical-align: inherit;">Par cons√©quent, cr√©ez-en un vecteur et ajoutez-le aux triangles et aux quadruples.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©lange de types </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, les mailles contiennent les indices d'√©l√©vation n√©cessaires. </font><font style="vertical-align: inherit;">Il ne nous reste plus qu'√† forcer le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† les </font><font style="vertical-align: inherit;">utiliser. </font><font style="vertical-align: inherit;">Pour que les indices tombent dans le shader de fragments, nous devons d'abord les faire passer dans le vertex shader. </font><font style="vertical-align: inherit;">Nous pouvons le faire dans notre propre fonction de sommet, comme nous l'avons fait dans le shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans ce cas, nous ajoutons un champ √† la structure d'entr√©e </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le copions dedans </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> ‚Ä¶ struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons √©chantillonner le tableau de texture trois fois par fragment. </font><font style="vertical-align: inherit;">Par cons√©quent, cr√©ons une fonction pratique pour cr√©er des coordonn√©es de texture, √©chantillonner un tableau et moduler un √©chantillon avec une carte splat pour un index.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pouvons-nous travailler avec un vecteur comme un tableau?</font></font></b> <div class="spoiler_text">  Oui   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En utilisant cette fonction, nous pouvons simplement √©chantillonner le tableau de texture trois fois et combiner les r√©sultats. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief textur√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons peindre le relief avec des textures. </font><font style="vertical-align: inherit;">Ils se m√©langent comme des couleurs unies. </font><font style="vertical-align: inherit;">Puisque nous utilisons les coordonn√©es du monde comme coordonn√©es UV, elles ne changent pas avec la hauteur. </font><font style="vertical-align: inherit;">En cons√©quence, le long des falaises ac√©r√©es, les textures sont √©tir√©es. </font><font style="vertical-align: inherit;">Si les textures sont assez neutres et tr√®s variables, les r√©sultats seront acceptables. </font><font style="vertical-align: inherit;">Sinon, nous obtenons de grosses vergetures laides. </font><font style="vertical-align: inherit;">Vous pouvez essayer de le masquer avec une g√©om√©trie ou une texture suppl√©mentaire des falaises, mais dans le tutoriel, nous ne le ferons pas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Balayer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque nous utilisons des textures au lieu de couleurs, il sera logique de changer le panneau de l'√©diteur. </font><font style="vertical-align: inherit;">Nous pouvons cr√©er une belle interface qui peut m√™me afficher des textures en relief, mais je me concentrerai sur les abr√©viations qui correspondent au style du sch√©ma existant.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options de secours. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© color n'est plus n√©cessaire, supprimez-la donc.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvez √©galement supprimer un tableau de couleurs et le code associ√©.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ ‚Ä¶ void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, un tableau de couleurs n'est √©galement pas n√©cessaire dans </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 15: distances </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichez les lignes de la grille. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basculez entre les modes d'√©dition et de navigation. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calculez la distance entre les cellules. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous trouvons des moyens de contourner les obstacles. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous prenons en compte les co√ªts variables de d√©m√©nagement. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir cr√©√© des cartes de haute qualit√©, nous commencerons la navigation. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le chemin le plus court n'est pas toujours rectiligne.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichage de la grille </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La navigation sur la carte s'effectue en se d√©pla√ßant de cellule en cellule. </font><font style="vertical-align: inherit;">Pour arriver quelque part, vous devez passer par une s√©rie de cellules. </font><font style="vertical-align: inherit;">Pour faciliter l'estimation des distances, ajoutons l'option d'afficher la grille hexagonale sur laquelle notre carte est bas√©e.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texture de maille </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgr√© les irr√©gularit√©s du maillage de la carte, le maillage sous-jacent est parfaitement plat. </font><font style="vertical-align: inherit;">Nous pouvons le montrer en projetant un motif de grille sur une carte. </font><font style="vertical-align: inherit;">Ceci peut √™tre r√©alis√© en utilisant une texture de maille r√©p√©t√©e.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture de maille r√©p√©t√©e. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La texture montr√©e ci-dessus contient une petite partie de la grille hexagonale couvrant 2 par 2 cellules. </font><font style="vertical-align: inherit;">Cette zone est rectangulaire et non carr√©e. </font><font style="vertical-align: inherit;">Comme la texture elle-m√™me est un carr√©, le motif semble √©tir√©. </font><font style="vertical-align: inherit;">Lors de l'√©chantillonnage, nous devons compenser cela.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projection de grille </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour projeter un motif de maillage, nous devons ajouter </font><font style="vertical-align: inherit;">une propri√©t√© de texture au </font><font style="vertical-align: inherit;">shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mat√©riau en relief avec texture en maille. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âchantillonnez la texture en utilisant les coordonn√©es XZ du monde, puis multipliez-la par l'alb√©do. </font><font style="vertical-align: inherit;">√âtant donn√© que les lignes de la grille sur la texture sont grises, cela entrelacera le motif dans le relief.</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alb√©do multipli√© par un maillage fin. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons mettre le mod√®le √† l'√©chelle afin qu'il corresponde aux cellules de la carte. </font><font style="vertical-align: inherit;">La distance entre les centres des cellules voisines est de 15, elle doit √™tre doubl√©e pour remonter de deux cellules. </font><font style="vertical-align: inherit;">Autrement dit, nous devons diviser les coordonn√©es de la grille V par 30. Le rayon int√©rieur des cellules est 5‚àö3, et pour d√©placer deux cellules vers la droite, nous avons besoin de quatre fois plus. </font><font style="vertical-align: inherit;">Par cons√©quent, il est n√©cessaire de diviser les coordonn√©es de la grille U par 20‚àö3.</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La taille de maille correcte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, les lignes de la grille correspondent aux cellules de la carte. </font><font style="vertical-align: inherit;">Comme les textures en relief, ils ignorent la hauteur, donc les lignes seront √©tir√©es le long des falaises.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projection sur cellules √† hauteur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La d√©formation du maillage n'est g√©n√©ralement pas si mauvaise, surtout lorsque vous regardez une carte √† longue distance.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maille au loin.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inclusion de grille </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que l'affichage d'une grille soit pratique, il n'est pas toujours n√©cessaire. </font><font style="vertical-align: inherit;">Par exemple, vous devez le d√©sactiver lorsque vous prenez une capture d'√©cran. </font><font style="vertical-align: inherit;">De plus, tout le monde ne pr√©f√®re pas voir la grille en permanence. </font><font style="vertical-align: inherit;">Rendons-le donc facultatif. </font><font style="vertical-align: inherit;">Nous allons ajouter la directive multi_compile au shader pour cr√©er des options avec et sans grille. </font><font style="vertical-align: inherit;">Pour ce faire, nous utiliserons le mot-cl√© </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La compilation des shaders conditionnels est d√©crite dans le didacticiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu 5, Lumi√®res multiples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la d√©claration d'une variable, nous lui </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribuons d'abord une valeur de 1. Par cons√©quent, la grille sera d√©sactiv√©e. </font><font style="vertical-align: inherit;">Ensuite, nous √©chantillonnerons la texture de la grille uniquement pour la variante avec un mot cl√© sp√©cifique </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme le mot-cl√© n'est </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas inclus dans le shader de terrain, la grille dispara√Ætra. </font><font style="vertical-align: inherit;">Pour le r√©activer, nous allons ajouter un commutateur √† l'interface utilisateur de l'√©diteur de carte. </font><font style="vertical-align: inherit;">Pour rendre cela possible, je </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois obtenir un lien vers le mat√©riau du </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et une m√©thode pour activer ou d√©sactiver le mot-cl√© </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editeur March hexagones en r√©f√©rence au mat√©riau. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un commutateur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† l'interface utilisateur </font><font style="vertical-align: inherit;">et connectez-le √† la m√©thode </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interrupteur de r√©seau.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrer l'√©tat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant en mode Play, nous pouvons changer l'affichage de la grille. </font><font style="vertical-align: inherit;">Lors du premier test, la grille est initialement d√©sactiv√©e et devient visible lorsque nous allumons l'interrupteur. </font><font style="vertical-align: inherit;">Lorsque vous le d√©sactivez, la grille dispara√Ætra √† nouveau. </font><font style="vertical-align: inherit;">Cependant, si nous quittons le mode Play lorsque la grille est visible, la prochaine fois que vous lancerez le mode Play, il sera r√©activ√©, bien que le commutateur soit d√©sactiv√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet, nous modifions le mot-cl√© pour le mat√©riau </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> g√©n√©ral </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous modifions l'actif mat√©riel, la modification est donc enregistr√©e dans l'√©diteur Unity. </font><font style="vertical-align: inherit;">Il ne sera pas enregistr√© dans l'assemblage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour toujours d√©marrer le jeu sans grille, nous d√©sactiverons le mot-cl√© </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans Awake </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mode √©dition </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous voulons contr√¥ler le mouvement sur la carte, nous devons interagir avec elle. </font><font style="vertical-align: inherit;">Au minimum, nous devons s√©lectionner la cellule comme point de d√©part du chemin. </font><font style="vertical-align: inherit;">Mais lorsque vous cliquez sur une cellule, elle sera modifi√©e. </font><font style="vertical-align: inherit;">Nous pouvons d√©sactiver toutes les options d'√©dition manuellement, mais cela n'est pas pratique. </font><font style="vertical-align: inherit;">De plus, nous ne voulons pas que les calculs de d√©placement soient effectu√©s pendant l'√©dition de la carte. </font><font style="vertical-align: inherit;">Ajoutons donc un commutateur qui d√©termine si nous sommes en mode √©dition.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifier le commutateur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ bool√©en </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ainsi qu'√† la m√©thode qui le d√©finit. </font><font style="vertical-align: inherit;">Ajoutez ensuite un autre commutateur √† l'interface utilisateur pour le contr√¥ler. </font><font style="vertical-align: inherit;">Commen√ßons par le mode de navigation, c'est-√†-dire que le mode d'√©dition sera d√©sactiv√© par d√©faut.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commutateur de mode d'√©dition. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©sactiver l' </font><font style="vertical-align: inherit;">√©dition en </font><font style="vertical-align: inherit;">fait, faire un appel </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©pendant </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtiquettes de d√©bogage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous n'avons pas d'unit√©s pour se d√©placer sur la carte. </font><font style="vertical-align: inherit;">Au lieu de cela, nous visualisons les distances de mouvement. </font><font style="vertical-align: inherit;">Pour ce faire, vous pouvez utiliser des √©tiquettes de cellule existantes. </font><font style="vertical-align: inherit;">Par cons√©quent, nous les rendrons visibles lorsque le mode d'√©dition est d√©sactiv√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous commen√ßons par le mode de navigation, les √©tiquettes par d√©faut doivent √™tre activ√©es. </font><font style="vertical-align: inherit;">Actuellement </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il les d√©sactive, mais il ne devrait plus le faire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtiquettes de coordonn√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les coordonn√©es des cellules deviennent d√©sormais visibles imm√©diatement apr√®s le lancement du mode Lecture. </font><font style="vertical-align: inherit;">Mais nous n'avons pas besoin de coordonn√©es, nous utilisons des √©tiquettes pour afficher les distances. </font><font style="vertical-align: inherit;">Comme cela ne n√©cessite qu'un seul num√©ro par cellule, vous pouvez augmenter la taille de la police pour une meilleure lecture. </font><font style="vertical-align: inherit;">Modifiez le pr√©fabriqu√© de l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©tiquette de cellule hexad√©cimale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'il utilise une police en gras de taille 8.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balises avec une taille de police en gras 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, apr√®s avoir lanc√© le mode Lecture, nous verrons de grandes balises. </font><font style="vertical-align: inherit;">Seules les premi√®res coordonn√©es de la cellule sont visibles, les autres ne sont pas plac√©es dans l'√©tiquette.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grands tags. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous n'avons plus besoin des coordonn√©es, nous supprimerons la </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font><font style="vertical-align: inherit;">dans l' </font><font style="vertical-align: inherit;">affectation </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez √©galement supprimer le commutateur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Labels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et sa m√©thode associ√©e </font><font style="vertical-align: inherit;">de l'interface utilisateur </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le changement de m√©thode n'est plus. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trouver des distances </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons le mode de navigation balis√©, nous pouvons commencer √† afficher les distances. </font><font style="vertical-align: inherit;">Nous allons s√©lectionner une cellule, puis afficher la distance de cette cellule √† toutes les cellules de la carte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichage de la distance </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour suivre la distance √† la cellule, ajoutez au </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ entier </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il indiquera la distance entre cette cellule et celle s√©lectionn√©e. </font><font style="vertical-align: inherit;">Par cons√©quent, pour la cellule s√©lectionn√©e elle-m√™me, elle sera nulle, pour le voisin imm√©diat, elle est 1, et ainsi de suite.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la distance est d√©finie, nous devons mettre √† jour le libell√© de la cellule pour afficher sa valeur. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a une r√©f√©rence √† l' </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objet UI. </font><font style="vertical-align: inherit;">Nous devrons l'appeler </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour se rendre √† la cellule. </font><font style="vertical-align: inherit;">Consid√©rez ce qui se </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouve dans l'espace de noms </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilisez-le donc au d√©but du script.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne devrions-nous pas garder un lien direct vers le composant Texte?</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©finissons la propri√©t√© g√©n√©rale pour recevoir et d√©finir la distance √† la cellule, ainsi que mettre √† jour son √©tiquette. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez √† la </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode g√©n√©rale </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec le param√®tre de cellule. </font><font style="vertical-align: inherit;">Pour l'instant, nous allons simplement d√©finir la distance z√©ro pour chaque cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le mode d'√©dition n'est pas activ√©, nous </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelons une nouvelle m√©thode avec la cellule actuelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Distances entre coordonn√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant en mode navigation, apr√®s avoir touch√© l'un d'eux, toutes les cellules affichent z√©ro. </font><font style="vertical-align: inherit;">Mais, bien s√ªr, ils devraient afficher la vraie distance de la cellule. </font><font style="vertical-align: inherit;">Pour calculer leur distance, nous pouvons utiliser les coordonn√©es de la cellule. </font><font style="vertical-align: inherit;">Par cons√©quent, supposons qu'il </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">poss√®de une m√©thode </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utilisez-la dans </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, ajoutez √† la </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il doit comparer ses propres coordonn√©es avec les coordonn√©es d'un autre ensemble. </font><font style="vertical-align: inherit;">Commen√ßons seulement par mesurer X, et nous soustraireons les coordonn√©es X les unes des autres.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence, nous obtenons un d√©calage le long de X par rapport √† la cellule s√©lectionn√©e. </font><font style="vertical-align: inherit;">Mais les distances ne peuvent pas √™tre n√©gatives, vous devez donc renvoyer la diff√©rence de coordonn√©es X modulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances le long de X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous obtenons donc les distances correctes uniquement si nous ne prenons en compte qu'une seule dimension. </font><font style="vertical-align: inherit;">Mais il y a trois dimensions dans une grille d'hexagones. </font><font style="vertical-align: inherit;">Alors additionnons les distances pour les trois dimensions et voyons ce que cela nous donne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somme des distances XYZ. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'av√®re que nous obtenons deux fois la distance. </font><font style="vertical-align: inherit;">Autrement dit, pour obtenir la distance correcte, ce montant doit √™tre divis√© en deux.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances r√©elles.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la somme est-elle √©gale au double de la distance?</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, ‚àí3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Travailler avec des obstacles </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les distances que nous calculons correspondent aux plus courts trajets de la cellule s√©lectionn√©e √† l'autre cellule. </font><font style="vertical-align: inherit;">Nous ne pouvons pas trouver un moyen plus court. </font><font style="vertical-align: inherit;">Mais ces chemins sont garantis pour √™tre corrects si l'itin√©raire ne bloque rien. </font><font style="vertical-align: inherit;">Les falaises, l'eau et d'autres obstacles peuvent nous faire faire le tour. </font><font style="vertical-align: inherit;">Peut-√™tre que certaines cellules ne peuvent pas √™tre atteintes du tout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trouver un moyen de contourner les obstacles, nous devons utiliser une approche diff√©rente au lieu de simplement calculer la distance entre les coordonn√©es. </font><font style="vertical-align: inherit;">Nous ne pouvons plus examiner chaque cellule individuellement. </font><font style="vertical-align: inherit;">Nous devrons rechercher la carte jusqu'√† ce que nous trouvions toutes les cellules accessibles.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisation de la recherche </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La recherche cartographique est un processus it√©ratif. </font><font style="vertical-align: inherit;">Pour comprendre ce que nous faisons, il serait utile de voir chaque √©tape de la recherche. </font><font style="vertical-align: inherit;">Nous pouvons le faire en transformant l'algorithme de recherche en coroutine, pour lequel nous avons besoin d'un espace de recherche </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le taux de rafra√Æchissement de 60 it√©rations par seconde est suffisamment petit pour que nous puissions voir ce qui se passe, et la recherche sur une petite carte n'a pas pris trop de temps.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons nous assurer qu'une seule recherche est active √† un moment donn√©. </font><font style="vertical-align: inherit;">Par cons√©quent, avant de commencer une nouvelle recherche, nous arr√™tons toutes les coroutines.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De plus, nous devons terminer la recherche lors du chargement d'une nouvelle carte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recherche en largeur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant m√™me de commencer la recherche, nous savons que la distance jusqu'√† la cellule s√©lectionn√©e est nulle. Et, bien s√ªr, la distance √† tous ses voisins est de 1, s'ils peuvent √™tre atteints. Ensuite, nous pouvons jeter un oeil √† l'un de ces voisins. Cette cellule a tr√®s probablement ses propres voisins accessibles et pour lesquels la distance n'a pas encore √©t√© calcul√©e. Si c'est le cas, alors la distance √† ces voisins devrait √™tre de 2. Nous pouvons r√©p√©ter ce processus pour tous les voisins √† une distance de 1. Apr√®s cela, nous le r√©p√©tons pour tous les voisins √† une distance de 2. Et ainsi de suite, jusqu'√† ce que nous atteignions toutes les cellules.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, nous trouvons d'abord toutes les cellules √† une distance de 1, puis nous trouvons tout √† une distance de 2, puis √† une distance de 3, et ainsi de suite, jusqu'√† ce que nous ayons termin√©. </font><font style="vertical-align: inherit;">Cela garantit que nous trouvons la plus petite distance √† chaque cellule accessible. </font><font style="vertical-align: inherit;">Cet algorithme est appel√© recherche en largeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que cela fonctionne, nous devons savoir si nous avons d√©j√† d√©termin√© la distance √† la cellule. </font><font style="vertical-align: inherit;">Souvent, pour cela, les cellules sont plac√©es dans une collection appel√©e ensemble pr√™t √† l'emploi ou ferm√©. </font><font style="vertical-align: inherit;">Mais nous pouvons d√©finir la distance jusqu'√† la cellule </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour indiquer que nous ne l'avons pas encore visit√©e. </font><font style="vertical-align: inherit;">Nous devons le faire pour toutes les cellules juste avant d'effectuer une recherche.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez √©galement l'utiliser pour masquer toutes les cellules non visit√©es en les modifiant </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apr√®s cela, nous commencerons chaque recherche sur une carte vierge.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons suivre les cellules qui doivent √™tre visit√©es et l'ordre dans lequel elles sont visit√©es. </font><font style="vertical-align: inherit;">Une telle collection est souvent appel√©e une bordure ou un ensemble ouvert. </font><font style="vertical-align: inherit;">Nous avons juste besoin de traiter les cellules dans le m√™me ordre dans lequel nous les avons rencontr√©es. </font><font style="vertical-align: inherit;">Pour ce faire, vous pouvez utiliser la file d'attente </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui fait partie de l'espace de noms </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La cellule s√©lectionn√©e sera la premi√®re √† √™tre plac√©e dans cette file d'attente et aura une distance de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir de ce moment, l'algorithme ex√©cute la boucle pendant qu'il y a quelque chose dans la file d'attente. </font><font style="vertical-align: inherit;">√Ä chaque it√©ration, la cellule la plus en avant est r√©cup√©r√©e de la file d'attente.</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant la cellule actuelle, qui peut √™tre √† n'importe quelle distance. </font><font style="vertical-align: inherit;">Ensuite, nous devons ajouter tous ses voisins √† la file d'attente un peu plus loin de la cellule s√©lectionn√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais nous ne devons ajouter que les cellules qui n'ont pas encore re√ßu de distance. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche large.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âvitez l'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir v√©rifi√© que la recherche en largeur d'abord trouve les bonnes distances sur la carte monotone, nous pouvons commencer √† ajouter des obstacles. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en refusant d'ajouter des cellules √† la file d'attente si certaines conditions sont remplies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, nous sautons d√©j√† certaines cellules: celles qui n'existent pas et celles auxquelles nous avons d√©j√† indiqu√© la distance. </font><font style="vertical-align: inherit;">R√©√©crivons le code afin que dans ce cas, nous ignorions explicitement les voisins.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sautons √©galement toutes les cellules qui sont sous l'eau. </font><font style="vertical-align: inherit;">Cela signifie que lors de la recherche des distances les plus courtes, nous ne consid√©rons que le mouvement au sol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances sans se d√©placer dans l'eau. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme trouve toujours les distances les plus courtes, mais √©vite d√©sormais toute eau. </font><font style="vertical-align: inherit;">Par cons√©quent, les cellules sous-marines ne prennent jamais de distance, comme les zones de terre isol√©es. </font><font style="vertical-align: inherit;">La cellule sous-marine ne re√ßoit la distance que si elle est s√©lectionn√©e.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âvitez les falaises </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, pour d√©terminer la possibilit√© de visiter un voisin, nous pouvons utiliser le type de c√¥te. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez faire en sorte que les falaises bloquent le chemin. </font><font style="vertical-align: inherit;">Si vous autorisez le mouvement sur les pentes, les cellules de l'autre c√¥t√© de la falaise peuvent toujours √™tre atteintes, uniquement sur d'autres chemins. </font><font style="vertical-align: inherit;">Par cons√©quent, ils peuvent √™tre √† des distances tr√®s diff√©rentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances sans traverser les falaises. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frais de voyage </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons √©viter les cellules et les bords, mais ces options sont binaires. </font><font style="vertical-align: inherit;">On peut imaginer qu‚Äôil est plus facile de naviguer dans certaines directions que dans d‚Äôautres. </font><font style="vertical-align: inherit;">Dans ce cas, la distance est mesur√©e en travail ou en temps.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routes rapides </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il sera logique qu'il soit plus facile et plus rapide de se d√©placer sur les routes, alors rendons moins co√ªteuse l'intersection des bords avec les routes. </font><font style="vertical-align: inherit;">Puisque nous utilisons des valeurs enti√®res pour d√©finir la distance de d√©placement, nous laisserons le co√ªt du d√©placement le long des routes √©gal √† 1, et le co√ªt du franchissement d'autres bords, nous augmenterons √† 10. C'est une grande diff√©rence qui nous permet de voir imm√©diatement si nous obtenons les bons r√©sultats.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avec de mauvaises distances.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tri par bordure </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, il s'av√®re que la recherche en priorit√© ne peut pas fonctionner avec des frais de d√©m√©nagement variables. </font><font style="vertical-align: inherit;">Il suppose que les cellules sont ajout√©es √† la fronti√®re dans l'ordre croissant de distance, et pour nous, ce n'est plus pertinent. </font><font style="vertical-align: inherit;">Nous avons besoin d'une file d'attente prioritaire, c'est-√†-dire d'une file d'attente qui se trie d'elle-m√™me. </font><font style="vertical-align: inherit;">Il n'y a pas de files d'attente prioritaires standard, car vous ne pouvez pas les programmer de telle mani√®re qu'elles conviennent √† toutes les situations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons cr√©er notre propre file d'attente prioritaire, mais optimisons-la pour le futur tutoriel. </font><font style="vertical-align: inherit;">Pour l'instant, nous rempla√ßons simplement la file d'attente par une liste qui aura une m√©thode </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne peux pas utiliser ListPool &lt;HexCell&gt;?</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que la bordure soit correcte, nous devons la trier apr√®s y avoir ajout√© une cellule. </font><font style="vertical-align: inherit;">En fait, nous pouvons reporter le tri jusqu'√† ce que tous les voisins de la cellule soient ajout√©s, mais, je le r√©p√®te, jusqu'√† ce que les optimisations ne nous int√©ressent pas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous voulons trier les cellules par distance. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons appeler la m√©thode de tri de liste avec un lien vers la m√©thode qui effectue cette comparaison.</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne cette m√©thode de tri?</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bordure tri√©e est toujours incorrecte.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mise √† jour de la fronti√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir commenc√© √† trier la fronti√®re, nous avons commenc√© √† obtenir de meilleurs r√©sultats, mais il y a encore des erreurs. En effet, lorsqu'une cellule est ajout√©e √† la bordure, nous ne trouvons pas n√©cessairement la distance la plus courte √† cette cellule. Cela signifie que maintenant nous ne pouvons plus ignorer les voisins qui ont d√©j√† re√ßu une distance. Au lieu de cela, nous devons v√©rifier si nous avons trouv√© un chemin plus court. Si c'est le cas, nous devons modifier la distance par rapport au voisin, au lieu de l'ajouter √† la fronti√®re.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les bonnes distances. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons les bonnes distances, nous allons commencer √† consid√©rer les co√ªts de d√©placement. </font><font style="vertical-align: inherit;">Vous pouvez remarquer que les distances √† certaines cellules sont initialement trop grandes, mais sont corrig√©es lorsqu'elles sont retir√©es de la fronti√®re. </font><font style="vertical-align: inherit;">Cette approche est appel√©e l'algorithme de Dijkstra, elle doit son nom au premier invent√© par Edsger Dijkstra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pistes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne voulons pas nous limiter √† des co√ªts diff√©rents uniquement pour les routes. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez r√©duire le co√ªt du franchissement des bords plats sans routes √† 5, en laissant les pentes sans routes une valeur de 10.</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour surmonter les pentes, vous devez faire plus de travail et les routes sont toujours rapides.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objets en relief </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons ajouter des co√ªts en pr√©sence d'objets de secours. </font><font style="vertical-align: inherit;">Par exemple, dans de nombreux jeux, il est plus difficile de naviguer dans les for√™ts. </font><font style="vertical-align: inherit;">Dans ce cas, nous ajoutons simplement tous les niveaux d'objets √† la distance. </font><font style="vertical-align: inherit;">Et l√† encore la route acc√©l√®re tout.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets ralentissent s'il n'y a pas de route.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les murs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, prenons en compte les murs. </font><font style="vertical-align: inherit;">Les murs doivent bloquer le mouvement si la route ne les traverse pas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les murs ne nous laissent pas passer, il faut chercher la porte. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425919/">https://habr.com/ru/post/fr425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425905/index.html">Comment √©crire du code assembleur avec des instructions qui se chevauchent (une autre technique pour masquer le bytecode)</a></li>
<li><a href="../fr425907/index.html">Nous faisons un projet d'apprentissage automatique en Python. 2e partie</a></li>
<li><a href="../fr425911/index.html">Transf√©rer le cloud CRM vers la version en bo√Æte</a></li>
<li><a href="../fr425915/index.html">Comment les communications transfrontali√®res peuvent remplacer les feux de circulation et raccourcir le chemin du travail</a></li>
<li><a href="../fr425917/index.html">Un combattant de la justice emp√™che Waymo de breveter une technologie lidar cl√©</a></li>
<li><a href="../fr425921/index.html">R√©union de la communaut√© .NET sur CLRium # 4 + en ligne</a></li>
<li><a href="../fr425923/index.html">Doom de 25 ans</a></li>
<li><a href="../fr425925/index.html">Impression 3D dans la cr√©ation de mises en page sur l'exemple du STUDIO 911</a></li>
<li><a href="../fr425927/index.html">Station m√©t√©o sur Arduino de A √† Z. Partie 2</a></li>
<li><a href="../fr425929/index.html">Google a abandonn√© la lutte pour le milliardi√®me contrat avec le Pentagone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>