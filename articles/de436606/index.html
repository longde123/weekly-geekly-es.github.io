<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèΩ üç† ü§∂üèª Wir schreiben ein Betriebssystem auf Rust. Seitenorganisation des Ged√§chtnisses üÜî üö§ ‚òéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel stellen wir Seiten vor , ein sehr verbreitetes Speicherverwaltungsschema, das wir auch in unserem Betriebssystem anwenden. Der Artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben ein Betriebssystem auf Rust. Seitenorganisation des Ged√§chtnisses</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436606/">  In diesem Artikel stellen wir <i>Seiten vor</i> , ein sehr verbreitetes Speicherverwaltungsschema, das wir auch in unserem Betriebssystem anwenden.  Der Artikel erkl√§rt, warum Speicherisolation erforderlich ist, wie <i>Segmentierung</i> funktioniert, was <i>virtueller Speicher ist</i> und wie Seiten das Fragmentierungsproblem l√∂sen.  Wir untersuchen auch das Schema von mehrstufigen Seitentabellen in der x86_64-Architektur. <br><br>  Dieser Blog ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ver√∂ffentlicht</a> .  Wenn Sie Fragen oder Probleme haben, √∂ffnen Sie dort die entsprechende Anfrage. <br><a name="habracut"></a><br><h1>  Speicherschutz </h1><br>  Eine der Hauptaufgaben des Betriebssystems besteht darin, Programme voneinander zu isolieren.  Beispielsweise sollte ein Browser einen Texteditor nicht st√∂ren.  Abh√§ngig von der Hardware- und Betriebssystemimplementierung gibt es verschiedene Ans√§tze. <br><br>  Beispielsweise verf√ºgen einige ARM Cortex-M-Prozessoren (in eingebetteten Systemen) √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>eine Speicherschutzeinheit</i></a> (MPU), die eine kleine Anzahl (z. B. 8) von Speicherbereichen mit unterschiedlichen Zugriffsberechtigungen definiert (z. B. kein Zugriff, schreibgesch√ºtzt, lesbar und) Aufzeichnungen).  Bei jedem Zugriff auf den Speicher stellt die MPU sicher, dass sich die Adresse in dem Bereich mit den richtigen Berechtigungen befindet. Andernfalls wird eine Ausnahme ausgel√∂st.  Durch √Ñndern des Bereichs und der Zugriffsberechtigungen stellt das Betriebssystem sicher, dass jeder Prozess nur auf seinen Speicher zugreifen kann, um die Prozesse voneinander zu isolieren. <br><br>  Unter x86 werden zwei verschiedene Ans√§tze zum Schutz des Speichers unterst√ºtzt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Segmentierung</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paging</a> . <br><br><h1>  Segmentierung </h1><br>  Die Segmentierung wurde bereits 1978 implementiert, um zun√§chst den adressierbaren Speicher zu erh√∂hen.  Zu diesem Zeitpunkt unterst√ºtzte die CPU nur 16-Bit-Adressen, wodurch die Menge des adressierbaren Speichers auf 64 KB begrenzt wurde.  Um dieses Volumen zu erh√∂hen, wurden zus√§tzliche Segmentregister eingef√ºhrt, von denen jedes eine Versatzadresse enth√§lt.  Die CPU f√ºgt diesen Offset bei jedem Speicherzugriff automatisch hinzu und adressiert so bis zu 1 MB Speicher. <br><br>  Die CPU w√§hlt abh√§ngig von der Art des Speicherzugriffs automatisch ein Segmentregister aus: Das <code>CS</code> -Codesegmentregister wird zum Empfangen von Anweisungen verwendet, und das <code>SS</code> Stapelsegmentregister wird f√ºr Stapeloperationen (Push / Pop) verwendet.  Andere Anweisungen verwenden das <code>DS</code> -Datensegmentregister oder das optionale <code>ES</code> Segmentregister.  Sp√§ter wurden zwei zus√§tzliche Segmentregister <code>FS</code> und <code>GS</code> zur freien Verwendung hinzugef√ºgt. <br><br>  In der ersten Version der Segmentierung enthielten die Register direkt den Offset, und die Zugriffskontrolle wurde nicht durchgef√ºhrt.  Mit dem Aufkommen des <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesch√ºtzten Modus hat sich der</a></i> Mechanismus ge√§ndert.  Wenn die CPU in diesem Modus arbeitet, speichern die Segmentdeskriptoren den Index in einer lokalen oder globalen Deskriptortabelle, die zus√§tzlich zur Offsetadresse die Segmentgr√∂√üe und die Zugriffsberechtigungen enth√§lt.  Durch Laden separater globaler / lokaler Deskriptortabellen f√ºr jeden Prozess kann das Betriebssystem Prozesse voneinander isolieren. <br><br>  Durch √Ñndern der Speicheradressen vor dem eigentlichen Zugriff implementierte die Segmentierung eine Methode, die heute fast √ºberall verwendet wird: Es handelt sich um <i>virtuellen Speicher</i> . <br><br><h3>  Virtueller Speicher </h3><br>  Die Idee des virtuellen Speichers besteht darin, Speicheradressen von einem physischen Ger√§t zu abstrahieren.  Anstatt direkt auf das Speicherger√§t zuzugreifen, wird zuerst ein Konvertierungsschritt ausgef√ºhrt.  Bei der Segmentierung wird die Versatzadresse des aktiven Segments in der √úbersetzungsphase hinzugef√ºgt.  Stellen Sie sich ein Programm vor, das in einem Segment mit einem Offset von <code>0x1111000</code> auf die Speicheradresse <code>0x1234000</code> <code>0x1111000</code> : In Wirklichkeit geht die Adresse an <code>0x2345000</code> . <br><br>  Um zwischen zwei Arten von Adressen zu unterscheiden, werden Adressen vor der Konvertierung als <i>virtuell</i> und Adressen nach der Konvertierung als <i>physisch bezeichnet</i> .  Es gibt einen wichtigen Unterschied zwischen ihnen: Physische Adressen sind eindeutig und beziehen sich immer auf denselben eindeutigen Speicherort im Speicher.  Virtuelle Adressen h√§ngen dagegen von der √úbersetzungsfunktion ab.  Zwei verschiedene virtuelle Adressen k√∂nnen sich durchaus auf dieselbe physische Adresse beziehen.  Dar√ºber hinaus k√∂nnen identische virtuelle Adressen nach der Konvertierung auf unterschiedliche physische Adressen verweisen. <br><br>  Ein Beispiel f√ºr die n√ºtzliche Verwendung dieser Eigenschaft ist der parallele Start desselben Programms zweimal: <br><br><img src="https://habrastorage.org/webt/qm/zz/nz/qmzznz4rei5d-xxygzcabu2latw.png"><br><br>  Hier wird dasselbe Programm zweimal ausgef√ºhrt, jedoch mit unterschiedlichen Konvertierungsfunktionen.  Die erste Instanz hat einen Segmentversatz von 100, sodass ihre virtuellen Adressen 0-150 in physische Adressen 100-250 konvertiert werden.  Die zweite Instanz hat einen Offset von 300, wodurch die virtuellen Adressen 0-150 in physische Adressen 300-450 √ºbersetzt werden.  Dadurch k√∂nnen beide Programme denselben Code ausf√ºhren und dieselben virtuellen Adressen verwenden, ohne sich gegenseitig zu st√∂ren. <br><br>  Ein weiterer Vorteil ist, dass Programme jetzt an beliebigen Stellen im physischen Speicher abgelegt werden k√∂nnen.  Somit nutzt das Betriebssystem die gesamte verf√ºgbare Speichermenge, ohne dass Programme neu kompiliert werden m√ºssen. <br><br><h3>  Fragmentierung </h3><br>  Der Unterschied zwischen virtuellen und physischen Adressen ist eine echte Errungenschaft der Segmentierung.  Aber es gibt ein Problem.  Stellen Sie sich vor, wir m√∂chten die dritte Kopie des oben gezeigten Programms ausf√ºhren: <br><br><img src="https://habrastorage.org/webt/rr/np/1m/rrnp1m95lefyki9vwhnwe4uocom.png"><br><br>  Obwohl im physischen Speicher mehr als genug Speicherplatz vorhanden ist, passt die dritte Kopie nirgendwo hin.  Das Problem ist, dass er ein <i>kontinuierliches</i> Fragment des Speichers ben√∂tigt und wir keine separaten freien Abschnitte verwenden k√∂nnen. <br><br>  Eine M√∂glichkeit, die Fragmentierung zu bek√§mpfen, besteht darin, die Programmausf√ºhrung anzuhalten, verwendete Speicherteile n√§her aneinander zu verschieben, die Konvertierung zu aktualisieren und dann die Ausf√ºhrung fortzusetzen: <br><br><img src="https://habrastorage.org/webt/hd/rm/zo/hdrmzooae2xt4huangnbzebq3o0.png"><br><br>  Jetzt ist gen√ºgend Platz vorhanden, um die dritte Instanz zu starten. <br><br>  Der Nachteil dieser Defragmentierung ist die Notwendigkeit, gro√üe Speichermengen zu kopieren, was die Leistung verringert.  Dieser Vorgang muss regelm√§√üig durchgef√ºhrt werden, bis der Speicher zu fragmentiert ist.  Die Leistung wird unvorhersehbar, Programme werden jederzeit gestoppt und reagieren m√∂glicherweise nicht mehr. <br><br>  Die Fragmentierung ist einer der Gr√ºnde, warum die Segmentierung in den meisten Systemen nicht verwendet wird.  Tats√§chlich wird es auch im 64-Bit-Modus unter x86 nicht mehr unterst√ºtzt.  Anstelle der Segmentierung werden Seiten verwendet, die das Problem der Fragmentierung vollst√§ndig beseitigen. <br><br><h1>  Seitenorganisation des Ged√§chtnisses </h1><br>  Die Idee ist, den Raum des virtuellen und physischen Speichers in kleine Bl√∂cke fester Gr√∂√üe zu unterteilen.  Virtuelle Speicherbl√∂cke werden als Seiten bezeichnet, und physische Adressraumbl√∂cke werden als Frames bezeichnet.  Jede Seite wird einzeln einem Frame zugeordnet, sodass Sie gro√üe Speicherbereiche auf nicht benachbarte physische Frames aufteilen k√∂nnen. <br><br>  Der Vorteil wird offensichtlich, wenn Sie das Beispiel mit einem fragmentierten Speicherplatz wiederholen, diesmal jedoch Seiten anstelle der Segmentierung verwenden: <br><br><img src="https://habrastorage.org/webt/29/rg/95/29rg95blzryjql4qjy_txkbx2uo.png"><br><br>  In diesem Beispiel betr√§gt die Seitengr√∂√üe 50 Byte, dh jeder der Speicherbereiche ist in drei Seiten unterteilt.  Jede Seite wird einem separaten Frame zugeordnet, sodass ein zusammenh√§ngender Bereich des virtuellen Speichers isolierten physischen Frames zugeordnet werden kann.  Auf diese Weise k√∂nnen Sie die dritte Instanz des Programms ohne Defragmentierung ausf√ºhren. <br><br><h3>  Versteckte Fragmentierung </h3><br>  Im Vergleich zur Segmentierung verwendet eine Paging-Organisation viele kleine Speicherbereiche mit fester Gr√∂√üe anstelle mehrerer gro√üer Bereiche mit variabler Gr√∂√üe.  Jeder Frame hat die gleiche Gr√∂√üe, sodass eine Fragmentierung aufgrund zu kleiner Frames nicht m√∂glich ist. <br><br>  Dies ist aber nur eine <i>Erscheinung</i> .  Tats√§chlich gibt es eine versteckte Form der Fragmentierung, die sogenannte <i>interne Fragmentierung</i> , da nicht jeder Speicherbereich genau ein Vielfaches der Seitengr√∂√üe betr√§gt.  Stellen Sie sich im obigen Beispiel ein Programm der Gr√∂√üe 101 vor: Es werden noch drei Seiten der Gr√∂√üe 50 ben√∂tigt, sodass 49 Bytes mehr ben√∂tigt werden, als Sie ben√∂tigen.  Aus Gr√ºnden der Klarheit wird die Fragmentierung aufgrund der Segmentierung als <i>externe Fragmentierung bezeichnet</i> . <br><br>  Es gibt nichts Gutes in der internen Fragmentierung, aber oft ist es ein geringeres √úbel als die externe Fragmentierung.  Zus√§tzlicher Speicher wird immer noch verbraucht, aber jetzt m√ºssen Sie ihn nicht mehr defragmentieren, und das Fragmentierungsvolumen ist vorhersehbar (durchschnittlich eine halbe Seite pro Speicherbereich). <br><br><h3>  Seitentabellen </h3><br>  Wir haben gesehen, dass jede der Millionen m√∂glichen Seiten einzeln einem Frame zugeordnet ist.  Diese Adress√ºbersetzungsinformationen m√ºssen irgendwo gespeichert werden.  Bei der Segmentierung werden f√ºr jeden aktiven Speicherbereich separate Segmentregister verwendet, was bei Seiten nicht m√∂glich ist, da es viel mehr als Register gibt.  Stattdessen wird eine Struktur verwendet, die als <i>Seitentabelle bezeichnet wird</i> . <br><br>  F√ºr das obige Beispiel sehen die Tabellen folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/ij/g0/93/ijg093nmmxzlvn8fkj3n2fxvujg.png"><br><br>  Wie Sie sehen k√∂nnen, hat jede Instanz des Programms eine eigene Seitentabelle.  Ein Zeiger auf die aktuell aktive Tabelle wird in einem speziellen Register der CPU gespeichert.  Auf <code>x86</code> es <code>CR3</code> .  Vor dem Starten jeder Instanz des Programms muss das Betriebssystem dort einen Zeiger auf die richtige Seitentabelle laden. <br><br>  Bei jedem Zugriff auf den Speicher liest die CPU den Tabellenzeiger aus dem Register und sucht nach dem entsprechenden Rahmen in der Tabelle.  Dies ist eine vollst√§ndig Hardwarefunktion, die f√ºr ein laufendes Programm vollst√§ndig transparent ausgef√ºhrt wird.  Um den Prozess zu beschleunigen, verf√ºgen viele Prozessorarchitekturen √ºber einen speziellen Cache, der die Ergebnisse der letzten Konvertierungen speichert. <br><br>  Abh√§ngig von der Architektur k√∂nnen Attribute wie Berechtigungen auch im Flag-Feld der Seitentabelle gespeichert werden.  Im obigen Beispiel macht das <code>r/w</code> Flag die Seite lesbar und beschreibbar. <br><br><h3>  √úberlagerte Seitentabellen </h3><br>  Einfache Seitentabellen haben ein Problem mit gro√üen Adressr√§umen: Speicher wird verschwendet.  Das Programm verwendet beispielsweise vier virtuelle Seiten <code>0</code> , <code>1_000_000</code> , <code>1_000_050</code> und <code>1_000_100</code> (wir verwenden <code>_</code> als Trennzeichen): <br><br><img src="https://habrastorage.org/webt/oh/hc/2d/ohhc2dbnzmw-3qfq1bjmjsksydg.png"><br><br>  Es sind nur vier physische Frames erforderlich, aber die Seitentabelle enth√§lt mehr als eine Million Datens√§tze.  Leere Datens√§tze k√∂nnen nicht √ºbersprungen werden, da die CPU w√§hrend des Konvertierungsprozesses nicht direkt zum richtigen Datensatz wechseln kann (es kann beispielsweise nicht mehr garantiert werden, dass auf der vierten Seite der vierte Datensatz verwendet wird). <br><br>  Um den Speicherverlust zu verringern, k√∂nnen Sie eine <b>zweistufige Organisation verwenden</b> .  Die Idee ist, dass wir verschiedene Tabellen f√ºr verschiedene Bereiche verwenden.  Eine zus√§tzliche Tabelle, die als Seitentabelle der <i>zweiten Ebene bezeichnet</i> wird, wird zwischen den Adressbereichen und Seitentabellen der ersten Ebene konvertiert. <br><br>  Dies l√§sst sich am besten anhand eines Beispiels erkl√§ren.  Wir definieren, dass jede Seitentabelle der Ebene 1 f√ºr einen Bereich der Gr√∂√üe <code>10_000</code> .  Dann existieren im obigen Beispiel die folgenden Tabellen: <br><br><img src="https://habrastorage.org/webt/7w/3s/qk/7w3sqkqe6zbpna2z4kcnsxqokco.png"><br><br>  Seite 0 f√§llt in den ersten Bereich von <code>10_000</code> Bytes und verwendet daher den ersten Datensatz in der Seitentabelle der zweiten Ebene.  Dieser Eintrag verweist auf die T1-Seitentabelle der ersten Ebene, die bestimmt, dass Seite 0 auf Frame 0 verweist. <br><br>  Die Seiten <code>1_000_000</code> , <code>1_000_050</code> und <code>1_000_100</code> fallen in den 100. Byte-Bereich von <code>10_000</code> , sodass sie den 100. Datensatz der Seitentabelle der Ebene 2 verwenden. Dieser Datensatz zeigt auf eine andere Tabelle T2 der ersten Ebene, die drei Seiten in die Frames 100, 150 und 200 √ºbersetzt. Hinweis <code>1_000_050</code> in den Tabellen der ersten Ebene keinen <code>1_000_050</code> betr√§gt der Datensatz f√ºr Seite <code>1_000_050</code> beispielsweise nur <code>50</code> . <br><br>  Wir haben noch 100 leere Eintr√§ge in der Tabelle der zweiten Ebene, aber das ist viel weniger als die vorherige Million.  Der Grund f√ºr die Einsparungen ist, dass Sie keine Seitentabellen der ersten Ebene f√ºr nicht <code>10_000</code> Speicherbereiche zwischen <code>10_000</code> und <code>1_000_000</code> <code>10_000</code> <code>1_000_000</code> . <br><br>  Das Prinzip von zweistufigen Tabellen kann auf drei, vier oder mehr Ebenen erweitert werden.  Im Allgemeinen wird ein solches System als <i>mehrstufige</i> oder <i>hierarchische</i> Seitentabelle bezeichnet. <br><br>  Wenn Sie die Seitenorganisation und die mehrstufigen Tabellen kennen, k√∂nnen Sie sehen, wie die Seitenorganisation in der x86_64-Architektur implementiert ist (wir gehen davon aus, dass der Prozessor im 64-Bit-Modus arbeitet). <br><br><h1>  Seitenorganisation auf x86_64 </h1><br>  Die x86_64-Architektur verwendet eine vierstufige Tabelle mit einer Seitengr√∂√üe von 4 KB.  Unabh√§ngig von der Ebene enth√§lt jede Seitentabelle 512 Elemente.  Jeder Datensatz hat eine Gr√∂√üe von 8 Bytes, sodass die Gr√∂√üe der Tabellen 512 √ó 8 Bytes = 4 KB betr√§gt. <br><br><img src="https://habrastorage.org/webt/tp/o9/x-/tpo9x-ibzvx7spvyvspck7_rtrq.png"><br><br>  Wie Sie sehen k√∂nnen, enth√§lt jeder Tabellenindex 9 Bits, was sinnvoll ist, da die Tabellen 2 ^ 9 = 512 Eintr√§ge haben.  Die unteren 12 Bits sind der 4-Kilobyte-Seitenversatz (2 ^ 12 Bytes = 4 KB).  Die Bits 48 bis 64 werden verworfen, sodass x86_64 eigentlich kein 64-Bit-System ist, sondern nur 48-Bit-Adressen unterst√ºtzt.  Es gibt Pl√§ne, die Adressgr√∂√üe durch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5-Ebenen-Seitentabelle</a> auf 57 Bit zu erweitern, aber ein solcher Prozessor wurde noch nicht erstellt. <br><br>  Obwohl die Bits 48 bis 64 verworfen werden, k√∂nnen sie nicht auf beliebige Werte gesetzt werden.  Alle Bits in diesem Bereich m√ºssen Kopien von Bit 47 sein, um eindeutige Adressen beizubehalten und eine zuk√ºnftige Erweiterung zu erm√∂glichen, beispielsweise auf eine Seitentabelle mit 5 Ebenen.  Dies wird als Zeichenerweiterung bezeichnet, da es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer Zeichenerweiterung in zus√§tzlichem Code</a> sehr √§hnlich ist.  Wenn die Adresse falsch erweitert wird, l√∂st die CPU eine Ausnahme aus. <br><br><h3>  Konvertierungsbeispiel </h3><br>  Schauen wir uns ein Beispiel f√ºr die Funktionsweise der Adress√ºbersetzung an: <br><br><img src="https://habrastorage.org/webt/zj/ox/fe/zjoxfeno1sahwas8h-ffyxechgm.png"><br><br>  Die physikalische Adresse der aktuell aktiven Seitentabelle von Seiten der Ebene 4, die die <code>CR3</code> der <code>CR3</code> dieser Ebene ist, wird im <code>CR3</code> gespeichert.  Jeder Seitentabelleneintrag zeigt dann auf den physischen Rahmen der Tabelle der n√§chsten Ebene.  Ein Tabelleneintrag der Ebene 1 zeigt den angezeigten Rahmen an.  Bitte beachten Sie, dass alle Adressen in den Seitentabellen physisch und nicht virtuell sind, da sonst die CPU diese Adressen konvertieren muss (was zu einer unendlichen Rekursion f√ºhren kann). <br><br>  Die obige Hierarchie konvertiert zwei Seiten (in blau).  Aus den Indizes k√∂nnen wir schlie√üen, dass die virtuellen Adressen dieser Seiten <code>0x803fe7f000</code> und <code>0x803FE00000</code> .  Mal sehen, was passiert, wenn ein Programm versucht, den Speicher unter der Adresse <code>0x803FE7F5CE</code> zu lesen.  Konvertieren Sie zun√§chst die Adresse in eine Bin√§rdatei und bestimmen Sie die Seitentabellenindizes und den Offset f√ºr die Adresse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/d08/367/600d08367d49e110f1852796c23f9754.png"><br><br>  Mit diesen Indizes k√∂nnen wir nun die Hierarchie der Seitentabellen durchgehen und den entsprechenden Frame finden: <br><br><ul><li>  Lesen Sie die Adresse der Tabelle der vierten Ebene aus dem <code>CR3</code> . </li><li>  Der Index der vierten Ebene ist 1, daher betrachten wir den Datensatz mit Index 1 in dieser Tabelle.  Sie sagt, dass eine Tabelle der Stufe 3 bei 16 KB gespeichert ist. </li><li>  Wir laden die Tabelle der dritten Ebene von dieser Adresse und betrachten den Datensatz mit dem Index 0, der auf die Tabelle der zweiten Ebene mit 24 KB verweist. </li><li>  Der Index der zweiten Ebene ist 511, daher suchen wir nach dem letzten Datensatz auf dieser Seite, um die Adresse der Tabelle der ersten Ebene herauszufinden. </li><li>  Aus dem Eintrag mit dem Index 127 in der Tabelle der ersten Ebene geht schlie√ülich hervor, dass die Seite einem 12-KB-Frame oder 0xc000 im Hexadezimalformat entspricht. </li><li>  Der letzte Schritt besteht darin, der Rahmenadresse einen Offset hinzuzuf√ºgen, um die physikalische Adresse zu erhalten: 0xc000 + 0x5ce = 0xc5ce. </li></ul><br><img src="https://habrastorage.org/webt/mo/iq/-g/moiq-grelw6eyagqsuygebpugkm.png"><br><br>  F√ºr die Seite in der Tabelle der ersten Ebene wird das Flag <code>r</code> angegeben, dh nur das Lesen ist zul√§ssig.  Eine Ausnahme wird auf Hardwareebene ausgel√∂st, wenn wir versuchen, dort aufzunehmen.  Die Berechtigungen der √ºbergeordneten Tabellen erstrecken sich auf die niedrigeren Ebenen. Wenn Sie also das Nur-Lese-Flag auf der dritten Ebene setzen, kann keine einzelne nachfolgende Seite der unteren Ebene beschreibbar sein, selbst wenn Flags vorhanden sind, die das Schreiben erm√∂glichen. <br><br>  Obwohl in diesem Beispiel nur eine Instanz jeder Tabelle verwendet wird, gibt es normalerweise in jedem Adressraum mehrere Instanzen jeder Ebene.  Maximum: <br><br><ul><li>  ein Tisch der vierten Ebene, </li><li>  512 Tabellen der dritten Ebene (da die Tabelle der vierten Ebene 512 Datens√§tze enth√§lt), </li><li>  512 * 512 Tabellen der zweiten Ebene (da jede der Tabellen der dritten Ebene 512 Eintr√§ge enth√§lt) und </li><li>  512 * 512 * 512 Tabellen der ersten Ebene (512 Datens√§tze f√ºr jede Tabelle der zweiten Ebene). </li></ul><br><h3>  Seitentabellenformat </h3><br>  In der x86_64-Architektur sind Seitentabellen im Wesentlichen Arrays von 512 Eintr√§gen.  In der Rust-Syntax: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(align(4096))]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageTable</span></span></span></span> { entries: [PageTableEntry; <span class="hljs-number"><span class="hljs-number">512</span></span>], }</code> </pre> <br>  Wie im <code>repr</code> Attribut angegeben, sollten die Tabellen auf der Seite ausgerichtet sein, d. H. Am 4-KB-Rand.  Diese Anforderung stellt sicher, dass die Tabelle immer die gesamte Seite optimal ausf√ºllt, wodurch die Eintr√§ge sehr kompakt werden. <br><br>  Die Gr√∂√üe jedes Datensatzes betr√§gt 8 Byte (64 Bit) und das folgende Format: <br><br><table><thead><tr><th>  Bit (s) </th><th>  Titel </th><th>  Wert </th></tr></thead><tbody><tr><td>  0 </td><td>  vorhanden </td><td>  Seite im Speicher </td></tr><tr><td>  1 </td><td>  beschreibbar </td><td>  Aufzeichnung erlaubt </td></tr><tr><td>  2 </td><td>  Benutzer zug√§nglich </td><td>  Wenn das Bit nicht gesetzt ist, hat nur der Kernel Zugriff auf die Seite </td></tr><tr><td>  3 </td><td>  Schreiben Sie durch Caching </td><td>  direkt in den Speicher schreiben </td></tr><tr><td>  4 </td><td>  Cache deaktivieren </td><td>  Deaktivieren Sie den Cache f√ºr diese Seite </td></tr><tr><td>  5 </td><td>  zugegriffen </td><td>  Die CPU setzt dieses Bit, wenn die Seite verwendet wird. </td></tr><tr><td>  6 </td><td>  schmutzig </td><td>  Die CPU setzt dieses Bit beim Schreiben auf die Seite </td></tr><tr><td>  7 </td><td>  riesige Seite / null </td><td>  Das Nullbit in P1 und P4 erzeugt 1 KB-Seiten in P3, 2 MB-Seiten in P2 </td></tr><tr><td>  8 </td><td>  global </td><td>  Die Seite wird beim Umschalten des Adressraums nicht aus dem Cache gef√ºllt (das PGE-Bit des CR4-Registers muss gesetzt sein). </td></tr><tr><td>  9-11 </td><td>  verf√ºgbar </td><td>  Das Betriebssystem kann sie frei verwenden </td></tr><tr><td>  12-51 </td><td>  physikalische Adresse </td><td>  seitenausgerichtete physikalische 52-Bit-Adresse des Frames oder der folgenden Seitentabelle </td></tr><tr><td>  52-62 </td><td>  verf√ºgbar </td><td>  Das Betriebssystem kann sie frei verwenden </td></tr><tr><td>  63 </td><td>  keine Ausf√ºhrung </td><td>  verbietet die Ausf√ºhrung von Code auf dieser Seite (das NXE-Bit muss im EFER-Register gesetzt sein) </td></tr></tbody></table><br>  Wir sehen, dass nur die Bits 12-51 zum Speichern der physischen Adresse des Rahmens verwendet werden und der Rest als Flags arbeitet oder vom Betriebssystem frei verwendet werden kann.  Dies ist m√∂glich, weil wir immer entweder auf eine 4096-Byte-ausgerichtete Adresse oder auf eine ausgerichtete Tabellenseite oder auf den Anfang des entsprechenden Frames verweisen.  Dies bedeutet, dass die Bits 0-11 immer Null sind, sodass sie nicht gespeichert werden k√∂nnen. Sie werden einfach auf die Hardwareebene zur√ºckgesetzt, bevor die Adresse verwendet wird.  Gleiches gilt f√ºr die Bits 52-63, da die x86_64-Architektur nur physische 52-Bit-Adressen (und nur virtuelle 48-Bit-Adressen) unterst√ºtzt. <br><br>  Schauen wir uns die verf√ºgbaren Flags genauer an: <br><br><ul><li>  Das <code>present</code> Flag unterscheidet angezeigte Seiten von nicht angezeigten.  Es kann verwendet werden, um Seiten vor√ºbergehend auf der Festplatte zu speichern, wenn der Hauptspeicher voll ist.  Beim n√§chsten Zugriff auf die Seite tritt eine spezielle PageFault-Ausnahme auf, auf die das Betriebssystem reagiert, indem es die Seite von der Festplatte austauscht. Das Programm funktioniert weiterhin. </li><li>  Die Flags " <code>writable</code> und " <code>no execute</code> bestimmen, ob der Seiteninhalt beschreibbar ist oder ausf√ºhrbare Anweisungen enth√§lt. </li><li>  Die <code>accessed</code> und <code>dirty</code> Flags werden vom Prozessor beim Lesen oder Schreiben auf die Seite automatisch gesetzt.  Das Betriebssystem kann diese Informationen beispielsweise verwenden, wenn es Seiten austauscht oder wenn √ºberpr√ºft wird, ob sich der Inhalt der Seite seit dem letzten Pumpen auf die Festplatte ge√§ndert hat. </li><li>  Mit den Caches zum <code>write through caching</code> und <code>disable cache</code> k√∂nnen Sie den Cache f√ºr jede Seite einzeln verwalten. </li><li>  Das <code>user accessible</code> macht die Seite f√ºr Code aus dem Benutzerbereich zug√§nglich, andernfalls steht sie nur dem Kernel zur Verf√ºgung.  Diese Funktion kann verwendet werden, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemaufrufe</a> zu beschleunigen und gleichzeitig die Adresszuordnung f√ºr den Kernel beizubehalten, w√§hrend das Benutzerprogramm ausgef√ºhrt wird.  Aufgrund der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spectre-</a> Sicherheitsanf√§lligkeit k√∂nnen diese Seiten jedoch von Programmen aus dem Benutzerbereich gelesen werden. </li><li>  <code>global</code>  ,                (.   TLB )     (address space switch).     user <code>accessible</code>        . </li><li>  <code>huge page</code>     ,      2  3     .      512 :     2  = 512 √ó 4 ,      1  = 512 √ó 2 .             . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die x86_64-Architektur definiert das Format </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Seitentabellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ihrer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datens√§tze</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sodass wir diese Strukturen nicht selbst erstellen m√ºssen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assoziativer √úbersetzungspuffer (TLB) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund der vier Ebenen erfordert jede Adress√ºbersetzung vier Speicherzugriffe. Aus Leistungsgr√ºnden speichert x86_64 die letzten √úbersetzungen im sogenannten assoziativen √úbersetzungspuffer (TLB) zwischen. Auf diese Weise k√∂nnen Sie die Konvertierung √ºberspringen, wenn sie sich noch im Cache befindet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu anderen Prozessor-Caches ist TLB nicht vollst√§ndig transparent und aktualisiert oder l√∂scht keine Konvertierungen, wenn der Inhalt von Seitentabellen ge√§ndert wird. Dies bedeutet, dass der Kernel den TLB selbst aktualisieren muss, wenn er die Seitentabelle √§ndert. Zu diesem Zweck gibt es einen speziellen CPU-Befehl namens </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>invlpg</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Seite ung√ºltig machen), der die √úbersetzung der angegebenen Seite aus dem TLB entfernt, damit sie beim n√§chsten Mal erneut aus der Seitentabelle geladen wird. TLB wird durch erneutes Laden des Registers vollst√§ndig gel√∂scht</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das ahmt einen Adressraumschalter nach. </font><font style="vertical-align: inherit;">Beide Optionen sind </font><font style="vertical-align: inherit;">√ºber das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tlb-Modul</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Rust verf√ºgbar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig, nicht zu vergessen, den TLB nach jedem Seitentabellenwechsel zu bereinigen, da die CPU sonst weiterhin die alte √úbersetzung verwendet, was zu unvorhersehbaren Fehlern f√ºhrt, die nur sehr schwer zu debuggen sind.</font></font><br><br><h1>  Implementierung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines haben wir nicht erw√§hnt: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Kern unterst√ºtzt bereits die Seitenorganisation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Bootloader aus dem Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûMinimaler Kernel on Rust‚Äú</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat bereits eine vierstufige Hierarchie eingerichtet, die jede Seite unseres Kernels einem physischen Frame zuordnet, da die Seitenorganisation im 64-Bit-Modus unter x86_64 erforderlich ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet, dass in unserem Kern alle Speicheradressen virtuell sind. Der Zugriff auf den VGA-Puffer unter der Adresse </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktionierte nur, weil die Bootloader-ID </font><font style="vertical-align: inherit;">diese Seite in den Speicher </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºbersetzt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat, dh die virtuelle Seite </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem physischen Frame zugeordnet hat </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank der Seitenorganisation ist der Kernel bereits relativ sicher: Jeder Zugriff √ºber den zul√§ssigen Speicher hinaus verursacht einen Seitenfehler und erlaubt kein Schreiben in den physischen Speicher. </font><font style="vertical-align: inherit;">Der Loader hat sogar die richtigen Zugriffsberechtigungen f√ºr jede Seite festgelegt: Es k√∂nnen nur Seiten mit Code ausgef√ºhrt werden, und nur Seiten mit Daten k√∂nnen geschrieben werden</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seitenfehler (PageFault) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir, PageFault aufzurufen, indem wir auf Speicher au√üerhalb des Kernels zugreifen. </font><font style="vertical-align: inherit;">Erstellen Sie zun√§chst einen Fehlerbehandler und registrieren Sie ihn in unserem IDT, um eine bestimmte Ausnahme anstelle eines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doppelten Fehlers eines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allgemeinen Typs anzuzeigen:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/interrupts.rs lazy_static! { static ref IDT: InterruptDescriptorTable = { let mut idt = InterruptDescriptorTable::new(); [‚Ä¶] idt.page_fault.set_handler_fn(page_fault_handler); // new idt }; } use x86_64::structures::idt::PageFaultErrorCode; extern "x86-interrupt" fn page_fault_handler( stack_frame: &amp;mut ExceptionStackFrame, _error_code: PageFaultErrorCode, ) { use crate::hlt_loop; use x86_64::registers::control::Cr2; println!("EXCEPTION: PAGE FAULT"); println!("Accessed Address: {:?}", Cr2::read()); println!("{:#?}", stack_frame); hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Seite fehlschl√§gt, setzt die CPU automatisch den Fall </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>CR2</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es enth√§lt die virtuelle Adresse der Seite, die den Fehler verursacht hat. Verwenden Sie die Funktion, um diese Adresse zu lesen und anzuzeigen </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cr2::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der Regel enth√§lt der Typ </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PageFaultErrorCode</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehr Informationen √ºber die Art des Speicherzugriffs, der den Fehler verursacht hat. Aufgrund des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehlers wird jedoch ein </font><font style="vertical-align: inherit;">ung√ºltiger Fehlercode √ºbertragen. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Daher</font></a><font style="vertical-align: inherit;"> werden diese Informationen vorerst ignoriert. Die Programmausf√ºhrung kann erst fortgesetzt werden, wenn der Seitenfehler behoben ist. F√ºgen Sie sie daher am Ende ein </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hlt_loop</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt erhalten wir Zugriff auf den Speicher au√üerhalb des Kernels:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use blog_os::interrupts::PICS; println!("Hello World{}", "!"); // set up the IDT first, otherwise we would enter a boot loop instead of // invoking our page fault handler blog_os::gdt::init(); blog_os::interrupts::init_idt(); unsafe { PICS.lock().initialize() }; x86_64::instructions::interrupts::enable(); // new let ptr = 0xdeadbeaf as *mut u32; unsafe { *ptr = 42; } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Start sehen wir, dass der Seitenfehler-Handler aufgerufen wird: Das </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/81e/aad/666/81eaad666e7980ce90867ffe3fcb0be3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register </font></font><code>CR2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt wirklich die Adresse, auf die </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir zugreifen wollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der aktuelle Anweisungszeiger ist </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass wir wissen, dass diese Adresse auf eine Codepage verweist. </font><font style="vertical-align: inherit;">Codepages werden vom schreibgesch√ºtzten Loader angezeigt, sodass das Lesen von dieser Adresse funktioniert und das Schreiben einen Fehler verursacht. </font><font style="vertical-align: inherit;">Versuchen Sie, den Zeiger </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf </font><font style="vertical-align: inherit;">Folgendes zu √§ndern </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Note: The actual address might be different for you. Use the address that // your page fault handler reports. let ptr = 0x20430a as *mut u32; // read from a code page -&gt; works unsafe { let x = *ptr; } // write to a code page -&gt; page fault unsafe { *ptr = 42; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir die letzte Zeile auskommentieren, k√∂nnen wir sicherstellen, dass das Lesen funktioniert und das Schreiben einen PageFault-Fehler verursacht. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zugriff auf Seitentabellen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen Sie sich nun die Seitentabellen f√ºr den Kernel an: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::registers::control::Cr3; let (level_4_page_table, _) = Cr3::read(); println!("Level 4 page table at: {:?}", level_4_page_table.start_address()); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cr3::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt aus dem Register die </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktuell aktive Seitentabelle der vierten Ebene zur√ºck. Ein Paar kehrt zur√ºck </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PhysFrame</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cr3Flags</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir interessieren uns nur f√ºr die erste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Start sehen wir folgendes Ergebnis: </font></font><br><br> <code>Level 4 page table at: PhysAddr(0x1000)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher wird derzeit die aktive Seitentabelle der vierten Ebene im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physischen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speicher unter der </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vom Typ angegebenen </font><font style="vertical-align: inherit;">Adresse </font><font style="vertical-align: inherit;">gespeichert </font></font><code>PhysAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Frage ist nun: Wie kann man vom Kernel aus auf diese Tabelle zugreifen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Seitenorganisation ist kein direkter Zugriff auf den physischen Speicher m√∂glich, da Programme sonst den Schutz leicht umgehen und Zugriff auf den Speicher anderer Programme erhalten k√∂nnen. Der einzige Weg, um Zugriff zu erhalten, ist eine virtuelle Seite, die bei in einen physischen Frame √ºbersetzt wird</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist ein typisches Problem, da der Kernel regelm√§√üig auf Seitentabellen zugreifen sollte, beispielsweise wenn ein Stapel f√ºr einen neuen Thread zugewiesen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die L√∂sungen f√ºr dieses Problem werden im n√§chsten Artikel ausf√ºhrlich beschrieben. Nehmen wir zun√§chst einmal an, dass der Loader eine Methode namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rekursive Seitentabellen verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die letzte Seite des virtuellen Adressraums ist </font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wir verwenden sie, um einige Eintr√§ge in dieser Tabelle zu lesen:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { let level_4_table_pointer = 0xffff_ffff_ffff_f000 as *const u64; for i in 0..10 { let entry = unsafe { *level_4_table_pointer.offset(i) }; println!("Entry {}: {:#x}", i, entry); } [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Adresse der letzten virtuellen Seite auf einen Zeiger auf reduziert </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie im vorherigen Abschnitt angegeben, hat jeder Seitentabelleneintrag eine Gr√∂√üe von 8 Byte (64 Bit) und </font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repr√§sentiert </font><font style="vertical-align: inherit;">daher </font><font style="vertical-align: inherit;">genau einen Eintrag. Mit der Schleife </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigen wir die ersten 10 Datens√§tze der Tabelle an. Innerhalb der Schleife verwenden wir einen unsicheren Block, um direkt vom Zeiger zu lesen und den Zeiger </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> offset</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu berechnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Nach dem </font><font style="vertical-align: inherit;">Start sehen wir die folgenden Ergebnisse </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/8b0/9cb/7258b09cb744af09041bb3a2ee05fd54.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oben beschrieben, wird </font><font style="vertical-align: inherit;">der Wert in das Format Nach </font></font><code>0x2023</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufzeichnungsmittel mit Flags 0 </font></font><code>present</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>writable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>accessed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die </font><font style="vertical-align: inherit;">√úbersetzung in einem Rahmen </font></font><code>0x2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Datensatz 1 wird im Frame gesendet </font></font><code>0x6e2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und hat die gleichen Flags plus</font></font><code>dirty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Eintr√§ge 2‚Äì9 fehlen, sodass diese virtuellen Adressbereiche keinen physischen Adressen zugeordnet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt direkt mit unsicheren Zeigern zu arbeiten, k√∂nnen Sie einen Typ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus verwenden </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::structures::paging::PageTable; let level_4_table_ptr = 0xffff_ffff_ffff_f000 as *const PageTable; let level_4_table = unsafe {&amp;*level_4_table_ptr}; for i in 0..10 { println!("Entry {}: {:?}", i, level_4_table[i]); } [‚Ä¶] }</span></span></code> </pre> <br>     <code>0xffff_ffff_ffff_f000</code>  ,       Rust.  - ,      ,      .        <code>&amp;PageTable</code> ,        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . <br><br> <code>x86_64</code>       ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/d89/73d/70ad8973d35a531c7ad5943ef5144ef8.png"><br><br>   ‚Äî      0   1     3.       ,  <code>0x2000</code>  <code>0x6e5000</code>    ,         .       . <br><br><h1>  Zusammenfassung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Artikel enth√§lt zwei Methoden zum Schutz des Speichers: Segmentierung und Seitenorganisation. Die erste Methode verwendet Speicherbereiche mit variabler Gr√∂√üe und leidet unter externer Fragmentierung, die zweite verwendet Seiten mit fester Gr√∂√üe und erm√∂glicht eine wesentlich detailliertere Kontrolle √ºber Zugriffsrechte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Seitenorganisation speichert Seiten√ºbersetzungsinformationen in Tabellen mit einer oder mehreren Ebenen. Die x86_64-Architektur verwendet vierstufige Tabellen mit einer Seitengr√∂√üe von 4 KB. Das Ger√§t umgeht automatisch die Seitentabellen und speichert die Konvertierungsergebnisse im assoziativen √úbersetzungspuffer (TLB) zwischen. Beim √Ñndern von Seitentabellen sollte eine Bereinigung erzwungen werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben erfahren, dass unser Kern die Seitenorganisation bereits unterst√ºtzt und dass durch den nicht autorisierten Zugriff auf den Speicher PageFault gel√∂scht wird. </font><font style="vertical-align: inherit;">Wir haben versucht, auf die derzeit aktiven Seitentabellen zuzugreifen, konnten jedoch nur auf die Tabelle der vierten Ebene zugreifen, da Seitenadressen physische Adressen speichern und wir nicht direkt vom Kernel aus darauf zugreifen k√∂nnen.</font></font><br><br><h1>  Was weiter? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der folgende Artikel basiert auf den grundlegenden Grundlagen, die wir jetzt gelernt haben. </font><font style="vertical-align: inherit;">Um √ºber den Kernel auf Seitentabellen zuzugreifen, wird eine erweiterte Technik namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rekursive Seitentabellen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet, um die Tabellenhierarchie zu durchlaufen und eine programmatische Adress√ºbersetzung zu implementieren. </font><font style="vertical-align: inherit;">In diesem Artikel wird auch erl√§utert, wie Sie neue √úbersetzungen in Seitentabellen erstellen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436606/">https://habr.com/ru/post/de436606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436594/index.html">Auf Wiedersehen Chevy Volt: Geschichten und Legenden des wiederaufladbaren Hybrids</a></li>
<li><a href="../de436596/index.html">Full-Stack-Entwickler stecken tats√§chlich auf mittlerer Ebene fest. Schonen Sie sich das Leiden - gehen Sie diesen Weg nicht</a></li>
<li><a href="../de436598/index.html">Ein gro√üer Schritt f√ºr eine Schachmaschine</a></li>
<li><a href="../de436600/index.html">Copyright √ºberholt und Choreografie: Fortnite-Sch√∂pfer wegen tanzender Pa-Game-Charaktere verklagt</a></li>
<li><a href="../de436602/index.html">Dawn Cargo Module: 20 Jahre im Orbit</a></li>
<li><a href="../de436608/index.html">[SAP] SAPUI5 f√ºr Dummies: Eine vollst√§ndige Schritt-f√ºr-Schritt-√úbung</a></li>
<li><a href="../de436610/index.html">Funktionsweise der CSS-Spezifit√§t in einem Browser</a></li>
<li><a href="../de436612/index.html">Brian Krebs: Mega-Leak-Kontodatenbank mit Hunderten von Millionen Datens√§tzen, 2-3 Jahre</a></li>
<li><a href="../de436614/index.html">Tesla wird die Zahl der festangestellten Mitarbeiter weltweit um 7% reduzieren.</a></li>
<li><a href="../de436616/index.html">Wie Singapur mit Innovation arbeitet: Von der staatlichen Regulierung zu Nachtclubs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>