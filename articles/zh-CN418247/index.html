<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏿 🧑🏾 👲🏻 使用SIMD加速float 4x4矩阵乘法 🏴 ☀️ 🍁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自从我熟悉Intel处理器上的MMX，SSE和后来的AVX指令以来，已经过去了很多年。 一次，在x86汇编程序的背景下，它们似乎像是一种魔术，而这早已是世俗的事物。 他们深深吸引了我，几年前，我想到了为一个著名游戏编写自己的软件渲染器的想法。 答应这些指示的事情向我保证了这一点。 在某些时候，我什至...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用SIMD加速float 4x4矩阵乘法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418247/"> 自从我熟悉Intel处理器上的MMX，SSE和后来的AVX指令以来，已经过去了很多年。 一次，在x86汇编程序的背景下，它们似乎像是一种魔术，而这早已是世俗的事物。 他们深深吸引了我，几年前，我想到了为一个著名游戏编写自己的软件渲染器的想法。 答应这些指示的事情向我保证了这一点。 在某些时候，我什至考虑过编写它。 但是事实证明，编写文本比编写代码要复杂得多。 <br><br> 当时，我想避免在不同处理器上支持的问题。 我希望能够检查我的渲染器的最大可用数量。 我仍然和旧的AMD处理器有朋友，他们的上限是SSE3。 因此，当时我决定将自己限制为SSE3的最大值。 因此，有一个向量数学库，比在SSE上完全实现的要少一些，在SSE3之前很少包含。 但是，在某些时候，我想知道对于一些关键的矢量数学运算，我可以从处理器中挤出什么最大性能。 一种这样的操作是将4个矩阵乘以4。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/ii/cq/kgiicqemuc5agmypikedjioaogc.jpeg"></div><a name="habracut"></a><br> 实际上，为了娱乐起见，我决定更多地从事这项业务。 我已经写过并且一直在我在SSE上的软件渲染中使用矩阵乘法，这对我来说似乎足够了。 但是后来我决定看看将2个float4x4矩阵相乘可以从原则上挤出多少个度量。 在我当前的SSE上，这是16个时钟周期。 的确，自从我开始为某些指令写1 *而不是0 *以来，最近到<abbr title="英特尔架构代码分析器">IACA</abbr> 3的过渡开始显示19。 显然，这只是分析仪中的一个缺陷。 <br><br><h3> 简要介绍所使用的实用程序 </h3><br> 对于代码分析，我使用了著名的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英特尔架构代码分析器</a>实用程序。 为了进行分析，我使用Haswell体系结构（HSW）作为支持AVX2的最低要求。 编写代码也非常方便使用：《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英特尔技术指南》</a>和《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英特尔优化手册》</a> 。 <br><br> 对于组装，我从控制台使用MSVS 2017社区。 我在带有内在函数的版本中编写代码。 您只需编写一次，通常它可以立即在不同平台上运行。 另外，x64 VC ++编译器不支持嵌入式汇编程序，但我希望它也能在x64下工作。 <br><br> 由于本文已经超出了SIMD编程的初学者水平，因此我将不介绍寄存器，指令，绘制（或刮削）精美的图片，而是尝试使用SIMD指令学习编程。 英特尔网站上有许多出色，清晰和详细的文档。 <br><br><h2> 我想让一切变得更轻松。。。 </h2><br> 这是时刻的开始，这使实现和本文都变得很复杂。 因此，我将对此稍作介绍。 对我来说，用元素的标准行布局编写矩阵乘法并不有趣。 谁需要它，所以他们就读大学或自己学习。 我们的目标是提高生产力。 首先，很久以前我切换到列布局。 我的软件渲染器基于OpenGL API，因此，为了避免不必要的转置，我开始将元素存储在列中。 这也很重要，因为矩阵乘法不是那么关键。 乘以2-5-10矩阵。 就是这样。 然后，我们将完成的矩阵乘以成千上万个顶点。 而且此操作更为关键。 当然，您每次都可以转置。 但是为什么，如果可以避免的话。 <br><br> 但是只回到矩阵。 我们确定了列的存储量。 但是，这可能会更加复杂。 对于我来说，将向量和矩阵行的高级元素存储在SIMD寄存器中比较方便，以便<strong>x</strong>处于最高浮点数（索引3），而<strong>w</strong>处于次要浮点（索引0）。 显然，在这里，我们将不得不退缩。 <br><br> 事实是，在矢量的软件渲染器中，您必须更频繁地操作<strong>w</strong>组件（ <strong>1 / z</strong>存储在其中），并且通过<strong>_ss</strong>版本的操作（仅在<em>xmm</em>寄存器的下浮点中的组件进行操作）非常方便，而无需触摸<strong><nobr>x，y，</nobr></strong> 。 因此，在SSE寄存器中，向量以易于理解的顺序<strong><nobr>x，y，z，w</nobr></strong>存储，并以相反的<strong><nobr>w，z，y，x</nobr></strong>顺序存储在存储器中。 <br><br> 此外，所有乘法选项也由单个功能实现。 这样做是因为我根据支持的指令类型使用它们来替代所需的选项。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">好在这里描述。</a> <br><br><h2> 我们实现基本功能 </h2><br><h3> 带循环的乘法，行有序 </h3><br><div class="spoiler">  <b class="spoiler_title">元素的行布局选项</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[i][j] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[i][j] += m[i][k] * n[k][j]; } } }</code> </pre> <br></div></div><br> 这里的一切都很简单明了。 对于每个元素，我们进行4次乘法和3次加法。 总共有64个乘法和48个加法。 而且这没有考虑到记录元素的读取。 <br><br> 简而言之，一切都很难过。 对于此选项，对于内部周期，IACA发出： <em>x86组装为3.65个时钟周期，x64组装为2.97个时钟</em> 。 不要问为什么小数。 我不知道  IACA 2.1并未遭受此困扰。 无论如何，这些数字应乘以约4 * 4 * 4 =64。即使您使用x64，结果也约为192小节。 显然，这是一个粗略的估计。 对于该选项，我看不出更准确地评估性能的意义。 <br><br><h3> 循环实现，列有序 </h3><br><div class="spoiler">  <b class="spoiler_title">转置矩阵，重新排列行和列索引</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][i] += m[k][i] * n[j][k]; } } }</code> </pre><br></div></div><br><h3> 周期乘法，面向SIMD的存储 </h3><br><div class="spoiler">  <b class="spoiler_title">以相反的顺序将行存储在内存中</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] += m[k][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] * n[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-k]; } } }</code> </pre><br></div></div><br> 这种实现在某种程度上简化了对内部发生的事情的理解，但显然还不够。 <br><br><h3> 助手类 </h3><br> 为了方便理解和编写参考和调试代码，实现两个辅助类很方便。 仅此而已，一切都只是为了理解。 我注意到，完整的向量和矩阵类的实现是一个单独的难题，并且未包含在本文的主题中。 <br><br><div class="spoiler">  <b class="spoiler_title">向量和矩阵类</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m128))</span></span></span><span class="hljs-function"> vec4 </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w, z, y, x; }; __m128 fmm; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> arr[<span class="hljs-number"><span class="hljs-number">4</span></span>]; }; vec4() {} vec4(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d) : w(d), z(c), y(b), x(a) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.00001</span></span></span></span><span class="hljs-function"><span class="hljs-params">f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(ab) &lt; t; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (vec4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> equ(x, vx) &amp;&amp; equ(y, vy) &amp;&amp; equ(z, vz) &amp;&amp; equ(w, vw); } }; <span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m256))</span></span></span><span class="hljs-function"> mtx4 </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//           union { struct { float _30, _20, _10, _00, _31, _21, _11, _01, _32, _22, _12, _02, _33, _23, _13, _03; }; __m128 r[4]; __m256 s[2]; vec4 v[4]; }; //    mtx4() {} mtx4( float i00, float i01, float i02, float i03, float i10, float i11, float i12, float i13, float i20, float i21, float i22, float i23, float i30, float i31, float i32, float i33) : _00(i00), _01(i01), _02(i02), _03(i03) , _10(i10), _11(i11), _12(i12), _13(i13) , _20(i20), _21(i21), _22(i22), _23(i23) , _30(i30), _31(i31), _32(i32), _33(i33) {} //      operator __m128 const* () const { return r; } operator __m128* () { return r; } //   bool operator == (mtx4 const&amp; m) const { return v[0]==mv[0] &amp;&amp; v[1]==mv[1] &amp;&amp; v[2]==mv[2] &amp;&amp; v[3]==mv[3]; } //  static mtx4 identity() { return mtx4( 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f); } static mtx4 zero() { return mtx4( 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f); } };</span></span></code> </pre><br></div></div><br><h3> 测试参考功能 </h3><br> 由于矩阵中元素的可接受顺序使理解变得很复杂，因此我们也不会被引用<em>清除</em>功能所打扰，该功能将在以后的实现中显示一切正常。 我们将与之比较后续结果。 <br><br><div class="spoiler">  <b class="spoiler_title">要创建它，只需采取并扩大周期</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_unroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; m = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_m); mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; n = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_n); mtx4&amp; r = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_r); r._00 = m._00*n._00 + m._01*n._10 + m._02*n._20 + m._03*n._30; r._01 = m._00*n._01 + m._01*n._11 + m._02*n._21 + m._03*n._31; r._02 = m._00*n._02 + m._01*n._12 + m._02*n._22 + m._03*n._32; r._03 = m._00*n._03 + m._01*n._13 + m._02*n._23 + m._03*n._33; r._10 = m._10*n._00 + m._11*n._10 + m._12*n._20 + m._13*n._30; r._11 = m._10*n._01 + m._11*n._11 + m._12*n._21 + m._13*n._31; r._12 = m._10*n._02 + m._11*n._12 + m._12*n._22 + m._13*n._32; r._13 = m._10*n._03 + m._11*n._13 + m._12*n._23 + m._13*n._33; r._20 = m._20*n._00 + m._21*n._10 + m._22*n._20 + m._23*n._30; r._21 = m._20*n._01 + m._21*n._11 + m._22*n._21 + m._23*n._31; r._22 = m._20*n._02 + m._21*n._12 + m._22*n._22 + m._23*n._32; r._23 = m._20*n._03 + m._21*n._13 + m._22*n._23 + m._23*n._33; r._30 = m._30*n._00 + m._31*n._10 + m._32*n._20 + m._33*n._30; r._31 = m._30*n._01 + m._31*n._11 + m._32*n._21 + m._33*n._31; r._32 = m._30*n._02 + m._31*n._12 + m._32*n._22 + m._33*n._32; r._33 = m._30*n._03 + m._31*n._13 + m._32*n._23 + m._33*n._33; }</code> </pre><br></div></div><br> 此处清楚地画出了经典算法，很难犯错（但您可以:-）。  IACA在其上发布了： <em>x86-69.95措施，x64-64措施</em> 。 这里大约有64个周期，我们将在将来查看此操作的加速情况。 <br><br><h2>  SSE实施 </h2><br><h3> 经典SSE算法 </h3><br> 为什么要经典？ 因为它早已在<em>FVec</em>的实现中作为MSVS的一部分。 首先，我们将编写如何在SSE寄存器中显示矩阵元素。 在这里看起来已经很简单了。 只是一个转置矩阵。 <br><br><pre> <code class="plaintext hljs">//     00, 10, 20, 30 // m[0] -  SIMD /   01, 11, 21, 31 // m[1] 02, 12, 22, 32 // m[2] 03, 13, 23, 33 // m[3]</code> </pre><br> 我们采用上述变体的<em>展开</em>代码。 不知何故他对上交所并不友好。 第一组行由结果矩阵的列的结果组成： <em><nobr>r._00，r._01，r._02，r._03</nobr></em> 。 我们有此列，但需要一行。 是的<strong><strong>，M，N</strong></strong>出现计算不便。 因此，我们重新排列算法的行，以使结果<strong>r是</strong>逐行的。 <br><br><pre> <code class="plaintext hljs">//  ,     r[0] r00 = m00*n00 + m01*n10 + m02*n20 + m03*n30; r10 = m10*n00 + m11*n10 + m12*n20 + m13*n30; r20 = m20*n00 + m21*n10 + m22*n20 + m23*n30; r30 = m30*n00 + m31*n10 + m32*n20 + m33*n30; //  ,     r[1] r01 = m00*n01 + m01*n11 + m02*n21 + m03*n31; r11 = m10*n01 + m11*n11 + m12*n21 + m13*n31; r21 = m20*n01 + m21*n11 + m22*n21 + m23*n31; r31 = m30*n01 + m31*n11 + m32*n21 + m33*n31; //  ,     r[2] r02 = m00*n02 + m01*n12 + m02*n22 + m03*n32; r12 = m10*n02 + m11*n12 + m12*n22 + m13*n32; r22 = m20*n02 + m21*n12 + m22*n22 + m23*n32; r32 = m30*n02 + m31*n12 + m32*n22 + m33*n32; //  ,     r[3] r03 = m00*n03 + m01*n13 + m02*n23 + m03*n33; r13 = m10*n03 + m11*n13 + m12*n23 + m13*n33; r23 = m20*n03 + m21*n13 + m22*n23 + m23*n33; r33 = m30*n03 + m31*n13 + m32*n23 + m33*n33;</code> </pre><br> 但这已经好多了。 实际上，我们看到了什么？ 根据每组中算法的列，我们具有矩阵<strong>m</strong>的行： <br><pre> m [0] = {00,10,20,30}，m [1] = {01,11,21,31}，m [2] = {02,12,22,32}，m [3] = {03,13,23,33}，
</pre> 它们乘以矩阵<strong>n</strong>的相同元素。 例如，对于第一个组，它是： <em>n._00，n._10，n._20，n._30</em> 。 对于算法的每一行行，矩阵<strong>n</strong>的元素再次位于矩阵的一行中。 <br><br> 然后一切都变得很简单：我们只需按索引取矩阵<strong>m</strong>的行，但对于元素<strong>n</strong>取其行，并通过<em>shuffle</em>指令将其分散到寄存器的所有4个元素，以便乘以寄存器中矩阵<strong>m</strong>的行。 例如，对于元素<em>n._00</em> （记住，它在寄存器中的移位具有索引3），它将是： <pre>  _mm_shuffle_ps（n [0]，n [0]，_ MM_SHUFFLE（3,3,3,3）） </pre><br> 以简化形式，该算法如下所示： <br><br><pre> <code class="plaintext hljs">//   n[0]={00,10,20,30} r[0] = m[0] * n00 + m[1] * n10 + m[2] * n20 + m[3] * n30; //   n[1]={01,11,21,31} r[1] = m[0] * n01 + m[1] * n11 + m[2] * n21 + m[3] * n31; //   n[2]={02,12,22,32} r[2] = m[0] * n02 + m[1] * n12 + m[2] * n22 + m[3] * n32; //   n[3]={03,13,23,33} r[3] = m[0] * n03 + m[1] * n13 + m[2] * n23 + m[3] * n33;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">基本的SSE实施</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); }</code> </pre><br></div></div><br> 现在我们将算法中的元素<strong>n</strong>更改为对应的<em>shuffle</em> ，乘以<em>_mm_mul_ps</em> ，乘以<em>_mm_add_ps</em> ，就可以了。 可以用 但是，代码看起来比算法本身看起来差很多。  IACA对此代码发布： <em>x86-18.89，x64-16个周期</em> 。 这比上一个快4倍。 在SSE中注册第四个浮点数 几乎线性关系。 <br><br><h4> 装饰SSE实施 </h4><br> 尽管如此，在代码中看起来还是很糟糕。 我们将尝试通过编写一些语法糖来改善这一点。 <br><br><div class="spoiler">  <b class="spoiler_title">操作员和改进员</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ( -    namespace) __m128 operator + (__m128 const a, __m128 const b) { return _mm_add_ps(a, b); } __m128 operator - (__m128 const a, __m128 const b) { return _mm_sub_ps(a, b); } __m128 operator * (__m128 const a, __m128 const b) { return _mm_mul_ps(a, b); } __m128 operator / (__m128 const a, __m128 const b) { return _mm_div_ps(a, b); } //_mm_shuffle_ps(u, v, _MM_SHUFFLE(3,2,1,0))   shuf&lt;3,2,1,0&gt;(u, v) template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(a, b, c, d)); } template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(a, b, c, d)); } //    template &lt;int i&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(i, i, i, i)); } template &lt;int i&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(i, i, i, i)); } //  float       , //    ,    template &lt;int a, int b, int c, int d&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(a, b, c, d))); } template &lt;int i&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(i, i, i, i))); }</span></span></code> </pre><br></div></div><br> 编译器可以完美地内联这些函数（尽管有时不带__forceinline）。 <br><br><div class="spoiler">  <b class="spoiler_title">因此代码正在转向...</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]); }</code> </pre><br></div></div><br> 因此，它已经更好，更易读。  IACA它发布了关于预期的结果<em>：86 - 19，64 - 16（什么是不是小数？）。</em> 实际上，性能没有改变，但是代码更加漂亮和易于理解。 <br><br><h4> 对未来优化的贡献很小 </h4><br> 让我们在铁版本中最近出现的功能级别上进行另一项改进。  <em>多次加法（fma）操作</em> 。  <em><nobr>fma（a，b，c）= a * b + c</nobr></em> 。 <br><br><div class="spoiler">  <b class="spoiler_title">多次添加实施</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_add_ps(_mm_mul_ps(a, b), c); }</code> </pre><br></div></div><br> 为什么这是必要的？ 首先，为了将来的优化。 例如，您可以根据需要通过相同的宏在完成的代码中简单地用<em>mad</em>替换<em>mad</em> 。 但是，我们现在将为优化奠定基础： <br><br><div class="spoiler">  <b class="spoiler_title">有多次添加的变体</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA： <em>x86-18.89，x64-16</em> 。 再次分数。 不过，IACA有时仍会产生奇怪的结果。 代码变化不大。 可能更糟。 但是优化有时需要做出这样的牺牲。 <br><br><h4> 我们通过_mm_stream进行保存 </h4><br> 各种优化指南再次建议不要为大容量保存操作拉入缓存。 当您处理成千上万个顶点时，通常这是合理的。 但是对于矩阵而言，这可能并不那么重要。 不过，我还是会添加它。 <br><br><div class="spoiler">  <b class="spoiler_title">流保存选项</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">1</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">3</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]))); }</code> </pre><br></div></div><br> 从字面上看，这里的时间没有任何变化。 但是，根据建议，我们现在不再再次触摸缓存。 <br><br><h2>  AVX实施 </h2><br><h3> 基本AVX选项 </h3><br><img src="https://habrastorage.org/webt/8d/l-/1r/8dl-1rgisfl2sqr0dhzmizkmawg.jpeg" align="right"><br> 接下来，我们进入下一步的优化。  SSE寄存器中包含第4个浮点数，而AVX中已经包含第4个浮点数。也就是说，理论上有机会减少执行的操作数量，如果不是一半，则提高生产率，至少是1.5倍。 但是有一点告诉我，过渡到AVX并非一切都会如此简单。 我们可以从双寄存器中获得必要的数据吗？ <br><br> 让我们尝试找出答案。 同样，我们写出上面使用的乘法算法。 您无法执行此操作，但是当所有内容都在附近并且无需向上滚动半页时，使用该代码更方便。 <br><br><pre> <code class="plaintext hljs">//    : 00, 10, 20, 30, 01, 11, 21, 31, 02, 12, 22, 32, 03, 13, 23, 33 //   SSE: r0 = m0*n00 + m1*n10 + m2*n20 + m3*n30 r1 = m0*n01 + m1*n11 + m2*n21 + m3*n31 r2 = m0*n02 + m1*n12 + m2*n22 + m3*n32 r3 = m0*n03 + m1*n13 + m2*n23 + m3*n33</code> </pre><br> 在输出处，我们期望得到<em><nobr>ymm = {r0：r1}</nobr></em>和<em><nobr>ymm = {r2：r3}的结果</nobr></em> 。 如果在SSE版本中我们的算法被泛化为列，那么现在我们需要将其泛化为行。 因此，在SSE选项的情况下无法正常工作。 <br><br> 如果考虑寄存器<em>ymm中</em>的矩阵<strong>m</strong> ，则分别得到<em><nobr>ymm = {m0：m1}</nobr></em>和<em><nobr>ymm = {m2：m3}</nobr></em> 。 以前，我们在寄存器中只有矩阵列，现在只有列和行。 <br><br> 如果您尝试像以前那样操作，则必须将<em><nobr>ymm = {m0：m1}</nobr></em>乘以寄存器<em><nobr>ymm = {n00，n00，n00，n00}：{n10，n10，n10，n10}</nobr></em> 。 由于<em>n00</em>和<em>n01</em>在矩阵<strong>n</strong>的同一行中，根据可用的AVX指令集判断，将它们分散<em>ymm</em>会很昂贵。  <em>ymm</em>寄存器内的float的两个四分之一（高<em>xmm</em>和低<em>xmm</em> ）中的每一个都分别进行<em>混洗</em>和<em>置换</em> 。 <br><br> 如果我们假设<strong>n个</strong> <em>YMM</em>矩阵<strong>，</strong>我们得到<em>N00</em>和<em>N10</em>在较旧的2内部<em>YMM</em> <em>xmm</em>寄存器中两个元件。  <em><nobr>{n00，n10，n20，n30}：{n01，n11，n21，n31}</nobr></em> 。 通常，现有指令的索引为0到3。它的地址仅在两个内部<em>ymm</em>寄存器中的一个<em>xmm</em>寄存器中浮动。 无法<em>廉价地</em>将<em>n10</em>从较旧的<em>xmm</em>转移到较年轻的<em>xmm</em> 。 然后必须多次重复此焦点。 我们不能忍受这种措施的损失。 有必要提出其他建议。 <br><br> 我们曾经对列进行泛化，但现在对行进行泛化。 因此，我们将尝试以一些不同的方式进行。 我们需要在<em>{r0：r1}中</em>得到结果。 这意味着必须对算法进行改进，而不是在算法的不同行中进行改进，而应同时进行两次改进。 在这里， <em>洗牌</em>和<em>置换</em>工作的<em>弊端</em>对我们来说将是一个加分。 当我们考虑矩阵<strong>n</strong>时，我们将看看<em>ymm</em>寄存器中的<em>内容</em> 。 <br><br><pre> <code class="plaintext hljs">n0n1 = {00, 10, 20, 30} : {01, 11, 21, 31} n2n3 = {02, 12, 22, 32} : {03, 13, 23, 33}</code> </pre><br> 是的，我们注意到在<em>ymm</em>寄存器的不同<em>xmm</em>部分中，我们有元素<em>00</em>和<em>01</em> 。 可以通过<em><nobr>{_00，_00，_00，_00}中的permute</nobr></em>命令通过寄存器乘以大小写<em><nobr>：{_ 01，_01，_01，_01}</nobr></em> ，这两个<em>xmm</em>部件仅指示一个索引3。 这正是我们所需要的。 实际上，系数也用在不同的行中。 仅现在才在对应的<em>ymm</em>寄存器中进行乘法运算，有必要保留<em>{m0：m0}</em> ，即矩阵<strong>m的</strong>第一行重复。 <br><br> 因此，我们将更详细地描述算法。 我们在<em>ymm</em>寄存器中读取矩阵<strong>m</strong>的双行： <br><br><pre> <code class="plaintext hljs">mm[0] = {m0:m0} mm[1] = {m1:m1} mm[2] = {m2:m2} mm[3] = {m3:m3}</code> </pre><br> 然后我们将乘法计算为： <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0] * {n00,n00,n00,n00:n01,n01,n01,n01} + // permute&lt;3,3,3,3&gt;(n0n1) mm[1] * {n10,n10,n10,n10:n11,n11,n11,n11} + // permute&lt;2,2,2,2&gt;(n0n1) mm[2] * {n20,n20,n20,n20:n21,n21,n21,n21} + // permute&lt;1,1,1,1&gt;(n0n1) mm[3] * {n30,n30,n30,n30:n31,n31,n31,n31} // permute&lt;0,0,0,0&gt;(n0n1) r2r3 = mm[0] * {n02,n02,n02,n02:n03,n03,n03,n03} + // permute&lt;3,3,3,3&gt;(n2n3) mm[1] * {n12,n12,n12,n12:n13,n13,n13,n13} + // permute&lt;2,2,2,2&gt;(n2n3) mm[2] * {n22,n22,n22,n22:n23,n23,n23,n23} + // permute&lt;1,1,1,1&gt;(n2n3) mm[3] * {n32,n32,n32,n32:n33,n33,n33,n33} // permute&lt;0,0,0,0&gt;(n2n3)</code> </pre><br> 我们重写得更清楚： <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3,3,3,3&gt;+mm[1]*n0n1&lt;2,2,2,2&gt;+mm[2]*n0n1&lt;1,1,1,1&gt;+mm[3]*n0n1&lt;0,0,0,0&gt; r2r3 = mm[0]*n2n3&lt;3,3,3,3&gt;+mm[1]*n2n3&lt;2,2,2,2&gt;+mm[2]*n2n3&lt;1,1,1,1&gt;+mm[3]*n2n3&lt;0,0,0,0&gt;</code> </pre><br> 或以简化形式： <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3&gt; + mm[1]*n0n1&lt;2&gt; + mm[2]*n0n1&lt;1&gt; + mm[3]*n0n1&lt;0&gt; r2r3 = mm[0]*n2n3&lt;3&gt; + mm[1]*n2n3&lt;2&gt; + mm[2]*n2n3&lt;1&gt; + mm[3]*n2n3&lt;0&gt;</code> </pre><br> 一切似乎都很清楚。 <br><br><div class="spoiler">  <b class="spoiler_title">剩下的只是写一个实现</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 mm0 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 mm1 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>]); __m256 mm2 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]); __m256 mm3 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], m[<span class="hljs-number"><span class="hljs-number">3</span></span>]); __m256 n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 y1 = _mm256_permute_ps(n0n1, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>);<span class="hljs-comment"><span class="hljs-comment">//3,3,3,3 __m256 y2 = _mm256_permute_ps(n0n1, 0xAA);//2,2,2,2 __m256 y3 = _mm256_permute_ps(n0n1, 0x55);//1,1,1,1 __m256 y4 = _mm256_permute_ps(n0n1, 0x00);//0,0,0,0 y1 = _mm256_mul_ps(y1, mm0); y2 = _mm256_mul_ps(y2, mm1); y3 = _mm256_mul_ps(y3, mm2); y4 = _mm256_mul_ps(y4, mm3); y1 = _mm256_add_ps(y1, y2); y3 = _mm256_add_ps(y3, y4); y1 = _mm256_add_ps(y1, y3); __m256 n2n3 = _mm256_load_ps(&amp;n[2].m128_f32[0]); __m256 y5 = _mm256_permute_ps(n2n3, 0xFF); __m256 y6 = _mm256_permute_ps(n2n3, 0xAA); __m256 y7 = _mm256_permute_ps(n2n3, 0x55); __m256 y8 = _mm256_permute_ps(n2n3, 0x00); y5 = _mm256_mul_ps(y5, mm0); y6 = _mm256_mul_ps(y6, mm1); y7 = _mm256_mul_ps(y7, mm2); y8 = _mm256_mul_ps(y8, mm3); y5 = _mm256_add_ps(y5, y6); y7 = _mm256_add_ps(y7, y8); y5 = _mm256_add_ps(y5, y7); _mm256_stream_ps(&amp;r[0].m128_f32[0], y1); _mm256_stream_ps(&amp;r[2].m128_f32[0], y5); }</span></span></code> </pre><br></div></div><br> 它一直有趣的数字从<em>IACA：86 - 12.53，64 - 12。</em> 虽然，当然，我想要更好。 错过了什么。 <br><br><h3>  AVX优化加语法糖 </h3><br> 似乎在上面的代码中，AVX并未充分发挥其潜力。 我们发现不用在<strong>ymm</strong>寄存器中设置两条相同的行，而是可以使用<em>broadcast</em> ，它可以用两个相同的<em>xmm</em>值填充<em>ymm</em>寄存器。 同样，在此过程中，为AVX功能添加一些“语法糖”。 <br><br><div class="spoiler">  <b class="spoiler_title">增强的AVX实施</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_sub_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_mul_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(i, i, i, i, j, j, j, j)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(a, b, c, d, e, f, g, h)); } __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(_mm256_mul_ps(a, b), c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[] { _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br> 结果在这里已经更加有趣了。  IACA产生数字：x86-10 <em>，x64-8.58</em> ，看起来好多了，但仍然不是2倍。 <br><br><h3>  AVX + FMA选项（最终） </h3><br> 让我们再尝试一次。 现在，再次调用FMA指令集是合乎逻辑的，因为它是在AVX之后添加到处理器中的。 只需更改单个<em>mul +添加</em>一次操作即可。 尽管我们仍然使用乘法指令为编译器提供更多的优化机会，并为处理器提供并行执行乘法的机会。 通常，我会在汇编器中查看生成的代码，以确保哪个选项更好。 <br><br> 在这种情况下，我们需要计算<em><nobr>a * b + c * d + e * f + g * h</nobr></em> 。 您可以这样做： <em><nobr>fma（a，b，fma（c，d，fma（e，f，g * h）））</nobr></em> 。 但是，正如我们看到的，如果不完成前一个操作就不可能在这里执行一个操作。 这意味着我们将无法使用成对乘法的功能，因为SIMD流水线允许我们这样做。 如果我们转换位计算<em><nobr>FMA（A，B，C *</nobr></em> d）+ FMA（E，F，G * H），我们看到，计算可以被并行化。 首先执行两个独立的乘法，然后执行两个独立的<em>fma</em>运算。 <br><br><div class="spoiler">  <b class="spoiler_title">AVX + FMA实施</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA： <em>x86-9.21，x64-8</em> 。 现在很好。 可能有人会说可以做得更好的方法，但我不知道如何做。 <br><br><h2> 基准测试 </h2><br> 我立即注意到，这些数字不应被视为最终真理。 即使进行了固定测试，它们也会在一定范围内游泳。 而且，它们在不同平台上的行为也有所不同。         . <br><br><h4>   </h4><br><ul><li> Function:  .   <b>s</b> —   ,   mov ( ).   ,     . </li><li> IACA cycles:      IACA </li><li> Measured cycles:    ( ,  ) </li><li> IACA speedup:      /     </li><li> Measured speedup:      /     ( ,  ) </li></ul><br><br>  loop_m       64.      .     . <br><br><h3> i3-3770: </h3><br><div class="spoiler"> <b class="spoiler_title">x86</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 70.00 </th><th> 50.75 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 119.21 </th><th> 0.30 </th><th> 0.43 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 27.51 </th><th> 3.70 </th><th> 1.84 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 27.61 </th><th> 3.68 </th><th> 1.84 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 27.22 </th><th> 3.70 </th><th> 1.86 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 27.18 </th><th> 3.70 </th><th> 1.87 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 19.21 </th><th> 5.38 </th><th> 2.64 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th>  03/20 </th><th> 5.38 </th><th> 2.53 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 12.91 </th><th> 6.99 </th><th> 3.93 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 17.34 </th><th> 6.99 </th><th> 2.93 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title">x64</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th>  70 </th><th> 68.60 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 119.37 </th><th> 0.30 </th><th> 0.57 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 21.98 </th><th> 3.70 </th><th> 3.12 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 21.09 </th><th> 3.68 </th><th> 3.25 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 22.19 </th><th> 3.70 </th><th> 3.09 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 22.39 </th><th> 3.70 </th><th> 3.06 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 9.61 </th><th> 5.38 </th><th> 7.13 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 16.90 </th><th> 5.38 </th><th> 4.06 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 9.20 </th><th> 6.99 </th><th> 7.45 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 14.64 </th><th> 6.99 </th><th> 4.68 </th></tr></tbody></table></div></div></div><br><h3> i7-8700K: </h3><br><div class="spoiler"> <b class="spoiler_title">x86</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 40.25 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 79.49 </th><th> 0.30 </th><th> 0.51 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 19.31 </th><th> 3.70 </th><th> 2.09 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 19.98 </th><th> 3.68 </th><th> 2.01 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 19.69 </th><th> 3.70 </th><th> 2.04 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 19.67 </th><th> 3.70 </th><th> 2.05 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 14.22 </th><th> 5.38 </th><th> 2.83 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 14.13 </th><th> 5.38 </th><th> 2.85 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 11.73 </th><th> 6.99 </th><th> 3.43 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.81 </th><th> 6.99 </th><th> 3.41 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 10.38 </th><th> 7.60 </th><th> 3.88 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 10.32 </th><th> 7.60 </th><th> 3.90 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title">x64</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 57.11 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 75.73 </th><th> 0.30 </th><th> 0.75 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 15.83 </th><th> 3.70 </th><th> 3.61 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 17.22 </th><th> 3.68 </th><th> 3.32 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 15.92 </th><th> 3.70 </th><th> 3.59 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 16.18 </th><th> 3.70 </th><th> 3.53 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 7.03 </th><th> 5.38 </th><th> 8.12 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 12.98 </th><th> 5.38 </th><th> 4.40 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 5.40 </th><th> 6.99 </th><th> 10.57 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.39 </th><th> 6.99 </th><th> 5.01 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 9.73 </th><th> 7.60 </th><th> 5.87 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 9.81 </th><th> 7.60 </th><th> 5.82 </th></tr></tbody></table></div></div></div><br>    .       ,   . <br><br><h2> BONUS    </h2><br> ,     ,         AVX512,     .   ,    .      ,    AVX+FMA.   ,   . <br><br><div class="spoiler"> <b class="spoiler_title"> ,     </b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_add_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_sub_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_mul_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx512</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">0</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">1</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">2</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">3</span></span>]) }; __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n = _mm512_load_ps(&amp;_n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm512_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  : <em>x86 — 4.79, x64 — 5.42</em> (IACA   SKX).  ,    64   48 . <br><br><h2> PS    </h2><br><div class="oembed"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/truthfinder/mul_m4_m4</a> </div><br><br>       .     .       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418247/">https://habr.com/ru/post/zh-CN418247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418237/index.html">在Neo中的SAP Cloud平台上开发多租户应用程序，第2部分：授权和身份验证</a></li>
<li><a href="../zh-CN418239/index.html">智能手机48百万像素</a></li>
<li><a href="../zh-CN418241/index.html">为什么是高斯？ （解方程组的100种方法）</a></li>
<li><a href="../zh-CN418243/index.html">天文学的流行史是错误的</a></li>
<li><a href="../zh-CN418245/index.html">如何不在Bitrix上开发项目</a></li>
<li><a href="../zh-CN418249/index.html">用于深度学习的新Google Compute Engine VM映像</a></li>
<li><a href="../zh-CN418251/index.html">计算机视觉：人工智能如何监视我们</a></li>
<li><a href="../zh-CN418253/index.html">初月可能有水，大气和生命</a></li>
<li><a href="../zh-CN418255/index.html">流量交换如何转售自动冲浪，以及数百万个机器人来自何处</a></li>
<li><a href="../zh-CN418257/index.html">Github.com拒绝使用jQuery并切换到纯JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>