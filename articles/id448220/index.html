<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐹 👧🏻 ⛹️ Dasar-dasar format GLTF dan GLB, bagian 1 🗃️ 🖊️ 😲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa itu GLTF dan GLB? 


 GLTF (GL Transmission Format) adalah format file untuk menyimpan adegan dan model 3D, yang sangat mudah dimengerti (struktur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar format GLTF dan GLB, bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448220/"><h2 id="chto-takoe-gltf-i-glb">  Apa itu GLTF dan GLB? </h2><br><p> GLTF (GL Transmission Format) adalah format file untuk menyimpan adegan dan model 3D, yang sangat mudah dimengerti (strukturnya ditulis dalam standar JSON), dapat diperluas dan mudah berinteraksi dengan teknologi web modern.  Format ini memampatkan adegan tiga dimensi dengan baik dan meminimalkan pemrosesan runtime aplikasi menggunakan WebGL dan API lainnya.  GLTF sekarang secara aktif dipromosikan oleh Khronos Group sebagai JPEG dari dunia 3D.  GLTF versi 2.0 saat ini digunakan.  Ada juga versi biner dari format ini yang disebut GLB, satu-satunya perbedaan adalah bahwa semuanya disimpan dalam satu file dengan ekstensi GLB. </p><br><p>  Artikel ini adalah bagian 1 dari 2.  Di dalamnya, kita akan mempertimbangkan artefak format dan atributnya seperti <strong>Scene, Node, Buffer, BufferView, Accessor dan Mesh</strong> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dan di artikel kedua</a> kita akan melihat sisanya: <strong>Bahan, Tekstur, Animasi, Kulit dan Kamera.</strong>  Informasi format yang lebih umum dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  Jika Anda ingin bekerja secara pribadi dengan format ini saat melihat artikel, Anda dapat mengunduh model GLTF 2.0 dari repositori Khronos resmi di <a href="">GitHub</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/15e/e5d/a48/15ee5da4816090d71188478d4ca55299.jpg" alt="gambar"></p><br><h2 id="problematika-i-eyo-reshenie">  Masalah dan solusinya </h2><br><p>  Awalnya, format GLTF disusun oleh Khronos Group sebagai solusi untuk mentransmisikan konten 3D melalui Internet dan dirancang untuk meminimalkan jumlah importir dan konverter, berbagai jenis yang dibuat ketika bekerja dengan API grafik. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/4fd/258/dbe/4fd258dbe0327507b5217d1989cab6f1.png" alt="gambar"><br><p>  Saat ini, GLTF dan saudara binernya GLB digunakan sebagai format terpadu dalam program CAD (Autodesk Maya, Blender, dll.), Dalam mesin game (Unreal Engine, Unity, dll.), Aplikasi AR / VR, dan layanan sosial.  jaringan, dll. </p><a name="habracut"></a><br><p>  Perwakilan dari Grup Khronos menyatakan sebagai berikut: </p><br><ol><li>  GLTF bersifat universal - dapat digunakan sama baiknya untuk geometri sederhana maupun untuk adegan kompleks dengan animasi, berbagai bahan, dll. </li><li>  Cukup kompak.  Ya, ini bisa diperdebatkan, karena semuanya tergantung pada algoritma konversi, dan saya pribadi tahu kasus di mana GLTF lebih besar dari aslinya, misalnya, file FBX, tetapi dalam kebanyakan kasus itu. </li><li>  Kemudahan analisis data adalah root plus dari format ini.  Hirarki GLTF menggunakan JSON, dan geometri disimpan dalam bentuk biner, tidak perlu decoding! </li></ol><br><h2 id="sistema-koordinat-i-edinicy-izmereniya">  Mengkoordinasikan sistem dan unit </h2><br><p>  GLTF menggunakan sistem koordinat tangan kanan, yaitu, produk silang + X dan + Y memberi + Z, di mana + Y adalah sumbu atas.  Bagian depan aset 3D GLTF menghadap ke sumbu + Z.  Satuan pengukuran untuk semua jarak linear adalah meter, sudut diukur dalam radian, dan rotasi positif benda berlawanan arah jarum jam.  Transformasi node dan jalur saluran animasi adalah vektor tiga dimensi atau angka empat dengan tipe data dan semantik berikut: </p><br><p>  <strong>terjemahan</strong> : vektor tiga dimensi yang berisi terjemahan sepanjang sumbu x, y, dan z <br>  <strong>rotasi</strong> : angka empat (x, y, z, w), di mana w adalah skalar <br>  <strong>skala</strong> : vektor tiga dimensi yang mengandung faktor penskalaan x, y, dan z <br><img src="https://habrastorage.org/getpro/habr/post_images/6ae/873/435/6ae873435487db304a902cfb4f080387.png" alt="gambar"></p><br><h2 id="gltf---vzglyad-iznutri">  GLTF - tampilan dalam </h2><br><p>  Seperti disebutkan di atas, GLTF, sebagai suatu peraturan, terdiri dari 2 file: yang pertama dengan format .gltf, yang menyimpan struktur adegan 3D dalam bentuk JSON dan file ke-2 dengan format .bin, yang menyimpan langsung semua data adegan ini. </p><br><p>  Struktur format sangat hierarkis dan memiliki bentuk berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/798/479/f31/798479f318326cba199da97f7570320c.png" alt="gambar"></p><br><p>  Berbicara lebih lanjut tentang struktur, saya akan menggunakan contoh file GLTF yang paling sederhana, yang menyimpan 1 segitiga satu sisi dengan bahan default.  Jika Anda mau, maka Anda dapat menyalinnya dan menempelkannya ke penampil GLTF untuk "merasakan" isi file secara pribadi.  Dalam latihan saya, saya menggunakan yang berbeda, tetapi memutuskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , yang menggunakan Three.js di bawah tenda.  Juga pilihan yang baik adalah menggunakan Visual Studio Code dengan plugin GLTF.  Jadi Anda akan memiliki pilihan segera dari 3 mesin: Babylon.js, Cesium, Three.js </p><br><h2 id="scene-i-node-elementy">  Elemen Scene dan Node </h2><br><p>  Hal pertama yang pertama adalah simpul utama yang disebut Scene.  Ini adalah titik root dalam file tempat semuanya dimulai.  Node ini berisi larik adegan yang GLTF simpan dan pilihan yang akan dimuat secara default setelah membuka file.  Konten adegan 3D dimulai dengan objek berikutnya, yang disebut "Node".  Array adegan dan node disebutkan tidak sia-sia, karena  kemampuan untuk menyimpan beberapa adegan dalam satu file diimplementasikan, tetapi dalam praktiknya mereka mencoba untuk menyimpan satu adegan dalam satu file. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"scenes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"mesh"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"scene"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Setiap node adalah "titik masuk" untuk menggambarkan objek individual.  Jika objek tersebut kompleks dan terdiri dari beberapa jerat, maka objek tersebut akan dijelaskan oleh simpul "induk" dan "anak".  Sebagai contoh, sebuah mobil, yang terdiri dari badan dan roda, dapat digambarkan sebagai berikut: simpul utama menggambarkan mobil dan, khususnya, tubuhnya.  Node ini berisi daftar "child node", yang, pada gilirannya, menjelaskan komponen yang tersisa, seperti, misalnya, roda.  Semua elemen akan diproses secara rekursif.  Node dapat memiliki animasi TRS (terjemahan, rotasi, skala alias perpindahan, rotasi, dan penskalaan).  Selain fakta bahwa transformasi tersebut secara langsung mempengaruhi mesh itu sendiri, mereka juga mempengaruhi node anak dengan cara yang persis sama.  Selain semua hal di atas, saya pikir perlu menyebutkan bahwa "kamera" internal, jika ada, yang bertanggung jawab untuk menampilkan objek dalam bingkai untuk pengguna, juga melekat pada objek Node.  Objek merujuk satu sama lain menggunakan atribut yang sesuai: scene memiliki atribut node, objek node memiliki atribut mesh.  Untuk pemahaman yang lebih sederhana, semua hal di atas diilustrasikan dalam gambar berikut. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/53d/e95/3af/53de953af178091e6a696c12530b38a8.png" alt="gambar"></p><br><h2 id="buffer-bufferview-i-accessor">  Buffer, BufferView, dan Accessor </h2><br><p>  Objek penyangga berarti penyimpanan biner, tidak diolah, data tanpa struktur, tanpa warisan, tanpa nilai.  Buffer menyimpan informasi tentang geometri, animasi, dan skinning.  Keuntungan utama dari data biner adalah bahwa ia diproses dengan sangat efisien oleh GPU, seperti  tidak memerlukan parsing tambahan, kecuali, mungkin, dekompresi.  Data dalam buffer dapat ditemukan oleh atribut URI, yang dengan jelas membuatnya jelas di mana data berada dan hanya ada 2 opsi: apakah data disimpan dalam file eksternal dengan format .bin, atau mereka tertanam di dalam JSON itu sendiri.  Dalam kasus pertama, URI berisi tautan ke file eksternal, dalam hal ini, folder tempat file GLTF berada dianggap sebagai root.  Dalam kasus kedua, file akan memiliki format .glb, yang merujuk kita ke yang lebih ringkas, dalam hal jumlah file, saudara kembar GLTF, format GLB.  Data dalam file biner disimpan apa adanya, byte-by-byte. </p><br><img src="https://habrastorage.org/webt/ls/9i/51/ls9i51hrvcaoxqmd5g8evlt3bou.png"><br><p>  JSON dalam contoh segitiga kami akan terlihat seperti ini: <br>  Contoh buffer yang disandikan base64: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA="</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">44</span></span> } ],</code> </pre> <br><p>  Jika Anda memiliki file eksternal, maka JSON akan mengonversi tampilan menjadi sebagai berikut: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"duck.bin"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">102040</span></span> } ],</code> </pre> <br><p>  Blok Buffer juga memiliki atribut byteLength tambahan, yang menyimpan nilai ukuran buffer. </p><br><p>  Langkah pertama dalam menyusun data dari buffer adalah objek BufferView.  BufferView dapat disebut "irisan" informasi dari Buffer, yang ditandai dengan pergeseran byte tertentu dari awal buffer.  "Iris" ini dijelaskan menggunakan 2 atribut: "pergeseran" dihitung dari awal buffer baca dan panjang irisan itu sendiri.  Contoh sederhana beberapa objek BufferView untuk menggambarkan penggunaannya berdasarkan contoh kami: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"bufferViews"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34963</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34962</span></span> } ],</code> </pre> <br><p>  Seperti yang Anda lihat, contoh ini berisi 4 atribut utama: </p><br><ol><li>  <strong>Buffer</strong> menunjuk ke indeks buffer (nomor urut dalam array buffer dimulai dari 0). </li><li>  <strong>byteOffset</strong> - mendefinisikan "shift" asal dalam byte untuk "slice" ini </li><li>  <strong>byteLength</strong> - mendefinisikan panjang "slice" </li><li>  <strong>target</strong> - mendefinisikan jenis data yang terkandung dalam bufferView <br>  BufferView pertama berisi 6 byte pertama buffer dan tidak memiliki pergeseran.  Dengan "cut" kedua, semuanya menjadi sedikit lebih rumit: seperti yang Anda lihat, shiftnya 8m byte, bukan 6 yang diharapkan.  2 byte ini kosong dan ditambahkan selama proses pembuatan buffer berkat proses yang disebut "padding".  Perlu untuk nilai untuk menyesuaikan nilai byte batas ke 4 byte.  Trik ini diperlukan untuk membaca data dari buffer dengan lebih cepat dan lebih mudah. </li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/300/8ea/c51/3008eac517a098df5794092bbce27af6.png" alt="gambar"></p><br><p>  Perlu dikatakan beberapa kata tentang atribut target.  Ini digunakan untuk mengklasifikasikan jenis informasi yang dirujuk oleh bufferView.  Hanya ada 2 opsi: baik itu nilai 34962, yang digunakan untuk merujuk pada atribut vertex (atribut vertex - 34962 - ARRAY_BUFFER) atau 34963, yang digunakan untuk indeks titik (indeks titik - 34963 - ELEMENT_ARRAY_BUFFER).  Sentuhan terakhir untuk memahami dan menyusun semua informasi dalam Buffer adalah objek Accessor. </p><br><p>  <strong>Accessor</strong> adalah objek yang mengakses BufferView dan berisi atribut yang menentukan jenis dan lokasi data dari BufferView.  Tipe data accessor dikodekan dalam tipe dan tipe komponen.  Nilai atribut type adalah string dan memiliki nilai berikut: SCALAR untuk nilai skalar, VEC3 untuk vektor 3 dimensi dan MAT4 untuk matriks 4x4 atau angka empat, yang digunakan untuk menggambarkan rotasi. </p><br><p>  Jenis Komponen pada gilirannya menunjukkan jenis komponen dari data ini.  Ini adalah konstanta GL, yang dapat memiliki nilai seperti 5126 (FLOAT) atau 5123 (UNSIGNED_SHORT), misalnya, untuk menunjukkan bahwa elemen memiliki titik apung, dll. </p><br><p>  Berbagai kombinasi properti ini dapat digunakan untuk menggambarkan tipe data yang berubah-ubah.  Contoh berdasarkan segitiga kami. </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"accessors"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"SCALAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] }, { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5126</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"VEC3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ] } ],</code> </pre> <br><p>  Mari kita menganalisis atribut yang diwakili dalam JSON: </p><br><ol><li>  <strong>bufferView</strong> - menunjukkan nomor urut BufferView dari array BufferView yang digunakan Accessor.  BufferView, pada gilirannya, menyimpan informasi tentang indeks. </li><li>  <strong>byteOffset</strong> - byte shift untuk mulai membaca data dari Accessor saat ini.  Beberapa objek Accessor dapat merujuk satu BufferView. </li><li>  <strong>componentType</strong> adalah konstanta yang menunjukkan jenis elemen.  Ini dapat memiliki nilai 5123, yang sesuai dengan tipe data UNSIGNED_SHORT, atau 5126 untuk FLOAT. </li><li>  <strong>count</strong> - menampilkan berapa banyak elemen yang disimpan dalam buffer. </li><li>  <strong>type</strong> - mendefinisikan tipe data: skalar, vektor, matriks. </li><li>  atribut maksimum dan minimum yang menentukan nilai minimum dan maksimum posisi elemen-elemen ini dalam ruang. </li></ol><br><h2 id="mesh">  Mesh </h2><br><p>  Objek <strong>jerat</strong> berisi informasi tentang jerat yang terletak di tempat kejadian.  Satu node (objek node) hanya dapat menyimpan 1 mesh.  Setiap objek bertipe mesh berisi array bertipe mesh. Priitif, pada gilirannya, primitif adalah objek primitif (misalnya, segitiga) yang terdiri dari mesh itu sendiri.  Objek ini mengandung banyak atribut tambahan, tetapi semua ini melayani satu tujuan - penyimpanan informasi yang benar tentang tampilan objek.  Atribut utama dari mesh: </p><br><ol><li>  <strong>POSISI</strong> - posisi simpul sepanjang sumbu XYZ </li><li>  <strong>NORMAL</strong> - Normalisasi Vertikal XYZ Normal </li><li>  <strong>TANGENT</strong> - XYZW garis singgung dari simpul.  W menunjukkan di mana tangen diarahkan dan memiliki nilai +1 atau -1. </li><li>  <strong>TEXCOORD_0</strong> - Koordinat tekstur UV.  Beberapa set dapat disimpan. </li><li>  <strong>COLOR_0</strong> - RGB atau warna RGBA dari simpul. </li><li>  <strong>JOINTS_0</strong> - atribut ini berisi indeks sendi / Sendi dari array sendi yang sesuai, yang harus memengaruhi vertex (vertex). </li><li>  <strong>WEIGHTS_0</strong> - data atribut ini menentukan bobot yang menunjukkan seberapa besar sendi mempengaruhi verteks. </li><li>  <strong>bobot</strong> - atribut yang bertanggung jawab atas bobot morphing. </li><li>  <strong>material</strong> - berisi indeks, yang merupakan jumlah material dalam array Material </li></ol><br><p>  Objek ini akan memiliki bentuk berikut untuk kasus kami: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"meshes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"primitives"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"POSITION"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"indices"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ] } ],</code> </pre> <br><p>  Sayangnya, karena pembatasan, semua materi tidak cocok menjadi satu artikel, sehingga sisanya dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di artikel kedua</a> , di mana kami akan mempertimbangkan artefak yang tersisa: <strong>Bahan, Tekstur, Animasi, Kulit dan Kamera</strong> , serta mengumpulkan file GLTF yang berfungsi minimal. </p><br><p>  Lanjutan di bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/en/post/448298/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448220/">https://habr.com/ru/post/id448220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448210/index.html">Meriam untuk satelit, blaster dan kapal tenaga surya: proyek yang aneh dan paradoks</a></li>
<li><a href="../id448212/index.html">Protokol AIBUS Cina dan reaktor kimia laboratorium</a></li>
<li><a href="../id448214/index.html">ES6 Proxy dalam praktiknya</a></li>
<li><a href="../id448216/index.html">Menyiapkan perakitan proyek yang nyaman di Visual Studio</a></li>
<li><a href="../id448218/index.html">Keamanan MFP Baru: imageRUNNER ADVANCE III</a></li>
<li><a href="../id448222/index.html">GPU, akselerator heksagonal, dan aljabar linier</a></li>
<li><a href="../id448224/index.html">AppsConf untuk mengatur semuanya</a></li>
<li><a href="../id448226/index.html">Mencari yang sangat (topik laporan untuk AppsConf)</a></li>
<li><a href="../id448228/index.html">Jenis-jenis pemodelan. Dasar-dasar Sculpting, Retopology, dan Sweep</a></li>
<li><a href="../id448230/index.html">Mengelola Kontinuitas Bisnis dengan ClearView</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>