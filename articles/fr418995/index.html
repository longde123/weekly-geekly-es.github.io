<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏻 😌 😘 Pourquoi ai-je rippé un CD 300 fois 🍭 🐋 🎡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je collectionne de la musique: j'achète des CD, les numérise avec Exact Audio Copy et je numérise les couvertures et les encarts. Parfois, ce n'est pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi ai-je rippé un CD 300 fois</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418995/"> Je collectionne de la musique: j'achète des CD, les numérise avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exact Audio Copy</a> et je numérise les couvertures et les encarts.  Parfois, ce n'est pas facile si le CD est sorti en édition limitée à l'étranger il y a 10 ans.  La chose la plus difficile est si le CD a un défaut de fabrication - et que certaines pistes ne peuvent pas être lues. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/e32/a86/6f5e32a86569ad14e42c0ea28a8de301.jpg" align="left">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'</a> album d'arrangements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour</a> piano <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'Altneuland</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">帰 る べ き 城</a> est sorti en 2005.  Je l'ai trouvé trois ans plus tard (probablement sur YouTube), j'ai téléchargé la meilleure copie - et l'ai mise sur la liste des futurs achats.  Les progrès récents de la technologie du courrier international ont permis d’acheter un disque usagé l’année dernière.  Malheureusement, aucun de mes lecteurs de CD n'a pu lire la piste numéro 3. Cela se produit souvent lors de l'achat de vieux disques, en particulier lorsqu'ils sont passés par le centre d'expédition international USPS.  Je l'ai mis de côté et j'ai commencé à chercher une autre copie que j'ai trouvée le mois dernier.  Il est arrivé vendredi - et j'ai immédiatement essayé de le déchirer.  Mais avec poussé avec <i>exactement la même erreur</i> .  Il semble que ce ne soit pas une question d'usure ou de dommage - le disque est probablement sorti défectueux dès l'usine. <br><br>  ADDITION: Après l'enquête, je ne crois plus que ce soit un défaut d'usine.  Lorsque j'écris le début ou la fin d'une mauvaise piste sur un CD-R vide et que je le copie, le ripper produit la même erreur!  Essayez-le vous-même avec le fichier <a href="">minimal.flac</a> . <br><a name="habracut"></a><br>  Il reste deux options: essayez un jour de trouver une autre copie qui sera copiée avec succès (peu probable), ou restaurez en quelque sorte les données audio originales à partir de disques endommagés.  Vous savez déjà quelle option j'ai choisie. <br><br><h1>  Comment fonctionne le ripper </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/9b0/ff6/69e9b0ff62e391da0701a6a4cd02b57d.png"><br>  <i><font color="gray">EAC n'a pas pu lire la piste n ° 3 du disque [帰 る べ き 城]</font></i> <br><br>  Les CD stockent des données numériques, mais il existe une interface complètement analogique entre les disques, les lasers et les diodes optiques.  Les erreurs de lecture se produisent pour diverses raisons: supports sales, rayures sur la couche de protection en polycarbonate, vibrations du lecteur lui-même.  Les codes de correction d'erreur primitifs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la norme CDDA</a> aident à minimiser la distorsion du son sur les disques rarement utilisés, mais ne sont pas en mesure de restaurer complètement le flux binaire sur un CD avec un grand nombre d'erreurs.  Les rippers modernes résolvent le problème avec deux méthodes de détection d'erreur importantes: la lecture redondante et AccurateRip. <br><br>  La page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EAC: Technologie d'extraction</a> décrit comment l'EAC produit des lectures redondantes: <br><br><blockquote>  En mode sans échec, le programme lit chaque secteur au moins deux fois [...] En cas d'erreur (lecture ou synchronisation), le programme continue de lire ce secteur jusqu'à ce que 8 tentatives sur 16 soient identiques.  Une telle procédure est effectuée au plus une, trois ou cinq fois (en fonction de la qualité de récupération d'erreur sélectionnée).  Donc dans le pire des cas, les mauvais secteurs sont lus 82 fois! </blockquote><br>  Tout est simple.  Si une demande de lecture renvoie parfois des données incorrectes, relisez-les, puis soyez particulièrement prudent si les deux premières lectures donnent des résultats différents.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AccurateRip</a> utilise le même principe, mais de manière distribuée: les rippers envoient des sommes de contrôle des fichiers audio copiés à ce service.  L'idée est que si un millier de personnes copient une piste avec les mêmes bits, c'est probablement la bonne rip. <br><br>  Cet article explique ce qu'il faut faire si les deux méthodes ne peuvent pas aider.  L'EAC ne donne pas de résultat si chaque lecture renvoie des données différentes, et dans la base de données AccurateRip, il n'y a qu'un seul enregistrement sur un disque rare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[1]</a> <a name="1_1"></a>  . <br><br><h1>  «J'ai passé dix mille passages, dix mille passages pour te voir» </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/1ab/850/44a1ab850b96409640f45e9425f73652.jpg"><br>  <i><font color="gray">Lecteurs optiques Asus, LG, Lite-On, Pioneer et OEM inconnu</font></i> <br><br>  Si le CD n'est pas copié, il est logique d'utiliser un autre lecteur.  Parfois, un modèle particulier est plus condescendant par rapport aux spécifications CDDA, ou existe-t-il un meilleur firmware pour corriger les erreurs, ou autre chose.  Le forum DBpoweramp a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une cote de précision de lecteur de CD / DVD</a> pour sélectionner le lecteur rip le plus approprié. <br><br>  Samedi matin, j'ai acheté cinq nouveaux lecteurs de CD de différents fabricants <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[2]</a> <a name="2_2"></a>  , Je les ai tous essayés - et j'en ai trouvé un qui pouvait garder la synchronisation sur une piste rythmique.  Malheureusement, la confirmation du rip n'a pas pu être obtenue - entre tous les rips, il y avait environ 20 000 octets différents. <br><br>  Mais maintenant, j'avais des fichiers .wav sur le disque, et vous pouvez en bénéficier.  J'ai pensé que les erreurs de lecture sur une mauvaise piste étaient quelque peu proches de la «bonne».  Par conséquent, il est logique de faire plusieurs déchirures et de trouver une valeur de «consensus» pour les octets instables.  Cette approche a finalement réussi, mais elle a demandé beaucoup plus de travail que ce à quoi je m'attendais. <br><br><h1>  «La quantité va dans la qualité» </h1><br>  J'ai commencé par copier le disque à plusieurs reprises sur l'un des lecteurs, écrire toutes les valeurs pour chaque octet et déclarer l'erreur «corrigeable» si plus de la moitié des déchirures produit une valeur d'octet spécifique pour cette position.  Le début était bon: le nombre d'erreurs non corrigibles est passé de près de ~ 6900 octets à N = 4 à ~ 5000 octets à N = 10.  Le bénéfice de chaque rip supplémentaire a diminué au fil du temps, jusqu'à ce que vers N = 80, le nombre d'erreurs non corrigibles se stabilise à ~ 3700.  J'ai arrêté de déchirer à N = 100. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/aaa/809/b87aaa809a043eaeaa2d049258fe0cb9.png"><br>  <i><font color="gray">Erreurs fixes et fatales sur le nombre de rip</font></i> <br><br>  Ensuite, j'ai essayé de copier le disque 100 fois sur le deuxième lecteur et d'utiliser deux cartes de correction pour «remplir» les positions d'erreur non corrigibles du premier lecteur.  Mais cela n'a pas fonctionné: sur chaque disque il y avait des milliers de corrections qui ne correspondaient pas à des corrections sur l'autre!  Il s'avère que le bruit ne peut pas être éliminé en le combinant avec une autre source de bruit mais liée. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/911/6d5/c33/9116d5c339461cb286edc4537c712a71.png"><br>  <i><font color="gray">La même chose, mais pour deux disques à validation croisée</font></i> <br><br><h1>  Art artisanal </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/829/554/ec78295544b0a161b472598114e2be2d.jpg"><br><br>  Il existe une autre bonne ressource sur le site Web de l'EAC: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">test de qualité DAE</a> , qui détermine la qualité du micrologiciel d'un lecteur en fonction du niveau d'erreurs corrigé.  Il s'agit d'une gestion des erreurs de niveau inférieur lorsque le lecteur <i>corrige les</i> erreurs de lecture plutôt que de simplement les signaler.  Le hic est que le «mode sans échec» du CAE n'est disponible que lorsque vous désactivez ce code de correction d'erreur intégré, ce qui suggère qu'il ne fonctionne pas correctement. <br><br>  J'ai préparé le test en gravant le fichier .wav sur CD-R, en mettant en évidence le secteur exact sur la surface de données et en le peignant soigneusement avec un marqueur noir.  Ce sont des erreurs fatales garanties sur un modèle déterministe. <br><br>  J'ai testé tous les disques et obtenu deux résultats intéressants: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/4c6/f55/11f4c6f554062ec91d1f5d4160b40a43.png"><br><br>  J'ai utilisé le lecteur Lite-On pour contourner les erreurs de synchronisation.  Il mâcha le marqueur magique avec plaisir, mais il était très confus par les lignes droites sur la surface des données.  Vous pouvez voir comment au lieu de trois pics séparés sur la droite, il y a un blob géant défaillant. <br><br> <code>Errors total Num : 206645159 <br> Errors (Loudness) Num : 965075 - Avg : -21.7 dB(A) - Max : -5.5 dB(A) <br> Error Muting Num : 154153 - Avg : 99.1 Samples - Max : 3584 Samples <br> Skips Num : 103 - Avg : 417.3 Samples - Max : 2939 Samples <br> <br> Total Test Result : 45.3 points (of 100.0 maximum)</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/07b/beb/2d7/07bbeb2d7534a3eb062e176c8b059182.png"><br><br>  Le lecteur Pioneer a reçu le score DAE le plus élevé.  À mon avis, le graphique n'a pas l'air spécial, mais l'outil d'analyse a dit que c'est le meilleur firmware pour corriger les erreurs dans mon petit ensemble. <br><br> <code>Errors total Num : 2331952 <br> Errors (Loudness) Num : 147286 - Avg : -77.2 dB(A) - Max : -13.2 dB(A) <br> Error Muting Num : 8468 - Avg : 1.5 Samples - Max : 273 Samples <br> Skips Num : 50 - Avg : 6.5 Samples - Max : 30 Samples <br> <br> Total Test Result : 62.7 points (of 100.0 maximum)</code> <br> <br><h1>  "A partir d'un certain moment, les chiffres comptent" </h1><br>  Comment utiliser le firmware Pioneer avec une bonne correction d'erreurs si le "mode sans échec" EAC l'ignore?  Très simple: basculez le CAE en "mode rafale" et écrivez sur le disque le flux binaire sous la forme dans laquelle le micrologiciel les signale.  Comment alors transformer ce tas de fichiers .wav non vérifiés en un fichier de bonne qualité, comme en "mode sans échec"?  Oui, le même outil d'analyse d'erreur que nous avons utilisé dans les déchirures avec Lite-On! <br><br>  Après quelques paramètres de configuration EAC et après une centaine de déchirures, nous obtenons un si beau diagramme. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/323/e9f/405323e9fad21af9069c1983e25a7025.png"><br>  <i><font color="gray">Erreurs fixes et non corrigibles sur le nombre de déchirures (Pioneer)</font></i> <br><br>  Ce qui peut être noté: <br><br><ul><li>  Les erreurs de bits fatales tendent rapidement à zéro, mais ne l'atteignent jamais. </li><li>  Un énorme saut dans les bugs corrigés en 53-54 déchirures. </li><li>  Le nombre d'erreurs avant et après ce grand saut ne change pratiquement pas, ce qui indique des zones de stabilité dans les données copiées. </li></ul><br><h1>  0xA595BC09 </h1><br>  En utilisant une correction d'erreur presque parfaite de Pioneer, j'ai généré un fichier de «meilleure estimation» et j'ai commencé à le comparer avec les déchirures de Pioneer.  Comme prévu, plusieurs sections de faible qualité ont été découvertes, que j'ai corrigées en effectuant 10 autres déchirures: <br><br> <code>$ for RIP_ID in $(seq -w 1 100); do echo -n "rip$RIP_ID: "; cmp -l analysis-out.wav rips-cd1-pioneer/rip${RIP_ID}/*.wav | wc -l ; done | sort -rgk2 | head -n 10 <br> rip054: 2865 <br> rip099: 974 <br> rip007: 533 <br> rip037: 452 <br> rip042: 438 <br> rip035: 404 <br> rip006: 392 <br> rip059: 381 <br> rip043: 327 <br> rip014: 323</code> <br> <br>  J'ai aussi trouvé quelque chose de vraiment intéressant: plusieurs déchirures ont produit <i>exactement le</i> même contenu!  Rappelez-vous, c'est précisément le critère de réussite dans le CA "mode sans échec".  <code>shncat -q -e | rhash --print="%C"</code>  <code>shncat -q -e | rhash --print="%C"</code> utilisé pour calculer la somme de contrôle CRC32 des données audio brutes: c'est ce que l'EAC utilise. <br><br> <code>$ for wav in rips-cd1-pioneer/*/*.wav; do shncat "$wav" -q -e | rhash --printf="%C $wav\n" - ; done | sort -k1 <br> [...] <br> 9DD05FFF rips-cd1-pioneer/rip059/rip.wav <br> 9F8D1B53 rips-cd1-pioneer/rip072/rip.wav <br> A2EA0283 rips-cd1-pioneer/rip082/rip.wav <br> A595BC09 rips-cd1-pioneer/rip021/rip.wav <br> A595BC09 rips-cd1-pioneer/rip022/rip.wav <br> A595BC09 rips-cd1-pioneer/rip023/rip.wav <br> A595BC09 rips-cd1-pioneer/rip024/rip.wav <br> A595BC09 rips-cd1-pioneer/rip025/rip.wav <br> A595BC09 rips-cd1-pioneer/rip026/rip.wav <br> A595BC09 rips-cd1-pioneer/rip027/rip.wav <br> A595BC09 rips-cd1-pioneer/rip028/rip.wav <br> A595BC09 rips-cd1-pioneer/rip030/rip.wav <br> A595BC09 rips-cd1-pioneer/rip031/rip.wav <br> A595BC09 rips-cd1-pioneer/rip040/rip.wav <br> A595BC09 rips-cd1-pioneer/rip055/rip.wav <br> A595BC09 rips-cd1-pioneer/rip058/rip.wav <br> AA3B5929 rips-cd1-pioneer/rip043/rip.wav <br> ABAAE784 rips-cd1-pioneer/rip033/rip.wav <br> [...]</code> <br> <br>  Pendant ce temps, des déchirures répétées de sections de faible qualité nous ont permis de terminer l'analyse avec zéro erreur fatale.  Et quand j'ai vérifié ce fichier, il y avait exactement le même contenu audio que dans le rip "normal"!  Cela suffit pour déclarer la victoire. <br><br>  Je suis sûr à 99% que j'ai bien copié ce CD problématique, et 0xA595BC09 est le bon montant de CRC pour la piste numéro 3. <br><br><h1>  Annexe A: compare.rs </h1><br>  J'ai utilisé cet outil pour calculer les erreurs d'octets probables.  Il n'est pas destiné à une utilisation à long terme, il est donc un peu moche, mais il peut être intéressant pour ceux qui sont tombés sur cette page, résolvant le même problème. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> memmap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::mpsc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> memmap::Mmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHUNK_SIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspect_positions</span></span></span></span>( mmaps: &amp;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt;, start_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, end_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> positions = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start_idx..end_idx { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { byte = file_content[ii]; first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> byte != file_content[ii] { positions.push(ii); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } positions } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = env::args().collect(); args.remove(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> files: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;fs::File&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmaps: HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt; = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = fs::File::open(&amp;filename).unwrap(); files.push(file); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { Mmap::map(files.last().unwrap()).unwrap() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; size = mmap.len(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(size == mmap.len()); } mmaps.insert(filename, mmap); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (suspects_tx, suspects_rx) = mpsc::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> start_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = sync::Arc::new(mmaps); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_start_idx = start_idx; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_end_idx = cmp::min(start_idx + CHUNK_SIZE, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_idx == t_end_idx { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = mmaps_ref.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects_tx = suspects_tx.clone(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects = suspect_positions(mmaps_ref.as_ref(), t_start_idx, t_end_idx); suspects_tx.send(suspects).unwrap(); }); start_idx = t_end_idx; } <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>(suspects_tx); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects_rx { suspects.append(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk); } suspects.sort(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{{\"files\": ["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first_file = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps_ref.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_file { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; first_file = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{{\"name\": \"{}\", \"suspect_bytes\": ["</span></span>, file_comma, file_name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ii, position) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects.iter().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ii == suspects.len() - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"[{}, {}]{}"</span></span>, position, file_content[*position], comma); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); }</code> </pre> <br>  1. <a name="1"></a>  Dans ce seul enregistrement AccurateRip, le CRC pour toutes les pistes sauf la piste numéro 3 correspond à mon disque: la somme est 0x84B9DD1A et j'ai 0xA595BC09.  Je soupçonne que le ripper n'a pas compris qu'il avait une mauvaise conduite.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[retour]</a> <br><br>  2. <a name="2"></a>  La question évidente lors de l'achat d'un lecteur de CD ou de DVD en 2018 est: "Merde, où puis-je les acheter?"  Et j'avais besoin non pas d'un, mais de <i>plusieurs</i> <i>marques différentes</i> .  Je ne connais qu'un seul magasin à proximité qui dispose de lecteurs de DVD de 5,25 pouces. Un seul magasin est assez grand pour ne pas regretter l'espace de stockage pour de tels lecteurs, et assez étrange pour ne pas sembler déplacé là-bas. Bien sûr, je parler de Frys Electronics. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[retour]</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418995/">https://habr.com/ru/post/fr418995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418979/index.html">Alors que je traversais le pays en avion, mettant en œuvre un projet pour plusieurs milliers d'emplois</a></li>
<li><a href="../fr418981/index.html">Méthodes numériques pour résoudre des équations elliptiques</a></li>
<li><a href="../fr418985/index.html">Analytique et conception dans leur ensemble</a></li>
<li><a href="../fr418987/index.html">Firefox contourne facilement la protection dans la nouvelle interface Gmail</a></li>
<li><a href="../fr418991/index.html">Le microfilm existera pendant un demi-millénaire</a></li>
<li><a href="../fr418997/index.html">Contribution réelle à une véritable source ouverte</a></li>
<li><a href="../fr418999/index.html">[Annonce, Peter] Rencontre JUG.ru avec Andrei Belyaev et Alexei Stukalov - Troll opprime CUBA: FAQ</a></li>
<li><a href="../fr419001/index.html">5 «super compétences» nécessaires au travail de demain</a></li>
<li><a href="../fr419003/index.html">Résumé des nouvelles de la blockchain</a></li>
<li><a href="../fr419005/index.html">Excursion au poste 220/110/20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>