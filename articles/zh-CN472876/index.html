<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📏 🙅 🕒 复杂性瀑布与按需架构 👜 ☺️ 🙋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在谈论“错误代码”时，人们几乎肯定会在其他流行问题中指“复杂代码”。 关于复杂性的事情是无处不在。 有一天，您开始了相当简单的项目，另一天，您发现了它的废墟。 而且没人知道它是如何发生的以及何时发生的。 


 但是，这最终是有原因的！ 代码复杂度通过两种可能的方式进入您的代码库：大块和增量添加。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>复杂性瀑布与按需架构</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472876/"><p><img src="https://habrastorage.org/webt/g9/_9/wk/g9_9wkgu4h6i8xyelaq9p5nwmjy.png" alt="商标"></p><br><p> 在谈论“错误代码”时，人们几乎肯定会在其他流行问题中指“复杂代码”。 关于复杂性的事情是无处不在。 有一天，您开始了相当简单的项目，另一天，您发现了它的废墟。 而且没人知道它是如何发生的以及何时发生的。 </p><br><p> 但是，这最终是有原因的！ 代码复杂度通过两种可能的方式进入您的代码库：大块和增量添加。 而且人们不善于审查和发现它们两者。 </p><a name="habracut"></a><br><p> 当有大量代码进入时，审阅者将被要求查找代码复杂的确切位置以及处理方法。 然后，审查将必须证明这一点：为什么此代码首先很复杂。 其他开发人员可能会不同意。 我们都知道这类代码审查！ </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/198/8ff/e0e/1988ffe0e3d5dc3b29b4743630b52e06.png" alt="评论和评论比例的行数"></p><br><p>进入代码的第二种复杂性方法是增量加法：向现有函数提交一两行时。 很难注意到您的函数在一个提交之前就可以了，但是现在它太复杂了。 要真正发现它，需要花费很大的精力，复习技巧和良好的代码导航实践。 大多数人（像我一样！）缺乏这些技能，并允许复杂性定期输入代码库。 </p><br><p> 因此，如何防止代码变得复杂？ 我们需要使用自动化！ 让我们深入研究代码的复杂性以及找到并最终解决它的方法。 </p><br><p> 在本文中，我将指导您遍历复杂性生活的地方以及如何与之抗争。 然后，我们将讨论编写良好的简单代码和自动化如何为“连续重构”和“按需架构”开发风格提供机会。 </p><br><h2 id="complexity-explained"> 复杂性解释 </h2><br><p> 有人可能会问：“代码复杂性”到底是什么？ 虽然听起来很熟悉，但在理解复杂度的确切位置方面存在隐藏的障碍。 让我们从最原始的部分开始，然后转到更高层次的实体。 </p><br><p> 还记得本文被命名为“复杂性瀑布”吗？ 我将向您展示从最简单的原语到最高抽象的复杂性。 </p><br><p>我将使用<code>python</code>作为示例的主要语言，并使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>wemake-python-styleguide</code></a>作为主要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>wemake-python-styleguide</code></a>工具，以查找代码中的违规并阐明我的观点。 </p><br><h3 id="expressions"> 表达方式 </h3><br><p> 您的所有代码都包含简单的表达式，例如<code>a + 1</code>和<code>print(x)</code> 。 尽管表达式本身很简单，但是它们有时可能会在一定程度上引起代码的复杂性溢出。 示例：假设您有一个代表某些<code>User</code>模型的字典，并且您像这样使用它： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_username</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user[<span class="hljs-string"><span class="hljs-string">'email'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]) &gt; <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>][:<span class="hljs-number"><span class="hljs-number">12</span></span>] + <span class="hljs-string"><span class="hljs-string">'...'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'@'</span></span> + user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]</code> </pre> <br><p> 看起来很简单，不是吗？ 实际上，它包含两个基于表达式的复杂性问题。 它<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>overuses 'username'</code>字符串，</a>并使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">魔幻数字</a> <code>12</code> （为什么我们首先使用这个数字，为​​什么不使用<code>13</code>或<code>10</code> ？）。 很难自己找到所有这些东西。 更好的版本如下所示： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#: That's how many chars fit in the preview box. LENGTH_LIMIT: Final = 12 def format_username(user) -&gt; str: username = user['username'] if not username: return user['email'] elif len(username) &gt; LENGTH_LIMIT: # See? It is now documented return username[:LENGTH_LIMIT] + '...' return '@' + username</span></span></code> </pre> <br><p> 表达也有不同的问题。 我们还可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a>一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">过度使用的表达式</a> ：在各处使用<code>some_object.some_attr</code>属性而不是创建新的局部变量时。 我们也可能拥有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">过于复杂的逻辑条件</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">过于深入的点访问</a> 。 </p><br><p>  <strong>解决方案</strong> ：创建新的变量，参数或常量。 如果需要，请创建并使用新的实用程序功能或方法。 </p><br><h3 id="lines"> 线数 </h3><br><p> 表达式形成代码行（请不要将行与语句混淆：单个语句可以占用多行，并且多个语句可能位于一行上）。 </p><br><p> 线的第一个也是最明显的复杂性度量是其长度。 是的，您没听错。 这就是为什么我们（程序员）更喜欢遵循每行<code>80</code>字符的规则，而不是因为它<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以前</a>是在电传打字机中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a>的。 最近有很多关于它的谣言，说在2k19中使用<code>80</code>字符作为代码没有任何意义。 但是，那显然不是事实。 </p><br><p> 这个想法很简单。 行数为<code>160</code>字符时，逻辑的数量是行数为<code>80</code>字符时的逻辑数量的两倍。 这就是为什么应该设置并强制执行此限制。 请记住，这<em>不是样式选择</em> 。 这是一个复杂性指标！ </p><br><p> 第二种主线复杂性度量标准鲜为人知，使用较少。 这称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">琼斯复杂度</a> 。 它背后的想法很简单：我们在一行中计算代码（或<code>ast</code> ）节点以获取其复杂性。 让我们看一个例子。 这两行的复杂度从根本上不同，但字符的宽度完全相同： </p><br><pre> <code class="python hljs">print(first_long_name_with_meaning, second_very_long_name_with_meaning, third) print(first * <span class="hljs-number"><span class="hljs-number">5</span></span> + math.pi * <span class="hljs-number"><span class="hljs-number">2</span></span>, matrix.trans(*matrix), display.show(matrix, <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br><p> 让我们计算第一个节点：一个调用，三个名称。 总共四个节点。 第二个节点有21个<code>ast</code>节点。 好吧，区别很明显。 这就是为什么我们使用琼斯复杂度度量标准来允许第一条长行并基于内部复杂性而不是仅基于原始长度来禁止第二条长行。 </p><br><p> 琼斯复杂度得分高的线怎么办？ </p><br><p>  <strong>解决方案</strong> ：将它们分成几行，或创建新的中间变量，实用函数，新类等。 </p><br><pre> <code class="python hljs">print( first * <span class="hljs-number"><span class="hljs-number">5</span></span> + math.pi * <span class="hljs-number"><span class="hljs-number">2</span></span>, matrix.trans(*matrix), display.show(matrix, <span class="hljs-number"><span class="hljs-number">2</span></span>), )</code> </pre> <br><p> 现在，它更具可读性！ </p><br><h3 id="structures"> 结构体 </h3><br><p> 下一步是分析由线条和表达式组成的语言结构，如<code>if</code> ， <code>for</code> ， <code>with</code> ，等。 我不得不说，这一点是非常特定于语言的。 我还将使用<code>python</code>展示该类别的一些规则。 </p><br><p> 我们将从<code>if</code>开始。  <code>if</code>比一个好孩子更容易呢？ 实际上， <code>if</code>真的开始变得棘手的话。 这是一个如何使用<code>if</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>reimplement switch</code></a>的示例： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(some, int): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, float): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, complex): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, str): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, bytes): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, list): ...</code> </pre> <br><p> 这段代码有什么问题？ 好吧，想象一下，我们应该涵盖数十种数据类型，包括我们尚不了解的海关数据类型。 然后，这个复杂的代码表明我们在这里选择了错误的模式。 我们需要重构代码以解决此问题。 例如，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>singledispatch</code></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">es</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>singledispatch</code></a> 。 他们做的一样，但是更好。 </p><br><p>  <code>python</code>永不停止逗我们。 例如，您可以编写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任意数量的case</a> ，这在思想上过于复杂和令人困惑： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> first(), second(), third(), fourth(): ...</code> </pre> <br><p> 您还可以使用任意数量的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>if</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>for</code></a>表达式编写理解，这可能导致复杂的，不可读的代码： </p><br><pre> <code class="python hljs">[ (x, y, z) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x_coords <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> y_coords <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> z_coords <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x + y &lt;= z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x + z &lt;= y <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y + z &lt;= x ]</code> </pre> <br><p> 将其与简单易读的版本进行比较： </p><br><pre> <code class="python hljs">[ (x, y, z) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, y, x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itertools.product(x_coords, y_coords, z_coords) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> valid_coordinates(x, y, z) ]</code> </pre> <br><p> 您还可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>multiple statements inside a try</code></a>案例中意外地包含<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>multiple statements inside a try</code></a> ，这是不安全的，因为它可以在预期的位置引发并处理异常： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: user = fetch_user() <span class="hljs-comment"><span class="hljs-comment"># Can also fail, but don't expect that log.save_user_operation(user.email) # Can fail, and we know it except MyCustomException as exc: ...</span></span></code> </pre> <br><p> 而且即使是10％的情况，您的<code>python</code>代码也可能会出错。 还有许多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多的边缘情况</a>需要跟踪和分析。 </p><br><p>  <strong>解决方案</strong> ：唯一可能的解决方案是为您选择的语言使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优质棉绒</a> 。 并重构此短绒棉突出的复杂场所。 否则，您将不得不重新发明轮子并为完全相同的问题设置自定义策略。 </p><br><h3 id="functions"> 功能介绍 </h3><br><p> 表达式，语句和结构形成函数。 这些实体的复杂性转化为功能。 这就是事情开始吸引人的地方。 因为函数实际上具有数十种复杂性指标：好坏。 </p><br><p> 我们将从最著名的代码开始： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">圈复杂度</a>和以代码行衡量的函数长度。 循环复杂度表明您的执行流程可以执行多少次：它几乎等于完全覆盖源代码所需的单元测试数。 这是一个很好的指标，因为它尊重语义并帮助开发人员进行重构。 另一方面，函数的长度是不好的指标。 由于我们已经知道，它与先前解释的琼斯复杂度度量标准不相称：多行比内部所有内容的大行更容易阅读。 我们将只关注好的指标，而忽略坏的指标。 </p><br><p> 根据我的经验，应该计算多个有用的复杂性指标，而不是常规函数的长度： </p><br><ul><li> 功能装饰器的数量； 越低越好 </li><li> 参数数量； 越低越好 </li><li> 批注数量； 越高越好 </li><li> 局部变量数； 越低越好 </li><li> 回报，收益，等待数量； 越低越好 </li><li> 语句和表达式的数量； 越低越好 </li></ul><br><p> 所有这些检查的组合实际上使您可以编写简单的函数（所有规则也适用于方法）。 </p><br><p> 当您尝试使用功能进行一些令人讨厌的事情时，您肯定会破坏至少一个指标。 这会让我们的小子失望，炸毁你的身材。 结果，您的功能将被保存。 </p><br><p>  <strong>解决方案</strong> ：当一个功能过于复杂时，您唯一需要解决的就是将该功能拆分为多个功能。 </p><br><h3 id="classes"> 班级 </h3><br><p> 函数之后的下一个抽象级别是类。 正如您已经猜到的那样，它们比函数还要复杂和灵活。 因为类内部可能包含多个函数（称为方法），并且具有其他独特功能，如继承和混合，类级属性和类级装饰器。 因此，我们必须将所有方法都检查为函数和类主体本身。 </p><br><p> 对于班级，我们必须衡量以下指标： </p><br><ul><li> 类装饰器的数量； 越低越好 </li><li> 基类数量； 越低越好 </li><li> 类级公共属性的数量； 越低越好 </li><li> 实例级公共属性的数量； 越低越好 </li><li> 方法数量； 越低越好 </li></ul><br><p> 如果其中任何一个过于复杂-我们都必须响起警报并使构建失败！ </p><br><p>  <strong>解决方案</strong> ：重构您失败的课程！ 将一个现有的复杂类拆分为几个简单的类，或创建新的实用程序函数并使用组合。 </p><br><p> 值得注意的是：还可以跟踪<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内聚</a>和耦合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">度量，</a>以验证OOP设计的复杂性。 </p><br><h3 id="modules"> 模组 </h3><br><p> 模块确实包含多个语句，函数和类。 正如您可能已经提到的，我们通常建议将函数和类拆分为新的函数和类。 这就是我们必须关注模块复杂性的原因：它实际上是从类和函数流入模块的。 </p><br><p> 要分析模块的复杂性，我们必须检查： </p><br><ul><li> 进口数量和进口名称； 越低越好 </li><li> 类和功能的数量； 越低越好 </li><li> 内部函数和类的平均复杂度； 越低越好 </li></ul><br><p> 如果是复杂的模块，我们该怎么办？ </p><br><p>  <strong>解决方案</strong> ：是的，您做对了。 我们将一个模块分成几个模块。 </p><br><h3 id="packages"> 配套 </h3><br><p> 软件包包含多个模块。 幸运的是，这就是他们所做的全部。 </p><br><p> 因此，包中的模块数量很快就会开始变得太大，因此最终您将拥有太多的模块。 这是可以在包中找到的唯一复杂性。 </p><br><p>  <strong>解决方案</strong> ：您必须将程序包分为子程序包和不同级别的程序包。 </p><br><h2 id="complexity-waterfall-effect"> 复杂性瀑布效应 </h2><br><p> 现在，我们已经涵盖了代码库中几乎所有可能的抽象类型。 我们从中学到了什么？ 到目前为止，主要的收获是，可以通过将复杂性提高到相同或更高的抽象级别来解决大多数问题。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9b6/8ad/453/9b68ad45340cdf61f51a8deb2c07930d.png" alt="复杂性瀑布"></p><br><p> 这使我们引出本文最重要的想法：不要让您的代码充满复杂性。 我将举几个例子说明它通常如何发生。 </p><br><p> 想象一下您正在实现一项新功能。 这是您所做的唯一更改： </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">+++ if user.is_active and user.has_sub() and sub.is_due(tz.now() + delta): --- if user.is_active and user.has_sub():</span></span></code> </pre> <br><p> 看起来还不错，我会在审核时通过此代码。 不会发生任何不良情况。 但是，我缺少的一点是复杂性溢出了这条线！ 这就是<code>wemake-python-styleguide</code>将报告的内容： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c87/b9e/0e5/c87b9e0e584a8cd01235e0ae7695a6c0.png" alt="wemake-python-styleguide-输出"></p><br><p> 好的，我们现在必须解决这种复杂性。 让我们创建一个新变量： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid: ... ... ...</code> </pre> <br><p> 现在，解决了线路复杂性。 但是，请稍等。 如果我们的函数现在变量太多了怎么办？ 因为我们创建了一个新变量，但没有先检查函数内部的编号。 在这种情况下，我们将不得不将此方法拆分为几个方法，如下所示： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._has_paid_sub(user, sub, delta): ... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_has_paid_sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user, sub, delta)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid ...</code> </pre> <br><p> 现在我们完成了！ 对不对 不，因为我们现在必须检查<code>Product</code>类的复杂性。 想象一下，自从我们创建了一个新的<code>_has_paid_sub</code>以来，它现在拥有太多的方法。 </p><br><p> 好的，我们运行linter来再次检查复杂性。 事实证明，我们的<code>Product</code>类现在确实太复杂了。 我们的行动？ 我们将其分为几类！ </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Policy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubcsriptionPolicy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Policy)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._has_paid_sub(user, sub, delta): ... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_has_paid_sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user, sub, delta)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> _purchasing_policy: Policy ... ...</code> </pre> <br><p> 请告诉我这是最后一次迭代！ 好吧，很抱歉，但是我们现在必须检查模块的复杂性。 你猜怎么着？ 现在我们有太多的模块成员。 因此，我们必须将模块拆分为单独的模块！ 然后我们检查程序包的复杂性。 并且也可能将其拆分为几个子包。 </p><br><p> 你看到了吗？ 由于定义良好的复杂性规则，我们的单行修改原来是一个包含几个新模块和类的巨大重构会话。 而且我们自己还没有做出一个决定：我们所有的重构目标都是由内部复杂性和揭示它的棉绒驱动的。 </p><br><p> 这就是我所说的“连续重构”过程。 您被迫进行重构。 总是 </p><br><p> 这个过程也有一个有趣的结果。 它使您可以拥有“按需架构”。 让我解释一下。 有了“按需架构”的理念，您总会从小做起。 例如，使用单个<code>logic/domains/user.py</code>文件。 然后您开始将所有与<code>User</code>相关的内容放到这里。 因为此时您可能不知道您的体系结构是什么样。 而且你不在乎。 您只有三种功能。 </p><br><p> 有些人陷入架构与代码复杂性陷阱之间。 从一开始，他们就可能使整个体系结构/服务/域层的体系结构过于复杂。 或者，它们可能会使源代码过于复杂，而没有明确的分隔。 像这样努力奋斗并生活多年（如果他们能够使用这样的代码生活多年！）。 </p><br><p>  “按需架构”的概念解决了这些问题。 当时间到来时，您从小处开始-拆分并重构事物： </p><br><ol><li> 您从<code>logic/domains/user.py</code>开始，然后将所有内容放入其中 </li><li> 稍后，当您具有足够的数据库相关内容时，可以创建<code>logic/domains/user/repository.py</code> /repository.py </li><li> 然后，当复杂性告诉您这样做时，将其拆分为<code>logic/domains/user/repository/queries.py</code>和<code>logic/domains/user/repository/commands.py</code> <code>logic/domains/user/repository/queries.py</code> </li><li> 然后使用<code>http</code>相关的内容创建<code>logic/domains/user/services.py</code> /services.py </li><li> 然后创建一个新的模块，称为<code>logic/domains/order.py</code> </li><li> 依此类推 </li></ol><br><p> 就是这样 它是平衡您的体系结构和代码复杂性的理想工具。 并获得您当前真正需要的尽可能多的体系结构。 </p><br><h2 id="conclusion"> 结论 </h2><br><p> 好的短毛绒比发现缺少逗号和错误的报价要多得多。 优良的短毛绒使您可以依靠它来进行体系结构决策，并帮助您进行重构过程。 </p><br><p> 例如， <code>wemake-python-styleguide</code>可能会帮助您解决<code>python</code>源代码的复杂性，它使您能够： </p><br><ul><li> 成功应对各个层面的复杂性 </li><li> 强制执行大量的命名标准，最佳实践和一致性检查 </li><li> 借助<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>diff</code>选项</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>flakehell</code></a>工具轻松将其集成到旧代码库中，因此可以原谅旧的违规行为，但不允许新的违规行为 </li><li> 将其启用到您的[CI]（）中，甚至作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github Action</a> </li></ul><br><p> 不要让复杂性溢出您的代码，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用优质的lint</a> ！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472876/">https://habr.com/ru/post/zh-CN472876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472866/index.html">护身符，保持稳定沟通</a></li>
<li><a href="../zh-CN472868/index.html">电话服务器管理：RUVDS移动客户端</a></li>
<li><a href="../zh-CN472870/index.html">为什么敏捷在不改变架构和开发工具的情况下陷入僵局-会议演讲</a></li>
<li><a href="../zh-CN472872/index.html">如何在不失去文化的前提下将初创企业增加到50名员工</a></li>
<li><a href="../zh-CN472874/index.html">星际飞船的故事：通过水塔通往星星</a></li>
<li><a href="../zh-CN472884/index.html">新手开发人员的刻板印象如何在游戏开始时崩溃</a></li>
<li><a href="../zh-CN472886/index.html">如何在开发中实现静态分析器，以使每个人都高兴？</a></li>
<li><a href="../zh-CN472890/index.html">适用于开发人员的DeepPavlov：＃1 NLP工具和创建聊天机器人</a></li>
<li><a href="../zh-CN472892/index.html">为什么传统的防病毒软件不适用于公共云。 怎么办？</a></li>
<li><a href="../zh-CN472894/index.html">DartUP 2019：11月23日在圣彼得堡举行的Dart和Flutter会议</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>