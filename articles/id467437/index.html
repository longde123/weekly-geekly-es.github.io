<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔬 👨‍👩‍👦 ⚠️ MVCC di PostgreSQL-1. Isolasi 🍹 💡 🤙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Dengan artikel ini saya memulai serangkaian seri (atau serangkaian set? - Singkatnya, idenya sangat muluk) tentang struktur internal Postg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC di PostgreSQL-1. Isolasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/">  Halo, Habr!  Dengan artikel ini saya memulai serangkaian seri (atau serangkaian set? - Singkatnya, idenya sangat muluk) tentang struktur internal PostgreSQL. <br><br>  Materi akan didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus pelatihan</a> (dalam bahasa Rusia) tentang administrasi yang saya dan Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">pluzanov</a> ciptakan.  Tidak semua orang suka menonton video (saya pasti tidak), dan membaca slide, bahkan dengan komentar, tidak baik sama sekali. <br><br><blockquote>  Sayangnya, satu-satunya kursus yang tersedia dalam bahasa Inggris saat ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar 2 Hari untuk PostgreSQL 11</a> . <br></blockquote><br>  Tentu saja, artikelnya tidak akan persis sama dengan isi kursus.  Saya hanya akan berbicara tentang bagaimana semuanya diatur, menghilangkan administrasi itu sendiri, tetapi saya akan mencoba melakukannya secara lebih rinci dan lebih menyeluruh.  Dan saya percaya bahwa pengetahuan seperti ini bermanfaat bagi pengembang aplikasi seperti halnya bagi administrator. <br><br>  Saya akan menargetkan mereka yang sudah memiliki pengalaman dalam menggunakan PostgreSQL dan setidaknya secara umum mengerti apa itu.  Teks akan terlalu sulit untuk pemula.  Sebagai contoh, saya tidak akan mengatakan sepatah kata pun tentang cara menginstal PostgreSQL dan menjalankan psql. <br><br>  Hal-hal yang dipermasalahkan tidak banyak berbeda dari versi ke versi, tapi saya akan menggunakan PostgreSQL vanilla ke-11 saat ini. <br><br>  Seri pertama berkaitan dengan masalah yang berkaitan dengan isolasi dan konkurensi multiversion, dan rencana seri adalah sebagai berikut: <br><br><ol><li>  Isolasi sebagaimana dipahami oleh standar dan PostgreSQL (artikel ini). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Garpu, file, halaman</a> - apa yang terjadi di tingkat fisik. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi baris</a> , transaksi virtual, dan subtransaksi. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Snapshots data</a> dan visibilitas versi baris;  cakrawala acara. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vakum dalam halaman dan pembaruan HOT</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vakum normal</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autovacuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembungkus dan pembekuan id transaksi</a> . </li></ol><br>  Ayo kita pergi! <br><br><blockquote>  Dan sebelum kita mulai, saya ingin mengucapkan terima kasih kepada Elena Indrupskaya karena menerjemahkan artikel-artikel itu ke dalam bahasa Inggris. <br></blockquote><br><a name="habracut"></a><br><h1>  Apa itu isolasi dan mengapa itu penting? </h1><br>  Mungkin, setiap orang setidaknya menyadari keberadaan transaksi, telah menemukan singkatan ACID, dan telah mendengar tentang tingkat isolasi.  Tetapi kita masih menghadapi pendapat bahwa ini berkaitan dengan teori, yang dalam praktiknya tidak perlu.  Karena itu, saya akan meluangkan waktu mencoba menjelaskan mengapa ini sangat penting. <br><br>  Anda tidak mungkin bahagia jika aplikasi mendapatkan data yang salah dari database atau jika aplikasi menulis data yang salah ke database. <br><br>  Tetapi apakah data yang "benar"?  Diketahui bahwa <em>kendala integritas</em> , seperti BUKAN NULL atau UNIK, dapat dibuat di tingkat basis data.  Jika data selalu memenuhi batasan integritas (dan ini memang karena DBMS menjaminnya), maka mereka integral. <br><br>  Apakah hal yang <em>benar</em> dan <em>integral</em> itu sama?  Tidak juga.  Tidak semua kendala dapat ditentukan di tingkat basis data.  Beberapa kendala terlalu rumit, misalnya, yang mencakup beberapa tabel sekaligus.  Dan bahkan jika suatu kendala secara umum dapat didefinisikan dalam database, tetapi untuk beberapa alasan tidak, itu tidak berarti bahwa kendala tersebut dapat dilanggar. <br><br>  Jadi, <em>kebenaran</em> lebih kuat daripada <em>integritas</em> , tetapi kita tidak tahu persis apa artinya ini.  Kami tidak memiliki apa-apa selain mengakui bahwa "standar emas" kebenaran adalah aplikasi yang, karena kami ingin percaya, ditulis <em>dengan benar</em> dan tidak pernah salah.  Dalam kasus apa pun, jika suatu aplikasi tidak melanggar integritas, tetapi melanggar kebenarannya, DBMS tidak akan mengetahuinya dan tidak akan menangkap aplikasi tersebut “tidak kidal”. <br><br>  Selanjutnya kita akan menggunakan istilah <em>konsistensi</em> untuk merujuk pada kebenaran. <br><br>  Namun, mari kita asumsikan bahwa suatu aplikasi hanya menjalankan urutan operator yang benar.  Apa peran DBMS jika aplikasi itu benar? <br><br>  Pertama, ternyata urutan operator yang benar untuk sementara waktu dapat merusak konsistensi data, dan, anehnya, ini normal.  Contoh yang usang namun jelas adalah transfer dana dari satu akun ke akun lainnya.  Aturan konsistensi mungkin terdengar seperti ini: <em>transfer tidak pernah mengubah jumlah total uang pada akun</em> (aturan ini cukup sulit untuk ditentukan dalam SQL sebagai kendala integritas, sehingga ada di tingkat aplikasi dan tidak terlihat oleh DBMS).  Transfer terdiri dari dua operasi: yang pertama mengurangi dana pada satu akun, dan yang kedua - menambahnya di yang lain.  Operasi pertama memecah konsistensi data, sedangkan yang kedua mengembalikannya. <br><br><blockquote>  Latihan yang baik adalah menerapkan aturan di atas pada tingkat kendala integritas. <br></blockquote><br>  Bagaimana jika operasi pertama dilakukan dan yang kedua tidak?  Bahkan, tanpa banyak basa-basi: selama operasi kedua mungkin terjadi kegagalan listrik, server crash, pembagian dengan nol - apa pun.  Jelas bahwa konsistensi akan rusak, dan ini tidak dapat diizinkan.  Secara umum, adalah mungkin untuk menyelesaikan masalah seperti itu di tingkat aplikasi, tetapi dengan biaya upaya yang luar biasa;  namun, untungnya, itu tidak perlu: ini dilakukan oleh DBMS.  Tetapi untuk melakukan ini, DBMS harus tahu bahwa kedua operasi adalah keseluruhan yang tidak dapat dibagi.  Yaitu, <em>transaksi</em> . <br><br>  Ternyata menarik: karena DBMS tahu bahwa operasi membuat transaksi, itu membantu menjaga konsistensi dengan memastikan bahwa transaksi itu atomik, dan ia melakukan ini tanpa mengetahui apa pun tentang aturan konsistensi tertentu. <br><br>  Tetapi ada titik kedua, yang lebih halus.  Segera setelah beberapa transaksi simultan muncul dalam sistem, yang benar-benar benar secara terpisah, mereka mungkin gagal untuk bekerja sama dengan benar.  Ini karena urutan operasi digabungkan: Anda tidak dapat mengasumsikan bahwa semua operasi dari satu transaksi dilakukan terlebih dahulu, dan kemudian semua operasi dari yang lain. <br><br>  Catatan tentang simultanitas.  Memang, transaksi dapat berjalan secara bersamaan pada sistem dengan prosesor multi-core, disk array, dll.  Tetapi alasan yang sama berlaku untuk server yang mengeksekusi perintah secara berurutan, dalam mode pembagian waktu: selama siklus jam tertentu satu transaksi dieksekusi, dan selama siklus tertentu berikutnya yang lain.  Terkadang istilah eksekusi <em>konkuren</em> digunakan untuk generalisasi. <br><br>  Situasi ketika transaksi yang benar bekerja bersama secara tidak tepat disebut <em>anomali</em> eksekusi bersamaan. <br><br>  Untuk contoh sederhana: jika aplikasi ingin mendapatkan data yang benar dari database, itu tidak boleh, setidaknya, melihat perubahan dari transaksi yang tidak berkomitmen lainnya.  Kalau tidak, Anda tidak hanya bisa mendapatkan data yang tidak konsisten, tetapi juga melihat sesuatu yang belum pernah ada dalam database (jika transaksi dibatalkan).  Keanehan ini disebut <em>pembacaan kotor</em> . <br><br>  Ada anomali lain yang lebih kompleks, yang akan kita bahas nanti. <br><br>  Tentu saja tidak mungkin untuk menghindari eksekusi bersamaan: jika tidak, kinerja seperti apa yang bisa kita bicarakan?  Tetapi Anda tidak dapat bekerja dengan data yang salah. <br><br>  Dan lagi, DBMS datang untuk menyelamatkan.  Anda dapat melakukan transaksi yang dilakukan secara berurutan, <em>seolah-olah</em> satu demi satu.  Dengan kata lain - <em>terisolasi</em> satu sama lain.  Pada kenyataannya, DBMS dapat melakukan operasi yang campur aduk, tetapi memastikan bahwa hasil eksekusi bersamaan akan sama dengan hasil dari beberapa eksekusi berurutan yang mungkin.  Dan ini menghilangkan kemungkinan anomali. <br><br>  Jadi kami sampai pada definisi: <br><br><blockquote>  Transaksi adalah serangkaian operasi yang dilakukan oleh aplikasi yang mentransfer basis data dari satu kondisi yang benar ke kondisi lain yang benar (konsistensi), asalkan transaksi tersebut selesai (atomicity) dan tanpa campur tangan dari transaksi lain (isolasi). <br></blockquote><br>  Definisi ini menyatukan tiga huruf pertama dari ACID akronim.  Mereka begitu erat terkait satu sama lain sehingga tidak masuk akal untuk mempertimbangkan satu tanpa yang lain.  Bahkan, sulit juga melepaskan huruf D (daya tahan).  Memang, ketika sistem crash, ia masih memiliki perubahan transaksi yang tidak dikomit, yang dengannya Anda perlu melakukan sesuatu untuk mengembalikan konsistensi data. <br><br>  Semuanya akan baik-baik saja, tetapi implementasi isolasi lengkap adalah tugas yang secara teknis sulit melibatkan pengurangan throughput sistem.  Oleh karena itu, dalam praktiknya sangat sering (tidak selalu, tetapi hampir selalu) isolasi lemah digunakan, yang mencegah beberapa, tetapi tidak semua anomali.  Ini berarti bahwa bagian dari pekerjaan untuk memastikan kebenaran data jatuh pada aplikasi.  Untuk alasan ini, sangat penting untuk memahami tingkat isolasi yang digunakan dalam sistem, jaminan apa yang diberikannya dan apa yang tidak diberikannya, dan bagaimana menulis kode yang benar dalam kondisi seperti itu. <br><br><h1>  Tingkat isolasi dan anomali dalam standar SQL </h1><br>  Standar SQL telah lama menggambarkan empat tingkat isolasi.  Level-level ini didefinisikan oleh daftar anomali yang diperbolehkan atau tidak diizinkan ketika transaksi dieksekusi secara bersamaan pada level ini.  Oleh karena itu, untuk berbicara tentang level-level ini, perlu untuk mengetahui anomali. <br><br>  Saya menekankan bahwa pada bagian ini kita berbicara tentang standar, yaitu, tentang teori, yang mendasari praktik secara signifikan, tetapi dari mana pada saat yang sama itu secara signifikan menyimpang.  Karena itu, semua contoh di sini adalah spekulatif.  Mereka akan menggunakan operasi yang sama pada akun pelanggan: ini cukup demonstratif, meskipun, diakui, tidak ada hubungannya dengan bagaimana operasi bank diatur dalam kenyataan. <br><br><h2>  Pembaruan kerugian </h2><br>  Mari kita mulai dengan <em>pembaruan yang hilang</em> .  Anomali ini terjadi ketika dua transaksi membaca baris tabel yang sama, lalu satu transaksi memperbarui baris itu, dan kemudian transaksi kedua juga memperbarui baris yang sama tanpa memperhitungkan perubahan yang dilakukan oleh transaksi pertama. <br><br>  Misalnya, dua transaksi akan meningkatkan jumlah pada akun yang sama sebesar ₽100 (₽ adalah tanda mata uang untuk rubel Rusia).  Transaksi pertama membaca nilai saat ini (₽1000) dan kemudian transaksi kedua membaca nilai yang sama.  Transaksi pertama meningkatkan jumlah (ini memberi ₽1100) dan menulis nilai ini.  Transaksi kedua bertindak dengan cara yang sama: ia mendapatkan ₽1100 yang sama dan menulis nilai ini.  Akibatnya, pelanggan kehilangan ₽100. <br><br>  Standar tidak memungkinkan pembaruan yang hilang pada tingkat isolasi apa pun. <br><br><h2>  Kotor membaca dan Baca Tidak Berkomitmen </h2><br>  <em>Bacaan kotor</em> adalah hal yang sudah kita ketahui.  Anomali ini terjadi ketika suatu transaksi membaca perubahan yang belum dilakukan oleh transaksi lain. <br><br>  Misalnya, transaksi pertama mentransfer semua uang dari akun pelanggan ke akun lain, tetapi tidak melakukan perubahan.  Transaksi lain membaca saldo akun, untuk mendapatkan ₽0, dan menolak untuk menarik uang tunai kepada pelanggan, meskipun transaksi pertama membatalkan dan mengembalikan perubahannya, sehingga nilai 0 tidak pernah ada dalam database. <br><br>  Standar memungkinkan pembacaan kotor di tingkat Baca Tidak Berkomitmen. <br><br><h2>  Baca dan Komit Baca yang tidak dapat diulang </h2><br>  Anomali <em>baca yang tidak dapat diulang</em> terjadi ketika transaksi membaca baris yang sama dua kali, dan di antara yang dibaca, transaksi kedua memodifikasi (atau menghapus) baris itu dan melakukan perubahan.  Maka transaksi pertama akan mendapatkan hasil yang berbeda. <br><br>  Misalnya, biarkan aturan konsistensi <em>melarang jumlah negatif pada akun pelanggan</em> .  Transaksi pertama akan mengurangi jumlah pada akun sebesar ₽100.  Ia memeriksa nilai saat ini, mendapatkan ₽1000 dan memutuskan bahwa penurunan itu mungkin.  Pada saat yang sama transaksi kedua mengurangi jumlah pada akun menjadi nol dan melakukan perubahan.  Jika transaksi pertama sekarang memeriksa kembali jumlahnya, itu akan mendapatkan ₽0 (tetapi telah memutuskan untuk mengurangi nilainya, dan akun “masuk ke merah”). <br><br>  Standar ini memungkinkan pembacaan yang tidak dapat diulang pada tingkat Read Uncommitted dan Read Committed.  Tetapi Read Committed tidak mengizinkan pembacaan kotor. <br><br><h2>  Phantom membaca dan Baca Berulang </h2><br>  Pembacaan <em>hantu</em> terjadi ketika transaksi membaca satu set baris dengan kondisi yang sama dua kali, dan di antara pembacaan, transaksi kedua menambahkan baris yang memenuhi kondisi itu (dan melakukan perubahan).  Maka transaksi pertama akan mendapatkan set baris yang berbeda. <br><br>  Misalnya, biarkan aturan konsistensi <em>mencegah pelanggan memiliki lebih dari 3 akun</em> .  Transaksi pertama akan membuka akun baru, memeriksa jumlah akun saat ini (katakanlah, 2), dan memutuskan bahwa pembukaan dimungkinkan.  Pada saat yang sama, transaksi kedua juga membuka akun baru untuk pelanggan dan melakukan perubahan.  Sekarang jika transaksi pertama memeriksa ulang nomornya, itu akan mendapatkan 3 (tetapi sudah membuka akun lain, dan pelanggan tampaknya memiliki 4 dari mereka). <br><br>  Standar ini memungkinkan phantom membaca di tingkat Baca Tidak Berkomitmen, Baca Berkomitmen, dan Baca Berulang.  Namun, pembacaan yang tidak dapat diulang tidak diperbolehkan pada tingkat Baca yang Diulang. <br><br><h2>  Tidak adanya anomali dan serializable </h2><br>  Standar mendefinisikan satu tingkat lagi - Serializable - yang tidak memungkinkan anomali.  Dan ini tidak sama dengan melarang pembaruan yang hilang dan kotor, tidak dapat diulang, atau membaca hantu. <br><br>  Masalahnya adalah bahwa ada banyak anomali yang lebih dikenal daripada yang tercantum dalam standar dan juga jumlah yang tidak diketahui namun belum diketahui. <br><br>  Level Serializable harus <em>benar-benar</em> mencegah <em>semua</em> anomali.  Ini berarti bahwa pada level ini, pengembang aplikasi tidak perlu memikirkan eksekusi bersamaan.  Jika transaksi melakukan urutan yang benar dari operator yang bekerja secara terpisah, data akan konsisten juga ketika transaksi ini dijalankan secara bersamaan. <br><br><h2>  Tabel ringkasan </h2><br>  Sekarang kami dapat menyediakan tabel yang terkenal.  Tapi di sini kolom terakhir, yang hilang dari standar, ditambahkan untuk kejelasan. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Perubahan yang hilang </th><th>  Kotor baca </th><th>  Baca tidak dapat diulang </th><th>  Phantom membaca </th><th>  Anomali lainnya </th></tr><tr><th>  Baca Tidak Berkomitmen </th><th>  - </th><th>  Ya </th><th>  Ya </th><th>  Ya </th><th>  Ya </th></tr><tr><th>  Baca berkomitmen </th><th>  - </th><th>  - </th><th>  Ya </th><th>  Ya </th><th>  Ya </th></tr><tr><th>  Baca berulang </th><th>  - </th><th>  - </th><th>  - </th><th>  Ya </th><th>  Ya </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  Mengapa justru anomali ini? </h2><br>  Mengapa daftar standar hanya beberapa dari banyak anomali yang mungkin, dan mengapa mereka persis ini? <br><br>  Sepertinya tidak ada yang tahu itu pasti.  Tapi di sini praktiknya jelas di depan teori, sehingga ada kemungkinan bahwa pada waktu itu (dari standar SQL: 92), anomali lain tidak hanya dipikirkan. <br><br>  Selain itu, diasumsikan bahwa isolasi harus dibangun di atas kunci.  Gagasan di balik <em>protokol Penguncian Dua Fase</em> (2PL) yang banyak digunakan adalah bahwa selama eksekusi, transaksi mengunci baris yang digunakannya dan melepaskan kunci pada penyelesaian.  Menyederhanakan, semakin banyak kunci yang diperoleh transaksi, semakin baik itu terisolasi dari transaksi lainnya.  Tetapi kinerja sistem juga lebih menderita, karena alih-alih bekerja bersama, transaksi mulai mengantri untuk baris yang sama. <br><br>  Perasaan saya adalah bahwa itu hanya jumlah kunci yang diperlukan, yang menyumbang perbedaan antara tingkat isolasi standar. <br><br>  Jika transaksi mengunci baris yang akan diubah agar tidak diperbarui, tetapi tidak dari membaca, kami mendapatkan tingkat Baca Tidak Berkomitmen: perubahan yang hilang tidak diizinkan, tetapi data yang tidak terikat dapat dibaca. <br><br>  Jika transaksi mengunci baris yang akan diubah dari pembacaan dan pembaruan, kami mendapatkan tingkat Komitmen Baca: Anda tidak dapat membaca data yang tidak dikomit, tetapi Anda bisa mendapatkan nilai yang berbeda (pembacaan yang tidak dapat diulang) ketika Anda mengakses baris lagi. <br><br>  Jika transaksi mengunci baris yang akan dibaca dan dimodifikasi serta dari membaca dan memperbarui, kami mendapatkan tingkat Baca Berulang: membaca ulang baris akan mengembalikan nilai yang sama. <br><br>  Tetapi ada masalah dengan Serializable: Anda tidak dapat mengunci baris yang belum ada.  Oleh karena itu, pembacaan hantu masih dimungkinkan: transaksi lain mungkin menambahkan (tetapi tidak menghapus) baris yang memenuhi persyaratan permintaan yang dieksekusi sebelumnya, dan baris itu akan dimasukkan dalam pemilihan ulang. <br><br>  Oleh karena itu, untuk menerapkan level Serializable, kunci normal tidak cukup - Anda perlu mengunci kondisi (predikat) daripada baris.  Oleh karena itu, kunci seperti itu disebut <em>predikat</em> .  Mereka diusulkan pada tahun 1976, tetapi penerapan praktis mereka dibatasi oleh kondisi yang cukup sederhana yang jelas bagaimana bergabung dengan dua predikat yang berbeda.  Sejauh yang saya tahu, kunci tersebut belum pernah diterapkan di sistem apa pun sejauh ini. <br><br><h1>  Level isolasi dalam PostgreSQL </h1><br>  Seiring waktu, protokol manajemen transaksi berbasis kunci digantikan dengan protokol Isolasi Snapshot (SI).  Idenya adalah bahwa setiap transaksi bekerja dengan snapshot data yang konsisten pada titik waktu tertentu, dan hanya perubahan yang masuk ke snapshot yang dilakukan sebelum dibuat. <br><br>  Isolasi ini secara otomatis mencegah pembacaan kotor.  Secara formal, Anda dapat menentukan level Read Uncommitted di PostgreSQL, tetapi ini akan bekerja dengan cara yang persis sama dengan Read Committed.  Oleh karena itu, lebih jauh kita tidak akan berbicara tentang level Read Uncommitted sama sekali. <br><br>  PostgreSQL mengimplementasikan varian <em>multiversion</em> dari protokol ini.  Gagasan multiversion concurrency adalah bahwa beberapa versi dari baris yang sama dapat hidup berdampingan dalam DBMS.  Ini memungkinkan Anda untuk membuat snapshot data menggunakan versi yang ada dan menggunakan minimum kunci.  Sebenarnya, hanya perubahan berikutnya pada baris yang sama yang dikunci.  Semua operasi lain dilakukan secara bersamaan: menulis transaksi tidak pernah mengunci transaksi read-only, dan transaksi read-only tidak pernah mengunci apa pun. <br><br>  Dengan menggunakan snapshot data, isolasi dalam PostgreSQL lebih ketat daripada yang disyaratkan oleh standar: tingkat Baca Berulang tidak hanya memungkinkan pembacaan yang tidak dapat diulang, tetapi juga pembacaan hantu (meskipun tidak memberikan isolasi lengkap).  Dan ini dicapai tanpa kehilangan efisiensi. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Perubahan yang hilang </th><th>  Kotor baca </th><th>  Baca tidak dapat diulang </th><th>  Phantom membaca </th><th>  Anomali lainnya </th></tr><tr><th>  Baca Tidak Berkomitmen </th><th>  - </th><th>  - </th><th>  Ya </th><th>  Ya </th><th>  Ya </th></tr><tr><th>  Baca berkomitmen </th><th>  - </th><th>  - </th><th>  Ya </th><th>  Ya </th><th>  Ya </th></tr><tr><th>  Baca berulang </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  Ya </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Kita akan berbicara di artikel selanjutnya tentang bagaimana multiversion concurrency diimplementasikan "di bawah tenda," dan sekarang kita akan melihat secara terperinci pada masing-masing dari tiga tingkat dengan mata pengguna (seperti yang Anda tahu, yang paling menarik tersembunyi di balik "anomali lain" ").  Untuk melakukan ini, mari kita buat tabel akun.  Alice dan Bob masing-masing memiliki 0001000, tetapi Bob memiliki dua akun yang dibuka: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Baca berkomitmen </h2><br><h3>  Tidak adanya baca kotor </h3><br>  Sangat mudah untuk memastikan bahwa data kotor tidak dapat dibaca.  Kami memulai transaksi.  Secara default ini akan menggunakan level isolasi Read Committed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Lebih tepatnya, level default diatur oleh parameter, yang dapat diubah jika perlu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Jadi, dalam transaksi terbuka, kami menarik dana dari akun, tetapi tidak melakukan perubahan.  Transaksi melihat perubahannya sendiri: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  Di sesi kedua, kami akan memulai transaksi lain dengan tingkat Komitmen Baca yang sama.  Untuk membedakan antara transaksi, perintah dari transaksi kedua akan diindentasi dan ditandai dengan bilah. <br><br>  Untuk mengulangi perintah di atas (yang berguna), Anda perlu membuka dua terminal dan menjalankan psql di masing-masing terminal.  Di terminal pertama, Anda dapat memasukkan perintah dari satu transaksi, dan di yang kedua - yang lainnya. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Seperti yang diharapkan, transaksi lainnya tidak melihat perubahan yang tidak dikomit karena pembacaan kotor tidak diperbolehkan. <br><br><h3>  Baca tidak dapat diulang </h3><br>  Sekarang, biarkan transaksi pertama melakukan perubahan dan yang kedua menjalankan kembali permintaan yang sama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Kueri sudah mendapatkan data baru - dan ini adalah anomali <em>baca yang tidak dapat diulang</em> , yang diizinkan pada tingkat Komitmen Baca. <br><br>  <em>Kesimpulan praktis</em> : dalam suatu transaksi, Anda tidak dapat membuat keputusan berdasarkan data yang dibaca oleh operator sebelumnya karena hal-hal dapat berubah antara pelaksanaan operator.  Berikut adalah contoh yang variasinya sering terjadi pada kode aplikasi sehingga dianggap sebagai antipattern klasik: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Selama waktu yang lewat antara memeriksa dan memperbarui, transaksi lain dapat mengubah keadaan akun dengan cara apa pun, sehingga "cek" seperti itu aman dari nol.  Sangat mudah untuk membayangkan bahwa antara operator dari satu transaksi, operator lain dari transaksi lain dapat "mengganjal," misalnya, sebagai berikut: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Jika semuanya bisa rusak dengan menata ulang operator, maka kodenya ditulis secara tidak benar.  Dan jangan menipu diri sendiri bahwa kebetulan seperti itu tidak akan terjadi - pasti akan terjadi. <br><br>  Tetapi bagaimana cara menulis kode dengan benar?  Pilihannya cenderung sebagai berikut: <br><br><ul><li>  Bukan untuk menulis kode. <br>  Ini bukan lelucon.  Misalnya, dalam hal ini, pengecekan dengan mudah berubah menjadi kendala integritas: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Tidak diperlukan pemeriksaan sekarang: cukup lakukan operasi dan, jika perlu, tangani pengecualian yang akan terjadi jika pelanggaran integritas dilakukan. <br></li><li>  Untuk menggunakan pernyataan SQL tunggal. <br>  Masalah konsistensi muncul karena dalam interval waktu antara operator transaksi lain dapat diselesaikan, yang akan mengubah data yang terlihat.  Dan jika ada satu operator, maka tidak ada interval waktu. <br>  PostgreSQL memiliki teknik yang cukup untuk menyelesaikan masalah kompleks dengan satu pernyataan SQL.  Mari kita perhatikan ekspresi tabel umum (CTE), di mana, di antara yang lain, Anda dapat menggunakan pernyataan INSERT / UPDATE / DELETE, serta pernyataan INSERT ON CONFLICT, yang mengimplementasikan logika "masukkan, tetapi jika baris sudah ada, perbarui ”dalam satu pernyataan. <br></li><li>  Kunci khusus. <br>  Pilihan terakhir adalah secara manual mengatur kunci eksklusif pada semua baris yang diperlukan (PILIH UNTUK PEMBARUAN) atau bahkan pada seluruh tabel (LOCK TABLE).  Ini selalu berhasil, tetapi membatalkan manfaat konkurensi multiversion: beberapa operasi akan dieksekusi secara berurutan alih-alih eksekusi bersamaan. <br></li></ul><br><h3>  Baca tidak konsisten </h3><br>  Sebelum melanjutkan ke tingkat isolasi berikutnya, Anda harus mengakui bahwa itu tidak sesederhana kedengarannya.  Implementasi PostgreSQL sedemikian rupa sehingga memungkinkan anomali lain yang kurang dikenal yang tidak diatur oleh standar. <br><br>  Mari kita asumsikan bahwa transaksi pertama memulai transfer dana dari satu akun Bob ke yang lain: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Pada saat yang sama, transaksi lain menghitung saldo Bob, dan perhitungan dilakukan dalam satu lingkaran di atas semua akun Bob.  Bahkan, transaksi dimulai dengan akun pertama (dan, jelas, melihat keadaan sebelumnya): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Pada titik waktu ini, transaksi pertama selesai dengan sukses: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dan yang lain membaca status akun kedua (dan sudah melihat nilai baru): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Oleh karena itu, transaksi kedua mendapat total ₽1100, yaitu data yang salah.  Dan ini adalah anomali <em>baca yang tidak konsisten</em> . <br><br>  Bagaimana cara menghindari anomali seperti itu saat tinggal di tingkat Komitmen Baca?  Tentu saja, gunakan satu operator.  Sebagai contoh: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Sampai di sini saya menegaskan bahwa visibilitas data hanya dapat berubah di antara operator, tetapi apakah itu begitu jelas?  Dan jika kueri membutuhkan waktu lama, dapatkah ia melihat bagian dari data di satu negara dan bagian di yang lain? <br><br>  Mari kita periksa.  Cara mudah untuk melakukan ini adalah memasukkan penundaan paksa ke operator dengan memanggil fungsi pg_sleep.  Parameternya menentukan waktu tunda dalam detik. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Ketika operator ini dieksekusi, kami mentransfer dana kembali dalam transaksi lain: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Hasilnya menunjukkan bahwa operator melihat data dalam keadaan yang mereka miliki pada saat eksekusi operator dimulai.  Ini tidak diragukan lagi benar. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Tapi di sini juga tidak sesederhana itu.  PostgreSQL memungkinkan Anda untuk mendefinisikan fungsi, dan fungsi memiliki konsep <em>kategori volatilitas</em> .  Jika fungsi VOLATILE dipanggil dalam kueri dan kueri lain dieksekusi dalam fungsi itu, kueri di dalam fungsi akan melihat data yang tidak konsisten dengan data di kueri utama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dalam hal ini, kami mendapatkan data yang salah - ₽100 hilang: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Saya menekankan bahwa efek ini hanya mungkin pada tingkat isolasi yang Baca Komit dan hanya dengan fungsi VOLATILE.  Masalahnya adalah bahwa secara default, tepatnya tingkat isolasi ini dan kategori volatilitas ini digunakan.  Jangan jatuh ke dalam perangkap! <br><br><h3>  Pembacaan tidak konsisten dengan imbalan perubahan yang hilang </h3><br>  Kami juga bisa mendapatkan pembacaan yang tidak konsisten dalam satu operator selama pembaruan, meskipun dengan cara yang agak tidak terduga. <br><br>  Mari kita lihat apa yang terjadi ketika dua transaksi mencoba mengubah baris yang sama.  Sekarang Bob memiliki ₽1000 pada dua akun: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Kami memulai transaksi yang mengurangi saldo Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Pada saat yang sama, dalam transaksi lain, bunga timbul pada semua akun pelanggan dengan total saldo sama dengan atau lebih besar dari ,0001.000: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  Eksekusi dari operator UPDATE terdiri dari dua bagian.  Pertama, sebenarnya SELECT dijalankan, yang memilih baris untuk memperbarui yang memenuhi kondisi yang sesuai.  Karena perubahan dalam transaksi pertama tidak dilakukan, transaksi kedua tidak dapat melihatnya, dan perubahan tidak mempengaruhi pemilihan baris untuk akrual bunga.  Kalau begitu, akun Bob memenuhi persyaratan dan setelah pembaruan dilakukan, saldonya akan meningkat sebesar ₽10. <br><br>  Tahap kedua dari eksekusi adalah memperbarui baris yang dipilih satu per satu.  Di sini transaksi kedua dipaksa untuk "hang" karena baris dengan id = 3 sudah dikunci oleh transaksi pertama. <br><br>  Sementara itu, transaksi pertama melakukan perubahan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Apa hasilnya? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Nah, di satu sisi, perintah UPDATE seharusnya tidak melihat perubahan transaksi kedua.  Tetapi di sisi lain, itu tidak boleh kehilangan perubahan yang dilakukan dalam transaksi kedua. <br><br>  Setelah kunci dilepaskan, UPDATE membaca kembali baris yang sedang berusaha diperbarui (tetapi hanya yang ini).  Akibatnya, Bob bertambah ₽9, berdasarkan jumlah ₽900.  Tetapi jika Bob memiliki ₽900, akunnya seharusnya tidak ada dalam pemilihan sama sekali. <br><br>  Jadi, transaksi mendapat data yang salah: beberapa baris terlihat pada satu titik waktu, dan sebagian lagi pada titik lainnya.  Alih-alih pembaruan yang hilang, kami kembali mendapatkan anomali <em>pembacaan yang tidak konsisten</em> . <br><br><blockquote>  Pembaca yang penuh perhatian mencatat bahwa dengan bantuan dari aplikasi Anda bisa mendapatkan pembaruan yang hilang bahkan pada tingkat Komitmen Baca.  Sebagai contoh: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Basis data tidak bisa disalahkan: ia mendapat dua pernyataan SQL dan tidak tahu apa-apa tentang fakta bahwa nilai x + 100 entah bagaimana terkait dengan jumlah akun.  Hindari menulis kode seperti itu. <br></blockquote><br><h2>  Baca berulang </h2><br><h3>  Tidak adanya non-repeatable dan phantom membaca </h3><br>  Nama tingkat isolasi mengasumsikan bahwa membaca dapat diulang.  Mari kita periksa, dan pada saat yang sama pastikan tidak ada hantu yang dibaca.  Untuk melakukan ini, dalam transaksi pertama, kami mengembalikan akun Bob ke keadaan sebelumnya dan membuat akun baru untuk Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Di sesi kedua, kami memulai transaksi dengan tingkat Baca Berulang dengan menetapkannya dalam perintah BEGIN (tingkat transaksi pertama tidak penting). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Sekarang transaksi pertama melakukan perubahan dan yang kedua mengeksekusi permintaan yang sama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Transaksi kedua masih melihat data yang sama persis seperti di awal: tidak ada perubahan pada baris yang ada atau baris baru yang terlihat. <br><br>  Pada level ini, Anda dapat menghindari kekhawatiran tentang sesuatu yang dapat berubah di antara dua operator. <br><br><h3>  Kesalahan serialisasi dengan imbalan perubahan yang hilang </h3><br>  Kami telah membahas sebelumnya bahwa ketika dua transaksi memperbarui baris yang sama pada tingkat Komitmen Baca, sebuah anomali pembacaan yang tidak konsisten dapat terjadi.  Ini karena transaksi menunggu membaca ulang baris yang dikunci dan karenanya tidak melihatnya sebagai titik waktu yang sama dengan baris lainnya. <br><br>  Pada level Repeatable Read, anomali ini tidak diperbolehkan, tetapi jika itu terjadi, tidak ada yang bisa dilakukan - sehingga transaksi berakhir dengan kesalahan serialisasi.  Mari kita periksa dengan mengulangi skenario yang sama dengan akrual bunga: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Data tetap konsisten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  Kesalahan yang sama akan terjadi dalam kasus perubahan kompetitif lainnya dari baris, bahkan jika kolom yang menjadi perhatian kita tidak benar-benar berubah. <br><br>  <em>Kesimpulan praktis</em> : jika aplikasi Anda menggunakan tingkat isolasi Baca Berulang untuk transaksi tulis, ia harus siap untuk mengulangi transaksi yang diakhiri dengan kesalahan serialisasi.  Untuk transaksi hanya baca, hasil ini tidak dimungkinkan. <br><br><h3>  Tulisan yang tidak konsisten </h3><br>  Jadi, di PostgreSQL, pada tingkat isolasi Read Repeatable, semua anomali yang dijelaskan dalam standar dicegah.  Namun tidak semua anomali pada umumnya.  Ternyata ada <em>dua</em> anomali yang masih mungkin terjadi.  (Ini berlaku tidak hanya untuk PostgreSQL, tetapi juga untuk implementasi lain dari Snapshot Isolasi.) <br><br>  Yang pertama dari anomali ini adalah <em>penulisan yang tidak konsisten</em> . <br><br>  Biarkan aturan konsistensi berikut berlaku: <em>jumlah negatif pada akun pelanggan diizinkan jika jumlah total pada semua akun pelanggan tetap non-negatif</em> . <br><br>  Transaksi pertama mendapatkan jumlah pada akun Bob: ₽900. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  Transaksi kedua mendapatkan jumlah yang sama. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  Transaksi pertama seharusnya meyakini bahwa jumlah salah satu akun dapat dikurangi ₽600. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Dan transaksi kedua sampai pada kesimpulan yang sama.  Tetapi mengurangi akun lain: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Kami berhasil membuat saldo Bob menjadi merah, meskipun setiap transaksi bekerja dengan benar sendirian. <br><br><h3>  Anomali transaksi hanya baca </h3><br>  Ini adalah anomali kedua dan terakhir yang dimungkinkan pada tingkat Baca Berulang.  Untuk menunjukkannya, Anda akan membutuhkan tiga transaksi, dua di antaranya akan mengubah data, dan yang ketiga hanya akan membacanya. <br><br>  Tapi pertama-tama mari kita mengembalikan keadaan akun Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Dalam transaksi pertama, bunga pada jumlah yang tersedia di semua akun Bob timbul.  Bunga dikreditkan ke salah satu akunnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Kemudian transaksi lain menarik uang dari akun Bob lain dan melakukan perubahannya: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Jika transaksi pertama dilakukan pada saat ini, tidak ada anomali akan terjadi: kita dapat mengasumsikan bahwa transaksi pertama dieksekusi pertama dan kemudian yang kedua (tetapi bukan sebaliknya karena transaksi pertama melihat keadaan akun dengan id = 3 sebelum itu akun diubah oleh transaksi kedua). <br><br>  Tetapi bayangkan bahwa pada titik ini transaksi ketiga (hanya baca) dimulai, yang membaca status beberapa akun yang tidak terpengaruh oleh dua transaksi pertama: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Dan hanya setelah itu transaksi pertama selesai: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Keadaan apa yang harus dilihat oleh transaksi ketiga sekarang? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Setelah dimulai, transaksi ketiga dapat melihat perubahan dari transaksi kedua (yang sudah dilakukan), tetapi bukan yang pertama (yang belum dilakukan).  Di sisi lain, kami telah memastikan di atas bahwa transaksi kedua harus dipertimbangkan dimulai setelah yang pertama.  Status apa pun yang dilihat transaksi ketiga akan tidak konsisten - ini hanya anomali dari transaksi read-only.  Tetapi pada tingkat Baca Berulang itu diizinkan: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serializable </h2><br>  Level Serializable mencegah semua anomali yang mungkin terjadi.  Bahkan, Serializable dibangun di atas Snapshot Isolasi.  Anomali yang tidak terjadi dengan Baca Berulang (seperti kotor, tidak dapat diulang, atau membaca hantu) juga tidak terjadi pada tingkat Serializable.  Dan anomali yang terjadi (penulisan yang tidak konsisten dan anomali transaksi read-only) terdeteksi, dan transaksi dibatalkan - kesalahan serialisasi yang dikenal terjadi: <em>tidak dapat membuat serial akses</em> . <br><br><h3>  Tulisan yang tidak konsisten </h3><br>  Untuk menggambarkan ini, mari kita ulangi skenario dengan anomali tulis yang tidak konsisten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Seperti halnya pada tingkat Baca Berulang, aplikasi yang menggunakan tingkat isolasi Serializable harus mengulangi transaksi yang diakhiri dengan kesalahan serialisasi, seperti yang diminta oleh pesan kesalahan tersebut. <br><br>  Kami mendapatkan kesederhanaan pemrograman, tetapi harga untuk itu adalah pemutusan paksa sebagian transaksi dan kebutuhan untuk mengulanginya.  Pertanyaannya, tentu saja, seberapa besar fraksi ini.  Jika hanya transaksi yang diakhiri yang tumpang tindih dengan transaksi lain, akan lebih baik.  Tetapi implementasi seperti itu mau tidak mau akan menjadi sumber daya intensif dan tidak efisien karena Anda harus melacak operasi di setiap baris. <br><br>  Sebenarnya, implementasi PostgreSQL sedemikian rupa sehingga memungkinkan negatif palsu: beberapa transaksi yang benar-benar normal yang hanya "sial" juga akan dibatalkan.  Seperti yang akan kita lihat nanti, ini tergantung pada banyak faktor, seperti ketersediaan indeks yang sesuai atau jumlah RAM yang tersedia.  Selain itu, ada beberapa batasan implementasi lain (cukup parah), misalnya, kueri di tingkat Serializable tidak akan berfungsi pada replika, dan mereka tidak akan menggunakan rencana eksekusi paralel.  Meskipun pekerjaan untuk meningkatkan implementasi terus berlanjut, keterbatasan yang ada membuat tingkat isolasi ini kurang menarik. <br><blockquote>  Paket paralel akan muncul pada PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patch</a> ).  Dan pertanyaan tentang replika dapat mulai bekerja di PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan lain</a> ). <br></blockquote><br><h3>  Anomali transaksi hanya baca </h3><br>  Untuk transaksi read-only untuk tidak menghasilkan anomali dan tidak menderita, PostgreSQL menawarkan teknik yang menarik: transaksi semacam itu dapat dikunci hingga pelaksanaannya aman.  Ini adalah satu-satunya kasus ketika operator SELECT dapat dikunci oleh pembaruan baris.  Seperti inilah bentuknya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Transaksi ketiga secara eksplisit dinyatakan BACA HANYA dan DITANGGUHKAN: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Saat mencoba mengeksekusi kueri, transaksi dikunci karena jika tidak maka akan menyebabkan anomali. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dan hanya setelah transaksi pertama dilakukan, yang ketiga melanjutkan eksekusi: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Catatan penting lainnya: jika isolasi Serializable digunakan, semua transaksi dalam aplikasi harus menggunakan level ini.  Anda tidak dapat mencampur transaksi Read-Committed (atau Repeatable Read) dengan Serializable.  Artinya, Anda <em>dapat</em> mencampur, tetapi kemudian Serializable akan berperilaku seperti Baca Berulang tanpa peringatan.  Kami akan membahas mengapa ini terjadi nanti, ketika kami berbicara tentang implementasi. <br><br>  Jadi, jika Anda memutuskan untuk menggunakan Serializble, yang terbaik adalah mengatur tingkat default secara global (meskipun ini, tentu saja, tidak akan mencegah Anda menentukan tingkat yang salah secara eksplisit): <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>  Anda dapat menemukan presentasi yang lebih teliti tentang masalah-masalah yang berkaitan dengan transaksi, konsistensi dan anomali dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kuliah</a> oleh Boris Novikov "Dasar-dasar teknologi basis data" (hanya tersedia di Russion). <br></blockquote><br><h1>  Tingkat isolasi apa yang digunakan? </h1><br>  Level isolasi Read Committed digunakan secara default di PostgreSQL, dan kemungkinan level ini digunakan di sebagian besar aplikasi.  Default ini nyaman karena pada level ini transaksi dibatalkan hanya mungkin jika terjadi kegagalan, tetapi bukan sebagai sarana untuk mencegah inkonsistensi.  Dengan kata lain, kesalahan serialisasi tidak dapat terjadi. <br><br>  Sisi lain dari koin adalah sejumlah besar kemungkinan anomali, yang telah dibahas secara rinci di atas.  Insinyur perangkat lunak selalu harus mengingatnya dan menulis kode agar tidak membiarkan mereka muncul.  Jika Anda tidak dapat membuat kode tindakan yang diperlukan dalam satu pernyataan SQL, Anda harus menggunakan penguncian eksplisit.  Yang paling menyusahkan adalah kode sulit untuk menguji kesalahan yang terkait dengan mendapatkan data yang tidak konsisten, dan kesalahan itu sendiri dapat terjadi dengan cara yang tidak dapat diprediksi dan tidak dapat direproduksi dan karenanya sulit untuk diperbaiki. <br><br>  Tingkat isolasi Baca Berulang menghilangkan beberapa masalah inkonsistensi, tetapi sayangnya, tidak semua.  Oleh karena itu, Anda tidak hanya harus ingat tentang anomali yang tersisa, tetapi juga memodifikasi aplikasi sehingga benar menangani kesalahan serialisasi.  Ini tentu saja merepotkan.  Tetapi untuk transaksi read-only, level ini secara sempurna melengkapi Read Committed dan sangat nyaman, misalnya, untuk membuat laporan yang menggunakan beberapa kueri SQL. <br><br>  Akhirnya, tingkat Serializable memungkinkan Anda untuk tidak khawatir tentang inkonsistensi sama sekali, yang sangat memudahkan pengkodean.  Satu-satunya hal yang diperlukan aplikasi adalah untuk dapat mengulangi transaksi apa pun ketika mendapatkan kesalahan serialisasi.  Tetapi fraksi transaksi yang dibatalkan, overhead tambahan, dan ketidakmampuan untuk memaralelkan kueri dapat secara signifikan mengurangi throughput sistem.  Perhatikan juga bahwa level Serializable tidak berlaku pada replika, dan bahwa level tersebut tidak dapat dicampur dengan level isolasi lainnya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467437/">https://habr.com/ru/post/id467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467423/index.html">Xamarin.Forms - penggunaan font ikon yang nyaman dalam aplikasi</a></li>
<li><a href="../id467425/index.html">Pendekatan Pembelajaran Intensif STEM</a></li>
<li><a href="../id467427/index.html">BudgetTracker - alat open-source lain untuk akuntansi keuangan pribadi</a></li>
<li><a href="../id467429/index.html">Habrastatistics: menjelajahi bagian situs yang paling banyak dikunjungi dan paling tidak dikunjungi</a></li>
<li><a href="../id467435/index.html">Kami mengirim laporan agen Veeam Linux ke email atau di Telegram</a></li>
<li><a href="../id467439/index.html">Mengapa vinil kembali, dan bagaimana layanan streaming terkait dengan ini?</a></li>
<li><a href="../id467443/index.html">Pusat Multimedia "Kodi" dan Proyek Yocto</a></li>
<li><a href="../id467445/index.html">Daftar pembaruan Windows yang diinstal yang sulit dipahami</a></li>
<li><a href="../id467449/index.html">Deteksi kerentanan dan penilaian resistensi terhadap serangan hacker kartu pintar dan prosesor kripto dengan perlindungan built-in</a></li>
<li><a href="../id467453/index.html">Memecahkan masalah nomor 42 menggunakan superkomputer planet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>