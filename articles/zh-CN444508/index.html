<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖲️ 👩🏼 🐂 我们使PHP 7的速度是PHP 5的两倍的方式。第1部分：优化数据结构 🏇🏼 🧜🏼 🔈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2015年12月 ，PHP 7.0发行了。 切换到“七个”的公司指出，生产力提高了，服务器的负载减少了。 首先搬到这七个国家的是Vebia和Etsy，我们有Badoo，Avito和OLX。 对于Badoo，切换到这七个服务器可节省100万美元的服务器成本。 借助OLX中的PHP 7，平均服务器负载减...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们使PHP 7的速度是PHP 5的两倍的方式。第1部分：优化数据结构</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/444508/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2015年12月</a> ，PHP 7.0发行了。 切换到“七个”的公司指出，生产力提高了，服务器的负载减少了。 首先搬到这七个国家的是Vebia和Etsy，我们有Badoo，Avito和OLX。 对于Badoo，切换到这七个服务器可节省100万美元的服务器成本。 借助OLX中的PHP 7，平均服务器负载减少了3倍，从而提高了效率并节省了资源。 <br><br>  Zend Technologies的<strong>Dmitry Stogov</strong>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HighLoad ++上发表</a>了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讲话</a> ，这提高了生产率。 在解码中：关于PHP的内部结构，关于7.0版核心的思想，关于确定成功的基本数据结构和算法的变化。 <br><br>  <em>免责声明：截至2019年3月</em> <em>，尽管自2019年1月1日</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>起不支持此版本</em></a> <em>，但</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>80％的站点</em></a> <em>都在PHP上运行，其中</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>70</em></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>％的站点</em></a> <em>在</em> <em>PHP 5</em> <em>上运行</em> <em>。</em>  <em>德米特里（Dmitry）在2016年的报告中指出，PHP 5和7之间的生产率翻倍的原则也与2019年3月有关。当然，对于一半的站点而言。</em> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/tHapNKpacSQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>关于发言人：德米特里·斯托戈夫（Dmitry Stogov）</strong>早在80年代<strong>就</strong>开始编写程序：“ Electronics B3-34”，基本的汇编程序。  2002年，Dmitry熟悉了PHP，并很快开始进行改进：他开发了针对PHP的Turck MMCache，领导了PHPNG项目，并在开发PHP的JIT中发挥了重要作用。  Zend Technologies的首席工程师的最后14年。 <br><br>  Zend Technologies正在开发PHP和基于它的商业解决方案。 它是由以色列程序员Andy Gutmans和Zeev Suraski于1999年创立的，两年前他们创建了PHP3。这些人处在PHP开发的最前沿，在很大程度上决定了该语言的当前外观以及该技术的成功。 <br><br>  Zend Technologies为它开发了PHP核心和应用程序，在工作中，我不得不编写扩展，进入所有子系统，甚至从事商业项目，有时根本不与PHP连接。 但是对我来说最有趣的话题一直是<strong>表演</strong> 。 <br><br> 在加入Zend之前，我就开始寻找提高PHP速度的方法，从事与公司竞争的我自己的项目。 在该项目的工作过程中，我彻底理解了该语言，并意识到不与主流项目一起工作，您只能影响脚本执行的某些方面，而所有最有趣和有效的操作都<strong>只能在内核中</strong>创建。 这种理解和巧合使我走向了Zend。 <br><br><h2> 略论PHP历史 </h2><br>  PHP不仅是而且<strong>不仅仅是一种编程语言</strong> 。  PHP代表个人主页-用于创建个人网页和动态网站的工具。 语言只是其主要部分之一。  PHP是一个功能强大的库，许多扩展用于与其他第三方库一起使用，例如，用于访问数据库或XML解析器，以及用于与各种Web服务器通信的一组模块。 <br><br> 丹麦程序员<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rasmus Lerdorf</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">于1995年6月</a>推出了PHP。 那时，它只是<strong>用Perl编写的CGI脚本</strong>的<strong>集合</strong> 。  96年4月，拉斯穆斯（Rasmus）推出了PHP / FI，并于6月发布了PHP / FI 2.0。 随后，Andy Gutmans和Zeev Surasky对这个版本进行了实质性的重新设计，并在第98发行了PHP 3.0。 到2000年，无论是在语言还是内部架构方面，这种语言已经成为我们如今所见的那种语言-基于Zend Engine的PHP 4。 <br><br> 从版本4开始，PHP不断发展。 转折点是2004年PHP 5的发布，当时<strong>对象模型已完全更新</strong> 。 是她开启了PHP框架的时代，并将性能问题提升到了一个新的高度。 预见到这一点，在5.0版本发布后，我们Zend立刻考虑了加速PHP的工作，并开始致力于提高生产力。 <br><br>  7.1版于2016年11月在综合测试中发布， <strong>比2002版快25倍</strong> 。 根据不同部门的性能变化图，主要突破在5.1和7.0中可见。 <br><br><img src="https://habrastorage.org/webt/ao/_s/mp/ao_smpopukfzjmclxqqu83xefvo.png"><br><br> 在5.1版中，我们才刚刚开始进行性能方面的工作，我们获得了一切，但是在5.3版之后，我们碰壁了，所有改进解释器的尝试都落空了。 <br><br> 不过，我们找到了挖掘的地方，并获得了超出预期的结果-与先前的5.6版测试相比，加速度提高了2.5倍。 但是最有趣的是，在未更改的实际应用程序中，我们获得了相同的2.5倍加速。 这是一种现象，因为我们在10年中的5个生命周期中都建立了先前的因子2。 <br><br><img src="https://habrastorage.org/webt/ge/9j/n_/ge9jn_isn9hxm-gbrk0ahaexfms.png"><br><br> 合成测试中5.1的巨大飞跃在实际应用中并不明显。 原因是在不同的用途下，PHP性能取决于与不同子系统相关的制动器。 <br><br>  <strong>PHP 7的历史始于三年停滞</strong> ，始于2012年，直到2015年结束第七个版本的发布。 然后我们意识到，仅通过对口译员进行少量改进，就无法再提高生产率，因此转向了JIT。 <br><br><h2> 在JIT周围徘徊 </h2><br> 我们花了将近两年的时间在PHP-5.5的JIT原型上。 首先，我们生成了一个非常简单的代码-一系列对标准处理程序的调用，类似于缝合的Fort代码。 然后，他们编写了自己的<strong>Runtime Assembler</strong> ，这是用于解决方法的内联单独代码，但意识到这种<strong>低级优化</strong>甚至对测试<strong>也没有实际</strong>效果。 <br><br> 然后，我们考虑使用静态分析方法导出变量类型。 意识到结论后，我们立即<strong>在测试中</strong>获得了<strong>2倍的加速度。</strong> 受到鼓舞，他们尝试编写全局寄存器分配器，但失败了。 我们使用了相当高级的表示形式，几乎不可能将其用于寄存器分配。 <br><br> 为了避免出现低级问题，我们决定尝试LLVM，一年后<strong>，Bench.php的加速度提高</strong>了<strong>10倍</strong> ，但在实际应用中却没有。 此外，现在编译真实的应用程序要花几分钟的时间，例如， <strong>对Wordpress</strong>的第一次<strong>请求花了2分钟，并且没有加速。</strong> 当然，这完全不适合实际实践。 <br><br><blockquote> 正确的类型预测可以产生良好的代码，而这种类型的预测在实际的应用程序中效果不佳，而使用PHP数据结构会使生成的代码效率低下。 </blockquote><br><h3> 什么变慢了？ </h3><br> 我们重新考虑了失败的原因，然后再次决定看看PHP为何运行缓慢。 该图显示了将多个请求分析到Wordpress主页的结果。 <br><br><img src="https://habrastorage.org/webt/3w/dh/7v/3wdh7vd40xumtwtyqgshsdan-a8.png"><br><br> 不到30％的时间用于解释字节码，20％的内存管理器开销，13％的哈希表处理，5％的正则表达式处理。 <br><br> 在JIT工作时，我们仅摆脱了前30％的工作，其他所有工作都无法实现。 几乎在所有地方，我们都被迫使用标准的PHP数据结构，这会产生开销：内存分配，引用计数等。 这种理解得出的结论是，有必要替换PHP中的关键数据结构。 以此<strong>为基础</strong> ， <strong>PHPNG</strong>项目<strong>开始了。</strong> <br><br><h2>  png 新世代 </h2><br> 该项目是在尝试为PHP创建JIT失败之后开发的。 主要目标是<strong>达到更高的生产率水平并为将来的改进奠定基础</strong> 。 <br><br> 我们承诺一段时间后，不再使用综合测试来衡量性能-这些通常是小型计算机程序，它们使用的数据量有限，完全适合处理器的缓存。 相比之下，实际的应用程序受制于与子系统内存相关的制动，并且从内存中进行一次读取可能会花费100条计算指令。  <strong>PHPNG项目是对关键PHP数据结构的重构，以优化内存访问</strong> 。 没有创新，与PHP 5兼容100％。 <br><br> 如何改变这些结构是显而易见的。 但是相关更改的数量巨大，因为<strong>PHP</strong>本身的<strong>核心是150,000行</strong> ，几乎三分之一的内容都需要更改。 添加基本​​分发中包含的一百多个扩展，针对不同Web服务器的十二个模块，您将实现该项目的宏伟壮丽。 <br><br> 我们甚至不确定我们是否会完成该项目。 因此，他们秘密启动了该项目，并仅在第一个乐观结果出现时才打开该项目。 简单地<strong>编译内核</strong>花了两个星期。 两个星期后，benched.php获得了。 我们花了一个半月的时间来确保Wordpress的工作。 一个月后，我们打开了该项目-2014年5月。 那时，我们<strong>在Wordpress上</strong>获得了<strong>30％</strong>的<strong>加速</strong> 。 这似乎已经是一个盛大的活动。 <br><br>  PHPNG立即引起了人们的关注，并于2014年8月将其<strong>用作PHP 7未来的基础</strong> 。 这已经是另一个具有不同目标集的项目，其中生产力只是其中一个。 <br><br><h2>  PHP 7.0 </h2><br> 版本号7本身令人怀疑。 前一个版本是第五个版本。 第六个是几年前开发的，完全致力于本机<strong>Unicode</strong>支持，但是在开发的早期阶段做出的不成功决定导致内核代码和每个扩展的过度复杂。 最后，决定冻结该项目。 <br><br> 到那时为止，已经积累了许多专门用于PHP 6的材料：在会议上的演讲，出版的书籍。 为了不让任何人感到困惑，我们将项目PHP 7跳过了PHP6。该版本要幸运得多-PHP 7几乎按计划于2015年12月发布。 <br><br> 除了性能之外，PHP 7中还出现了一些人们期待已久的创新： <br><br><ul><li> 能够定义参数和返回值的标量类型。 </li><li> 异常而不是错误-现在我们可以捕获并处理它们。 </li><li> <code>Zero-cost assert()</code> ，匿名类，清理不一致，新的运算符和函数（&lt;=&gt;，??）。 </li></ul><br> 创新是好的，但要回到内部变化。 让我们讨论一下PHP 7遵循的路径以及该路径可以指引我们的方向。 <br><br><h2> 兹瓦尔 </h2><br> 这是基本的PHP数据结构。 它用于<strong>表示PHP中的任何值</strong> 。 由于我们的语言是动态类型的，并且变量的类型可以在程序执行期间更改，因此我们需要存储一个类型字段（zend_uchar类型），该字段可以使用值IS_NULL，IS_BOOL，IS_LONG，IS_DOUBLE，IS_ARRAY，IS_OBJECT等，实际上由union（值）表示的值，其中可以存储整数，实数，字符串，数组或对象。 <br><br><h3>  PHP 5中的zval </h3><br> 每个此类结构的内存都在堆中单独分配。 除了类型和值外，它还包含对该结构的引用计数器。 因此，该结构占用了24个字节，还没有计算内存管理器及其指向的开销。 <br><br> 右上方的图片显示了在PHP 5内存中为简单脚本创建的数据结构。 <br><br><img src="https://habrastorage.org/webt/m8/km/ix/m8kmixgehjrhtxthe-gefmmi86i.png"><br><br> 在堆栈上，为指针所代表的4个变量分配了内存。 值本身（zval）在堆上。 在我们的例子中，这只是两个zval，每个zval由两个变量引用，因此它们的引用计数器设置为2。 <br><br> 要访问类型或标量值，您至少需要读取两次：首先读取指针的值，然后读取结构的值。 如果您不需要读取标量值，而是例如读取字符串或数组的一部分，则至少需要再读取一次。 <br><br><h3>  PHP 7中的zval </h3><br> 在以前使用指针的地方，在七个指针中我们开始嵌入zval。 我们已经不再使用标量类型的引用计数了。 字段的类型和值保持不变，但是没有添加其他标志和保留位置，稍后我将讨论。 <br><br><img src="https://habrastorage.org/webt/tz/we/yn/tzweyn8n32_rntdwwjxhz-fbwc4.png"><br><br> 左边是PHP 5，右边是PHP 7。 <br><br><img src="https://habrastorage.org/webt/5n/wl/4h/5nwl4hrqaqr2kb4pmenzvbtrnh4.png"><br><br> 现在，zval本身就在堆栈中。 要读取类型和标量值，只需一条机器指令就足够了。 所有值都分组在一个内存区域中，这意味着使用局部变量时，由于处理器高速缓存未命中，我们几乎不会损失。 但是，当需要复制时，新性能的真正力量就包括在内。 <br><br><h3> 复制记录 </h3><br> 在脚本的第一行，添加了另一个任务。 <br><br><img src="https://habrastorage.org/webt/kb/yr/ww/kbyrwwvzaeuqpt8quf1lyujztjo.png"><br><br> 在PHP5中，我们从堆中为新的zval分配了内存，初始化了它的int（2），更改了指向变量b的指针的值，并减少了b先前已引用的值的引用计数器。 <br><br> 在PHP 7中，我们只需<strong>要用几条指令</strong>就可以直接<strong>初始化变量b</strong> ，而在PHP 5中则需要数百条指令。 所以zval现在看起来在内存中。 <br><br><img src="https://habrastorage.org/webt/ax/ab/sa/axabsadvso8c49azoqvvks5jsfc.png"><br><br> 这是两个64位字。 第一个单词的<strong>含义是：</strong>整数，实数或指针。 在第二个单词中，是<strong>类型</strong> （表示如何解释含义），标志和保留位置，它们在对齐时仍会添加。 但是它并没有消失，但是被不同的子系统用来存储间接相关的值。 <br><br>  <strong>标志是一组位</strong> ，其中每个位指示zval是否支持协议。 例如，如果它是<code>IS_TYPE_REFCOUNTED</code> ，则在使用此zval时，引擎应注意参考计数器的值。 分配时，增加；离开范围时，减少；如果参考计数器达到零，则销毁从属结构。 <br><br> 在这些类型中，与PHP 5相比，出现了几个新类型。 <br><br><ul><li>  <code>IS_UNDEF</code>未初始化变量的标记。 </li><li> 单个<code>IS_BOOL</code>单独的<code>IS_FALSE</code>和<code>IS_TRUE</code> 。 </li><li> 添加了链接的单独类型和更多魔术类型。 </li></ul><br> 从<code>IS_UNDEF</code>到<code>IS_DOUBLE</code>类型是标量，不需要额外的内存。 要复制它们，只需复制第一个机器的64位字的值和第二个一半的类型和标志的值即可。 <br><br><h3> 重新计价 </h3><br> 与其他类型比较困难。 它们全部由一个从属结构表示，zval仅存储对该结构的引用。 对于每种类型，此结构都不同，但是就OOP而言，它们都有一个通用的抽象祖先或zend_refcounted结构。 它确定第一个<strong>64位字</strong>的格式，其中存储了垃圾回收的引用计数和其他信息。 <br><br><img src="https://habrastorage.org/webt/vn/zm/yy/vnzmyywum831lpzipgxtenm_98s.png"><br><br> 这个词可以简单地视为垃圾收集器的信息，并且特定类型的结构在第一个词之后添加其字段。 <br><br><h3> 线数 </h3><br> 在字符串的七个中，我们存储哈希函数的计算值，其长度和字符本身。 这种结构的大小是可变的，并且取决于字符串的长度。 必要时，为字符串计算一次哈希函数。 在PHP 5中，它可以根据需要进行重新计算。 <br><br><img src="https://habrastorage.org/webt/em/2t/ax/em2tax1wdnckpbzqxjh1tlqn37o.png"><br><br> 现在这些字符串是引用计数的，并且如果在PHP 5中我们复制了字符本身，现在足以增加此结构的引用计数。 <br><br> 与PHP 5一样，我们仍然具有<strong>不可变或内部字符串</strong>的概念。 它们通常存在于一个实例中，一直存在到查询结束，并且其行为类似于标量值。 我们不需要照顾对它们的引用的计数器，并且要进行复制就足以在四个机器指令的帮助下仅复制zval本身。 <br><br><h3> 数组 </h3><br> 数组由内置的哈希表表示，与PHP 5并没有太大区别。哈希表本身已更改，但在此方面有更多更改。 <br><br><img src="https://habrastorage.org/webt/_u/kn/ls/_uknlsdbw247d7whq_-euez8zuw.png"><br><br> 现在，数组是一种<strong>自适应结构</strong> ，根据存储的数据会稍微改变其内部结构和行为。 如果我们仅存储具有紧密数字键的元素，那么我们就可以通过索引直接访问元素，访问速度可以与C中的数组速度相媲美。但是，如果将具有字符串键的元素添加到同一数组中，它将变成具有冲突解决方案的真实哈希。 <br><br> 这就是哈希表在PHP 5中的样子。 <br><br><img src="https://habrastorage.org/webt/d6/c-/6r/d6c-6rvue6zlsyyhnscfyjtnjj4.png"><br><br> 这是经典的哈希表实现，使用线性列表来解决冲突（如右上角所示）。 每个项目都由一个桶代表。 所有存储桶都通过双向链接列表链接来解决冲突，并通过另一个双向链接列表链接来依次进行迭代。 每个zval的值是单独分配的-在存储桶中，我们仅存储指向其的链接。 同样，可以分别分配字符串键。 <br><br> 因此，对于每个哈希表，您需要分配很多小的内存块，并且为了以后查找内容，您必须沿着指针运行。 每次这样的转换都会导致cahce丢失和大约10-100个处理器周期的延迟。 <br><br> 这就是PHP 7中发生的情况。 <br><br><img src="https://habrastorage.org/webt/g_/mk/ax/g_mkaxt7a0ua8shao-rzketmjag.png"><br><br> 逻辑结构保持不变，只有物理结构改变。 现在，在哈希表下，通过一个操作分配内存。 <br><br> 在图片中，基本指针的底部是元素，顶部是由哈希函数寻址的哈希数组。 对于平面或压缩数组，当我们仅存储具有数字索引的元素时，上半部分根本没有分配，我们直接通过数字寻址存储桶。 <br><br> 为了绕过元素，我们从上到下或从下到上依次对其进行排序，现代处理器可以完美地做到这一点。 这些值内置在存储桶中，但其中的保留空间仅用于解决冲突。 它存储具有相同哈希函数值或列表标记结尾的另一个存储桶的索引。 <br><br> 键的字符串值的内存是单独分配的，但仍然是相同的zend_string。 当粘贴到数组中时，增加字符串的引用计数器就足够了，尽管在我们不得不直接复制字符之前，并且在搜索时，我们现在可以比较的不是字符串，而是指向字符串本身的指针。 <br><br><h3> 不变数组 </h3><br> 以前，我们有不可变的字符串，但现在也出现了不可变的数组。 像字符串一样，它们不使用引用计数，并且直到请求结束都不会销毁。 这是一个简单的脚本，它创建了一个包含一百万个元素的数组，每个元素都是带有单个“ hello”元素的同一数组。 <br><br><img src="https://habrastorage.org/webt/uv/sm/lu/uvsmluqtfldezjnbbfdqvd83sr8.png"><br><br> 在PHP 5中，每次循环迭代时，都会创建一个新的空数组，并向其中写入“ hello”，并将所有这些都添加到结果数组中。 在PHP 7中，在编译阶段，我们<strong>只创建一个</strong>行为类似于标量的<strong>不可变数组</strong> ，并将其添加到结果<strong>数组</strong>中。 在给出的示例中，这使我们可以减少10倍以上的内存消耗和近10倍的加速。 <br><br> 当然，在实际应用中通常不会发现数百万个元素的恒定数组，但是较小的元素很常见。 在他们每个人上，您都会获得一个小小的胜利。 <br><br><h3> 对象 </h3><br> 链接到PHP 5中所有对象的链接位于单独的存储库中，在zval中只有句柄-唯一的对象ID。 <br><br><img src="https://habrastorage.org/webt/in/lo/dq/inlodqhjne7lo12nslgcuqrckvy.png"><br><br> 为了达到目标，我们至少读取了3个读数。 此外，对象的每个属性的值的内存是分别分配的，我们至少需要再读取2次才能读取它。 <br><br> 在PHP 7中，我们能够转向直接寻址。 <br><br><img src="https://habrastorage.org/webt/zm/vp/vv/zmvpvvqlmybttr3zvze6gzglin4.png"><br><br>  <code>zend_object</code>可以通过一条机器指令访问<code>zend_object</code>地址。 而且Property是内置的，要阅读它们，您只需要再阅读一遍。 它们也被分组在一起，从而<strong>改善了数据的局部性，</strong>并帮助现代处理器避免绊倒。 <br><br> 除了预定义的属性，此对象的类的链接也存储在此处，一些处理程序-虚拟方法表的类似物，以及尚未定义的属性的哈希表。 在PHP中，您可以将属性添加到最初未定义的任何对象中，并且如果多条机器指令足以访问预定义的属性，则对于非预定义的属性，您将必须使用哈希表，这将需要数十条机器指令。 当然，这要贵得多。 <br><br><h3> 参考资料 </h3><br> 最后，我们必须引入一个<strong>单独的类型</strong>来表示PHP链接。 <br><br><img src="https://habrastorage.org/webt/yk/jj/ng/ykjjngfnlq8sefuvmwzjfxwjz7g.png"><br><br> 这是一个完全透明的类型。  PHP脚本不可见。 脚本会看到另一个内置在zend_reference结构中的zval。 可以理解，我们至少从两个位置引用了这种结构，并且该结构的参考计数器始终大于1。一旦计数器降为1，链接就会变成常规的标量值。 链接中嵌入的zval被复制到引用它的最后一个zval，并且结构本身被删除。 <br><br> 看来现在使用引用比使用其他类型复杂得多（这是事实），但是实际上在PHP 5中，访问任何值（甚至是素数整数）时，我们都必须进行相当复杂的工作。 现在，我们仅将一种更复杂的协议应用于一种类型，从而加快了与其他所有类型的协议的工作，尤其是标量值的工作。 <br><br><h3>  IS_FALSE和IS_TRUE </h3><br> 我已经说过，单个类型IS_BOOL被分为单独的IS_FALSE和IS_TRUE。 这个想法在LuaJIT的实现中得到了体现，并被用来加速最常见的操作之一-条件转换。 <br><br><img src="https://habrastorage.org/webt/fv/5j/-z/fv5j-zx0u_2kfmtmxjwce4uzetk.png"><br><br> 如果在PHP 5中需要读取类型，检查布尔值，读取值，确定是true还是false并基于此进行转换，那么现在只需检查类型并将其与true进行比较就足够了： <br><br><ul><li> 如果是真的，那么我们沿着一个分支前进； </li><li> 如果小于真，则转到另一个分支；否则，转到另一个分支。 </li><li> 如果它大于true，请转到所谓的慢路径（slow path），在那里我们检查它来自什么类型以及如何处理：如果它是整数，那么我们必须将其值与0进行比较，如果是float-则再次与0（但真实）等 </li></ul><br><h2> 通话约定 </h2><br> 调用约定或函数调用约定的更改是一项重要的优化，不仅影响数据结构，而且还影响基础算法。 左图中是一个小的脚本，由foo（）函数及其调用组成。 以下是PHP 5将该脚本编译到的字节码。 <br><br><img src="https://habrastorage.org/webt/bn/fw/a4/bnfwa4e5ifjqs6rd6cp66uctega.png"><br><br> 首先，我将告诉您它在PHP 5中是如何工作的。 <br><br><h3>  PHP 5中的调用约定 </h3><br> 第一个<code>SEND_VAL</code>语句是将值“ 3”发送到foo函数。 为此，她被迫在堆上分配一个新的zval，在其中复制值（3）并将指向该结构的指针的值写入堆栈。 <br><br><img src="https://habrastorage.org/webt/mt/vu/d3/mtvud3tb2ljaijnwecbmvnqepjs.png"><br><br> 与第二条指令类似。 进一步的<code>DO_FCALL</code>初始化了<code>CALL FRAME</code> ，为局部和临时变量保留了一个位置，并将控制权转移给了被调用的函数。 <br><br><img src="https://habrastorage.org/webt/rx/rw/qo/rxrwqogtbhgd0q9tsd7wnw2r4og.png"><br><br> 第一个<code>RECV</code>检查第一个参数，并使用相应的局部变量（$ a）初始化堆栈上的插槽。 在这里，我们没有进行复制，只是增加了相应参数（zval的值为3）的参考计数器。 同样，第二条<code>RECV</code>在变量$ b和参数5之间建立了连接。 <br><br><img src="https://habrastorage.org/webt/lw/c1/zw/lwc1zw26uby_oj54yjzu7yz-vus.png"><br><br> 进一步的身体功能。 发生了3 + 5加法-结果为8。这是一个临时变量，其值直接存储在堆栈中。 <br><br><img src="https://habrastorage.org/webt/d0/xj/s5/d0xjs5j2c0i6qgioybezypay9k4.png"><br><br> 返回，我们从函数返回。 <br><br><img src="https://habrastorage.org/webt/zd/cc/nb/zdccnbal1xuynwdcymbrwcf2fmq.png"><br><br> 返回时，我们释放所有超出范围的变量和参数。 为此，我们要检查释放帧中插槽引用的所有zval，并为每一个减少引用计数。 如果达到0，则销毁相应的结构。 <br><br> 如您所见，即使是向函数发送常量这样的简单操作，也需要分配新的内存，复制和增加引用计数器，然后还要进行两次减少和删除。 <br><br><h3>  PHP 7中的调用约定 </h3><br> 在PHP 7中，这些问题已修复-现在在堆栈上，我们存储的不是zval指针，而是zval指针。 <br><br><img src="https://habrastorage.org/webt/xc/ek/ls/xceklspoxwmga__zvpeat1a4plw.png"><br><br> 我们还引入了一条新指令<code>INIT_FCALL</code> ，该指令现在负责在<code>CALL FRAME</code>下初始化和分配内存，并为参数和临时变量保留空间。 <br><br><img src="https://habrastorage.org/webt/yi/gd/a5/yigda5wg7xswdcyadip7euboboa.png"><br><br>  <code>SEND_VAL 3</code>现在仅将参数复制到<code>CALL FRAME</code>之后的第一个插槽。 接下来的<code>SEND_VAL 5</code>到第二个广告位。 <br><br><img src="https://habrastorage.org/webt/-0/es/8_/-0es8_skigjtyvja3vzzegwo-su.png"><br><br> 然后最有趣。 似乎<code>DO_FCALL</code>应该将控制权传递给被调用函数的第一条指令。 但是参数已经触及了为变量参数$ a和$ b保留的位置，而<code>RECV</code>指令什么也没做。 因此，您可以直接跳过它们。 我们发送了两个参数，因此我们跳过了两个指令。 如果他们发送了三个，他们将错过三个。 <br><br><img src="https://habrastorage.org/webt/4z/vm/gj/4zvmgjldpmtfpgprtvqoks__-km.png"><br><br> 因此，我们直接转到函数的主体，进行加法并返回。 <br><br><img src="https://habrastorage.org/webt/zh/j1/yf/zhj1yfwxp5kf1s4xxlyoasy170i.png"><br><br> 返回时，我们清除所有局部变量，但是现在仅清除两个插槽，并且由于那里有标量，因此我们无需执行任何操作。 <br><br><img src="https://habrastorage.org/webt/wy/dh/2p/wydh2pvz_hpawjivtoxx3hmxoqa.png"><br><br> 我的故事有些简化，它没有考虑变量数量可变的函数以及类型检查和其他一些要点。 <br><br>  <strong>新的《呼叫约定》已经破坏了兼容性</strong> 。  PHP具有<code>func_get_arg</code>和<code>func_get_args</code>类的功能。 如果以前他们返回了已发送参数的原始值，则现在他们返回了相应局部变量的当前值，因为我们只是不存储原始值。 就像C.调试器一样 <br><br><img src="https://habrastorage.org/webt/5r/n2/6j/5rn26j24gjyfolmeu07qgv1wmxu.png"><br><br> 此外，该函数不能再包含多个具有相同名称的参数。 之前没有任何意义，但是我遇到了这样的PHP代码<code>foo($_, $_)</code> 。 看起来像什么？  （我认可Prolog） <br><br><h2> 新的内存管理器 </h2><br> 完成数据结构和基本算法的优化后，我们再次提请注意所有制动子系统。  PHP 5中的内存管理器在Wordpress上占用了<strong>近20％的处理器时间</strong> 。 <br><br> 在我们摆脱了很多分配之后，他的管理费用变得更少了，但是仍然很可观-并不是因为他正在做任何重要的工作，而是因为他偶然发现了缓存。 发生这种情况的原因是，我们使用了经典的道格·里阿（Doug Lea）的malloc算法，该算法涉及通过链接和树来查找合适的空闲内存位置，所有这些行程不可避免地导致高速缓存未命中。 <br><br> 如今，有新的内存管理算法考虑了现代处理器的功能。 例如： <strong>Google的</strong> <strong>jemalloc</strong>和<strong>ptmalloc</strong> 。 最初，我们尝试不加改变地使用它们，但没有成功，因为缺少特定的PHP功能使在请求结束时完全释放内存的成本更高。 结果，我们放弃了dlmalloc并编写了自己的东西，结合了旧内存管理器和jemalloc的想法。 <br><br> 我们将<strong>内存管理器的开销减少到5％</strong> ，减少了服务信息的内存开销，并改善了CPU缓存的使用。 现在可以通过位图搜索合适的内存块，从各个页面分配小块的内存，并在释放时进行缓存，并添加针对常用块大小的专用功能。 <br><br><h2> 许多小的改进 </h2><br> 我只谈到了最重要的改进，但是还有很多次要的改进。 我可以提到其中一些。 <br><br><ul><li> 用于解析内部函数参数的快速API，以及用于在HashTable上进行迭代的新API。 </li><li> 新的VM指令：字符串连接，特殊化，超级指令。 </li><li> 一些内部功能已变成VM指令：strlen，is_int。 </li><li> 将CPU寄存器用作VM寄存器：IP和FP。 </li><li> 优化复制和删除数组。 </li><li> 使用链接计数而不是尽可能复制。 </li><li>  PCRE JIT。 </li><li> 优化内部功能并序列化（）。 </li><li> 减少代码大小并处理数据。 </li></ul><br> 有些非常简单，例如，只需要三行代码就可以在常规Perl表达式中启用JIT，这立即为几乎所有应用程序带来了可见的（2-3％）加速。 其他优化涉及某些PHP函数的某些狭窄方面，尽管这些小改进的总贡献是非常重要的，但并不是特别有趣。 <br><br><h2> 发生了什么 </h2><br> 这是WordPress / PHP 7.0上各个子系统的贡献。 <br><br><img src="https://habrastorage.org/webt/7q/r4/d0/7qr4d08m8yhid4rngwh9-gffxbu.png"><br><br> 虚拟机的贡献增加到50％。 Memory Manager    5% —         Memory Manager,        .         130 . ,    10 .  ,           Memory Manager           ,         . <br><br><img src="https://habrastorage.org/webt/kk/nq/5p/kknq5ppnd1ihr8wjw9xfv38boyy.png"><br>   : <br><br><ul><li>      2 . </li><li>   MM   17 . </li><li> -     4 . </li><li>    WordPress   3,5 . </li></ul><br>       2,5-  ,    .  ?   ,         ,        CPU time,   —  ,    .  PHP     ,        . <br><br><h3>  PHP 7 </h3><br> WordPress 3.6      —         .  - ,   PHP 7   mysql,     ,     . <br><br><img src="https://habrastorage.org/webt/bs/x9/pa/bsx9pa3fc3ccedmnajaj1h5dm0q.png"><br><br>   ,          PHPNG.     2/3 .     ,    . <br><br> ,       WordPress,      ,      —  1,5  2- . <br><br><h3> PHP 7  HHVM </h3><br>              HHVM. <br><br><img src="https://habrastorage.org/webt/fs/vg/ot/fsvgotogozunvqed7dwflmmef1u.png"><br><br>      —  .     .   Facebook   .   HHVM   . ,      ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/c_/pg/jv/c_pgjvoejr-q3o5sgvgtplxkbm0.png"><br><br>  PHP 7 —    .    Vebia,  Etsy  Badoo. Highload-    ,       . <br><br>   PHP 7.0  Etsy  Badoo       -. Badoo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>    . <br><br><img src="https://habrastorage.org/webt/pn/rv/rj/pnrvrjrzp9re46lbmngnyddzu44.png"><br><br>  ,          2 ,    —   7 . <br><br>         PHP 7.0.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,  PHP 7.1,        . <br><br><blockquote>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PHP Russia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>        <b>PHP 8</b> .         PHP,  ,    ,      — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>  1 .  , ,    —   ,    ,     ,  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444508/">https://habr.com/ru/post/zh-CN444508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444494/index.html">La Moto Volante（Lazareth LMV 496）-飞行变压器摩托车</a></li>
<li><a href="../zh-CN444496/index.html">用于检测HTTPS拦截的新工具</a></li>
<li><a href="../zh-CN444500/index.html">3月29日，莫斯科-后端故事3.0</a></li>
<li><a href="../zh-CN444502/index.html">量子密码学真的可靠吗？</a></li>
<li><a href="../zh-CN444504/index.html">立即在Python中使用本地包目录</a></li>
<li><a href="../zh-CN444512/index.html">创建一个图形化应用程序来解决骑马过程中的问题</a></li>
<li><a href="../zh-CN444514/index.html">网络研讨会“机器学习安全性：人工智能的自然问题”</a></li>
<li><a href="../zh-CN444516/index.html">Wolfenstein 3D：使用WebGL1进行光线跟踪</a></li>
<li><a href="../zh-CN444518/index.html">走向意识的基本理论</a></li>
<li><a href="../zh-CN444520/index.html">2. Check Point入门R80.20。 解决方案架构</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>