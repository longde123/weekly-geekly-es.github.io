<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗣️ 🛌🏿 👉🏾 Penyimpanan terdistribusi Rusia. Bagaimana cara kerjanya 🐷 🆘 🔤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Musim semi ini, tim Reydiks menyiapkan dan merilis versi pertama dari perangkat lunak untuk membuat sistem penyimpanan blok terdistribusi yang berjala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penyimpanan terdistribusi Rusia. Bagaimana cara kerjanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raidix/blog/415961/"><img src="https://habrastorage.org/webt/wn/-j/zy/wn-jzyaxkasgaeb_mcf8xmjhhri.jpeg"><br><br>  Musim semi ini, tim Reydiks menyiapkan dan merilis versi pertama dari perangkat lunak untuk membuat sistem penyimpanan blok terdistribusi yang berjalan pada platform server Elbrus-4.4 berdasarkan mikroprosesor Elbrus-4C. <br><br>  Kegunaan simbiosis semacam itu dapat dilihat dengan mata telanjang - perakitan sistem penyimpanan berdasarkan besi domestik dan sistem operasi domestik menjadi produk yang menarik dari pasar domestik, khususnya bagi pelanggan dengan fokus pada substitusi impor. <br><a name="habracut"></a><br>  Namun, potensi sistem operasi yang dikembangkan tidak terbatas pada platform server Rusia.  Saat ini, kompatibilitas dengan server x86-64 standar, yang didistribusikan secara luas di pasar, sedang diuji dan diuji.  Selain itu, produk "selesai" dengan fungsi yang diinginkan, yang akan memungkinkan penerapannya di luar pasar Rusia. <br><br>  Di bawah ini kami akan menyajikan diskusi kecil tentang bagaimana solusi perangkat lunak (disebut RAIDIX RAIN) diatur, yang memungkinkan menggabungkan media server lokal menjadi satu cluster penyimpanan toleran-kesalahan dengan manajemen terpusat dan kemampuan penskalaan horizontal dan vertikal. <br><br><h2>  Fitur Penyimpanan Terdistribusi </h2><br>  Sistem penyimpanan tradisional, dibuat dalam bentuk kompleks perangkat keras dan lunak tunggal, memiliki masalah umum terkait penskalaan: kinerja sistem bergantung pada pengontrol, jumlah mereka terbatas, ekspansi kapasitas dengan menambahkan rak ekspansi dengan operator tidak meningkatkan produktivitas. <br><br>  Dengan pendekatan ini, kinerja keseluruhan sistem penyimpanan akan turun, karena dengan peningkatan kapasitas, jumlah pengontrol sebelumnya perlu memproses lebih banyak operasi akses ke volume data yang meningkat. <br><br>  RAIDIX RAIN mendukung penskalaan blok horizontal, berbeda dengan solusi tradisional, meningkatkan node (blok server) dari sistem mengarah pada peningkatan linier dalam kapasitas tidak hanya, tetapi juga kinerja sistem.  Hal ini dimungkinkan karena setiap simpul RAIDIX RAIN tidak hanya mencakup media, tetapi juga sumber daya komputasi untuk I / O dan pemrosesan data. <br><br><h2>  Skenario aplikasi </h2><br>  RAIDIX RAIN melibatkan penerapan semua skenario aplikasi utama untuk penyimpanan blok terdistribusi: infrastruktur penyimpanan cloud, basis data yang sangat banyak, dan penyimpanan analisis Big Data.  RAIDIX RAIN juga dapat bersaing dengan sistem penyimpanan tradisional dengan volume data yang cukup tinggi dan kemampuan keuangan yang sesuai dari klien. <br><br><h3>  Awan publik dan pribadi </h3><br>  Solusi ini memberikan skalabilitas fleksibel yang diperlukan untuk menggunakan infrastruktur cloud: peningkatan kinerja, throughput, dan kapasitas penyimpanan dengan setiap node ditambahkan ke sistem. <br><br><h3>  Basis data </h3><br>  Cluster RAIDIX RAIN dalam konfigurasi all-flash adalah solusi yang efisien untuk melayani basis data yang sangat dimuat.  Solusi ini akan menjadi alternatif yang terjangkau untuk produk Oracle Exadata untuk Oracle RAC. <br><br><h3>  Analisis Data Besar </h3><br>  Bersama dengan perangkat lunak tambahan, dimungkinkan untuk menggunakan solusi untuk melakukan analisis data besar.  RAIDIX RAIN memberikan tingkat kinerja dan kemudahan perawatan yang jauh lebih tinggi dibandingkan dengan cluster HDFS. <br><br><h2>  Arsitektur Solusi </h2><br>  RAIDIX RAIN mendukung 2 opsi penempatan: berdedikasi (eksternal atau konvergen) dan hyper-konvergensi (HCI, infrastruktur hyper-konvergen). <br><br><h3>  Opsi Penempatan Khusus </h3><br>  Dalam versi yang dipilih, cluster RAIDIX RAIN adalah penyimpanan perangkat lunak klasik.  Solusinya dikerahkan pada jumlah node server khusus yang diperlukan (setidaknya 3, jumlahnya praktis tak terbatas dari atas), sumber daya yang sepenuhnya digunakan untuk tugas penyimpanan. <br><img src="https://habrastorage.org/webt/jr/zz/wd/jrzzwd0nqs1ykrpbv5nousfxfh0.png"><br>  <i><font color="#99999">Fig.</font></i>  <i><font color="#99999">1. Opsi penyebaran khusus</font></i> <br><br>  Perangkat lunak RAIDIX RAIN diinstal langsung pada bare metal.  Aplikasi, layanan, sumber daya komputasi yang menggunakan RAIN untuk menyimpan informasi di-host pada host eksternal dan terhubung dengannya melalui jaringan penyimpanan (arsitektur pusat data klasik). <br><br><h3>  Opsi penerapan hyperconverged </h3><br>  Opsi hyperconvergent melibatkan penempatan daya komputasi bersama (hypervisor dan VM produksi) dan sumber daya penyimpanan (penyimpanan perangkat lunak) dari pusat data pada satu set node, terutama ini berlaku untuk infrastruktur virtual.  Dengan pendekatan ini, perangkat lunak RAIN diinstal pada setiap host (node) infrastruktur (HCI) dalam bentuk mesin virtual. <br><img src="https://habrastorage.org/webt/rc/6g/s4/rc6gs4fegn69jy4fpfy7idz45nw.png"><br>  <i><font color="#99999">Fig.</font></i>  <i><font color="#99999">2. Opsi penyebaran Hyperconverged</font></i> <br><br>  Interaksi node cluster RAIN satu sama lain dan dengan pengguna akhir sumber daya penyimpanan (server, aplikasi) dilakukan melalui iSCSI (IP, IPoIB), iSER (RoCE, RDMA) atau protokol NVMeOF. <br><br>  Opsi penerapan hyperconverged menawarkan manfaat berikut: <br><br><ul><li>  Konsolidasi sumber daya komputasi dan penyimpanan (tidak perlu menerapkan dan memelihara penyimpanan eksternal khusus). </li><li>  Penskalaan blok horisontal gabungan sumber daya komputasi dan sumber daya penyimpanan. </li><li>  Kemudahan implementasi dan pemeliharaan. </li><li>  Manajemen terpusat. </li><li>  Menghemat kapasitas rack-mount dan konsumsi daya. </li></ul><br>  Dalam hal media yang digunakan, RAIDIX RAIN mendukung 3 konfigurasi: <br><br><ul><li>  All-flash - node cluster hanya disediakan dengan media flash (NVMe, SSD); </li><li>  HDD - node cluster hanya disediakan dengan HDD-carrier; </li><li>  Hibrida - dua tingkat penyimpanan independen pada HDD dan SSD. </li></ul><br><br><h2>  Ketahanan Produktif </h2><br>  <b>Nilai inti dari RAIDIX RAIN</b> adalah keseimbangan kinerja, toleransi kesalahan, dan penggunaan kapasitas penyimpanan yang efisien. <br><br>  Sebagai bagian dari infrastruktur TI klien, RAIDIX RAIN juga menarik karena kami memiliki akses blok "jujur" pada output, yang membedakan solusi dari sebagian besar analog pasar. <br><br>  Saat ini, sebagian besar produk kompetitif menunjukkan kinerja tinggi, hanya ketika menggunakan mirroring.  Pada saat yang sama, kapasitas penyimpanan yang berguna berkurang sebanyak 2 kali atau lebih: replikasi data tunggal (mirroring) - redundansi 50%, replikasi data ganda (mirroring ganda) - redundansi 66,6%. <br><br>  Penggunaan teknologi optimisasi penyimpanan seperti EC (Erasure Coding - noiseless coding), deduplikasi dan kompresi yang diterapkan dalam sistem penyimpanan terdistribusi menyebabkan penurunan kinerja penyimpanan yang signifikan, yang tidak dapat diterima untuk aplikasi yang sensitif terhadap penundaan. <br><br>  Oleh karena itu, dalam praktiknya, solusi semacam itu biasanya dipaksa untuk beroperasi tanpa menggunakan teknologi ini, atau untuk memasukkannya hanya untuk data "dingin". <br><br><h3>  Persyaratan kegagalan </h3><br>  Awalnya, RAIDIX RAIN dirancang dengan serangkaian persyaratan awal yang jelas untuk ketahanan dan ketersediaan sistem: <br><br><ul><li>  Cluster harus selamat dari kegagalan setidaknya dua node, dengan jumlah node benar-benar lebih besar dari 4. Untuk tiga dan empat, kegagalan satu node dijamin. </li><li>  Sebuah node harus selamat dari kegagalan setidaknya dua disk di setiap node jika setidaknya ada 5 disk dalam sebuah node. </li><li>  Tingkat redundansi drive pada kluster tipikal (dari 16 node) tidak boleh lebih dari 30% </li><li>  Tingkat ketersediaan data harus minimal 99,999% </li></ul><br>  Ini telah sangat mempengaruhi arsitektur produk yang ada. <br><br><h3>  Menghapus Kemampuan Pengkodean dalam Penyimpanan Terdistribusi </h3><br>  Pendekatan toleransi kesalahan utama RAIDIX RAIN adalah penggunaan teknologi Erasure Coding yang unik.  Perusahaan EC yang dikenal dengan produk andalannya juga digunakan dalam penyimpanan terdistribusi, yang memungkinkan kinerjanya sebanding dengan konfigurasi cermin.  Ini berlaku untuk muatan acak dan berurutan.  Pada saat yang sama, tingkat toleransi kesalahan yang telah ditentukan dipastikan dan kapasitas yang berguna meningkat secara signifikan, dan biaya overhead tidak lebih dari 30% dari kapasitas penyimpanan mentah. <br><br>  Disebutkan terpisah diperlukan EC RAIDIX kinerja tinggi pada operasi berurutan, khususnya ketika menggunakan disk SATA berkapasitas besar. <br><br>  Secara umum, RAIDIX RAIN menawarkan 3 opsi pengkodean koreksi-kesalahan: <br><br><ul><li>  selama 3 node, penggunaan RAID 1 optimal; </li><li>  untuk 4 node, penggunaan optimal RAID 5; </li><li>  untuk subkluster penyimpanan 5 hingga 20 node, pendekatan optimal adalah dengan menggunakan RAID jaringan 6. </li></ul><br><img src="https://habrastorage.org/webt/ci/55/pd/ci55pdydidxbcjdkpzbhn5bwmzs.png"><br>  <i><font color="#99999">Fig.</font></i>  <i><font color="#99999">3. Opsi untuk pengkodean koreksi kesalahan</font></i> <br><br>  Semua opsi mengasumsikan distribusi data yang seragam di semua node cluster dengan penambahan redundansi dalam bentuk checksum (atau kode koreksi).  Ini memungkinkan kita untuk menggambar paralel dengan kode Reed-Solomon yang digunakan dalam array RAID standar (RAID-6) dan memungkinkan failover hingga 2 operator.  Jaringan RAID-6 bekerja mirip dengan yang berbasis disk, namun, itu mendistribusikan data di antara node cluster dan memungkinkan failover dari 2 node. <br><br>  Dalam RAID 6, ketika 1-2 operator gagal dalam satu node, mereka dipulihkan secara lokal tanpa menggunakan checksum terdistribusi, meminimalkan jumlah data yang dipulihkan, beban jaringan dan degradasi sistem secara keseluruhan. <br><br><h3>  Domain kegagalan </h3><br>  HUJAN mendukung konsep domain kesalahan atau domain ketersediaan.  Ini memungkinkan Anda untuk mengetahui kegagalan tidak hanya node individual, tetapi juga seluruh server rak atau keranjang, yang node secara logis dikelompokkan ke dalam domain kegagalan.  Kemungkinan ini dicapai dengan mendistribusikan data untuk memastikan toleransi kesalahan mereka tidak pada tingkat node individu, tetapi pada tingkat domain, yang akan memungkinkan untuk bertahan dari kegagalan semua node yang dikelompokkan di dalamnya (misalnya, seluruh rak server).  Dalam pendekatan ini, cluster dibagi menjadi subkelompok independen (subclust).  Jumlah node dalam satu subkelompok tidak lebih dari 20, yang menyediakan persyaratan untuk toleransi kesalahan dan ketersediaan.  Selain itu, jumlah subkelompok tidak terbatas. <br><img src="https://habrastorage.org/webt/mb/y6/u2/mby6u20ud-fmtvc2jiaghsjmr8u.png"><br>  <i><font color="#99999">Fig.</font></i>  <i><font color="#99999">4. Kegagalan Domain</font></i> <br><br>  Kegagalan setiap kegagalan (disk, node atau jaringan) dilakukan secara otomatis, tanpa menghentikan sistem. <br><br>  Selain itu, semua perangkat cluster RAIDIX RAIN dilindungi terhadap kegagalan daya dengan menghubungkan ke catu daya tak terputus (UPS).  Perangkat yang terhubung ke UPS yang sama disebut kelompok kegagalan daya. <br><br><h2>  Fitur dan Fungsi </h2><br>  Pertimbangkan fitur fungsional utama RAIDIX RAIN. <br>  <i><font color="#99999">Tabel 1. Fitur Basic RAIDIX RAIN</font></i> <br><table><tbody><tr><th>  Karakteristik operasional </th><th>  Nilai </th></tr><tr><td>  Jenis Node yang Didukung </td><td>  Platform server domestik berdasarkan pada prosesor Elbrus-4C <br>  Server standar x86-64 (perspektif) </td></tr><tr><td>  Jenis Media yang Didukung </td><td>  SATA dan SAS HDD, SATA dan SAS SSD, NVMe </td></tr><tr><td>  Kapasitas penyimpanan maksimum </td><td>  16 EB </td></tr><tr><td>  Ukuran cluster maksimum </td><td>  1.024 knot </td></tr><tr><td>  Fungsionalitas dasar </td><td>  Ekspansi Volume Panas <br>  Hot menambahkan node ke cluster <br>  Penyeimbangan ulang kluster <br>  Gagal tanpa downtime </td></tr><tr><td>  Teknologi Ketahanan </td><td>  Kegagalan node, media, jaringan. <br>  Erasure Coding, didistribusikan di seluruh node cluster: network RAID 0/1/5/6. <br>  Kode koreksi di tingkat pembawa host lokal (RAID 6 lokal) <br>  Domain kegagalan </td></tr></tbody></table><br>  Sebagai fitur fungsional penting RAIDIX RAIN, perlu dicatat bahwa layanan seperti <b>inisialisasi, rekonstruksi dan penulisan ulang (penskalaan) masuk di latar belakang dan mereka dapat diatur ke parameter prioritas</b> . <br><br>  Pengaturan prioritas memungkinkan pengguna untuk secara mandiri menyesuaikan beban dalam sistem, mempercepat atau memperlambat kerja layanan ini.  Misalnya, prioritas 0 berarti bahwa layanan hanya berfungsi ketika tidak ada beban dari aplikasi klien. <br><br><h3>  Opsi penskalaan </h3><br>  Proses memperluas RAIDIX RAIN cluster adalah sesederhana dan seotomatis mungkin, sistem secara independen mendistribusikan kembali data dalam proses latar belakang dengan mempertimbangkan kapasitas node baru, beban menjadi seimbang dan seragam, kinerja keseluruhan dan kapasitas penyimpanan ditingkatkan secara proporsional.  Proses penskalaan horisontal melewati "panas" tanpa downtime, tidak memerlukan penghentian aplikasi dan layanan. <br><img src="https://habrastorage.org/webt/jp/93/5s/jp935sen4sbae6usigcpgmytu2e.png"><br>  <i><font color="#99999">Fig.</font></i>  <i><font color="#99999">5. Skema dari proses penskalaan</font></i> <br><br><h3>  Fleksibilitas arsitektur </h3><br>  RAIDIX RAIN adalah produk perangkat lunak dan tidak terbatas pada platform perangkat keras tertentu - konsepnya menunjukkan kemampuan untuk menginstal pada perangkat keras server yang kompatibel. <br><br>  Berdasarkan spesifik infrastruktur dan aplikasi mereka, setiap pelanggan memilih opsi penyebaran terbaik: berdedikasi atau hyperconverged. <br><br>  Dukungan untuk berbagai jenis media memungkinkan Anda membangun berdasarkan anggaran dan tugas-tugas yang akan dibangun berdasarkan RAIDIX RAIN: <br>  1. mendistribusikan semua penyimpanan flash dengan kinerja tinggi yang belum pernah terjadi sebelumnya dan dijamin latensi rendah; <br>  2. sistem hybrid ekonomis yang memenuhi sebagian besar tipe beban dasar. <br><br><h2>  Indikator kinerja </h2><br>  Sebagai kesimpulan, kami akan menunjukkan beberapa angka yang diperoleh sebagai hasil pengujian RAIDIX RAIN pada konfigurasi cluster NVMe 6-node.  Sekali lagi, kami mencatat bahwa pada perakitan seperti itu (dengan server x86-64) produk masih dalam penyelesaian, dan angka-angka ini belum final. <br><br><h3>  Lingkungan uji </h3><br><ul><li>  6 knot pada 2 disk NVMe HGST SN100 </li><li>  Kartu IB Mellanox MT27700 Family [ConnectX-4] </li><li>  Kernel Linux 4.11.6-1.el7.elrepo.x86_64 </li><li>  MLNX_OFED_LINUX-4.3-1.0.1.0-rhel7.4-x86_64 </li><li>  Raid lokal - raid 0 </li><li>  Serangan eksternal - serangan 6 </li><li>  Benchmark untuk pengujian FIO 3.1 </li></ul><br><br>  <b>UPD:</b> beban dilakukan dalam blok 4K, berurutan - 1M, kedalaman antrian 32. Beban diluncurkan pada semua node cluster secara bersamaan dan tabel menunjukkan hasil total.  Penundaan tidak melebihi 1 ms (99,9 persen). <br><br>  <i><font color="#99999">Tabel 2. Hasil Tes</font></i> <br><table><tbody><tr><th>  Jenis beban </th><th>  Nilai </th></tr><tr><td>  Baca acak 100% </td><td>  4.098.000 IOps </td></tr><tr><td>  Tulis acak 100% </td><td>  517.000 IOps </td></tr><tr><td>  Sequential read 100% </td><td>  33,8 GB / s </td></tr><tr><td>  Penulisan berurutan 100% </td><td>  12 GB / s </td></tr><tr><td>  Baca acak 70% / tulis acak 30% </td><td>  1.000.000 IOps / 530.000 IOps </td></tr><tr><td>  Acak baca 50% / tulis acak 50% </td><td>  530.000 IOps / 530.000 IOps </td></tr><tr><td>  Acak baca 30% / tulis acak 70% </td><td>  187.000 IOps / 438.000 IOps </td></tr></tbody></table></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415961/">https://habr.com/ru/post/id415961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415949/index.html">Penambangan tinggi: opsi terbaru untuk melindungi blockchain PoW dari “serangan 51%”</a></li>
<li><a href="../id415951/index.html">Mitap Sberbank dan IBM di HyperLedger Fabric</a></li>
<li><a href="../id415953/index.html">Bagaimana perusahaan berdarah memenangkan sumber terbuka: pertempuran untuk BPMS</a></li>
<li><a href="../id415957/index.html">Kami membutuhkan lebih banyak ransel: Bobby XL dari XD Design</a></li>
<li><a href="../id415959/index.html">Ketika kami menulis kode jaringan penembak PvP seluler: sinkronisasi pemain pada klien</a></li>
<li><a href="../id415963/index.html">Naif Bayes, atau bagaimana matematika memungkinkan Anda untuk memfilter spam</a></li>
<li><a href="../id415965/index.html">Apa yang harus dibaca pada bulan Juli: 19 buku baru untuk para profesional digital</a></li>
<li><a href="../id415967/index.html">SolidFire - Penyimpanan untuk penyimpanan ** cking hate</a></li>
<li><a href="../id415969/index.html">HyperX Pulsefire Surge RGB - pembunuh alami</a></li>
<li><a href="../id415973/index.html">Bagaimana tidak memecah gugus Apache Ignite dari awal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>