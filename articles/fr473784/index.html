<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇 🤞🏻 🥝 Comment rédiger un contrat intelligent pour WebAssembly sur un réseau d'ontologie? Partie 2: C ++ 👂🏾 🈴 👩🏾‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous examinerons deux exemples de la façon d'écrire un contrat intelligent en C ++ à l'aide de WASM basé sur le réseau de blockchain...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rédiger un contrat intelligent pour WebAssembly sur un réseau d'ontologie? Partie 2: C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473784/"><img src="https://habrastorage.org/getpro/habr/post_images/3e1/ec5/4dd/3e1ec54ddc0f1d35cad05f7f2b6e600e.png" alt="image"><br><br>  Dans cet article, nous examinerons deux exemples de la façon d'écrire un contrat intelligent en C ++ à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WASM</a> basé sur le réseau de blockchain d'Ontology.  Aujourd'hui, après plusieurs mois de fonctionnement stable en mode test, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ontology a lancé WASM</a> sur le réseau principal, ce qui permet de transférer des contrats dApp avec une logique métier complexe vers la blockchain sans douleur et à moindre coût, enrichissant ainsi considérablement l'écosystème dApp. <br><br>  Ontology Wasm prend également en charge la création de contrats intelligents dans la langue Rust, vous pouvez en lire plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Voici deux exemples de contrat intelligent: tout d'abord, écrivez «Bonjour tout le monde!»  puis créez une enveloppe d'argent virtuelle qui peut être envoyée à un ami en cadeau. <br><br><h2>  Développement d'un contrat WASM en C ++ </h2><br><a name="habracut"></a><br><h3>  Exemple 1. Bonjour tout le monde </h3><br>  Commençons par Hello World: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; #include&lt;stdio.h&gt; using namespace ontio; class hello:public contract { public: using contract::contract: void sayHello(){ printf("hello world!"); } }; ONTIO_DISPATCH(hello, (sayHello));</span></span></span></span></code> </pre> <br><h3>  Création de contrat </h3><br>  Le compilateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CDT d'Ontology Wasm</a> contient un point d'entrée et des paramètres d'analyse, de sorte que les développeurs n'ont pas besoin de redéfinir les méthodes d'entrée.  De plus, pour écrire la logique du service, vous pouvez appeler les méthodes API du contrat intelligent. <br><br><pre> <code class="cpp hljs">ONTIO_DISPATCH(hello, (sayHello));</code> </pre> <br>  Dans l'exemple ci-dessus, nous ne prenons en charge que sayHello jusqu'à présent: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"hello world!"</span></span>);</code> </pre> <br>  "Bonjour tout le monde!"  sera affiché dans le journal du nœud de débogage.  Lors de l'écriture directe d'un contrat intelligent, printf ne peut être utilisé que pour le débogage, car le contrat intelligent lui-même contient des commandes plus fonctionnelles. <br><br><h3>  API de contrat intelligent </h3><br>  Ontology Wasm fournit les API suivantes pour interagir avec la blockchain du serveur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d29/dad/66d/d29dad66d40c938e872179cc3487172e.png" alt="image"><br><br><h2>  Exemple 2: enveloppe d'argent </h2><br>  Voyons maintenant un exemple plus complexe utilisant l'API de contrat intelligent Wasm. <br><br>  Dans cet exemple, nous allons écrire une enveloppe d'argent virtuelle, un analogue de l'enveloppe rouge (hongbao) est une caractéristique populaire du messager chinois Wechat, qui vous permet d'envoyer de l'argent à des amis dans un chat.  L'utilisateur reçoit un message sous forme d'enveloppe rouge, l'ouvre et l'argent est automatiquement crédité sur le solde du compte. <br><br>  Dans le cadre d'un contrat intelligent, les utilisateurs peuvent utiliser ce contrat pour envoyer des jetons ONT, ONG ou OEP-4 à l'aide d'enveloppes d'argent virtuel à leurs amis, qui peuvent ensuite transférer des jetons vers leurs portefeuilles blockchain. <br><br><h3>  Se préparer à créer un contrat </h3><br>  Créez d'abord le fichier de contrat source et nommez-le redEnvelope.cpp.  Ensuite, nous avons besoin de trois API pour ce contrat: <br><br><ul><li>  <i>createRedEnvelope</i> : créer une enveloppe d'argent </li><li>  <i>queryEnvelope</i> : demande d'informations sur l'enveloppe </li><li>  <i>claimEnvelope</i> : ouvrez une enveloppe et recevez de l'argent </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; using namespace ontio; class redEnvlope: public contract{ } ONTIO_DISPATCH(redEnvlope, (createRedEnvlope)(queryEnvlope)(claimEnvelope));</span></span></span></span></code> </pre> <br>  Maintenant, nous devons enregistrer la valeur-clé.  Dans un contrat intelligent, les données sont stockées dans le contexte du contrat en tant que valeur-clé, et nous devons ajouter un préfixe aux données KEY pour une demande ultérieure. <br><br>  Ci-dessous, nous définissons trois préfixes que nous utiliserons: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> rePrefix = <span class="hljs-string"><span class="hljs-string">"RE_PREFIX_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sentPrefix = <span class="hljs-string"><span class="hljs-string">"SENT_COUNT_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> claimPrefix = <span class="hljs-string"><span class="hljs-string">"CLAIM_PREFIX_"</span></span>;</code> </pre><br>  Étant donné que le contrat prend en charge les jetons Ontology - ONT et ONG, nous pouvons déterminer à l'avance leur adresse de contrat.  Contrairement à un contrat intelligent standard, la propre adresse de contrat d'Ontology est fixe et n'est pas dérivée du hachage du contrat. <br><br><pre> <code class="cpp hljs">address ONTAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; address ONGAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>};</code> </pre> <br>  Ensuite, vous devez enregistrer des informations sur le jeton utilisé dans le contrat: l'adresse du jeton de contrat, le montant total de l'enveloppe et le nombre d'enveloppes. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class">{</span></span> address account; <span class="hljs-comment"><span class="hljs-comment">//User address asset amount; //Received amount ONTLIB_SERIALIZE(receiveRecord,(account)(amount)) }; struct envlopeStruct{ address tokenAddress; //Token asset address asset totalAmount; //Total amount asset totalPackageCount; //Total number of red envelope asset remainAmount; //Remaining amount asset remainPackageCount; //Remaining number of red envelope std::vector&lt;struct receiveRecord&gt; records; //Received records ONTLIB_SERIALIZE( envlopeStruct, (tokenAddress)(totalAmount)(totalPackageCount)(remainAmount)(remainPackageCount)(records) ) };</span></span></code> </pre> <br>  Voici l'opération de macro définie par le CDT Ontology Wasm, qui est utilisé pour la sérialisation avant la structuration des données. <br><br><pre> <code class="cpp hljs">ONTLIB_SERIALIZE(receiveRecord,(account)(amount))</code> </pre> <br><h3>  Création d'une enveloppe </h3><br>  Maintenant que nous avons terminé les préparatifs nécessaires, nous allons commencer à développer la logique API. <br><br>  1. Lors de la création d'une enveloppe monétaire, il est nécessaire d'indiquer l'adresse du propriétaire, le nombre et le montant des enveloppes, ainsi que l'adresse du token: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRedEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address owner,asset packcount, asset amount,address tokenAddr )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2. Vérifiez la signature du propriétaire, sinon nous annulerons (annuler la transaction) et quitterons: <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(owner),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>);</code> </pre> <br>  <i>Remarque</i> : ontio_assert (expr, errormsg): false expr renvoie une erreur et quitte le contrat. <br><br>  3. Si un jeton ONT est utilisé dans une enveloppe, il est important de se rappeler que ONT n'est pas fragmenté (au moins 1 ONT).  Ensuite, le montant total de l'enveloppe monétaire doit être supérieur ou égal au nombre de jetons afin de s'assurer qu'il y a au moins 1 ONT dans chaque enveloppe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ ontio_assert(amount &gt;= packcount,<span class="hljs-string"><span class="hljs-string">"ont amount should greater than packcount"</span></span>); }</code> </pre> <br>  4. Ensuite, nous déterminons pour le titulaire de l'enveloppe le nombre total d'enveloppes d'argent qu'il envoie: <br><br><pre> <code class="cpp hljs">key sentkey = make_key(sentPrefix,owner.tohexstring()); asset sentcount = <span class="hljs-number"><span class="hljs-number">0</span></span>; storage_get(sentkey,sentcount); sentcount += <span class="hljs-number"><span class="hljs-number">1</span></span>; storage_put(sentkey,sentcount);</code> </pre> <br>  5. Générez le hachage de l'enveloppe - l'identifiant qui marque cette enveloppe: <br><br><pre> <code class="cpp hljs">H256 hash ; hash256(make_key(owner,sentcount),hash) ; key rekey = make_key(rePrefix,hash256ToHexstring(hash));</code> </pre> <br>  6. Nous traduirons les jetons dans le contrat.  Nous découvrons l'adresse du contrat en cours d'exécution à l'aide de la commande self_address (), puis nous transférons la quantité de jetons attribuée au contrat en fonction du type de jetons: <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),owner,selfaddr,amount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res; call_contract(tokenAddr,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  <u>Note 1:</u> pour ONT et ONG, Ontology Wasm CDT fournit l'API ont :: transfer pour transférer des jetons;  Les jetons OEP-4 doivent être envoyés en utilisant la méthode conventionnelle d'appel croisé. <br><br>  <u>Remarque 2:</u> comme une adresse de portefeuille classique, l'adresse du contrat peut accepter tout type de jeton.  Cependant, l'adresse du contrat est générée par un hachage binaire compilé et n'a donc pas de clé privée correspondante et ne peut pas utiliser de jetons de contrat.  Si vous n'avez pas configuré de clé privée, vous ne pourrez pas gérer ces jetons. <br><br>  7. Enregistrez les informations sur le contrat dans l'entrepôt de données: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class"> ;</span></span> es.tokenAddress = tokenAddr; es.totalAmount = amount; es.totalPackageCount = packcount; es.remainAmount = amount; es.remainPackageCount = packcount; es.records = {}; storage_put(rekey, es);</code> </pre> <br>  8. Envoyez une notification concernant la création de l'enveloppe.  Il s'agit d'un processus asynchrone pour invoquer un contrat intelligent, le contrat enverra également une notification du résultat de l'exécution.  Le format d'exécution peut être déterminé par l'auteur du contrat. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\", \"%s\", \"%s\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"createEnvlope"</span></span>,owner.tohexstring().c_str(),hash256ToHexstring(hash).c_str()); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  Hourra, l'enveloppe d'argent est presque prête.  Voyons maintenant comment demander des informations sur l'enveloppe. <br><br><h3>  Enveloppe de requête (requête </h3><br>  La logique de la demande est assez simple, il vous suffit d'obtenir les informations et le format du magasin de données, puis de sortir: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> formatEnvlope(es); }</code> </pre> <br>  <u>Remarque:</u> pour les opérations de contrat intelligent en lecture seule (par exemple, la requête), vous pouvez vérifier le résultat via une pré-exécution.  Contrairement à un appel de contrat régulier, le pré-exécutable ne nécessite pas de signature de portefeuille et ne nécessite donc pas de commission en ONG.  Cela fait, les autres utilisateurs peuvent désormais demander l'enveloppe s'ils ont un hachage d'enveloppe (ID enveloppe). <br><br><h3>  Enveloppe de réception </h3><br>  À ce stade, nous avons déjà transféré avec succès des jetons vers un contrat intelligent, afin que vos amis puissent réclamer avec succès une part dans l'enveloppe, vous devez leur envoyer l'identifiant de l'enveloppe (hachage). <br><br>  1. Pour recevoir une enveloppe, vous devez saisir l'adresse de votre compte et le hachage de l'enveloppe: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">claimEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address account, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2. Ensuite, le contrat vérifiera la signature de votre compte pour vous assurer que vous en êtes le propriétaire.  Chaque compte ne peut demander une enveloppe qu'une seule fois: <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(account),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>); key claimkey = make_key(claimPrefix,hash,account); asset claimed = <span class="hljs-number"><span class="hljs-number">0</span></span> ; storage_get(claimkey,claimed); ontio_assert(claimed == <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"you have claimed this envlope!"</span></span>);</code> </pre><br>  3. Vérifiez si l'enveloppe est reçue conformément aux informations de hachage reçues du magasin: <br><br><pre> <code class="cpp hljs">key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); ontio_assert(es.remainAmount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>); ontio_assert(es.remainPackageCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>);</code> </pre> <br>  4. Création d'un dossier de réclamation: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class"> ;</span></span> record.account = account; asset claimAmount = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  5. Calcul du montant pour chaque demandeur d'enveloppe. <br>  Pour le dernier participant, le montant du solde est déterminé, pour tout autre, le montant déclaré est déterminé par un nombre aléatoire calculé par le hachage du bloc courant et les informations courantes sur l'enveloppe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (es.remainPackageCount == <span class="hljs-number"><span class="hljs-number">1</span></span>){ claimAmount = es.remainAmount; record.amount = claimAmount; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ H256 random = current_blockhash() ; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> part[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(part,&amp;random,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> random_num = *(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>*)part; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> percent = random_num % <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; claimAmount = es.remainAmount * percent / <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ont case if (claimAmount == 0){ claimAmount = 1; }else if(isONTToken(es.tokenAddress)){ if ( (es.remainAmount - claimAmount) &lt; (es.remainPackageCount - 1)){ claimAmount = es.remainAmount - es.remainPackageCount + 1; } } record.amount = claimAmount; } es.remainAmount -= claimAmount; es.remainPackageCount -= 1; es.records.push_back(record);</span></span></code> </pre> <br><h3>  6. Créditer des fonds </h3><br>  Le montant correspondant de jetons est transféré sur le compte des demandeurs d'enveloppe en fonction du résultat du calcul: <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ont token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ong token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),selfaddr,account,claimAmount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; call_contract(es.tokenAddress,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  7. Nous noterons les informations sur la réception des fonds et les informations mises à jour sur l'enveloppe dans le coffre-fort et enverrons une notification sur l'exécution du contrat: <br><br><pre> <code class="cpp hljs">storage_put(claimkey,claimAmount); storage_put(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\",\"%s\",\"%s\",\"%lld\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"claimEnvlope"</span></span>,hash.c_str(),account.tohexstring().c_str(),claimAmount); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Comme mentionné ci-dessus, ce contrat peut envoyer des jetons du contrat via l'API claimEnvelope.  Cela garantit la sécurité des jetons lorsqu'ils sont dans l'enveloppe, car personne ne peut retirer des actifs sans remplir les conditions requises. <br><br>  C'est fait!  Vous avez écrit votre premier contrat intelligent.  Le code de contrat complet peut être trouvé sur GitHub <a href="">ici</a> . <br><br><h3>  Test de contrat </h3><br>  Il existe deux façons de vérifier un contrat: <br><br><ol><li>  Utiliser <a href="">CLI</a> </li><li>  Utilisez <a href="">Golang SDK</a> </li></ol><br><h2>  Conclusion </h2><br>  Dans cet article, nous avons expliqué comment écrire un contrat intelligent pour Ontolgy Wasm à l'aide de l'API blockchain.  Il reste à résoudre le problème de confidentialité pour que le contrat intelligent se transforme en un produit à part entière.  À ce stade du code, n'importe qui peut obtenir un hachage de l'enveloppe rouge en suivant les enregistrements du contrat, ce qui signifie que n'importe qui peut réclamer une part de l'enveloppe.  Ce problème peut être résolu simplement - nous définissons une liste de comptes qui peuvent demander une enveloppe lors de sa création.  Si vous le souhaitez, cette fonction peut également être testée. <br><br><hr><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Obtenez une subvention en</a> ontologie pour le développement de dApp à partir de 20 000 $ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Postulez pour</a> le programme de talent étudiant en ontologie <br><br><hr><br>  Êtes-vous développeur?  Rejoignez notre communauté technologique sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Discord</a> .  De plus, jetez un œil au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Developer Center</a> sur notre site Web, où vous pouvez trouver des outils de développement, de la documentation et bien plus encore. <br><br><h4>  Ontologie </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Site Web d'ontologie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discorde</a> </li><li>  Télégramme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">anglais</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">russe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reddit</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473784/">https://habr.com/ru/post/fr473784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473770/index.html">Analyse statique de gros volumes de code Python: expérience Instagram. 2e partie</a></li>
<li><a href="../fr473774/index.html">Cloud sécurisé sur DF Cloud</a></li>
<li><a href="../fr473776/index.html">Unification des règles de validation par l'exemple d'Asp core + VueJS</a></li>
<li><a href="../fr473778/index.html">Optimisation d'image: comment utiliser Vision AI de Google pour comprendre les principes de classement des images</a></li>
<li><a href="../fr473780/index.html">Détection rapide des contours en vidéo 4K: couleurs et formes complexes</a></li>
<li><a href="../fr473786/index.html">L'inscription au hackathon de Riga se termine. Prix ​​- formation de courte durée au PhysTech</a></li>
<li><a href="../fr473788/index.html">Les microprotéines découvrent des aspects inconnus de la biologie moderne</a></li>
<li><a href="../fr473790/index.html">Splines dans les graphismes 3D, l'option la plus automatisée</a></li>
<li><a href="../fr473794/index.html">Phishing mobile - menaces infinies</a></li>
<li><a href="../fr473796/index.html">Extender HDMI optique. 300 mètres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>