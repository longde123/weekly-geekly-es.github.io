<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèΩ ü§† üêü Raspberry Pi + CentOS = Ponto de acesso Wi-Fi (ou Raspberry Router em um Red Hat) üí£ üà∑Ô∏è üôéüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° muitas informa√ß√µes na Internet sobre a cria√ß√£o de pontos de acesso Wi-Fi baseados em um PC Raspberry de placa √∫nica. Como regra, isso implica o uso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raspberry Pi + CentOS = Ponto de acesso Wi-Fi (ou Raspberry Router em um Red Hat)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458994/"> H√° muitas informa√ß√µes na Internet sobre a cria√ß√£o de pontos de acesso Wi-Fi baseados em um PC Raspberry de placa √∫nica.  Como regra, isso implica o uso do sistema operacional nativo do Raspberry - Raspbian. <br><br>  Sendo um adepto de sistemas baseados em RPM, n√£o pude superar esse pequeno milagre e nem experimentar o meu CentOS favorito. <br><br>  O artigo fornece instru√ß√µes para criar um roteador Wi-Fi de 5 GHz / CA a partir do Raspberry Pi 3 Modelo B +, com base no sistema operacional CentOS.  Haver√° v√°rios truques padr√£o, mas pouco conhecidos, e como b√¥nus - um desenho de conex√£o com o equipamento Wi-Fi adicional "framboesa", permitindo que ele trabalhe simultaneamente em v√°rios modos (2,4 + 5 GHz). <br><br><img src="https://habrastorage.org/webt/mp/yb/fz/mpybfz6gzojqkaftnuljhpzx5da.png" alt="imagem"><br>  <sub><i>(mistura de imagens de acesso gratuito)</i></sub> <br><a name="habracut"></a><br>  Notamos imediatamente que algumas velocidades c√≥smicas n√£o funcionar√£o.  Aperto no m√°ximo 100 Mbit da minha ‚Äúframboesa‚Äù no ar, e isso cobre a velocidade do meu provedor de Internet.  Por que precisamos de um AC t√£o lento, mesmo que em N, em teoria, voc√™ consiga meio gigabyte?  Se voc√™ fez essa pergunta, v√° √† loja para um roteador real com oito antenas externas. <br><br><h1>  0. O que √© necess√°rio </h1><br><ul><li>  Na verdade, o "produto de framboesa" do pr√≥prio calibre: Pi 3 Modelo B + (para atingir as cobi√ßadas velocidades e canais de 5 GHz); <br></li><li>  MicroSD s√≥lido&gt; = 4 GB; <br></li><li>  Esta√ß√£o de trabalho Linux com leitor / gravador microSD; <br></li><li>  A presen√ßa de habilidades suficientes no Linux, o artigo √© para o Geek preparado; <br></li><li>  Conectividade de rede com fio (eth0) entre Raspberry e Linux, um servidor DHCP em funcionamento na rede local e acesso √† Internet de ambos os dispositivos. <br></li></ul><br>  Um breve coment√°rio sobre o √∫ltimo ponto.  ‚ÄúO que veio primeiro, um ovo ou ...‚Äù como fazer um roteador Wi-Fi na aus√™ncia de qualquer equipamento de acesso √† Internet?  Vamos deixar esse exerc√≠cio divertido fora do escopo do artigo e simplesmente assumir que o Raspberry est√° conectado √† rede local por fio e tem acesso √† Internet.  Nesse caso, n√£o precisamos de uma TV e um manipulador adicionais para configurar a framboesa. <br><br><h1>  1. Instale o CentOS </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P√°gina inicial do projeto</a> <br><br>  No momento da reda√ß√£o deste artigo, a vers√£o funcional do CentOS no dispositivo era de 32 bits.  Em algum lugar da vastid√£o da World Wide Web, me deparei com opini√µes sobre a degrada√ß√£o do desempenho desses SOs na arquitetura ARM de 64 bits em at√© 20%.  Vou deixar este ponto sem comentar. <br><br>  No Linux, baixe a imagem m√≠nima com o kernel " <b>-RaspberryPI-</b> " e <b>grave</b> -a no microSD: <br><br><pre><code class="plaintext hljs"># xzcat CentOS-Userland-7-armv7hl-RaspberryPI-Minimal-1810-sda.raw.xz | \ dd of=/dev/mmcblk0 bs=4M # sync</code> </pre> <br>  Antes de usar a imagem, exclua a se√ß√£o SWAP, expanda a raiz para todo o volume dispon√≠vel e livre-se do SELinux.  O algoritmo √© simples: fazemos uma c√≥pia da raiz no Linux, exclu√≠mos todas as parti√ß√µes do microSD, exceto a primeira (/ boot), criamos uma nova raiz e retornamos seu conte√∫do da c√≥pia. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de a√ß√µes necess√°rias (sa√≠da severa do console)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># mount /dev/mmcblk0p3 /mnt # cd /mnt # tar cfz ~/pi.tgz . --no-selinux # cd # umount /mnt</code> </pre><br><pre> <code class="plaintext hljs"># parted /dev/mmcblk0 (parted) unit s (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 2369535s 999424s primary linux-swap(v1) 3 2369536s 5298175s 2928640s primary ext4 5298176s 31116287s 25818112s Free Space (parted) rm 3 (parted) rm 2 (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 1370112s 31116287s 29746176s Free Space (parted) mkpart Partition type? primary/extended? primary File system type? [ext2]? ext4 Start? 1370112s End? 31116287s (parted) set Partition number? 2 Flag to Invert? lba New state? on/[off]? off (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 31116287s 29746176s primary ext4 (parted) quit</code> </pre><br><pre> <code class="plaintext hljs"># mkfs.ext4 /dev/mmcblk0p2 mke2fs 1.44.6 (5-Mar-2019) /dev/mmcblk0p2 contains a swap file system labelled '_swap' Proceed anyway? (y,N) y Discarding device blocks: done Creating filesystem with 3718272 4k blocks and 930240 inodes Filesystem UUID: 6a1a0694-8196-4724-a58d-edde1f189b31 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208 Allocating group tables: done Writing inode tables: done Creating journal (16384 blocks): done Writing superblocks and filesystem accounting information: done # mount /dev/mmcblk0p2 /mnt # tar xfz ~/pi.tgz -C /mnt --no-selinux</code> </pre><br>  Ap√≥s descompactar o conte√∫do da parti√ß√£o raiz, √© hora de fazer algumas altera√ß√µes. <br><br>  Desative o SELinux em <b>/ mnt / etc / selinux / config</b> : <br><br><pre> <code class="plaintext hljs">SELINUX=disabled</code> </pre><br>  <b>Editamos / mnt / etc / fstab</b> , deixando apenas duas entradas de parti√ß√£o: boot (/ boot, inalterada) e root (altere o valor UUID, que pode ser encontrado examinando a sa√≠da do comando blkid no Linux): <br><br><pre> <code class="plaintext hljs">UUID=6a1a0694-8196-4724-a58d-edde1f189b31 / ext4 defaults,noatime 0 0 UUID=6938-F4F2 /boot vfat defaults,noatime 0 0</code> </pre><br>  Por fim, alteramos os par√¢metros de inicializa√ß√£o do kernel: especifique o novo local da parti√ß√£o raiz, desabilite a sa√≠da das informa√ß√µes de depura√ß√£o e (opcionalmente) pro√≠ba o kernel de atribuir endere√ßos IPv6 nas interfaces de rede: <br><br><pre> <code class="plaintext hljs"># cd # umount /mnt # mount /dev/mmcblk0p1 /mnt</code> </pre><br>  <b>Trazemos o</b> conte√∫do de <b>/mnt/cmdline.txt</b> para o seguinte formato (uma linha sem hifeniza√ß√£o): <br><br><pre> <code class="plaintext hljs">root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait quiet ipv6.disable_ipv6=1</code> </pre><br>  Feito: <br><br><pre> <code class="plaintext hljs"># cd # umount /mnt # sync</code> </pre><br></div></div><br>  Reorganizamos o microSD no "Malinka", executamos e obtemos acesso √† rede via ssh (root / centos). <br><br><h1>  2. Configurando o CentOS </h1><br>  Os tr√™s primeiros movimentos inabal√°veis: <b>passwd</b> , <b>yum -y update</b> , <b>reboot</b> . <br><br>  Damos gerenciamento de rede ao <b>networkd</b> : <br><br><pre> <code class="plaintext hljs"># yum install systemd-networkd # systemctl enable systemd-networkd # systemctl disable NetworkManager # chkconfig network off</code> </pre><br>  Crie o arquivo (junto com os diret√≥rios) <b>/etc/systemd/network/eth0.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=eth0 [Network] DHCP=ipv4</code> </pre><br>  Reiniciamos o "raspberry" e novamente obtemos acesso √† rede via ssh (o endere√ßo IP pode mudar).  Observe que o <b>/etc/resolv.conf</b> , criado anteriormente pelo Network Manager, √© usado.  Portanto, em caso de problemas com a resolu√ß√£o, edite seu conte√∫do.  N√£o usaremos <b>systemd-resolved</b> . <br><br>  Removemos o "sup√©rfluo", reparamos e agilizamos o carregamento do sistema operacional: <br><br><pre> <code class="plaintext hljs"># systemctl set-default multi-user.target # yum remove GeoIP Network* aic* alsa* cloud-utils-growpart \ cronie* dhc* firewal* initscripts iwl* kexec* logrotate \ postfix rsyslog selinux-pol* teamd wpa_supplicant</code> </pre><br>  Quem precisa do <b>cron</b> e quem n√£o digere os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">timers do systemd</a> integrados, pode instalar o que est√° faltando.  <b>/ var / log -</b> e veja o <b>journalctl</b> .  Se voc√™ precisar de um hist√≥rico de log (por padr√£o, as informa√ß√µes s√£o armazenadas apenas a partir do momento em que o sistema √© iniciado): <br><br><pre> <code class="plaintext hljs"># mkdir /var/log/journal # systemd-tmpfiles --create --prefix /var/log/journal # systemctl restart systemd-journald # vi /etc/systemd/journald.conf</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Desativar o uso do IPv6 pelos servi√ßos principais (se necess√°rio)</b> <div class="spoiler_text">  <b>/ etc / ssh / sshd_config</b> : <br><br><pre> <code class="plaintext hljs">AddressFamily inet</code> </pre><br>  <b>/ etc / sysconfig / chronyd</b> : <br><pre> <code class="plaintext hljs">OPTIONS="-4"</code> </pre><br></div></div><br>  A relev√¢ncia do tempo na "framboesa" √© uma coisa importante.  Como "pronto para uso", n√£o h√° capacidade de hardware para salvar o estado atual do rel√≥gio ao reiniciar, voc√™ precisa de sincroniza√ß√£o.  Um daemon muito bom e r√°pido para isso - <b>chrony</b> - j√° est√° instalado e √© iniciado automaticamente.  Voc√™ pode alterar os servidores NTP para o pr√≥ximo. <br><br>  <b>/etc/chrony.conf</b> : <br><br><pre> <code class="plaintext hljs">server 0.ru.pool.ntp.org iburst server 1.ru.pool.ntp.org iburst server 2.ru.pool.ntp.org iburst server 3.ru.pool.ntp.org iburst</code> </pre><br>  Usaremos o <b>truque</b> para definir o fuso hor√°rio.  Como nosso objetivo √© criar um roteador Wi-Fi operando em frequ√™ncias de 5 GHz, prepararemos antecipadamente as surpresas <b>do regulador</b> : <br><blockquote>  # yum info crda <br>  Resumo: Daemon de conformidade regulamentar para redes sem fio 802.11 <br></blockquote><br>  Esse design rancoroso, concentrando-se, entre outras coisas, no fuso hor√°rio, "pro√≠be" o uso (na R√∫ssia) de frequ√™ncias e canais de 5 GHz com n√∫meros "grandes".  O truque √© definir o fuso hor√°rio sem usar os nomes do continente / cidade, ou seja, em vez de: <br><br><pre> <code class="plaintext hljs"># timedatectl set-timezone Europe/Moscow</code> </pre><br>  Pressione: <br><br><pre> <code class="plaintext hljs"># timedatectl set-timezone Etc/GMT-3</code> </pre><br>  E os retoques finais no penteado do sistema: <br><br><pre> <code class="plaintext hljs"># hostnamectl set-hostname router</code> </pre><br>  <b>/root/.bash_profile</b> : <br><br><pre> <code class="plaintext hljs">. . . # User specific environment and startup programs export PROMPT_COMMAND="echo -n $(($(&lt;/sys/class/thermal/thermal_zone0/temp) / 1000))\'C\ " export LANG=en_US.UTF-8 export PATH=$PATH:$HOME/bin</code> </pre><br><h1>  3. Complementos para o CentOS </h1><br>  Tudo o que foi dito acima pode ser considerado instru√ß√µes completas para a instala√ß√£o do CentOS "vanilla" no Raspberry Pi.  Voc√™ deve ter um PC que (re) inicialize em menos de 10 segundos, use menos de 15 megabytes de RAM e 1,5 gigabytes de microSD (na verdade, menos de 1 gigabyte devido √† inicializa√ß√£o / incompleto, mas seremos honestos at√© o final): <br><img src="https://habrastorage.org/webt/mu/0g/cf/mu0gcfyiokq0x_2dysrb1ieh0ke.jpeg"><br><br><img src="https://habrastorage.org/webt/xx/l3/_g/xxl3_gukovfw0zawwvvy8ua0dtw.jpeg"><br><br><img src="https://habrastorage.org/webt/wt/yc/-9/wtyc-9erdcdx-rvqnnjite7c9ru.jpeg"><br><br>  Para instalar o software do ponto de acesso Wi-Fi neste sistema, voc√™ precisar√° expandir um pouco os recursos da distribui√ß√£o padr√£o do CentOS.  Primeiro, ‚Äúbombeie‚Äù o driver (firmware) do adaptador Wi-Fi embutido.  A p√°gina inicial do projeto diz: <br><blockquote>  Wifi no Raspberry 3B e 3B + <br><br>  Os arquivos de firmware do Raspberry PI 3B / 3B + n√£o podem ser distribu√≠dos pelo Projeto CentOS.  Voc√™ pode usar os seguintes artigos para entender o problema, obter o firmware e configurar o wifi. <br></blockquote><br>  O que o projeto CentOS n√£o pode fazer n√£o nos √© proibido para uso pessoal.  Substitu√≠mos o firmware Wi-Fi de distribui√ß√£o no CentOS pelo correspondente dos desenvolvedores da Broadcom (os mesmos odiavam blobs bin√°rios ...).  Isso, em particular, permitir√° o uso de CA no modo de ponto de acesso. <br><br><div class="spoiler">  <b class="spoiler_title">Atualiza√ß√£o de firmware Wi-Fi</b> <div class="spoiler_text">  Descobrimos o modelo do dispositivo e a vers√£o atual do firmware: <br><br><pre> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Mar 1 2015 07:29:38 version 7.45.18 (r538002) FWID 01-6a2c8ad4 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 7.14.8 Compiler: 1.24.9 ClmImport: 1.24.9 Creation: 2014-09-02 03:05:33 Inc Data: 7.17.1 Inc Compiler: 1.26.11 Inc ClmImport: 1.26.11 Creation: 2015-03-01 07:22:34</code> </pre><br>  Vemos que a vers√£o do firmware √© 7.45.18 de 01/03/2015 e lembramos o seguinte conjunto de n√∫meros: <b>43455</b> (brcmfmac43455-sdio.bin). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fa√ßa o download da imagem atual do Raspbian</a> .  Pessoas pregui√ßosas podem gravar a imagem no microSD e de l√° pegar os arquivos com o firmware.  E voc√™ pode montar a parti√ß√£o raiz da imagem no Linux e copiar a que voc√™ precisa a partir da√≠: <br><br><pre> <code class="plaintext hljs"># wget https://downloads.raspberrypi.org/raspbian_lite_latest # unzip -p raspbian_lite_latest &gt; raspbian.img # fdisk -l raspbian.img Disk raspbian.img: 2 GiB, 2197815296 bytes, 4292608 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x17869b7d Device Boot Start End Sectors Size Id Type raspbian.img1 8192 532480 524289 256M c W95 FAT32 (LBA) raspbian.img2 540672 4292607 3751936 1.8G 83 Linux # mount -t ext4 -o loop,offset=$((540672 * 512)) raspbian.img /mnt # cp -fv /mnt/lib/firmware/brcm/*43455* ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.bin' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.clm_blob' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.txt' -&gt; ... # umount /mnt</code> </pre><br>  Os arquivos de firmware resultantes para o adaptador Wi-Fi devem ser copiados com a substitui√ß√£o do "raspberry" no diret√≥rio <b>/ usr / lib / firmware / brcm /</b> <br><br>  Reiniciamos o futuro roteador e sorrimos: <br><br><pre> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Feb 27 2018 03:15:32 version 7.45.154 (r684107 CY) FWID 01-4fbe0b04 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 9.10.105 Compiler: 1.29.4 ClmImport: 1.36.3 Creation: 2018-03-09 18:56:28</code> </pre><br>  Vers√£o: 7.45.154 de 27/02/2017. <br></div></div><br>  E, claro, EPEL: <br><br><pre> <code class="plaintext hljs"># cat &gt; /etc/yum.repos.d/epel.repo &lt;&lt; EOF [epel] name=Epel rebuild for armhfp baseurl=https://armv7.dev.centos.org/repodir/epel-pass-1/ enabled=1 gpgcheck=0 EOF # yum clean all # rm -rfv /var/cache/yum # yum update</code> </pre><br><h1>  4. Configura√ß√£o de rede e pr√≥ximos desafios </h1><br>  Como concordamos acima, o "Malinka" √© conectado por um "fio" √† rede local.  Suponha que um provedor forne√ßa acesso √† Internet exatamente da mesma maneira: um endere√ßo em uma rede p√∫blica √© emitido dinamicamente por um servidor DHCP (pode ser vinculado a um MAC).  Nesse caso, ap√≥s a configura√ß√£o final do "raspberry", basta "conectar" o cabo do provedor nele e tudo est√° pronto.  A autoriza√ß√£o usando <b>systemd-networkd</b> √© o t√≥pico de um artigo separado e n√£o √© considerada aqui. <br><br>  A (s) interface (s) Wi-Fi do Raspberry √© uma rede local e o adaptador Ethernet (eth0) interno √© externo.  N√≥s numeramos a rede local estaticamente, por exemplo: 192.168.0.0/24.  Endere√ßo de Malinka: 192.168.0.1.  Em uma rede externa (Internet), um servidor DHCP funcionar√°. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O problema da uniformidade de nomea√ß√£o</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">famoso programador guatemalteco</a> s√£o dois problemas √† espera de todos os envolvidos na configura√ß√£o de interfaces e servi√ßos de rede nas distribui√ß√µes systemd. <br><br><div class="spoiler">  <b class="spoiler_title">Caos Paralelo (digress√£o l√≠rica)</b> <div class="spoiler_text">  Lennart Pottering fez seu programa <b>systemd</b> muito bem.  Esse <b>sistema</b> lan√ßa outros programas t√£o rapidamente que eles, n√£o tendo tido tempo de recuperar o ju√≠zo do apito do √°rbitro, trope√ßam e caem no in√≠cio, sem sequer iniciar o curso de obst√°culos. <br><br>  Mas, falando s√©rio, a paraleliza√ß√£o agressiva dos processos lan√ßados no in√≠cio do systemd-OS √© uma esp√©cie de "ponte de burro" para drivers LSB seriais experientes.  Felizmente, arrumar esse "caos paralelo" acaba sendo simples, embora a verdade nem sempre seja √≥bvia. <br></div></div><br>  Criamos duas interfaces de ponte virtual com nomes constantes: <b>lan</b> e <b>wan</b> .  "Conectaremos" o (s) adaptador (es) Wi-Fi ao primeiro e eth0 do "raspberry" ao segundo. <br><br>  <b>/etc/systemd/network/lan.netdev</b> : <br><br><pre> <code class="plaintext hljs">[NetDev] Name=lan Kind=bridge</code> </pre><br>  <b>/etc/systemd/network/lan.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=lan [Network] Address=192.168.0.1/24 IPForward=yes</code> </pre><br>  <b>/etc/systemd/network/wan.netdev</b> : <br><br><pre> <code class="plaintext hljs">[NetDev] Name=wan Kind=bridge #MACAddress=xx:xx:xx:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wan.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=wan [Network] DHCP=ipv4 IPForward=yes</code> </pre><br>  <b>IPForward = yes</b> elimina a necessidade de dar dicas ao kernel atrav√©s do sysctl para habilitar o roteamento. <br>  <b>MACAddress =</b> descomente e altere, se necess√°rio. <br><br>  Primeiro, conectamos eth0.  Lembre-se do ‚Äúproblema de uniformidade‚Äù e use apenas o endere√ßo MAC desta interface, que voc√™ pode descobrir, por exemplo, assim: <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/eth0/address</code> </pre><br>  Crie <b>/etc/systemd/network/eth.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Network] Bridge=wan</code> </pre><br>  Exclua o arquivo de configura√ß√£o eth0 anterior, reinicie o "raspberry" e obtenha acesso √† rede (o endere√ßo IP provavelmente mudar√°): <br><br><pre> <code class="plaintext hljs"># rm -fv /etc/systemd/network/eth0.network # reboot</code> </pre><br><h1>  5. DNSMASQ </h1><br>  Para a fabrica√ß√£o de pontos de acesso Wi-Fi, nada melhor do que um doce casal do <b>dnsmasq</b> + <b>hostapd</b> ainda n√£o foi inventado.  Na minha opini√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Se algu√©m esqueceu, ent√£o ...</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O hostapd</a> √© uma coisa que gerencia adaptadores Wi-Fi (em particular, ser√° necess√°rio conect√°-los √† <b>LAN</b> virtual do raspberry), autoriza e registra clientes sem fio. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dnsmasq</a> - configura a pilha de clientes da rede: fornece endere√ßos IP, servidores DNS, um gateway padr√£o e similares. <br></div></div><br>  Come√ßamos com dnsmasq: <br><br><pre> <code class="plaintext hljs"># yum install dnsmasq</code> </pre><br>  Template <b>/etc/resolv.conf</b> : <br><br><pre> <code class="plaintext hljs">nameserver 1.1.1.1 nameserver 1.0.0.1 nameserver 8.8.8.8 nameserver 8.8.4.4 nameserver 77.88.8.8 nameserver 77.88.8.1 domain router.local search router.local</code> </pre><br>  edite-o ao seu gosto. <br><br>  Minimalista <b>/etc/dnsmasq.conf</b> : <br><br><pre> <code class="plaintext hljs">domain-needed bogus-priv interface=lan bind-dynamic expand-hosts domain=# dhcp-range=192.168.0.100,192.168.0.199,255.255.255.0,24h conf-dir=/etc/dnsmasq.d</code> </pre><br>  A ‚Äúm√°gica‚Äù aqui √© o par√¢metro <b>bind-dynamic</b> , que instrui o daemon dnsmasq a aguardar a <b>interface = lan</b> aparecer no sistema e a n√£o desmaiar de um ataque de orgulhosa solid√£o ap√≥s o in√≠cio. <br><br><pre> <code class="plaintext hljs"># systemctl enable dnsmasq # systemctl start dnsmasq; journalctl -f</code> </pre><br><h1>  6. HOSTAPD </h1><br>  Finalmente, as configura√ß√µes m√°gicas do hostapd.  N√£o tenho d√∫vidas de que algu√©m est√° lendo este artigo em busca dessas linhas preciosas. <br><br>  Antes de instalar o hostapd, voc√™ precisa lidar com o "problema de uniformidade".  O adaptador Wi-Fi wlan0 embutido pode facilmente mudar seu nome para wlan1 ao conectar equipamentos Wi-Fi USB adicionais.  Portanto, corrigiremos os nomes das interfaces da seguinte maneira: criaremos nomes exclusivos de adaptadores (sem fio) e os vincularemos aos endere√ßos MAC. <br><br>  Para o adaptador Wi-Fi embutido, que ainda √© wlan0: <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b8:27:eb:xx:xx:xx</code> </pre><br>  Crie <b>/etc/systemd/network/wl0.link</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Link] Name=wl0</code> </pre><br>  Agora teremos certeza de que <b>wl0</b> √© o Wi-Fi embutido.  N√≥s reiniciamos o "raspberry" para ver isso. <br><br>  Instalar: <br><br><pre> <code class="plaintext hljs"># yum install hostapd wireless-tools</code> </pre><br>  Arquivo de configura√ß√£o <b>/etc/hostapd/hostapd.conf</b> : <br><br><pre> <code class="plaintext hljs">ssid=rpi wpa_passphrase=1234567890 channel=36 country_code=US interface=wl0 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=a wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[MAX-AMSDU-3839][HT40+][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40] # AC ieee80211ac=1 require_vht=1 ieee80211d=0 ieee80211h=0 vht_capab=[MAX-AMSDU-3839][SHORT-GI-80] vht_oper_chwidth=1 vht_oper_centr_freq_seg0_idx=42</code> </pre><br>  Sem esquecer o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GKChP</a> por um minuto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alteramos</a> os par√¢metros necess√°rios e verificamos manualmente o desempenho: <br><br><pre> <code class="plaintext hljs"># hostapd /etc/hostapd/hostapd.conf</code> </pre><br>  O hostapd come√ßar√° interativamente, convertendo seu estado no console.  Se n√£o houver erros, os clientes que suportam o modo CA j√° podem estar conectados ao ponto de acesso.  Para parar o hostapd - Ctrl-C. <br><br>  Resta incluir o hostapd na inicializa√ß√£o do sistema.  Se voc√™ agir de maneira padr√£o (systemctl enable hostapd), ap√≥s a pr√≥xima reinicializa√ß√£o, poder√° obter um "daemon no sangue" de um dem√¥nio com um diagn√≥stico de " <b>interface wl0 n√£o encontrada</b> ".  Como resultado do "caos paralelo", o hostapd terminou mais r√°pido do que o kernel encontrou um adaptador sem fio. <br><br>  A Internet est√° cheia de drogas: desde o tempo limite for√ßado antes do daemon iniciar (por alguns minutos) at√© outro daemon que monitora a apar√™ncia da interface e (re) inicia o hostpad.  As solu√ß√µes s√£o bastante funcionais, mas terrivelmente feias.  Pedimos ajuda ao grande <b>sistema</b> com seus "objetivos" e " <s>tarefas</s> " "depend√™ncias". <br><br>  Copie o arquivo do servi√ßo de distribui√ß√£o para <b>/etc/systemd/system/hostapd.service</b> : <br><br><pre> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system</code> </pre><br>  e traga seu conte√∫do para o seguinte formato: <br><br><pre> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl0.device BindsTo=sys-subsystem-net-devices-wl0.device [Service] Type=forking PIDFile=/run/hostapd.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd.conf -P /run/hostapd.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl0.device</code> </pre><br>  A m√°gica do arquivo de servi√ßo atualizado √© vincular dinamicamente o hostapd a um novo destino - a interface wl0.  Quando a interface aparece, o daemon √© iniciado e, quando desaparece, para.  E est√° tudo online - sem reiniciar o sistema.  Especialmente, essa t√©cnica ser√° √∫til ao conectar ao adaptador Wi-Fi USB "raspberry". <br><br>  Agora voc√™ pode: <br><br><pre> <code class="plaintext hljs"># systemctl enable hostapd # reboot</code> </pre><br><h1>  7. IPTABLES </h1><br>  "Shta ???"  ¬© sim, sim!  Nenhum <b>sistema</b>  Nenhuma combina√ß√£o newfangled (na forma de <b>firewalld</b> ), que finalmente faz a mesma coisa. <br><br>  Usamos as boas e antigas <b>iptables</b> , cujos servi√ßos, ap√≥s o in√≠cio, far√£o o upload de regras de rede para o kernel e ser√£o silenciosamente encerrados sem permanecer residente e sem consumir recursos.  O Systemd possui um <b>IPMasquerade =</b> elegante, mas ainda confiaremos ao iptables a tradu√ß√£o de endere√ßo (NAT) e o firewall. <br><br>  Instalar: <br><br><pre> <code class="plaintext hljs"># yum install iptables-services # systemctl enable iptables ip6tables</code> </pre><br>  Eu prefiro armazenar a configura√ß√£o do iptables como um script (exemplo): <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # Disable IPv6 # ip6tables --flush ip6tables --delete-chain ip6tables --policy INPUT DROP ip6tables --policy FORWARD DROP ip6tables --policy OUTPUT DROP ip6tables-save &gt; /etc/sysconfig/ip6tables systemctl restart ip6tables # # Cleaning # iptables -F iptables -X iptables -t nat -F iptables -t nat -X iptables -t mangle -F iptables -t mangle -X iptables -P INPUT DROP iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT # # Loopback, lan # iptables -A INPUT -i lo -j ACCEPT iptables -A INPUT -i lan -j ACCEPT # # Ping, Established # iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # # NAT # iptables -t nat -A POSTROUTING -o wan -j MASQUERADE # # Saving # iptables-save &gt; /etc/sysconfig/iptables systemctl restart iptables</span></span></code> </pre><br>  Executamos o script acima e perdemos a capacidade de estabelecer novas conex√µes ssh com fio com o "Malinka".  √â isso mesmo, criamos um roteador Wi-Fi, cujo acesso "via Internet" √© proibido por padr√£o - agora apenas "pelo ar".  Conectamos o cabo do provedor √† Ethernet e come√ßamos a navegar! <br><br><h1>  8. B√¥nus: + 2.4GHz </h1><br>  Quando montei o primeiro roteador Raspberry a partir do desenho descrito acima, descobri na minha fazenda v√°rios dispositivos que, devido √†s limita√ß√µes de design, o Wi-Fi n√£o conseguia ver a "framboesa".  A reconfigura√ß√£o do roteador para funcionar em 802.11b / g / n foi antidesportiva, pois a velocidade m√°xima "over the air" nesse caso n√£o excedeu 40 Mbps e meu provedor de Internet favorito me oferece 100 (via cabo). <br><br>  De fato, uma solu√ß√£o para o problema j√° foi inventada: uma segunda interface Wi-Fi operando a 2,4 GHz e um segundo ponto de acesso.  Na barraca mais pr√≥xima, comprei n√£o o primeiro, mas o segundo ‚Äúapito‚Äù de Wi-Fi USB que me ocorreu.  O vendedor foi atormentado por perguntas sobre o chipset, compatibilidade com os n√∫cleos ARM do Linux e a possibilidade de trabalhar no modo AP (ele come√ßou pela primeira vez). <br><br>  Configuramos o "apito" por analogia com o adaptador Wi-Fi embutido. <br><br>  Primeiro, renomeie-o para <b>wl1</b> : <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b0:6e:bf:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wl1.link</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b0:6e:bf:xx:xx:xx [Link] Name=wl1</code> </pre><br>  Confiaremos o gerenciamento da nova interface Wi-Fi a um daemon hostapd separado, que ser√° iniciado e interrompido dependendo da presen√ßa de um "apito" estritamente definido no sistema: wl1. <br><br>  Arquivo de configura√ß√£o <b>/etc/hostapd/hostapd2.conf</b> : <br><br><pre> <code class="plaintext hljs">ssid=rpi2 wpa_passphrase=1234567890 #channel=1 #channel=6 channel=11 interface=wl1 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=g wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[HT40][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40]</code> </pre><br>  O conte√∫do deste arquivo depende diretamente do modelo do adaptador USB Wi-Fi, portanto, uma c√≥pia / pasta trivial pode decepcion√°-lo. <br><br>  Copie o arquivo do servi√ßo de distribui√ß√£o para <b>/etc/systemd/system/hostapd2.service</b> : <br><br><pre> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system/hostapd2.service</code> </pre><br>  e traga seu conte√∫do para o seguinte formato: <br><br><pre> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl1.device BindsTo=sys-subsystem-net-devices-wl1.device [Service] Type=forking PIDFile=/run/hostapd2.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd2.conf -P /run/hostapd2.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl1.device</code> </pre><br>  Resta incluir uma nova inst√¢ncia do hostapd: <br><br><pre> <code class="plaintext hljs"># systemctl enable hostapd2</code> </pre><br>  Isso √© tudo!  Puxe o apito e a pr√≥pria framboesa, observe as redes sem fio ao redor. <br><br>  E, finalmente, quero alertar sobre a qualidade do adaptador USB Wi-Fi e da fonte de alimenta√ß√£o Raspberry.  Conectado "a um apito quente", √†s vezes pode causar um "travamento de framboesa" devido a problemas el√©tricos de curto prazo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458994/">https://habr.com/ru/post/pt458994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458984/index.html">Como criar o primeiro aplicativo para negocia√ß√£o na bolsa: 3 etapas iniciais</a></li>
<li><a href="../pt458986/index.html">Receitas do PostgreSQL: Convertendo de HTML e URLs para PDF e PS</a></li>
<li><a href="../pt458988/index.html">Texturiza√ß√£o ou o que voc√™ precisa saber para se tornar um Artista de Superf√≠cie. Parte 4. Modelos, normais e varredura</a></li>
<li><a href="../pt458990/index.html">Pare de zeloso com coment√°rios no c√≥digo</a></li>
<li><a href="../pt458992/index.html">Aten√ß√£o para manequins e implementa√ß√£o em Keras</a></li>
<li><a href="../pt458996/index.html">Usu√°rio Inyerface - como n√£o atormentar o usu√°rio</a></li>
<li><a href="../pt459000/index.html">Como eu tentei melhorar o Halo 2, mas quase arruinei</a></li>
<li><a href="../pt459002/index.html">Como configurar o HTTPS - SSL Configuration Generator ajudar√°</a></li>
<li><a href="../pt459004/index.html">Algoritmo criptogr√°fico Grasshopper: praticamente o complexo</a></li>
<li><a href="../pt459012/index.html">Criando um aplicativo para Bitrix24 do zero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>