<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏾 📪 👟 Le nouvel opérateur de vaisseau spatial en C ++ 20 ⚔️ 🏴‍☠️ 🍞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 ajoute un nouvel opérateur appelé «vaisseau spatial»: <=> . Il n'y a pas si longtemps, Simon Brand a publié un article contenant des informati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le nouvel opérateur de vaisseau spatial en C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458242/"> C ++ 20 ajoute un nouvel opérateur appelé «vaisseau spatial»: <code>&lt;=&gt;</code> .  Il n'y a pas si longtemps, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Simon Brand a</a> publié un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> contenant des informations conceptuelles détaillées sur ce qu'est cet opérateur et à quelles fins il est utilisé.  La tâche principale de cet article est d'étudier les applications spécifiques du nouvel opérateur "étrange" et de son <code>operator==</code> analogique <code>operator==</code> , ainsi que de formuler des recommandations pour son utilisation dans le codage quotidien. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"></div><a name="habracut"></a><br><h2>  Comparaison </h2><br>  Il n'est pas rare de voir du code comme celui-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Remarque: les lecteurs attentifs remarqueront que cela est encore moins verbeux qu'il ne devrait l'être dans le code avant C ++ 20.</i>  <i>Plus d'informations à ce sujet plus tard.</i> <br><br>  Vous devez écrire beaucoup de code standard pour vous assurer que notre type est comparable à quelque chose du même type.  Ok, nous allons le découvrir pendant un certain temps.  Vient ensuite quelqu'un qui écrit comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  La première chose que vous remarquerez est que le programme ne se compilera pas. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Le problème est que <code>constexpr</code> été oublié dans la fonction de comparaison.  Ensuite, certains ajouteront <code>constexpr</code> à tous les opérateurs de comparaison.  Quelques jours plus tard, quelqu'un ajoutera l' <code>is_gt</code> , mais notez que tous les opérateurs de comparaison n'ont pas de spécification d'exception, et vous devrez suivre le même processus fastidieux d'ajouter <code>noexcept</code> à chacune des 5 surcharges. <br><br>  C'est là que le nouvel opérateur de vaisseau spatial C ++ 20 vient à notre aide.  Voyons comment vous pouvez écrire le <code>IntWrapper</code> origine dans le monde C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  La première différence que vous remarquerez peut-être est la nouvelle inclusion de <code>&lt;compare&gt;</code> .  L'en-tête <code>&lt;compare&gt;</code> est chargé de remplir le compilateur avec tous les types de catégories de comparaison nécessaires à l'opérateur du vaisseau spatial, afin qu'il renvoie un type adapté à notre fonction par défaut.  Dans l'extrait ci-dessus, le type de retour de <code>auto</code> sera <code>std::strong_ordering</code> . <br><br>  Nous avons non seulement supprimé 5 lignes supplémentaires, mais nous n'avons même pas besoin de déterminer quoi que ce soit, le compilateur le fera pour nous.  <code>is_lt</code> reste inchangé et fonctionne juste, tout en restant <code>constexpr</code> , bien que nous ne l'ayons pas spécifié explicitement dans notre <code>operator&lt;=&gt;</code> par défaut <code>operator&lt;=&gt;</code> .  C'est bien, mais certaines personnes peuvent se <code>is_lt</code> pourquoi <code>is_lt</code> autorisé à compiler même s'il n'utilise pas du tout l'opérateur de vaisseau spatial.  Trouvons la réponse à cette question. <br><br><h2>  Réécriture d'expressions </h2><br>  En C ++ 20, le compilateur est introduit dans un nouveau concept lié aux expressions «réécrites».  L'opérateur du vaisseau spatial, avec l' <code>operator==</code> , est l'un des deux premiers candidats qui peuvent être réécrits.  Pour un exemple plus spécifique d'expressions de réécriture, regardons l'exemple donné dans <code>is_lt</code> . <br><br>  Tout en résolvant la surcharge, le compilateur choisira parmi un ensemble des candidats les plus appropriés, chacun correspondant à l'opérateur dont nous avons besoin.  Le processus de sélection change très légèrement pour les opérations de comparaison et les opérations d'équivalence, lorsque le compilateur doit également collecter des candidats spéciaux transcrits et synthétisés ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Pour notre expression <code>a &lt; b</code> norme stipule que nous pouvons rechercher des fonctions de type <code>a</code> pour l' <code>operator&lt;=&gt;</code> ou l' <code>operator&lt;=&gt;</code> qui acceptent ce type.  C'est ce que fait le compilateur et découvre que le type <code>a</code> contient réellement <code>IntWrapper::operator&lt;=&gt;</code> .  Le compilateur est alors autorisé à utiliser cet opérateur et à réécrire l'expression <code>a &lt; b</code> as <code>(a &lt;=&gt; b) &lt; 0</code> .  Cette expression réécrite est ensuite utilisée comme candidate à une résolution normale de surcharge. <br><br>  Vous pouvez vous demander pourquoi cette expression réécrite est correcte.  La justesse de l'expression découle en fait de la sémantique fournie par l'opérateur du vaisseau spatial.  <code>&lt;=&gt;</code> est une comparaison à trois, ce qui implique que vous obtenez non seulement un résultat binaire, mais aussi un ordre (dans la plupart des cas).  Si vous avez une commande, vous pouvez exprimer cette commande en termes d'opérations de comparaison.  Un exemple rapide, l'expression 4 &lt;=&gt; 5 en C ++ 20 retournera le résultat <code>std::strong_ordering::less</code> .  Le résultat de <code>std::strong_ordering::less</code> implique que <code>4</code> non seulement différent de <code>5</code> mais également strictement inférieur à cette valeur, ce qui rend l'application de l'opération <code>(4 &lt;=&gt; 5) &lt; 0</code> correcte et précise pour décrire notre résultat. <br><br>  En utilisant les informations ci-dessus, le compilateur peut prendre n'importe quel opérateur de comparaison généralisé (c'est-à-dire <code>&lt;</code> , <code>&gt;</code> , etc.) et le réécrire en termes d'opérateur de vaisseau spatial.  Dans la norme, une expression réécrite est souvent appelée <code>(a &lt;=&gt; b) @ 0</code> où <code>@</code> représente toute opération de comparaison. <br><br><h2>  Synthétiser des expressions </h2><br>  Les lecteurs ont peut-être remarqué une référence subtile aux expressions «synthétisées» ci-dessus, et ils jouent également un rôle dans ce processus de réécriture des déclarations.  Considérez la fonction suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Si nous utilisons notre définition d'origine pour <code>IntWrapper</code> , ce code ne sera pas compilé. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Cela est logique avant C ++ 20, et la façon de résoudre ce problème consiste à ajouter des fonctions <code>friend</code> supplémentaires à <code>IntWrapper</code> qui occupent le côté gauche de l' <code>int</code> .  Si vous essayez de créer cet exemple à l'aide du compilateur et de la <code>IntWrapper</code> C ++ 20, vous remarquerez peut-être que cela fonctionne à nouveau.  Voyons pourquoi le code ci-dessus est toujours en cours de compilation en C ++ 20. <br><br>  Tout en résolvant les surcharges, le compilateur collectera également ce que la norme appelle des candidats «synthétisés», ou une expression réécrite avec l'ordre inverse des paramètres.  Dans l'exemple ci-dessus, le compilateur tentera d'utiliser l'expression réécrite <code>(42 &lt;=&gt; a) &lt; 0</code> , mais constatera qu'il n'y a pas de conversion d' <code>IntWrapper</code> en <code>int</code> pour satisfaire le côté gauche, de sorte que l'expression réécrite est ignorée.  Le compilateur appelle également l'expression «synthétisée» <code>0 &lt; (a &lt;=&gt; 42)</code> et détecte qu'une conversion de <code>int</code> vers <code>IntWrapper</code> via son constructeur de conversion, donc ce candidat est utilisé. <br><br>  Le but des expressions synthétisées est d'éviter la confusion d'écrire des modèles de fonction <code>friend</code> pour combler les lacunes dans lesquelles votre objet peut être converti à partir d'autres types.  Les expressions synthétisées sont généralisées à <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Types plus complexes </h2><br>  L'opérateur de vaisseau spatial généré par le compilateur ne s'arrête pas aux membres individuels des classes; il génère l'ensemble de comparaisons correct pour tous les sous-objets de vos types: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Le compilateur sait comment développer les membres de classe qui sont des tableaux dans leurs listes de sous-objets et les comparer récursivement.  Bien sûr, si vous voulez écrire vous-même le corps de ces fonctions, vous bénéficierez toujours de la réécriture des expressions par le compilateur. <br><br><h2>  Ressemble à un canard, nage comme un canard et charlatans comme <code>operator==</code> </h2><br>  Certaines personnes très intelligentes du comité de normalisation ont remarqué que l'opérateur du vaisseau spatial effectuera toujours une comparaison lexicographique des éléments, quoi qu'il arrive.  L'exécution inconditionnelle de comparaisons lexicographiques peut conduire à un code inefficace, en particulier, avec l'opérateur d'égalité. <br><br>  Un exemple canonique comparant deux lignes.  Si vous avez la chaîne <code>"foobar"</code> et que vous la comparez avec la chaîne <code>"foo"</code> utilisant ==, vous pouvez vous attendre à ce que cette opération soit presque constante.  Un algorithme de comparaison de chaînes efficace est le suivant: <br><br><ul><li>  Comparez d'abord la taille des deux lignes.  Si les tailles sont différentes, retournez <code>false</code> </li><li>  Sinon, parcourez pas à pas chaque élément de deux lignes et comparez-les jusqu'à ce qu'il y ait une différence ou que tous les éléments se terminent.  Renvoie le résultat. </li></ul><br>  Conformément aux règles de l'opérateur du vaisseau spatial, nous devons commencer par comparer chaque élément jusqu'à ce que nous en trouvions un qui soit différent.  Dans notre exemple, <code>"foobar"</code> et <code>"foo"</code> uniquement lorsque vous comparez <code>'b'</code> et <code>'\0'</code> , vous retournez finalement <code>false</code> . <br><br>  Pour lutter contre cela, il y avait l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1185R2</a> , qui détaille comment le compilateur réécrit et génère l' <code>operator==</code> indépendamment de l'opérateur du vaisseau spatial.  Notre <code>IntWrapper</code> peut s'écrire comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Un pas de plus ... cependant, il y a de bonnes nouvelles;  vous n'avez pas vraiment besoin d'écrire le code ci-dessus, car il suffit d'écrire <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> pour que le compilateur génère implicitement un <code>operator==</code> séparé et plus efficace <code>operator==</code> pour vous! <br><br>  Le compilateur applique une règle de «réécriture» légèrement modifiée, spécifique à <code>==</code> et <code>!=</code> , Où dans ces opérateurs ils sont réécrits en termes d' <code>operator==</code> plutôt que d' <code>operator&lt;=&gt;</code> .  Cela signifie que <code>!=</code> Bénéficie également de l'optimisation. <br><br><h2>  L'ancien code ne cassera pas </h2><br>  À ce stade, vous pourriez penser: eh bien, si le compilateur est autorisé à effectuer cette opération de réécriture d'opérateur, que se passera-t-il si j'essaie de déjouer le compilateur: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  La réponse n'est pas grave.  Le modèle de résolution de surcharge en C ++ est l'arène dans laquelle tous les candidats s'affrontent.  Dans cette bataille particulière, nous en avons trois: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (réécrit) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (synthétisé) <br><br>  Si nous adoptions des règles de résolution de surcharge en C ++ 17, le résultat de cet appel serait mélangé, mais les règles de résolution de surcharge C ++ 20 ont été modifiées afin que le compilateur puisse résoudre cette situation à la surcharge la plus logique. <br><br>  Il y a une phase de résolution de surcharge lorsque le compilateur doit effectuer une série de passes supplémentaires.  C ++ 20 a introduit un nouveau mécanisme dans lequel les surcharges qui ne sont pas écrasées ou synthétisées sont préférées, ce qui fait de notre <code>IntWrapper::operator&lt;</code> surcharge le meilleur candidat et résout l'ambiguïté.  Le même mécanisme empêche l'utilisation de candidats synthétisés au lieu des expressions réécrites habituelles. <br><br><h2>  Réflexions finales </h2><br>  L'opérateur de vaisseau spatial est un ajout bienvenu au C ++, car il peut vous aider à simplifier votre code et à écrire moins, et parfois moins c'est mieux.  Alors attachez et contrôlez votre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vaisseau spatial</a> C ++ 20! <br><br>  Nous vous invitons à sortir et à essayer l'opérateur de vaisseau spatial, il est disponible dès maintenant dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio 2019</a> sous <code>/std:c++latest</code> !  Remarque: les modifications apportées au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1185R2</a> seront disponibles dans Visual Studio 2019 version 16.2.  Veuillez garder à l'esprit que l'opérateur du vaisseau spatial fait partie de C ++ 20 et est soumis à certaines modifications jusqu'au moment où C ++ 20 est finalisé. <br><br>  Comme toujours, nous attendons vos commentaires.  N'hésitez pas à envoyer vos commentaires par e-mail à <a href="">visualcpp@microsoft.com</a> , via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter @visualc</a> ou Facebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft Visual Cpp</a> . <br><br>  Si vous rencontrez d'autres problèmes avec MSVC dans VS 2019, veuillez nous en informer via l'option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Signaler un problème»</a> , soit à partir du programme d'installation, soit à partir de l'IDE Visual Studio lui-même.  Pour des suggestions ou des rapports de bogues, écrivez-nous via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458242/">https://habr.com/ru/post/fr458242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458222/index.html">Briser un jeu de mémoire: toute une histoire de détective</a></li>
<li><a href="../fr458224/index.html">Le logiciel du Boeing-737 Max a été écrit par des sous-traitants gagnant 9 $ de l'heure</a></li>
<li><a href="../fr458228/index.html">Pourquoi avons-nous besoin de fonctions virtuelles</a></li>
<li><a href="../fr458230/index.html">Comment l'IA, les drones et les caméras assurent la sécurité de nos routes et de nos ponts</a></li>
<li><a href="../fr458240/index.html">Comment l'intelligence artificielle, les drones et les caméras assurent la sécurité des routes et des ponts</a></li>
<li><a href="../fr458244/index.html">Une liste interminable et ridicule de ce que vous devez savoir pour utiliser en toute sécurité les réseaux Wi-Fi publics</a></li>
<li><a href="../fr458246/index.html">Coïncidences aléatoires dans la vie, ou comment il s'est avéré qu'on vous a présenté un gâteau dans une usine de tracteurs</a></li>
<li><a href="../fr458248/index.html">Simplifiez votre code avec Rocket Science: l'opérateur de vaisseau spatial de C ++ 20</a></li>
<li><a href="../fr458250/index.html">BTRFS pour les plus petits</a></li>
<li><a href="../fr458252/index.html">Modèle mathématique d'un radiotélescope super long</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>