<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¸ ğŸ« â›¹ğŸ½ Comment j'ai crÃ©Ã© un filtre qui ne corrompe pas l'image mÃªme aprÃ¨s un million d'exÃ©cutions - partie 2 âœˆï¸ â° ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la premiÃ¨re partie de cet article, j'ai expliquÃ© comment l'utilisation rÃ©pÃ©tÃ©e de filtres demi-pixels standard crÃ©e des images dÃ©formÃ©es, puis j'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai crÃ©Ã© un filtre qui ne corrompe pas l'image mÃªme aprÃ¨s un million d'exÃ©cutions - partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="image"></div><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premiÃ¨re partie de</a> cet article, j'ai expliquÃ© comment l'utilisation rÃ©pÃ©tÃ©e de filtres demi-pixels standard crÃ©e des images dÃ©formÃ©es, puis j'ai montrÃ© un nouveau filtre qui ne prÃ©sente pas ce problÃ¨me. <br><br>  C'Ã©tait un peu plus flou et cela ne convenait pas Ã  tout le monde.  Cependant, c'Ã©tait mieux que ses alternatives - en fait, ce filtre Ã©tait utilisÃ© dans la version originale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bink 2</a> .  En raison de la charge de travail constante, je n'ai jamais rÃ©ussi Ã  revenir vers lui et Ã  l'examiner plus en dÃ©tail. <br><br>  Mais maintenant que j'ai <i>trouvÃ© le</i> temps de revenir sur ce filtre et d'Ã©crire un article Ã  ce sujet, je devrais enfin poser la question: existe-t-il un filtre <i>moins flou</i> qui conserve encore la propriÃ©tÃ© de Â«stabilitÃ© infinieÂ»? <br><br>  Avertissement de spoiler: la bonne rÃ©ponse est Â«probablement pasÂ» et Â«certainement lÃ Â».  Mais avant de comprendre pourquoi il y a deux rÃ©ponses Ã  cette question et ce qu'elles signifient, prÃ©parons mieux le banc d'essai. <br><a name="habracut"></a><br><h2>  RÃ©glage du dÃ©calage </h2><br>  Quand j'ai d'abord travaillÃ© sur ce problÃ¨me, je n'avais aucune idÃ©e de ce que je cherchais.  Je ne savais mÃªme pas qu'il <i>existait</i> un filtre demi-pixel Â«infiniment stableÂ», donc je n'ai pas crÃ©Ã© de systÃ¨me dans sa recherche.  Je cherchais juste quelque chose qui rÃ©sisterait aux Â«nombreusesÂ» itÃ©rations du filtre sans distorsion de l'image.  Toutes les images de la premiÃ¨re partie reflÃ¨tent cette mÃ©thodologie: l'image est dÃ©calÃ©e de droite Ã  gauche d'un demi-pixel Ã  la fois, c'est-Ã -dire que si vous appliquez le filtre 100 fois, l'image rÃ©sultante sera dÃ©calÃ©e de 50 pixels. <br><br>  Maintenant que nous savons ce que nous recherchons, nous pouvons Ãªtre un peu plus prÃ©cis.  En appliquant le filtre halfpel deux fois, nous dÃ©calons l'image exactement d'un pixel.  Autrement dit, si nous <i>dÃ©plaÃ§ons</i> simplement <i>l'image d'un pixel en arriÃ¨re</i> , elle restera dans le mÃªme espace.  GrÃ¢ce Ã  cela, le test sera beaucoup plus beau, car nous pourrons non seulement appliquer le filtre un certain nombre de fois, sans craindre que l'image ne "rampe" loin de l'Ã©cran, mais nous pourrons Ã©galement trouver la <i>diffÃ©rence de l'</i> image avec les versions prÃ©cÃ©dentes et avec l'original. <br><br>  Cela nous permettra de tester les filtres automatiquement.  Nous appliquons simplement le filtre plusieurs fois et voyons l'une des deux choses: soit la convergence vers une image inchangÃ©e, indiquant que le filtre est infiniment stable, soit un Ã©cart significativement important par rapport Ã  l'image d'origine, indiquant que le filtre est Â«cassÃ©Â».  Pour ces tests, j'ai choisi l'erreur moyenne par canal 64 (sur 255), ou l'erreur maximale sur l'un des canaux au maximum 255 comme Â«significativement grandeÂ». Si l'une de ces conditions est vraie, nous supposerons que le filtre Â«s'est cassÃ©Â» ". <br><br><h2>  Re-tester les filtres de la premiÃ¨re partie </h2><br>  Donc, maintenant nous comprenons mieux comment tester ces filtres, alors jetons un nouveau regard sur les filtres de la premiÃ¨re partie.  CommenÃ§ons par un bilinÃ©aire, ce qui, bien sÃ»r, n'est pas trÃ¨s intÃ©ressant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br>  Ceci est une image aprÃ¨s 244 itÃ©rations.  Comme vous pouvez vous y attendre, l'image se Â«casseÂ» progressivement en raison de la moyenne constante des pixels.  Mais mÃªme elle atteint progressivement la limite de l'erreur moyenne. <br><br>  Voici h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br>  Pour briser l'image, 78 itÃ©rations lui suffisent.  Le filtre HEVC avec 8 Ã©chantillons se comporte un peu mieux, mais se casse toujours aprÃ¨s 150 itÃ©rations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br>  Lanczos avec 6 Ã©chantillons se brise aprÃ¨s 166 itÃ©rations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br>  C'est tout nos filtres cassÃ©s.  Tout ce qui reste est mon filtre entier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br>  Comme prÃ©vu, il n'Ã©tait <i>pas le</i> seul <i>Ã </i> casser.  Il converge vers une image infiniment stable aprÃ¨s 208 itÃ©rations. <br><br>  Ce que nous savons est tout Ã  fait remarquable ici: au moins pour une large gamme d'images de test, ce filtre est <i>infiniment stable</i> , c'est-Ã -dire qu'il ne crÃ©era jamais d'artefact, quel que soit le nombre de fois qu'il est utilisÃ©. <br><br>  Cela nous ramÃ¨ne Ã  la question initiale: est-il vraiment le meilleur?  Et vous connaissez dÃ©jÃ  les rÃ©ponses, car au dÃ©but de l'article, j'ai aussi Ã©crit: Â«probablement pasÂ» et Â«dÃ©finitivement, ouiÂ». <br><br>  Examinons d'abord la partie Â«probablement pasÂ» en premier. <br><br><h2>  Filtres entiers </h2><br>  Donc, dans la premiÃ¨re partie de l'article, j'ai mentionnÃ© que le noyau de filtre que j'ai trouvÃ© Ã©tait "le meilleur des dÃ©tectÃ©s", et c'est sa particularitÃ©.  Et voici la fonctionnalitÃ©: <br><br>  Quand je cherchais ce filtre, <i>en fait</i> je ne cherchais pas le <i>meilleur</i> filtre.  Je cherchais le meilleur filtre <i>qui puisse Ãªtre exprimÃ© avec un trÃ¨s petit nombre de dÃ©calages entiers, d'additions et de soustractions</i> .  Cela peut sembler Ã©trange, mais prenez votre temps. <br><br>  Vous avez peut-Ãªtre remarquÃ© que lorsque j'ai montrÃ© les coefficients de h.264, HEVC et le filtre bilinÃ©aire, ainsi que mon filtre, je les ai Ã©crits comme des numÃ©rateurs entiers sur des dÃ©nominateurs entiers, comme ceci: <br><br><pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Mais dans le cas de sinc fenÃªtrÃ©, j'ai agi diffÃ©remment et l'ai Ã©crit comme ceci: <br><br><pre> <code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number"><span class="hljs-number">0.02446</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.02446</span></span>};</code> </pre> <br>  La raison en est que le sinc fenÃªtrÃ© est en fait dÃ©duit d'une fonction mathÃ©matique continue qui n'a rien Ã  voir avec les fractions entiÃ¨res ordinaires.  Lorsque vous utilisez ce filtre, des nombres Ã  virgule flottante (aussi prÃ©cis que possible) sont utilisÃ©s qui correspondent aux valeurs de la fonction sinc.  Si vous vous efforcez de les appliquer avec prÃ©cision, vous ne devez pas les arrondir aux fractions ordinaires, car cela ajoutera une erreur. <br><br>  Les codecs vidÃ©o ne peuvent traditionnellement pas se permettre d'effectuer de telles opÃ©rations.  Les opÃ©rations en virgule flottante sur des tÃ¢ches aussi Â«lourdesÂ» que la compensation de mouvement sont tout simplement impossibles Ã  utiliser sur des Ã©quipements de faible puissance ou spÃ©cialisÃ©s.  Cela est <i>particuliÃ¨rement</i> vrai si nous parlons de codecs standard de l'industrie qui devraient fonctionner sur une large gamme d'appareils, y compris des puces intÃ©grÃ©es Ã  faible coÃ»t et Ã  faible coÃ»t. <br><br>  De plus, mÃªme si vous les exÃ©cutez sur le CPU, les jeux d'instructions modernes sont basÃ©s sur SIMD, c'est-Ã -dire que les opÃ©rations entiÃ¨res sur le CPU peuvent toujours Ãªtre effectuÃ©es plus rapidement: vous pouvez insÃ©rer deux entiers 16 bits dans l'espace d'un flottant 32 bits, doublant essentiellement les performances des opÃ©rations, par consÃ©quent, si nous considÃ©rons le nombre exact de cycles par opÃ©ration, un point flottant n'est pas toujours l'option la plus rapide. <br><br>  Vous voyez maintenant pourquoi cette fonctionnalitÃ© Ã©tait importante.  Comme je n'avais besoin que de simples opÃ©rations sur des nombres entiers de 16 bits, j'ai cherchÃ© ces noyaux qui peuvent Ãªtre exprimÃ©s en petits nombres entiers sur des diviseurs de deux Ã  64 et pas plus.  Il s'agit d'un ensemble de filtres beaucoup plus limitÃ© que si je considÃ©rais <i>un</i> ensemble de 6 coefficients Ã  virgule flottante. <br><br>  De mÃªme, pour des raisons d'efficacitÃ©, je n'ai considÃ©rÃ© aucun <i>autre</i> nombre d'Ã©chantillons.  La seule option Ã©tait 6 ou moins, donc je n'ai mÃªme pas testÃ© les versions avec 8 ou 10 Ã©chantillons. <br><br>  C'est ainsi que nous sommes arrivÃ©s Ã  la premiÃ¨re rÃ©ponse: "probablement pas".  Si nous adhÃ©rons Ã  ces restrictions, nous ne trouverons probablement pas de meilleur filtre qui puisse Ãªtre appliquÃ© un nombre infini de fois sans dÃ©gradation.  Le noyau du filtre de la premiÃ¨re partie est <i>probablement le</i> meilleur que nous puissions trouver, bien que je dois admettre que je ne peux pas le prouver de maniÃ¨re exhaustive. <br><br>  Mais que se passe-t <i>-</i> il si nous <i>n'avons pas besoin</i> de respecter de telles restrictions? <br><br><h2>  Version Ã  virgule flottante </h2><br>  Si nous nous dÃ©barrassons des limitations spÃ©cifiques Ã  la version originale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bink 2</a> (qui est maintenant assez obsolÃ¨te - de nombreuses rÃ©visions ont depuis Ã©tÃ© publiÃ©es) et utilisons des coefficients arbitraires en virgule flottante, comment pouvons-nous amÃ©liorer les rÃ©sultats? <br><br>  Eh bien, puisque nous savons que mon noyau entier ne se dÃ©grade jamais, et nous savons que Lanczos est plus net, mais se dÃ©grade, il est logique que nous puissions trouver une place <i>entre les</i> deux ensembles de coefficients oÃ¹ la dÃ©gradation commence.  J'ai donc Ã©crit un programme qui m'a aidÃ© Ã  trouver ce point particulier, et voici le noyau que j'ai trouvÃ©: <br><br><pre> <code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number"><span class="hljs-number">0.027617</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.027617</span></span>};</code> </pre> <br>  Ce noyau nÃ©cessite 272 itÃ©rations pour converger, mais il est infiniment stable et semble <i>beaucoup</i> plus net que mon filtre entier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br>  En fait, il est presque impossible de le distinguer de l'original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Presque ... mais pas tout Ã  fait.  Si vous regardez attentivement, vous pouvez toujours voir le flou et l'attÃ©nuation dans les zones Ã  contraste Ã©levÃ©.  La faÃ§on la plus simple de voir cela est dans l'Å“il d'un "dinosaure" orange et dans des zones de lumiÃ¨re vive derriÃ¨re le bambou. <br><br>  Autrement dit, un filtre Ã  virgule flottante Ã  6 Ã©chantillons est certainement meilleur, mais ce n'est pas parfait.  Peut-il encore Ãªtre amÃ©liorÃ©? <br><br><h2>  Augmentez la largeur du filtre </h2><br>  Initialement, un filtre Ã  6 Ã©chantillons a Ã©tÃ© sÃ©lectionnÃ© pour les mÃªmes raisons que les fractions Ã  petits entiers: je cherchais un filtre extrÃªmement efficace.  Mais maintenant, nous faisons des recherches et nous sommes dÃ©jÃ  passÃ©s Ã  des nombres Ã  virgule flottante, alors pourquoi ne pas envisager un filtre plus large? <br><br>  En combinant notre filtre entier Ã  6 Ã©chantillons avec le Lanczos Ã  6 Ã©chantillons, nous avons obtenu un trÃ¨s bon filtre.  Pourquoi ne le couplons-nous pas avec les Lanczos Ã  8 Ã©chantillons? <br><br>  Le Lanczos Ã  8 Ã©chantillons ressemble Ã  ceci: <br><br><pre> <code class="cpp hljs">Lanczos8[] = {<span class="hljs-number"><span class="hljs-number">-0.01263</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.01263</span></span>};</code> </pre> <br>  Comme le Lanczos Ã  6 Ã©chantillons, il est trÃ¨s instable et s'effondre aprÃ¨s 178 itÃ©rations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br>  Si nous recherchons un meilleur filtre entre un filtre entier Ã  6 Ã©chantillons et un Lanczos Ã  8 Ã©chantillons, nous trouvons ce filtre Ã  8 Ã©chantillons plutÃ´t remarquable: <br><br><pre> <code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number"><span class="hljs-number">-0.010547</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.010547</span></span>};</code> </pre> <br>  En tant que filtre infiniment stable, il fonctionne incroyablement bien.  Il converge aprÃ¨s 202 itÃ©rations (la convergence est plus rapide que mes deux filtres), et ressemble tellement Ã  l'original qu'il est difficile de dÃ©terminer lequel est lequel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br>  Voici Ã  nouveau l'original pour rÃ©fÃ©rence: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Par rapport Ã  mon filtre entier d'origine, il y a une amÃ©lioration significative. <br><br><h2>  Comment fonctionnent les filtres infiniment stables? </h2><br>  J'allais terminer ce post quelque chose comme ceci: <br><br>  "Je ne sais pas exactement comment tout cela fonctionne.  Dans d'autres domaines oÃ¹ j'ai travaillÃ© avec les transformations applicables Ã  l'infini, je sais comment les mathÃ©matiques des limites sont effectuÃ©es et une analyse utile est crÃ©Ã©e.  Tout d'abord, il s'agit de l'analyse de la surface limite pour les surfaces de subdivision, oÃ¹ les valeurs propres et les vecteurs propres de la matrice de subdivision sont calculÃ©s, aprÃ¨s quoi il est possible de prendre prÃ©cisÃ©ment la limite Ã  un degrÃ© infini.  Mais je n'ai aucune expÃ©rience dans la rÃ©alisation d'une telle analyse pour les filtres halfpel, car ils ne laissent pas les pixels en place, mais les dÃ©calent latÃ©ralement. " <br><br>  C'Ã©tait mon plan.  Mais entre l'Ã©criture des premiÃ¨re et deuxiÃ¨me parties, j'ai envoyÃ© les rÃ©sultats du filtre amÃ©liorÃ© Ã  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fabien Giessen</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Charles Bloom</a> .  Il n'est pas surprenant <i>qu'ils</i> connaissent les mathÃ©matiques nÃ©cessaires Ã  l'Ã©tude analytique de ce problÃ¨me.  Il s'est avÃ©rÃ© que pour les filtres, il y a vraiment une analyse des valeurs propres et des vecteurs, mais cela ne fonctionne pas tout Ã  fait de cette faÃ§on. <br><br>  Mais il <i>peut Ãªtre</i> facilement exÃ©cutÃ© - en fait, il est intÃ©grÃ© dans les programmes CAM comme un processus trivial en une seule Ã©tape et nous pouvons vraiment regarder les valeurs propres des filtres.  Il ne nous donne pas de rÃ©ponses complÃ¨tes, car ici le fait d' <i>arrondir</i> (ou troncature) Ã  8 bits (ou 10 bits, ou 12 bits) aprÃ¨s chaque filtrage est important, car la troncature affecte la mÃ©thode d'accumulation des erreurs par rapport Ã  l'algÃ¨bre infiniment prÃ©cise. <br><br>  Malheureusement, comme ce n'est pas du tout mon domaine d'expertise, je ne peux mÃªme pas avoir un aperÃ§u prÃ©cis de cette analyse.  J'ai demandÃ© Ã  Fabien et Charles s'ils pouvaient Ã©crire des articles avec les bonnes informations qu'ils m'ont envoyÃ©es par la poste (ils ont tous les deux des blogs techniques - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le blog</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ryg</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cbloom rants</a> ), et Fabien a Ã©crit une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellente sÃ©rie d'articles sur les fondements mathÃ©matiques des filtres stables</a> .  Si vous Ãªtes intÃ©ressÃ© par la structure thÃ©orique de ce qui se passe dans mes deux articles, alors je vous recommande de lire cette sÃ©rie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468629/">https://habr.com/ru/post/fr468629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468615/index.html">Les 10 meilleures langues pour la localisation d'applications</a></li>
<li><a href="../fr468621/index.html">Nous traduisons le rÃ©seau domestique en DoH, ou un autre clic sur le nez de filtrage</a></li>
<li><a href="../fr468623/index.html">Je veux des avis sur Habr</a></li>
<li><a href="../fr468625/index.html">Sans serveur: 15% plus lent et huit fois plus cher</a></li>
<li><a href="../fr468627/index.html">Modules d'E / S ADAM-6200</a></li>
<li><a href="../fr468631/index.html">Test des applications Flutter. Commencer</a></li>
<li><a href="../fr468635/index.html">DichalcogÃ©nures de mÃ©taux de transition: dÃ©bloquer les secrets de la croissance des cristaux WS2</a></li>
<li><a href="../fr468637/index.html">Comment gÃ©rer de grands ensembles de donnÃ©es dans les pandas. Nous travaillons avec la base de donnÃ©es FIAS en utilisant python et 8 Go de mÃ©moire</a></li>
<li><a href="../fr468639/index.html">NouveautÃ©s des consoles Web 2019</a></li>
<li><a href="../fr468641/index.html">Tutoriel pour crÃ©er une solution de chaÃ®ne de blocs sur Hyperledger Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>