<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚸 🎫 ⛹🏽 Comment j'ai créé un filtre qui ne corrompe pas l'image même après un million d'exécutions - partie 2 ✈️ ⏰ 👩🏾‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la première partie de cet article, j'ai expliqué comment l'utilisation répétée de filtres demi-pixels standard crée des images déformées, puis j'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai créé un filtre qui ne corrompe pas l'image même après un million d'exécutions - partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="image"></div><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de</a> cet article, j'ai expliqué comment l'utilisation répétée de filtres demi-pixels standard crée des images déformées, puis j'ai montré un nouveau filtre qui ne présente pas ce problème. <br><br>  C'était un peu plus flou et cela ne convenait pas à tout le monde.  Cependant, c'était mieux que ses alternatives - en fait, ce filtre était utilisé dans la version originale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bink 2</a> .  En raison de la charge de travail constante, je n'ai jamais réussi à revenir vers lui et à l'examiner plus en détail. <br><br>  Mais maintenant que j'ai <i>trouvé le</i> temps de revenir sur ce filtre et d'écrire un article à ce sujet, je devrais enfin poser la question: existe-t-il un filtre <i>moins flou</i> qui conserve encore la propriété de «stabilité infinie»? <br><br>  Avertissement de spoiler: la bonne réponse est «probablement pas» et «certainement là».  Mais avant de comprendre pourquoi il y a deux réponses à cette question et ce qu'elles signifient, préparons mieux le banc d'essai. <br><a name="habracut"></a><br><h2>  Réglage du décalage </h2><br>  Quand j'ai d'abord travaillé sur ce problème, je n'avais aucune idée de ce que je cherchais.  Je ne savais même pas qu'il <i>existait</i> un filtre demi-pixel «infiniment stable», donc je n'ai pas créé de système dans sa recherche.  Je cherchais juste quelque chose qui résisterait aux «nombreuses» itérations du filtre sans distorsion de l'image.  Toutes les images de la première partie reflètent cette méthodologie: l'image est décalée de droite à gauche d'un demi-pixel à la fois, c'est-à-dire que si vous appliquez le filtre 100 fois, l'image résultante sera décalée de 50 pixels. <br><br>  Maintenant que nous savons ce que nous recherchons, nous pouvons être un peu plus précis.  En appliquant le filtre halfpel deux fois, nous décalons l'image exactement d'un pixel.  Autrement dit, si nous <i>déplaçons</i> simplement <i>l'image d'un pixel en arrière</i> , elle restera dans le même espace.  Grâce à cela, le test sera beaucoup plus beau, car nous pourrons non seulement appliquer le filtre un certain nombre de fois, sans craindre que l'image ne "rampe" loin de l'écran, mais nous pourrons également trouver la <i>différence de l'</i> image avec les versions précédentes et avec l'original. <br><br>  Cela nous permettra de tester les filtres automatiquement.  Nous appliquons simplement le filtre plusieurs fois et voyons l'une des deux choses: soit la convergence vers une image inchangée, indiquant que le filtre est infiniment stable, soit un écart significativement important par rapport à l'image d'origine, indiquant que le filtre est «cassé».  Pour ces tests, j'ai choisi l'erreur moyenne par canal 64 (sur 255), ou l'erreur maximale sur l'un des canaux au maximum 255 comme «significativement grande». Si l'une de ces conditions est vraie, nous supposerons que le filtre «s'est cassé» ". <br><br><h2>  Re-tester les filtres de la première partie </h2><br>  Donc, maintenant nous comprenons mieux comment tester ces filtres, alors jetons un nouveau regard sur les filtres de la première partie.  Commençons par un bilinéaire, ce qui, bien sûr, n'est pas très intéressant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br>  Ceci est une image après 244 itérations.  Comme vous pouvez vous y attendre, l'image se «casse» progressivement en raison de la moyenne constante des pixels.  Mais même elle atteint progressivement la limite de l'erreur moyenne. <br><br>  Voici h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br>  Pour briser l'image, 78 itérations lui suffisent.  Le filtre HEVC avec 8 échantillons se comporte un peu mieux, mais se casse toujours après 150 itérations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br>  Lanczos avec 6 échantillons se brise après 166 itérations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br>  C'est tout nos filtres cassés.  Tout ce qui reste est mon filtre entier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br>  Comme prévu, il n'était <i>pas le</i> seul <i>à</i> casser.  Il converge vers une image infiniment stable après 208 itérations. <br><br>  Ce que nous savons est tout à fait remarquable ici: au moins pour une large gamme d'images de test, ce filtre est <i>infiniment stable</i> , c'est-à-dire qu'il ne créera jamais d'artefact, quel que soit le nombre de fois qu'il est utilisé. <br><br>  Cela nous ramène à la question initiale: est-il vraiment le meilleur?  Et vous connaissez déjà les réponses, car au début de l'article, j'ai aussi écrit: «probablement pas» et «définitivement, oui». <br><br>  Examinons d'abord la partie «probablement pas» en premier. <br><br><h2>  Filtres entiers </h2><br>  Donc, dans la première partie de l'article, j'ai mentionné que le noyau de filtre que j'ai trouvé était "le meilleur des détectés", et c'est sa particularité.  Et voici la fonctionnalité: <br><br>  Quand je cherchais ce filtre, <i>en fait</i> je ne cherchais pas le <i>meilleur</i> filtre.  Je cherchais le meilleur filtre <i>qui puisse être exprimé avec un très petit nombre de décalages entiers, d'additions et de soustractions</i> .  Cela peut sembler étrange, mais prenez votre temps. <br><br>  Vous avez peut-être remarqué que lorsque j'ai montré les coefficients de h.264, HEVC et le filtre bilinéaire, ainsi que mon filtre, je les ai écrits comme des numérateurs entiers sur des dénominateurs entiers, comme ceci: <br><br><pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Mais dans le cas de sinc fenêtré, j'ai agi différemment et l'ai écrit comme ceci: <br><br><pre> <code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number"><span class="hljs-number">0.02446</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.02446</span></span>};</code> </pre> <br>  La raison en est que le sinc fenêtré est en fait déduit d'une fonction mathématique continue qui n'a rien à voir avec les fractions entières ordinaires.  Lorsque vous utilisez ce filtre, des nombres à virgule flottante (aussi précis que possible) sont utilisés qui correspondent aux valeurs de la fonction sinc.  Si vous vous efforcez de les appliquer avec précision, vous ne devez pas les arrondir aux fractions ordinaires, car cela ajoutera une erreur. <br><br>  Les codecs vidéo ne peuvent traditionnellement pas se permettre d'effectuer de telles opérations.  Les opérations en virgule flottante sur des tâches aussi «lourdes» que la compensation de mouvement sont tout simplement impossibles à utiliser sur des équipements de faible puissance ou spécialisés.  Cela est <i>particulièrement</i> vrai si nous parlons de codecs standard de l'industrie qui devraient fonctionner sur une large gamme d'appareils, y compris des puces intégrées à faible coût et à faible coût. <br><br>  De plus, même si vous les exécutez sur le CPU, les jeux d'instructions modernes sont basés sur SIMD, c'est-à-dire que les opérations entières sur le CPU peuvent toujours être effectuées plus rapidement: vous pouvez insérer deux entiers 16 bits dans l'espace d'un flottant 32 bits, doublant essentiellement les performances des opérations, par conséquent, si nous considérons le nombre exact de cycles par opération, un point flottant n'est pas toujours l'option la plus rapide. <br><br>  Vous voyez maintenant pourquoi cette fonctionnalité était importante.  Comme je n'avais besoin que de simples opérations sur des nombres entiers de 16 bits, j'ai cherché ces noyaux qui peuvent être exprimés en petits nombres entiers sur des diviseurs de deux à 64 et pas plus.  Il s'agit d'un ensemble de filtres beaucoup plus limité que si je considérais <i>un</i> ensemble de 6 coefficients à virgule flottante. <br><br>  De même, pour des raisons d'efficacité, je n'ai considéré aucun <i>autre</i> nombre d'échantillons.  La seule option était 6 ou moins, donc je n'ai même pas testé les versions avec 8 ou 10 échantillons. <br><br>  C'est ainsi que nous sommes arrivés à la première réponse: "probablement pas".  Si nous adhérons à ces restrictions, nous ne trouverons probablement pas de meilleur filtre qui puisse être appliqué un nombre infini de fois sans dégradation.  Le noyau du filtre de la première partie est <i>probablement le</i> meilleur que nous puissions trouver, bien que je dois admettre que je ne peux pas le prouver de manière exhaustive. <br><br>  Mais que se passe-t <i>-</i> il si nous <i>n'avons pas besoin</i> de respecter de telles restrictions? <br><br><h2>  Version à virgule flottante </h2><br>  Si nous nous débarrassons des limitations spécifiques à la version originale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bink 2</a> (qui est maintenant assez obsolète - de nombreuses révisions ont depuis été publiées) et utilisons des coefficients arbitraires en virgule flottante, comment pouvons-nous améliorer les résultats? <br><br>  Eh bien, puisque nous savons que mon noyau entier ne se dégrade jamais, et nous savons que Lanczos est plus net, mais se dégrade, il est logique que nous puissions trouver une place <i>entre les</i> deux ensembles de coefficients où la dégradation commence.  J'ai donc écrit un programme qui m'a aidé à trouver ce point particulier, et voici le noyau que j'ai trouvé: <br><br><pre> <code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number"><span class="hljs-number">0.027617</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.027617</span></span>};</code> </pre> <br>  Ce noyau nécessite 272 itérations pour converger, mais il est infiniment stable et semble <i>beaucoup</i> plus net que mon filtre entier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br>  En fait, il est presque impossible de le distinguer de l'original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Presque ... mais pas tout à fait.  Si vous regardez attentivement, vous pouvez toujours voir le flou et l'atténuation dans les zones à contraste élevé.  La façon la plus simple de voir cela est dans l'œil d'un "dinosaure" orange et dans des zones de lumière vive derrière le bambou. <br><br>  Autrement dit, un filtre à virgule flottante à 6 échantillons est certainement meilleur, mais ce n'est pas parfait.  Peut-il encore être amélioré? <br><br><h2>  Augmentez la largeur du filtre </h2><br>  Initialement, un filtre à 6 échantillons a été sélectionné pour les mêmes raisons que les fractions à petits entiers: je cherchais un filtre extrêmement efficace.  Mais maintenant, nous faisons des recherches et nous sommes déjà passés à des nombres à virgule flottante, alors pourquoi ne pas envisager un filtre plus large? <br><br>  En combinant notre filtre entier à 6 échantillons avec le Lanczos à 6 échantillons, nous avons obtenu un très bon filtre.  Pourquoi ne le couplons-nous pas avec les Lanczos à 8 échantillons? <br><br>  Le Lanczos à 8 échantillons ressemble à ceci: <br><br><pre> <code class="cpp hljs">Lanczos8[] = {<span class="hljs-number"><span class="hljs-number">-0.01263</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.01263</span></span>};</code> </pre> <br>  Comme le Lanczos à 6 échantillons, il est très instable et s'effondre après 178 itérations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br>  Si nous recherchons un meilleur filtre entre un filtre entier à 6 échantillons et un Lanczos à 8 échantillons, nous trouvons ce filtre à 8 échantillons plutôt remarquable: <br><br><pre> <code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number"><span class="hljs-number">-0.010547</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.010547</span></span>};</code> </pre> <br>  En tant que filtre infiniment stable, il fonctionne incroyablement bien.  Il converge après 202 itérations (la convergence est plus rapide que mes deux filtres), et ressemble tellement à l'original qu'il est difficile de déterminer lequel est lequel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br>  Voici à nouveau l'original pour référence: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Par rapport à mon filtre entier d'origine, il y a une amélioration significative. <br><br><h2>  Comment fonctionnent les filtres infiniment stables? </h2><br>  J'allais terminer ce post quelque chose comme ceci: <br><br>  "Je ne sais pas exactement comment tout cela fonctionne.  Dans d'autres domaines où j'ai travaillé avec les transformations applicables à l'infini, je sais comment les mathématiques des limites sont effectuées et une analyse utile est créée.  Tout d'abord, il s'agit de l'analyse de la surface limite pour les surfaces de subdivision, où les valeurs propres et les vecteurs propres de la matrice de subdivision sont calculés, après quoi il est possible de prendre précisément la limite à un degré infini.  Mais je n'ai aucune expérience dans la réalisation d'une telle analyse pour les filtres halfpel, car ils ne laissent pas les pixels en place, mais les décalent latéralement. " <br><br>  C'était mon plan.  Mais entre l'écriture des première et deuxième parties, j'ai envoyé les résultats du filtre amélioré à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fabien Giessen</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Charles Bloom</a> .  Il n'est pas surprenant <i>qu'ils</i> connaissent les mathématiques nécessaires à l'étude analytique de ce problème.  Il s'est avéré que pour les filtres, il y a vraiment une analyse des valeurs propres et des vecteurs, mais cela ne fonctionne pas tout à fait de cette façon. <br><br>  Mais il <i>peut être</i> facilement exécuté - en fait, il est intégré dans les programmes CAM comme un processus trivial en une seule étape et nous pouvons vraiment regarder les valeurs propres des filtres.  Il ne nous donne pas de réponses complètes, car ici le fait d' <i>arrondir</i> (ou troncature) à 8 bits (ou 10 bits, ou 12 bits) après chaque filtrage est important, car la troncature affecte la méthode d'accumulation des erreurs par rapport à l'algèbre infiniment précise. <br><br>  Malheureusement, comme ce n'est pas du tout mon domaine d'expertise, je ne peux même pas avoir un aperçu précis de cette analyse.  J'ai demandé à Fabien et Charles s'ils pouvaient écrire des articles avec les bonnes informations qu'ils m'ont envoyées par la poste (ils ont tous les deux des blogs techniques - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le blog</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ryg</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cbloom rants</a> ), et Fabien a écrit une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellente série d'articles sur les fondements mathématiques des filtres stables</a> .  Si vous êtes intéressé par la structure théorique de ce qui se passe dans mes deux articles, alors je vous recommande de lire cette série! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468629/">https://habr.com/ru/post/fr468629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468615/index.html">Les 10 meilleures langues pour la localisation d'applications</a></li>
<li><a href="../fr468621/index.html">Nous traduisons le réseau domestique en DoH, ou un autre clic sur le nez de filtrage</a></li>
<li><a href="../fr468623/index.html">Je veux des avis sur Habr</a></li>
<li><a href="../fr468625/index.html">Sans serveur: 15% plus lent et huit fois plus cher</a></li>
<li><a href="../fr468627/index.html">Modules d'E / S ADAM-6200</a></li>
<li><a href="../fr468631/index.html">Test des applications Flutter. Commencer</a></li>
<li><a href="../fr468635/index.html">Dichalcogénures de métaux de transition: débloquer les secrets de la croissance des cristaux WS2</a></li>
<li><a href="../fr468637/index.html">Comment gérer de grands ensembles de données dans les pandas. Nous travaillons avec la base de données FIAS en utilisant python et 8 Go de mémoire</a></li>
<li><a href="../fr468639/index.html">Nouveautés des consoles Web 2019</a></li>
<li><a href="../fr468641/index.html">Tutoriel pour créer une solution de chaîne de blocs sur Hyperledger Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>