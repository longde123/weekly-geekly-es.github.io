<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏽 🤯 🍕 Como não dar um tiro na perna com uma máquina de estado 👨🏼‍🔬 🚵🏾 👨🏾‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A máquina de estado raramente é usada pelos desenvolvedores móveis. Embora a maioria conheça os princípios do trabalho e o implemente facilmente de fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como não dar um tiro na perna com uma máquina de estado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423293/"> A máquina de estado raramente é usada pelos desenvolvedores móveis.  Embora a maioria conheça os princípios do trabalho e o implemente facilmente de forma independente.  No artigo, descobriremos quais tarefas são resolvidas pela máquina de estado usando o exemplo de aplicativos iOS.  A história é aplicada na natureza e é dedicada aos aspectos práticos do trabalho. <br><br>  Abaixo do corte, você encontrará uma transcrição expandida do discurso de Alexander Sychev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Brain89</a> ) no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a> , no qual ele compartilhou suas opções para usar a máquina de estado no desenvolvimento de aplicativos que não são de jogos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GKMrJe3mfwU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Sobre o palestrante:</b> Alexander Sychev atua no desenvolvimento de iOS há oito anos, durante os quais participou da criação de aplicativos simples e clientes complexos para redes sociais e setor financeiro.  No momento, é líder técnico do Sberbank. <br><a name="habracut"></a><br>  Eles vêm para a programação de muitas áreas, com diferentes experiências e antecedentes, então primeiro lembramos da teoria básica. <br><br><h2>  Declaração do problema <br></h2><br><img src="https://habrastorage.org/webt/ow/wa/vd/owwavd51w_12g14nwehehu4yfu4.jpeg"><br><br>  Uma máquina de estado é uma abstração matemática que consiste em três elementos principais: <br><br><ul><li>  muitos estados internos </li><li>  o conjunto de sinais de entrada que determinam a transição do estado atual para o próximo, </li><li>  conjuntos de estados finais, após a transição para a qual o autômato conclui seu trabalho ("admite a palavra de entrada x"). </li></ul><br><h3>  Condição <br></h3><br>  Por estado, queremos dizer uma variável ou um grupo de variáveis ​​que determinam o comportamento de um objeto.  Por exemplo, no aplicativo iOS padrão "Configurações <strong>",</strong> há um item "Negrito" ("Básico → Acesso universal").  O valor deste item permite alternar entre duas opções para exibir texto na tela do dispositivo. <br><br><img src="https://habrastorage.org/webt/mx/if/68/mxif68m4rgadt4kgjqovnzswvny.jpeg"><br><br>  Ao enviar o mesmo sinal "Alterar o valor da chave seletora <strong>"</strong> , obtemos uma reação diferente do sistema: o estilo de fonte usual ou negrito - tudo é simples.  Estando em diferentes estados e recebendo o mesmo sinal, um objeto reage de maneira diferente a uma mudança de estado. <br><br><h2>  Tarefas tradicionais <br></h2><br>  Na prática, os programadores geralmente encontram uma máquina de estados finitos. <br><br><h3>  Aplicações de jogos <br></h3><br>  Esta é a primeira coisa que vem à mente - como parte da jogabilidade, quase tudo é determinado pelo estado atual do jogo.  Portanto, a Apple assume o uso de máquinas de estado principalmente em aplicativos de jogos (discutiremos isso em detalhes posteriormente). <br><br>  O comportamento do sistema ao processar o mesmo sinal, mas com um estado interno diferente, pode ser ilustrado pelos seguintes exemplos.  Por exemplo: <br><br>  ● o personagem do jogo pode ter diferentes forças: uma com armadura mecânica e uma pistola a laser, e a outra com pouca força.  Dependendo desse estado, o comportamento dos inimigos é determinado: eles atacam ou fogem. <br><br><img src="https://habrastorage.org/webt/-9/ur/ci/-9urcijninqy6zo8as2i8adn46o.jpeg"><br><br>  ● o jogo está em pausa - não é necessário desenhar o quadro atual;  o jogador no modo de menu ou no processo do jogo - a renderização é completamente diferente. <br><br><h3>  Análise de Texto <br></h3><br>  Uma das tarefas mais populares de análise de texto associadas ao uso de uma máquina de estado são os filtros de spam.  Que haja um conjunto de palavras de parada e uma sequência de entrada.  Você deve filtrar essa sequência ou não exibi-la. <br><br><img src="https://habrastorage.org/webt/vo/ka/c2/vokac2-lpmhmsapxqmtked5buo4.jpeg"><br><br>  Formalmente, esta é a tarefa de encontrar uma substring em uma string.  Para resolvê-lo, é utilizado o algoritmo Knut-Morris-Pratt, cuja implementação de software é uma máquina de estados finitos.  O estado é o deslocamento da sequência de entrada e o número de caracteres encontrados na palavra de parada padrão. <br><br>  Além disso, <strong>ao analisar expressões regulares</strong> , frequentemente são usadas máquinas de estado finito. <br><br><h3>  Processamento de consulta paralela <br></h3><br>  Uma máquina de estado é uma das opções para implementar o processamento de solicitações e executar um conjunto estrito de instruções. <br><br><img src="https://habrastorage.org/webt/i_/ll/n9/i_lln9kr6-tfmnr0ejx7mjn3ytk.jpeg"><br><br>  Por exemplo, no servidor da web nginx, as solicitações de entrada de vários protocolos são processadas usando máquinas de estado.  Dependendo do protocolo específico, uma implementação específica da máquina de estados é selecionada e, portanto, um conjunto conhecido de instruções é executado. <br><br>  Em geral, são obtidas duas classes de problemas: <br><br><ul><li>  gerenciar a lógica de um objeto complexo com um estado interno complexo, </li><li>  formação de controle e fluxos de dados (descrição do algoritmo). </li></ul><br>  Obviamente, essas tarefas comuns são encontradas na prática de qualquer programador.  Portanto, é possível o uso de uma máquina de estado, inclusive em aplicativos de conteúdo que não sejam de jogos, envolvidos na maioria dos desenvolvedores de dispositivos móveis. <br><br>  Em seguida, analisaremos onde e quando a máquina de estado pode ser usada para criar aplicativos iOS típicos. <br><br>  A maioria dos aplicativos móveis possui uma arquitetura em camadas.  Existem três camadas de base. <br><br><ul><li>  Camada de apresentação. </li><li>  Camada de lógica de negócios. </li><li>  Um conjunto de auxiliares, clientes de rede e assim por diante (camada principal). </li></ul><br>  Como indicado acima, a máquina de estado controla objetos com comportamento complexo, ou seja,  com condição complexa.  Esses objetos estão definitivamente na camada de apresentação, porque toma decisões processando entradas ou mensagens do usuário do sistema operacional.  Vejamos as diferentes abordagens para sua execução. <br><br><img src="https://habrastorage.org/webt/ic/iq/pw/iciqpwtfuuokmoik0j5abflppg4.jpeg"><br><br>  Na metáfora arquitetônica clássica do Model-View-Controller, o estado estará no controlador: ele decide o que é exibido no View e como responder aos sinais de entrada: pressionando um botão, alterando o controle deslizante e assim por diante.  É lógico que uma das implementações do controlador seja uma máquina de estado. <br><br><img src="https://habrastorage.org/webt/xt/sv/cr/xtsvcrd3ehffxfreo8ivtwx7jy8.jpeg"><br><br>  No VIPER, o estado está no apresentador: é ele quem determina a transição de navegação específica da tela atual e a exibição dos dados na Visualização. <br><br><img src="https://habrastorage.org/webt/_p/ob/xb/_pobxbwjjwduuken8qiucqg5o30.jpeg"><br><br>  No Model-View-ViewModel, o estado está no ViewModel.  Independentemente de termos ou não ligantes reativos, o comportamento do módulo definido na metáfora MVVM será registrado no ViewModel.  Obviamente, sua implementação através de uma máquina de estado é uma opção aceitável. <br><br><img src="https://habrastorage.org/webt/x0/8e/kf/x08ekfoc9zyg1s9_9jiirethpgm.jpeg"><br><br>  Objetos complexos com um conjunto não trivial de estados também são encontrados na camada de lógica de negócios do aplicativo.  Por exemplo, um cliente de rede que, dependendo se uma conexão com o servidor está ou não estabelecida, envia ou bloqueia solicitações.  Ou um objeto para trabalhar com um banco de dados que precisa converter funções de linguagem em uma consulta SQL, executá-lo, obter uma resposta, traduzi-lo em objetos etc. <br><br><img src="https://habrastorage.org/webt/pb/bq/yt/pbbqytlwgtmbcutdlliqv5xkwjs.jpeg"><br><br>  Em tarefas mais específicas, como um módulo de pagamento, no qual um conjunto mais amplo de estados, lógica complexa, o uso de uma máquina de estados também está correto. <br><br>  Como resultado, descobrimos que em aplicativos móveis existem muitos objetos cujo estado e lógica de comportamento são descritos mais complicados do que com uma frase.  Eles devem ser capazes de gerenciar. <br><br>  Considere um <strong>exemplo real</strong> e entenda em que ponto uma máquina de estado finito é realmente necessária e onde sua aplicação não é justificada. <br><br><img src="https://habrastorage.org/webt/96/hk/lw/96hklw8ditorh2imz2zcx36wmga.jpeg"><br><br>  Considere o ViewController do aplicativo Championship iOS, um recurso esportivo popular.  Este controlador exibe um conjunto de comentários em forma de tabela.  Os usuários inserem a descrição da partida, visualizam fotos, leem as notícias e deixam seus comentários.  A tela é bastante simples: a camada subjacente fornece dados, é processada e exibida na tela. <br><img src="https://habrastorage.org/webt/m7/m1/yz/m7m1yz9--h4qttlcuxjrozagl48.jpeg"><br><br>  Dados reais ou um erro podem ser transmitidos para o display.  Portanto, o primeiro operador condicional aparece, o primeiro ramo, que determina o comportamento adicional do aplicativo. <br><br>  A próxima pergunta é o que fazer se não houver dados.  Esta condição é um erro?  Provavelmente não: nem todas as notícias têm comentários de usuários.  Por exemplo, o hóquei no Egito é de pouco interesse para qualquer pessoa; nesse artigo, geralmente não há comentários.  Esse é o comportamento normal e o estado normal da tela que você precisa para poder exibir.  Portanto, o segundo operador condicional aparece. <br><br>  É lógico supor que também existe um estado inicial no qual o usuário espera dados (por exemplo, quando a tela de comentários aparece apenas na tela).  Nesse caso, exiba o indicador de carregamento corretamente.  Esta é a terceira declaração condicional. <br><br>  Portanto, já temos quatro estados em uma tela simples, cuja lógica de exibição é descrita através da construção if-else-if-else. <br><br><img src="https://habrastorage.org/webt/ys/yg/mq/ysygmq4fbj3mog3p6mjb0t5av9o.jpeg"><br><br>  Mas e se houver mais desses estados?  O desenvolvimento iterativo da tela leva a um emaranhado intrincado de construções condicionais, um monte de sinalizadores ou uma caixa de comutação múltipla complicada.  Este código é assustador.  Imagine que o desenvolvedor que o apoiará sabe onde você mora e ele tem uma serra elétrica que ele sempre carrega com ele.  E você realmente quer viver de acordo com sua pensão pequena, mas bem merecida. <br><br>  Penso que, neste caso, vale a pena considerar se vale a pena deixar essa implementação no aplicativo. <br><br><h3>  Desvantagens <br></h3><br>  Vamos entender o que não gostamos neste código. <br><br><img src="https://habrastorage.org/webt/2u/a-/67/2ua-67iwmlvw9zki5oxmjf4mfqe.jpeg"><br><br>  Primeiro de tudo, é <strong>difícil de ler</strong> . <br><br>  Como o código é mal lido, significa que será difícil para um novo desenvolvedor descobrir o que exatamente é implementado em um determinado local do projeto.  Dessa forma, gastará muito tempo analisando a lógica de comportamento do aplicativo - o <strong>custo do suporte e do desenvolvimento aumentará</strong> . <br><br>  Este código não é <strong>flexível</strong> .  Se você precisar adicionar um novo estado que não segue da escada atual, ele pode não ter êxito!  Se você precisar de uma passagem direta - pare abruptamente de passar nas verificações nesta escada - como fazê-lo?  Quase nada. <br><br>  Além disso, com essa abordagem, <strong>não há proteção contra estados fictícios</strong> .  Quando as transições são descritas através de um caso de opção, provavelmente o comportamento padrão é implementado.  Esse estado é lógico em termos de comportamento do programa, mas dificilmente lógico em termos da lógica humana ou comercial do aplicativo. <br><br>  Qual pode ser a solução para as deficiências indicadas?  Obviamente, essa é a construção da lógica de cada módulo / controlador / objeto complexo, não com base na intuição, mas usando uma boa abordagem formalizada.  Por exemplo, uma máquina de estados finitos. <br><br><h2>  Gameplaykit <br></h2><br>  Como <strong>exemplo,</strong> tomamos o que a Apple oferece.  Dentro da estrutura GameplayKit, existem duas classes que nos ajudam a trabalhar com a máquina de estado. <br><br><ul><li>  GKState. </li><li>  GKStateMachine. </li></ul><br>  O nome da estrutura deixa claro que a Apple queria ser usada em jogos.  Mas <strong>em aplicativos que não sejam de jogos,</strong> será útil. <br><br><img src="https://habrastorage.org/webt/pz/ez/de/pzezdem8jc81mab3alsm3e8pqwo.png"><br><br>  A classe <strong>GKState</strong> define estado.  Para descrevê-lo, você precisa executar etapas simples.  Herdamos dessa classe, definimos o nome do estado e definimos três métodos. <br><br><ul><li>  isValidNextState - se o estado atual é válido com base no anterior. </li><li>  didEnterFrom - ações na transição para esse estado. </li><li>  willExitTo - ações ao sair desse estado. </li></ul><br><br><img src="https://habrastorage.org/webt/z2/q2/gj/z2q2gj0bg2-vsoejvz0crdbhmb4.png"><br><br>  <strong>GKStateMachine é</strong> uma classe de máquina de estado.  É ainda mais fácil.  É o suficiente para executar duas ações. <br><br><ul><li>  Passamos o conjunto de estados de entrada para o array digitado através do inicializador. </li><li>  Fazemos transições dependendo dos sinais de entrada usando o método enter.  Por meio dele, o estado inicial também é definido. </li></ul><br>  Pode ser confuso que qualquer classe seja passada como argumento para o método <strong>enter</strong> .  Mas deve-se notar que um objeto de qualquer classe não pode ser definido em uma matriz de estados <strong>-</strong> isso proíbe a digitação estrita.  Portanto, se você definir uma classe arbitrária como a próxima classe de estado, nada acontecerá e o método enter retornará false. <br><br><h3>  Estados e transições entre eles <br></h3><br>  Tendo se familiarizado com a estrutura da Apple, voltemos ao exemplo.  É necessário descrever os estados e transições entre eles.  Você precisa fazer isso da maneira mais compreensível.  Existem duas opções comuns: uma tabela ou como um gráfico de transição.  O gráfico de transição, na minha opinião, é uma opção mais compreensível.  Está na UML de maneira padronizada.  Portanto, nós escolhemos. <br><br>  No gráfico de transição, existem estados descritos por nomes e setas que conectam esses estados para descrever transições.  No exemplo, existe um estado inicial <strong>-</strong> estamos esperando dados <strong>-</strong> e há três estados que podem ser alcançados desde o inicial: dados recebidos, nenhum dado e erro. <br><br><img src="https://habrastorage.org/webt/cg/dn/gs/cgdngsj7omvfgbfvkpdgtazpeva.jpeg"><br><br>  Na implementação, temos quatro classes pequenas. <br><br><img src="https://habrastorage.org/webt/qo/tc/rq/qotcrq6wbihios-sonhj8ajfhey.png"><br><br>  Vamos analisar o estado "Dados pendentes".  Na entrada, vale a pena exibir o indicador de download.  E quando você sair desse estado <strong>,</strong> oculte-o.  Para fazer isso, você precisa ter um link fraco para o ViewController, que é controlado pela máquina de estado criada. <br><br><img src="https://habrastorage.org/webt/p8/41/aa/p841aapjpxsvcqirsklkcy9o4us.png"><br><br><h3>  Parâmetros da máquina <br></h3><br>  O segundo passo que precisa ser feito <strong>é</strong> definir os parâmetros da máquina de estado.  Para fazer isso, crie estados e transfira-os para o objeto de autômato. <br><br><img src="https://habrastorage.org/webt/zd/ww/pm/zdwwpm8i_i6lxoxjkzh_a2deqzi.jpeg"><br><br>  Também não se esqueça de definir o estado inicial <br><br><img src="https://habrastorage.org/webt/mx/sg/ka/mxsgkacbkni4fjczcvsagtec8lm.png"><br><br>  Em princípio, tudo, a máquina está pronta.  Agora é necessário processar reações a eventos externos, alterando o estado do autômato. <br><br><img src="https://habrastorage.org/webt/_c/jt/hf/_cjthf0r7-5d5u0fdxucgksdz2w.png"><br><br>  Lembre-se da declaração do problema.  Temos uma escada do if-else, com base na qual foi decidido que ação deve ser executada.  Como controle de um autômato simples, essa opção de implementação pode ser (de fato, uma opção simples <strong>-</strong> essa é uma implementação primitiva de uma máquina de estados finitos), mas praticamente não nos livramos das desvantagens mencionadas anteriormente. <br><br>  Existe outra abordagem que permitirá que você se afaste dessas escadas.  É proposto pelos clássicos da programação <strong>- a</strong> chamada "quadrilha dos quatro". <br><br><img src="https://habrastorage.org/webt/qv/if/sf/qvifsfqe0iqs3rsroauy4bptayg.jpeg"><br><br>  Existe um padrão de design especial, chamado "Status". <br><br><img src="https://habrastorage.org/webt/nd/eh/wp/ndehwptccwh7lh90dmsixkzybo0.jpeg"><br><br>  Esse é um padrão comportamental semelhante a uma estratégia que descreve uma abstração de máquina de estado.  Permite que o objeto altere seu comportamento, dependendo do estado.  O principal objetivo do aplicativo <strong>é</strong> encapsular o comportamento e os dados associados a um estado específico em uma classe separada.  Assim, a máquina de estado, que inicialmente tomou a decisão de qual estado causar, agora transmitirá um sinal, o converterá em um estado, e o estado tomará uma decisão.  Então, descarregue parcialmente a escada e o código se tornará mais agradável de usar. <br><br>  A estrutura padrão não sabe como.  Ele sugere que a <strong>GKStateMachine</strong> tome a decisão.  Portanto, expandimos a máquina de estados finitos com um novo método, onde, como configuração, passamos a descrição de todas as variáveis ​​condicionais que determinam exclusivamente o próximo estado.  Dentro deste método, você pode delegar a seleção do próximo estado para o atual. <br><br><img src="https://habrastorage.org/webt/gu/sw/nr/guswnro2dw8m3fsctqqjx8_7js8.png"><br><br>  É uma boa prática descrever o estado com um objeto e sempre transmiti-lo, em vez de escrever muitos parâmetros de entrada.  Em seguida, delegamos a escolha do próximo estado para o atual.  Essa é a atualização completa. <br><br><img src="https://habrastorage.org/webt/te/9t/5a/te9t5acirqz1o5awpxzy1tsbyia.png"><br><br>  <strong>Vantagens do GameplayKit.</strong> <br><br><ul><li>  Biblioteca padrão.  Não há necessidade de baixar nada, use cocoapods ou cartago. </li><li>  A biblioteca é bastante fácil de aprender. </li><li>  Existem duas implementações ao mesmo tempo: no Objective-C e no Swift. </li></ul><br>  <strong>Desvantagens:</strong> <br><br><ul><li>  Realizações de estados e transições estão intimamente relacionadas. <br>  O princípio da responsabilidade exclusiva é violado: o Estado sabe para onde vai e como. </li><li>  Estados duplicados não são controlados de forma alguma. <br>  Uma matriz é passada para a máquina de estados, não muitos estados.  Se você transferir vários estados idênticos, o último da lista será usado. </li></ul><br>  O que mais são as implementações de máquinas de estados finitos?  Dê uma olhada no GitHub. <br><br><h2>  Implementações de Objective-C <br></h2><br><img src="https://habrastorage.org/webt/vo/zt/zy/voztzyatty-amllrmtl8ny4ke3c.png"><br><br><h3>  TransitionKit <br></h3><br>  Essa é a biblioteca Objective-C mais popular por um longo tempo, sem deficiências identificadas no GamePlayKit.  Ele nos permite implementar uma máquina de estado e todas as ações associadas a ela em blocos. <br><br>  <strong>O estado é separado das transições</strong> . <br><br>  No TransitionKit, existem 2 classes. <br><br><ol><li>  TKState - para definir estados e ações de entrada e saída. </li><li>  TKEvent é uma classe para descrever a transição. <br>  O TKEvent liga alguns estados a outros.  O evento em si é definido simplesmente por uma string. </li></ol><br>  Além disso, há benefícios adicionais. <br><br>  <strong>Você pode transferir dados úteis durante a transição</strong> .  Isso funciona da mesma maneira que ao usar o NSNotificationCenter.  Toda carga útil vem na forma de um dicionário userInfo e o usuário analisa as informações. <br><br>  <strong>A transição errônea tem uma descrição</strong> .  Quando tentamos fazer uma transição inexistente - impossível - obtemos não apenas o valor NO ao retornar do método de transição, mas também uma descrição detalhada do erro, que é útil ao depurar uma máquina de estado. <br><br><img src="https://habrastorage.org/webt/hi/x9/bx/hix9bx5ctgjldoay4btqajopgb0.jpeg"><br><br>  O TransitionKit é usado no popular harvester da rede RestKit.  Este é um bom exemplo de como uma máquina de estado pode ser usada no kernel do aplicativo ao implementar operações de rede. <br><br><img src="https://habrastorage.org/webt/ls/os/d3/lsosd3z1zbg5knnmbrggmpq2zro.jpeg"><br><br>  O RestKit possui uma classe especial - RKOperationStateMachine - para gerenciar operações simultâneas.  Na entrada, ele aceita a operação que está sendo processada e a fila para sua execução. <br><br><img src="https://habrastorage.org/webt/r2/pn/mc/r2pnmcfsl_6uzdzhsin_mrq_vkg.jpeg"><br><br>  Internamente, a máquina de estados é muito simples: três estados (pronto, executado, concluído) e duas transições: execução inicial e final.  Após o início do processamento (e em qualquer transição), a máquina de estado começa a controlar um bloco de código definido pelo usuário na fila especificada ao criar a fila. <br><br>  Uma operação associada ao seu autômato transfere eventos externos para o autômato e realiza transições entre estados e todas as ações relacionadas.  Máquina de estado cuida de <br><br><ul><li>  execução de código assíncrono, </li><li>  execução de código atômico durante transições, </li><li>  controle de transição </li><li>  Cancelamento de operações </li><li>  a correção das variáveis ​​de estado da mudança de operação: isReady, isExecuting, isFinished. </li></ul><br><h3>  Mudança <br></h3><br>  Além do TransitionKit, vale mencionar separadamente <strong>Shift</strong> - uma pequena biblioteca implementada como uma categoria no NSObject.  Essa abordagem permite transformar qualquer objeto em uma máquina de estado, descrevendo seu estado na forma de constantes de string e ações em blocos durante transições.  Obviamente, este é mais um projeto de treinamento, mas bastante interessante e permite que você experimente o que é uma máquina de estado a um custo mínimo. <br><br><h2>  Implementações rápidas <br></h2><br><img src="https://habrastorage.org/webt/_t/dx/kd/_tdxkdwt0sqzgy78o-q-_z0c_nq.png"><br><br>  Existem muitas implementações de máquinas de estados finitos no Swift.  Vou destacar um ( <strong>observação</strong> : infelizmente, o projeto não está sendo desenvolvido nos últimos dois anos após o relatório, mas vale a pena contar as idéias nele contidas no artigo). <br><br><h3>  SwiftyStateMachine <br></h3><br>  No SwiftyStateMachine, a máquina de estado é representada por uma estrutura não estável; por meio dos métodos didSet da propriedade, você pode capturar facilmente as alterações de estado. <br><br>  Nesta biblioteca, a máquina de estados é definida através da tabela de correspondência de estados e transições entre eles.  Este esquema é descrito separadamente do objeto que a máquina controlará.  Isso é implementado através de uma caixa de opções aninhada. <br><br><img src="https://habrastorage.org/webt/y5/cz/dl/y5czdlkikmxb4kyylgwgxfsdxuy.png"><br><br>  ,    . <br><br><ul><li>       . <br>       ,        . </li><li>    . <br>    state machine ,         state machine. </li><li>    ,   ,      . </li><li> ,     DOT. <br>        state- — DOT.    ,  ,     . </li></ul><br><img src="https://habrastorage.org/webt/wb/zg/du/wbzgduy9duy-shpt0pcjjjt0ru8.jpeg"><br><br><h2>  Conclusão <br></h2><br>          . <br><br><ul><li> <strong>.</strong> <br>           ,     .    ,         . ,   . <br></li><li> <strong>  .</strong> <br>     ( ). <br></li><li> <strong> .</strong> <br>       ,    ,        . </li><li> <strong>       .</strong> , SwiftyStateMachine     ,    ,     .     . </li><li> <strong> .</strong> <br>   ,    . , ,      .       . <br></li></ul><br>        . <br><br><img src="https://habrastorage.org/webt/wb/ek/ww/wbekwwlr0a_w8wzt6z0bo12jdmm.jpeg"><br><br>       .      ,    .    , ,    switch case:  ,  ,  —     . <br><br><img src="https://habrastorage.org/webt/hq/ay/db/hqaydbygw58xgcalwyvph1haeho.jpeg"><br><br>  .    .    ,  .  ,    ,  ,     .    . <br><br><img src="https://habrastorage.org/webt/b9/mb/ze/b9mbze-xdkufz2mbs7p61obsjqo.jpeg"><br><br>      ,      ,      .     . <br><br><img src="https://habrastorage.org/webt/bc/qp/hr/bcqphramltmjhaakirn_uo00e4i.png"><br><br>    —  <strong> </strong> .       :      , —    . <br><br><img src="https://habrastorage.org/webt/iw/qz/we/iwqzwefnjh4xnqexwoovxccugqo.jpeg"><br><br><img src="https://habrastorage.org/webt/i4/80/vk/i480vkfuwmhwpdd31totlvl5298.jpeg"><br><br>   «-»     <strong> </strong> . <br><br><img src="https://habrastorage.org/webt/s-/kf/ox/s-kfoxsckujhbrzsslebpzuqwei.jpeg"><br><br> ,    .         . <br><br><img src="https://habrastorage.org/webt/le/oo/ju/leoojuz3yycfncczpfbgftsa1tq.jpeg"><br><br>        <strong>app coordinators</strong> —   ,     ,    : ,     .       ,       . <br><br>  , app coordinator ,  state machine.            . ,    app coordinators  state machine,         , ,  , <strong>  </strong> .      , ,   ,         .    . <br><br><img src="https://habrastorage.org/webt/mx/yu/1q/mxyu1qczcjazzunuhe7jfoolv2e.png"><br><br> , state machine  ,    ,         . <br><br>     state machine  ,     if-else.   ,         . <br><br><blockquote>     Apps Conf 2018,   8  9 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>    -     . <br><br>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YouTube-</a> .           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423293/">https://habr.com/ru/post/pt423293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423279/index.html">Como desenvolvi o tablet russo</a></li>
<li><a href="../pt423281/index.html">Feedback na equipe, 360 e 14 de fevereiro</a></li>
<li><a href="../pt423283/index.html">Modelando o efeito Sagnac usando óptica geométrica</a></li>
<li><a href="../pt423285/index.html">Engenharia social: o inimigo ilusório no mundo da segurança cibernética</a></li>
<li><a href="../pt423291/index.html">Russos estabelecem um recorde: 110 filmes piratas por pessoa</a></li>
<li><a href="../pt423295/index.html">Conferência de Desenvolvimento Móvel Mais Útil</a></li>
<li><a href="../pt423297/index.html">Do desenvolvedor Android ao DevOps</a></li>
<li><a href="../pt423299/index.html">Coordenador de aplicativos em aplicativos iOS</a></li>
<li><a href="../pt423303/index.html">AI, curso prático. Transformação da Música Baseada na Emoção</a></li>
<li><a href="../pt423305/index.html">Arruinar o desempenho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>