<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇 🕺🏿 💃🏻 ¿No necesitas registros? 📪 ⚜️ 🚵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El desarrollo ha cambiado mucho en los últimos años. En lugar de aplicaciones monolíticas, llegaron microservicios y funciones. Las bases de datos de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿No necesitas registros?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/468535/">  El desarrollo ha cambiado mucho en los últimos años.  En lugar de aplicaciones monolíticas, llegaron microservicios y funciones.  Las bases de datos de monstruos industriales universales se han degenerado en objetivos específicos.  Docker cambió de opinión sobre el despliegue.  Pero, ¿ha cambiado nuestra idea de los registros? <br><br>  Uno de los grandes problemas en Yandex.Verticals fueron los registros: 18 TB por día y 250,000 registros por segundo, todo está escrito en archivos.  Los registros son heterogéneos porque hay muchos idiomas: Scala, Java, Python, Go.  Luego los recoge Fluent Bit, escribe en Kafka, los manipuladores trabajan en una máquina de hierro, ensamblan desde Kafka y escriben todo en el disco.  Además, esta es la segunda versión de los registros. <br><br><img src="https://habrastorage.org/webt/4i/z8/ws/4iz8wst0a72z7ytipvzx77wnxiq.jpeg"><br><br>  Como resultado, surge un largo problema de búsqueda.  Estos registros se buscan utilizando grep.  En algunos servicios, grep puede alcanzar horas.  Si tiene problemas en la producción, no estará buscando sus registros durante horas.  Para resolver el problema, Yandex decidió escribir su propia bicicleta de entrega de registros para la búsqueda.  Lo que surgió de esto, le dirá a <b>Alexei Danilov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">danevge</a> ), el desarrollador del equipo de infraestructura en Yandex.  Desarrolla, escribe y respalda proyectos de auto.ru y Yandex.Real Estate. <br><br>  <i>Descargo de responsabilidad.</i>  <i>El artículo habla sobre el desarrollo moderno y es adecuado para la arquitectura de microservicios.</i>  <i>Aquí se presentan varios productos: estas son herramientas que se utilizan en Yandex.Verticals.</i>  <i>En otras condiciones, los análogos son posibles con mayor éxito, pero realizan casi las mismas funciones.</i> <a name="habracut"></a><br><blockquote>  Nota  El artículo es una versión extendida del informe de Alexey Danilov "No se necesitan registros" en RIT ++ 2019 DevOps Conf, que se modifica estilísticamente y se complementa con material nuevo.  Puede encontrar la grabación de video del discurso de Alexey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el enlace</a> de nuestro canal de YouTube. </blockquote><br>  El equipo de Yandex.Vertical tiene 300 personas, de las cuales aproximadamente 100 son desarrolladores.  En desarrollo, no somos diferentes de la mayoría de las empresas que crean sus propias soluciones de productos.  Microservicios, todos viven en Docker, un monolito en PHP está acumulando polvo en un rincón oscuro, implementado a través de Hashicorp Nomad y mantenemos un zoológico de idiomas: Scala, Java, Go, Node.js, Python. <br><br>  Uno de los grandes problemas de infraestructura en Yandex.Verticals son los registros de aplicaciones.  Cuando abordamos seriamente este problema, utilizamos la tercera versión de su recopilación y procesamiento.  Simplificado, funcionó así: <br><br><ul><li>  las aplicaciones escribieron en archivos; <br></li><li>  Bit fluido leyó los archivos y los envió línea por línea a Kafka filebeat; <br></li><li>  En una máquina de hierro dedicada había una aplicación que leía el tema de Kafka y escribía en los archivos del disco. <br></li></ul><br>  En la temporada de calor, tuvimos 18 TB de registros por día, o 250,000 líneas por segundo.  Esta es una cantidad muy grande, lo que complica el trabajo con estos datos.  La única forma de analizar esto es grep, ya que todo se almacena en archivos.  Para aplicaciones grandes, el análisis puede llevar horas.  Para problemas en la producción, no tienes este tiempo. <br><br>  Las soluciones preparadas no encajaban en precio, recursos o velocidad.  No podían manejar aceptablemente nuestro flujo.  Incluso es difícil contar la cantidad de intentos de cocinar Elasticsearch.  Supongo que no sabemos cómo cocinarlo.  Pero esto no es lo que necesitamos, si para usarlo como un depósito de registros, se requieren habilidades especiales (habilidades). <br><br>  En esta situación, decidimos implementar nuestro propio sistema para recopilar y analizar registros. <br><br><h2>  Bicicleta </h2><br><img src="https://habrastorage.org/webt/aw/49/s9/aw49s9cfjgf28z2eqyofr3cx7ea.jpeg"><br><br>  <i>Nota: Si la próxima bicicleta no es interesante, proceda inmediatamente a la sección "Tipificación".</i> <br><br><h3>  Formato </h3><br>  Usamos varios PL y amamos los microservicios.  Para trabajar con los registros, formamos uniformemente nuestro propio formato JSON.  Cubre la mayoría de las necesidades de trabajo adicional con registros. <br><br><img src="https://habrastorage.org/webt/z8/8q/g5/z88qg5gh3s5ntz9n91q5opbk0ku.png"><br>  <i>Un ejemplo de registros con todos los campos posibles.</i> <br><br><h2>  Controlador de registro de Docker </h2><br>  Para recopilar los registros, escribimos nuestro propio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">controlador de registro de Docker</a> , una aplicación en Go.  Se ensambla de una manera especial, entregada por los comandos del complemento Docker, almacenada en el registro y se ejecuta en una sola instancia con Docker. <br><br>  Dado que cualquier problema con el controlador de registro puede afectar negativamente todo el trabajo, intentamos escribir una implementación mínima.  Nuestro controlador escucha la salida estándar del contenedor e inmediatamente pasa los registros a la aplicación que está cerca.  Ya se ocupa de la parte más compleja de la entrega. <br><br><h3>  Los problemas </h3><br>  Mencionaré por separado los problemas de actualización de la versión del controlador de registro de Docker. <br><br><img src="https://habrastorage.org/webt/a6/sy/md/a6symdnuvy0z5kekvjv924yth-i.png"><br>  <i>Captura de pantalla de la Grafana interna.</i> <br><br>  A la izquierda está la relación de versiones instaladas a máquinas.  Ahora se instalan tres versiones en todo el hardware: no se pierden automóviles en ningún lugar y no hay instalaciones innecesarias.  A la derecha está el número de contenedores que usan esta o aquella versión. <br><br>  El controlador de Docker no puede ir y actualizarse de inmediato.  Para hacer esto, tendría que reiniciar todos los contenedores y todos los servicios, lo que podría ocasionar problemas.  Por lo tanto, para instalar la nueva versión, solo esperamos que todos los contenedores se actualicen. <br><br><h2>  Esquema general </h2><br>  Considere el esquema general de un nuevo sistema para recopilar y entregar registros.  Otros detalles no son tan interesantes. <br><br><img src="https://habrastorage.org/webt/nm/lx/pq/nmlxpqlg41ntzuar5imu8pw3-km.jpeg"><br><br>  Las aplicaciones escriben registros en formato JSON en stdout.  Docker escucha la canalización desde el contenedor y la redirige al controlador Docker.  El controlador Docker lee y vuelve a fundir asincrónicamente todo en Pusher. <br><br>  Pusher se encuentra en cada carro de hierro.  Prepara, satura, voltea e inserta registros en Yandex Message Queue.  La secuencia de registro de MQ es analizada por tres tipos de trabajadores y escrita en los repositorios. <br><br>  Hay tres repositorios para grabar registros. <br><br><ul><li>  <b>Yandex mapReduce</b> para almacenar y analizar registros durante un largo período de tiempo.  Este es un análogo de Hadoop. <br></li><li>  <b>ClickHouse</b> para almacenar registros durante el último día. <br></li><li>  <b>Humio</b> (como experimento) para almacenar registros para el último día. <br></li></ul><br><h3>  Ganancia </h3><br>  El formato general le permite escribir y procesar registros de la misma manera.  La recopilación de registros es automática, sin usar un disco, y la entrega se realiza en unos segundos.  Búsquedas clave de 2 segundos a 5 segundos.  Almacenamiento y recuperación durante un largo período de tiempo. <br><br>  Para volúmenes más pequeños, considere alternativas: Humio, Splunk y Elastic.  Los dos últimos tienen controladores Docker oficiales.  Si vives en AWS, ese es Amazon CloudWatch. <br><br><h3>  Amazon Cloudwatch </h3><br>  Amazon CloudWatch maneja métricas, eventos y registros.  No busca lo último, no proporciona elementos de súper búsqueda y no los procesa de la forma habitual.  Amazon CloudWatch procesa registros, análisis, filtros y pantallas en gráficos. <br><br><img src="https://habrastorage.org/webt/xc/le/o2/xcleo2if8o1ezw7hob29olfzcta.png"><br>  <i>Amazon CloudWatch convierte registros en métricas y gráficos.</i> <br><br><h2>  ¿Qué hacer con los registros? </h2><br>  De vuelta a nuestra bicicleta, ¿satisface todos los casos?  No, nuestra solución le permite encontrar los registros, pero requieren mucha mayor heterogeneidad de información y sus tipos.  Los registros se utilizan en muchos más casos. <br><br>  Tan pronto como recopile los registros, la siguiente oración será: "Analicemos algo, procesémoslo de alguna manera, escríbalo en alguna parte y comencemos a mostrarlo en gráficos, en tableros".  Este es el camino al infierno.  Especialmente si estamos hablando de herramientas comunes. <br><br><blockquote>  Si imagina los registros como un cierto caos o registro de eventos de cualquier dato, entonces no funcionarán. </blockquote><br>  Esto será un gran desorden de información que no se puede procesar.  Un juego comenzará en la formalización de los registros: "¡Escribamos estas líneas en un formato especial para que sea conveniente analizarlas más tarde!"  Eso tampoco funciona.  Créanos, lo intentamos. <br><br><h2>  Escribiendo </h2><br>  Si divide los registros en tipos y los procesa por separado, puede encontrar herramientas que facilitarán el trabajo con ellos.  Trabajando no más como con los registros, sino como con datos útiles, este trabajo es más transparente y conveniente.  Algunos tipos de registros se pueden tirar por completo. <br><br><h3>  Por si acaso </h3><br>  Este tipo de registros "to be" es mi favorito.  Si es imposible responder claramente por qué se necesita esta o aquella línea, entonces lo son.  Este tipo también se puede llamar "registros por si acaso". <br><br><pre><code class="plaintext hljs">// validate customer func Validate(customer Customer) { // ??? log.debug(“Validate customer %v”, customer) … log.Error(“Customer not valid %v. Reason: %s”, ...) …. }</code> </pre> <br><blockquote>  Los registros no son comentarios que se puedan eliminar.  Esto es parte del código que es más difícil de modificar, mantener y aún más eliminar. </blockquote><br>  En el mejor de los casos, dicho registro puede convertirse en una depuración o rastreo.  Este tipo <b>abarrota el código</b> .  Debido al registro precipitado, puedo ingresar datos personales, contraseñas y cookies de los usuarios. <br><br>  La forma correcta es <b>tirarlos y olvidarlos</b> .  Pero luego nos enfrentamos a un nuevo problema.  ¿Cómo analizar la situación con un error? <br><br><h3>  Error fatal / crítico </h3><br>  Para empezar, consideramos solo los errores críticos.  Estos son errores que sufren los usuarios y desarrolladores.  El primero: cuando no pueden completar la operación.  El segundo: cuando necesita hacer correcciones a mano. <br><br>  ¿Por qué los registros no encajan? <br><br>  <b>No hay respuesta rápida</b> .  Si el equipo de desarrollo se entera del error de los usuarios a través del soporte o de Twitter, entonces es hora de cambiar algo. <br><br>  <b>No hay contexto</b>  Una línea separada del registro de errores es inútil.  Tenemos que recopilar el contexto poco a poco.  Aun así, puede que no sea suficiente, ya que este es el contexto del proceso, no el error. <br><br>  <b>No hay una gran imagen</b> .  No hay respuesta a las preguntas: <br><br><ul><li>  con qué frecuencia ocurre tal error; <br></li><li>  ocurrió en las réplicas restantes del servicio; <br></li><li>  fue antes? <br></li></ul><br>  Para solucionar estos problemas, use una herramienta adecuada, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sentry.io</a> .  Le permite trabajar con información de error representativa, completa (contextual) con una <code>alerting rule</code> personalizable.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El sitio web de centinela</a> describe las diferencias en los registros del uso de sentry.io. <br><br><h3>  Error no crítico </h3><br>  Lanzamos errores fatales y críticos y ahora están escritos en Sentry.  Pero hubo errores internos: varias bibliotecas o respuestas de servicios de terceros. <br><br>  Un buen ejemplo es un reintento exitoso.  Supongamos que el servicio A recurrió al servicio B pero, debido a problemas de red, no pudo obtener una respuesta.  Después del error, el servicio A volvió al servicio B y recibió una respuesta válida.  ¿Es crítico el error en la primera llamada?  No  En este caso, el proceso se completó con éxito y el usuario pudo usar el servicio. <br><br>  Si tales errores no son críticos para que el servicio funcione y no afectan al usuario con una repetición rara, entonces estos no son errores en absoluto.  Esto es una degradación del servicio, aunque la respuesta al usuario llegó 50 ms después.  Este tipo de registro se refiere a advertencias - Advertencia. <br><br><h3>  Advertencia </h3><br><blockquote>  Las alertas son información sobre la degradación de un servicio. </blockquote><br>  Aquí veremos los mismos problemas inherentes a los errores críticos, pero con una reserva.  La reacción a un evento individual no es importante: su cantidad a lo largo del tiempo es importante. <br><br>  Considere un ejemplo en el que un servicio no puede recuperar una entrada de caché y accede al almacenamiento en frío.  Si esto sucede una vez por minuto, esto puede tomarse para el funcionamiento normal del servicio.  <b>Las emisiones raras no son importantes</b> . <br><br>  Pero al mismo tiempo, necesita tener una herramienta para ver el panorama general, necesita <b>un análisis en tiempo real</b> .  Para realizar un seguimiento de los cambios durante un largo período de tiempo, sería bueno tener también un <b>análisis retrospectivo</b> .  La degradación por encima de un cierto nivel (umbrales) puede afectar negativamente a los usuarios: necesita una <b>reacción con degradación severa</b> . <br><br><blockquote>  No necesitamos los registros marcados como Advertencia, sino las métricas de degradación. </blockquote><br>  La herramienta de recopilación de métricas más popular es Prometheus, y puede usar Grafana para la visualización.  Si necesita un contexto grande (igual que el error), entonces el mismo Centinela funcionará, pero con las alertas desactivadas.  Sin embargo, en la mayoría de los casos habrá suficiente contexto.  Se usará para gráficos: etiquetas de Prometheus. <br><br>  Ejemplos. <br><div class="scrollable-table"><table><tbody><tr><td>  etiqueta <br></td><td>  ejemplo 1 <br></td><td>  ejemplo 2 <br></td><td>  ejemplo 3 <br></td></tr><tr><td>  contexto <br></td><td>  db <br></td><td>  servicio_interno <br></td><td>  caché <br></td></tr><tr><td>  módulo <br></td><td>  servicio_usuario <br></td><td>  servicio_usuario <br></td><td>  servicio_usuario <br></td></tr><tr><td>  razon <br></td><td>  consulta larga <br></td><td>  reintentar <br></td><td>  miss_cache <br></td></tr><tr><td>  otro <br></td><td>  get_user <br></td><td>  servicio_b <br></td><td>  user_permisson <br></td></tr></tbody></table></div><br>  Se produjeron tres eventos en el servicio de <code>user_service</code> condicional.  Afectan el funcionamiento del servicio: una solicitud larga a la base de datos, acceso repetido a la API del servicio <code>service_b</code> y no se encontraron derechos de usuario en la memoria caché.  Los gráficos y alertas se configurarán como importantes para los desarrolladores del servicio, gracias al contexto. <br><br><h3>  Rastreo </h3><br>  Esto es lo primero para comenzar si elegimos la ruta donde necesita analizar los registros.  Por sí misma, esta información en los registros es inútil, porque necesita construir cadenas de llamadas, ver datos dentro de las solicitudes, errores en las cadenas de llamadas, tiempos de respuesta, el número de RPS. <br><br>  Existen excelentes herramientas para el rastreo: Jaeger o Zipkin.  Recomiendo usar OpenTracing, que ambos admiten. <br><br>  Puede recopilar el seguimiento de tres fuentes. <br><br><ul><li>  Si usa <b>equilibradores</b> compartidos, analice los registros de ellos y envíelos a Jaeger. <br></li><li>  <b>Los servicios mismos</b> , si reciben direcciones a través de Service Discovery y van directamente.  En este caso, el seguimiento de los servicios se envía directamente a Jaeger. <br></li><li>  <b>Servicio</b> inteligente de <b>malla</b> .  Él sabe cómo recopilar y enviar un rastro, por ejemplo, Istio. <br></li></ul><br><br><h3>  Información inicial </h3><br>  Esta información es sobre llamadas de servicio API, lanzamiento de Cron, consultas de bases de datos o llamadas a otros servicios. <br><br><pre> <code class="plaintext hljs">{ "_message": "Request: ...; request_id: ...,... ", "_level": "INFO", "_time": "2019-03-08T12:04:05.000+07:00", "_context": "ryawvcHandler", "_tread": "785534" }</code> </pre> <br>  Esta información pertenece al bloque "Por si acaso", pero está separada porque es más común.  Esta información es necesaria para analizar el error y <b>puede descartarla</b> . <br><br>  Si la información sobre las llamadas a métodos internos es de importancia crítica y no puede prescindir de ella, incluso con el contexto recopilado en caso de error, entonces vale la pena instrumentar las llamadas de método como un rastro. <br><br><h3>  Tiempo de ejecución </h3><br>  Esta información es sobre el tiempo de ejecución de métodos, API, consultas de bases de datos u otros servicios. <br><br><pre> <code class="plaintext hljs">{ "_message": "Get customer 12ms", "_level": "INFO", "_time": "2019-03-08T12:04:05.000+07:00", "_context": "ryawvcCustomerRepository", "_tread": "785534" }</code> </pre> <br>  No hay ningún valor en los registros, porque necesita analizar esta información, mostrarla en gráficos y configurar umbrales.  Este tipo de registros debe reemplazarse con <b>métricas</b> , por ejemplo, en Prometheus. <br><br><h3>  Información del negocio </h3><br>  Esta información es necesaria para análisis de negocios, análisis de comportamiento del cliente, cálculos financieros.  En este lugar, históricamente utilizamos el enfoque opuesto: los registros analizados.  Pero este es un buen ejemplo de lo que los registros de la aplicación pueden degenerar si trabaja con ellos de esta manera. <br><br>  Para los registros con datos comerciales, se formaron acuerdos con campos fijos en formato TSKV, que son necesarios para el análisis.  Las aplicaciones escribieron registros de negocios en un archivo dedicado.  Luego, los registros se leyeron y se enviaron línea por línea a MQ, y una aplicación separada los procesó y los escribió en la base de datos.  Este es un ejemplo de en lo que se convierte cualquier análisis. <br><br><blockquote>  No funcionará analizar todo el flujo de registros con la esperanza de que los datos converjan. </blockquote><br>  Están surgiendo convenciones, formatos, reglas y requisitos de confiabilidad.  Esto ya se parece un poco a los registros de la aplicación.  En este caso, el registro se convierte en la cola de entrega de datos con todos los requisitos resultantes para MQ.  Es notable que el middleware en forma de registro es superfluo aquí. <br><br>  Una buena solución es enviar estos datos directamente a MQ.  Ya allí serán procesados, almacenados en el almacenamiento apropiado y utilizados por el equipo de análisis.  Por ejemplo, para la visualización usamos Tableau. <br><br><h3>  Rendimiento </h3><br>  Este tipo de registro rara vez se encuentra en los registros de aplicaciones y se recopila con mayor frecuencia como una métrica.  Por separado, agrego que para recopilar las métricas básicas que son específicas del idioma, es suficiente usar la biblioteca Prometheus.  Por defecto, recogerá todo lo que alcance.  El costo de agregar estas métricas es pequeño. <br><br><img src="https://habrastorage.org/webt/iz/od/jv/izodjvufyysy4-3ihlurtw9rueq.png"><br><br><h3>  Resultado de escritura </h3><br>  Después de ordenar los registros por tipo, podemos elegir herramientas más potentes para trabajar con ellos.  No hay sistemas complejos o tecnologías espaciales como Amazon, no hay nada que no pueda plantearse mañana.  Probablemente ya tenga algunos de estos sistemas o análogos: Sentry está acumulando polvo en alguna parte, Prometheus está trabajando en alguna parte. <br><br><img src="https://habrastorage.org/webt/69/jj/ik/69jjikx9uuyrghuq-1rpw0bu5o0.png"><br><br><blockquote>  El problema no está en la tecnología, sino en una trampa cognitiva cuando confiamos en los registros como un medio de representación confiable del estado de nuestro sistema.  Esto no es así, los registros son un conjunto de eventos caóticos. </blockquote><br>  Hay una excepción: los registros de depuración, que se pueden usar en casos excepcionales. <br><br><h3>  Registro de depuración </h3><br>  Los registros de depuración deben ser información detallada.  No deben duplicar lo que ya se está enviando a los sistemas que describimos anteriormente.  Este tipo existe para analizar casos especiales.  Por ejemplo, se produce un error incomprensible en la producción, y en este momento no está claro por métricas lo que está sucediendo. <br><br>  <b>Active los registros de depuración en caliente, sin reiniciar el servicio</b> .  Como estamos hablando de varios servicios, no habrá muchos de ellos.  No se necesita infraestructura sofisticada.  Suficiente pila de ELK sin complicada "preparación".  También tiene sentido agregar una alerta a Sentry con todo el contexto necesario. <br><br>  <b>Los registros de depuración se pueden usar para el desarrollo</b> .  Pero se reemplazan perfectamente por depuración. <br><br><h2>  Para resumir </h2><br>  <b>Escribimos nuestra entrega de registro de bicicleta para la búsqueda</b> .  No satisfacemos a los clientes del servicio; todos vienen a analizarlos, recopilarlos y agregarlos en algún lugar.  Esto se puede evitar: no se necesitan sistemas complejos de procesamiento de registros. <br><br><blockquote>  Los registros sin procesar son inútiles, pero pueden convertirse en métricas útiles. </blockquote><br>  Es suficiente crear una infraestructura para entregar métricas y datos útiles sobre los servicios.  Como resultado, aparecerán métricas útiles que hablan sobre los servicios y muestran de manera transparente todo lo que les sucede. <br><br><blockquote>  Los errores deben contener el contexto del error mismo. </blockquote><br>  Esto ayudará a sobrellevarlo y a solucionarlo de inmediato.  <b>Los errores y la degradación deberían llevar a la acción</b> , de modo que los desarrolladores aprendan instantáneamente sobre los problemas y los solucionen incluso antes de que los usuarios enojados lo soliciten. <br><br>  <b>Las herramientas adecuadas harán que trabajar con sus servicios sea más agradable y transparente</b> .  La depuración tiene un lugar para estar, pero debes ser estricto con ella. <br><br><blockquote>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++ 2019</a> en noviembre habrá una sección de DevOps: 13 informes sobre cargas en AWS, un sistema de monitoreo en Lamoda, transportadores para entrega de modelos, vida sin Kubernetes y mucho más.  Consulte la lista completa de temas y resúmenes en la página separada " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informes</a> ".  Y nos reuniremos en DevOpsConf en la primavera: suscríbase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">al boletín informativo</a> y avísenos cuando determinemos las fechas y la ubicación. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468535/">https://habr.com/ru/post/468535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468525/index.html">Juguetes de madera, primera parte - 1982-1985</a></li>
<li><a href="../468527/index.html">Síntesis de un controlador por el método del problema de dinámica inversa</a></li>
<li><a href="../468529/index.html">Domar a Gorynych o descompilar eBPF en Ghidra</a></li>
<li><a href="../468531/index.html">El primer bot PHP para VKontakte</a></li>
<li><a href="../468533/index.html">Autostop en DevOps con Express 42</a></li>
<li><a href="../468537/index.html">Conceptos básicos de DevOps. Ingreso al proyecto desde cero</a></li>
<li><a href="../468541/index.html">¿Arrastrar y soltar componentes para usuarios ciegos? Estas bromeando</a></li>
<li><a href="../468543/index.html">Entre semana Comité del Programa FrontendConf. Entrevista con Sergey Popov</a></li>
<li><a href="../468547/index.html">Habla inglés, CSS, Grid y accesibilidad en FrontendConf</a></li>
<li><a href="../468549/index.html">GPU enlazado. Cómo transferir todo a la tarjeta de video y un poco más. Animaciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>