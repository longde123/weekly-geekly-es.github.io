<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏻 🙇🏿 😯 使用pytest进行Python测试。 第3章pytest固定装置 🙉 🌶️ 👨🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="返回 下一个 


 本书是每本全面的Python书籍中都缺少的章节。 


 弗兰克·鲁伊斯 
 Box，Inc.首席站点可靠性工程师 





 本书中的示例是使用Python 3.6和pytest 3.2编写的。 pytest 3.2支持Python 2.6、2.7和Python 3.3+ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用pytest进行Python测试。 第3章pytest固定装置</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448786/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一个</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p> 本书是每本全面的Python书籍中都缺少的章节。 </p><br><p> 弗兰克·鲁伊斯 <br>  Box，Inc.首席站点可靠性工程师 </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p> 本书中的示例是使用Python 3.6和pytest 3.2编写的。  pytest 3.2支持Python 2.6、2.7和Python 3.3+ </p><br><blockquote>本书网页上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">链接</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com</a>上提供了Tasks项目以及本书中显示的所有测试的源代码。 您无需下载源代码即可了解测试代码。 示例中以方便的形式提供了测试代码。 但是，为了跟上项目的任务，或者改编测试示例来测试自己的项目（不费力气！），您必须转到本书的网页并下载工作。 在该书的网页上，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://pragprog.com/titles/bopytest/errata">勘误</a>信息链接和一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="https://forums.pragprog.com/forums/438">论坛</a> 。 </blockquote><p> 在剧透下方是该系列文章的列表。 </p><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>引言</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第1章：pytest入门</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第2章：编写测试函数</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第3章：Pytest固定装置</strong></a> （本文） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第4章：内置灯具</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第5章：插件</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第6章：配置</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>第7章：与其他工具一起使用pytest</strong></a> </li></ul></div></div><br><p> 既然您已经了解了pytest的基础知识，那么让我们将注意力转向固定装置，这些固定装置对于构建几乎所有非平凡的软件系统的测试代码都是必不可少的。 夹具是pytest在实际测试功能之前（有时是之后）执行的功能。 灯具代码可以执行您需要的任何操作。 您可以使用夹具来获取数据集进行测试。 您可以在运行测试之前使用Fixtures使系统处于已知状态。 夹具也用于获取多个测试的数据。 </p><br><p> 这是返回数字的简单夹具示例： </p><br><blockquote> <strong>ch3 / <code>test_fixtures.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest @pytest.fixture() def some_data(): """Return answer to ultimate question.""" return 42 def test_some_data(some_data): """Use fixture return value in a test.""" assert some_data == 42</code> </pre> <br><p>  <code>@pytest.fixture()</code>装饰器用于告诉pytest该函数是一个固定装置。 当您在测试功能的参数列表中包含灯具名称时，pytest会在运行测试之前知道如何运行它。 夹具可以完成这项工作，也可以将数据返回到测试功能。 </p><br><p>  <code>test_some_data()</code>测试将<code>test_some_data()</code>名称<code>some_data</code>作为参数。  pytest会检测到这一点并找到具有该名称的灯具。 该名称在pytest中有意义。  pytest将在测试模块中查找具有该名称的灯具。 如果他在<em>conftest.py</em>中找不到它，他还将搜索。 </p><br><p> 在开始研究夹具（和conftest.py文件）之前，我需要考虑以下事实：术语夹具在编程和测试社区，甚至在Python社区中都有许多含义。 我可以交替使用<code>fixture</code> ， <code>fixture function</code>和<code>fixture method</code>来引用本章中介绍的<code>@pytest.fixture()</code>函数。 夹具也可以用于指示夹具功能所引用的资源。 夹具功能通常会设置或检索测试可以使用的一些数据。 有时，这些数据被认为是夹具。 例如，Django社区经常使用固定装置来指示一些在应用程序开始时加载到数据库中的原始数据。 </p><br><p> 不管其他含义如何，在pytest和本书中，测试装置都是指pytest提供的机制，用于将“准备就绪”和“清理后”代码与测试功能分开。 </p><br><p>  pytest固定装置是使pytest超越其他测试环境的独特功能之一，也是许多受人尊敬的人转而选择…并坚持使用pytest的原因。 但是，pytest中的装置与Django中的装置不同，并且与unittest和鼻子中的设置和拆卸程序不同。 固定装置有许多功能和细微差别。 一旦有了关于它们如何工作的良好心理模型，您就会感觉好些。 但是，您需要与它们玩一会儿才能进入，所以让我们开始吧。 </p><br><h2 id="obmen-fixtures-cherez-conftestpy"> 通过conftest.py共享装置 </h2><br><p> 您可以将固定装置放在单独的测试文件中，但是要在多个测试文件中共享固定装置，最好在公共位置集中使用<em>conftest.py</em>文件，集中进行所有测试。 对于任务项目，所有固定装置都将位于<code>tasks_proj/tests/conftest.py</code> 。 </p><br><p> 从那里，任何面团都可以共享固定装置。 如果希望仅在此文件的测试中使用灯具，则可以将灯具放在单独的测试文件中。 同样，您可以在<em>顶部测试</em>目录的子目录中拥有其他<em>conftest.py</em>文件。 如果这样做，这些低级conftest.py文件中定义的固定装置将可用于此目录和子目录中的测试。 但是，到目前为止，Tasks项目中的装置都是针对任何测试而设计的。 因此，在测试根目录<em>conftest.py</em>文件中使用我们所有的工具<code>tasks_proj/tests</code>最有意义。 </p><br><p> 尽管conftest.py是Python模块，但不应由测试文件导入。 何时不输入conftest！  conftest.py文件由pytest读取，并被视为本地插件，当我们在第95页第5章“插件”中开始谈论插件时，该文件将变得很清楚。现在，将<code>tests/conftest.py</code>视为放置灯具的地方测试目录中的所有测试。 然后，让我们对<code>task_proj</code>进行一些测试，以正确使用固定装置。 </p><br><h2 id="ispolzovanie--fixtures-dlya-setup-i-teardown"> 使用治具进行设置和拆卸 </h2><br><p>  Tasks项目中的大多数测试都假定Tasks数据库已经配置，正在运行并且已经准备就绪。 如果需要清洁，我们必须在最后删除一些条目。 并且您可能还需要断开与数据库的连接。 幸运的是，大多数任务已在任务代码中通过使用<code>tasks.start_tasks_db(&lt;directory to store db\&gt;, 'tiny' or 'mongo')</code>和<code>tasks.stop_tasks_db()</code> 。 我们只需要在正确的时间调用它们，我们还需要一个临时目录。 </p><br><p> 幸运的是，pytest包含了一个出色的夹具，称为tmpdir。 我们可以将其用于测试，而不必担心清理。 这不是魔术，只是最好奇的人的良好编码习惯。  （请放心；我们将分析tmpdir并在第71页上的“使用tmpdir和tmpdir_factory”部分中使用tmpdir_factory进行更详细地编写。） </p><br><p> 考虑到所有这些组件，此灯具非常有效： </p><br><blockquote>  <strong>ch3 / a /tasks_proj/tests/conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task @pytest.fixture() def tasks_db(tmpdir): """    ,  .""" # Setup : start db tasks.start_tasks_db(str(tmpdir), 'tiny') yield #    # Teardown : stop db tasks.stop_tasks_db()</code> </pre> <br><p>  <em>tmpdir</em>值不是字符串，而是一个代表目录的对象。 但是，它实现了<code>__str__</code> ，因此我们可以使用<code>str()</code>将字符串传递给<code>start_tasks_db()</code> 。 目前，我们仍在TinyDB中使用tiny。 </p><br><p> 夹具功能在使用它的测试之前运行。 但是，如果函数具有<em>yield</em> ，则它将在此处停止，控制将传递给测试，并在测试完成后执行<em>yield</em>之后的下一行。 因此，将<em>yield</em>上方的代码视为“ setup”，并将<em>yield</em>之后的代码视为“ teardown”。 不管测试期间发生什么，都将执行<em>yield</em> “ teardown”之后的代码。 我们不会在此灯具中返回带有输出的数据。 但是可以。 </p><br><p> 让我们修改我们的<code>tasks.add()</code>测试之一以使用此固定装置： </p><br><blockquote>  ch3 / a <code>test_add</code> </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;)    .""" # GIVEN    # WHEN    # THEN  task_id  int new_task = Task('do something') task_id = tasks.add(new_task) assert isinstance(task_id, int)</code> </pre> <br><p> 此处的主要更改是文件中多余的固定装置已被删除，并且我们在测试参数列表中添加了<code>tasks_db</code> 。 我喜欢使用注释构造<em>GIVEN / WHEN / THEN</em>格式（DANO / WHEN / AFTER）的测试，尤其是如果这从代码中看不出来的话。 我认为这在这种情况下很有用。 希望GIVEN初始化的db任务将有助于找出为什么使用<code>tasks_db</code>作为测试工具。 </p><br><hr><br><p> 确保已安装任务。 </p><br><hr><br><p> 我们仍在本章中为Tasks项目编写测试，该项目最初是在第2章中安装的。如果您跳过了本章，请确保使用cd代码安装任务；  <code>pip install ./tasks_proj/</code> 。 </p><br><hr><br><h2 id="trassirovka-fixture-execution-s-setup-show"> 使用–setup-show跟踪夹具执行 </h2><br><p> 如果您从上一节开始运行测试，则不会看到正在运行的灯具： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ $ pip install ./tasks_proj/ #      $ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest -v test_add.py -k valid_id ===================== test session starts ====================== collected 3 items test_add.py::test_add_returns_valid_id PASSED ====================== 2 tests deselected ====================== ============ 1 passed, 2 deselected in 0.02 seconds ============</code> </pre> <br><p> 在设计灯具时，我需要查看什么有效以及何时可用。 幸运的是，pytest提供了这样的命令行标志<code>-- setup-show</code> ，它可以做到： </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_add.py -k valid_id ============================= test session starts ============================= collected 3 items / 2 deselected test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tmpdir, tmpdir_factory). TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory =================== 1 passed, 2 deselected in 0.18 seconds ====================</code> </pre> <br><p> 我们的测试在中间，而pytest为每个灯具指定了SETUP和TEARDOWN部分。 从<code>test_add_returns_valid_id</code>开始，您会看到<code>tmpdir</code>在测试之前起作用。 在那之前<code>tmpdir_factory</code> 。  <code>tmpdir</code>似乎<code>tmpdir</code>将其用作固定装置。 </p><br><p> 灯具名称前面的<strong>F</strong>和<strong>S</strong>表示该区域。  <strong>F</strong>表示作用域， <strong>S</strong>表示会话作用域。 我将在第56页的“示波器夹具规格”部分介绍示波器。 </p><br><h2 id="ispolzovanie-fixtures-dlya-test-data"> 使用夹具测试数据 </h2><br><p> 夹具是存储数据进行测试的好地方。 您可以退货。 这是一个返回混合型元组的夹具： </p><br><blockquote>  <strong>ch3 / test_fixtures.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def a_tuple(): """ -  """ return (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" assert a_tuple[3]['bar'] == 32</code> </pre> <br><p> 由于<code>test_a_tuple()</code>应该失败<em>（23！= 32）</em> ，我们将看到夹具测试失败时会发生什么： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest test_fixtures.py::test_a_tuple ============================= test session starts ============================= collected 1 item test_fixtures.py F [100%] ================================== FAILURES =================================== ________________________________ test_a_tuple _________________________________ a_tuple = (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" &gt; assert a_tuple[3]['bar'] == 32 E assert 23 == 32 test_fixtures.py:38: AssertionError ========================== 1 failed in 0.17 seconds ===========================</code> </pre> <br><p>  pytest与堆栈跟踪部分一起显示了导致异常或断言失败的函数的值参数。 在测试的情况下，夹具是测试的参数，因此使用堆栈跟踪报告它们。 如果在夹具中发生断言（或异常）会怎样？ </p><br><pre> <code class="plaintext hljs">$ pytest -v test_fixtures.py::test_other_data ============================= test session starts ============================= test_fixtures.py::test_other_data ERROR [100%] =================================== ERRORS ==================================== ______________________ ERROR at setup of test_other_data ______________________ @pytest.fixture() def some_other_data(): """Raise an exception from fixture.""" x = 43 &gt; assert x == 42 E assert 43 == 42 test_fixtures.py:21: AssertionError =========================== 1 error in 0.13 seconds ===========================</code> </pre> <br><p> 有几件事发生。 堆栈跟踪正确显示断言发生在夹具函数中。 此外， <code>test_other_data</code>报告为<strong>FAIL</strong> ，而是报告为<strong>ERROR</strong> 。 这是一个主要区别。 如果测试突然失败，您将知道失败发生在测试本身中，并且与某些固定装置无关。 </p><br><p> 但是任务项目呢？ 对于Tasks项目，我们可能会使用一些数据固定装置，可能使用具有不同属性的不同任务列表： </p><br><blockquote>  <strong>ch3 / a / tasks_proj /测试/conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">#    Task constructor # Task(summary=None, owner=None, done=False, id=None) # summary    # owner  done   # id    @pytest.fixture() def tasks_just_a_few(): """    .""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture() def tasks_mult_per_owner(): """     .""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p> 您可以直接从测试或其他固定装置中使用它们。 让我们创建非空数据库以在其帮助下进行测试。 </p><br><h2 id="ispolzovanie-multiple-fixtures"> 使用多个灯具 </h2><br><p> 您已经看到tmpdir使用tmpdir_factory。 您在我们的task_db固定装置中使用了tmpdir。 让我们继续进行链接，并为任务项目的非空基础添加一些专用固定装置： </p><br><blockquote>  <strong>ch3 / a / tasks_proj /测试/conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def db_with_3_tasks(tasks_db, tasks_just_a_few): """   3 ,  .""" for t in tasks_just_a_few: tasks.add(t) @pytest.fixture() def db_with_multi_per_owner(tasks_db, tasks_mult_per_owner): """   9 , 3 owners,  3   .""" for t in tasks_mult_per_owner: tasks.add(t)</code> </pre> <br><p> 所有这些装置都在其参数列表中包括两个装置： <code>tasks_db</code>和数据集。 数据集用于将任务添加到数据库。 现在，如果您希望测试从非空数据库开始，则可以使用测试，例如： </p><br><blockquote>  <strong>ch3 / a / tasks_proj /测试/func/test_add.py</strong> </blockquote><br><pre> <code class="plaintext hljs">def test_add_increases_count(db_with_3_tasks): """Test tasks.add()    tasks.count().""" # GIVEN db  3  # WHEN     tasks.add(Task('throw a party')) # THEN    1 assert tasks.count() == 4</code> </pre> <br><p> 这也说明了使用固定装置的主要原因之一：将测试重点放在您实际测试的内容上，而不是为准备测试做些什么。 我喜欢对GIVEN / WHEN / THEN使用注释，并出于两个原因尝试将尽可能多的数据（GIVEN）推送到固定装置中。 首先，它使测试更具可读性，因此更易于维护。 其次，夹具中的断言或异常会导致错误（ERROR），而测试功能中的断言或异常会导致错误（FAIL）。 如果数据库初始化<code>test_add_increases_count()</code>我不希望<code>test_add_increases_count()</code>失败。 这只是令人困惑。 我希望只有在<code>add ()</code>确实无法更改计数器的情况下， <code>test_add_increases_count()</code>的失败（FAIL） <code>test_add_increases_count()</code>可能。 让我们运行并查看所有灯具如何工作： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest --setup-show test_add.py::test_add_increases_count ============================= test session starts ============================= collected 1 item test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) SETUP F tasks_just_a_few SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_just_a_few, tmpdir, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_just_a_few TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory ========================== 1 passed in 0.20 seconds ===========================</code> </pre> <br><p> 在功能和会话区域，我们又得到了一堆Fs和Ss。 让我们看看它是什么。 </p><br><h2 id="specifikaciya-oblasteyscope-fixture"> 示波器夹具规格 </h2><br><p> 灯具包括一个名为<strong>scope</strong>的可选参数，该参数确定灯具接收安装和拆卸的频率。  <code>@ pytest.fixture()</code>的<em>scope</em>参数可以具有函数，类，模块或会话值。  <em>范围</em>是默认情况下的功能。  task_db设置和所有装置都尚未定义区域。 因此，它们是功能性固定装置。 </p><br><p> 以下是每个<em>范围</em>值的简要说明： </p><br><ul><li><p>  <em>范围='功能'</em> </p><br><p> 对于测试的每个功能都执行一次。 在使用夹具进行每次测试之前，将运行设置部分。 每次使用夹具测试后，拆卸部分就会开始。 如果未指定scope参数，则这是默认区域。 </p><br></li><li><p>  <em>范围='类别'</em> </p><br><p> 无论该类中有多少种测试方法，它都会对每个测试类执行一次。 </p><br></li><li><p>  <em>范围='模块'</em> </p><br><p> 无论使用该模块多少次测试功能，方法或其他固定装置，每个模块都会执行一次。 </p><br></li><li><p>  <em>范围=“会话”</em> </p><br><p> 每个会话执行一次。 所有使用会话范围固定装置的测试方法和功能都使用单个设置和拆卸调用。 </p><br></li></ul><br><p> 实际作用域范围如下所示： </p><br><blockquote>  <strong>ch3 / test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Demo fixture scope.""" import pytest @pytest.fixture(scope='function') def func_scope(): """A function scope fixture.""" @pytest.fixture(scope='module') def mod_scope(): """A module scope fixture.""" @pytest.fixture(scope='session') def sess_scope(): """A session scope fixture.""" @pytest.fixture(scope='class') def class_scope(): """A class scope fixture.""" def test_1(sess_scope, mod_scope, func_scope): """   ,   .""" def test_2(sess_scope, mod_scope, func_scope): """     .""" @pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p> 让我们使用<code>--setup-show</code>来演示根据区域执行的具夹具和设置调用与拆卸的配对次数： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/ $ pytest --setup-show test_scope.py ============================= test session starts ============================= collected 4 items test_scope.py SETUP S sess_scope SETUP M mod_scope SETUP F func_scope test_scope.py::test_1 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP F func_scope test_scope.py::test_2 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP C class_scope test_scope.py::TestSomething::()::test_3 (fixtures used: class_scope). test_scope.py::TestSomething::()::test_4 (fixtures used: class_scope). TEARDOWN C class_scope TEARDOWN M mod_scope TEARDOWN S sess_scope ========================== 4 passed in 0.11 seconds ===========================</code> </pre> <br><p> 现在，您不仅可以看到<strong>F</strong>和<strong>S</strong>表示功能和会话，而且还可以看到<strong>C</strong>和<strong>M</strong>表示类和模块。 </p><br><p> 范围是使用灯具定义的。 我知道这从代码中是显而易见的，但这是确保完全completely吟的重要一点。了解“）。 范围是在灯具定义中定义的，而不是在其调用位置定义的。 使用夹具的测试功能无法控制设置（SETUP）和夹具损坏（TEARDOWN）的频率。 </p><br><p> 灯具只能依靠来自相同或更多扩展范围的其他灯具。 因此，功能范围固定装置可能依赖于其他功能范围固定装置（默认情况下，仍在Tasks项目中使用）。 功能范围固定装置也可能取决于会话区域的类，模块和固定装置，但绝不会相反。 </p><br><h3 id="smena-scope-dlya-tasks-project-fixtures"> 任务项目固定装置的更改范围 </h3><br><p> 有了对范围的了解，现在让我们更改Task项目的某些固定装置的范围。 </p><br><p> 到目前为止，我们在测试时间上没有任何问题。 但是，您必须承认，为每个测试创建一个临时目录和一个新的数据库连接是没有用的。 只要我们可以提供一个空的数据库，则在必要时就足够了。 </p><br><p> 要将<code>tasks_db</code>之类的<code>tasks_db</code>用作会话范围，必须使用<code>tmpdir_factory</code> ，因为<code>tmpdir</code>是函数的范围，而<code>tmpdir_factory</code>是会话的范围。 幸运的是，这只是一行代码更改（嗯，如果在参数列表中考虑<code>tmpdir-&gt;tmpdir_factory</code> ， <code>tmpdir-&gt;tmpdir_factory</code>两行）： </p><br><blockquote>  <strong>ch3 / b / tasks_proj /测试/conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Define some fixtures to use in the project.""" import pytest import tasks from tasks import Task @pytest.fixture(scope='session') def tasks_db_session(tmpdir_factory): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), 'tiny') yield tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</code> </pre> <br><p> 在这里，我们根据<code>tasks_db_session</code>更改了<code>tasks_db_session</code> ，并删除了所有条目以确保其为空。 由于我们尚未更改其名称，因此已经包含它的所有固定装置或测试都不应更改。 </p><br><p> 数据固定装置只是返回一个值，因此实际上没有理由让它们一直工作。 每个会话一次就足够了： </p><br><blockquote>  <strong>ch3 / b / tasks_proj /测试/conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs"># Reminder of Task constructor interface # Task(summary=None, owner=None, done=False, id=None) # summary is required # owner and done are optional # id is set by database @pytest.fixture(scope='session') def tasks_just_a_few(): """All summaries and owners are unique.""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture(scope='session') def tasks_mult_per_owner(): """Several owners with several tasks each.""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p> 现在，让我们看看所有这些更改是否都适用于我们的测试： </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest ===================== test session starts ====================== collected 55 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ....... tests/func/test_unique_id.py . tests/unit/test_task.py .... ================== 55 passed in 0.17 seconds ===================</code> </pre> <br><p> 一切似乎井井有条。 让我们看一下单个测试文件的固定装置，以了解不同区域如何根据我们的期望进行工作： </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show tests/func/test_add.py ============================= test session starts ============================= platform win32 -- Python 3.6.5, pytest-3.9.3, py-1.7.0, pluggy-0.8.0 rootdir: c:\_BOOKS_\pytest_si\bopytest-code\code\ch3\b\tasks_proj\tests, inifile: pytest.ini collected 3 items tests\func\test_add.py SETUP S tmpdir_factory SETUP S tasks_db_session (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_added_task_has_id_set (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP S tasks_just_a_few SETUP F tasks_db (fixtures used: tasks_db_session) SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_db_session, tasks_just_a_few, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_db TEARDOWN S tasks_db_session TEARDOWN S tmpdir_factory TEARDOWN S tasks_just_a_few ========================== 3 passed in 0.24 seconds ===========================</code> </pre> <br><p> 是的  . <code>tasks_db_session</code>     ,    <code>task_db</code>        . </p><br><h3 id="specifying-fixtures-with-usefixtures"> Specifying Fixtures with usefixtures </h3><br><p>   ,   ,    ,       .  ,        <code>@pytest.mark.usefixtures('fixture1', 'fixture2')</code> . <em>usefixtures</em>  ,    ,  .          —     .       : </p><br><blockquote> <strong>ch3/test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p>  <em>usefixtures</em>    ,         .     ,       ,       . ,   -  <em>usefixtures</em> ,      . </p><br><h2 id="ispolzovanie--autouse-dlya-fixtures-that-always-get-used-kotorye-ispolzuyutsya-nepreryvno">  autouse  Fixtures That Always Get Used (  ) </h2><br><p>        ,  ,    (  <em>usefixtures</em>     ).     <em>autouse=True</em> ,    .     ,       ,              .    : </p><br><blockquote> <strong>ch3/test_autouse.py</strong> </blockquote><br><pre> <code class="plaintext hljs">""" autouse fixtures.""" import pytest import time @pytest.fixture(autouse=True, scope='session') def footer_session_scope(): """    session().""" yield now = time.time() print('--') print('finished : {}'.format(time.strftime('%d %b %X', time.localtime(now)))) print('-----------------') @pytest.fixture(autouse=True) def footer_function_scope(): """     .""" start = time.time() yield stop = time.time() delta = stop - start print('\ntest duration : {:0.3} seconds'.format(delta)) def test_1(): """   .""" time.sleep(1) def test_2(): """    .""" time.sleep(1.23)</code> </pre> <br><p>         ,         .     : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest -v -s test_autouse.py ===================== test session starts ====================== collected 2 items test_autouse.py::test_1 PASSED test duration : 1.0 seconds test_autouse.py::test_2 PASSED test duration : 1.24 seconds -- finished : 25 Jul 16:18:27 ----------------- =================== 2 passed in 2.25 seconds ===================</code> </pre> <br><p>  <em>autouse</em>  .    ,  .    ,          . </p><br><p> ,    <em>autouse</em>  ,   ,       <code>tasks_db</code>   .   Tasks  ,     ,  ,      API   .      .      ,     . </p><br><h2 id="pereimenovanie-fixtures">  Fixtures </h2><br><p>  ,        ,  ,      . , <em>pytest</em>       name  <code>@pytest.fixture()</code> : </p><br><blockquote> <strong>ch3/ <code>test_rename_fixture.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">""" fixture renaming.""" import pytest @pytest.fixture(name='lue') def ultimate_answer_to_life_the_universe_and_everything(): """  .""" return 42 def test_everything(lue): """   .""" assert lue == 42</code> </pre> <br><p>  <em>lue</em>    <code>fixture</code> ,   <code>fixture_with_a_name_much_longer_than_lue</code> .    ,       <code>--setup-show</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_rename_fixture.py ======================== test session starts ======================== collected 1 items test_rename_fixture.py SETUP F lue test_rename_fixture.py::test_everything (fixtures used: lue). TEARDOWN F lue ===================== 1 passed in 0.01 seconds ======================</code> </pre> <br><p>    ,   <em>lue</em> ,    pytest <code>--fixtures</code>       .     ,   ,    ,   : </p><br><pre> <code class="plaintext hljs">$ pytest --fixtures test_rename_fixture.py ======================== test session starts ======================= ... ------------------ fixtures defined from test_rename_fixture ------------------ lue Return ultimate answer. ================= no tests ran in 0.01 seconds =================</code> </pre> <br><p>      —   .  , ,   ,  ,   ,   .    ,    <em>lue</em> .      «Tasks»: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest --fixtures tests/func/test_add.py ======================== test session starts ======================== ... tmpdir_factory Return a TempdirFactory instance for the test session. tmpdir Return a temporary directory path object which is unique to each test function invocation, created as a sub directory of the base temporary directory. The returned object is a `py.path.local`_ path object. ----------------------- fixtures defined from conftest ------------------------ tasks_db An empty tasks db. tasks_just_a_few All summaries and owners are unique. tasks_mult_per_owner Several owners with several tasks each. db_with_3_tasks Connected db with 3 tasks, all unique. db_with_multi_per_owner Connected db with 9 tasks, 3 owners, all with 3 tasks. tasks_db_session Connect to db before tests, disconnect after. =================== no tests ran in 0.01 seconds ====================</code> </pre> <br><p> !     <em>conftest.py</em> .        <code>tmpdir</code>  <code>tmpdir_factory</code> ,    . </p><br><h2 id="parametrizaciya-fikstur">   </h2><br><p>  [Parametrized Testing] ,  . 42,   .     .  -    ,      ,   : </p><br><blockquote> <code>ch3/b/tasks_proj/tests/func/test_add_variety2.py</code> <br> <br> """Test the tasks.add() API function.""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> tasks_to_try = (Task('sleep', done=True), <br> Task('wake', 'brian'), <br> Task('breathe', 'BRIAN', True), <br> Task('exercise', 'BrIaN', False)) <br><br> task_ids = ['Task({},{},{})'.format(t.summary, t.owner, t.done) <br> for t in tasks_to_try] <br><br> def equivalent(t1, t2): <br> """Check two tasks for equivalence.""" <br> return ((t1.summary == t2.summary) and <br> (t1.owner == t2.owner) and <br> (t1.done == t2.done)) </blockquote><p>  ,   ,      <code>a_task</code> : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try) <br> def a_task(request): <br> """ .""" <br> return request.param <br><br> def test_add_a(tasks_db, a_task): <br> """  a_task ( ids).""" <br> task_id = tasks.add(a_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, a_task) </blockquote><p> ,    fixture,    ,    .      .    param,      ,  params  <code>@pytest.fixture(params=tasks_to_try)</code> . </p><br><p>  <code>a_task</code>   —    <code>request.param</code>     ,  .        ,     ,       : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj/tests/func $ pytest -v test_add_variety2.py::test_add_a ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_a[a_task0] PASSED test_add_variety2.py::test_add_a[a_task1] PASSED test_add_variety2.py::test_add_a[a_task2] PASSED test_add_variety2.py::test_add_a[a_task3] PASSED =================== 4 passed in 0.03 seconds ===================</code> </pre> <br><p>    ,  pytest   ,   ()   .        ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try, ids=task_ids) <br> def b_task(request): <br> """  .""" <br> return request.param <br><br> def test_add_b(tasks_db, b_task): <br> """  b_task,  .""" <br> task_id = tasks.add(b_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, b_task) </blockquote><p>      : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_b ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_b[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_b[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_b[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_b[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>      <code>ids</code>  ,   ,   .    ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> def id_func(fixture_value): <br> """   .""" <br> t = fixture_value <br> return 'Task({},{},{})'.format(t.summary, t.owner, t.done) <br><br> @pytest.fixture(params=tasks_to_try, ids=id_func) <br> def c_task(request): <br> """  (id_func)   .""" <br> return request.param <br><br> def test_add_c(tasks_db, c_task): <br> """    .""" <br> task_id = tasks.add(c_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, c_task) </blockquote><p>         .       Task, <code>id_func()</code>     <em>Task</em> ,       <em>namedtuple</em>      <em>Task</em>      <em>Task</em>  .   ,      ,   : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_c ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_c[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_c[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_c[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_c[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>          .       ,   ,    .    , ! </p><br><h3 id="parametrizaciya-fixtures-v-tasks-project">  Fixtures  Tasks Project </h3><br><p>   ,         Tasks.      <em>TinyDB</em>   .   ,        .   ,   ,   ,   ,     <em>TinyDB</em> ,    <em>MongoDB</em> . </p><br><p>  ( ),     ,    <code>start_tasks_db()</code>   <code>tasks_db_session</code> : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ch3/b/tasks_proj/tests/conftest.py</a> <br><br> """      .""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> @pytest.fixture(scope='session') <br> def tasks_db_session(tmpdir_factory): <br> """    ,  .""" <br> temp_dir = tmpdir_factory.mktemp('temp') <br> tasks.start_tasks_db(str(temp_dir), 'tiny') <br> yield <br> tasks.stop_tasks_db() <br><br> @pytest.fixture() <br> def tasks_db(tasks_db_session): <br> """   tasks.""" <br> tasks.delete_all() </blockquote><p>  <code>db_type</code>   <code>start_tasks_db()</code>   .      ,        : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>tasks_proj/src/tasks/api.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_tasks_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db_path, db_type)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (str, str) -None """  API  .""" if not isinstance(db_path, string_types): raise TypeError('db_path must be a string') global _tasksdb if db_type == 'tiny': import tasks.tasksdb_tinydb _tasksdb = tasks.tasksdb_tinydb.start_tasks_db(db_path) elif db_type == 'mongo': import tasks.tasksdb_pymongo _tasksdb = tasks.tasksdb_pymongo.start_tasks_db(db_path) else: raise ValueError("db_type   'tiny'  'mongo'")</span></span></code> </pre> <br><p>   MongoDB,       db_type  mongo.  : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>ch3/c/tasks_proj/tests/conftest.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Task <span class="hljs-comment"><span class="hljs-comment"># @pytest.fixture(scope='session', params=['tiny',]) @pytest.fixture(scope='session', params=['tiny', 'mongo']) def tasks_db_session(tmpdir_factory, request): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), request.param) yield # this is where the testing happens tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</span></span></code> </pre> <br><p>    params=['tiny',' mongo']  -.   <code>request</code>    <em>temp_db</em>   <em>db_type</em>  <code>request.param</code>  ,    "tiny"  "mongo". </p><br><p>   <code>--verbose</code>   <code>-v</code>    pytest     , pytest        .      ,   . </p><br><hr><br><p>  <strong>安装MongoDB</strong> </p><br><hr><br><p>    MongoDB, ,   MongoDB  <em>pymongo</em> .       MongoDB,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.mongodb.com/download-center</a> . pymongo   pip— <em>pip install pymongo</em> .   MongoDB       ;           <strong> 7</strong> . </p><br><hr><br><p>     : </p><br><pre> <code class="plaintext hljs"> $ cd /path/to/code/ch3/c/tasks_proj $ pip install pymongo $ pytest -v --tb=no ===================== test session starts ====================== collected 92 items test_add.py::test_add_returns_valid_id[tiny] PASSED test_add.py::test_added_task_has_id_set[tiny] PASSED test_add.py::test_add_increases_count[tiny] PASSED test_add_variety.py::test_add_1[tiny] PASSED test_add_variety.py::test_add_2[tiny-task0] PASSED test_add_variety.py::test_add_2[tiny-task1] PASSED ... test_add.py::test_add_returns_valid_id[mongo] FAILED test_add.py::test_added_task_has_id_set[mongo] FAILED test_add.py::test_add_increases_count[mongo] PASSED test_add_variety.py::test_add_1[mongo] FAILED test_add_variety.py::test_add_2[mongo-task0] FAILED ... ============= 42 failed, 50 passed in 4.94 seconds =============</code> </pre> <br><p> 嗯 . ,     ,     -   Mongo.  ,     pdb:   ,  . 125.        TinyDB. </p><br><h2 id="uprazhneniya"> 练习题 </h2><br><ol><li>    <code>test_fixtures.py</code> . <br> 2.  fixtures—functions     <code>@pytest.fixture()</code> ,     . ,   ,  . </li><li>         ,   . </li><li>   ,       . </li><li>  <code>pytest --setup-show test_fixtures.py</code> .      ? </li><li>  <code>scope= 'module'</code>     4. </li><li>   <code>pytest --setup-show test_fixtures.py</code> . 有什么变化？ </li><li>     6  <code>return &lt;data&gt;</code>  <code>yield &lt;data&gt;</code> . </li><li>       <code>yield</code> . </li><li>  <code>pytest -s -v test_fixtures.py</code> .    ? </li></ol><br><h2 id="chto-dalshe"> 接下来是什么 </h2><br><p>  pytest fixture  ,   ,   <em>building blocks</em> ,    <em>setup</em>  <em>teardown</em> ,        (,  Mongo  TinyDB).    ,      ,         . </p><br><p>       pytest,   ,    (builtin)  tmpdir  tmpdir_factory.        (builtin) . </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一个</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448786/">https://habr.com/ru/post/zh-CN448786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448774/index.html">使用DBMS_SQL的SQL至CSV</a></li>
<li><a href="../zh-CN448776/index.html">RxVMS-适用于Flutter应用程序的实用架构</a></li>
<li><a href="../zh-CN448778/index.html">为Visual Studio Enterprise 2019引入时间旅行调试</a></li>
<li><a href="../zh-CN448780/index.html">什么使软件可以赚钱</a></li>
<li><a href="../zh-CN448782/index.html">使用pytest进行Python测试。 pytest入门，第1章</a></li>
<li><a href="../zh-CN448788/index.html">使用pytest进行Python测试。 第2章，编写测试函数</a></li>
<li><a href="../zh-CN448790/index.html">SpaceVIL-用于在.Net Core，.Net Standard和JVM上开发的跨平台GUI框架</a></li>
<li><a href="../zh-CN448796/index.html">使用pytest进行Python测试。 配置，第6章</a></li>
<li><a href="../zh-CN448798/index.html">使用pytest进行Python测试。 将pytest与其他工具结合使用，第7章</a></li>
<li><a href="../zh-CN448800/index.html">使用.vsconfig在整个组织中配置Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>