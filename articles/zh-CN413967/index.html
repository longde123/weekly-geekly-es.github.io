<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌷 🎅 🎓 动物杂交开发人员模式逆向工程 📕 👨‍⚖️ 🤵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="去年夏天，我开始对GameCube的Animal Crossing进行逆向工程。 我想探索为该游戏创建mod的可能性。 另外，我想记录一下为对ROM和逆向工程感兴趣的人们创建教程的过程。 在本文中，我将讨论游戏中剩余的开发人员调试功能，并分享我如何发现可用于解锁功能的作弊连击。 

 new_Deb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>动物杂交开发人员模式逆向工程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413967/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/fe4/7f0/b4dfe47f0139ba1af039decfb6274524.jpg" alt="在真实的GameCube上使用代码"></div><br> 去年夏天，我开始对GameCube的Animal Crossing进行逆向工程。 我想探索为该游戏创建mod的可能性。 另外，我想记录一下为对ROM和逆向工程感兴趣的人们创建教程的过程。 在本文中，我将讨论游戏中剩余的开发人员调试功能，并分享我如何发现可用于解锁功能的作弊连击。 <br><a name="habracut"></a><br><h3>  new_Debug_mode </h3><br> 研究了其余的调试符号后，我注意到包含单词“ debug”的函数和变量的名称，并决定看看游戏中是否还有任何调试功能会很有趣。 如果我设法激活调试或开发功能，这将在创建mod的过程中为我提供帮助。 <br><br> 我注意到的第一个功能是<code>new_Debug_mode</code> 。 它由<code>entry</code>功能调用，该功能在Nintendo徽标屏幕完成后立即启动。 她所做的只是放置<code>0x1C94</code>字节结构并保存一个指向它的指针。 <br><br> 在宿主结构中以偏移量<code>0xD4</code>在<code>entry</code>中调用它之后<code>0xD4</code>紧接着在调用<code>mainproc</code>之前<code>mainproc</code>值设置<code>mainproc</code> 0。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63e/fbc/0af/63efbc0af9ebfb4eeb2c3b42feddcbed.png"></div><br> 为了查看当值不为零时会发生什么，我在<code>80407C8C</code>修补了<code>li r0, 0</code> <code>80407C8C</code>指令，将其替换为<code>li r0, 1</code> <code>80407C8C</code> 。  <code>li r0, 0</code>指令的原始字节为<code>38 00 00 00</code> ，其中赋值位于指令的末尾，因此我只需将字节替换为<code>38 00 00 01</code>得到<code>li r0, 1</code> 。 作为构建指令的更可靠方法，可以使用<code>kstool</code>类的<code>kstool</code> ： <br><br> <code>$ kstool ppc32be "li 0, 1" <br> li 0, 1 = [ 38 00 00 01 ]</code> <br> <br> 在Dolphin模拟器中，可以通过在游戏属性中转到“补丁”选项卡并按如下方式输入来应用此补丁： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e65/ecb/706/e65ecb7061c9470c9a9b71c4aad8e506.png"></div><br> 分配值1之后，屏幕底部会出现一个有趣的图形： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be5/cab/e1f/be5cabe1fe1df63d0534c092d49ca8f9.png"></div><br><br> 它看起来像一个性能指标：屏幕底部的小条会增加或减少。  （后来，当我查看绘制此图的函数的名称时，我发现它们实际上显示了CPU和内存使用率指标。） <br><br> 很棒，但不是特别有用。 分配值1后，我的城市停止加载，因此此处无法进行其他操作。 <br><br><h3> 祖鲁模式 </h3><br> 我再次开始寻找有关调试功能的其他参考，并且几次遇到称为“ zuru模式”的东西。 具有调试功能的代码块分支经常检查<code>zurumode_flag</code>变量。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/4d4/63c/88e4d463c3ea3474d3b67e2cf8367ee2.png" alt="game_move_first函数"></div><br> 仅当<code>zurumode_flag</code>不等于0时， <code>zurumode_flag</code>调用上面显示的<code>game_move_first</code>函数中的<code>zzz_LotsOfDebug</code> （我自己<code>zzz_LotsOfDebug</code>的名称）。 <br><br> 寻找与此值关联的函数，我发现了这些： <br><br><ul><li> <code>zurumode_init</code> </li> <li> <code>zurumode_callback</code> </li> <li> <code>zurumode_update</code> </li> <li> <code>zurumode_cleanup</code> </li> </ul><br> 乍一看，它们的用途是神秘的，它们在<code>osAppNMIBuffer</code>变量的偏移量中<code>osAppNMIBuffer</code> 。 <br><br> 乍看之下，这些功能的工作方式如下： <br><br><h4>  zurumode_init </h4><br><ul><li> 将<code>zurumode_flag</code>设置为0 </li><li> 检查<code>osAppNMIBuffer</code>几个位 </li><li> 在<code>padmgr</code>结构中保存指向<code>zurumode_callback</code>函数的指针 </li><li> 调用<code>zurumode_update</code> </li></ul><br><h4>  zurumode_update </h4><br><ul><li> 检查<code>osAppNMIBuffer</code>几个位 </li><li> 根据这些位的值， <code>zurumode_flag</code>更新 </li><li> 将格式字符串打印到OS控制台。 </li></ul><br> 通常在为代码提供上下文时很有用，但是该行中有很多不可打印的字符。 唯一可识别的文本是“ zurumode_flag”和“％d”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/f99/093/268f99093e0f9dec2a19bfc22be95ac7.png" alt="zuru模式格式字符串"></div><br> 假设它可能是带有多字节字符编码的日语文本，我将该字符串通过了编码识别工具，然后发现该字符串是使用Shift-JIS编码的。 在翻译中，该行仅表示“ zurumode_flag的值已从％d更改为％d”。 这不会给我们带来太多新信息，但是现在我们知道使用了Shift-JIS：在二进制文件和行表中，此编码中包含更多行。 <br><br><h4>  zurumode_callback </h4><br><ul><li> 调用<code>zerumode_check_keycheck</code> </li><li> 检查<code>osAppNMIBuffer</code>几个位 </li><li>  <code>zurumode_flag</code>值在<code>zurumode_flag</code> </li><li> 调用<code>zurumode_update</code> </li></ul><br>  <code>zerumode_check_keycheck</code>直到我们由于拼写不同而见面……这是什么？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49e/ca7/1fd/49eca71fdd3cefb01b01c578a93bbe72.png" alt="zerumode_check_keycheck"></div><br> 一个巨大的复杂函数，对具有未命名值的位进行更多工作。 <br><br> 此时，我决定退后一步，研究其他调试功能和变量，因为我不确定zuru模式的重要性。 另外，我不明白“密钥检查”在这里的含义。 这可能是加密密钥吗？ <br><br><h3> 返回调试 </h3><br> 大约在这个时候，我注意到我在IDA中加载调试符号的方式存在问题。 游戏磁盘上的<code>foresta.map</code>文件包含许多地址以及函数和变量的名称。 最初，我没有看到每个部分的地址都从头开始，因此我编写了一个简单的脚本，为文件的每一行添加了一个名称条目。 <br><br> 我编写了新的IDA脚本来修复程序不同部分的加载符号表： <code>.text</code> ， <code>.rodata</code> ， <code>.data</code>和<code>.bss</code> 。  <code>.text</code>部分包含所有功能，因此我做到了，这样，当我设置名称时，脚本将自动识别每个地址处的功能。 <br><br> 现在，在数据部分中，他为每个二进制对象创建了一个段（例如， <code>m_debug.o</code> ，应该将其编译为<code>m_debug</code>代码），并为每个数据段设置空间和名称。 <br><br> 这给了我更多的信息，但是我必须为每个数据手动设置数据类型，因为我将每个数据对象都定义为一个简单的字节数组。  （回想一下，我理解最好假设4个字节的片段包含32位整数，因为存在很多，并且包含许多对构建交叉引用很重要的函数和数据的地址。） <br><br> 研究<code>m_debug_mode.o</code>的新<code>.bss</code>段，我发现了几个变量，形式为<code>quest_draw_status</code>和<code>event_status</code> 。 这很有趣，因为我希望在调试模式下显示有用的信息，而不仅仅是性能图。 幸运的是，从这些数据记录中可以看到对<code>debug_print_flg</code>的大量代码的交叉引用。 <br><br> 在Dolphin模拟器中使用调试器，我在检查<code>debug_print_flg</code>的函数的位置（在<code>8039816C</code> ）设置了一个断点，以了解此检查的工作方式。 但是该程序从未传递到此断点。 <br><br> 让我们<code>game_debug_draw_last</code>一下发生这种情况的原因： <code>game_debug_draw_last</code>调用此函数。 猜猜在有条件调用之前检查了什么值？  <code>zurumode_flag</code> ！ 到底是怎么回事？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/257/048/964/257048964f9e8265670952e66868fc83.png" alt="zurumode_flag检查"></div><br> 我在此检查（ <code>80404E18</code> ）上设置了一个断点，它立即起作用。  <code>zurumode_flag</code>的值为零，因此在正常执行中，程序将错过对该函数的调用。 我插入了一条NOP分支指令（用一条什么都不做的指令代替）来检查调用该函数时发生的情况。 <br><br> 在Dolphin调试器中，可以通过暂停游戏，右键单击说明并选择“ Insert nop”来完成此操作： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/f00/8d1/2e6f008d1dcf1be707b1961e05df2e71.png" alt="海豚调试器"></div><br> 没事 然后，我检查了函数内部发生的情况，发现了另一个分支构造，该构造避开了<code>803981a8</code>发生的所有有趣的事情。 我也插入了NOP，屏幕的右上角出现了字母“ D”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/9a0/816/a189a0816b08438ad5b85c09adaac57c.png" alt="调试模式字母D"></div><br> 在<code>8039816C</code>此函数（我将其称为<code>zzz_DebugDrawPrint</code> ）中，仍然有很多有趣的代码，但是没有被调用。 如果以图表的形式查看此函数，则可以看到有一系列分支运算符会跳过整个函数中的代码块： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/236/131/4bb/2361314bbb4165b8e1c82386e8c50533.png" alt="zzz_DebugDrawPrint中的分支"></div><br> 插入NOP而不是其他几个分支结构后，我开始在屏幕上看到各种有趣的东西： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/c19/008/0dbc1900844131d0c3d7f507f2b61b63.png" alt="打印更多调试内容"></div><br> 下一个问题是如何在不更改代码的情况下激活此调试功能。 <br><br> 另外，在某些分支构造中， <code>zurumode_flag</code>在此调试绘制函数中再次出现。 我添加了另一个补丁，以便在<code>zurumode_update</code> <code>zurumode_flag</code>始终<code>zurumode_update</code>标志分配值2，因为当它不与0比较时，它专门与值2比较。 <br><br> 重新启动游戏后，我在屏幕的右上角看到了一条消息“ msg。 不。” <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97d/16e/a0b/97d16ea0b169c72dd86ab623e0e3f977.png" alt="消息号显示"></div><br> 数字687是最近显示的消息的记录标识符。 我使用分析开始时编写的表查看器程序对其进行了检查，但是您也可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">具有完整GUI</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字符串表编辑器</a>对其进行检查，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GUI</a>是我为黑客ROM而编写的。 这是帖子在编辑器中的外观： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/e3f/378/cade3f3785a86e9bf335a144fe16a338.png" alt="弦表编辑器中的消息687"></div><br> 在这一点上，很明显，不再研究zuru模式了-它与游戏的调试功能直接相关。 <br><br><h3> 再次回到祖鲁模式 </h3><br>  <code>zurumode_init</code>初始化几件事： <br><br><ul><li>  <code>0xC(padmgr_class)</code>分配了<code>zurumode_callback</code>地址的值 </li><li>  <code>0x10(padmgr_class)</code>分配了<code>padmgr_class</code>本身的地址值 </li><li>  <code>0x4(zuruKeyCheck)</code>分配了从<code>0x3C(osAppNMIBuffer)</code>加载的字中的最后一位的值。 </li></ul><br> 我弄清楚<code>padmgr</code>什么，“ gamepad manager”的缩写。 这意味着可能存在可以在游戏板上输入以激活zuru模式的按键（按钮）的特殊组合，或者可以用于发送信号以激活信号的某种调试设备或开发者控制台的功能。 <br><br>  <code>zurumode_init</code>仅在游戏的第一次启动时执行（按下重置按钮<code>zurumode_init</code>不起作用）。 <br><br> 在地址<code>8040efa4</code>处设置了一个断点，并为其指定了<code>0x4(zuruKeyCheck)</code>的值<code>0x4(zuruKeyCheck)</code> ，我们可以看到，在不按任何键加载的情况下，该值设置为0。如果将其替换为1，则会发生有趣的事情： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dc/5f5/0fb/9dc5f50fbd68beb624745d0704a18383.png" alt="zuru模式的标题屏幕"></div><br> 字母“ D”再次出现在右上角（这次是绿色，而不是黄色），并且还会显示一些装配信息： <br><br> <code>[CopyDate: 02/08/01 00:16:48 ] <br> [Date: 02-07-31 12:52:00] <br> [Creator:SRD@SRD036J]</code> <br> <br> 一个始终在开始时始终将<code>0x4(zuruKeyCheck)</code>为1的补丁看起来像这样： <br><br> <code>8040ef9c 38c00001</code> <br> <br> 这似乎是初始化zuru模式的正确方法。 此后，可能需要采取各种措施来实现某些调试信息的显示。 开始游戏，散步并与村民交谈时，我们将看不到上述任何消息（角落处的字母“ D”除外）。 <br><br> 最可能的可疑对象是<code>zurumode_update</code>和<code>zurumode_callback</code> 。 <br><br><h4>  zurumode_update </h4><br>  <code>zurumode_update</code>首先在<code>zurumode_init</code>中<code>zurumode_init</code> ，然后由<code>zurumode_callback</code>不断调用。 <br><br> 它将再次检查最后一位<code>0x3C(osAppNMIBuffer)</code> ，然后根据此值更新<code>zurumode_flag</code> 。 <br><br> 如果该位为零，则标志设置为零。 <br><br> 如果不是，则执行以下语句，其完整值为<code>0x3c(osAppNMIBuffer)</code>为<code>r5</code> ： <br><br> <code>extrwi r3, r5, 1, 28</code> <br> <br> 它从<code>r5</code>提取第28位并将其存储在<code>r3</code> 。 <br><br> 然后将1添加到结果中，即最终结果始终为1或2。 <br><br> 然后将<code>zurumode_flag</code>与先前的结果进行比较，具体取决于第28位和最后一位中有多少位设置为<code>0x3c(osAppNMIBuffer)</code> ：0、1或2。 <br><br> 该值被写入<code>zurumode_flag</code> 。 如果不做任何更改，该函数将退出并返回当前标志值。 如果更改了该值，则将执行更为复杂的代码块链。 <br><br> 一条消息以日语显示：相同的“ zurumode_flag值从％d更改为％d”，如上所述。 <br><br> 然后，根据标志是否已变为零，使用不同的参数调用一系列函数。 这部分的汇编代码是单调的，因此我将显示其伪代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag_changed_to_zero) { JC_JUTAssertion_changeDevice(<span class="hljs-number"><span class="hljs-number">2</span></span>) JC_JUTDbPrint_setVisible(JC_JUTDbPrint_getManager(), <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BIT(nmiBuffer, <span class="hljs-number"><span class="hljs-number">25</span></span>) || BIT(nmiBuffer, <span class="hljs-number"><span class="hljs-number">31</span></span>)) { JC_JUTAssertion_changeDevice(<span class="hljs-number"><span class="hljs-number">3</span></span>) JC_JUTDbPrint_setVisible(JC_JUTDbPrint_getManager(), <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br> 注意，如果标志为零，则将参数0传递给JC_JUTDbPrint_setVisible。 <br><br> 如果该标志不等于零，并且位25或位31设置为<code>0x3C(osAppNMIBuffer)</code> ，则<code>setVisible</code>传递给参数1。 <br><br> 这是激活zuru模式的第一个关键：最后一位<code>0x3C(osAppNMIBuffer)</code>必须设置为1以显示调试信息并将<code>zurumode_flag</code>设置<code>zurumode_flag</code>非零值。 <br><br><h4>  zurumode_callback </h4><br>  <code>zurumode_callback</code>位于<code>8040ee74</code> ，可能由与游戏手柄相关的函数调用。 在Dolphin调试器中插入断点后，调用堆栈向我们显示实际上是从<code>padmgr_HandleRetraceMsg</code>调用<code>padmgr_HandleRetraceMsg</code> 。 <br><br> 她的第一个动作是执行<code>zerucheck_key_check</code> 。 该函数很复杂，但似乎通常设计为读取和更新<code>zuruKeyCheck</code>的值。 在继续进行keycheck函数之前，我决定检查在回调函数的其余部分中如何使用此值。 <br><br> 然后，它再次检查<code>0x3c(osAppNMIBuffer)</code>某些位。 如果设置了位26，或者设置了位25，并且<code>padmgr_isConnectedController(1)</code>返回非零值，则<code>0x3c(osAppNMIBuffer)</code>的最后一位<code>0x3c(osAppNMIBuffer)</code>为1！ <br><br> 如果没有设置这些位或设置了位25，但是<code>padmgr_isConnectedController(1)</code>返回0，则该函数检查地址<code>0x4(zuruKeyCheck)</code>处的字节是否等于零。 如果相等，则它将重置原始值的最后一位并将其写回到<code>0x3c(osAppNMIBuffer)</code> 。 如果不是，则仍将最后一位设置为1。 <br><br> 在伪代码中，它看起来像这样： <br><br><pre> <code class="cpp hljs">x = osAppNMIBuffer[<span class="hljs-number"><span class="hljs-number">0x3c</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BIT(x, <span class="hljs-number"><span class="hljs-number">26</span></span>) || (BIT(x, <span class="hljs-number"><span class="hljs-number">25</span></span>) &amp;&amp; isConnectedController(<span class="hljs-number"><span class="hljs-number">1</span></span>)) || zuruKeyCheck[<span class="hljs-number"><span class="hljs-number">4</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { osAppNMIBuffer[<span class="hljs-number"><span class="hljs-number">0x3c</span></span>] = x | <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// set last bit } else { osAppNMIBuffer[0x3c] = x &amp; ~1 // clear last bit }</span></span></code> </pre> <br> 此后，如果未设置位26，则函数继续调用<code>zurumode_update</code> ，然后退出。 <br><br> 如果该位置1，则如果<code>0x4(zuruKeyCheck)</code>不等于零，则它将加载格式字符串，并在其中显示以下内容：“ ZURU％d /％d”。 <br><br><h4> 汇总小计 </h4><br> 这是发生了什么： <br><br>  <code>padmgr_HandleRetraceMsg</code>调用<code>zurumode_callback</code> 。 我假设此“句柄回溯消息”意味着它仅扫描控制器的击键。 每次扫描都会导致一系列不同的回调。 <br><br> 执行<code>zurumode_callback</code>它将检查当前的击键（按钮）。 看来她正在检查特定按钮或按钮组合。 <br><br>  NMI缓冲区中的最后一位将根据其当前值中的特定位以及<code>zuruKeyCheck</code>字节之一（ <code>0x4(zuruKeyCheck)</code> ）的值进行更新。 <br><br> 然后<code>zurumode_update</code>并检查该位。 如果为0，则zuru模式标志设置为0。如果为1，则模式标志更改为1或2，具体取决于是否设置了位28。 <br><br>  <strong>有三种激活zuru模式的方法：</strong> <br><br><ol><li> 位26设置为<code>0x3C(osAppNMIBuffer)</code> </li><li> 位25设置为<code>0x3C(osAppNMIBuffer)</code> ，并且控制器连接到端口2 </li><li>  <code>0x4(zuruKeyCheck)</code>不为零 </li></ol><br><h4>  osAppNMIBuffer </h4><br> 对<code>osAppNMIBuffer</code>含义感兴趣，我开始寻找“ NMI”，并在Nintendo上下文中找到了指向“不可屏蔽中断”的链接。 事实证明，此变量的名称在Nintendo 64的开发人员文档中被完全提及： <br><br><blockquote>  osAppNMIBuffer是一个64字节的缓冲区，在冷重启后会清除。 如果系统由于NMI而重启，则该缓冲区的状态不会更改。 </blockquote><br> 实际上，这只是在“软”重启（使用复位按钮）期间保存的一小块内存。 当控制台在网络上时，游戏可以使用此缓冲区存储任何数据。 原始的《动物穿越》是在Nintendo 64上发布的，因此逻辑上应该在代码中出现类似的内容。 <br><br> 如果转到二进制<code>boot.dol</code>文件（上面显示的所有内容都在<code>foresta.rel</code> ），则其<code>main</code>功能具有指向<code>osAppNMIBuffer</code>的大量链接。 快速查看显示了一系列检查，这些检查可以导致使用OR操作<code>0x3c(osAppNMIBuffer)</code>不同位<code>0x3c(osAppNMIBuffer)</code>值。 <br><br> 以下OR操作数值可能很有趣： <br><br><ul><li> 位31：0x01 </li><li> 位30：0x02 </li><li> 位29：0x04 </li><li> 位28：0x08 </li><li> 位27：0x10 </li><li> 位26：0x20 </li></ul><br> 我们记得，第25、26和28位特别有趣：第25和26位决定zuru模式是否开启，第28位决定标志位（1或2）。 <br> 第31位也很有趣，但是看起来它根据其他值而变化。 <br><br><h5> 位26 </h5><br> 首先：在地址<code>800062e0</code>有一条指令<code>ori r0, r0, 0x20</code> <code>0x3c</code> ，其缓冲区值为<code>0x3c</code> 。 它将位26置位，该位始终打开zuru模式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/b3c/207/b5cb3c207a61dc20dd12e6724f25099b.png" alt="设置位26"></div><br> 对于要设置的位，从<code>DVDGetCurrentDiskID</code>返回的第八个字节必须为<code>0x99</code> 。 该标识符位于游戏磁盘映像的最开始，并以<code>80000000</code>加载到内存中。 在游戏的常规零售版中，ID如下所示： <br><br> <code>47 41 46 45 30 31 00 00 GAFE01..</code> <br> <br> 将标识符的最后一个字节替换为<code>0x99</code>的<code>0x99</code> ，我们在开始游戏时会得到以下图片： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da6/c58/c90/da6c58c90515fefb62ed8cf766ad8776.png" alt="游戏版本ID 0x99"></div><br> 并且在操作系统控制台中显示以下内容： <br><br> <code>06:43:404 HW\EXI_DeviceIPL.cpp:339 N[OSREPORT]: ZURUMODE2 ENABLE <br> 08:00:288 HW\EXI_DeviceIPL.cpp:339 N[OSREPORT]: osAppNMIBuffer[15]=0x00000078</code> <br> <br> 可以删除所有其他修补程序，然后字母D再次出现在屏幕的右上角，但是不再激活调试消息。 <br><br><h5>  25位 </h5><br> 位25与控制器端口2检查一起使用，是什么导致它打开？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/d00/4a1/ddfd004a1488ec21842c90581ef177fc.png" alt="25位和28位"></div><br> 事实证明，他应该使用与位28相同的检查：版本必须大于或等于<code>0x90</code> 。 如果设置了位26（ID为<code>0x99</code> ），那么这两个位也将被设置，并且zuru模式仍将被激活。 <br><br> 但是，如果版本的范围是<code>0x90</code>到<code>0x98</code> ，则zuru模式不会立即打开。 回顾在<code>zurumode_callback</code>执行的检查-仅当设置了位25 <em>并且</em> <code>padmgr_isConnectedController(1)</code>返回非零值时，该模式才会启用。 <br><br> 控制器连接到端口2后（参数<code>isConnectedController</code>索引为零），将激活zuru模式。 字母D和有关程序集的信息出现在初始屏幕上，我们...可以使用第二个控制器的按钮来控制调试的显示！ <br><br> 一些按钮执行的操作不仅会改变显示效果，而且还会例如提高游戏速度。 <br><br><h4>  zerucheck_key_check </h4><br> 最后一个谜仍然是<code>0x4(zuruKeyCheck)</code> 。 事实证明，此值是使用上面显示的巨大复杂功能更新的： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49e/ca7/1fd/49eca71fdd3cefb01b01c578a93bbe72.png" alt="zerumode_check_keycheck"></div><br> 使用Dolphin模拟器调试器，我能够确定此功能检查的值是一组与第二个控制器上的按钮按下相对应的位。 <br><br> 对按钮单击的跟踪以16位值存储在<code>0x2(zuruKeyCheck)</code> 。 未连接控制器时，值为<code>0x7638</code> 。 <br><br> 将下载2个字节，其中包含控制器按钮按下的标志，然后在<code>zerucheck_key_check</code>的开头进行<code>zerucheck_key_check</code> 。 在调用回调函数时，新值将通过寄存器<code>r4</code>传递<code>r4</code> <code>padmgr_HandleRetraceMsg</code>函数。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/478/318/f984783181e592098f8beef9c22cef23.png" alt="关键检查结束"></div><br> 在<code>zerucheck_key_check</code>末尾附近，还有另一个更新<code>0x4(zuruKeyCheck)</code>地方<code>0x4(zuruKeyCheck)</code> 。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它没有出现在交叉引用列表中，因为它使用它作为基址</font></font><code>r3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且我们</font></font><code>r3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能在调用此函数之前通过查看分配给它</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">来</font><font style="vertical-align: inherit;">找到该值</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在该地址，该</font></font><code>8040ed88</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值被</font></font><code>r4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入</font></font><code>0x4(zuruKeyCheck)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。就在此之前，但是它是从同一位置写入的，然后是从1进行的XOR。此操作的任务是在0和1之间切换字节的值（实际上是最后一位）。（如果值为0，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则从1 </font><font style="vertical-align: inherit;">进行</font><font style="vertical-align: inherit;">XOR </font><font style="vertical-align: inherit;">的结果</font><font style="vertical-align: inherit;">将为1 。如果值为1，则结果将为0。有关XOR的信息，请参见真值表。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/c32/eb1/048c32eb12dda64c878fa7b9f0bd7ddc.png" alt="密钥检查结束"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前，当我研究内存中的值时，我没有注意到这种现象，但是我将尝试在调试器中破坏此指令以了解正在发生的情况。原始值加载到</font></font><code>8040ed7c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果不触摸控制器按钮，则不会在初始屏幕上到达此断点。要进入此代码块，该值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须</font></font><code>0xb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在断点（</font></font><code>8040ed74</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">之前的分支指令之前</font><font style="vertical-align: inherit;">等于</font><font style="vertical-align: inherit;">。在通往此块的许多不同路径中，只有一个</font><font style="vertical-align: inherit;">在其前面的address处</font><font style="vertical-align: inherit;">分配一个</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">。</font></font><code>0xb</code><font style="vertical-align: inherit;"></font><code>8040ed68</code><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/926/959/04c926959999b5f6facfc8920f6a212f.png" alt="将r5设置为0xb"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，为了到达分配该</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">的块</font></font><code>0xB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该值</font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须紧接</font><font style="vertical-align: inherit;">在它之前</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在整个功能块开始之前，我们可以看到实现此块所需的所有限制：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ed74：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须相等</font></font><code>0xB</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ed60：值</font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须相等</font></font><code>0x1000</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ebe8：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须相等</font></font><code>0xA</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ebe4：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须小于</font></font><code>0x5B</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040eba4：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须更大</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040eb94：值</font></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须为1</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040eb5c：值</font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能为0</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040eb74：端口2按钮值应更改 </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/2fa/9f3/28e2fa9f3d35b1c6146f816120dee72b.png" alt="跟踪代码路径"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们到达了加载旧按钮值并保存新值的地步。然后是对新值和旧值应用的几个操作：</font><font style="vertical-align: inherit;">XOR操作标记两个值之间已更改的所有位。然后，AND操作会屏蔽新输入，以将当前未设置为状态0的所有位设置为1。结果</font><font style="vertical-align: inherit;">是新值</font><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">的一组新位（按钮按下）。如果不为空，那么我们走在正确的轨道上。</font><font style="vertical-align: inherit;">为了</font><font style="vertical-align: inherit;">要紧</font><font style="vertical-align: inherit;">，应该从第四16位跟踪按钮来改变。在XOR / AND操作后插入断点后，我发现START按钮触发了此状态。</font><font style="vertical-align: inherit;">下一个问题是如何</font><font style="vertical-align: inherit;">使它最初相等</font></font><br><br> <code>old_vals = old_vals XOR new_vals <br> old_vals = old_vals AND new_vals</code> <br> <br><font style="vertical-align: inherit;"></font><code>r0</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>r0</code><font style="vertical-align: inherit;"></font><code>0x1000</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>r5</code><font style="vertical-align: inherit;"></font><code>0xA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font><font style="vertical-align: inherit;">在我们不进入包含的代码块时</font></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font></font><code>0x0(zuruKeyCheck)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键测试函数的开头</font><font style="vertical-align: inherit;">加载并</font><font style="vertical-align: inherit;">在接近结尾时进行更新</font></font><code>0x4(zuruKeyCheck)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此之前，有几个地方</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配</font><font style="vertical-align: inherit;">了</font><font style="vertical-align: inherit;">值</font></font><code>0xA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ul><li> <code>8040ed50</code> </li> <li> <code>8040ed00</code> </li> <li> <code>8040ed38</code> </li> </ul><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040ed38 </font></font></h5><br><ul><li> <code>8040ed34</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须相等</font></font><code>0x4000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（按下按钮B）</font></font></li><li> <code>8040ebe0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须相等</font></font><code>0x5b</code> </li><li> <code>8040eba4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须更大</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 然后一切都会像以前一样... </font></font></li></ul><br> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 应该从 </font></font><code>0x5b</code> <br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040ed00 </font></font></h5><br><ul><li> <code>8040ecfc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须相等</font></font><code>0xC000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（按下A和B）</font></font></li><li> <code>8040ebf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须&gt; = 9</font></font></li><li> <code>8040ebf0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须小于10</font></font></li><li> <code>8040ebe4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须小于</font></font><code>0x5b</code> </li><li> <code>8040eba4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该更多</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 然后一切都会像以前一样... </font></font></li></ul><br> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 应该从9开始 </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040ed50 </font></font></h5><br><ul><li> <code>8040ed4c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须相等</font></font><code>0x8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（按下按钮A）</font></font></li><li> <code>8040ec04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须小于</font></font><code>0x5d</code> </li><li> <code>8040ebe4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须更大</font></font><code>0x5b</code> </li><li> <code>8040eba4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：值</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须更大</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 然后一切都会像以前一样... </font></font></li></ul><br> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该开始</font></font><code>0x5c</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">于按键之间似乎存在某种状态，此后您需要从按钮输入一定的连击序列，最后按START键。</font><font style="vertical-align: inherit;">看来A和/或B应该在START之前就走了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您跟踪将</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">为9 </font><font style="vertical-align: inherit;">的代码的路径</font><font style="vertical-align: inherit;">，则会出现一个模式：</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-它是一个递增的值，当</font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到合适的值</font><font style="vertical-align: inherit;">时可以增加，也可以</font><font style="vertical-align: inherit;">为零。</font><font style="vertical-align: inherit;">最奇怪的情况是它不是从</font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font><font style="vertical-align: inherit;">的范围内的值</font></font><code>0xB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当用几个按钮处理步骤时，例如同时按下A和B时，会出现，试图进入此组合的人在跟踪游戏手柄时通常不能完全同时按下两个按钮，因此您必须处理被按下的按钮第一个。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将继续探索不同的代码路径：</font></font><br><br><ul><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在地址处按RIGHT时，取值为9 </font></font><code>8040ece8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按下地址上的右键C时，取值为8 </font></font><code>8040eccc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当在地址处按左按钮C时，取值为7 </font></font><code>8040ecb0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在地址处按LEFT键时，取值为6 </font></font><code>8040ec98</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当在地址处按DOWN时，取值5（而r6取值1）</font></font><code>8040ec7c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按下地址上的上按钮C时，值为4 </font></font><code>8040ec64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按下地址上的下按钮C时，值为3 </font></font><code>8040ec48</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在地址上按UP时，取值为2 </font></font><code>8040ec30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在地址处按Z时</font><font style="vertical-align: inherit;">，取值1（并</font><font style="vertical-align: inherit;">取值1）</font></font><code>8040ec1c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前顺序为：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z，UP，C-DOWN，C-UP，DOWN，LEFT，C-LEFT，C-RIGHT，RIGHT，A + B，START </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在检查Z之前，还要检查另外一种情况：尽管应该按下一个新按钮Z，当前标志必须相等</font></font><code>0x2030</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：必须同时按下左右保险杠（它们的值为</font></font><code>0x10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>0x20</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">另外，上/下/左/右是D-pad按钮，不是模拟摇杆。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 作弊代码 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完全组合看起来像这样： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 握住保险杠L + R，然后按Z </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 向上 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C-DOWN </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C-up </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D向下 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D向左 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C向左 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 右 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D-右 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A + B </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开始 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效！</font><font style="vertical-align: inherit;">将控制器连接到第二个端口并输入代码，然后显示调试信息。</font><font style="vertical-align: inherit;">之后，您可以开始按下第二个（甚至第三个）控制器上的按钮以执行各种操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该组合无需更改游戏版本号即可使用。</font><font style="vertical-align: inherit;">它甚至可以在没有任何作弊工具或游戏机模组的情况下，用于游戏的常规零售副本中。</font><font style="vertical-align: inherit;">重新输入连击将禁用zuru模式。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/fe4/7f0/b4dfe47f0139ba1af039decfb6274524.jpg" alt="在真实的GameCube上使用代码"></div><br><font style="vertical-align: inherit;"></font><code>zurumode_callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在磁盘ID已经相等的情况下输入组合</font></font><code>0x99</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（可能是为了调试作弊代码本身）</font><font style="vertical-align: inherit;">，则消息“ ZURU％d /％d” </font><font style="vertical-align: inherit;">用于显示此组合的状态</font><font style="vertical-align: inherit;">。第一个数字是您在序列中的当前位置，即</font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。第二个取值为1，当按住序列中的某些按钮时，它们可以对应于</font></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配值1 </font><font style="vertical-align: inherit;">时的</font><font style="vertical-align: inherit;">情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大多数消息在屏幕上都没有解释它们的作用，因此，要了解其用途，您需要找到处理它们的功能。例如，屏幕顶部的一排长长的蓝色和红色星星是占位符，用于显示各种任务的状态。激活任务后，那里会显示一些数字，报告任务的状态。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按下Z所显示的黑屏是用于显示调试消息的控制台，特别是针对低级方面（例如内存分配，堆错误和其他不良异常）的控制台。根据行为，</font></font><code>fault_callback_scroll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以假定它用于在系统重新启动之前显示这些错误。它不会引发任何这些错误，但是会导致它们打印多个NOP的垃圾字符。我认为将来对显示您自己的调试消息将非常有用：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b06/755/a33/b06755a33e0b0b8b010b7cbff7a26594.png" alt="JUTConsole垃圾字符"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成所有这些操作后，我发现</font><font style="vertical-align: inherit;">其他人已经知道</font><font style="vertical-align: inherit;">通过修补</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本</font><font style="vertical-align: inherit;">ID进入调试模式</font></font><code>0x99</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">//tcrf.net/Animal_Crossing#Debug_Mode</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">（在链接上也有很多不错的注释，它们指示各种消息，并讨论了端口3中的控制器可以完成的其他操作。）但是，据我所知，还没有人发布欺骗组合。</font></font><br><br> 仅此而已。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我还想探索其他开发人员功能，例如卡的调试屏幕和NES仿真器选择屏幕，以及如何在不使用补丁的情况下激活它们。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/258/eb3/445/258eb3445236357c201c343d6c8ae4ba.png" alt="地图选择画面"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 另外，我将发表有关对话系统，事件和任务的逆向工程的文章，以创建mod为目标。 </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413967/">https://habr.com/ru/post/zh-CN413967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413955/index.html">IoT设备的完整开发周期，用于在Arduino环境中对ESP8266进行泳池加热控制</a></li>
<li><a href="../zh-CN413957/index.html">在Node.js上创建实时体育应用程序的示例</a></li>
<li><a href="../zh-CN413959/index.html">最小的Docker映像-小于1000字节</a></li>
<li><a href="../zh-CN413963/index.html">小型企业的小型CRM</a></li>
<li><a href="../zh-CN413965/index.html">代码审查：您做错了</a></li>
<li><a href="../zh-CN413969/index.html">拉斯基技术园-数十亿预算的创新发展</a></li>
<li><a href="../zh-CN413971/index.html">10多种面向语言学习者的英语新闻媒体</a></li>
<li><a href="../zh-CN413973/index.html">Cavium ThunderX2评估：Arm Server的梦想成真（第2部分）</a></li>
<li><a href="../zh-CN413977/index.html">为小型企业构建扩展的防病毒保护系统。 第三部分</a></li>
<li><a href="../zh-CN413979/index.html">米塔普“如何管理行会和社区？” 来自Tutu.ru和AgileVerse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>