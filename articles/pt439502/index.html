<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù§Ô∏è üôãüèΩ üèóÔ∏è Comportamento indefinido e verdade n√£o definida üïö üê° üßóüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O termo "comportamento indefinido" na linguagem C e C ++ designa uma situa√ß√£o na qual literalmente "o que simplesmente n√£o acontece". Historicamente, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comportamento indefinido e verdade n√£o definida</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/439502/">  O termo <b>"comportamento indefinido"</b> na linguagem C e C ++ designa uma situa√ß√£o na qual literalmente "o que simplesmente n√£o acontece".  Historicamente, os casos em que os compiladores C anteriores (e as arquiteturas nele) se comportavam de maneira incompat√≠vel eram atribu√≠dos a um comportamento indefinido, e o comit√™ para desenvolver o padr√£o, em sua sabedoria ilimitada, decidiu n√£o decidir nada sobre isso (ou seja, n√£o dar prefer√™ncia) algumas das implementa√ß√µes concorrentes).  O comportamento indefinido tamb√©m foi chamado de situa√ß√µes poss√≠veis nas quais o padr√£o, geralmente t√£o exaustivo, n√£o prescreveu nenhum comportamento espec√≠fico.  Esse termo tem um terceiro significado, que em nosso tempo est√° se tornando cada vez mais relevante: comportamento indefinido - essa √© a oportunidade de otimiza√ß√£o.  E os desenvolvedores em C e C ++ <i>adoram</i> otimiza√ß√µes;  eles exigem insistentemente que os compiladores fa√ßam todos os esfor√ßos para acelerar o c√≥digo. <br><br>  <i>Este artigo foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>publicado</i></a> pela primeira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>vez</i></a> no site de servi√ßos de criptografia.</i>  <i>A tradu√ß√£o √© publicada com permiss√£o do autor Thomas Pornin.</i> <br><a name="habracut"></a><br>  Aqui est√° um exemplo cl√°ssico: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Compilaremos esse c√≥digo GCC em uma plataforma x86 de 64 bits para Linux (eu trabalho na vers√£o mais recente do Ubuntu 18.04, vers√£o GCC - 7.3.0).  <i>Ativamos</i> a otimiza√ß√£o total e, em seguida, analisamos a lista do assembler, para a qual usamos as teclas <i>"-W -Wall -O9 -S</i> " (o argumento " <i>-O9</i> " define o n√≠vel m√°ximo de otimiza√ß√£o do GCC, que na pr√°tica √© equivalente a " <i>-O3</i> ", embora em alguns garfos N√≠veis definidos e mais altos do CCG).  Temos o seguinte resultado: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Cada uma das duas primeiras instru√ß√µes <i>movupd</i> move dois valores <i>duplos</i> para o registro SSE2 de 128 bits (o <i>dobro</i> tem um tamanho de 64 bits, para que o registro SSE2 possa armazenar dois valores <i>duplos</i> ).  Em outras palavras, quatro valores iniciais s√£o lidos primeiro e somente depois s√£o <i>convertidos</i> para <i>int</i> (opera√ß√£o <i>cvttpd2dq</i> ).  A opera√ß√£o <i>punpcklqdq</i> move os quatro n√∫meros inteiros de 32 bits recebidos em um registro SSE2 <i>(% xmm0</i> ), cujo conte√∫do √© gravado na RAM ( <i>movimentos</i> ).  E agora o principal: nosso programa C exige formalmente que o acesso √† mem√≥ria ocorra na seguinte ordem: <br><br><ul><li>  Leia o primeiro valor <i>duplo</i> de <i>src [0]</i> . </li><li>  Escreva o primeiro valor do tipo <i>int</i> em <i>dst [0]</i> . </li><li>  Leia o segundo valor <i>duplo</i> de <i>src [1]</i> . </li><li>  Escreva o segundo valor do tipo <i>int</i> em <i>dst [1]</i> . </li><li>  Leia o terceiro valor <i>duplo</i> de <i>src [2]</i> . </li><li>  Escreva o terceiro valor do tipo <i>int</i> para <i>dst [2]</i> . </li><li>  Leia o quarto valor <i>duplo</i> de <i>src [3]</i> . </li><li>  Escreva o quarto valor do tipo <i>int</i> em <i>dst [3]</i> . </li></ul><br>  No entanto, todos esses requisitos fazem sentido apenas no contexto de uma m√°quina abstrata, que o padr√£o C define;  o procedimento em uma m√°quina real pode variar.  O compilador √© livre para reorganizar ou modificar opera√ß√µes, desde que seu resultado n√£o contradiga a sem√¢ntica da m√°quina abstrata (a chamada regra como se √© "como se").  No nosso exemplo, a ordem de a√ß√£o √© apenas diferente: <br><br><ul><li>  Leia o primeiro valor <i>duplo</i> de <i>src [0]</i> . </li><li>  Leia o segundo valor <i>duplo</i> de <i>src [1]</i> . </li><li>  Leia o terceiro valor <i>duplo</i> de <i>src [2]</i> . </li><li>  Leia o quarto valor <i>duplo</i> de <i>src [3]</i> . </li><li>  Escreva o primeiro valor do tipo <i>int</i> em <i>dst [0]</i> . </li><li>  Escreva o segundo valor do tipo <i>int</i> em <i>dst [1]</i> . </li><li>  Escreva o terceiro valor do tipo <i>int</i> para <i>dst [2]</i> . </li><li>  Escreva o quarto valor do tipo <i>int</i> em <i>dst [3]</i> . </li></ul><br>  Esta √© a linguagem C: todo o conte√∫do da mem√≥ria √©, em √∫ltima inst√¢ncia, bytes (ou seja, slots com valores do tipo <i>char n√£o assinado</i> , mas na pr√°tica, grupos de oito bits) e qualquer opera√ß√£o arbitr√°ria de ponteiro √© permitida.  Em particular, os ponteiros <i>src</i> e <i>dst</i> podem ser usados ‚Äã‚Äãpara acessar partes sobrepostas da mem√≥ria quando chamadas (essa situa√ß√£o √© chamada de "alias").  Portanto, a ordem de leitura e grava√ß√£o pode ser importante se os bytes forem gravados e depois lidos novamente.  Para que o comportamento real do programa corresponda ao resumo definido pelo padr√£o C, o compilador precisar√° alternar entre opera√ß√µes de leitura e grava√ß√£o, fornecendo um ciclo completo de acessos √† mem√≥ria a cada itera√ß√£o.  O c√≥digo resultante seria maior e funcionaria muito mais devagar.  Para desenvolvedores C, isso seria uma tristeza. <br><br>  Felizmente, aqui o <i>comportamento indefinido</i> vem em socorro.  O padr√£o C indica que os valores n√£o podem ser acessados ‚Äã‚Äãatrav√©s de ponteiros cujo tipo n√£o corresponde aos tipos atuais desses valores.  Simplificando, se o valor for gravado em <i>dst [0]</i> , onde <i>dst √©</i> um ponteiro <i>int</i> , os bytes correspondentes n√£o poder√£o ser lidos via <i>src [1]</i> , onde <i>src</i> √© um ponteiro <i>duplo</i> , pois nesse caso tentar√≠amos acessar value, que agora √© do tipo <i>int</i> , usando um ponteiro de um tipo incompat√≠vel.  Nesse caso, um comportamento indefinido ocorreria.  Isso √© afirmado no par√°grafo 7 da se√ß√£o 6.5 da norma ISO 9899: 1999 (‚ÄúC99‚Äù) (na nova edi√ß√£o 9899: 2018 ou ‚ÄúC17‚Äù, a reda√ß√£o n√£o mudou).  Esse requisito √© chamado de regra estrita de alias.  Como resultado, o compilador C pode agir com base no pressuposto de que as opera√ß√µes de acesso √† mem√≥ria que levam a um comportamento indefinido devido √† viola√ß√£o da regra estrita de alias n√£o ocorrem.  Portanto, o compilador pode reorganizar as opera√ß√µes de leitura e grava√ß√£o em qualquer ordem, pois n√£o deve acessar partes sobrepostas da mem√≥ria.  √â disso que se trata a otimiza√ß√£o de c√≥digo. <br><br>  O significado de comportamento indefinido, em resumo, √© o seguinte: o compilador pode assumir que n√£o haver√° comportamento indefinido e gerar c√≥digo com base nessa suposi√ß√£o.  No caso da regra estrita de alias - desde que o alias ocorra, o comportamento indefinido permite otimiza√ß√µes importantes que seriam dif√≠ceis de implementar.  De um modo geral, cada instru√ß√£o nos procedimentos de gera√ß√£o de c√≥digo usados ‚Äã‚Äãpelo compilador possui depend√™ncias que restringem o algoritmo de planejamento da opera√ß√£o: uma instru√ß√£o n√£o pode ser executada antes das instru√ß√µes das quais depende ou ap√≥s as instru√ß√µes que dependem dela.  Em nosso exemplo, o comportamento indefinido elimina as depend√™ncias entre opera√ß√µes de grava√ß√£o nas opera√ß√µes <i>dst []</i> e ‚Äúsubsequentes‚Äù de leitura do <i>src []</i> : essa depend√™ncia pode existir apenas nos casos em que ocorre um comportamento indefinido ao acessar a mem√≥ria.  Da mesma forma, o conceito de comportamento indefinido permite que o compilador exclua simplesmente o c√≥digo que n√£o pode ser executado sem entrar em um estado de comportamento indefinido. <br><br>  Tudo isso, √© claro, √© bom, mas esse comportamento √†s vezes √© percebido como trai√ß√£o trai√ßoeira pelo compilador.  Voc√™ costuma ouvir a frase: "O compilador usa o conceito de comportamento indefinido como uma desculpa para quebrar meu c√≥digo".  Suponha que algu√©m escreva um programa que adicione n√∫meros inteiros e os medos excedam - lembre-se do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caso do Bitcoin</a> .  Ele pode pensar assim: para representar n√∫meros inteiros, o processador usa c√≥digo adicional, o que significa que, se ocorrer um estouro, isso acontecer√° porque o resultado ser√° truncado para o tamanho do tipo, ou seja,  32 bit  Isso significa que o resultado do estouro pode ser previsto e verificado com um teste. <br><br>  Nosso desenvolvedor condicional escrever√° isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Agora vamos tentar compilar esse c√≥digo usando o GCC: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Ok, parece funcionar.  Agora tente outro compilador, por exemplo, Clang (eu tenho a vers√£o 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  O que? <br><br>  Acontece que quando uma opera√ß√£o com tipos de n√∫meros inteiros assinados leva a um resultado que n√£o pode ser representado pelo tipo de destino, entramos no territ√≥rio de comportamento indefinido.  Mas o compilador pode assumir que isso n√£o acontece.  Em particular, otimizando a express√£o <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> , o compilador conclui que, como os valores de <i>xey s√£o</i> estritamente positivos, a terceira verifica√ß√£o n√£o pode ser verdadeira (a soma de dois valores n√£o pode ser menor que qualquer um deles), e voc√™ pode pular toda essa opera√ß√£o.  Em outras palavras, como o transbordamento √© um comportamento indefinido, "n√£o pode acontecer" do ponto de vista do compilador, e todas as instru√ß√µes que dependem desse estado podem ser exclu√≠das.  O mecanismo para detectar comportamento indefinido simplesmente desapareceu. <br><br>  O padr√£o nunca prescreveu a suposi√ß√£o de que ‚Äúsem√¢ntica assinada‚Äù (que √© realmente usada nas opera√ß√µes do processador) √© usada em c√°lculos com tipos assinados;  isso aconteceu bastante pela tradi√ß√£o - mesmo naqueles dias em que os compiladores n√£o eram inteligentes o suficiente para otimizar o c√≥digo, concentrando-se em v√°rios valores.  Voc√™ pode for√ßar o Clang e o GCC a aplicar a sem√¢ntica de quebra <i>autom√°tica</i> aos tipos assinados usando o sinalizador <i>-fwrapv</i> (no Microsoft Visual C, voc√™ pode usar <i>-d2UndefIntOverflow-,</i> conforme descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  No entanto, essa abordagem n√£o √© confi√°vel, o sinalizador pode desaparecer quando o c√≥digo √© transferido para outro projeto ou para outra arquitetura. <br><br>  Poucas pessoas sabem que o excesso de tipos de caracteres envolve um comportamento indefinido.  Isto √© afirmado no par√°grafo 5 da se√ß√£o 6.5 das normas C99 e C17: <br><br>  <i>Se ocorrer uma exce√ß√£o ao avaliar uma express√£o (ou seja, se o resultado n√£o estiver definido matematicamente ou estiver fora do intervalo de valores v√°lidos de um determinado tipo), o comportamento ser√° indefinido.</i> <br><br>  Para tipos n√£o assinados, no entanto, a sem√¢ntica modular √© garantida.  O par√°grafo 9 da se√ß√£o 6.2.5 diz o seguinte: <br><br>  <i>O estouro nunca ocorre nos c√°lculos com operandos n√£o assinados, pois um resultado que n√£o pode ser representado pelo tipo inteiro n√£o assinado resultante √© truncado no m√≥dulo um n√∫mero que √© um a mais que o valor m√°ximo representado pelo tipo resultante.</i> <br><br>  Outro exemplo de comportamento indefinido em opera√ß√µes com tipos assinados √© a opera√ß√£o de divis√£o.  Como todos sabem, o resultado da divis√£o por zero n√£o √© matematicamente determinado; portanto, de acordo com o padr√£o, essa opera√ß√£o implica um comportamento indefinido.  Se o divisor for zero na opera√ß√£o <i>idiv</i> no processador x86, uma exce√ß√£o do processador ser√° lan√ßada.  Como solicita√ß√µes de interrup√ß√£o, as exce√ß√µes do processador s√£o tratadas pelo sistema operacional.  Em sistemas tipo Unix, como o Linux, a exce√ß√£o do processador acionada pela opera√ß√£o <i>idiv</i> √© convertida em um sinal <i>SIGFPE</i> , enviado ao processo e termina com o manipulador padr√£o (n√£o se surpreenda que ‚ÄúFPE‚Äù represente ‚Äúexce√ß√£o de ponto flutuante‚Äù (exce√ß√£o em opera√ß√µes de ponto flutuante), enquanto o <i>idiv</i> trabalha com n√∫meros inteiros).  Mas h√° outra situa√ß√£o que leva a um comportamento indefinido.  Considere o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; }  : $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  E a verdade √©: nesta m√°quina (o mesmo x86 para Linux), o tipo <i>int</i> representa um intervalo de valores de -2.147.483.648 a +2.147.483.647. Se voc√™ dividir -2.147.483.648 por -1, dever√° obter +2.147.483.648 Mas esse n√∫mero n√£o est√° no intervalo de valores <i>int</i> .  Portanto, o comportamento n√£o est√° definido.  Tudo pode acontecer.  Nesse caso, o processo √© encerrado √† for√ßa.  Em outro sistema, especialmente com um processador pequeno que n√£o possui uma opera√ß√£o de divis√£o, o resultado pode variar.  Nessas arquiteturas, a divis√£o √© realizada programaticamente - com a ajuda do procedimento normalmente fornecido pelo compilador, e agora ele pode fazer o que bem entender com um comportamento indefinido, porque √© exatamente isso que √©. <br><br>  Observo que o <i>SIGFPE</i> pode ser obtido nas mesmas condi√ß√µes e com a ajuda do operador do m√≥dulo ( <i>%</i> ).  E, de fato: nela est√° a mesma opera√ß√£o de <i>identifica√ß√£o</i> , que calcula o quociente e o restante, de modo que a mesma exce√ß√£o do processador √© acionada.  Curiosamente, o padr√£o C99 diz que a express√£o <i>INT_MIN% -1</i> n√£o pode levar a um comportamento indefinido, pois o resultado √© matematicamente definido (zero) e entra claramente no intervalo de valores do tipo de destino.  Na vers√£o C17, o texto do par√°grafo 6 da se√ß√£o 6.5.5 foi alterado e agora esse caso tamb√©m √© levado em considera√ß√£o, o que aproxima o padr√£o da situa√ß√£o real em plataformas de hardware comuns. <br><br>  Existem muitas situa√ß√µes n√£o √≥bvias que tamb√©m levam a um comportamento indefinido.  D√™ uma olhada neste c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  Voc√™ acha que um programa, seguindo o padr√£o C, deve ser impresso se passarmos os fatores 45.000 e 50.000 para a fun√ß√£o? <br><br><ul><li>  18.048 </li><li>  2.250.000.000 </li><li>  Deus salve a rainha! </li></ul><br>  A resposta correta ... sim, todas as op√ß√µes acima!  Voc√™ pode ter argumentado assim: como um <i>curto n√£o assinado</i> √© um tipo n√£o assinado, ele deve suportar o m√≥dulo de sem√¢ntica de empacotamento 65 536, porque em um processador x86 o tamanho desse tipo, via de regra, √© exatamente de 16 bits (o padr√£o tamb√©m permite um tamanho maior, mas na pr√°tica, esse ainda √© um tipo de 16 bits).  Como matematicamente o produto √© 2.250.000.000, ser√° truncado o m√≥dulo 65.536, que fornece uma resposta de 18.048. No entanto, pensando assim, esquecemos a extens√£o dos tipos inteiros.  De acordo com o padr√£o C (se√ß√£o 6.3.1.1, par√°grafo 2), se os operandos s√£o de um tipo cujo tamanho √© estritamente menor que o tamanho de <i>int</i> , e os valores desse tipo podem ser representados pelo tipo <i>int</i> sem perda de bits (e apenas temos este caso: no meu x86 em O Linux tem um tamanho <i>int</i> de 32 bits e pode armazenar explicitamente valores de 0 a 65.535); ent√£o, os dois operandos s√£o convertidos em <i>int</i> e a opera√ß√£o j√° √© executada nos valores convertidos.  A saber: o produto √© calculado como um valor do tipo <i>int</i> e, somente ao retornar da fun√ß√£o, √© trazido de volta para um <i>curto n√£o assinado</i> (isto √©, neste momento ocorre o m√≥dulo de truncamento 65 536).  O problema √© que matematicamente o resultado antes da transforma√ß√£o inversa √© de 2.250 milh√µes e esse valor excede o intervalo de <i>int</i> , que √© um tipo assinado.  Como resultado, temos um comportamento indefinido.  Depois disso, tudo pode acontecer, incluindo ataques repentinos de patriotismo ingl√™s. <br><br>  No entanto, na pr√°tica, com compiladores comuns, o resultado √© 18.048, uma vez que ainda n√£o h√° otimiza√ß√£o que possa tirar proveito do comportamento indefinido nesse programa em particular (pode-se imaginar cen√°rios mais artificiais onde isso realmente causaria problemas). <br><br>  Finalmente, outro exemplo, agora em C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  Este n√£o √© o t√≠pico ‚Äúp√©ssimo p√©ssimo <i>strcpy ()</i> !‚Äù Para voc√™.  De fato, aqui a fun√ß√£o <i>strcpy ()</i> √© executada apenas se o tamanho da string de origem, incluindo o terminal zero, for pequeno o suficiente.  Al√©m disso, os elementos da matriz s√£o explicitamente inicializados como zero, portanto, todos os bytes da matriz t√™m um determinado valor, independentemente de uma cadeia grande ou pequena ser passada para a fun√ß√£o.  Ao mesmo tempo, o loop no final est√° incorreto: ele l√™ um byte a mais do que deveria. <br><br>  Execute o c√≥digo: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo ++?</span></span></code> </pre> <br>  Voc√™ pode objetar ingenuamente: bem, ele l√™ um byte extra al√©m dos limites da matriz;  mas isso n√£o √© t√£o assustador, porque na pilha esse byte ainda est√° l√°, √© mapeado para a mem√≥ria, ent√£o o √∫nico problema aqui √© o d√©cimo s√©timo elemento extra com um valor desconhecido.  O ciclo ainda imprime exatamente 17 n√∫meros inteiros (em formato hexadecimal) e termina sem nenhuma reclama√ß√£o. <br><br>  Mas o compilador tem sua pr√≥pria opini√£o sobre esse assunto.  Ele est√° ciente de que a d√©cima s√©tima leitura provoca um comportamento indefinido.  Segundo sua l√≥gica, qualquer instru√ß√£o subsequente est√° no limbo: n√£o h√° exig√™ncia de que, ap√≥s um comportamento indefinido, alguma coisa exista (formalmente at√© instru√ß√µes anteriores podem estar sob ataque, pois o comportamento indefinido tamb√©m funciona na dire√ß√£o oposta).  No nosso caso, o compilador simplesmente ignorar√° a verifica√ß√£o da condi√ß√£o no loop e girar√° para sempre, ou melhor, at√© que comece a ler fora da mem√≥ria alocada para a pilha, ap√≥s a qual o sinal <i>SIGSEGV</i> funcionar√°. <br><br>  √â engra√ßado, mas se o GCC iniciar com configura√ß√µes menos agressivas para otimiza√ß√µes, ele emitir√° um aviso: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  Em <i>-O9,</i> esse aviso desaparece de alguma forma.  Talvez o fato seja que, em altos n√≠veis de otimiza√ß√£o, o compilador imponha mais agressivamente a implanta√ß√£o do loop.  √â poss√≠vel (mas impreciso) que esse seja um bug do GCC (no sentido de uma perda de aviso; portanto, as a√ß√µes do GCC em qualquer caso n√£o contradizem o padr√£o, porque n√£o requer a emiss√£o de "diagn√≥sticos" nessa situa√ß√£o). <br><br>  Conclus√£o: se voc√™ estiver escrevendo c√≥digo em C ou C ++, seja extremamente cuidadoso e evite situa√ß√µes que levem a um comportamento indefinido, mesmo quando parecer que est√° tudo bem. <br><br>  Os tipos inteiros n√£o assinados s√£o um bom auxiliar nos c√°lculos aritm√©ticos, uma vez que s√£o sem√¢nticas modulares garantidas (mas voc√™ ainda pode obter problemas relacionados √† extens√£o dos tipos inteiros).  Outra op√ß√£o - por algum motivo impopular - n√£o √© escrever em C e C ++.  Por v√°rias raz√µes, essa solu√ß√£o nem sempre √© adequada.  Mas se voc√™ pode escolher em qual idioma gravar o programa, ou seja,  quando voc√™ est√° apenas iniciando um novo projeto em uma plataforma que suporta Go, Rust, Java ou outras linguagens, pode ser mais rent√°vel recusar usar C como a "linguagem padr√£o".  A escolha de ferramentas, incluindo uma linguagem de programa√ß√£o, √© sempre um compromisso.  As armadilhas de C, especialmente o comportamento indefinido em opera√ß√µes com tipos assinados, levam a custos adicionais para manuten√ß√£o adicional do c√≥digo, que geralmente s√£o subestimados. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439502/">https://habr.com/ru/post/pt439502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439490/index.html">Tipos de refer√™ncia do .NET vs tipos de valor. Parte 2</a></li>
<li><a href="../pt439492/index.html">10 dicas para ser um bom l√≠der t√©cnico</a></li>
<li><a href="../pt439496/index.html">Como o faturamento √© feito l√°: quando o cliente e o desenvolvedor falam idiomas diferentes</a></li>
<li><a href="../pt439498/index.html">Em qual hardware analisar uma enorme quantidade de informa√ß√µes?</a></li>
<li><a href="../pt439500/index.html">Por que os captchas se tornam t√£o complicados</a></li>
<li><a href="../pt439504/index.html">Sua equipe precisa de um engenheiro de dados?</a></li>
<li><a href="../pt439506/index.html">9 alternativas para uma equipe ruim (padr√£o de design)</a></li>
<li><a href="../pt439508/index.html">Mitap sobre desenvolvimento de c√≥digo aberto em Moscou</a></li>
<li><a href="../pt439510/index.html">Sistema de controle distribu√≠do altamente carregado de uma moderna usina nuclear</a></li>
<li><a href="../pt439512/index.html">A idade dos dinossauros ou resseguro legalmente verificado?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>