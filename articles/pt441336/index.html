<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚒 🚶🏿 👩🏽‍🤝‍👨🏿 RTOS ou não RTOS é a questão 🆙 👨‍🎤 👩🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fui solicitado a escrever este artigo por um longo ramo de comentários (infelizmente não posso chamar isso de discussão) ao meu artigo recente "O mund...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RTOS ou não RTOS é a questão</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/441336/"><img src="https://habrastorage.org/files/3ff/676/da5/3ff676da5b2f4acabdd782f871f1b782.jpg" alt="imagem" align="right">  Fui solicitado a escrever este artigo por um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">longo ramo de comentários</a> (infelizmente não posso chamar isso de discussão) ao meu artigo recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"O mundo diversificado dos sistemas embarcados e o lugar da Embox nele"</a> .  Fui criticado em vários lugares por confundir o RTOS e o Embedded OS, que chamei de LynxOS, QNX e VxWorks e não RTOS, embora, na minha opinião, é claro, não o fizesse.  Eu sugeri o autor desses comentários várias vezes para escrever um artigo no qual ele declararia sua visão do conceito de "sistema operacional em tempo real", mas por algum motivo ele recusou.  Bem, apresentarei minha visão desse termo e vamos discutir como o RTOS pode ser chamado e o que não pode.  No final, essa pergunta é freqüentemente feita em relação à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Embox</a> . <br><a name="habracut"></a><br><h2>  O termo OS RV (RTOS) refere-se ao campo do marketing! </h2><br>  Pensei em começar de maneira científica, com a introdução de termos, mas decidi que essa tese provocativa seria muito bem-vinda.  Então, por que argumento que o termo RTOS (sistemas operacionais em tempo real) se refere a marketing, mais precisamente, é um slogan de marketing (publicidade)?  Tudo é simples.  Quando um produto é produzido, ele precisa ser vendido.  Mas se você tentar vender apenas o sistema operacional, surgirão dificuldades.  É aqui que o posicionamento do mercado vem em socorro.  Por exemplo, você poderia dizer "somos mais rápidos que eles". <br><br><div class="spoiler">  <b class="spoiler_title">Fato interessante:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O QNX foi originalmente chamado de Quick Unix (Qunix), "O sistema operacional era originalmente chamado de Qunix," Quick UNIX ", até que eles receberam uma carta educada dos advogados da AT&amp;T pedindo que mudassem o nome".</a> <br></div></div><br>  Mas você pode ir a tribunal por isso!  E aí você precisará fornecer evidências.  Mas como provar que você é mais rápido em todos os casos?  Esta não é uma competição em andamento.  Mas é claro que essa concorrência não totalmente correta está um pouco fora do posicionamento normal do mercado. <br><br>  O posicionamento normal envolve a formação de um retrato do consumidor, identificando as propriedades do produto com maior demanda e concentrando-se nessas propriedades.  Bem, ou você forma essas necessidades no usuário.  Por exemplo, nosso processador tem essa frequência, o smartphone tem um processador N-core e assim por diante. <br><br>  Como os clássicos do gênero já formularam que os sistemas operacionais são necessários não apenas para os sistemas do usuário, mas também para controlar vários processos tecnológicos no modo automático e até introduziram o conceito de sistema operacional em tempo real, é um pecado não usá-lo.  Introduzindo o conceito de sistemas em tempo real, os clássicos falaram de um certo limite crítico de tempo.  Ou seja, difere dos sistemas convencionais, onde, se o usuário espera por algo, ele pode esperar, um sistema rígido em tempo real, por exemplo, controlar uma turbina, não pode esperar, caso contrário, você pode rolar para algo ruim. <br><br>  Assim, você pode dizer ao usuário que, diferentemente dos sistemas operacionais convencionais, eles receberão um sistema que garante o tempo de resposta do sistema.  Naturalmente, quanto menor, maior o número de diferentes processos tecnológicos que o sistema pode controlar.  E muitas tabelas aparecem onde vários parâmetros-chave do RTOS são dados como um parâmetro-chave. <br><br>  Como eles são recebidos?  Este processo é descrito honestamente!  Aqui tomamos um problema de modelo e de plataforma de hardware e aplicamos o efeito.  Bem, o marketing, é claro, pode simplificar e distribuir, um tempo de reação de 1 μs.  Mas não levamos isso em consideração, acreditamos que tudo é descrito honestamente. <br><br>  Mas com licença, e se houver outra tarefa?  10 tarefas, 100 tarefas?  E se um programador bêbado trava interrompe?  E se no sistema o programador não priorizar corretamente as tarefas? <br><br>  Houve um caso em que a Embox passou nos testes em tempo real.  Sentamos e pensamos em como provar que este é um sistema operacional em tempo real.  Existe um laboratório, há um cliente que quer que seja assim.  Descobrimos que, para o cliente em tempo real, o tempo de resposta do sistema é de 1 µs.  Pergunto se o seguinte experimento será evidência: <br><br><ul><li>  Tomamos uma certa plataforma de hardware </li><li>  Aplique um sinal a uma das entradas GPIO </li><li>  Capturar programaticamente um evento </li><li>  Na saída GPIO, sinalizamos programaticamente </li><li>  As medições são realizadas usando um osciloscópio, o tempo de reação será a diferença entre as frentes de entrada e saída. </li></ul><br>  O cliente confirma que é exatamente isso que é necessário.  Faço uma pergunta esclarecedora e estamos projetando um sistema modelo e talvez não o inicie (não carregue) com outras tarefas.  Ou seja, é normal que o sistema faça apenas uma tarefa de teste tão simples.  O cliente disse que isso requer tarefas de teste.  Provavelmente você mesmo entende que o sistema passou nos testes!  Naturalmente, com a confirmação das características, ou seja, o impacto foi repetido. <br><br>  Esta seção não é de forma alguma escrita para depreciar qualquer sistema operacional ou qualquer desenvolvedor.  Mas apenas para mostrar toda a incompletude da imagem.  Não afirmei que as características de alguns sistemas operacionais não permitem que elas sejam atribuídas ao RTOS, mas apenas esse termo é usado pelos profissionais de marketing.  Vi outros testes quando pedi a escolha do sistema operacional de um laboratório independente com base nos requisitos da tarefa.  Havia um conjunto complexo de tarefas de modelo, e a interação da rede foi considerada, e como os parâmetros mudam se o sistema estiver carregado e o comportamento em várias situações de emergência. <br><br><h2>  Definição do termo "sistema operacional em tempo real" </h2><br>  Agora vou apresentar o termo "sistema operacional em tempo real".  Não, não vou.  O fato é que existem muitas definições desse termo.  Pegue pelo menos os comentários no artigo original: <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Em sistemas em tempo real, uma pessoa geralmente é supérflua e, portanto, a velocidade de um sistema em tempo real deve ser comparada com os processos que ele controla, seja um carro autônomo ou um sistema de controle de processo em uma fábrica.</a> </blockquote><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SRV / RTOS - este é apenas um ranking da previsibilidade da resposta a eventos críticos.</a> </blockquote><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O RTOS é um sistema operacional no qual a correção de uma tarefa é caracterizada não apenas pela correção lógica, mas pelo tempo necessário para concluir essa tarefa.</a> </blockquote><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Defina o critério para alternar o contexto de qualquer tarefa para 1 µs por processador de 100 MHz com um coprocessador de ponto flutuante com uma determinação de 0,1 µs e tudo se encaixará.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Você verá claramente onde e onde não está o RTOS.</a> </blockquote>  Bem, não posso ignorar a opinião de que falei em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> que foi dublado em uma das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conferências da OSDAY</a> : <br><blockquote>  Um sistema pode ser considerado um sistema rígido em tempo real se não houver locais onde, com interrupções bloqueadas, haja ciclos com um número desconhecido de iterações. </blockquote>  Mas talvez seja tudo apenas particular e, como sugerido nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comentários</a> , você só precisa usar os clássicos e não criar bicicletas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vou citar o</a> clássico especificado (Andrew Tanenbaum, se alguém não adivinhou): <br><blockquote>  “Outro tipo de sistema operacional é o sistema em tempo real.  Esses sistemas são caracterizados por ter o tempo como um parâmetro-chave.  Por exemplo, nos sistemas de controle de processos industriais, os computadores em tempo real precisam coletar dados sobre o processo de produção e usá-los para controlar as máquinas na fábrica.  Muitas vezes, existem prazos rígidos que devem ser cumpridos.  Por exemplo, se um carro estiver descendo uma linha de montagem, determinadas ações deverão ocorrer em determinados instantes de tempo.  Se um robô de solda soldar muito cedo ou muito tarde, o carro será arruinado.  Se a ação absolutamente deve ocorrer em um determinado momento (ou dentro de um determinado intervalo), temos um sistema rígido em tempo real.  Muitos deles são encontrados nas áreas de controle de processos industriais, aviônicos, militares e aplicações similares.  Esses sistemas devem fornecer garantias absolutas de que uma determinada ação ocorrerá em um determinado período de tempo. <br><br>  Outro tipo de sistema em tempo real é um sistema flexível em tempo real, no qual a falta de um prazo ocasional, embora não seja desejável, é aceitável e não causa nenhum dano permanente.  Os sistemas de áudio ou multimídia digital se enquadram nessa categoria.  Os telefones digitais também são sistemas suaves em tempo real. <br><br>  Como o cumprimento de prazos estritos é crucial nos sistemas em tempo real, às vezes o sistema operacional é simplesmente uma biblioteca vinculada aos programas aplicativos, com tudo firmemente acoplado e sem proteção entre partes do sistema.  Um exemplo desse tipo de sistema em tempo real é o e-Cos. <br><br>  As categorias de computadores de mão, sistemas embarcados e sistemas em tempo real se sobrepõem significativamente.  Quase todos eles têm pelo menos alguns aspectos suaves em tempo real.  Os sistemas embarcados e em tempo real executam apenas o software instalado pelos projetistas do sistema;  os usuários não podem adicionar seu próprio software, o que facilita a proteção.  Os computadores de mão e os sistemas embarcados são destinados aos consumidores, enquanto os sistemas em tempo real são mais para uso industrial.  No entanto, eles têm uma certa quantidade em comum. ” </blockquote>  Porém, a partir dessa descrição, segue-se apenas que sistemas podem ser usados ​​em sistemas em que a ausência de reação dentro de um determinado período pode levar a conseqüências desastrosas.  Bem, para atingir um parâmetro-chave (não excedendo o tempo de reação), o sistema operacional pode ser uma biblioteca, um exemplo de eCos. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre tempo real suave e difícil</b> <div class="spoiler_text">  Eu deliberadamente não percebi a divisão entre soft e hard, pois qualquer sistema operacional universal moderno pode ser considerado um sistema em tempo real, bem, por exemplo, o Windows reproduz arquivos multimídia perfeitamente.  E eu entendo que aqui havia mais sobre todos os tipos de DSPs, ou seja, processamento de sinal.  Mas se também considerarmos essa parte, nunca a terminaremos.  Em geral, a seguir, queremos dizer apenas sistemas em que é impossível violar o limite de tempo, ou seja, em tempo real difícil. <br></div></div><br><h2>  Como obter características em tempo real </h2><br>  Eu não poderia dar uma definição estrita (se alguém estiver pronto para dar, escreva nos comentários).  Mas em todas as definições acima, algumas propriedades são visíveis (desta vez e previsíveis).  Se você converter o tempo na opção de previsibilidade (o peso do arco ao passar de um estado para outro), apenas a previsibilidade permanece! <br><br>  Vamos pensar em como conseguir isso. <br><br>  Será óbvio remover todos os desnecessários do sistema crítico.  É improvável que um sistema universal seja estável.  Até o camarada Tanenbaum falou sobre isso, quero dizer, quando ele falou sobre eCos. <br><br>  Outra abordagem que aumenta a previsibilidade do sistema, novamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">proposta por Tanenbaum</a> , é o uso de algoritmos especiais (simples) para o planejamento de recursos, principalmente o tempo do processador, ou seja, agendadores de tarefas especiais.  Ele sugeriu várias abordagens para o planejamento, mas eu gostaria de focar primeiro na tabela estática orientada a tabelas. <br><br>  O desenvolvedor deve garantir que todas as tarefas tenham êxito na conclusão do intervalo de tempo.  Para isso, propõe-se analisar estaticamente a tarefa crítica e determinar seus valores limite.  Essa abordagem é estabelecida na norma ARINC-653.  O padrão para sistemas de bordo, e você mesmo entende, se algo de repente não tiver tempo para trabalhar no avião, uma catástrofe pode acontecer. <br><br>  A próxima abordagem é uma programação estática, mas baseada em prioridades.  Ou seja, o desenvolvedor deve analisar novamente todas as situações e, tendo atribuído todas as tarefas nas prioridades do sistema, garantir que tarefas críticas sejam concluídas em um determinado momento. <br><br>  Não quero continuar, porque há um original!  Está escrito, é claro, melhor do que eu posso fazer e, além disso, eles podem ser novamente acusados ​​de distorcer os fatos.  Citei precisamente essas abordagens para mostrar que, em qualquer caso, o desenvolvedor do sistema final tem a responsabilidade de garantir as características do sistema.  E o sistema operacional deve fornecer apenas os recursos apropriados. <br><br>  Continuando a discussão sobre métodos para aumentar a previsibilidade, quero fazer outro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comentário</a> <br><blockquote>  "Você pode obter tempo real em uma framboesa, mas não com o RTOS, mas com uma pequena máquina de estado invadindo seu cache". </blockquote>  Aqui eu quero prestar atenção aos seguintes pontos: <br><br><ul><li>  maior previsibilidade (propriedades em tempo real) devido à exclusão de qualquer RTOS do sistema </li><li>  representação de um programa por uma máquina de estado </li><li>  Bem, a dependência dos sistemas em tempo real não apenas nas propriedades do software, mas também no hardware. </li></ul><br>  Com uma diminuição na quantidade de imprevisibilidade no caso de uma diminuição no número de linhas de código, acho que todos concordam.  Embora, como sempre, eu não concorde, mas mais sobre isso mais tarde. <br><br>  Qual é a influência do hardware também provavelmente não está em dúvida.  Em particular, quando foi dito que não havia loops com um número arbitrário de iterações no estado de interrupções bloqueadas, parecia que em algum córtex-m no RTOS descrito não havia desconexão de interrupções.  Isso é um pouco astuto, porque o controlador de interrupção desativa as interrupções com prioridade igual ou inferior, independentemente, mas o fato da influência é óbvio.  E, é claro, a presença de cache, tradução de endereços (ou melhor, falta de páginas) contribui para a incerteza.  Especialmente, eu queria chamar a atenção para o fato de que, de fato, ninguém pode garantir cem por cento de operacionalidade correta do equipamento.  Bem, as postagens caíram de você, como a presença de um RTOS ajudará a evitar um resultado catastrófico de eventos? <br><br>  Representando o programa como uma máquina de estado, gostaria de propor considerá-lo de um lado não óbvio.  Ou seja, que um programa de previsibilidade pode ser analisado.  E como estamos falando de todas as condições, ela deve ser analisada, e estaticamente, para todas as situações possíveis.  Bem, como as linguagens de programação funcionais são muito mais adequadas para a análise estática, é possível desenvolver um programa em alguma linguagem especial ou adicionar o uso de linguagens de programação especiais.  A primeira abordagem é usada, por exemplo, no kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seL4</a> verificado.  Um exemplo da segunda abordagem é o mesmo padrão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ARINC-653</a> , com sua formação obrigatória de requisitos em XML. <br><br>  Existem outros métodos que aumentam a previsibilidade ou, se você preferir, fatores que afetam a previsibilidade do sistema.  Fiz um relatório sobre esse tópico em uma das conferências do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OSDay</a> .  Em particular, além dos já listados, destaquei uma abordagem arquitetônica.  Afinal, é sabido que, por exemplo, a arquitetura de microkernel pode aumentar a previsibilidade do sistema.  Mas, mesmo no mesmo relatório, uma abordagem organizacional um tanto óbvia foi destacada.  Esse é exatamente o ponto em que eu não concordo que a falta de RTOS leva a um aumento da previsibilidade.  Se você pensar bem, em geral, o conceito de sistema operacional reduziu significativamente o número de erros devido à reutilização do código.  Ou seja, se você não possui um código que realmente se encaixa em um switch / case, é melhor usar módulos prontos.  Afinal, o parâmetro "número de erros por 1.000 linhas de código" não foi cancelado e, independentemente de quão depurado seja o seu novo código, há erros. <br><br><h2>  O RTOS existe? </h2><br>  Tendo decidido a afirmação na seção anterior de que há erros em qualquer código, quero fazer mais uma tese provocativa.  O RTOS existe? <br><br>  Vamos descobrir.  Discutindo com um amigo sobre sistemas em tempo real, concordamos na medida em que um sistema operacional em tempo real (estamos falando de sistemas rígidos em tempo real) dificilmente pode existir.  Ele propôs representar todo o sistema como uma máquina ou gráfico de estados com uma descrição do tempo máximo de transição de um estado para outro.  Além disso, o sistema pode ser considerado estável se for provado que, para todas as entradas e estados internos, existe um arco que leva a um determinado estado com um limite de tempo.  Bem, você entende, isso é possível apenas para um sistema muito pequeno, apenas a própria máquina de estados mencionada no comentário, mas no mundo moderno poucas pessoas precisam desse sistema. <br><br>  Mas não temos dúvidas de que existem sistemas em tempo real.  E, claro, o RTOS também.  Se não fosse assim, <s>então o primeiro pica-pau voador destruiria a civilização,</s> não haveria aviônica, astronáutica, robótica, ACS-TP e muito mais. <br><br>  Como sair da situação.  É muito simples, embora em geral o problema seja provavelmente insolúvel, mas para um problema específico, é possível introduzir restrições que o tornem solucionável, com algum tipo de probabilidade significativa de erro. <br><br>  Por exemplo, são introduzidos padrões: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">POSIX em tempo real</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ARINC-653</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ITRON</a> .  Esses padrões, de fato, distinguem uma classe de tarefas que podem ser resolvidas se você aderir a esse padrão.  Ou estudos são realizados por laboratórios independentes que estudam se as propriedades de um sistema operacional específico são adequadas para resolver o problema-alvo. <br><br><h2>  Então Embox RTOS ou não RTOS? </h2><br>  Na minha opinião, para responder a uma pergunta semelhante, tanto para a Embox quanto para qualquer outro sistema operacional, você pode apenas perguntar: "O que você quer dizer?".  Mais precisamente: “O que você quer dizer com conceito de tempo real?”.  Ou seja, se o tempo de processamento da interrupção for de interesse e se for possível chamar diretamente o manipulador de interrupções, isso é uma coisa, se você precisar aumentar a confiabilidade do trabalho, embora devagar, mas certamente haverá muito menos probabilidade de falhar, essa é outra, a conformidade com qualquer padrão é a terceira, A verificação é a quarta.  Não é por acaso que o grande clássico Andrei Tanenbaum, embora tenha proposto métodos para aumentar a previsibilidade, usou o próprio conceito de sistema em tempo real, mas se absteve de quaisquer definições estritas. <br><br>  PS No momento da redação deste documento, nenhum RTOS foi afetado. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441336/">https://habr.com/ru/post/pt441336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441326/index.html">Pare de falar sobre "levar a segurança e a privacidade a sério"</a></li>
<li><a href="../pt441328/index.html">Sobre computação quântica e livre arbítrio</a></li>
<li><a href="../pt441330/index.html">[spoilers] Filme Terra Errante: O sol cai. Astronauta chinês e um russo com um frasco de vodka salvarão todos</a></li>
<li><a href="../pt441332/index.html">Colônia. Capítulo 26: Port Demetrio</a></li>
<li><a href="../pt441334/index.html">"Equipe elétrica" ​​- agora definitivamente</a></li>
<li><a href="../pt441338/index.html">Como criamos um sistema de pagamento em criptomoeda: cinco problemas principais</a></li>
<li><a href="../pt441340/index.html">A herança cultural do Cazaquistão em modelos 3D</a></li>
<li><a href="../pt441344/index.html">Entre no céu. Uma história honesta sobre uma paixão séria pelo paraquedismo</a></li>
<li><a href="../pt441346/index.html">Conheça um estrategista de conteúdo: uma entrevista com Dmitry Kabanov, curador do Techstars Startup Digest e consultor SXSW</a></li>
<li><a href="../pt441348/index.html">Roteamento direto e balanceamento com NFT vs Nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>