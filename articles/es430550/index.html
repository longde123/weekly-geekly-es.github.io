<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëá üë®üèΩ‚Äçüíª üî¨ Construyendo un sistema de componentes reactivos con Kotlin üíÖüèø üè≥Ô∏è üêí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Mi nombre es Anatoly Varivonchik, soy desarrollador de Android en Badoo. Hoy compartir√© con ustedes la traducci√≥n de la segunda parte de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construyendo un sistema de componentes reactivos con Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430550/"><img src="https://habrastorage.org/webt/9w/km/zp/9wkmzp6x1umysciwpqgvzuplf7y.png"><br><br>  Hola a todos!  Mi nombre es Anatoly Varivonchik, soy desarrollador de Android en Badoo.  Hoy compartir√© con ustedes la traducci√≥n de la segunda parte del art√≠culo de mi colega Zsolt Kocsi sobre la implementaci√≥n de MVI, que usamos diariamente en el proceso de desarrollo.  La primera parte est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  Que queremos y como lo hacemos </h2><br>  En la primera parte del art√≠culo, presentamos <b>Caracter√≠sticas</b> , los elementos centrales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MVICore</a> que pueden reutilizarse.  Pueden tener la estructura m√°s simple e incluir un solo <b>reductor</b> , o pueden convertirse en una herramienta completamente funcional para administrar tareas asincr√≥nicas, eventos y mucho m√°s. <br><br>  Cada caracter√≠stica es rastreable: existe la oportunidad de suscribirse a los cambios en su estado y recibir notificaciones al respecto.  Sin embargo, Feature se puede suscribir a una fuente de entrada.  Y esto tiene sentido, porque con la inclusi√≥n de Rx en la base del c√≥digo, ya tenemos muchos objetos y suscripciones observables en varios niveles. <br><br>  Es en relaci√≥n con el aumento en el n√∫mero de componentes reactivos que es hora de reflexionar sobre lo que tenemos y si es posible mejorar a√∫n m√°s el sistema. <br><a name="habracut"></a><br>  Tenemos que responder tres preguntas: <br><br><ol><li>  ¬øQu√© elementos deben usarse al agregar nuevos componentes reactivos? <br></li><li>  ¬øCu√°l es la forma m√°s f√°cil de administrar sus suscripciones? <br></li><li>  ¬øEs posible ignorar la administraci√≥n del ciclo de vida / la necesidad de borrar las suscripciones para evitar p√©rdidas de memoria?  En otras palabras, ¬øpodemos separar el enlace de componentes de la gesti√≥n de suscripci√≥n? <br></li></ol><br>  En esta parte del art√≠culo, veremos los conceptos b√°sicos y los beneficios de construir un sistema utilizando componentes reactivos y veremos c√≥mo Kotlin ayuda con esto. <br><br><h2>  Elementos principales </h2><br>  Cuando llegamos a trabajar en el dise√±o y la estandarizaci√≥n de nuestras <b>caracter√≠sticas</b> , ya hab√≠amos probado muchos enfoques diferentes y decidimos que las <b>caracter√≠sticas</b> estar√≠an en forma de componentes reactivos.  Primero, nos centramos en las interfaces principales.  En primer lugar, necesit√°bamos determinar los tipos de datos de entrada y salida. <br><br>  Razonamos de la siguiente manera: <br><br><ul><li>  No reinventemos la rueda, veamos qu√© interfaces ya existen. <br></li><li>  Como ya estamos usando la biblioteca RxJava, tiene sentido referirse a sus interfaces b√°sicas. <br></li><li>  El n√∫mero de interfaces debe minimizarse. <br></li></ul><br>  Como resultado, decidimos usar <b>ObservableSource &lt;T&gt;</b> para la salida y <b>Consumer &lt;T&gt;</b> para la entrada.  ¬øPor qu√© no <b>Observable / Observador</b> , preguntas?  <b>Observable</b> es una clase abstracta de la que necesita heredar, y <b>ObservableSource</b> es la interfaz que implementa que satisface completamente la necesidad de implementar un protocolo reactivo. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.reactivex; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.reactivex.annotations.*; <span class="hljs-comment"><span class="hljs-comment">/** * Represents a basic, non-backpressured {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observable} source base interface, * consumable via an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observer}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the element type * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 2.0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Subscribes the given Observer to this ObservableSource instance. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> observer the Observer, not null * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> NullPointerException if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> observer} is null */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Observer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; observer)</span></span></span></span>; }</code> </pre> <br>  <b>Observer</b> , la primera interfaz que viene a la mente, implementa cuatro m√©todos: onSubscribe, onNext, onError y onComplete.  En un esfuerzo por simplificar el protocolo tanto como sea posible, preferimos <b>Consumer &lt;T&gt;</b> , que acepta nuevos elementos utilizando un √∫nico m√©todo.  Si elegimos <b>Observer</b> , los m√©todos restantes a menudo ser√≠an redundantes o funcionar√≠an de manera diferente (por ejemplo, nos gustar√≠a presentar errores como parte del estado, y no como excepciones, y ciertamente no interrumpir el flujo). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * A functional interface (callback) that accepts a single value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the value type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Consume the given value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> t the value * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception on error */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>; }</code> </pre> <br>  Entonces, tenemos dos interfaces, cada una de las cuales contiene un m√©todo.  Ahora podemos vincularlos firmando <b>Consumer &lt;T&gt;</b> a <b>ObservableSource &lt;T&gt;</b> .  Este √∫ltimo acepta solo instancias de <b>Observer &lt;T&gt;</b> , pero podemos envolverlo en un <b>Observable &lt;T&gt;</b> , que est√° suscrito a <b>Consumer &lt;T&gt;</b> : <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;String&gt; = Observable.just(<span class="hljs-string"><span class="hljs-string">"item1"</span></span>, <span class="hljs-string"><span class="hljs-string">"item2"</span></span>, <span class="hljs-string"><span class="hljs-string">"item3"</span></span>) val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(output).subscribe(input)</code> </pre> <br>  (Afortunadamente, la funci√≥n <i>.wrap (salida)</i> no crea un nuevo objeto si la <i>salida</i> ya <i>es</i> un <b>Observable &lt;T&gt;</b> ). <br><br>  Es posible que recuerde que el componente <b>Caracter√≠stica</b> de la primera parte del art√≠culo utilizaba datos de entrada del tipo <b>Deseo</b> (correspondiente a la intenci√≥n del modelo-vista-intenci√≥n) y la salida del tipo <b>Estado</b> , y por lo tanto puede estar en ambos lados del paquete: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Wishes -&gt; Feature val wishes: ObservableSource&lt;Wish&gt; = Observable.just(Wish.SomeWish) val feature: Consumer&lt;Wish&gt; = SomeFeature() val disposable = Observable.wrap(wishes).subscribe(feature) // Feature -&gt; State consumer val feature: ObservableSource&lt;State&gt; = SomeFeature() val logger: Consumer&lt;State&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(feature).subscribe(logger)</span></span></code> </pre> <br>  Esta vinculaci√≥n de <i>Consumidor</i> y <i>Productor</i> ya parece bastante simple, pero hay una forma a√∫n m√°s sencilla en la que no necesita crear suscripciones manualmente o cancelarlas. <br><br>  Introduciendo <b>Binder</b> . <br><br><h2>  Enlace de esteroides </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MVICore</a> contiene una clase llamada <b>Binder</b> que proporciona una API simple para administrar las suscripciones Rx y tiene una serie de caracter√≠sticas interesantes. <br><br>  ¬øPor qu√© es necesario? <br><br><ul><li>  Cree un enlace suscribiendo entradas para el fin de semana. <br></li><li>  La capacidad de darse de baja al final del ciclo de vida (cuando es un concepto abstracto y no tiene nada que ver con Android). <br></li><li>  Bonificaci√≥n: <b>Binder le</b> permite agregar objetos intermedios, por ejemplo, para el registro o la depuraci√≥n de viajes en el tiempo. <br></li></ul><br>  En lugar de firmar manualmente, puede volver a escribir los ejemplos anteriores de la siguiente manera: <br><br><pre> <code class="java hljs">val binder = Binder() binder.bind(wishes to feature) binder.bind(feature to logger)</code> </pre> <br>  Gracias a Kotlin, todo parece muy simple. <br><br>  Estos ejemplos funcionan si el tipo de entrada y salida es el mismo.  Pero, ¬øy si no es as√≠?  Al implementar la funci√≥n de extensi√≥n, podemos hacer que la transformaci√≥n sea autom√°tica: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;A&gt; = TODO() val input: Consumer&lt;B&gt; = TODO() val transformer: (A) -&gt; B = TODO() binder.bind(output to input using transformer)</code> </pre> <br>  Presta atenci√≥n a la sintaxis: se lee casi como una oraci√≥n normal (y esta es otra raz√≥n por la que amo a Kotlin).  Pero <b>Binder</b> no solo se usa como az√∫car sint√°ctico, tambi√©n nos es √∫til para resolver problemas con el ciclo de vida. <br><br><h2>  Crear carpeta </h2><br>  Crear una instancia no parece m√°s f√°cil: <br><br><pre> <code class="java hljs">val binder = Binder()</code> </pre> <br>  Pero en este caso, debe darse de baja manualmente, y debe llamar a <code>binder.dispose()</code> cada vez que necesite eliminar suscripciones.  Hay otra forma: inyectar la instancia del ciclo de vida en el constructor.  As√≠: <br><br><pre> <code class="java hljs">val binder = Binder(lifecycle)</code> </pre> <br>  Ahora no necesita preocuparse por las suscripciones, ya que se eliminar√°n al final del ciclo de vida.  Al mismo tiempo, el ciclo de vida puede repetirse muchas veces (como el ciclo de inicio y finalizaci√≥n en la interfaz de usuario de Android), y <b>Binder</b> crear√° y eliminar√° suscripciones cada vez. <br><br><h2>  ¬øY qu√© es un ciclo de vida? </h2><br>  La mayor√≠a de los desarrolladores de Android, al ver la frase "ciclo de vida", representan los ciclos de Actividad y Fragmento.  S√≠, <b>Binder</b> puede trabajar con ellos, cancelando la suscripci√≥n al final del ciclo. <br><br>  Pero esto es solo el comienzo, porque no utiliza la interfaz de Android <b>LifecycleOwner</b> de ninguna manera: <b>Binder</b> tiene su propia <b>versi√≥n</b> , m√°s universal.  Es esencialmente un flujo de se√±al BEGIN / END: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ BEGIN, END } <span class="hljs-comment"><span class="hljs-comment">// Remainder omitted }</span></span></code> </pre><br>  Puede implementar esta secuencia usando Observable (mediante mapeo), o simplemente usar la clase <b>ManualLifecycle</b> de la biblioteca para entornos que no son Rx (ver exactamente a continuaci√≥n). <br><br>  ¬øC√≥mo funciona la <b>carpeta</b> ?  Al recibir una se√±al de INICIO, crea suscripciones para los componentes que configur√≥ previamente ( <i>entrada / salida</i> ), y al recibir una se√±al de FIN, los elimina.  Lo m√°s interesante es que puedes comenzar de nuevo: <br><br><pre> <code class="java hljs">val output: PublishSubject&lt;String&gt; = PublishSubject.create() val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val lifecycle = ManualLifecycle() val binder = Binder(lifecycle) binder.bind(output to input) output.onNext(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"3"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"4"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"5"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"6"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"7"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// will print: // 2 // 3 // 5 // 6</span></span></code> </pre> <br>  Esta flexibilidad en la reasignaci√≥n de suscripciones es especialmente √∫til cuando se trabaja con Android, cuando puede haber varios ciclos Start-Stop y Resume-Pause, adem√°s del habitual Create-Destroy. <br><br><h2>  Android Binder Lifecycles </h2><br>  Hay tres clases en la biblioteca: <br><br><ul><li>  <b>CreateDestroyBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>StartStopBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>ResumePauseBinderLifecycl</b> e ( <i>androidLifecycle</i> ) <br></li></ul><br>  <code>androidLifecycle</code> es el valor devuelto por el m√©todo <code>getLifecycle()</code> , es decir, <b>AppCompatActivity</b> , <b>AppCompatDialogFragment</b> , etc. Todo es muy simple: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBinderForActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: AppCompatActivity)</span></span></span><span class="hljs-function"> </span></span>= Binder(   CreateDestroyBinderLifecycle(activity.lifecycle) )</code> </pre> <br><h2>  Ciclos de vida individuales </h2><br>  No nos detengamos all√≠, porque no estamos vinculados a Android de ninguna manera.  ¬øCu√°l es el ciclo de vida de una <b>carpeta</b> ?  Literalmente cualquier cosa: por ejemplo, el tiempo de reproducci√≥n de un di√°logo o el tiempo de ejecuci√≥n de alguna tarea asincr√≥nica.  Puede, por ejemplo, vincularlo con el alcance DI, y luego cualquier suscripci√≥n se eliminar√° con √©l.  Completa libertad de acci√≥n. <br><br><ol><li>  ¬øDesea guardar las suscripciones antes de que el <b>Observable</b> env√≠e el elemento?  Convierta este objeto a <b>Lifecycle</b> y p√°selo a <b>Binder</b> .  Implemente el siguiente c√≥digo en la funci√≥n de <i>extensi√≥n</i> y util√≠celo m√°s adelante: <br><br><pre> <code class="java hljs">fun Observable&lt;T&gt;.toBinderLifecycle() = Lifecycle.wrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>   .first()   .map { END }   .startWith(BEGIN) )</code> </pre></li><li>  ¬øDesea conservar sus enlaces hasta que se <b>complete Completable</b> ?  Sin problemas: esto se hace por analog√≠a con el p√°rrafo anterior: <br><br><pre> <code class="java hljs">fun Completable.toBinderLifecycle() = Lifecycle.wrap(   Observable.concat(       Observable.just(BEGIN),       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.andThen(Observable.just(END))   ) )</code> </pre> </li><li>  ¬øDesea alg√∫n otro c√≥digo que no sea Rx para decidir cu√°ndo eliminar las suscripciones?  Use <b>ManualLifecycle</b> como se describe arriba. <br></li></ol><br>  En cualquier caso, puede colocar una secuencia reactiva en la secuencia del elemento <b>Lifecycle.Event</b> o usar <b>ManualLifecycle</b> si est√° trabajando con c√≥digo que no es Rx. <br><br><h2>  Descripci√≥n general del sistema </h2><br>  <b>Binder</b> oculta los detalles de la creaci√≥n y administraci√≥n de suscripciones Rx.  Todo lo que queda es una breve descripci√≥n general: "El componente A interact√∫a con el componente B en el alcance C". <br><br>  Supongamos que tenemos los siguientes componentes reactivos para la pantalla actual: <br><br><img src="https://habrastorage.org/webt/qu/gn/go/qugngoe-ishhqmff4kd--vlip7m.png"><br><br>  Nos gustar√≠a que los componentes se conectaran dentro de la pantalla actual, y sabemos que: <br><br><ul><li>  UIEvent se puede alimentar directamente a <b>AnalyticsTracker</b> ; <br></li><li>  UIEvent se puede transformar en <b>Wish</b> for <b>Feature</b> ; <br></li><li>  <b>El estado</b> se puede transformar en un <b>modelo</b> de <b>vista</b> para una <b>vista</b> . <br></li></ul><br>  Esto se puede expresar en un par de l√≠neas: <br><br><pre> <code class="java hljs">with(binder) {   bind(feature to view using stateToViewModelTransformer)   bind(view to feature using uiEventToWishTransformer)   bind(view to analyticsTracker) }</code> </pre> <br>  Hacemos tales apretones para demostrar la interconexi√≥n de componentes.  Y dado que los desarrolladores pasamos m√°s tiempo leyendo el c√≥digo que escribi√©ndolo, una breve descripci√≥n general es extremadamente √∫til, especialmente a medida que aumenta el n√∫mero de componentes. <br><br><h2>  Conclusi√≥n </h2><br>  Vimos c√≥mo <b>Binder</b> ayuda a administrar las suscripciones de Rx y c√≥mo le ayuda a obtener una visi√≥n general de un sistema construido a partir de componentes reactivos. <br><br>  En los siguientes art√≠culos, diremos c√≥mo separamos los componentes reactivos de la interfaz de usuario de la l√≥gica empresarial y c√≥mo agregar objetos intermedios usando <b>Binder</b> (para el registro y la depuraci√≥n del viaje en el tiempo).  ¬°No cambies! <br><br>  Mientras tanto, echa un vistazo a la biblioteca en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430550/">https://habr.com/ru/post/es430550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430536/index.html">Dise√±o de funciones de ventana sumadas en una unidad con un nivel dado de superposici√≥n</a></li>
<li><a href="../es430538/index.html">¬øLees Scaladoc para m√©todos de recolecci√≥n "obvios"? O por qu√© la pereza no siempre es buena</a></li>
<li><a href="../es430542/index.html">Seminario web abierto "Infraestructura como c√≥digo"</a></li>
<li><a href="../es430546/index.html">"Se cre√≠a que el c√≥digo ser√≠a reemplazado por diagramas UML, y no habr√≠a necesidad de probarlo": una entrevista con Alexei Barantsev</a></li>
<li><a href="../es430548/index.html">Interrupciones de dispositivos externos en un sistema x86. Parte 1. La evoluci√≥n de los controladores de interrupci√≥n</a></li>
<li><a href="../es430552/index.html">Inicio del d√≠a (septiembre-octubre de 2018)</a></li>
<li><a href="../es430554/index.html">Zapatillas de realidad virtual patentadas por Google que puedes caminar para siempre</a></li>
<li><a href="../es430556/index.html">GeekBrains lanza curso de capacitaci√≥n de gerente de producto</a></li>
<li><a href="../es430558/index.html">C√≥mo funciona la puntuaci√≥n en la industria del autom√≥vil compartido. Parte 1. Descripci√≥n general de herramientas populares sobre datos reales</a></li>
<li><a href="../es430560/index.html">Frontend, algoritmos y zarig√ºeya Frederick. Analizamos las tareas del concurso Yandex.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>