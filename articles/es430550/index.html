<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇 👨🏽‍💻 🔬 Construyendo un sistema de componentes reactivos con Kotlin 💅🏿 🏳️ 🐒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Mi nombre es Anatoly Varivonchik, soy desarrollador de Android en Badoo. Hoy compartiré con ustedes la traducción de la segunda parte de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construyendo un sistema de componentes reactivos con Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430550/"><img src="https://habrastorage.org/webt/9w/km/zp/9wkmzp6x1umysciwpqgvzuplf7y.png"><br><br>  Hola a todos!  Mi nombre es Anatoly Varivonchik, soy desarrollador de Android en Badoo.  Hoy compartiré con ustedes la traducción de la segunda parte del artículo de mi colega Zsolt Kocsi sobre la implementación de MVI, que usamos diariamente en el proceso de desarrollo.  La primera parte está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h2>  Que queremos y como lo hacemos </h2><br>  En la primera parte del artículo, presentamos <b>Características</b> , los elementos centrales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MVICore</a> que pueden reutilizarse.  Pueden tener la estructura más simple e incluir un solo <b>reductor</b> , o pueden convertirse en una herramienta completamente funcional para administrar tareas asincrónicas, eventos y mucho más. <br><br>  Cada característica es rastreable: existe la oportunidad de suscribirse a los cambios en su estado y recibir notificaciones al respecto.  Sin embargo, Feature se puede suscribir a una fuente de entrada.  Y esto tiene sentido, porque con la inclusión de Rx en la base del código, ya tenemos muchos objetos y suscripciones observables en varios niveles. <br><br>  Es en relación con el aumento en el número de componentes reactivos que es hora de reflexionar sobre lo que tenemos y si es posible mejorar aún más el sistema. <br><a name="habracut"></a><br>  Tenemos que responder tres preguntas: <br><br><ol><li>  ¿Qué elementos deben usarse al agregar nuevos componentes reactivos? <br></li><li>  ¿Cuál es la forma más fácil de administrar sus suscripciones? <br></li><li>  ¿Es posible ignorar la administración del ciclo de vida / la necesidad de borrar las suscripciones para evitar pérdidas de memoria?  En otras palabras, ¿podemos separar el enlace de componentes de la gestión de suscripción? <br></li></ol><br>  En esta parte del artículo, veremos los conceptos básicos y los beneficios de construir un sistema utilizando componentes reactivos y veremos cómo Kotlin ayuda con esto. <br><br><h2>  Elementos principales </h2><br>  Cuando llegamos a trabajar en el diseño y la estandarización de nuestras <b>características</b> , ya habíamos probado muchos enfoques diferentes y decidimos que las <b>características</b> estarían en forma de componentes reactivos.  Primero, nos centramos en las interfaces principales.  En primer lugar, necesitábamos determinar los tipos de datos de entrada y salida. <br><br>  Razonamos de la siguiente manera: <br><br><ul><li>  No reinventemos la rueda, veamos qué interfaces ya existen. <br></li><li>  Como ya estamos usando la biblioteca RxJava, tiene sentido referirse a sus interfaces básicas. <br></li><li>  El número de interfaces debe minimizarse. <br></li></ul><br>  Como resultado, decidimos usar <b>ObservableSource &lt;T&gt;</b> para la salida y <b>Consumer &lt;T&gt;</b> para la entrada.  ¿Por qué no <b>Observable / Observador</b> , preguntas?  <b>Observable</b> es una clase abstracta de la que necesita heredar, y <b>ObservableSource</b> es la interfaz que implementa que satisface completamente la necesidad de implementar un protocolo reactivo. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.reactivex; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.reactivex.annotations.*; <span class="hljs-comment"><span class="hljs-comment">/** * Represents a basic, non-backpressured {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observable} source base interface, * consumable via an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observer}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the element type * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 2.0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Subscribes the given Observer to this ObservableSource instance. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> observer the Observer, not null * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> NullPointerException if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> observer} is null */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Observer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; observer)</span></span></span></span>; }</code> </pre> <br>  <b>Observer</b> , la primera interfaz que viene a la mente, implementa cuatro métodos: onSubscribe, onNext, onError y onComplete.  En un esfuerzo por simplificar el protocolo tanto como sea posible, preferimos <b>Consumer &lt;T&gt;</b> , que acepta nuevos elementos utilizando un único método.  Si elegimos <b>Observer</b> , los métodos restantes a menudo serían redundantes o funcionarían de manera diferente (por ejemplo, nos gustaría presentar errores como parte del estado, y no como excepciones, y ciertamente no interrumpir el flujo). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * A functional interface (callback) that accepts a single value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the value type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Consume the given value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> t the value * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception on error */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>; }</code> </pre> <br>  Entonces, tenemos dos interfaces, cada una de las cuales contiene un método.  Ahora podemos vincularlos firmando <b>Consumer &lt;T&gt;</b> a <b>ObservableSource &lt;T&gt;</b> .  Este último acepta solo instancias de <b>Observer &lt;T&gt;</b> , pero podemos envolverlo en un <b>Observable &lt;T&gt;</b> , que está suscrito a <b>Consumer &lt;T&gt;</b> : <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;String&gt; = Observable.just(<span class="hljs-string"><span class="hljs-string">"item1"</span></span>, <span class="hljs-string"><span class="hljs-string">"item2"</span></span>, <span class="hljs-string"><span class="hljs-string">"item3"</span></span>) val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(output).subscribe(input)</code> </pre> <br>  (Afortunadamente, la función <i>.wrap (salida)</i> no crea un nuevo objeto si la <i>salida</i> ya <i>es</i> un <b>Observable &lt;T&gt;</b> ). <br><br>  Es posible que recuerde que el componente <b>Característica</b> de la primera parte del artículo utilizaba datos de entrada del tipo <b>Deseo</b> (correspondiente a la intención del modelo-vista-intención) y la salida del tipo <b>Estado</b> , y por lo tanto puede estar en ambos lados del paquete: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Wishes -&gt; Feature val wishes: ObservableSource&lt;Wish&gt; = Observable.just(Wish.SomeWish) val feature: Consumer&lt;Wish&gt; = SomeFeature() val disposable = Observable.wrap(wishes).subscribe(feature) // Feature -&gt; State consumer val feature: ObservableSource&lt;State&gt; = SomeFeature() val logger: Consumer&lt;State&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(feature).subscribe(logger)</span></span></code> </pre> <br>  Esta vinculación de <i>Consumidor</i> y <i>Productor</i> ya parece bastante simple, pero hay una forma aún más sencilla en la que no necesita crear suscripciones manualmente o cancelarlas. <br><br>  Introduciendo <b>Binder</b> . <br><br><h2>  Enlace de esteroides </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MVICore</a> contiene una clase llamada <b>Binder</b> que proporciona una API simple para administrar las suscripciones Rx y tiene una serie de características interesantes. <br><br>  ¿Por qué es necesario? <br><br><ul><li>  Cree un enlace suscribiendo entradas para el fin de semana. <br></li><li>  La capacidad de darse de baja al final del ciclo de vida (cuando es un concepto abstracto y no tiene nada que ver con Android). <br></li><li>  Bonificación: <b>Binder le</b> permite agregar objetos intermedios, por ejemplo, para el registro o la depuración de viajes en el tiempo. <br></li></ul><br>  En lugar de firmar manualmente, puede volver a escribir los ejemplos anteriores de la siguiente manera: <br><br><pre> <code class="java hljs">val binder = Binder() binder.bind(wishes to feature) binder.bind(feature to logger)</code> </pre> <br>  Gracias a Kotlin, todo parece muy simple. <br><br>  Estos ejemplos funcionan si el tipo de entrada y salida es el mismo.  Pero, ¿y si no es así?  Al implementar la función de extensión, podemos hacer que la transformación sea automática: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;A&gt; = TODO() val input: Consumer&lt;B&gt; = TODO() val transformer: (A) -&gt; B = TODO() binder.bind(output to input using transformer)</code> </pre> <br>  Presta atención a la sintaxis: se lee casi como una oración normal (y esta es otra razón por la que amo a Kotlin).  Pero <b>Binder</b> no solo se usa como azúcar sintáctico, también nos es útil para resolver problemas con el ciclo de vida. <br><br><h2>  Crear carpeta </h2><br>  Crear una instancia no parece más fácil: <br><br><pre> <code class="java hljs">val binder = Binder()</code> </pre> <br>  Pero en este caso, debe darse de baja manualmente, y debe llamar a <code>binder.dispose()</code> cada vez que necesite eliminar suscripciones.  Hay otra forma: inyectar la instancia del ciclo de vida en el constructor.  Así: <br><br><pre> <code class="java hljs">val binder = Binder(lifecycle)</code> </pre> <br>  Ahora no necesita preocuparse por las suscripciones, ya que se eliminarán al final del ciclo de vida.  Al mismo tiempo, el ciclo de vida puede repetirse muchas veces (como el ciclo de inicio y finalización en la interfaz de usuario de Android), y <b>Binder</b> creará y eliminará suscripciones cada vez. <br><br><h2>  ¿Y qué es un ciclo de vida? </h2><br>  La mayoría de los desarrolladores de Android, al ver la frase "ciclo de vida", representan los ciclos de Actividad y Fragmento.  Sí, <b>Binder</b> puede trabajar con ellos, cancelando la suscripción al final del ciclo. <br><br>  Pero esto es solo el comienzo, porque no utiliza la interfaz de Android <b>LifecycleOwner</b> de ninguna manera: <b>Binder</b> tiene su propia <b>versión</b> , más universal.  Es esencialmente un flujo de señal BEGIN / END: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ BEGIN, END } <span class="hljs-comment"><span class="hljs-comment">// Remainder omitted }</span></span></code> </pre><br>  Puede implementar esta secuencia usando Observable (mediante mapeo), o simplemente usar la clase <b>ManualLifecycle</b> de la biblioteca para entornos que no son Rx (ver exactamente a continuación). <br><br>  ¿Cómo funciona la <b>carpeta</b> ?  Al recibir una señal de INICIO, crea suscripciones para los componentes que configuró previamente ( <i>entrada / salida</i> ), y al recibir una señal de FIN, los elimina.  Lo más interesante es que puedes comenzar de nuevo: <br><br><pre> <code class="java hljs">val output: PublishSubject&lt;String&gt; = PublishSubject.create() val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val lifecycle = ManualLifecycle() val binder = Binder(lifecycle) binder.bind(output to input) output.onNext(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"3"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"4"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"5"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"6"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"7"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// will print: // 2 // 3 // 5 // 6</span></span></code> </pre> <br>  Esta flexibilidad en la reasignación de suscripciones es especialmente útil cuando se trabaja con Android, cuando puede haber varios ciclos Start-Stop y Resume-Pause, además del habitual Create-Destroy. <br><br><h2>  Android Binder Lifecycles </h2><br>  Hay tres clases en la biblioteca: <br><br><ul><li>  <b>CreateDestroyBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>StartStopBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>ResumePauseBinderLifecycl</b> e ( <i>androidLifecycle</i> ) <br></li></ul><br>  <code>androidLifecycle</code> es el valor devuelto por el método <code>getLifecycle()</code> , es decir, <b>AppCompatActivity</b> , <b>AppCompatDialogFragment</b> , etc. Todo es muy simple: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBinderForActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: AppCompatActivity)</span></span></span><span class="hljs-function"> </span></span>= Binder(   CreateDestroyBinderLifecycle(activity.lifecycle) )</code> </pre> <br><h2>  Ciclos de vida individuales </h2><br>  No nos detengamos allí, porque no estamos vinculados a Android de ninguna manera.  ¿Cuál es el ciclo de vida de una <b>carpeta</b> ?  Literalmente cualquier cosa: por ejemplo, el tiempo de reproducción de un diálogo o el tiempo de ejecución de alguna tarea asincrónica.  Puede, por ejemplo, vincularlo con el alcance DI, y luego cualquier suscripción se eliminará con él.  Completa libertad de acción. <br><br><ol><li>  ¿Desea guardar las suscripciones antes de que el <b>Observable</b> envíe el elemento?  Convierta este objeto a <b>Lifecycle</b> y páselo a <b>Binder</b> .  Implemente el siguiente código en la función de <i>extensión</i> y utilícelo más adelante: <br><br><pre> <code class="java hljs">fun Observable&lt;T&gt;.toBinderLifecycle() = Lifecycle.wrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>   .first()   .map { END }   .startWith(BEGIN) )</code> </pre></li><li>  ¿Desea conservar sus enlaces hasta que se <b>complete Completable</b> ?  Sin problemas: esto se hace por analogía con el párrafo anterior: <br><br><pre> <code class="java hljs">fun Completable.toBinderLifecycle() = Lifecycle.wrap(   Observable.concat(       Observable.just(BEGIN),       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.andThen(Observable.just(END))   ) )</code> </pre> </li><li>  ¿Desea algún otro código que no sea Rx para decidir cuándo eliminar las suscripciones?  Use <b>ManualLifecycle</b> como se describe arriba. <br></li></ol><br>  En cualquier caso, puede colocar una secuencia reactiva en la secuencia del elemento <b>Lifecycle.Event</b> o usar <b>ManualLifecycle</b> si está trabajando con código que no es Rx. <br><br><h2>  Descripción general del sistema </h2><br>  <b>Binder</b> oculta los detalles de la creación y administración de suscripciones Rx.  Todo lo que queda es una breve descripción general: "El componente A interactúa con el componente B en el alcance C". <br><br>  Supongamos que tenemos los siguientes componentes reactivos para la pantalla actual: <br><br><img src="https://habrastorage.org/webt/qu/gn/go/qugngoe-ishhqmff4kd--vlip7m.png"><br><br>  Nos gustaría que los componentes se conectaran dentro de la pantalla actual, y sabemos que: <br><br><ul><li>  UIEvent se puede alimentar directamente a <b>AnalyticsTracker</b> ; <br></li><li>  UIEvent se puede transformar en <b>Wish</b> for <b>Feature</b> ; <br></li><li>  <b>El estado</b> se puede transformar en un <b>modelo</b> de <b>vista</b> para una <b>vista</b> . <br></li></ul><br>  Esto se puede expresar en un par de líneas: <br><br><pre> <code class="java hljs">with(binder) {   bind(feature to view using stateToViewModelTransformer)   bind(view to feature using uiEventToWishTransformer)   bind(view to analyticsTracker) }</code> </pre> <br>  Hacemos tales apretones para demostrar la interconexión de componentes.  Y dado que los desarrolladores pasamos más tiempo leyendo el código que escribiéndolo, una breve descripción general es extremadamente útil, especialmente a medida que aumenta el número de componentes. <br><br><h2>  Conclusión </h2><br>  Vimos cómo <b>Binder</b> ayuda a administrar las suscripciones de Rx y cómo le ayuda a obtener una visión general de un sistema construido a partir de componentes reactivos. <br><br>  En los siguientes artículos, diremos cómo separamos los componentes reactivos de la interfaz de usuario de la lógica empresarial y cómo agregar objetos intermedios usando <b>Binder</b> (para el registro y la depuración del viaje en el tiempo).  ¡No cambies! <br><br>  Mientras tanto, echa un vistazo a la biblioteca en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430550/">https://habr.com/ru/post/es430550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430536/index.html">Diseño de funciones de ventana sumadas en una unidad con un nivel dado de superposición</a></li>
<li><a href="../es430538/index.html">¿Lees Scaladoc para métodos de recolección "obvios"? O por qué la pereza no siempre es buena</a></li>
<li><a href="../es430542/index.html">Seminario web abierto "Infraestructura como código"</a></li>
<li><a href="../es430546/index.html">"Se creía que el código sería reemplazado por diagramas UML, y no habría necesidad de probarlo": una entrevista con Alexei Barantsev</a></li>
<li><a href="../es430548/index.html">Interrupciones de dispositivos externos en un sistema x86. Parte 1. La evolución de los controladores de interrupción</a></li>
<li><a href="../es430552/index.html">Inicio del día (septiembre-octubre de 2018)</a></li>
<li><a href="../es430554/index.html">Zapatillas de realidad virtual patentadas por Google que puedes caminar para siempre</a></li>
<li><a href="../es430556/index.html">GeekBrains lanza curso de capacitación de gerente de producto</a></li>
<li><a href="../es430558/index.html">Cómo funciona la puntuación en la industria del automóvil compartido. Parte 1. Descripción general de herramientas populares sobre datos reales</a></li>
<li><a href="../es430560/index.html">Frontend, algoritmos y zarigüeya Frederick. Analizamos las tareas del concurso Yandex.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>