<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó°Ô∏è üï¥üèø üóæ Meningkatkan Fungsi Komponen Bereaksi dengan React.memo () „äôÔ∏è üëñ ü•Ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami menyajikan kepada Anda terjemahan artikel oleh Chidume Nnamdi, yang diterbitkan di blog.bitsrc.io. Jika Anda ingin mempelajari cara menghindari r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meningkatkan Fungsi Komponen Bereaksi dengan React.memo ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/442116/">  Kami menyajikan kepada Anda terjemahan artikel oleh Chidume Nnamdi, yang diterbitkan di blog.bitsrc.io.  Jika Anda ingin mempelajari cara menghindari render yang tidak perlu dan bagaimana alat baru berguna dalam Bereaksi, selamat datang di cat. <br><br><img src="https://habrastorage.org/webt/pd/cr/7a/pdcr7arl6hgkxg17v5c4laoxsj8.jpeg"><a name="habracut"></a><br><br>  Tim React.js bekerja keras untuk membuat React berjalan secepat mungkin.  Untuk memungkinkan pengembang mempercepat aplikasi Bereaksi mereka, alat berikut telah ditambahkan ke dalamnya: <br><br><ul><li>  React.lazy dan Suspense untuk keterlambatan memuat komponen; </li><li>  Komponen murni </li><li>  kait siklus hidup seharusnya memperbarui (...) {...}. </li></ul><br>  Pada artikel ini, kami akan mempertimbangkan, antara lain, alat pengoptimalan lain yang ditambahkan dalam React v16.6 untuk mempercepat fungsi komponen - <b>React.memo</b> . <br><br>  Tip: Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bit</a> untuk menginstal dan berbagi komponen Bereaksi.  Gunakan komponen Anda untuk membangun aplikasi baru dan membaginya dengan tim untuk mempercepat.  Cobalah! <br><br><img src="https://habrastorage.org/webt/uk/nn/k8/uknnk8ugyblbcsges3q5aag8n3m.gif"><br><br><h3>  Render ekstra </h3><br>  Dalam Bereaksi, setiap komponen terkait dengan unit tampilan.  Komponen juga memiliki status.  Ketika nilai status berubah karena tindakan pengguna, komponen menyadari bahwa menggambar ulang diperlukan.  Komponen Bereaksi dapat digambar ulang beberapa kali.  Dalam beberapa kasus, ini perlu, tetapi paling sering Anda dapat melakukannya tanpa renderer, terutama karena sangat memperlambat aplikasi. <br><br>  Pertimbangkan komponen berikut: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div &gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count} &lt;button onClick={(</span></span></span><span class="hljs-function">)=&gt;</span></span><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>})}&gt;Click Me&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre> <br>  Nilai awal dari keadaan {count: 0} adalah 0. Jika Anda mengklik tombol Klik saya, status penghitungan akan menjadi 1. Di layar kami, 0 juga akan berubah menjadi 1. Tetapi jika kami mengklik tombol lagi, masalah mulai: komponen tidak boleh digambar ulang, karena kondisinya belum berubah.  Nilai penghitung "ke" adalah 1, nilai baru juga satu, yang berarti bahwa tidak perlu memperbarui DOM. <br><br>  Untuk melihat pembaruan TestC kami, di mana kondisi yang sama diatur dua kali, saya menambahkan dua metode siklus hidup.  React memulai siklus componentWillUpdate ketika komponen diperbarui / digambar ulang karena perubahan status.  ComponentdidUpdate React cycle dimulai ketika komponen berhasil dibuat. <br><br>  Jika kami meluncurkan komponen di browser dan mencoba mengklik tombol Click me beberapa kali, kami mendapatkan hasil berikut: <br><br><img src="https://habrastorage.org/webt/qj/l9/zx/qjl9zx25xiry_bzjrwasb9t4b5k.png"><br><br>  Mengulangi entri componentWillUpdate di konsol kami menunjukkan bahwa komponen tersebut digambar ulang bahkan ketika keadaan tidak berubah.  Ini adalah render tambahan. <br><br><h3>  Komponen Murni / harusPerbarui komponen </h3><br>  Kait siklus hidup shouldComponentUpdate akan membantu menghindari rendering yang tidak perlu dalam komponen Bereaksi. <br><br>  React meluncurkan metode <b>shouldComponentUpdate</b> di awal rendering komponen dan menerima lampu hijau dari metode ini untuk melanjutkan proses atau sinyal bahwa proses <b>terhambat</b> . <br><br>  Biarkan shouldComponentUpdate kami terlihat seperti ini: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><ul><li>  <code>nextProps</code> : nilai properti berikutnya yang akan diterima komponen; </li><li>  <code>nextState</code> : nilai <code>state</code> selanjutnya yang akan diterima komponen. </li></ul><br>  Jadi kami mengizinkan Bereaksi untuk merender komponen karena nilai kembali <code>true</code> . <br><br>  Misalkan kita menulis yang berikut ini: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  Dalam hal ini, kami melarang Bereaksi untuk membuat komponen, karena <code>false</code> dikembalikan. <br>  Dari penjelasan di atas, untuk membuat komponen kita perlu mengembalikan <code>true</code> .  Sekarang kita dapat menulis ulang komponen TestC sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count === nextState.count) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Kami menambahkan pengait shouldComponentUpdate ke komponen TestC.  Sekarang nilai <code>count</code> dalam objek keadaan saat ini <code>this.state.count</code> dibandingkan dengan nilai <code>count</code> dalam objek keadaan berikutnya <code>nextState.count</code> .  Jika mereka sama <code>===</code> , menggambar ulang tidak terjadi dan <code>false</code> dikembalikan.  Jika mereka tidak sama, <code>true</code> dikembalikan dan penyaji diluncurkan untuk menampilkan nilai baru. <br><br>  Jika kami menguji kode di browser, kami akan melihat hasil yang familier: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br>  Tetapi dengan mengklik tombol <code>Click Me</code> beberapa kali, yang kami lihat adalah yang berikut (hanya ditampilkan sekali!): <br><br> <code>componentWillUpdate <br> componentDidUpdate</code> <br> <br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Anda dapat mengubah status komponen TestC di tab React DevTools.  Klik pada tab React, pilih TestC di sebelah kanan, dan Anda akan melihat nilai status penghitung: <br><br><img src="https://habrastorage.org/webt/pi/qg/ix/piqgixsafppm6jygqftfm8nkpyq.png"><br><br>  Nilai ini bisa diubah.  Klik pada teks penghitung, ketik 2 dan tekan Enter. <br><br><img src="https://habrastorage.org/webt/v3/4m/tl/v34mtl_unwz6gmkip2kxw_4a1km.png"><br><br>  Keadaan hitungan akan berubah, dan di konsol kita akan melihat: <br><br><pre> <code class="javascript hljs">componentWillUpdate componentDidUpdate componentWillUpdate componentDidUpdate</code> </pre><br><img src="https://habrastorage.org/webt/ql/3y/_i/ql3y_ijc3qwx9byxo_lu8ckbg-g.png"><br><br>  Nilai sebelumnya adalah 1, dan yang baru adalah 2, jadi redraw diperlukan. <br>  Mari kita beralih ke <b>Komponen Murni</b> . <br><br>  Komponen Murni muncul di Bereaksi dalam versi v15.5.  Ini digunakan untuk membandingkan nilai standar ( <code>change detection</code> ).  Menggunakan <code>extend React.PureComponent</code> , Anda tidak perlu menambahkan metode siklus hidup <code>shouldComponentUpdate</code> ke komponen: ubah pelacakan terjadi dengan sendirinya. <br><br>  Tambahkan PureComponent ke komponen TestC. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/*shouldComponentUpdate(nextProps, nextState) { if (this.state.count === nextState.count) { return false } return true }*/</span></span> render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div &gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Seperti yang Anda lihat, kami <code>shouldComponentUpdate</code> ke dalam komentar.  Kami tidak lagi membutuhkannya: semua pekerjaan dilakukan oleh <code>React.PureComponent</code> . <br><br>  Mulai ulang browser untuk menguji solusi baru, dan mengklik tombol <code>Click Me</code> beberapa kali, kita dapatkan: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Seperti yang Anda lihat, hanya satu <code>component*Update</code> Entri <code>component*Update</code> muncul di konsol. <br><br>  Setelah melihat bagaimana bekerja di Bereaksi dengan menggambar ulang di kelas komponen ES6, kami beralih ke fungsi komponen.  Bagaimana cara mencapai hasil yang sama dengan mereka? <br><br><h3>  Komponen Fungsi </h3><br>  Kita sudah tahu bagaimana mengoptimalkan kerja dengan kelas menggunakan Komponen Murni dan <code>shouldComponentUpdate</code> siklus hidup <code>shouldComponentUpdate</code> .  Tidak ada yang berpendapat bahwa komponen kelas adalah komponen utama Bereaksi, tetapi Anda dapat menggunakan fungsi sebagai komponen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> I am a functional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre> <br>  Penting untuk diingat bahwa komponen fungsi, tidak seperti komponen kelas, tidak memiliki status (meskipun sekarang kait penggunaanState telah <code>useState</code> , ini dapat diperdebatkan dengan), yang berarti bahwa kita tidak dapat mengonfigurasi redrawingnya.  Metode siklus hidup yang kami gunakan saat bekerja dengan kelas tidak tersedia bagi kami di sini.  Jika kita dapat menambahkan kait siklus hidup ke komponen fungsi, kita dapat menambahkan metode <code>shouldComponentUpdate</code> untuk memberi tahu Bereaksi bahwa penyaji fungsi diperlukan.  (Mungkin, dalam kalimat terakhir, penulis membuat kesalahan faktual. - Approx. Ed.) Dan, tentu saja, kita tidak bisa menggunakan <code>extend React.PureComponent</code> . <br><br>  Kami mengubah kelas komponen kami ES6 TestC menjadi fungsi komponen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Rendering TestC :`</span></span> props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {props.count} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC; <span class="hljs-comment"><span class="hljs-comment">// App.js &lt;TestC count={5} /&gt;</span></span></code> </pre> <br>  Setelah rendering di konsol, kita melihat <code>Rendering TestC :5</code> . <br><br><img src="https://habrastorage.org/webt/zl/ul/q4/zlulq4t7iokqfn9my1s9yka6v_w.png"><br><br>  Buka DevTools dan klik pada tab React.  Di sini kita akan mencoba mengubah nilai properti dari komponen TestC.  Pilih TestC, dan properti penghitung dengan semua properti dan nilai TestC akan terbuka di sebelah kanan.  Kami hanya melihat penghitung dengan nilai saat ini dari 5. <br><br>  Klik pada angka 5 untuk mengubah nilainya.  Jendela input akan muncul sebagai gantinya. <br><br><img src="https://habrastorage.org/webt/1h/u-/31/1hu-31ov7pulpn2iuqatr667rns.png"><br><br>  Jika kita mengubah nilai numerik dan menekan Enter, properti komponen akan berubah sesuai dengan nilai yang kita masukkan.  Misalkan pada usia 45. <br><br><img src="https://habrastorage.org/webt/bn/9t/yx/bn9tyxzi3bznqpx_6onqz2athra.png"><br><br>  Buka tab Konsol. <br><br><img src="https://habrastorage.org/webt/1m/8a/k8/1m8ak8oggdsmsahkqbg8npptrau.png"><br><br>  Komponen TestC digambar ulang karena nilai sebelumnya dari 5 berubah menjadi yang sekarang - 45. Kembali ke tab Bereaksi dan ubah nilainya menjadi 45, kemudian kembali ke Konsol. <br><br><img src="https://habrastorage.org/webt/ea/mu/vy/eamuvycxua6dksm8yp_o2b0bcym.png"><br><br>  Seperti yang Anda lihat, komponen digambar ulang, meskipun nilai sebelumnya dan yang baru adalah sama.  :( <br><br>  Bagaimana cara mengelola penyaji? <br><br><h3>  Solusi: React.memo () </h3><br>  <code>React.memo()</code> adalah fitur baru yang diperkenalkan di React v16.6.  Prinsip operasinya mirip dengan prinsip <code>React.PureComponent</code> : membantu dalam mengelola <code>React.PureComponent</code> fungsi-komponen.  <code>React.memo(...)</code> untuk komponen kelas adalah <code>React.PureComponent</code> untuk komponen fungsi. <br><br>  <b>Bagaimana cara kerja dengan React.memo (...)?</b> <br>  Cukup sederhana.  Katakanlah kita memiliki fungsi komponen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre><br>  Kita hanya perlu meneruskan FuncComponent sebagai argumen ke fungsi React.memo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemodFuncComponent = React.memo(FunComponent)</code> </pre> <br>  React.memo mengembalikan MemodFuncComponent yang <code>purified MemodFuncComponent</code> .  Inilah yang akan kita gambar di markup JSX.  Ketika properti dan status komponen berubah, React membandingkan properti dan status komponen sebelumnya dan saat ini.  Dan hanya jika mereka tidak identik, fungsi komponen digambar ulang. <br><br>  Terapkan ini ke komponen fungsi TestC. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Rendering TestC :'</span></span>, props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { props.count } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> ) } TestC = React.memo(TestC);</span></span></code> </pre> <br>  Buka browser dan unduh aplikasi.  Buka DevTools dan buka tab React.  Pilih <code>&lt;Memo(TestC)&gt;</code> . <br><br>  Jika di blok di sebelah kanan kami mengubah properti penghitung ke 89, aplikasi akan digambar ulang. <br><br><img src="https://habrastorage.org/webt/kf/tl/ms/kftlmsn1bznnmh9loxbedc_acqi.png"><br><br>  Jika kami mengubah nilai ke yang sebelumnya, 89, maka ... <br><br><img src="https://habrastorage.org/webt/j4/ak/tq/j4aktqq4qfwkizulxk2h-em4ism.png"><br><br>  Tidak akan ada penggambaran ulang! <br><br>  Glory to React.memo (...)!  :) <br><br>  Tanpa menggunakan <code>React.memo(...)</code> dalam contoh pertama kami, fungsi komponen TestC digambar ulang bahkan ketika nilai sebelumnya berubah menjadi yang identik.  Sekarang, terima kasih kepada <code>React.memo(...)</code> , kita dapat menghindari rendering fungsi komponen yang tidak perlu. <br><br><h3>  Kesimpulan </h3><br><ul><li>  Mari kita lihat daftarnya? </li><li>  <code>React.PureComponent</code> - perak; </li><li>  <code>React.memo(...)</code> - emas; </li><li>  <code>React.PureComponent</code> bekerja dengan kelas ES6; </li><li>  <code>React.memo(...)</code> berfungsi dengan fungsi; </li><li>  <code>React.PureComponent</code> mengoptimalkan gambar ulang kelas ES6; </li><li>  <code>React.memo(...)</code> mengoptimalkan fungsi redrawing; </li><li>  optimisasi fitur adalah ide yang hebat; </li><li>  <code>React</code> tidak akan pernah sama lagi. </li></ul><br>  Jika Anda memiliki pertanyaan tentang artikel atau informasi tambahan, perubahan atau keberatan, jangan ragu untuk menulis komentar, email, atau pesan pribadi kepada saya. <br><br>  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442116/">https://habr.com/ru/post/id442116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442104/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 5</a></li>
<li><a href="../id442108/index.html">Panduan bagi pengembang untuk membuat aplikasi AI</a></li>
<li><a href="../id442110/index.html">Vim Antipatterns</a></li>
<li><a href="../id442112/index.html">Bahasa pemrograman baru secara diam-diam mematikan koneksi kita dengan kenyataan</a></li>
<li><a href="../id442114/index.html">Panduan untuk audit otomatis kontrak pintar. Bagian 3: Mythril</a></li>
<li><a href="../id442118/index.html">Kelompok penambangan Coinhive berhenti bekerja</a></li>
<li><a href="../id442120/index.html">Melatih model TensorFlow dengan Layanan Pembelajaran Azure Machine</a></li>
<li><a href="../id442122/index.html">Levelord Muscovite yang sederhana: sebuah wawancara dengan pencipta Duke Nukem</a></li>
<li><a href="../id442124/index.html">Facebook akan memberi pengguna kesempatan untuk membersihkan cerita mereka</a></li>
<li><a href="../id442128/index.html">Kehidupan di partikel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>