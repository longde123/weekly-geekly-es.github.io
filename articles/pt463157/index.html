<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòã üë®üèª‚Äç‚úàÔ∏è üë®üèª‚Äçüîß Servidor de Streaming de V√≠deo ESP32-CAM Conectando Monitores I2C e SPI üê¶ üíÆ üé•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M√≥dulo CAM ESP-32 com c√¢mera da Diymore 

 Servidor de Streaming de V√≠deo ESP32-CAM 
 Um exemplo de uso est√° aqui . 

 Voc√™ deve primeiro instalar as ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Servidor de Streaming de V√≠deo ESP32-CAM Conectando Monitores I2C e SPI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463157/">  M√≥dulo CAM ESP-32 com c√¢mera da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Diymore</a> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/it/oc/feitoc3nxkss7zc6ocsw7cmuyho.jpeg" width="500"></div><br><h3>  Servidor de Streaming de V√≠deo ESP32-CAM </h3><br>  Um exemplo de uso est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Voc√™ deve primeiro instalar as bibliotecas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Placa Esp32 no Arduino Ide</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Placa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Windows</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Esp32 no Arduino Ide Linux e Mac</a> <br><br>  Configura√ß√µes detalhadas est√£o no artigo. <br><br>  No meu caso, usei o m√≥dulo AI-THINKER t√£o descomentado <br>  #define CAMERA_MODEL_AI_THINKER <br><br>  A funcionalidade do reconhecimento de rosto n√£o funcionou para mim.  O coment√°rio no artigo foi √∫til. <br><a name="habracut"></a><br>  Parece que o reconhecimento de faces n√£o est√° mais funcionando (pelo menos com o programa de exemplo) ao usar o n√∫cleo 1.02 ESP.  Revertendo para o n√∫cleo 1.01 e usando o programa de exemplo pertencente a esse n√∫cleo, ele ser√° corrigido <br><br>  Depois de reverter para a vers√£o anterior da biblioteca 1.01, tudo funcionou. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/tg/47/_2tg47ntvkqznzh-nr_jhqzitz8.png"></div><br>  Eu tenho um par de displays I2C 128x64 e TFT SPI 128x128 <br><br>  Artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OV7670 com FIFO</a> como conectar a c√¢mera ao monitor se voc√™ n√£o possui um m√≥dulo CAM.  Suporte c√¢meras OV2640 e OV7670 <br><br>  No momento em que escrevi, o seguinte funcionou para mim <br><br>  C√¢mera ESP32 + Servidor Wi-Fi + Tela I2C (AdaFruit) <br>  C√¢mera ESP32 + Tela SPI 1,44 "TFT 128x128 v1.1 (AdaFruit) <br>  C√¢mera ESP32 + Tela SPI 1,8 "TFT 128 * 160 (biblioteca Espressif) <br><br>  O driver WiFi entra em conflito com o barramento SPI.  Solu√ß√£o poss√≠vel para usar uma biblioteca diferente.  O problema surgiu no momento da inicializa√ß√£o do m√≥dulo WiFi. <br><br>  O principal problema √© que o m√≥dulo ESP32-CAM possui um n√∫mero limitado de pernas livres.  Parte das portas √© usada para a c√¢mera, parte em paralelo com o cart√£o SD.  O conector da placa sd est√° instalado na placa.  Outra conclus√£o (IO4) √© a lanterna LED. <br><br>  A tela I2C P / B n√£o √© de particular interesse para uso real com a imagem recebida da c√¢mera.  Cor TFT e alta resolu√ß√£o.  Nele voc√™ j√° pode ver o rosto.  Em um monitor ou com uma resolu√ß√£o um pouco mais alta, voc√™ pode fazer o Door Eye <br><br>  Eu direi imediatamente que a biblioteca do AdaFruit n√£o √© a mais r√°pida.  Consegui exibir alguns quadros por segundo.  √â mais promissor usar bibliotecas que funcionam em um n√≠vel baixo.  Mas n√£o consegui obter uma ESP32_TFT_library com a tela 1,44 "128x128 SPI V1.1. Talvez o ILI9163 n√£o seja suportado. Tirei 1,8" 128 * 160 SPI TFT e consegui espremer cerca de 12 FPS!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link</a> <br><br>  Existem algumas bibliotecas que funcionam mais rapidamente.  Mas alguns n√£o s√£o portados para o esp-32 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ): <br><br>  4,98 seg. Adafruit_ST7735 <br>  1,71 seg ST7735X_kbv <br>  1,30 seg PDQ_ST7735 <br><br>  O v√≠deo parece impressionante: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HnhsxP0W0m4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Ao usar <s>duas portas,</s> uma das portas de hardware HSPI ou VSPI no microcontrolador e a tela com o driver ILI9341 podem receber 30 quadros por segundo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7a/39/93/7a3993k5m_j9z5f2juglv5s9h9g.png"></div><br><br>  Mas, como eu disse anteriormente no m√≥dulo ESP32-CAM, apenas um SPI √© gratuito.  √â exibido nos seguintes PINS: <br><br>  IO2 - CC (A0) <br>  IO14 - CLK <br>  IO15 - CS <br>  IO13 - MOSI (SDA) <br>  IO12 - MISO (entrada. N√£o usado) <br><br>  IO0 - BCKL (luz de fundo. N√£o usado) <br>  IO16 - RST <br><br><img src="https://habrastorage.org/webt/ob/wr/wy/obwrwyztxqm6ct4dtlxe_fggdim.png"><br><br><img src="https://habrastorage.org/webt/nr/7e/dg/nr7edg2broaykspjtyxncso2zxy.png"><br><br>  A primeira biblioteca que tentei foi o AdaFruit SSD1306 <br><br><h3>  Tela OLED azul I2C 128x64 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/xl/ji/ecxljimycqq42q16yxswiehsv98.png"></div><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Wire.h&gt; #include &lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels // Declaration for an SSD1306 display connected to I2C (SDA, SCL pins) #define OLED_RESET -1 // Reset pin # (or -1 if sharing Arduino reset pin) Adafruit_SSD1306 display; void init_display(){ pinMode(14,INPUT_PULLUP); pinMode(15,INPUT_PULLUP); Wire.begin(14,15); display = Adafruit_SSD1306(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET); if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64 Serial.println(F("SSD1306 allocation failed")); for(;;); // Don't proceed, loop forever } ....</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">camera_capture ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BACKCOLOR 0x0000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Black #define PIXELCOLOR 0xFFFF // White #define FRAME_WIDTH 320 #define FRAME_HEIGHT 240 uint16_t pixel_color = 0; esp_err_t camera_capture(){ //acquire a frame camera_fb_t * fb = esp_camera_fb_get(); if (!fb) { ESP_LOGE(TAG, "Camera Capture Failed"); return ESP_FAIL; } int i = 0; for(int y = 0; y &lt; SCREEN_HEIGHT; y++){ for(int x = 0; x &lt; SCREEN_WIDTH; x++){ i = y * FRAME_WIDTH + x; // FRAMESIZE_QVGA // 320x240 char ch = (char)fb-&gt;buf[i]; if (ch &gt; 128) pixel_color = WHITE; else pixel_color = BLACK; // Draw a single pixel in white display.drawPixel(x, y, pixel_color); } } display.display(); //return the frame buffer back to the driver for reuse esp_camera_fb_return(fb); Serial.println("Capture frame ok."); return ESP_OK; }</span></span></span></span></code> </pre><br></div></div><br>  Ao trabalhar no esp32, a emula√ß√£o de Software I2C √© usada.  IO14 e IO15 envolvidas.  Quase todas as portas livres podem ser usadas, e n√£o o barramento H / W. <br><br>  Como conectar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">monitor monocrom√°tico de 0,96 "i2c OLED</a> . Voc√™ precisa prestar aten√ß√£o ao endere√ßo de exibi√ß√£o no barramento I2C. Nesse caso, 0x3C <br><br><h3>  Biblioteca SPI Display 1,8 "TFT 128 * 160 Espressif </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e9/ym/zg/e9ymzg6iukpuzpowfbgvlln89dg.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/jv/j0/eojvj0nkmzg1dqiubx3jcaoepou.jpeg"></div><br>  Diagrama de fia√ß√£o: <br><br>  IO2 - A0 <br>  IO14 - SCK <br>  IO15 - CS <br>  IO13 - SDA <br>  IO16 - RESET <br><br><img src="https://habrastorage.org/webt/fp/v8/iv/fpv8iv79hdpoefoxwnzsc64ychm.png"><br>  A placa tamb√©m possui um leitor de cart√£o SD <br><br>  Configura√ß√£o de E / S: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Configuration for other boards, set the correct values for the display used //---------------------------------------------------------------------------- #define DISP_COLOR_BITS_24 0x66 //#define DISP_COLOR_BITS_16 0x55 // Do not use! // ############################################# // ### Set to 1 for some displays, ### // for example the one on ESP-WROWER-KIT ### // ############################################# #define TFT_INVERT_ROTATION 0 #define TFT_INVERT_ROTATION1 0 // ################################################ // ### SET TO 0X00 FOR DISPLAYS WITH RGB MATRIX ### // ### SET TO 0X08 FOR DISPLAYS WITH BGR MATRIX ### // ### For ESP-WROWER-KIT set to 0x00 ### // ################################################ #define TFT_RGB_BGR 0x08 // ############################################################## // ### Define ESP32 SPI pins to which the display is attached ### // ############################################################## // The pins configured here are the native spi pins for HSPI interface // Any other valid pin combination can be used #define PIN_NUM_MISO 12 // SPI MISO #define PIN_NUM_MOSI 13 // SPI MOSI #define PIN_NUM_CLK 14 // SPI CLOCK pin #define PIN_NUM_CS 15 // Display CS pin #define PIN_NUM_DC 2 // Display command/data pin #define PIN_NUM_TCS 0 // Touch screen CS pin (NOT used if USE_TOUCH=0) // -------------------------------------------------------------- // ** Set Reset and Backlight pins to 0 if not used ! // ** If you want to use them, set them to some valid GPIO number #define PIN_NUM_RST 0 // GPIO used for RESET control #define PIN_NUM_BCKL 0 // GPIO used for backlight control #define PIN_BCKL_ON 0 // GPIO value for backlight ON #define PIN_BCKL_OFF 1 // GPIO value for backlight OFF // -------------------------------------------------------------- // ####################################################### // Set this to 1 if you want to use touch screen functions // ####################################################### #define USE_TOUCH TOUCH_TYPE_NONE // ####################################################### // ####################################################################### // Default display width (smaller dimension) and height (larger dimension) // ####################################################################### #define DEFAULT_TFT_DISPLAY_WIDTH 128 #define DEFAULT_TFT_DISPLAY_HEIGHT 160 // ####################################################################### #define DEFAULT_GAMMA_CURVE 0 #define DEFAULT_SPI_CLOCK 32000000 #define DEFAULT_DISP_TYPE DISP_TYPE_ST7735B //---------------------------------------------------------------------------- #define TFT_INVERT_ROTATION 0 #define TFT_INVERT_ROTATION1 1 #define TFT_INVERT_ROTATION2 0</span></span></code> </pre><br>  Instale o ambiente e ambiente de desenvolvimento da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Espressif</a> .  Instru√ß√µes detalhadas sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como fazer isso</a> . <br><br>  Instale a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca</a> .  Duas corre√ß√µes precisam ser feitas para montar a biblioteca. <br><br>  Makefile: <br><br><pre> <code class="bash hljs">+ CFLAGS += -Wno-error=tautological-compare \ + -Wno-implicit-fallthrough \ + -Wno-implicit-function-declaration</code> </pre><br>  components / tft / tftspi.c: <br><br><pre> <code class="cpp hljs">+ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"driver/gpio.h</span></span></span></span></code> </pre><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Patch</a> <br><br>  Em seguida, instale o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">driver da c√¢mera ESP32</a> . <br><br>  Configure: <br><br>  #.  $ HOME / esp / esp-idf / export.sh <br>  # idf.py menuconfig <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/yl/ml/ycylmlzznbfewlweiaris71dbzo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_3/gn/5s/_3gn5s4bmrqunmhwjeabdtxe9yu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x8/jc/g6/x8jcg6ia43npfcol7rebn1taz7e.png"></div><br>  Permitir acesso √† porta USB para firmware e monitoramento: <br><br>  #sudo chmod 777 / dev / ttyUSB0 <br><br>  Coletamos e preenchemos: <br><br>  #make -j4 &amp;&amp; make flash <br><br>  12FPS √© alcan√ßado atrav√©s da grava√ß√£o de pacotes usando o m√©todo send_data.  A grava√ß√£o n√£o √© pixel por pixel, mas uma linha inteira igual √† largura da tela: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">esp_err_t</span></span> camera_capture(){ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tstart, t1, t2; tstart = clock(); <span class="hljs-comment"><span class="hljs-comment">//acquire a frame camera_fb_t * fb = esp_camera_fb_get(); if (!fb) { printf("Camera Capture Failed\n"); return ESP_FAIL; } t1 = clock() - tstart; printf("Capture camera time: %u ms\r\n", t1); int i = 0, bufPos = 0; uint8_t hb, lb; color_t color; color_t *color_line = heap_caps_malloc(_width*3, MALLOC_CAP_DMA); tstart = clock(); for(int y = 0; y &lt; _height; y++) { bufPos = 0; for(int x = 0; x &lt; _width; x++) { i = (y * FRAME_WIDTH + x) &lt;&lt; 1; hb = fb-&gt;buf[i] ; lb = fb-&gt;buf[i + 1]; color.r = (lb &amp; 0x1F) &lt;&lt; 3; color.g = (hb &amp; 0x07) &lt;&lt; 5 | (lb &amp; 0xE0) &gt;&gt; 3; color.b = hb &amp; 0xF8; color_line[bufPos] = color; bufPos++; // TFT_drawPixel(0, 0, color, 1); } disp_select(); send_data(0, y, _width-1, y, _width, color_line); wait_trans_finish(1); disp_deselect(); } free(color_line); t1 = clock() - tstart; printf("Send buffer time: %u ms\r\n", t1); esp_camera_fb_return(fb); printf("Capture frame ok.\n"); return ESP_OK; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Configura√ß√£o da c√¢mera</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// #if defined(CAMERA_MODEL_AI_THINKER) #define PWDN_GPIO_NUM 32 #define RESET_GPIO_NUM -1 #define XCLK_GPIO_NUM 0 #define SIOD_GPIO_NUM 26 #define SIOC_GPIO_NUM 27 #define Y9_GPIO_NUM 35 #define Y8_GPIO_NUM 34 #define Y7_GPIO_NUM 39 #define Y6_GPIO_NUM 36 #define Y5_GPIO_NUM 21 #define Y4_GPIO_NUM 19 #define Y3_GPIO_NUM 18 #define Y2_GPIO_NUM 5 #define VSYNC_GPIO_NUM 25 #define HREF_GPIO_NUM 23 #define PCLK_GPIO_NUM 22 void camera_init_(){ camera_config_t config; config.ledc_channel = LEDC_CHANNEL_0; config.ledc_timer = LEDC_TIMER_0; config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM; config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM; config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM; config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM; config.pin_xclk = XCLK_GPIO_NUM; config.pin_pclk = PCLK_GPIO_NUM; config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM; config.pin_sscb_sda = SIOD_GPIO_NUM; config.pin_sscb_scl = SIOC_GPIO_NUM; config.pin_pwdn = PWDN_GPIO_NUM; config.pin_reset = RESET_GPIO_NUM; config.xclk_freq_hz = 20000000; config.fb_count = 2; // for display config.frame_size = FRAMESIZE_QVGA; config.pixel_format = PIXFORMAT_RGB565; // camera init esp_err_t err = esp_camera_init(&amp;config); if (err != ESP_OK) { printf("Camera init failed with error 0x%x", err); return; } printf("Camera init OK\n"); }</span></span></code> </pre><br></div></div><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gist</a> <br><br>  <u>FRAME_WIDTH √© a largura do quadro de 320 pixels para QVGA</u> <br><br><pre> <code class="cpp hljs">config.frame_size = FRAMESIZE_QVGA; <span class="hljs-comment"><span class="hljs-comment">// 320x240</span></span></code> </pre><br>  De fato, vemos na janela de exibi√ß√£o 128 * 160 do quadro completo <br><br>  <i>Registre a configura√ß√£o com um buffer de c√¢mera de v√≠deo (config.fb_count = 1)</i> <i><br></i>  <i>Capturar tempo da c√¢mera: 32 ms</i> <i><br></i>  <i>Tempo de buffer de envio: 47 ms</i> <i><br></i>  <i>Capturar quadro ok.</i> <br><br>  <b>Resultado</b> <b><br></b>  <b>1000 / (32 + 47) = 12,65 FPS</b> <br><br><div class="spoiler">  <b class="spoiler_title">Registre a configura√ß√£o com dois buffers da c√¢mera de v√≠deo (config.fb_count = 2)</b> <div class="spoiler_text">  Capturar tempo da c√¢mera: 39 ms <br><br>  Tempo de buffer de envio: 63 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 59 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 34 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 40 ms <br><br>  Tempo de buffer de envio: 64 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 59 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 34 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 40 ms <br><br>  Tempo de buffer de envio: 63 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 60 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 34 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 39 ms <br><br>  Tempo de buffer de envio: 63 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 60 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 1 ms <br><br>  Tempo de buffer de envio: 34 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 40 ms <br><br>  Tempo de buffer de envio: 63 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 60 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 34 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 40 ms <br><br>  Tempo de buffer de envio: 63 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 59 ms <br><br>  Capturar quadro ok. <br>  Capturar tempo da c√¢mera: 0 ms <br><br>  Tempo de buffer de envio: 35 ms <br><br>  Capturar quadro ok. </div></div><br>  Usando o segundo buffer da c√¢mera de v√≠deo, o buffer em alguns ciclos √© obtido instantaneamente.  Inicialmente, o ciclo completo √© obtido em menos de um buffer, mas dessa vez "continua".  O intervalo entre os ciclos √© flutuante. <br><br>  V√°rias vezes peguei nos registros "O detector de trincas foi acionado" e desliguei o detector.  Porque no come√ßo eu alimentei a tela de luz de fundo do pino ESP32-CAM de 3,3 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"soc/rtc_cntl_reg.h"</span></span></span><span class="hljs-meta"> ... WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//disable brownout detector</span></span></span></span></code> </pre><br><h3>  Conclus√£o </h3><br>  M√≥dulo funcional de baixo custo ESP32.  H√° uma falta catastr√≥fica de conclus√µes para as portas implementadas na vers√£o CAM da placa; portanto, escolha a vers√£o CAM se voc√™ realmente precisa de uma c√¢mera. <br><br><div class="spoiler">  <b class="spoiler_title">Links √∫teis</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">randomnerdtutorials.com/esp32-trou Troubleshooting-guide</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.instructables.com/id/Select-Color-Display-for-ESP32</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/gnulabis/UTFT-ESP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/Bodmer/TFT_eSPI</a> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463157/">https://habr.com/ru/post/pt463157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463143/index.html">Introdu√ß√£o ao Google Analytics: App + Web</a></li>
<li><a href="../pt463147/index.html">ROS Trolley Robot - Parte 3. Acelere, troque a c√¢mera, conserte a marcha</a></li>
<li><a href="../pt463149/index.html">Alan Kay recomenda a leitura de livros de programa√ß√£o antigos e esquecidos, mas importantes</a></li>
<li><a href="../pt463151/index.html">iOS 13 sob a lupa</a></li>
<li><a href="../pt463155/index.html">O ru√≠do branco desenha um quadrado preto. Parte 2. Solu√ß√£o</a></li>
<li><a href="../pt463159/index.html">Sobre seguran√ßa, n√∫meros, e-mails e um pouco sobre publicidade</a></li>
<li><a href="../pt463165/index.html">Telegrama revoga DPI e bloqueios - TLS falso</a></li>
<li><a href="../pt463167/index.html">Materiais necess√°rios para iniciar o desenvolvimento de um projeto de treinamento em VR</a></li>
<li><a href="../pt463169/index.html">Aparelho auditivo de c√≥digo aberto - como funciona</a></li>
<li><a href="../pt463171/index.html">Redes neurais e aprendizado profundo: um tutorial on-line, cap√≠tulo 6, parte 1: aprendizado profundo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>