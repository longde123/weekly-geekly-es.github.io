<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🌾 👲🏿 👩‍💼 Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 2 🔱 👨‍🏫 ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute veröffentlichen wir den zweiten Teil der Übersetzung des Materials, der der Verwendung von JS-Modulen in der Produktion gewidmet ist. 

  

 → H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466539/">  Heute veröffentlichen wir den zweiten Teil der Übersetzung des Materials, der der Verwendung von JS-Modulen in der Produktion gewidmet ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/y4/3w/bg/y43wbgvqwezj1-b0oyx882a-gne.jpeg"></a> <br><br>  → Hier ist übrigens der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Teil des</a> Artikels. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Dynamischer Import</font> </h2><br>  Einer der Nachteile der Verwendung realer Importausdrücke zum Trennen von Code- und Lademodulen besteht darin, dass die Aufgabe der Arbeit mit Browsern, die keine Module unterstützen, beim Entwickler liegt. <br><br>  Und wenn Sie dynamische <code>import()</code> Befehle verwenden möchten, um das Laden von verzögertem Code zu organisieren, müssen Sie sich unter anderem damit auseinandersetzen, dass einige Browser, obwohl sie mit Sicherheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Module</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterstützen, dynamische import () - Befehle</a> immer noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht unterstützen</a> (Edge 16–18, Firefox 60–66, Safari 11, Chrome 61–63). <br><br>  Glücklicherweise hilft uns dieses Problem bei der Lösung einer kleinen (ca. 400 Byte großen) und extrem schnellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyfüllung</a> . <br><br>  Das Hinzufügen dieser Polyfüllung zu einem Webprojekt ist sehr einfach.  Sie müssen es nur importieren und am Haupteinstiegspunkt der Anwendung initialisieren (bevor Sie einen der <code>import()</code> Befehle im Code aufrufen): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dynamicImportPolyfill <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dynamic-import-polyfill'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         .   //    ,       . dynamicImportPolyfill.initialize({modulePath: '/modules/'});</span></span></code> </pre> <br>  Das letzte, was getan werden muss, damit dieses Schema funktioniert, ist, Rollup mitzuteilen, dass es die im Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigten</a> dynamischen <code>import()</code> Befehle unter Verwendung des von Ihnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gewählten</a> Namens umbenennen muss (über die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">output.dynamicImportFunction</a> ).  Eine Polyfüllung, die die dynamische Importfunktion implementiert, verwendet <code>__import__</code> Namen <code>__import__</code> , kann jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angepasst werden</a> . <br><br>  Der Grund, warum Sie <code>import()</code> Ausdrücke umbenennen müssen, liegt darin, dass <code>import</code> in JavaScript ein Schlüsselwort ist.  Dies bedeutet, dass es mit Polyfill-Mitteln unmöglich ist, das Ersetzen des Standardbefehls <code>import()</code> durch einen gleichnamigen Befehl zu organisieren.  Wenn Sie dies versuchen, tritt ein Syntaxfehler auf. <br><br>  Es ist jedoch sehr gut, dass Rollup die Befehle während der Erstellung des Projekts umbenennt, da dies bedeutet, dass Sie Standardbefehle im Quellcode verwenden können.  Darüber hinaus muss in Zukunft, wenn die Polyfüllung nicht mehr benötigt wird, der Quellcode des Projekts nicht neu geschrieben werden, um zu ändern, was zuvor anders benannt wurde. <br><br><h2>  <font color="#3AC1EF">Effizientes Laden von JavaScript</font> </h2><br>  Wenn Sie die Codetrennung verwenden, schadet es nicht, das Vorladen aller Module zu organisieren, von denen Sie wissen, dass sie sehr bald geladen werden (dies sind beispielsweise alle Module im Abhängigkeitsbaum des Hauptmoduls, das der Einstiegspunkt für das Projekt ist). <br><br>  Wenn wir jedoch echte JavaScript-Module laden (über <code>&lt;script type="module"&gt;</code> und dann über die entsprechenden <code>import</code> ), müssen wir das Attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modulepreload</a> anstelle des üblichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Preloads</a> verwenden, das nur für klassische Skripte vorgesehen ist. <br><br><pre> <code class="javascript hljs">&lt;link rel=<span class="hljs-string"><span class="hljs-string">"modulepreload"</span></span> href=<span class="hljs-string"><span class="hljs-string">"/modules/main.XXXX.mjs"</span></span>&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-one.XXXX.mjs"&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-two.XXXX.mjs"&gt; &lt;link rel="modulepreload" href="/modules/npm.pkg-three.XXXX.mjs"&gt; &lt;!-- ... --&gt; &lt;script type="module" src="/modules/main.XXXX.mjs"&gt;&lt;/script&gt;</code> </pre> <br>  Tatsächlich ist das <code>modulepreload</code> Modulen beim Vorladen realer Module definitiv besser als der herkömmliche Mechanismus zum <code>modulepreload</code> .  Tatsache ist, dass bei der Verwendung nicht nur die Datei heruntergeladen wird.  Darüber hinaus wird das Skript sofort außerhalb des Hauptthreads analysiert und kompiliert.  Ein reguläres <code>preload</code> kann dies nicht tun, da es während des Vorladens nicht weiß, ob die Datei als Modul oder als reguläres Skript verwendet wird. <br><br>  Dies bedeutet, dass das Laden von Modulen mit dem Attribut <code>modulepreload</code> häufig schneller ist und dass beim Initialisieren von Modulen die Wahrscheinlichkeit geringer ist, dass der Hauptthread übermäßig belastet wird, was zu Schnittstellenproblemen führt. <br><br><h2>  <font color="#3AC1EF">Erstellen einer Liste von Modulen zum Vorladen</font> </h2><br>  Das Eingabefragment im Rollup- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bundle-</a> Objekt enthält eine vollständige Liste der Importe in ihren statischen Abhängigkeitsbäumen.  Daher ist es im Rollup-Hook " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">generateBundle</a> " einfach, eine Liste der Dateien abzurufen, die vorinstalliert werden müssen. <br><br>  Obwohl Plugins in npm zum Generieren von Modul-Vorladelisten zu finden sind, erfordert das Erstellen einer ähnlichen Liste für jeden Eingabepunkt im Abhängigkeitsbaum nur wenige Codezeilen.  Daher ziehe ich es vor, solche Listen manuell mit folgendem Code zu erstellen: <br><br><pre> <code class="javascript hljs">{  generateBundle(options, bundle) {    <span class="hljs-comment"><span class="hljs-comment">//         .    const modulepreloadMap = {};    for (const [fileName, chunkInfo] of Object.entries(bundle)) {      if (chunkInfo.isEntry || chunkInfo.isDynamicEntry) {        modulepreloadMap[chunkInfo.name] = [fileName, ...chunkInfo.imports];      }    }    //  -   ...    console.log(modulepreloadMap);  } }</span></span></code> </pre> <br>  Hier ist zum Beispiel, wie ich eine <a href="">Modul-Vorladeliste</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">philipwalton.com</a> und für meine <a href="">Demo-Anwendung erstellt habe</a> , über die wir weiter unten sprechen werden. <br><br>  Beachten Sie, dass das Attribut <code>modulepreload</code> definitiv besser ist als das klassische <code>preload</code> zum Laden von <code>modulepreload</code> , jedoch die schlechteste Browserunterstützung bietet (derzeit wird es nur von Chrome unterstützt).  Wenn ein erheblicher Teil Ihres Datenverkehrs nicht von Chrome stammt, ist es in Ihrer Situation möglicherweise sinnvoll, anstelle des <code>preload</code> reguläres <code>preload</code> zu <code>preload</code> . <br><br>  In Bezug auf die Verwendung der <code>preload</code> möchte ich Sie vor etwas warnen.  Tatsache ist, dass beim Laden von Skripten mit <code>preload</code> im Gegensatz zu <code>modulepreload</code> diese Skripte nicht in die Browser- <code>modulepreload</code> gelangen.  Dies bedeutet, dass die Möglichkeit besteht, dass Preload-Anforderungen mehrmals ausgeführt werden können (z. B. wenn das Modul die Datei importiert, bevor der Browser das Preload abgeschlossen hat). <br><br><h2>  <font color="#3AC1EF">Warum echte Module in der Produktion einsetzen?</font> </h2><br>  Wenn Sie bereits einen Bundler wie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webpack verwenden</a> und bereits Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufteilen</a> und die entsprechenden Dateien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorladen</a> (ähnlich wie ich gerade gesagt habe), fragen Sie sich möglicherweise, ob Sie zu einer Strategie wechseln sollten konzentrierte sich auf die Verwendung von realen Modulen.  Es gibt mehrere Gründe, die mich glauben lassen, dass Sie in Betracht ziehen sollten, auf Module umzusteigen.  Darüber hinaus glaube ich, dass die Konvertierung eines Projekts in echte Module besser ist als die Verwendung klassischer Skripte mit eigenem Code zum Laden von Modulen. <br><br><h3>  <font color="#3AC1EF">▍ Reduzieren der Gesamtmenge an Code</font> </h3><br>  Wenn das Projekt echte Module verwendet, müssen Benutzer moderner Browser keinen zusätzlichen Code herunterladen, der zum Laden von Modulen oder zum Verwalten von Abhängigkeiten entwickelt wurde.  Wenn Sie beispielsweise echte Module verwenden, müssen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Laufzeitmechanismen und das Webpack-Manifest</a> nicht laden. <br><br><h3>  <font color="#3AC1EF">▍ Verbesserter Preload-Code</font> </h3><br>  Wie im vorherigen Abschnitt erwähnt, können <code>modulepreload</code> mit dem Attribut <code>modulepreload</code> Code <code>modulepreload</code> und ihn außerhalb des Hauptthreads <code>modulepreload</code> und kompilieren.  Alles andere bleibt im Vergleich zum <code>preload</code> Attribut gleich.  Dies bedeutet, dass Seiten dank des <code>modulepreload</code> von <code>modulepreload</code> schneller interaktiv werden und die Wahrscheinlichkeit verringert wird, dass der Hauptstrom während der Benutzerinteraktion blockiert wird. <br><br>  Unabhängig davon, in welcher Größe der Anwendungscode in Fragmente unterteilt ist, ist es daher viel produktiver, diese Fragmente mithilfe der Importbefehle und des Attributs <code>modulepreload</code> , als sie mit dem üblichen <code>script</code> Tag und dem üblichen <code>preload</code> Attribut zu laden (insbesondere, wenn die entsprechenden Tags generiert werden) dynamisch und zur Laufzeit zum DOM hinzugefügt). <br><br>  Mit anderen Worten, ein Rollup-Bundle eines Projektcodes, der aus 20 Modulfragmenten besteht, wird schneller geladen als ein Bundle desselben Projekts, das aus 20 klassischen Skriptfragmenten besteht, die von webpack erstellt wurden (nicht wegen der Verwendung von webpack, sondern weil dass dies keine echten Module sind). <br><br><h3>  <font color="#3AC1EF">▍ Verbesserung des zukünftigen Fokus von Code</font> </h3><br>  Viele großartige neue Funktionen von Browsern basieren auf Modulen und nicht auf klassischen Skripten.  Wenn Sie diese Funktionen verwenden möchten, sollte Ihr Code in Form von realen Modulen dargestellt werden.  Es sollte nicht in ES5 transpiliert und mit den Mitteln des klassischen <code>script</code> Tags geladen sein (dies ist das Problem, über das ich geschrieben habe, als ich versucht habe, die experimentelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KV-Speicher-API zu verwenden</a> ). <br><br>  Hier sind einige der interessantesten neuen Browserfunktionen, die sich ausschließlich auf Module konzentrieren: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingebaute Module</a> </li><li>  <a href="">HTML-Module</a> </li><li>  <a href="">CSS-Module</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-Module</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karten importieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Freigeben von Modulen für Mitarbeiter, Servicemitarbeiter und das Dokumentfenster</a> </li></ul><br><h2>  <font color="#3AC1EF">Legacy-Browser-Unterstützung</font> </h2><br>  Weltweit unterstützen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr als 83% der Browser</a> JavaScript-Module (einschließlich des dynamischen Imports). Daher können die meisten Benutzer ohne besonderen Aufwand seitens der Entwickler dieses Projekts mit einem Projekt arbeiten, das auf Module umgestellt wurde. <br><br>  Bei Browsern, die Module unterstützen, aber keinen dynamischen Import unterstützen, wird empfohlen, die oben beschriebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyfill für den dynamischen Import und die Polyfüllung zu verwenden</a> .  Da es sehr klein ist und nach Möglichkeit die standardmäßige browserbasierte <code>import()</code> -Methode verwendet, hat die Verwendung dieser Polyfüllung fast keinen Einfluss auf die Größe oder Leistung des Projekts. <br><br>  Wenn wir über Browser sprechen, die Module absolut nicht unterstützen, können Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modul / Nomodule-Muster verwenden</a> , um die Arbeit mit ihnen zu organisieren. <br><br><h3>  <font color="#3AC1EF">▍Bedienungsbeispiel</font> </h3><br>  Da es immer einfacher ist, über die Cross-Browser-Kompatibilität zu sprechen, als sie zu erreichen, habe ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Anwendung erstellt</a> , die die oben beschriebenen Technologien verwendet. <br><br>  Diese Anwendung funktioniert in Browsern wie Edge 18 und Firefox ESR, die keine dynamischen <code>import()</code> -Befehle unterstützen.  Darüber hinaus funktioniert es in Browsern wie Internet Explorer 11, die keine Module unterstützen. <br><br>  Um zu zeigen, dass die hier diskutierte Strategie nicht nur für einfache Projekte geeignet ist, habe ich in dieser Anwendung viele Funktionen verwendet, die heute in großen Projekten benötigt werden: <br><br><ul><li>  Codetransformation mit Babel (einschließlich JSX). </li><li>  CommonJS-Abhängigkeiten (z. B. Reagieren und Reagieren). </li><li>  CSS-Abhängigkeiten. </li><li>  Ressourcen-Hashing </li><li>  Codetrennung </li><li>  Dynamischer Import (mit einem Fallback als Polyfill). </li><li>  Implementierung des Modul / Nomodul-Musters. </li></ul><br>  Der Projektcode befindet sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> Sie können das Repository aufteilen und das Projekt selbst erstellen). Die Demoversion wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glitch</a> gehostet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sodass</a> Sie damit experimentieren können. <br><br>  Das Wichtigste im Demo-Projekt ist die <a href="">Rollup-Konfiguration</a> , da sie bestimmt, wie die resultierenden Module erstellt werden. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ich hoffe, dieses Material hat Sie nicht nur von der Möglichkeit überzeugt, Standard-JavaScript-Module in der Produktion bereitzustellen, sondern auch davon, dass es die Ladezeit der Site und ihre Leistung wirklich verbessern kann. <br><br>  Hier ist eine kurze Übersicht über die Schritte, die Sie ausführen müssen, um die Module im Projekt zu implementieren: <br><br><ul><li>  Verwenden Sie einen Bundler unter den unterstützten Ausgabeformaten, für die ES2015-Module vorhanden sind. </li><li>  Aggressive Annäherung an die <code>node_modules</code> (wenn möglich bis zur Zuordnung von Abhängigkeiten von <code>node_modules</code> zu separaten Fragmenten). </li><li>  Laden Sie alle Module in Ihrem statischen Abhängigkeitsbaum vor (mithilfe von <code>modulepreload</code> ). </li><li>  Verwenden Sie polyfill für Browser, die keine dynamischen <code>import()</code> -Anweisungen unterstützen. </li><li>  Verwenden Sie das Modul- / Nomodelmuster, um die Arbeit mit Browsern zu organisieren, die keine Module unterstützen. </li></ul><br>  Wenn Sie Rollup bereits zum Erstellen des Projekts verwenden, möchten wir, dass Sie versuchen, worüber ich hier gesprochen habe, und echte Module in der Produktion bereitstellen (mithilfe von Codetrennung und dynamischen Importtechniken).  Wenn Sie dies tun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lassen Sie mich wissen,</a> wie es Ihnen geht.  Ich interessiere mich für Probleme und erfolgreiche Fälle der Einführung von Modulen. <br><br>  Es ist sehr klar, dass Module die Zukunft von JavaScript sind.  Ich würde gerne und vorzugsweise bald sehen, wie die von uns verwendeten Tools und die Hilfsbibliotheken diese Technologie übernehmen.  Ich hoffe, dass dieses Material diesen Prozess zumindest ein wenig unterstützen kann. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie JS-Module in der Produktion? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466539/">https://habr.com/ru/post/de466539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466525/index.html">Was ist ein PSD iPhone Layout und wie wird es verwendet?</a></li>
<li><a href="../de466527/index.html">Testen der Benutzerfunktionalität von Websites mit Capybara-Seitenobjekten</a></li>
<li><a href="../de466529/index.html">Kompilierungstypen in der JVM: Aufdecken der Black Magic-Sitzung</a></li>
<li><a href="../de466535/index.html">DeepClone neu denken</a></li>
<li><a href="../de466537/index.html">Verwendung von JavaScript-Modulen in der Produktion: aktueller Stand der Dinge. Teil 1</a></li>
<li><a href="../de466541/index.html">Verwenden von DbTool zum Seeding von Datenbanken in .NET-Anwendungen (Core)</a></li>
<li><a href="../de466543/index.html">Habr Weekly # 17 / Sberbank-Darlehen werden von AI genehmigt - beängstigend, Werbung in Open-Source-Produkten - zweifelhaft</a></li>
<li><a href="../de466547/index.html">Glücklicher Programmiertag</a></li>
<li><a href="../de466549/index.html">Allgemeine Funktionsprinzipien von QEMU-KVM</a></li>
<li><a href="../de466551/index.html">Puppenspieler mit ES6 in einem Knoten und Browser oder warum Zora das beste Testframework in seiner Nische ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>