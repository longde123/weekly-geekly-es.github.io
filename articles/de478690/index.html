<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÅ ‚û∞ ‚ùï Dynamische Assemblierung und Bereitstellung von Docker-Images mit werf anhand der Beispielsite der versionierten Dokumentation üö≠ üßëüèº üóíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben bereits mehr als einmal √ºber unser werf GitOps-Tool gesprochen, aber dieses Mal m√∂chten wir die Erfahrung beim Erstellen der Site mit der Pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dynamische Assemblierung und Bereitstellung von Docker-Images mit werf anhand der Beispielsite der versionierten Dokumentation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/478690/">  Wir haben bereits mehr <a href="https://github.com/flant/werf">als einmal</a> √ºber unser werf GitOps-Tool gesprochen, aber dieses Mal m√∂chten wir die Erfahrung beim <a href="https://werf.io/">Erstellen</a> der Site mit der Projektdokumentation - <a href="https://werf.io/">werf.io</a> (die russische Version ist <a href="https://ru.werf.io/">ru.werf.io</a> ) <a href="https://ru.werf.io/">teilen</a> .  Dies ist eine regul√§re statische Site, aber ihre Assembly ist interessant, da sie mit einer dynamischen Anzahl von Artefakten erstellt wird. <br><br><img src="https://habrastorage.org/webt/m_/ox/od/m_oxod8ckyfsipscttspcn5opd8.png"><br><br>  Gehen Sie auf die Feinheiten der Site-Struktur ein: Generieren eines allgemeinen Men√ºs f√ºr alle Versionen, Seiten mit Informationen zu Releases usw.  - werden wir nicht.  Stattdessen konzentrieren wir uns auf Probleme und Funktionen der dynamischen Assembly und ein wenig auf die begleitenden CI / CD-Prozesse. <a name="habracut"></a><br><br><h2>  Einf√ºhrung: Wie ist die Site aufgebaut? </h2><br>  Zu Beginn wird die werf-Dokumentation zusammen mit ihrem Code gespeichert.  Dies stellt bestimmte Entwicklungsanforderungen, die im Allgemeinen √ºber den Rahmen dieses Artikels hinausgehen, aber zumindest k√∂nnen wir Folgendes sagen: <br><br><ul><li>  Neue werf-Funktionen sollten nicht ohne Aktualisierung der Dokumentation freigegeben werden. Umgekehrt implizieren √Ñnderungen in der Dokumentation die Freigabe einer neuen werf-Version. </li><li>  Das Projekt hat eine ziemlich intensive Entwicklung: neue Versionen k√∂nnen mehrmals am Tag erscheinen; </li><li>  Die manuelle Bereitstellung einer Site mit einer neuen Version der Dokumentation ist zumindest m√ºhsam. </li><li>  Das Projekt verfolgte den Ansatz der semantischen <a href="https://ru.werf.io/releases.html">Versionierung</a> mit 5 Stabilit√§tskan√§len.  Der Freisetzungsprozess beinhaltet den sequentiellen Durchlauf von Versionen durch die Kan√§le, um die Stabilit√§t zu erh√∂hen: von Alpha zu Rock-Solid; </li><li>  Die Site verf√ºgt √ºber eine russischsprachige Version, die parallel zur Hauptversion (dh der englischen Version) "lebt und sich entwickelt" (dh deren Inhalt aktualisiert wird). </li></ul><br>  Um dem Benutzer diese ‚Äûinnere K√ºche‚Äú <b>vorenthalten zu k√∂nnen und</b> ihm etwas anzubieten, das ‚Äûeinfach funktioniert‚Äú, haben wir ein <b>separates werf-Installations- und Aktualisierungstool erstellt</b> - das ist <a href="https://github.com/flant/multiwerf">multiwerf</a> .  Es reicht aus, die Release-Nummer und den Stabilit√§tskanal anzugeben, den Sie verwenden m√∂chten. Multiwerf pr√ºft, ob eine neue Version auf dem Kanal vorhanden ist, und l√§dt sie gegebenenfalls herunter. <br><br>  Die neueste Version von werf in jedem Kanal ist im Versionsauswahlmen√º auf der Site verf√ºgbar.  Standardm√§√üig wird die Version des stabilsten Kanals f√ºr die neueste Version unter <a href="https://werf.io/documentation/">werf.io/documentation ge√∂ffnet.</a> Sie wird auch von Suchmaschinen indiziert.  Die Dokumentation f√ºr den Channel ist unter einzelnen Adressen verf√ºgbar (z. B. <a href="https://werf.io/v1.0-beta/documentation/">werf.io/v1.0-beta/documentation</a> f√ºr Beta-Release 1.0). <br><br>  Insgesamt hat die Website die folgenden Versionen: <br><br><ol><li>  root (wird standardm√§√üig ge√∂ffnet) </li><li>  f√ºr jeden aktiven Update-Kanal jeder Version (z. B. <a href="https://werf.io/v1.0-beta/">werf.io/v1.0-beta</a> ). </li></ol><br>  Um im allgemeinen Fall eine bestimmte Version einer Site zu generieren, gen√ºgt es, sie mit <a href="https://jekyllrb.com/">Jekyll-</a> Tools zu kompilieren, indem Sie den entsprechenden Befehl ( <code>jekyll build</code> ) im Verzeichnis <code>/docs</code> des Werf-Repositorys ausf√ºhren, nachdem Sie zum Git-Tag der erforderlichen Version gewechselt haben. <br><br>  Es bleibt nur hinzuzuf√ºgen, dass: <br><br><ul><li>  Das Dienstprogramm selbst (werf) wird f√ºr die Montage verwendet. </li><li>  CI / CD-Prozesse basieren auf GitLab CI; </li><li>  und das alles funktioniert nat√ºrlich in Kubernetes. </li></ul><br><h2>  Die Aufgaben </h2><br>  Nun formulieren wir Aufgaben, die alle beschriebenen Besonderheiten ber√ºcksichtigen: <br><br><ol><li>  Nach dem √Ñndern der werf-Version in einem Update-Kanal sollte die <b>Dokumentation auf der Site automatisch aktualisiert werden</b> . </li><li>  F√ºr die Entwicklung m√ºssen Sie gelegentlich <b>vorl√§ufige Versionen der Site anzeigen k√∂nnen</b> . </li></ol><br>  Die erneute Kompilierung der Site muss durchgef√ºhrt werden, nachdem die Version auf einem Kanal von den entsprechenden Git-Tags ge√§ndert wurde. Beim Erstellen des Images werden jedoch die folgenden Funktionen bereitgestellt: <br><br><ul><li>  Da sich die Liste der Versionen in den Kan√§len √§ndert, muss die Dokumentation nur f√ºr die Kan√§le neu zusammengestellt werden, in denen sich die Version ge√§ndert hat.  Immerhin ist es nicht sehr sch√∂n, alles wieder zusammenzusetzen. </li><li>  Die Anzahl der Kan√§le f√ºr Ver√∂ffentlichungen kann variieren.  Zu einem bestimmten Zeitpunkt ist die Version auf den Channels m√∂glicherweise nicht stabiler als die Version 1.1 f√ºr den fr√ºhen Zugriff. Mit der Zeit werden sie jedoch angezeigt. √Ñndern Sie in diesem Fall die Assembly nicht manuell. </li></ul><br>  Es stellt sich heraus, dass die <b>Assembly von der √Ñnderung externer Daten abh√§ngt</b> . <br><br><h2>  Implementierung </h2><br><h3>  Wahl des Ansatzes </h3><br>  Alternativ k√∂nnen Sie jede erforderliche Version mit einem separaten Pod in Kubernetes ausf√ºhren.  Diese Option impliziert eine gr√∂√üere Anzahl von Objekten im Cluster, die mit zunehmender Anzahl stabiler werf-Releases zunehmen wird.  Dies wiederum impliziert einen komplexeren Service: Jede Version hat einen eigenen HTTP-Server und eine geringe Auslastung.  Dies ist nat√ºrlich mit h√∂heren Kosten f√ºr Ressourcen verbunden. <br><br>  Wir sind den Weg gegangen, <b>alle notwendigen Versionen in einem Image zusammenzufassen</b> .  Die kompilierte Statistik aller Versionen der Site befindet sich in einem Container mit NGINX, und der Datenverkehr zur entsprechenden Bereitstellung erfolgt √ºber NGINX Ingress.  Eine einfache Struktur - eine zustandslose Anwendung - erleichtert die Skalierung der Bereitstellung (abh√§ngig von der Auslastung) mithilfe von Kubernetes. <br><br>  Genauer gesagt, wir sammeln zwei Bilder: eines f√ºr die Produktionsschaltung, das andere f√ºr die Entwicklungsschaltung.  Ein zus√§tzliches Image wird nur auf dem Entwicklungs-Circuit zusammen mit dem Haupt-Image verwendet (gestartet) und enth√§lt die Site-Version aus dem √úberpr√ºfungs-Commit. Das Routing zwischen diesen Images wird mithilfe von Ingress-Ressourcen durchgef√ºhrt. <br><br><h3>  werf vs git Klon und Artefakte </h3><br>  Wie bereits erw√§hnt, m√ºssen Sie zum Generieren von Websitestatiken f√ºr eine bestimmte Version der Dokumentation auf das entsprechende Repository-Tag wechseln.  Sie k√∂nnen dies auch tun, indem Sie das Repository jedes Mal w√§hrend der Assembly klonen und die entsprechenden Tags aus der Liste ausw√§hlen.  Dies ist jedoch ein ziemlich ressourcenintensiver Vorgang und erfordert dar√ºber hinaus das Schreiben von nicht trivialen Anweisungen ... Ein weiteres schwerwiegendes Minus - bei diesem Ansatz ist es nicht m√∂glich, w√§hrend der Montage etwas zwischenzuspeichern. <br><br>  Hier hilft uns das Dienstprogramm werf, das <b>Smart Caching</b> implementiert und die Verwendung <a href="https://ru.werf.io/documentation/configuration/stapel_image/git_directive.html"><b>externer Repositorys erm√∂glicht</b></a> .  Die Verwendung von werf zum Hinzuf√ºgen von Code aus dem Repository beschleunigt den Build erheblich  werf klont das Repository im Wesentlichen einmal und <code>fetch</code> dann <i>nur</i> bei Bedarf.  Au√üerdem k√∂nnen wir beim Hinzuf√ºgen von Daten aus dem Repository nur die erforderlichen Verzeichnisse ausw√§hlen (in unserem Fall ist dies das Verzeichnis <code>docs</code> ), wodurch sich die Menge der hinzugef√ºgten Daten erheblich verringert. <br><br>  Da Jekyll ein Werkzeug zum Kompilieren von <a href="https://ru.werf.io/documentation/configuration/stapel_artifact.html">Statiken</a> ist und im endg√ºltigen Bild nicht ben√∂tigt wird, w√§re es logisch, das <a href="https://ru.werf.io/documentation/configuration/stapel_artifact.html">werf-Artefakt</a> zu kompilieren und <b>nur das Kompilierungsergebnis</b> in das endg√ºltige Bild zu <b>importieren</b> . <br><br><h3>  Schreiben werf.yaml </h3><br>  Deshalb haben wir beschlossen, jede Version in einem eigenen Werf-Artefakt zu kompilieren.  Wir <b>wissen jedoch nicht, wie viele dieser Artefakte w√§hrend der Montage vorhanden sein werden</b> , daher k√∂nnen wir keine feste Montagekonfiguration schreiben (genau genommen k√∂nnen wir das immer noch, aber es wird nicht vollst√§ndig effektiv sein). <br><br>  Mit werf k√∂nnen Sie <a href="https://ru.werf.io/documentation/configuration/introduction.html">Go-Templates</a> in Ihrer Konfigurationsdatei ( <code>werf.yaml</code> ) verwenden. Auf diese Weise k√∂nnen Sie <b>eine Konfiguration "on the fly" in</b> Abh√§ngigkeit von externen Daten erstellen (was Sie ben√∂tigen!).  Bei externen Daten handelt es sich in unserem Fall um Informationen zu Versionen und Releases, auf deren Grundlage wir die erforderliche Anzahl von Artefakten sammeln und als Ergebnis zwei Bilder erhalten: <code>werf-doc</code> und <code>werf-dev</code> , die auf unterschiedlichen Pfaden ausgef√ºhrt werden. <br><br>  Externe Daten werden √ºber Umgebungsvariablen √ºbergeben.  Hier ist ihre Zusammensetzung: <br><br><ul><li>  <code>RELEASES</code> - eine Zeile mit einer Liste von Releases und der entsprechenden aktuellen Version von werf in Form einer durch ein Leerzeichen getrennten Liste im Format <code>&lt;_&gt;%&lt;_&gt;</code> .  Beispiel: <code>1.0%v1.0.4-beta.20</code> </li><li>  <code>CHANNELS</code> - eine Zeile mit einer Liste von Kan√§len und der entsprechenden aktuellen Version von werf in Form einer Liste mit einem Leerzeichen von Werten im Format <code>&lt;&gt;%&lt;_&gt;</code> .  Beispiel: <code>1.0-beta%v1.0.4-beta.20 1.0-alpha%v1.0.5-alpha.22</code> </li><li>  <code>ROOT_VERSION</code> - Die Version der werf-Version, die standardm√§√üig auf der Site angezeigt wird (es ist nicht immer erforderlich, die Dokumentation f√ºr die h√∂chste Versionsnummer anzuzeigen).  Beispiel: <code>v1.0.4-beta.20</code> </li><li>  <code>REVIEW_SHA</code> - Hash des √úberpr√ºfungs-Commits, aus dem Sie die Version f√ºr die <code>REVIEW_SHA</code> m√ºssen. </li></ul><br>  Diese Variablen werden in der GitLab-CI-Pipeline eingetragen und wie genau dies nachfolgend beschrieben wird. <br><br>  Zun√§chst definieren wir der <code>werf.yaml</code> Go-Template-Variablen in <code>werf.yaml</code> indem wir ihnen Werte aus Umgebungsvariablen <code>werf.yaml</code> : <br><br><pre> <code class="go hljs">{{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfVersions"</span></span> (cat (env <span class="hljs-string"><span class="hljs-string">"CHANNELS"</span></span>) (env <span class="hljs-string"><span class="hljs-string">"RELEASES"</span></span>) | splitList <span class="hljs-string"><span class="hljs-string">" "</span></span>) }} {{ $Root := . }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfRootVersion"</span></span> (env <span class="hljs-string"><span class="hljs-string">"ROOT_VERSION"</span></span>) }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfReviewCommit"</span></span> (env <span class="hljs-string"><span class="hljs-string">"REVIEW_SHA"</span></span>) }}</code> </pre> <br>  Die Beschreibung des Artefakts zum Kompilieren der Statik der Site-Version ist im Allgemeinen f√ºr alle F√§lle gleich (einschlie√ülich der Generierung der Root-Version sowie der Version f√ºr die Dev-Schaltung).  Daher platzieren wir es mit der Funktion <code>define</code> in einem separaten Block - f√ºr die sp√§tere Wiederverwendung mit <code>include</code> .  Wir werden die folgenden Argumente an die Vorlage √ºbergeben: <br><br><ul><li>  <code>Version</code> - generierte Version (Tagname); </li><li>  <code>Channel</code> - Der Name des Aktualisierungskanals, f√ºr den das Artefakt generiert wird. </li><li>  <code>Commit</code> - Commit-Hash, wenn ein Artefakt f√ºr das Review-Commit generiert wird. </li><li>  Kontext. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Beschreibung der Artefaktvorlage</b> <div class="spoiler_text"><pre> <code class="go hljs">{{- define <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> -}} {{- $Root := index . <span class="hljs-string"><span class="hljs-string">"Root"</span></span> -}} artifact: doc-{{ .Channel }} from: jekyll/builder:<span class="hljs-number"><span class="hljs-number">3</span></span> mount: - from: build_dir to: /usr/local/bundle ansible: install: - shell: | export PATH=/usr/jekyll/bin/:$PATH - name: <span class="hljs-string"><span class="hljs-string">"Install Dependencies"</span></span> shell: bundle install args: executable: /bin/bash chdir: /app/docs beforeSetup: {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .Commit }} - shell: echo <span class="hljs-string"><span class="hljs-string">"Review SHA - {{ .Commit }}."</span></span> {{- end }} {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> eq .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} - name: <span class="hljs-string"><span class="hljs-string">"releases.yml HASH: {{ $Root.Files.Get "</span></span>releases.yml<span class="hljs-string"><span class="hljs-string">" | sha256sum }}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ $Root.Files.Get <span class="hljs-string"><span class="hljs-string">"releases.yml"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /app/docs/_data/releases.yml {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} - file: path: /app/docs/_data/releases.yml state: touch {{- end }} - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/ - /app/ru_site/ - file: dest: /app/docs/pages_ru/cli state: link src: /app/docs/pages/cli - shell: | echo -e <span class="hljs-string"><span class="hljs-string">"werfVersion: {{ .Version }}\nwerfChannel: {{ .Channel }}"</span></span> &gt; /tmp/_config_additional.yml export PATH=/usr/jekyll/bin/:$PATH {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> and (ne .Version <span class="hljs-string"><span class="hljs-string">"review"</span></span>) (ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span>) }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> ( printf <span class="hljs-string"><span class="hljs-string">"v%s"</span></span> .Channel ) }} {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> .Channel }} {{- end }} jekyll build -s /app/docs -d /app/_main_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/tmp/_config_additional.yml jekyll build -s /app/docs -d /app/_ru_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/app/docs/_config_ru.yml,/tmp/_config_additional.yml args: executable: /bin/bash chdir: /app/docs git: - url: https:<span class="hljs-comment"><span class="hljs-comment">//github.com/flant/werf.git to: /app/ owner: jekyll group: jekyll {{- if .Commit }} commit: {{ .Commit }} {{- else }} tag: {{ .Version }} {{- end }} stageDependencies: install: ['docs/Gemfile','docs/Gemfile.lock'] beforeSetup: '**/*' includePaths: 'docs' excludePaths: '**/*.sh' {{- end }}</span></span></code> </pre> </div></div><br>  Der Name des Artefakts muss eindeutig sein.  Dies k√∂nnen wir beispielsweise erreichen, indem wir den Namen des Kanals (Wert der Variablen <code>.Channel</code> ) als Suffix f√ºr den Namen des Artefakts <code>artifact: doc-{{ .Channel }}</code> : <code>artifact: doc-{{ .Channel }}</code> .  Sie m√ºssen jedoch wissen, dass Sie beim Importieren aus Artefakten auf dieselben Namen verweisen m√ºssen. <br><br>  Bei der Beschreibung eines Artefakts wird ein werf-Feature wie <a href="https://ru.werf.io/documentation/configuration/stapel_image/mount_directive.html">mount verwendet</a> .  Durch das Mounten mit dem <code>build_dir</code> k√∂nnen Sie den Jekyll-Cache zwischen den Pipeline-Starts speichern, was die <code>build_dir</code> <b>erheblich beschleunigt</b> . <br><br>  M√∂glicherweise haben Sie auch die Verwendung der Datei <code>releases.yml</code> bemerkt - dies ist die YAML-Datei mit den von <a href="https://github.com/flant/werf">github.com</a> angeforderten <a href="https://github.com/flant/werf">Versionsdaten</a> (das durch Ausf√ºhren der Pipeline erhaltene Artefakt).  Es wird beim Kompilieren der Site ben√∂tigt, aber im Kontext des Artikels interessiert uns die Tatsache, dass <b>nur ein Artefakt</b> , das Root- <b>Artefakt</b> der Site-Version <b>,</b> von seinem Status abh√§ngt (in anderen Artefakten wird es nicht ben√∂tigt). <br><br>  Dies wird mithilfe des bedingten Operators f√ºr <code>if</code> Vorlagen und der <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code>  <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code> auf der <a href="https://ru.werf.io/documentation/reference/stages_and_images.html">B√ºhne</a> .  Dies funktioniert folgenderma√üen: Wenn Sie ein Artefakt f√ºr die Stammversion zusammenstellen (die Variable <code>.Channel</code> ist <code>root</code> ), wirkt sich der Hash der Datei <code>releases.yml</code> auf die Signatur der gesamten Phase aus, da er Bestandteil des Namens des Ansible-Jobs ist (Parameter <code>name</code> ).  Wenn Sie also den <b>Inhalt der</b> Datei <code>releases.yml</code> √§ndern, wird das entsprechende Artefakt neu erstellt. <br><br>  Achten Sie auch auf die Arbeit mit einem externen Repository.  Nur das Verzeichnis <code>/docs</code> wird dem Image des Artefakts aus <a href="">dem Werf-Repository</a> hinzugef√ºgt. Abh√§ngig von den √ºbergebenen Parametern werden die Daten des erforderlichen Tags oder des erforderlichen √úberpr√ºfungs-Commits sofort hinzugef√ºgt. <br><br>  Um mithilfe der Artefaktvorlage eine Artefaktbeschreibung der √ºbertragenen Versionen von Channels und Releases zu generieren, organisieren wir eine Schleife f√ºr die Variable <code>.WerfVersions</code> in <code>werf.yaml</code> : <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> $VersionsDict._1 <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> $VersionsDict._0 <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{ end -}}</code> </pre> <br>  Weil  Die Schleife erzeugt mehrere Artefakte (wir hoffen es). Es ist notwendig, das Trennzeichen zwischen ihnen zu ber√ºcksichtigen - die Reihenfolge <code>---</code> (weitere Informationen zur Syntax der Konfigurationsdatei finden Sie in der <a href="https://ru.werf.io/documentation/configuration/introduction.html">Dokumentation</a> ).  Wie zuvor festgelegt, √ºbergeben wir beim Aufrufen der Vorlage in einer Schleife die Versionsparameter, die URL und den Stammkontext. <br><br>  √Ñhnlich, aber bereits ohne Schleife, rufen wir die Artefaktvorlage f√ºr "Sonderf√§lle" auf: f√ºr die Root-Version sowie f√ºr die Version aus dem Review-Commit: <br><br><pre> <code class="go hljs">{{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> .WerfRootVersion <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"root"</span></span> <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .WerfReviewCommit }} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Commit"</span></span> .WerfReviewCommit <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} {{- end }}</code> </pre> <br>  Beachten Sie, dass das Artefakt f√ºr das √úberpr√ºfungs-Commit nur erfasst wird, wenn die Variable <code>.WerfReviewCommit</code> ist. <br><br>  Artefakte sind fertig - es ist Zeit zu importieren! <br><br>  Das endg√ºltige Image, das f√ºr die Ausf√ºhrung in Kubernetes entwickelt wurde, ist ein regul√§res NGINX-Image, in dem die <code>nginx.conf</code> und <code>nginx.conf</code> von Artefakten hinzugef√ºgt werden.  Zus√§tzlich zum Artefakt der Root-Version der Site m√ºssen wir die Schleife f√ºr die Variable <code>.WerfVersions</code> wiederholen, um Artefakte der Versionen von Channels und Releases zu importieren. + <code>.WerfVersions</code> die zuvor angenommene Benennungsregel f√ºr Artefakte.  Da jedes Artefakt Versionen der Site f√ºr zwei Sprachen speichert, importieren wir sie an den in der Konfiguration angegebenen Stellen. <br><br><div class="spoiler">  <b class="spoiler_title">Beschreibung des endg√ºltigen werf-doc-Image</b> <div class="spoiler_text"><pre> <code class="go hljs">image: werf-doc from: nginx:stable-alpine ansible: setup: - name: <span class="hljs-string"><span class="hljs-string">"Setup /etc/nginx/nginx.conf"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ .Files.Get <span class="hljs-string"><span class="hljs-string">".werf/nginx.conf"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /etc/nginx/nginx.conf - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/assets - /app/ru_site/assets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_main_site to: /app/main_site/v{{ $Channel }} before: setup {{ end -}} {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_ru_site to: /app/ru_site/v{{ $Channel }} before: setup {{ end -}}</code> </pre> </div></div><br>  Das zus√§tzliche Image, das zusammen mit dem Hauptimage auf der Entwickler-Schaltung gestartet wird, enth√§lt nur zwei Versionen der Site: die Version aus dem Review-Commit und die Root-Version der Site (es gibt allgemeine Assets und, wenn Sie sich erinnern, Release-Daten).  Daher unterscheidet sich das zus√§tzliche Bild vom Hauptbild nur im Importbereich (und nat√ºrlich im Namen): <br><br><pre> <code class="plaintext hljs">image: werf-dev ... import: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{- if .WerfReviewCommit }} - artifact: doc-review add: /app/_main_site to: /app/main_site/review before: setup - artifact: doc-review add: /app/_ru_site to: /app/ru_site/review before: setup {{- end }}</code> </pre> <br>  Wie bereits oben erw√§hnt, wird das Artefakt f√ºr das √úberpr√ºfungs-Commit nur generiert, wenn werf mit der Umgebungsvariablen REVIEW_SHA startet.  Es w√§re m√∂glich, √ºberhaupt kein werf-dev-Image zu generieren, wenn es keine <code>REVIEW_SHA</code> Umgebungsvariable gibt. Damit jedoch die werf-dev- <a href="https://ru.werf.io/documentation/reference/cleaning_process.html">basierte Bereinigung von Richtlinien f√ºr</a> Docker-Images f√ºr das werf-dev-Image funktioniert, lassen wir es nur mit dem Artefakt der Root-Version (wie auch immer) sammeln bereits montiert), um den Aufbau der Pipeline zu vereinfachen. <br><br>  Die Montage ist fertig!  Wir gehen zu CI / CD und wichtigen Nuancen √ºber. <br><br><h3>  Pipeline in GitLab CI und Funktionen der dynamischen Assemblierung </h3><br>  Beim Starten der Assembly m√ºssen die in <code>werf.yaml</code> verwendeten Umgebungsvariablen <code>werf.yaml</code> .  Dies gilt nicht f√ºr die Variable REVIEW_SHA, die wir festlegen, wenn die Pipeline vom GitHub-Hook aufgerufen wird. <br><br>  Wir werden die erforderlichen externen Daten im Bash-Skript generate_artifacts <code>generate_artifacts</code> , das zwei GitLab-Pipeline-Artefakte generiert: <br><br><ul><li>  Datei <code>releases.yml</code> mit Versionsdaten, </li><li>  Datei <code>common_envs.sh</code> mit Umgebungsvariablen f√ºr den Export. </li></ul><br>  Den Inhalt der Datei <code>generate_artifacts</code> in unserem <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">Beispielrepository</a> .  Das Erhalten von Daten ist nicht Gegenstand des Artikels, aber die Datei <code>common_envs.sh</code> ist wichtig f√ºr uns, weil  die arbeit von werf h√§ngt davon ab.  Ein Beispiel f√ºr seinen Inhalt: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> RELEASES=<span class="hljs-string"><span class="hljs-string">'1.0%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CHANNELS=<span class="hljs-string"><span class="hljs-string">'1.0-alpha%v1.0.7-1 1.0-beta%v1.0.7-1 1.0-ea%v1.0.6-4 1.0-stable%v1.0.6-4 1.0-rock-solid%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ROOT_VERSION=<span class="hljs-string"><span class="hljs-string">'v1.0.6-4'</span></span></code> </pre> <br>  Sie k√∂nnen die Ausgabe eines solchen Skripts zum Beispiel mit der <code>source</code> Bash-Funktion verwenden. <br><br>  Und jetzt zum spa√üigen Teil.  Damit die Anwendungen zum Erstellen und Bereitstellen ordnungsgem√§√ü funktionieren, m√ºssen Sie <code>werf.yaml</code> f√ºr mindestens <b>eine Pipeline auf</b> <code>werf.yaml</code> <b>gleichen</b> <code>werf.yaml</code> .  Wenn diese Bedingung nicht erf√ºllt ist, unterscheiden sich die Signaturen der Stufen, die beim Zusammenbau berechnet werden, und beispielsweise die Bereitstellung.  Dies f√ºhrt zu einem Bereitstellungsfehler  Das f√ºr die Bereitstellung erforderliche Image fehlt. <br><br>  Mit anderen Worten: Wenn w√§hrend der Erstellung des Site-Image die Informationen zu Releases und Versionen eins sind und zum Zeitpunkt der Ver√∂ffentlichung eine neue Version ver√∂ffentlicht wird und die Umgebungsvariablen unterschiedliche Werte aufweisen, schl√§gt die Bereitstellung mit einem Fehler fehl: Das Artefakt der neuen Version wurde noch nicht erfasst. <br><br>  Wenn die Generierung von <code>werf.yaml</code> von externen Daten abh√§ngt (z. B. einer Liste aktueller Versionen, wie in unserem Fall), sollten die Zusammensetzung und die Werte solcher Daten in der Pipeline aufgezeichnet werden.  Dies ist besonders wichtig, wenn sich die externen Parameter h√§ufig √§ndern. <br><br>  Wir werden <b>externe Daten</b> in der ersten Phase der Pipeline in GitLab ( <i>Prebuild</i> ) <b>empfangen, erfassen</b> und als <b>GitLab-CI-Artefakt</b> <i>weiterleiten</i> .  Auf diese Weise k√∂nnen Sie Pipeline-Tasks (Erstellen, Bereitstellen, Bereinigen) mit derselben Konfiguration in <code>werf.yaml</code> starten und neu <code>werf.yaml</code> . <br><br>  Der Inhalt der <i>Vorbereitungsphase</i> der Datei <i>.gitlab</i> - <i>ci.yml</i> : <br><br><pre> <code class="plaintext hljs">Prebuild: stage: prebuild script: - bash ./generate_artifacts 1&gt; common_envs.sh - cat ./common_envs.sh artifacts: paths: - releases.yml - common_envs.sh expire_in: 2 week</code> </pre> <br>  Durch Erfassen externer Daten in einem Artefakt k√∂nnen Sie mithilfe der Standard-GitLab CI-Pipeline-Phasen erstellen und bereitstellen: Erstellen und Bereitstellen.  Wir starten die Pipeline durch Hooks aus dem gerHub-Repository werf (d. H. Beim √Ñndern des Repositorys auf GitHub).  Die Daten f√ºr sie k√∂nnen in den Eigenschaften des GitLab-Projekts im <i>Abschnitt CI / CD-Einstellungen -&gt; Pipeline-Trigger</i> abgerufen und anschlie√üend in GitHub der entsprechende Webhook ( <i>Einstellungen -&gt; Webhooks</i> ) erstellt werden. <br><br>  Die Erstellungsphase sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">Build: stage: build script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf build-and-publish --stages-storage :local except: refs: - schedules dependencies: - Prebuild</code> </pre> <br>  GitLab f√ºgt der <i>Erstellungsphase</i> zwei Artefakte aus der <i>Prebuild-</i> Phase hinzu, sodass wir die Variablen mit vorbereiteten Eingaben mithilfe des <code>source common_envs.sh</code> .  In jedem Fall beginnen wir mit der Montage, mit Ausnahme des termingerechten Starts der Pipeline.  Entsprechend dem Zeitplan wird die Pipeline zur Reinigung in Betrieb genommen - wir m√ºssen in diesem Fall nicht bauen. <br><br>  In der Bereitstellungsphase beschreiben wir zwei Aufgaben - getrennt f√ºr die Bereitstellung auf Produktions- und Entwicklungsschaltkreisen unter Verwendung der YAML-Vorlage: <br><br><pre> <code class="plaintext hljs">.base_deploy: &amp;base_deploy stage: deploy script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf deploy --stages-storage :local dependencies: - Prebuild except: refs: - schedules Deploy to Production: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: prod environment: name: production url: werf.io only: refs: - master except: variables: - $REVIEW_SHA refs: - schedules Deploy to Test: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: dev environment: name: test url: werf.test.flant.com except: refs: - schedules only: variables: - $REVIEW_SHA</code> </pre> <br>  Die Aufgaben unterscheiden sich im Wesentlichen nur dadurch, dass der Kontext des Clusters angegeben wird, in dem das Deployment ausgef√ºhrt werden soll ( <code>WERF_KUBE_CONTEXT</code> ) und die Umgebungsvariablen der Kontur ( <code>environment.name</code> und <code>environment.url</code> ) festgelegt werden, die dann in den Helm-Diagrammvorlagen verwendet werden.  Der Inhalt der Vorlagen wird nicht angegeben, weil  Es gibt nichts Interessantes f√ºr dieses Thema, aber Sie finden sie im <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">Artikel-Repository</a> . <br><br><h3>  Letzte Ber√ºhrung </h3><br>  Da die werf-Versionen h√§ufig ver√∂ffentlicht werden, werden h√§ufig neue Bilder gesammelt und die Docker-Registrierung wird st√§ndig erweitert.  Daher ist es erforderlich, die automatische Bereinigung von Bildern nach Richtlinien zu konfigurieren.  Es ist sehr einfach zu machen. <br><br>  Zur Implementierung ben√∂tigen Sie: <br><br><ul><li>  <code>.gitlab-ci.yml</code> einen Reinigungsschritt zu <code>.gitlab-ci.yml</code> ; </li><li>  Hinzuf√ºgen von regelm√§√üigen Bereinigungsaufgaben; </li><li>  Setzen Sie die Umgebungsvariable mit Schreibzugriffstoken. </li></ul><br>  F√ºgen Sie die Bereinigungsstufe zu <code>.gitlab-ci.yml</code> : <br><br><pre> <code class="plaintext hljs">Cleanup: stage: cleanup script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - docker login -u nobody -p ${WERF_IMAGES_CLEANUP_PASSWORD} ${WERF_IMAGES_REPO} - werf cleanup --stages-storage :local only: refs: - schedules</code> </pre><br>  Fast alle von uns haben dies bereits ein wenig h√∂her gesehen - nur zum Reinigen m√ºssen Sie sich zuerst mit einem Token bei der Docker-Registrierung anmelden, das zum L√∂schen von Bildern in der Docker-Registrierung berechtigt ist (das automatisch ausgegebene GitLab CI-Task-Token verf√ºgt nicht √ºber solche Rechte).  Das Token muss zuvor in GitLab eingegeben und sein Wert in der Umgebungsvariablen <code>WERF_IMAGES_CLEANUP_PASSWORD</code> Projekts <i>(CI / CD-Einstellungen -&gt; Variablen) angegeben werden</i> . <br><br>  Das Hinzuf√ºgen einer Reinigungsaufgabe mit dem erforderlichen Zeitplan erfolgt in <i>CI / CD -&gt;</i> <i><br></i>  <i>Zeitpl√§ne</i> <br><br>  Das Projekt in der Docker-Registrierung w√§chst nicht mehr st√§ndig aus nicht verwendeten Bildern. <br><br>  Am Ende des praktischen Teils erinnere ich mich, dass die vollst√§ndigen Auflistungen des Artikels in <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">Git</a> verf√ºgbar sind: <br><br><ul><li>  <a href="">gitlab-ci.yml</a> ; </li><li>  <a href="">werf.yaml</a> . </li></ul><br><h2>  Ergebnis </h2><br><ol><li>  Wir haben eine logische Build-Struktur: ein Artefakt pro Version. </li><li>  Die Assembly ist universell und erfordert keine manuellen √Ñnderungen, wenn neue Versionen von werf ver√∂ffentlicht werden: Die Dokumentation auf der Site wird automatisch aktualisiert. </li><li>  Es werden zwei Bilder f√ºr unterschiedliche Konturen gesammelt. </li><li>  Es funktioniert schnell, weil  Caching wird maximal genutzt - Wenn eine neue Version von werf ver√∂ffentlicht wird oder ein GitHub-Hook f√ºr ein Review-Commit aufgerufen wird, wird nur das entsprechende Artefakt mit einer ge√§nderten Version neu erstellt. </li><li>  √úber das L√∂schen nicht verwendeter Bilder m√ºssen Sie nicht nachdenken: Die Bereinigung der Werf-Richtlinie beh√§lt die Reihenfolge in der Docker-Registrierung bei. </li></ol><br><h2>  Schlussfolgerungen </h2><br><ul><li>  Mit werf kann die Assembly schnell arbeiten, da sowohl die Assembly selbst als auch das Caching bei der Arbeit mit externen Repositorys zwischengespeichert werden. </li><li>    Git-               . werf        ,    <code>fetch</code>    . </li><li>   Go-     <code>werf.yaml</code>   ,      . </li><li>    werf     ‚Äî   ,     pipeline. </li><li> werf    ,      . </li></ul><br><h2>  PS </h2><br>     : <br><br><ul><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/476320/">         Kubernetes</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/469541/">      werf  GitLab CI</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/468049/"> werf    Helm-</a> ¬ª; </li><li> ¬´ <a href="https://habr.com/ru/company/flant/blog/481306/"> werf 1.0 stable:    GitOps,   </a> ¬ª. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478690/">https://habr.com/ru/post/de478690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478670/index.html">Wie Angreifer Ihre Korrespondenz im Telegramm lesen k√∂nnen. Und wie k√∂nnen sie das verhindern?</a></li>
<li><a href="../de478672/index.html">AI Testing und Startup: Interview mit Adam Carmi (Applitools)</a></li>
<li><a href="../de478680/index.html">Warum und vor allem, wohin gehen die Leute von der IT?</a></li>
<li><a href="../de478684/index.html">Einf√ºhrung in die SSD. Teil 2. Schnittstelle</a></li>
<li><a href="../de478688/index.html">Wie es war, 2019 Data Science zu studieren</a></li>
<li><a href="../de478692/index.html">Wie Java 8 auf Android unterst√ºtzt wird</a></li>
<li><a href="../de478694/index.html">Da empfehlen wir die neuesten Kataloge im ivi Online-Kino (+ Python-Code)</a></li>
<li><a href="../de478696/index.html">Wie ich Urban Tech 2019 besuchte. Veranstaltungsbericht</a></li>
<li><a href="../de478698/index.html">In 15 Minuten erstellen wir einen interaktiven Gel√§ndeplan</a></li>
<li><a href="../de478702/index.html">Metrische Verarbeitungstricks in Kapacitor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>