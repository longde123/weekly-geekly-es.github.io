<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘“ ğŸ˜” ã€½ï¸ Periksa Chromium Keenam, Kata Penutup ğŸ’¯ ğŸ’£ ğŸš£ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada awal 2018 blog kami dilengkapi dengan serangkaian artikel tentang pemeriksaan keenam kode sumber proyek Chromium. Seri ini mencakup 8 artikel ten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Periksa Chromium Keenam, Kata Penutup</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/438756/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/0f3/36b/e3e0f336b600672c601b8849d274d251.png" alt="unicorn yang parah"></div><br>  Pada awal 2018 blog kami dilengkapi dengan serangkaian artikel tentang pemeriksaan keenam kode sumber proyek Chromium.  Seri ini mencakup 8 artikel tentang kesalahan dan rekomendasi untuk pencegahannya.  Dua artikel memicu diskusi panas, dan saya masih kadang-kadang mendapat komentar melalui surat tentang topik yang dibahas di dalamnya.  Mungkin, saya harus memberikan penjelasan tambahan dan seperti yang mereka katakan, luruskan. <br><a name="habracut"></a><br>  Setahun telah berlalu sejak menulis serangkaian artikel tentang pemeriksaan rutin kode sumber proyek Chromium: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: Pemeriksaan Proyek Keenam dan 250 Bug</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium Bagus dan Canggung Memset</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">istirahat dan gagal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: kebocoran memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: Typos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: Penggunaan Data Tidak Dipercaya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa penting untuk memeriksa apa fungsi malloc dikembalikan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: Kesalahan Lainnya</a> </li></ol><br>  Artikel yang ditujukan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memset</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">malloc</a> telah menyebabkan dan terus menyebabkan perdebatan, yang menurut saya aneh.  Rupanya, ada beberapa kebingungan karena fakta bahwa saya kurang akurat ketika memverbalisasi pikiran saya.  Saya memutuskan untuk kembali ke artikel-artikel itu dan membuat beberapa klarifikasi. <br><br><h2>  memset </h2><br>  Mari kita mulai dengan artikel tentang <i>memset</i> , karena di sini semuanya sederhana.  Beberapa argumen muncul tentang cara terbaik untuk menginisialisasi struktur.  Cukup banyak programmer menulis bahwa akan lebih baik untuk memberikan rekomendasi untuk tidak menulis: <br><br><pre><code class="cpp hljs">HDHITTESTINFO hhti = {};</code> </pre> <br>  selain menulis dengan cara berikut: <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti = { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br>  Alasan: <br><br><ol><li>  Konstruksi {0} lebih mudah diperhatikan ketika membaca kode, daripada {}. </li><li>  Konstruksi {0} lebih mudah dimengerti secara intuitif, daripada {}.  Yang berarti, 0 menunjukkan bahwa struktur diisi dengan nol. </li></ol><br>  Oleh karena itu, pembaca menyarankan saya untuk mengubah contoh inisialisasi ini dalam artikel.  Saya tidak setuju dengan argumen dan tidak berencana untuk mengedit artikel.  Sekarang saya akan menjelaskan pendapat saya dan memberikan beberapa alasan. <br><br>  Adapun visibilitas, saya pikir, ini masalah selera dan kebiasaan.  Saya tidak berpikir bahwa keberadaan 0 di dalam tanda kurung secara fundamental mengubah situasi. <br><br>  Adapun argumen kedua, saya benar-benar tidak setuju dengan itu.  Catatan jenis {0} memberikan alasan untuk salah memahami kode.  Misalnya, Anda dapat menganggap bahwa jika Anda mengganti 0 dengan 1, semua bidang akan diinisialisasi dengan yang.  Karena itu, gaya penulisan seperti itu lebih cenderung berbahaya daripada membantu. <br><br>  Penganalisis PVS-Studio bahkan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1009</a> diagnostik terkait, deskripsi yang dikutip di bawah ini. <br><br>  <b>V1009.</b>  <b>Periksa inisialisasi array.</b>  <b>Hanya elemen pertama yang diinisialisasi secara eksplisit.</b> <br><br>  Analisator telah mendeteksi kemungkinan kesalahan yang terkait dengan fakta bahwa ketika mendeklarasikan array nilai hanya ditentukan untuk satu elemen.  Dengan demikian, elemen yang tersisa akan diinisialisasi secara implisit oleh nol atau dengan konstruktor default. <br><br>  Mari kita perhatikan contoh kode yang mencurigakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Mungkin programmer yang diharapkan daripada <i>arr</i> akan seluruhnya terdiri dari yang, tetapi tidak.  Array akan terdiri dari nilai 1, 0, 0. <br><br>  Kode yang benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Kebingungan tersebut dapat terjadi karena kesamaan dengan konstruksi <i>arr = {0}</i> , yang menginisialisasi seluruh array dengan nol. <br><br>  Jika konstruksi semacam itu secara aktif digunakan dalam proyek Anda, Anda dapat menonaktifkan diagnostik ini. <br><br>  Kami juga menyarankan untuk tidak mengabaikan kejelasan kode Anda. <br><br>  Misalnya, kode untuk pengkodean nilai warna dicatat sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> };</code> </pre> <br>  Berkat inisialisasi implisit, semua warna ditentukan dengan benar, tetapi lebih baik menulis ulang kode lebih jelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> };</code> </pre> <br><h2>  malloc </h2><br>  Sebelum membaca lebih lanjut, harap ingat isi artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa penting untuk memeriksa apa fungsi malloc dikembalikan</a> ".  Artikel ini menimbulkan banyak perdebatan dan kritik.  Inilah beberapa diskusi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reddit.com/r/cpp</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reddit.com/r/C_Programming</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com</a> (en).  Kadang-kadang pembaca masih mengirimi saya email tentang artikel ini. <br><br>  Artikel ini dikritik oleh pembaca karena hal-hal berikut: <br><br>  <b>1. Jika</b> <b><i>malloc</i></b> <b>mengembalikan</b> <b><i>NULL</i></b> <b>, maka lebih baik untuk segera menghentikan program, daripada menulis sekelompok</b> <b><i>if</i></b> <b>-s dan mencoba untuk entah bagaimana menangani memori, karena itu eksekusi program seringkali tidak mungkin.</b> <br><br>  Saya belum mendorong untuk berjuang sampai akhir dengan konsekuensi kebocoran memori, dengan melewati kesalahan yang semakin tinggi.  Jika diizinkan untuk aplikasi Anda untuk menghentikan pekerjaannya tanpa peringatan, maka biarkanlah demikian.  Untuk keperluan ini bahkan satu cek saja setelah <i>malloc</i> atau menggunakan <i>xmalloc</i> sudah cukup (lihat poin selanjutnya). <br><br>  Saya keberatan dan memperingatkan tentang kurangnya cek karena program terus bekerja seolah-olah tidak ada yang terjadi.  Ini kasus yang sama sekali berbeda.  Ini berbahaya, karena mengarah pada perilaku yang tidak terdefinisi, korupsi data, dan sebagainya. <br><br>  <b>2. Tidak ada deskripsi solusi yang terletak pada penulisan fungsi wrapper untuk mengalokasikan memori dengan cek yang mengikutinya atau menggunakan fungsi yang sudah ada, seperti</b> <b><i>xmalloc</i></b> <b>.</b> <br><br>  Setuju, saya melewatkan poin ini.  Saat menulis artikel saya hanya tidak memikirkan cara untuk memperbaiki situasi.  Lebih penting bagi saya untuk menyampaikan kepada pembaca tentang bahaya ketidakhadiran cek.  Bagaimana cara memperbaiki kesalahan adalah pertanyaan tentang selera dan detail implementasi. <br><br>  Fungsi <i>xmalloc</i> bukan bagian dari pustaka C standar (lihat " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa perbedaan antara xmalloc dan malloc?</a> ").  Namun, fungsi ini dapat dideklarasikan di perpustakaan lain, misalnya, di perpustakaan utils <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU libiberty</a> ). <br><br>  Poin utama dari fungsi ini adalah bahwa program macet ketika gagal mengalokasikan memori.  Implementasi fungsi ini mungkin terlihat sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"fatal: out of memory (xmalloc(%zu)).\n"</span></span>, s); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> <br>  Dengan demikian, dengan memanggil fungsi <i>xmalloc</i> alih-alih <i>malloc</i> setiap kali, Anda dapat yakin bahwa perilaku yang tidak terdefinisi tidak akan terjadi dalam program karena penggunaan pointer nol. <br><br>  Sayangnya, <i>xmalloc</i> juga bukan obat untuk semua.  Orang harus ingat bahwa penggunaan <i>xmalloc</i> tidak dapat diterima ketika menulis kode pustaka.  Saya akan membicarakannya nanti. <br><br>  <b>3. Sebagian besar komentar adalah sebagai berikut: "dalam praktiknya,</b> <b><i>malloc</i></b> <b>tidak pernah mengembalikan</b> <b><i>NULL</i></b> <b>."</b> <br><br>  Untungnya, saya bukan satu-satunya, yang mengerti bahwa ini adalah pendekatan yang salah.  Saya sangat menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> ini dalam dukungan saya: <br><br>  <i>Menurut pengalaman saya membahas topik ini, saya punya perasaan bahwa ada dua sekte di Internet.</i>  <i>Penganut yang pertama sangat percaya bahwa malloc tidak pernah mengembalikan NULL di Linux.</i>  <i>Pendukung yang kedua dengan sepenuh hati mengklaim bahwa jika memori tidak dapat dialokasikan dalam program Anda, tidak ada yang bisa dilakukan, Anda hanya bisa crash.</i>  <i>Tidak ada cara untuk membujuk mereka secara berlebihan.</i>  <i>Terutama ketika kedua sekte ini bersinggungan.</i>  <i>Anda hanya bisa menganggapnya sebagai pemberian.</i>  <i>Dan itu bahkan tidak penting di mana sumber daya khusus diskusi berlangsung.</i> <br><br>  Saya berpikir sebentar dan memutuskan untuk mengikuti saran, jadi saya tidak akan mencoba membujuk siapa pun :).  Semoga kelompok pengembang ini hanya menulis program yang tidak fatal.  Jika, misalnya, beberapa data dalam game rusak, tidak ada yang penting di dalamnya. <br><br>  Satu-satunya hal yang penting adalah bahwa pengembang perpustakaan, basis data tidak boleh melakukan seperti ini. <br><br><h2>  Banding ke pengembang kode dan perpustakaan yang sangat bergantung </h2><br>  Jika Anda mengembangkan pustaka atau kode lain yang sangat tergantung, selalu periksa nilai pointer yang dikembalikan oleh fungsi <i>malloc / realloc</i> dan kembalikan kode kesalahan jika memori tidak dapat dialokasikan. <br><br>  Di perpustakaan, Anda tidak dapat memanggil fungsi <i>keluar</i> , jika alokasi memori gagal.  Untuk alasan yang sama, Anda tidak dapat menggunakan <i>xmalloc</i> .  Untuk banyak aplikasi, tidak dapat diterima hanya membatalkannya.  Karena itu, misalnya, basis data dapat rusak.  Seseorang dapat kehilangan data yang dievaluasi selama berjam-jam.  Karena itu, program dapat dicapai untuk kerentanan "penolakan layanan", ketika, alih-alih menangani dengan benar beban kerja yang bertambah, aplikasi multithreaded berakhir begitu saja. <br><br>  Tidak dapat diasumsikan, dengan cara apa dan dalam proyek apa perpustakaan akan digunakan.  Oleh karena itu, harus diasumsikan bahwa aplikasi dapat menyelesaikan tugas yang sangat kritis.  Itu sebabnya hanya membunuhnya dengan memanggil <i>keluar</i> tidak baik.  Kemungkinan besar, program semacam itu ditulis dengan mempertimbangkan kemungkinan kekurangan memori dan dapat melakukan sesuatu dalam kasus ini.  Misalnya, sistem CAD tidak dapat mengalokasikan buffer memori yang sesuai yang akan cukup untuk operasi reguler karena fragmentasi memori yang kuat.  Dalam hal ini, itu bukan alasan untuk menghancurkan dalam mode darurat dengan kehilangan data.  Program ini dapat memberikan kesempatan untuk menyelamatkan proyek dan memulai kembali dengan sendirinya secara normal. <br><br>  Dalam keadaan apa pun, mustahil untuk mengandalkan <i>malloc</i> yang akan selalu dapat mengalokasikan memori.  Tidak diketahui pada platform apa dan bagaimana perpustakaan akan digunakan.  Jika situasi memori rendah pada satu platform eksotis, itu bisa menjadi situasi yang cukup umum di platform lain. <br><br>  Kami tidak dapat berharap bahwa jika <i>malloc</i> mengembalikan <i>NULL</i> , maka program akan macet.  Apa pun bisa terjadi.  Seperti yang saya jelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> , program mungkin menulis data bukan dengan alamat nol.  Akibatnya, beberapa data mungkin rusak, yang mengarah pada konsekuensi yang tidak terduga.  Bahkan <i>memset</i> itu berbahaya.  Jika padding dengan data berjalan dalam urutan terbalik, pertama-tama beberapa data rusak, dan kemudian program akan macet.  Tetapi kecelakaan itu mungkin terjadi terlambat.  Jika data tercemar digunakan dalam utas paralel saat fungsi <i>memset</i> berfungsi, konsekuensinya bisa fatal.  Anda bisa mendapatkan transaksi yang rusak dalam database atau mengirim perintah ke penghapusan file "tidak perlu".  Apa pun memiliki peluang untuk terjadi.  Saya sarankan pembaca untuk bermimpi, apa yang mungkin terjadi karena penggunaan sampah dalam memori. <br><br>  Dengan demikian, perpustakaan hanya memiliki satu cara yang benar untuk bekerja dengan fungsi <i>malloc</i> .  Anda perlu SEGERA memeriksa bahwa fungsi kembali, dan jika itu NULL, maka kembalikan status kesalahan. <br><br><h2>  Tautan tambahan </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan OOM</a> </li><li>  Bersenang-senang dengan pointer NULL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> </li><li>  Yang Harus Diketahui Setiap Pemrogram C Tentang Perilaku Tidak Terdefinisi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 3</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438756/">https://habr.com/ru/post/id438756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438746/index.html">Dalam perjalanan ke prinsip fisik evolusi biologis. Lanjutan</a></li>
<li><a href="../id438748/index.html">Infrastruktur sebagai kode, kami menang dalam skala besar (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../id438750/index.html">Peradaban Mata Air, 4/5</a></li>
<li><a href="../id438752/index.html">Akuntansi langsung di bank: cara membuat pengusaha individu bahagia</a></li>
<li><a href="../id438754/index.html">Bagaimana kami melakukan pemantauan jaringan untuk 14.000 objek</a></li>
<li><a href="../id438758/index.html">Mengapa Google mengubah antarmuka URL standar di browser</a></li>
<li><a href="../id438762/index.html">DBX: upaya untuk menyingkirkan kompilasi permintaan MySQL</a></li>
<li><a href="../id438764/index.html">Tes Chromium Keenam, Kata Penutup</a></li>
<li><a href="../id438766/index.html">DNA ekstraseluler sebagai biomarker penuaan dan berbagai patologi</a></li>
<li><a href="../id438768/index.html">Betapa saya membantu Alice untuk tidak menanggapi nama-nama lain. Magang Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>