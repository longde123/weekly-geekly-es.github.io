<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📯 😒 🕴🏾 Verwalten von Geheimnissen mit HashiCorp Vault 🍒 🤛🏻 🤞🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie man Geheimnisse bewahrt? Im Repository, im Bereitstellungssystem oder im Konfigurationsmanagementsystem? Auf einem PC, auf Servern oder vielleicht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwalten von Geheimnissen mit HashiCorp Vault</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/438740/">  Wie man Geheimnisse bewahrt?  Im Repository, im Bereitstellungssystem oder im Konfigurationsmanagementsystem?  Auf einem PC, auf Servern oder vielleicht in einer Box unter dem Bett?  Und wie gehe ich mit Geheimnissen um, um Lecks zu vermeiden? <br><br>  <strong>Sergey Noskov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Albibek</a> ) - der Leiter der Informationssicherheitsgruppe der Plattform aus Avito</strong> , kennt die Antwort auf diese Fragen und wird sie uns <strong>mitteilen</strong> .  In Avito nutzt HashiCorp Vault HashiCorp Vault seit zwei Jahren aktiv. Während dieser Zeit haben sie Unebenheiten und Erfahrung auf das „Master“ -Niveau gebracht. <br><br>  In dem Artikel werden wir umfassend über Vault sprechen: Was es ist, wo und wie es im Unternehmen verwendet wird, wie Avito Geheimnisse mit HashiCorp Vault verwaltet, wie Puppet und Kubernetes verwendet werden, Anwendungsfälle mit Puppet und anderen SCM, welche Probleme auftreten, was die Sicherheit beeinträchtigt und Entwickler, und natürlich teilen Ideen, wie man es beheben kann. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oDdDPU6moTs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><h2>  Was ist ein Geheimnis? </h2><br>  Alle vertraulichen Informationen: <br><br><ul><li>  Login und Passwort zum Beispiel in der Datenbank; </li><li>  API-Schlüssel </li><li>  Server-Zertifikatschlüssel (* .google.com) </li><li>  Kundenzertifikatschlüssel (Partner, Yandex-Geld, QIWI); </li><li>  Schlüssel zum Signieren mobiler Anwendungen. </li></ul><br>  Alle Informationen, die wir geheim halten wollen, nennen wir geheim.  Dies führt zu einem Speicherproblem: Das Speichern im Repository ist in verschlüsselter Form fehlerhaft. Sie müssen die Verschlüsselungsschlüssel irgendwo aufbewahren. <br><br>  <strong>HashiCorp Vault</strong> ist eine der guten Lösungen für das Problem. <br><br><ul><li>  Schlüssel sicher speichern und verwalten. </li><li>  Geschärft auf der Welt der Microservices, seit dem Microservice selbst. </li><li>  <strong>HashiCorp Vault</strong> hat viel getan, um den Zugriff auf Geheimnisse wie ACLs und das Prinzip der Mindestberechtigungen zu authentifizieren und zu autorisieren. </li><li>  REST-Schnittstelle mit JSON. </li><li>  Sicherheit ist nicht perfekt, aber auf einem ziemlich hohen Niveau. </li></ul><br>  Meiner Meinung nach ist dies ein ziemlich praktisches Werkzeug. <br><br><h2>  Was ist neu in HashiCorp Vault? <br></h2><br>  Das Tool entwickelt sich und in den letzten Jahren sind viele interessante Funktionen enthalten: CORS-Header für die grafische Benutzeroberfläche ohne Zwischenhändler;  eingebaute GUI;  native Integration mit Kubernetes;  Plugins für logische und Auth-Backends und Frameworks. <br><br>  Die meisten Änderungen, die mir persönlich gefallen haben, sind die <strong>Möglichkeit, keine Erweiterungen und Ergänzungen zu schreiben</strong> , die außerhalb des Tools stehen. <br><br>  Zum Beispiel gibt es Vault, das Sie erweitern möchten - schreiben Sie zusätzliche Logik oder Ihre eigene Benutzeroberfläche für die Automatisierung, die etwas automatisiert.  Vor den Änderungen musste ich einen zusätzlichen Dienst auslösen, dem Vault gegenübersteht, und alle Anforderungen weiterleiten: Zuerst gehen die Anforderungen an den Dienst, dann an Vault.  Dies ist schlecht, da im Zwischendienst möglicherweise ein geringeres Sicherheitsniveau besteht und alle Geheimnisse dies durchlaufen.  <strong>Sicherheitsrisiken sind viel höher, wenn das Geheimnis mehrere Punkte gleichzeitig durchläuft!</strong> <br><br><h2>  Henne-Ei-Problem <br></h2><br>  Wenn Sie das Problem der Speicherung vertraulicher Informationen ansprechen und sich für die Verschlüsselung entscheiden, wird Ihr Geheimnis, sobald Sie etwas verschlüsseln, vom Ort der Verschlüsselung an den Ort verschoben, an dem der Schlüssel gespeichert ist.  Dies geschieht ständig: Sobald Sie irgendwo ein Geheimnis gespeichert oder ein vorhandenes geändert haben, haben Sie ein anderes und ein verzauberter Kreis beginnt - <strong>wo Sie das Geheimnis für den Zugriff auf das Geheimnis aufbewahren können</strong> . <br><br>  Das Geheimnis für den Zugriff auf das Geheimnis ist der Teil der Sicherheit, der als <strong>Authentifizierung bezeichnet wird</strong> .  Sicherheit hat einen anderen Teil - die <strong>Autorisierung.</strong>  Im Autorisierungsprozess wird geprüft, ob der Benutzer genau dort zugreifen kann, wo er anfordert.  Im Fall von Vault gibt es einen vertrauenswürdigen Dritten, der entscheidet, ob das Geheimnis preisgegeben wird oder nicht.  Die Autorisierung löst das Problem nur teilweise. <br><br><h2>  HashiCorp Vault in Avito <br></h2><br>  Bei Avito wird HashiCorp in der einzigen großen Installation im gesamten Netzwerk installiert.  HashiCorp Vault hat viele verschiedene Backends.  Wir verwenden das auf <strong>Consul</strong> basierende Backend auch von HashiCorp, da Vault seine eigene Fehlertoleranz nur über Consul unterstützen kann. <br><br>  <strong>Das Entsiegeln</strong> ist eine Möglichkeit, den Hauptschlüssel nicht an einem Ort <strong>aufzubewahren</strong> .  Wenn Vault gestartet wird, wird alles auf einem Schlüssel verschlüsselt, und erneut tritt das Problem mit Hühnchen und Eiern auf: Wo soll ein Geheimnis aufbewahrt werden, das alle anderen Geheimnisse verschlüsselt?  Um dieses Problem zu vermeiden, stellt Vault einen zusammengesetzten Schlüssel zur Verfügung, für den mehrere Teile des Schlüssels erforderlich sind, den wir an mehrere Mitarbeiter verteilen.  In Avito haben wir Unseal in den Optionen für 3 von 7 Personen konfiguriert. Wenn wir Vault starten, müssen mindestens 3 Personen hereinkommen und ihren Teil des Schlüssels eingeben, um mit der Arbeit zu beginnen.  Der Schlüssel ist in 7 Teile unterteilt und Sie können jeden von ihnen mitbringen. <br><br>  Wir haben einen kleinen Test-Tresor zusammengestellt, eine Sandbox für Entwickler, in der sie spielen können.  Es hat die Form eines Docker-Containers und schafft einfache Geheimnisse, damit die Leute das Werkzeug mit den Händen berühren und es sich bequem machen können.  Es gibt keinen Konsul und kein Clustering in der Sandbox. Es handelt sich lediglich um ein Dateisystem, in dem Vault verschlüsselte Geheimnisse enthält, und ein kleines Skript zum Initialisieren. <br><br>  Folgendes speichern wir jetzt in Vault: <br><br><ul><li>  Fast alle Geheimnisse für Kubernetes Microservices: Datenbankkennwörter, API-Schlüssel, alle oben genannten. </li><li>  Geheimnisse für das Auflegen auf die "Eisen" -Server und LXC. </li><li>  Wir haben auch Geheimnisse für CI / CD-Builds in TeamCity in Vault gespeichert.  Die Abdeckung ist nicht 100%, aber durchaus akzeptabel. </li><li>  Die Schlüssel aller Zertifikate: interne PKI, externe Zertifizierungsstellen, z. B. GeoTrust und dergleichen. </li><li>  Gemeinsame Geheimnisse für Teams. </li></ul><br>  Im Inneren speichert Vault alles nur in JSON. Dies ist nicht immer praktisch und erfordert zusätzliche Aktionen des Entwicklers. Daher veröffentlichen wir Geheimnisse im Grunde in Form einer Datei. <br><br><blockquote>  Wir versuchen, Geheimnisse in Form von Dateien zu liefern. <br></blockquote><br>  Wir sagen dem Entwickler nicht: "Gehe zu Vault, nimm ein Geheimnis!", Aber lege die Datei auf die Festplatte und sage: "Entwickler, eine Datei wird auf deiner Festplatte angezeigt, nimm das Geheimnis von ihr und wir werden bereits herausfinden, wie du sie aus Vault holen und bringen kannst dir". <br><img src="https://habrastorage.org/webt/rg/9o/mj/rg9omjizdszcnw0lzrr_iogfosc.png"><br><br>  Wir haben eine einfache Vereinbarung für JSON-Felder getroffen, in der wir angeben, mit welchen Rechten die Datei hochgeladen werden soll.  Dies sind Metadaten für das Dateisystem, und das Datenfeld ist eine codierte Zeichenfolge mit dem Geheimnis selbst, das zum Inhalt der Datei wird. <br><br><h2>  Marionette + Hiera + Gewölbe <br></h2><br>  Fast die gesamte Avito-Infrastruktur verwendet Puppet und rollt alle Server aus. <br><br>  Puppet hat ein praktisches Werkzeug zum Organisieren von Hierarchien - <strong>Hiera</strong> .  Vault lässt sich über ein Add-On-Modul sehr gut in Hiera integrieren, da die Schlüsselwertanforderung an diese Bibliothek gesendet wird und Vault die Schlüsselwertdatenbank selbst ist, jedoch mit allen Sicherheitsfunktionen - mit transparenter Verschlüsselung und der Möglichkeit, den Schlüsselzugriff zu wählen. <br><br>  Daher haben wir als erstes Vault in Puppet implementiert, aber mit einem Zusatz - wir haben eine Zwischenschicht namens <strong>Router-Backend</strong> .  Router-Backend - ein separates Hiera-Modul, nur Dateien auf der Festplatte, die angeben, wo Hiera den Schlüssel abrufen soll - in Vault oder an einem anderen Ort. <br><br>  Er wird gebraucht, damit Hiera nicht ständig zum Tresor geht, weil sie immer durch die Hierarchie geht.  Dies ist kein Vault-Problem oder eine Belastung, sondern eine Funktion von Hiera.  Wenn Sie daher nur das Modul für Vault ohne das Router-Backend belassen, dauert es sehr lange, bis der Puppet-Master die Konfiguration für den Puppet-Agenten erfasst, da er jeden Schlüssel im Vault überprüft. <br><img src="https://habrastorage.org/webt/dv/di/f6/dvdif6z09jpflg98zykbwf7l7cq.png"><br><br>  Für Puppet ist das Problem von Huhn und Eiern dadurch gelöst, dass die autorisierende Partei der Puppenspieler ist.  Er gibt das Geheimnis, um auf das Geheimnis zuzugreifen.  Der Puppenmeister hat Zugriff auf alle Geheimnisse gleichzeitig, aber jeder Host darf nur das empfangen, das für ihn bestimmt ist.  Der Host auf dem Puppet Master ist bereits durch sein Zertifikat autorisiert, das lokal generiert wird und die Hostlimits nicht verlässt.  Im Prinzip bleibt das Geheimnis, um auf das Geheimnis zuzugreifen, aber dies ist nicht so kritisch. <br><br>  Unser Prozess, ein neues Geheimnis in Puppet zu enthüllen, besteht aus den folgenden Schritten. <br><br><ul><li>  Wir nehmen irgendwo ein Geheimnis - jemand gibt es uns oder löscht es. </li><li>  Ein Geheimnis in Vault mit einer Hierarchie wie in Hiera: <strong>/puppet/role/www/site.ssl.key</strong> . </li><li>  Wir registrieren ein Präfix im Puppet-Manifest, das angibt, dass sich die Datei in Vault befindet und wo sie erhältlich ist. </li><li>  Wir schreiben den Pfad in Vault in YAML für den Hiera-Router und das Backend, damit Hiera ihn finden kann. </li><li>  Ziehen Sie die Anforderung über GIT in das Manifest-Repository. </li><li>  Führen Sie aus oder warten Sie, bis der Puppet-Agent ausgeführt wird. </li></ul><br>  Puppenspieler rennen alle 30 Minuten mit uns weg, also müssen Sie ein bisschen warten, bis das Geheimnis herauskommt.  Dies verursacht keine Probleme - <strong>wir teilen nicht jeden Tag Geheimnisse</strong> .  Solange Kubernetes nicht in das Geschäft involviert ist, gibt es nicht viel Aufwand und wir sind bereit, mit minimaler Automatisierung mit unseren Händen Geheimnisse in Vault zu lüften. <br><br>  Ein zusätzliches Plus ist die "Chip" -Hiera - das <strong>Geheimnis kann sofort für eine Gruppe von Hosts</strong> oder abhängig von der Rolle des Hosts, die wir in der variablen Rolle festgelegt haben, festgelegt werden. <br><br>  Die einzige <strong>Gefahr</strong> : Wenn Sie Puppet haben und Hiera verwenden, ersetzen Sie Variablenvorlagen nicht durch Hindernisse, da viele Fakten und Variablen auf der Clientseite gesammelt werden.  Wenn ein Angreifer eine Tatsache auf dem Klienten ersetzt, gibt ihm der Puppenmeister die Geheimnisse anderer Leute.  <strong>Überprüfen Sie unbedingt die Variablen</strong> : Verwenden Sie nur diejenigen, die der Puppet-Master auf der Client-Seite nicht bestimmen kann. <br><br><h2>  Was tun mit SCM ohne Assistenten? <br></h2><br>  Wenn Sie plötzlich keine Puppe mehr haben, dann höchstwahrscheinlich Ansible.  Für Chefkoch und andere zentralisierte SCMs sind ihre Lösungen ein Plugin, das auf Vault zugreifen kann.  Ich biete verschiedene Optionen an, die mit Ansible implementiert werden können. <br><br><h3>  Lokaler Agent <br></h3><br>  Generieren Sie lokal für den Server ein Token, das eigentlich das Kennwort für den Zugriff auf den Tresor ist.  Das Token ist jederzeit gültig.  Sie können es aktualisieren oder automatisieren.  Mit diesem Token gehst du zum Tresor und nimmst deine Geheimnisse weg. <br><br>  Die Idee ist, dass auf Ihrem Server, auf dem Sie Geheimnisse bereitstellen müssen, der Agent, der zu Vault kommt, sich dreht, alle Geheimnisse überprüft und sie in Form von Dateien ablegt.  Wir verwenden den Agenten auf mehreren separaten Servern, auf denen keine Marionette vorhanden ist. <br><br>  <strong>Nachteile:</strong> <br><br><ul><li>  Das Token kann einfach in ein kleines Segment eingegeben werden. Wenn jedoch mehrere Dutzend Server pro Tag bereitgestellt werden, müssen Sie für jeden Server ein Token generieren und eine Richtlinie vorschreiben.  Dies ist unpraktisch. </li><li>  Token muss aktualisiert werden. </li><li>  Das Gruppieren von Servern nach Rolle, Zweck oder Fakten ist schwierig. Sie müssen mit Vault synchronisiert werden. </li></ul><br><h3>  Transit-Verschlüsselung <br></h3><br>  Vault verfügt über eine Transitverschlüsselungsfunktion, deren Kern darin besteht, dass Vault als <strong>Verschlüsselungsserver fungiert</strong> .  Sie bringen ihm nur Klartext, und er verschlüsselt und gibt auf seinem privaten Schlüssel, den nur er hat, den geschlossenen Text aus.  Dann wählen Sie, wer diesen geschlossenen Text entschlüsseln kann. <br><br>  Ansible hat eine Entität, auch Vault genannt.  Dies ist kein HashiCorp-Tresor, sondern ein <strong>Ansible-Tresor</strong> .  Es besteht kein Grund zur Verwirrung, und Geheimnisse können sowohl im ersten als auch im zweiten gespeichert werden.  Ansible verfügt über ein vorgefertigtes Plugin für die Bereitstellung von Geheimnissen aus Hashicorp Vault.  Wenn Sie persönlichen Zugriff auf Vault gewähren, können Sie Geheimnisse entschlüsseln.  Wenn Sie Ansible rollen, geht es in Ihrem Namen zu Vault, entschlüsselt die Geheimnisse, die im Repository verschlüsselt sind, und rollt es in die Produktion. <br><br>  Es gibt auch einen Nachteil: <strong>Jeder Administrator erhält Zugriff auf Geheimnisse</strong> .  Aber es gibt eine Prüfung: Vault weiß, wie man ein Aktivitätsprotokoll darüber führt, welcher Benutzer hereingekommen ist, welches Geheimnis er gelesen hat und welcher Zugriff erhalten hat.  Sie wissen immer, wer, wann und was mit einem Geheimnis zu tun hat.  Diese Option scheint mir gut zu sein. <br><br><h3>  Großer Fehler # 1 <br></h3><br>  Der größte Nachteil, der uns am meisten schmerzt, ist, dass Sie in Vault die vollständige Kontrolle über keinen <strong>Teil der</strong> <strong>Daten an</strong> Dritte delegieren können.  In Vault erfolgt der Zugriff auf das Geheimnis auf ähnliche Weise wie in UNIX. Namen werden normalerweise durch Schrägstriche getrennt, und das Ergebnis ist ein "Verzeichnis".  Wenn Sie einen solchen Pfad haben, möchten Sie manchmal Teil des Pfads sein und ihn zur Kontrolle an eine andere Person weitergeben. <br><img src="https://habrastorage.org/webt/w-/hq/gf/w-hqgfwmxgok3_dimlgnn8baxag.png"><br><br>  Sie haben beispielsweise Zertifikate mit dem Namen <strong>/ certs erhalten</strong> und möchten diese einzelnen Sicherheitsbeauftragten geben, die sich mit PKI befassen.  Vault kann das nicht.  Sie können nicht das Recht einräumen, Rechte innerhalb dieses Präfixes zu erteilen, damit die Sicherheitskräfte selbst die Rechte an Zertifikaten an andere Personen verteilen können. <br><br>  <strong>Vault ist nicht in der Lage, selektiv Rechte zu gewähren, um Rechte zu gewähren</strong> .  Sobald Sie das Recht eingeräumt haben, Rechte zu gewähren, haben Sie auch die Möglichkeit gegeben, uneingeschränkten Zugriff auf alle Geheimnisse zu erhalten.  Mit anderen Worten, Sie können keinen Zugriff auf den Vault-Teil gewähren. <br><br>  Dies ist eines der größten Probleme.  Ich habe eine Idee, wie ich es lösen kann. Ich werde es dir später erzählen. <br><br><h2>  Kubernetes <br></h2><br>  Bei RIT ++ habe ich über ein separates System gesprochen, das wir für <strong>Kubernetes</strong> implementiert haben: Es dient als Dritter, geht zur API, überprüft den Zugriff und fordert dann ein Geheimnis in Vault an. <br><br>  Jetzt hat unser System an Relevanz verloren, da in Vault 0.9 native Unterstützung für Kubernetes angezeigt wurde.  Jetzt weiß Vault selbst, wie man zu Kubernetes geht und sicherstellt, dass der Zugriff auf das Geheimnis erlaubt ist.  Er tut dies mit einem <strong>Service Account Token</strong> .  Wenn Sie beispielsweise einen Pod eingeführt haben, gibt es einen speziellen, signierten und autorisierten <strong>JWT</strong> dafür, der für Anforderungen an die Kubernetes-API entwickelt wurde.  Mit einem Token können Sie sich auch bei Vault anmelden und Geheimnisse speziell für Ihren Namespace abrufen. <br><br>  Alles wird auf der Ebene von Vault selbst erledigt.  Es ist richtig, dass Sie für jeden Namespace eine Rolle starten müssen, dh Vault mitteilen, dass es einen solchen Namespace gibt, dass eine Autorisierung darin vorhanden ist, und registrieren, wohin Sie zu Kubernetes gehen sollen.  Dies wird einmal durchgeführt, und dann geht Vault zur API selbst, bestätigt die Gültigkeit des JWT und stellt sein eigenes Zugriffstoken aus. <br><br><h3>  Kubernetes Regeln <br></h3><br>  In Bezug auf den Servicenamen und zusätzliche Metadaten vertrauen wir den Entwicklern.  Es besteht eine geringe Wahrscheinlichkeit, dass Entwickler versehentlich oder absichtlich die Geheimnisse anderer Dienste erfahren, die sich in einem Namespace drehen. Daher haben wir eine Regel eingeführt: <strong>einen Dienst</strong> - <strong>einen Namespace.</strong> <br><br>  Neuer Microservice?  Holen Sie sich einen neuen Namespace mit Ihren Geheimnissen.  Sie können nicht über die Grenze zum Nachbarn gehen - sie haben ein eigenes Service Account Token.  <strong>Die Sicherheitsgrenze bei Kubernetes ist derzeit der Namespace.</strong>  Wenn Sie in zwei verschiedenen Namespaces ein Geheimnis benötigen, kopieren Sie es. <br><br>  Kubernetes hat <strong>Kubernetes Geheimnisse</strong> .  Sie werden unverschlüsselt in etcd in Kubernetes gespeichert und können im Dashboard oder beim Start von kubectl get pods "aufleuchten".  Wenn die Authentifizierung in etcd in Ihrem Cluster deaktiviert ist oder Sie jemandem vollständigen Lesezugriff gewährt haben, sind alle Geheimnisse für ihn sichtbar.  Aus diesem Grund haben wir zwei Regeln eingeführt: Es ist <strong>verboten, Kubernetes-Geheimnisse zu verwenden,</strong> und es ist <strong>verboten, Geheimnisse in Umgebungsvariablen in Manifesten anzugeben</strong> .  Wenn Sie in deploy.yaml ein Geheimnis in die Umgebung schreiben, ist dies schlecht, da das Manifest selbst von jedem gesehen werden kann, der nicht faul ist. <br><br><h3>  Kubernetes Lieferung <br></h3><br>  Wie gesagt, wir müssen die Datei irgendwie in Kubernetes ablegen.  Wir haben eine Art Geheimnis: die Essenz, das Passwort, das in JSON in Vault geschrieben ist.  Wie kann man es jetzt in eine Datei im Container von Kubernetes verwandeln? <br><img src="https://habrastorage.org/webt/gm/ki/wb/gmkiwblvlm7ca4hiwmvhhx14wxu.png"><br><br>  Die erste Lieferoption. <br><br><ul><li>  Wir starten einen speziellen Init-Container. </li><li>  Es geht von unserem Bild aus. </li><li>  Das Image enthält ein kleines Dienstprogramm, das mit dem Service Account Token an Vault geht, das Geheimnis aufnimmt und es in das freigegebene Volume legt. </li><li>  Für das Dienstprogramm wird ein spezielles freigegebenes Volume nur im TMPFS-Speicher bereitgestellt, damit keine Geheimnisse über die Festplatte übertragen werden. </li><li>  Der Init-Container geht zu Vault und legt in diesem Volume in Form von Dateien alle Geheimnisse ab, die er auf dem angegebenen Pfad findet. </li><li>  Als nächstes wird das freigegebene Volume in dem Hauptcontainer bereitgestellt, in dem es benötigt wird. </li><li>  Wenn der Hauptcontainer gestartet wird, erhält er sofort das, was der Entwickler benötigt - Geheimnisse in Form einer Datei auf der Festplatte. </li></ul><br>  Der Entwickler muss sich nur an den Weg erinnern, auf dem sein Geheimnis liegt. <br><br>  Wir verwenden so etwas wie dieses Präfix: <br><br><pre><code class="plaintext hljs">/k8s/&lt;cluster&gt;/&lt;namespace&gt;/&lt;service&gt;/some_secret</code> </pre> <br>  Der Präfixname enthält den Clusternamen, den Namespace und den Dienstnamen.  Jeder Dienst hat sein eigenes Geheimnis, jeder Namespace hat sein eigenes Geheimnis. <br><br>  Die zweite Option ist Ihr <strong>eigener Einstiegspunkt</strong> .  Wir ziehen jetzt in Avito um, weil Entwickler Probleme mit dem Init-Container haben.  Im Diagramm befindet sich diese Option rechts. <br><br>  Nicht jeder kann sich seinen eigenen Einstiegspunkt leisten.  Wir können, also erzwingen wir in jedem Container unseren speziellen Einstiegspunkt. <br><br>  Unser Einstiegspunkt macht dasselbe wie der Init-Container: Er geht mit einem Service Account Token zu Vault, nimmt Geheimnisse und löscht sie.  Zusätzlich zu den Dateien legt er sie wieder in der Umgebung ab.  Sie haben die Möglichkeit, die Anwendung wie vom <strong>Twelve-Factor App-</strong> Konzept empfohlen auszuführen: Die Anwendung übernimmt alle Einstellungen, einschließlich Geheimnisse, von Umgebungsvariablen. <br><br>  Umgebungsvariablen sind im Manifest und im Dashboard nicht sichtbar, da sie beim Start durch PID 1 (den Hauptcontainerprozess) festgelegt werden.  Hierbei handelt es sich nicht um Umgebungsvariablen aus deploy.yaml, sondern um Umgebungsvariablen, die vom Einstiegspunkt im Prozess festgelegt werden.  Sie sind im Dashboard nicht sichtbar, sie sind auch dann nicht sichtbar, wenn Sie kubectl exec in einem Container ausführen, da in diesem Fall parallel zu PID1 ein anderer Prozess gestartet wird. <br><br><h3>  Workflow <br></h3><br>  Aus organisatorischer Sicht ist der Prozess wie folgt.  Der Entwickler erfährt vom Sicherheitschampion oder aus der Dokumentation, dass er keine Geheimnisse im Repository, sondern nur in Vault aufbewahren soll.  Dann kommt er zu uns und fragt, wo er Geheimnisse preisgeben soll - er reicht einen Antrag bei der Sicherheit ein, um ein Präfix festzulegen.  In Zukunft können Sie sofort beim Erstellen eines Dienstes ein Präfix ohne Anforderung erstellen. <br><br>  Der Entwickler wartet, und das ist schlecht, weil  Die Hauptsache für ihn ist die Markteinführungszeit.  Dann liest er die Anweisungen, befasst sich mit langen Dateien - "füge diese Zeile dort ein, füge diese Zeile hier ein".  Ein Entwickler hat noch nie einen Init-Container gestartet, muss ihn jedoch herausfinden und in deploy.yaml (Helmdiagramm) registrieren. <br><br> <code>Commit -&gt; deploy -&gt; feel pain -&gt; fix -&gt; repeat</code> <br> <br>  Es legt fest, wartet auf die Einführung von TeamCity, sieht Fehler in TeamCity, fühlt Schmerzen, versucht, etwas zu beheben, hat wieder Schmerzen.  Darüber hinaus wird überlagert, dass jeder Rollout in TeamCity weiterhin in die Warteschlange gestellt werden kann.  Manchmal kann ein Entwickler es nicht selbst herausfinden, kommt zu uns und wir klären es gemeinsam. <br><br>  Grundsätzlich leidet der Entwickler an seinen eigenen Fehlern: <strong>falsch angegebener Init-Container oder hat die Dokumentation nicht gelesen</strong> . <br><br>  Sicherheit hat auch Probleme.  Der Sicherheitsbeamte erhält eine Anwendung, in der immer nur wenige Informationen vorhanden sind, und wir finden immer noch die fehlenden Fragen heraus: Finden Sie die Namen der Cluster und den Namespace des Dienstes heraus, da der Entwickler sie in der Anwendung nicht angibt und nicht einmal immer weiß, was es ist.  Wenn wir alles herausfinden, Richtlinien und Rollen in Vault erstellen, Gruppen Richtlinien vorschreiben und gemeinsam mit dem Entwickler herausfinden, wo und warum er einen Fehler gemacht hat, lesen wir gemeinsam die Protokolle. <br><br>  Die Einheit „Architektur“ hilft bei der Lösung des Problems, indem sie sich vor dem Entwickler von deploy.yaml versteckt.  Sie entwickeln ein Stück, das alles für den Entwickler generiert, einschließlich des Einstiegspunkts.  Aufgrund der Tatsache, dass wir unseren Einstiegspunkt ersetzen, können wir ihn nicht nur zur Übermittlung von Geheimnissen verwenden, sondern auch für andere Dinge, die Sie möglicherweise beim Start tun müssen. <br><br><h3>  Offensichtliche Probleme mit Kubernetes Geheimnissen. <br></h3><br><ul><li>  <strong>Sehr komplizierter Workflow</strong> sowohl für den Entwickler als auch für den Sicherheitsbeamten. </li><li>  <strong>Sie können nichts an jemanden delegieren.</strong>  Der Sicherheitsbeamte hat vollen Zugriff auf den Tresor, und ein teilweiser Zugriff ist nicht möglich (siehe Großer Fehler Nr. 1). </li><li>  Beim Verschieben von Entwicklern von Cluster zu Cluster, von Namespace zu Namespace, wenn gemeinsame Geheimnisse benötigt werden, treten Schwierigkeiten auf, da zunächst davon ausgegangen wird, dass verschiedene Geheimnisse in verschiedenen Clustern unterschiedlich sind. </li></ul><br>  Wir sagen: „Warum brauchen Sie Produktionsgeheimnisse im Entwicklungscluster?  Holen Sie sich ein Testgeheimnis, machen Sie mit! “  Infolgedessen gibt es <strong>Minen</strong> <strong>und Geheimnisse</strong> , die schwer zu verwalten sind.  Wenn sich das Geheimnis geändert hat, dürfen Sie es nicht vergessen, es überall ändern, und es gibt keine Möglichkeit festzustellen, dass es dasselbe Geheimnis ist, außer durch den Namen des Dienstes. <br><br><h3>  Idee: Kubernetes KMS <br></h3><br>  In neuen Versionen von Kubernetes ist das KMS-Subsystem Key Management Service eine neue geheime Verschlüsselungsfunktion von Kubernetes.  In v1.11 befand es sich im Alpha-Zustand, in v1.12 wurde es in die Beta übertragen. <br><img src="https://habrastorage.org/webt/yq/nw/i9/yqnwi9a_t6atxpxdu_qrtu0qz80.png"><br>  <em>Das Bild stammt von der KMS-Provider-Projektwebsite für Vault und weist einen Fehler auf.</em>  <em>Wenn Sie finden - schreiben Sie in die Kommentare.</em> <br><br>  Die Bedeutung von KMS besteht darin, einen einzigen Nachteil zu beseitigen - die unverschlüsselte Datenspeicherung in etcd. <br><br>  KMS kann dies wie Ansible. <br><br><ul><li>  Gehen Sie irgendwohin, verschlüsseln Sie das native Geheimnis von Kubernet und verschlüsseln Sie es. </li><li>  Bei Bedarf an den Pod liefern, entschlüsseln und in entschlüsselte Form bringen. </li></ul><br>  Die Entwickler haben einen speziellen Dienst geschrieben, der dies mithilfe der Transitverschlüsselung tut.  Die Idee scheint zu funktionieren, aber es ist wichtig, sich daran zu erinnern, dass Geheimnisse nicht mehr nur unter der Kontrolle von Vault stehen und woanders in den Verantwortungsbereich der Kubernetes-Administratoren gehen. <br><br>  Nachteile KMS. <br><br><ul><li>  <strong>Speicherdezentralisierung</strong> - <strong>Übernahme von Vault zu Kubernetes (etcd)</strong> .  Geheimnisse werden von Vault unkontrollierbar und eignen sich als zentrales Repository für Geheimnisse.  Es stellt sich heraus, dass die Hälfte der Geheimnisse in Vault und die andere Hälfte. </li><li>  <strong>Nur-Kubernetes-Lösung</strong> .  Wenn Sie nur über eine Kubernetes-Infrastruktur verfügen, holen Sie sich Vault und denken fast nicht, was dort gespeichert ist, weil  Es enthält nur die Verschlüsselungsschlüssel, die Sie korrekt verwalten - regelmäßig drehen usw. ... Die Geheimnisse selbst befinden sich in Kubernetes, und dies ist praktisch. </li><li>  <strong>Es ist schwierig, Geheimnisse zwischen Clustern auszutauschen</strong> .  Für jeden neuen Cluster müssen Sie erneut beginnen. Das Kopieren von Geheimnissen wie im Fall eines einzelnen Tresors funktioniert möglicherweise nicht. </li></ul><br>  Vorteile von KMS. <br><br><ul><li>  <strong>Native Unterstützung</strong> in Kubernetes, einschließlich Verstecken beim Anzeigen der Umgebung. </li><li>  <strong>Autorisierung im Verantwortungsbereich von Kubernetes</strong> . </li><li>  <strong>Praktisch keine Vault-Unterstützung erforderlich</strong> . </li><li>  <strong>Schlüsselumdrehung aus der Box</strong> . </li></ul><br><h2>  CI / CD: TeamCity <br></h2><br>  In TeamCity ist alles einfach, da JetBrains ein Plug-In geschrieben hat, das selbst Geheimnisse für den Zugriff auf das Geheimnis vorschreiben, diese mit TeamCity verschlüsseln und es dann irgendwo in der Vorlage als Parameter in Prozent ersetzen kann.  In diesem Moment geht der TeamCity-Agent selbst zu Vault, nimmt das Geheimnis und bringt es als Parameter zum Build. <br><br>  Während der Bereitstellung werden einige Geheimnisse benötigt, z. B. Datenbankmigration oder Warnungen in Slack.  AppRole wird für jedes Projekt gestartet - die Einstellungen enthalten auch ein Geheimnis (Daten für AppRole), werden jedoch im Nur-Schreib-Modus eingegeben - TeamCity erlaubt das spätere Lesen nicht. <br><br>  TeamCity selbst sorgt dafür, dass sich ein Geheimnis automatisch tarnt, wenn es in die Build-Protokolle eingeht.  Infolgedessen wird das Geheimnis entweder überhaupt nicht durch die Festplatte "geleitet" oder mit TeamCity von der Festplatte gelöscht.  Infolgedessen wird die gesamte Sicherheit des Geheimnisses durch TeamCity selbst und das Plugin gut gewährleistet, und zusätzliche Tänze mit einem Tamburin sind nicht erforderlich <br><br><h3>  CI / CD ist nicht TeamCity? <br></h3><br>  Dies sind die wichtigsten Punkte, die zu berücksichtigen sind, wenn Sie ein anderes System (nicht TeamCity) als CI verwenden. <br><br><ul><li>  Isolation: Beschränken Sie den Umfang eines Geheimnisses auf ein Projekt, ein Team usw. </li><li>  Wer autorisiert den Zugriff auf das Geheimnis. </li><li>  Schließen Sie die Möglichkeit aus, das Geheimnis der autorisierenden Partei anzuzeigen. </li><li>  Eine separate Phase des Builds besteht darin, das Geheimnis in Dateien zu importieren. </li><li>  Räumen Sie nach sich selbst auf. </li></ul><br>  Infolgedessen werden Sie höchstwahrscheinlich etwas schreiben, das dem TeamCity-Plugin für Ihr CI / Ihre CD sehr ähnlich ist.  Die autorisierende Partei hier wird höchstwahrscheinlich CI / CD sein, und sie wird entscheiden, ob dieser Build Zugriff auf dieses Geheimnis haben kann und ob sie das Geheimnis selbst basierend auf den Ergebnissen preisgibt oder nicht. <br><br>  Es ist wichtig, nicht zu vergessen, <strong>die Build-Ergebnisse am Ende der Assembly</strong> zu <strong>bereinigen</strong> , wenn sie auf einer Festplatte angeordnet waren, oder sicherzustellen, dass sie sich nur im Speicher befinden. <br><br><h2>  Zertifizierungen <br></h2><br>  Zertifikate haben nichts Besonderes - wir verwenden Vault hauptsächlich für deren Speicherung. <br><img src="https://habrastorage.org/webt/ix/ye/4j/ixye4jru2blznsbq2jxmljomqi8.png"><br><br>  Vault verfügt über ein spezielles PKI-Backend für die Ausstellung von Zertifikaten, in dem Sie eine Zertifizierungsstelle erstellen und neue Zertifikate signieren können.  Wir haben eine einzige interne PKI ... Die Stammzertifizierungsstelle und die Zertifizierungsstelle der zweiten Ebene sind separat vorhanden, und wir verwalten die Zertifizierungsstelle der dritten Ebene bereits über Vault.  Um ausgestellte Zertifikate jeder Ebene zu speichern, einschließlich von externen Zertifizierungsstellen signierter Zertifikate, verwenden wir ein separates Präfix und legen dort fast alle gültigen Zertifikate für Buchhaltungs- und Überwachungszwecke ab.  Das Format zum Speichern von Zertifikaten ist proprietär und eignet sich zum Speichern eines separaten privaten Schlüssels und des Zertifikats selbst. <br><br><h2>  Zusammenfassung <br></h2><br>  <strong>Zu viel manuelle Arbeit</strong> für den Sicherheitsbeamten, <strong>zu viel Eingabeschwelle für den Entwickler</strong> und keine integrierten Delegierungstools, obwohl ich wirklich ... <br><br>  Wie man ist  Dann beginnen die Träume. <br><br><h2>  Ideen: wie man es besser macht <br></h2><br>  Wie kann ich ein paar Kopien eines Geheimnisses loswerden? <br><br><h3>  Lieferung Master-Slave <br></h3><br>  Wir haben ein Hauptgeheimnis und einen speziellen Dämon, der herumläuft, das Geheimnis und seine Metadaten betrachtet, es wo nötig ablegt und sich als Sklavengeheimnis herausstellt.  Auf dem Weg, auf dem der Daemon den Slave gepostet hat, kann nichts von Hand geändert werden, da der Daemon kommt und das Master-Geheimnis wieder auf den Slave legt. <br><br>  Zuerst wollten wir einen Symlink-Mechanismus erstellen, um einfach anzuzeigen: "Suchen Sie dort nach diesem Geheimnis!", Wie unter Linux.  Es stellte sich heraus, dass es Probleme mit Zugriffsrechten gibt: Es ist nicht bekannt, wie Zugriffsrechte überprüft werden sollen - wie unter Linux oder nicht, mit übergeordneten Pfaden, mit Übergängen zwischen Mountpunkten.  Es gibt zu viele zweideutige Momente und Chancen, einen Fehler zu machen, deshalb haben wir die Symlinks abgelehnt. <br><br><h3>  Eigentumsberechtigung <br></h3><br>  Das zweite, was wir tun möchten, ist <strong>, den Besitzer für jedes Geheimnis zu bestimmen</strong> .  Standardmäßig gehört das Geheimnis der Person, die es erstellt hat.  Bei Bedarf können Sie den Verantwortungsbereich auf die Einheit erweitern, indem Sie eine Eigentümergruppe festlegen. <br><br>  Wenn wir delegieren lernen, geben wir dem Eigentümer das Recht auf ein Geheimnis, und er kann mit dem Geheimnis tun, was er will. <br><br><ul><li>  In k8s verbreiten - eine Richtlinie wird generiert, eine Slave-Kopie wird erstellt. </li><li>  Auf dem Server verteilen - Eine Richtlinie wird generiert, eine Slave-Kopie wird erstellt. </li><li>  Verbreitung in CI / CD - ... </li><li>  Übertragung an einen anderen Eigentümer. </li><li>  Neuen Zugriff gewähren, neue ACLs generieren. </li></ul><br>  Jetzt sind wir für alle Geheimnisse und die Sicherheit verantwortlich, aber wir möchten die Verantwortung auf den Schöpfer übertragen.  <strong>Die Sicherheit wird nicht beeinträchtigt</strong> , da die Person, die mit der Bitte um Geheimhaltung zu uns gekommen ist, versteht, dass sie ein Geheimnis sicher aufbewahren muss, und sich ihrer Verantwortung bewusst ist. <br><br>  Da er der Besitzer des Geheimnisses ist, konnte er für die Master-Slave-Lieferoption auswählen, wo und in welchem ​​Format das Geheimnis an ihn geliefert werden soll.  Es stellt sich heraus, dass der Eigentümer alles selbst verwaltet. Es ist nicht erforderlich, Anträge einzureichen. Sie können das erforderliche Präfix selbst verwenden und Geheimnisse selbst erstellen und löschen. <br><br><h3>  Delegierung über ACL-Vorlagen <br></h3><br>  Die Zugriffsrichtlinie für die Zugriffssteuerungsliste in Vault ist in zwei Teile unterteilt: <br><br><ul><li>  Zugriffssteuerungsliste in der klassischen Ansicht, die den Zugriff auf das Präfix beschreibt, welche Art zu lesen und zu schreiben ist, welche nur zu lesen ist usw. </li><li>  Wenn Sie eine ACL erstellen, können Sie am Ende ein Sternchen schreiben, was "dieses Präfix und alles darunter" bedeutet.  Das Präfix kann als separate Operation zugewiesen werden, die dem Benutzer oder der Gruppe zugewiesen wird, dh mehreren verschiedenen Entitäten zugeordnet ist. </li></ul><br>  Derzeit kann nur der Vault-Administrator die ACL ändern.  Nachdem Sie Zugriff auf eine solche ACL erhalten haben, können Sie alles, was Sie möchten, vorschreiben, z. B. den <code>path “*” { capabilities = [sudo, ...] }</code> , und vollen Zugriff erhalten.  Dies ist die Essenz von <strong>Biggest Flaw</strong> # 1 - <strong>es ist unmöglich zu verbieten, den</strong> <strong>Inhalt der ACL</strong> <strong>zu ändern</strong> <strong>.</strong> <br><br>  Wir möchten die ACLs mit einer vorgefertigten Vorlage festlegen, die den Pfad und die Platzhalter enthält, auf denen neue ACLs für diese Vorlage generiert werden dürfen. <br><br><h4>  Beispiel <br></h4><br>  Unten finden Sie die gelbe Schriftart, den Pfad der fertigen Standard-ACL von Vault und die zulässigen Aktionen auf diesem Pfad.  Wir betrachten es als ACL für die Berechtigung, eine andere ACL unten zu ändern, die in Form einer Vorlage angegeben wird. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Wir möchten den Zugriff auf / k8s delegieren, wir lassen nur solche Vorlagen zu generieren.  Geben Sie beispielsweise schreibgeschützten Zugriff auf einen bestimmten Cluster, Namespace oder Dienst, ändern Sie jedoch nicht das Feld "Funktionen". <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Darüber hinaus möchten wir die Berechtigung erteilen, diese ACLs zu binden und andere Rechte zu erteilen. <br><br>  Wir haben die Vorlage angewendet, um dem Entwickler Rechte zu gewähren.  Beim Templating führte er den <code>$ vault write policy-mgr/create/k8s-microservice ...</code> .  Als Ergebnis haben wir eine ACL erhalten, die cluster = prod, namespace = ..., service = ... usw. angibt.  Die Rechte wurden automatisch festgelegt, eine Richtlinie wurde mit dem Namen <code>/k8s/some-srv</code> - dies ist nur der ACL-Name, der aus der Vorlage generiert werden kann. <br><img src="https://habrastorage.org/webt/ro/ih/ur/roihurfk7gxhvrv-hjpik6lctxc.png"><br><br>  Infolgedessen weist der Entwickler diese ACL nach unserem Ermessen jedem zu, der dies wünscht, und wird selbst Eigentümer. Er kann sie als Geheimnis verwalten: Löschen, Geben und Entfernen von Benutzern und Gruppen.  Jetzt ist die Person selbst für ihr Präfix verantwortlich: Er verwaltet alle Geheimnisse, generiert ACLs gemäß der Vorlage und kann den gewünschten ACLs zuweisen.  Natürlich können wir es auch einschränken. <br><br>  Alle Magie funktioniert mit den neuen Vault-Entity- <strong>Plugins</strong> .  Sie sind ein separater Dienst, der dem eingangs erwähnten sehr ähnlich ist und fast genauso funktioniert.  Der einzige wichtige Unterschied ist, dass sie keine Proxies sind.  Plugins werden "auf der Seite" von Vault gestartet und starten ihren Haupt-Vault-Prozess.  Aus diesem Grund werden alle Anforderungen nicht über den Dienst, sondern an Vault gesendet, der selbst bereits mit dem Plug-In interagiert und ihm eine verifizierte und gelöschte Anforderung sendet. <br><br>  Informationen zu Plugins, wie sie angeordnet sind und wie sie geschrieben werden, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Vault-Website</a> .  Es ist am besten, sie auf Go zu schreiben, was ganz einfach ist, weil  Es gibt einen Rahmen für Go.  Vault kommuniziert mit dem Plugin über grpc, startet es als Dienst, aber keine Angst, Sie berühren es nicht - alles ist bereits im Framework.  Sie schreiben einfach eine mehr oder weniger standardmäßige REST-Anwendung, in der Sie Endpunkte angeben, ihnen vorgefertigte Funktionen und Handler mit Logik zuweisen. <br><br>  Haben Sie keine Angst, dass Sie etwas im Hauptgewölbe zerbrechen.  Ein Plugin ist ein separater Dienst.  Selbst wenn Ihr Plugin in Panik geriet und abstürzte, wird es die Arbeit von Vault nicht beeinträchtigen.  Vault startet das Plugin einfach neu und arbeitet weiter. <br><br>  Zusätzlich gibt es zusätzliche Einstellungen für das Plugin selbst: Es überprüft immer die Hash-Summen, damit niemand die Binärdatei ändert.  <strong>Die Sicherheit der Ausführung von Plugins ist gewährleistet</strong> . <br><br><h2>  Nützliche Links: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.vaultproject.io</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jovandeginste/hiera-router</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jsok/hiera-vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.owasp.org/index.php/Security_Champions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blog.jetbrains.com/teamcity/2017/09/vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/oracle/kubernetes-vault-kms-plugin</a> </li></ul><br><blockquote>  Wir werden über DevOps und Sicherheit, CI / CD, k8s, Puppet und all das in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> (das nächstgelegene in St. Petersburg im April) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevOpsConf sprechen</a> .  Teilen Sie Ihre Erfahrungen mit oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schauen Sie sich</a> andere an.  Um nicht zu vergessen, abonnieren Sie den Blog und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter</a> , in denen wir Sie an Fristen erinnern und nützliche Materialien sammeln. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438740/">https://habr.com/ru/post/de438740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438726/index.html">Y Combinator: So schließen Sie ein Unternehmen</a></li>
<li><a href="../de438730/index.html">HomoLudens: Alles Gute zum Geburtstag, Sid Meyer (+ alle Artikel in russischer Sprache)</a></li>
<li><a href="../de438732/index.html">Amateurfunkmessungen: I2C-Bussignalanalyse</a></li>
<li><a href="../de438734/index.html">Gewirr von Gleichgesinnten</a></li>
<li><a href="../de438736/index.html">DevDay für Manager: IT verwalten</a></li>
<li><a href="../de438746/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution. Fortsetzung</a></li>
<li><a href="../de438748/index.html">Infrastruktur als Code gewinnen wir auf einer Skala (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../de438750/index.html">Zivilisation der Quellen, 4/5</a></li>
<li><a href="../de438752/index.html">Buchhaltung direkt bei der Bank: Wie man einzelne Unternehmer glücklich macht</a></li>
<li><a href="../de438754/index.html">Wie wir die Netzwerküberwachung für 14.000 Objekte durchgeführt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>