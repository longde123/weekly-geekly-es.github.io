<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìØ üòí üï¥üèæ Verwalten von Geheimnissen mit HashiCorp Vault üçí ü§õüèª ü§ûüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie man Geheimnisse bewahrt? Im Repository, im Bereitstellungssystem oder im Konfigurationsmanagementsystem? Auf einem PC, auf Servern oder vielleicht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwalten von Geheimnissen mit HashiCorp Vault</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/438740/">  Wie man Geheimnisse bewahrt?  Im Repository, im Bereitstellungssystem oder im Konfigurationsmanagementsystem?  Auf einem PC, auf Servern oder vielleicht in einer Box unter dem Bett?  Und wie gehe ich mit Geheimnissen um, um Lecks zu vermeiden? <br><br>  <strong>Sergey Noskov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Albibek</a> ) - der Leiter der Informationssicherheitsgruppe der Plattform aus Avito</strong> , kennt die Antwort auf diese Fragen und wird sie uns <strong>mitteilen</strong> .  In Avito nutzt HashiCorp Vault HashiCorp Vault seit zwei Jahren aktiv. W√§hrend dieser Zeit haben sie Unebenheiten und Erfahrung auf das ‚ÄûMaster‚Äú -Niveau gebracht. <br><br>  In dem Artikel werden wir umfassend √ºber Vault sprechen: Was es ist, wo und wie es im Unternehmen verwendet wird, wie Avito Geheimnisse mit HashiCorp Vault verwaltet, wie Puppet und Kubernetes verwendet werden, Anwendungsf√§lle mit Puppet und anderen SCM, welche Probleme auftreten, was die Sicherheit beeintr√§chtigt und Entwickler, und nat√ºrlich teilen Ideen, wie man es beheben kann. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oDdDPU6moTs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><h2>  Was ist ein Geheimnis? </h2><br>  Alle vertraulichen Informationen: <br><br><ul><li>  Login und Passwort zum Beispiel in der Datenbank; </li><li>  API-Schl√ºssel </li><li>  Server-Zertifikatschl√ºssel (* .google.com) </li><li>  Kundenzertifikatschl√ºssel (Partner, Yandex-Geld, QIWI); </li><li>  Schl√ºssel zum Signieren mobiler Anwendungen. </li></ul><br>  Alle Informationen, die wir geheim halten wollen, nennen wir geheim.  Dies f√ºhrt zu einem Speicherproblem: Das Speichern im Repository ist in verschl√ºsselter Form fehlerhaft. Sie m√ºssen die Verschl√ºsselungsschl√ºssel irgendwo aufbewahren. <br><br>  <strong>HashiCorp Vault</strong> ist eine der guten L√∂sungen f√ºr das Problem. <br><br><ul><li>  Schl√ºssel sicher speichern und verwalten. </li><li>  Gesch√§rft auf der Welt der Microservices, seit dem Microservice selbst. </li><li>  <strong>HashiCorp Vault</strong> hat viel getan, um den Zugriff auf Geheimnisse wie ACLs und das Prinzip der Mindestberechtigungen zu authentifizieren und zu autorisieren. </li><li>  REST-Schnittstelle mit JSON. </li><li>  Sicherheit ist nicht perfekt, aber auf einem ziemlich hohen Niveau. </li></ul><br>  Meiner Meinung nach ist dies ein ziemlich praktisches Werkzeug. <br><br><h2>  Was ist neu in HashiCorp Vault? <br></h2><br>  Das Tool entwickelt sich und in den letzten Jahren sind viele interessante Funktionen enthalten: CORS-Header f√ºr die grafische Benutzeroberfl√§che ohne Zwischenh√§ndler;  eingebaute GUI;  native Integration mit Kubernetes;  Plugins f√ºr logische und Auth-Backends und Frameworks. <br><br>  Die meisten √Ñnderungen, die mir pers√∂nlich gefallen haben, sind die <strong>M√∂glichkeit, keine Erweiterungen und Erg√§nzungen zu schreiben</strong> , die au√üerhalb des Tools stehen. <br><br>  Zum Beispiel gibt es Vault, das Sie erweitern m√∂chten - schreiben Sie zus√§tzliche Logik oder Ihre eigene Benutzeroberfl√§che f√ºr die Automatisierung, die etwas automatisiert.  Vor den √Ñnderungen musste ich einen zus√§tzlichen Dienst ausl√∂sen, dem Vault gegen√ºbersteht, und alle Anforderungen weiterleiten: Zuerst gehen die Anforderungen an den Dienst, dann an Vault.  Dies ist schlecht, da im Zwischendienst m√∂glicherweise ein geringeres Sicherheitsniveau besteht und alle Geheimnisse dies durchlaufen.  <strong>Sicherheitsrisiken sind viel h√∂her, wenn das Geheimnis mehrere Punkte gleichzeitig durchl√§uft!</strong> <br><br><h2>  Henne-Ei-Problem <br></h2><br>  Wenn Sie das Problem der Speicherung vertraulicher Informationen ansprechen und sich f√ºr die Verschl√ºsselung entscheiden, wird Ihr Geheimnis, sobald Sie etwas verschl√ºsseln, vom Ort der Verschl√ºsselung an den Ort verschoben, an dem der Schl√ºssel gespeichert ist.  Dies geschieht st√§ndig: Sobald Sie irgendwo ein Geheimnis gespeichert oder ein vorhandenes ge√§ndert haben, haben Sie ein anderes und ein verzauberter Kreis beginnt - <strong>wo Sie das Geheimnis f√ºr den Zugriff auf das Geheimnis aufbewahren k√∂nnen</strong> . <br><br>  Das Geheimnis f√ºr den Zugriff auf das Geheimnis ist der Teil der Sicherheit, der als <strong>Authentifizierung bezeichnet wird</strong> .  Sicherheit hat einen anderen Teil - die <strong>Autorisierung.</strong>  Im Autorisierungsprozess wird gepr√ºft, ob der Benutzer genau dort zugreifen kann, wo er anfordert.  Im Fall von Vault gibt es einen vertrauensw√ºrdigen Dritten, der entscheidet, ob das Geheimnis preisgegeben wird oder nicht.  Die Autorisierung l√∂st das Problem nur teilweise. <br><br><h2>  HashiCorp Vault in Avito <br></h2><br>  Bei Avito wird HashiCorp in der einzigen gro√üen Installation im gesamten Netzwerk installiert.  HashiCorp Vault hat viele verschiedene Backends.  Wir verwenden das auf <strong>Consul</strong> basierende Backend auch von HashiCorp, da Vault seine eigene Fehlertoleranz nur √ºber Consul unterst√ºtzen kann. <br><br>  <strong>Das Entsiegeln</strong> ist eine M√∂glichkeit, den Hauptschl√ºssel nicht an einem Ort <strong>aufzubewahren</strong> .  Wenn Vault gestartet wird, wird alles auf einem Schl√ºssel verschl√ºsselt, und erneut tritt das Problem mit H√ºhnchen und Eiern auf: Wo soll ein Geheimnis aufbewahrt werden, das alle anderen Geheimnisse verschl√ºsselt?  Um dieses Problem zu vermeiden, stellt Vault einen zusammengesetzten Schl√ºssel zur Verf√ºgung, f√ºr den mehrere Teile des Schl√ºssels erforderlich sind, den wir an mehrere Mitarbeiter verteilen.  In Avito haben wir Unseal in den Optionen f√ºr 3 von 7 Personen konfiguriert. Wenn wir Vault starten, m√ºssen mindestens 3 Personen hereinkommen und ihren Teil des Schl√ºssels eingeben, um mit der Arbeit zu beginnen.  Der Schl√ºssel ist in 7 Teile unterteilt und Sie k√∂nnen jeden von ihnen mitbringen. <br><br>  Wir haben einen kleinen Test-Tresor zusammengestellt, eine Sandbox f√ºr Entwickler, in der sie spielen k√∂nnen.  Es hat die Form eines Docker-Containers und schafft einfache Geheimnisse, damit die Leute das Werkzeug mit den H√§nden ber√ºhren und es sich bequem machen k√∂nnen.  Es gibt keinen Konsul und kein Clustering in der Sandbox. Es handelt sich lediglich um ein Dateisystem, in dem Vault verschl√ºsselte Geheimnisse enth√§lt, und ein kleines Skript zum Initialisieren. <br><br>  Folgendes speichern wir jetzt in Vault: <br><br><ul><li>  Fast alle Geheimnisse f√ºr Kubernetes Microservices: Datenbankkennw√∂rter, API-Schl√ºssel, alle oben genannten. </li><li>  Geheimnisse f√ºr das Auflegen auf die "Eisen" -Server und LXC. </li><li>  Wir haben auch Geheimnisse f√ºr CI / CD-Builds in TeamCity in Vault gespeichert.  Die Abdeckung ist nicht 100%, aber durchaus akzeptabel. </li><li>  Die Schl√ºssel aller Zertifikate: interne PKI, externe Zertifizierungsstellen, z. B. GeoTrust und dergleichen. </li><li>  Gemeinsame Geheimnisse f√ºr Teams. </li></ul><br>  Im Inneren speichert Vault alles nur in JSON. Dies ist nicht immer praktisch und erfordert zus√§tzliche Aktionen des Entwicklers. Daher ver√∂ffentlichen wir Geheimnisse im Grunde in Form einer Datei. <br><br><blockquote>  Wir versuchen, Geheimnisse in Form von Dateien zu liefern. <br></blockquote><br>  Wir sagen dem Entwickler nicht: "Gehe zu Vault, nimm ein Geheimnis!", Aber lege die Datei auf die Festplatte und sage: "Entwickler, eine Datei wird auf deiner Festplatte angezeigt, nimm das Geheimnis von ihr und wir werden bereits herausfinden, wie du sie aus Vault holen und bringen kannst dir". <br><img src="https://habrastorage.org/webt/rg/9o/mj/rg9omjizdszcnw0lzrr_iogfosc.png"><br><br>  Wir haben eine einfache Vereinbarung f√ºr JSON-Felder getroffen, in der wir angeben, mit welchen Rechten die Datei hochgeladen werden soll.  Dies sind Metadaten f√ºr das Dateisystem, und das Datenfeld ist eine codierte Zeichenfolge mit dem Geheimnis selbst, das zum Inhalt der Datei wird. <br><br><h2>  Marionette + Hiera + Gew√∂lbe <br></h2><br>  Fast die gesamte Avito-Infrastruktur verwendet Puppet und rollt alle Server aus. <br><br>  Puppet hat ein praktisches Werkzeug zum Organisieren von Hierarchien - <strong>Hiera</strong> .  Vault l√§sst sich √ºber ein Add-On-Modul sehr gut in Hiera integrieren, da die Schl√ºsselwertanforderung an diese Bibliothek gesendet wird und Vault die Schl√ºsselwertdatenbank selbst ist, jedoch mit allen Sicherheitsfunktionen - mit transparenter Verschl√ºsselung und der M√∂glichkeit, den Schl√ºsselzugriff zu w√§hlen. <br><br>  Daher haben wir als erstes Vault in Puppet implementiert, aber mit einem Zusatz - wir haben eine Zwischenschicht namens <strong>Router-Backend</strong> .  Router-Backend - ein separates Hiera-Modul, nur Dateien auf der Festplatte, die angeben, wo Hiera den Schl√ºssel abrufen soll - in Vault oder an einem anderen Ort. <br><br>  Er wird gebraucht, damit Hiera nicht st√§ndig zum Tresor geht, weil sie immer durch die Hierarchie geht.  Dies ist kein Vault-Problem oder eine Belastung, sondern eine Funktion von Hiera.  Wenn Sie daher nur das Modul f√ºr Vault ohne das Router-Backend belassen, dauert es sehr lange, bis der Puppet-Master die Konfiguration f√ºr den Puppet-Agenten erfasst, da er jeden Schl√ºssel im Vault √ºberpr√ºft. <br><img src="https://habrastorage.org/webt/dv/di/f6/dvdif6z09jpflg98zykbwf7l7cq.png"><br><br>  F√ºr Puppet ist das Problem von Huhn und Eiern dadurch gel√∂st, dass die autorisierende Partei der Puppenspieler ist.  Er gibt das Geheimnis, um auf das Geheimnis zuzugreifen.  Der Puppenmeister hat Zugriff auf alle Geheimnisse gleichzeitig, aber jeder Host darf nur das empfangen, das f√ºr ihn bestimmt ist.  Der Host auf dem Puppet Master ist bereits durch sein Zertifikat autorisiert, das lokal generiert wird und die Hostlimits nicht verl√§sst.  Im Prinzip bleibt das Geheimnis, um auf das Geheimnis zuzugreifen, aber dies ist nicht so kritisch. <br><br>  Unser Prozess, ein neues Geheimnis in Puppet zu enth√ºllen, besteht aus den folgenden Schritten. <br><br><ul><li>  Wir nehmen irgendwo ein Geheimnis - jemand gibt es uns oder l√∂scht es. </li><li>  Ein Geheimnis in Vault mit einer Hierarchie wie in Hiera: <strong>/puppet/role/www/site.ssl.key</strong> . </li><li>  Wir registrieren ein Pr√§fix im Puppet-Manifest, das angibt, dass sich die Datei in Vault befindet und wo sie erh√§ltlich ist. </li><li>  Wir schreiben den Pfad in Vault in YAML f√ºr den Hiera-Router und das Backend, damit Hiera ihn finden kann. </li><li>  Ziehen Sie die Anforderung √ºber GIT in das Manifest-Repository. </li><li>  F√ºhren Sie aus oder warten Sie, bis der Puppet-Agent ausgef√ºhrt wird. </li></ul><br>  Puppenspieler rennen alle 30 Minuten mit uns weg, also m√ºssen Sie ein bisschen warten, bis das Geheimnis herauskommt.  Dies verursacht keine Probleme - <strong>wir teilen nicht jeden Tag Geheimnisse</strong> .  Solange Kubernetes nicht in das Gesch√§ft involviert ist, gibt es nicht viel Aufwand und wir sind bereit, mit minimaler Automatisierung mit unseren H√§nden Geheimnisse in Vault zu l√ºften. <br><br>  Ein zus√§tzliches Plus ist die "Chip" -Hiera - das <strong>Geheimnis kann sofort f√ºr eine Gruppe von Hosts</strong> oder abh√§ngig von der Rolle des Hosts, die wir in der variablen Rolle festgelegt haben, festgelegt werden. <br><br>  Die einzige <strong>Gefahr</strong> : Wenn Sie Puppet haben und Hiera verwenden, ersetzen Sie Variablenvorlagen nicht durch Hindernisse, da viele Fakten und Variablen auf der Clientseite gesammelt werden.  Wenn ein Angreifer eine Tatsache auf dem Klienten ersetzt, gibt ihm der Puppenmeister die Geheimnisse anderer Leute.  <strong>√úberpr√ºfen Sie unbedingt die Variablen</strong> : Verwenden Sie nur diejenigen, die der Puppet-Master auf der Client-Seite nicht bestimmen kann. <br><br><h2>  Was tun mit SCM ohne Assistenten? <br></h2><br>  Wenn Sie pl√∂tzlich keine Puppe mehr haben, dann h√∂chstwahrscheinlich Ansible.  F√ºr Chefkoch und andere zentralisierte SCMs sind ihre L√∂sungen ein Plugin, das auf Vault zugreifen kann.  Ich biete verschiedene Optionen an, die mit Ansible implementiert werden k√∂nnen. <br><br><h3>  Lokaler Agent <br></h3><br>  Generieren Sie lokal f√ºr den Server ein Token, das eigentlich das Kennwort f√ºr den Zugriff auf den Tresor ist.  Das Token ist jederzeit g√ºltig.  Sie k√∂nnen es aktualisieren oder automatisieren.  Mit diesem Token gehst du zum Tresor und nimmst deine Geheimnisse weg. <br><br>  Die Idee ist, dass auf Ihrem Server, auf dem Sie Geheimnisse bereitstellen m√ºssen, der Agent, der zu Vault kommt, sich dreht, alle Geheimnisse √ºberpr√ºft und sie in Form von Dateien ablegt.  Wir verwenden den Agenten auf mehreren separaten Servern, auf denen keine Marionette vorhanden ist. <br><br>  <strong>Nachteile:</strong> <br><br><ul><li>  Das Token kann einfach in ein kleines Segment eingegeben werden. Wenn jedoch mehrere Dutzend Server pro Tag bereitgestellt werden, m√ºssen Sie f√ºr jeden Server ein Token generieren und eine Richtlinie vorschreiben.  Dies ist unpraktisch. </li><li>  Token muss aktualisiert werden. </li><li>  Das Gruppieren von Servern nach Rolle, Zweck oder Fakten ist schwierig. Sie m√ºssen mit Vault synchronisiert werden. </li></ul><br><h3>  Transit-Verschl√ºsselung <br></h3><br>  Vault verf√ºgt √ºber eine Transitverschl√ºsselungsfunktion, deren Kern darin besteht, dass Vault als <strong>Verschl√ºsselungsserver fungiert</strong> .  Sie bringen ihm nur Klartext, und er verschl√ºsselt und gibt auf seinem privaten Schl√ºssel, den nur er hat, den geschlossenen Text aus.  Dann w√§hlen Sie, wer diesen geschlossenen Text entschl√ºsseln kann. <br><br>  Ansible hat eine Entit√§t, auch Vault genannt.  Dies ist kein HashiCorp-Tresor, sondern ein <strong>Ansible-Tresor</strong> .  Es besteht kein Grund zur Verwirrung, und Geheimnisse k√∂nnen sowohl im ersten als auch im zweiten gespeichert werden.  Ansible verf√ºgt √ºber ein vorgefertigtes Plugin f√ºr die Bereitstellung von Geheimnissen aus Hashicorp Vault.  Wenn Sie pers√∂nlichen Zugriff auf Vault gew√§hren, k√∂nnen Sie Geheimnisse entschl√ºsseln.  Wenn Sie Ansible rollen, geht es in Ihrem Namen zu Vault, entschl√ºsselt die Geheimnisse, die im Repository verschl√ºsselt sind, und rollt es in die Produktion. <br><br>  Es gibt auch einen Nachteil: <strong>Jeder Administrator erh√§lt Zugriff auf Geheimnisse</strong> .  Aber es gibt eine Pr√ºfung: Vault wei√ü, wie man ein Aktivit√§tsprotokoll dar√ºber f√ºhrt, welcher Benutzer hereingekommen ist, welches Geheimnis er gelesen hat und welcher Zugriff erhalten hat.  Sie wissen immer, wer, wann und was mit einem Geheimnis zu tun hat.  Diese Option scheint mir gut zu sein. <br><br><h3>  Gro√üer Fehler # 1 <br></h3><br>  Der gr√∂√üte Nachteil, der uns am meisten schmerzt, ist, dass Sie in Vault die vollst√§ndige Kontrolle √ºber keinen <strong>Teil der</strong> <strong>Daten an</strong> Dritte delegieren k√∂nnen.  In Vault erfolgt der Zugriff auf das Geheimnis auf √§hnliche Weise wie in UNIX. Namen werden normalerweise durch Schr√§gstriche getrennt, und das Ergebnis ist ein "Verzeichnis".  Wenn Sie einen solchen Pfad haben, m√∂chten Sie manchmal Teil des Pfads sein und ihn zur Kontrolle an eine andere Person weitergeben. <br><img src="https://habrastorage.org/webt/w-/hq/gf/w-hqgfwmxgok3_dimlgnn8baxag.png"><br><br>  Sie haben beispielsweise Zertifikate mit dem Namen <strong>/ certs erhalten</strong> und m√∂chten diese einzelnen Sicherheitsbeauftragten geben, die sich mit PKI befassen.  Vault kann das nicht.  Sie k√∂nnen nicht das Recht einr√§umen, Rechte innerhalb dieses Pr√§fixes zu erteilen, damit die Sicherheitskr√§fte selbst die Rechte an Zertifikaten an andere Personen verteilen k√∂nnen. <br><br>  <strong>Vault ist nicht in der Lage, selektiv Rechte zu gew√§hren, um Rechte zu gew√§hren</strong> .  Sobald Sie das Recht einger√§umt haben, Rechte zu gew√§hren, haben Sie auch die M√∂glichkeit gegeben, uneingeschr√§nkten Zugriff auf alle Geheimnisse zu erhalten.  Mit anderen Worten, Sie k√∂nnen keinen Zugriff auf den Vault-Teil gew√§hren. <br><br>  Dies ist eines der gr√∂√üten Probleme.  Ich habe eine Idee, wie ich es l√∂sen kann. Ich werde es dir sp√§ter erz√§hlen. <br><br><h2>  Kubernetes <br></h2><br>  Bei RIT ++ habe ich √ºber ein separates System gesprochen, das wir f√ºr <strong>Kubernetes</strong> implementiert haben: Es dient als Dritter, geht zur API, √ºberpr√ºft den Zugriff und fordert dann ein Geheimnis in Vault an. <br><br>  Jetzt hat unser System an Relevanz verloren, da in Vault 0.9 native Unterst√ºtzung f√ºr Kubernetes angezeigt wurde.  Jetzt wei√ü Vault selbst, wie man zu Kubernetes geht und sicherstellt, dass der Zugriff auf das Geheimnis erlaubt ist.  Er tut dies mit einem <strong>Service Account Token</strong> .  Wenn Sie beispielsweise einen Pod eingef√ºhrt haben, gibt es einen speziellen, signierten und autorisierten <strong>JWT</strong> daf√ºr, der f√ºr Anforderungen an die Kubernetes-API entwickelt wurde.  Mit einem Token k√∂nnen Sie sich auch bei Vault anmelden und Geheimnisse speziell f√ºr Ihren Namespace abrufen. <br><br>  Alles wird auf der Ebene von Vault selbst erledigt.  Es ist richtig, dass Sie f√ºr jeden Namespace eine Rolle starten m√ºssen, dh Vault mitteilen, dass es einen solchen Namespace gibt, dass eine Autorisierung darin vorhanden ist, und registrieren, wohin Sie zu Kubernetes gehen sollen.  Dies wird einmal durchgef√ºhrt, und dann geht Vault zur API selbst, best√§tigt die G√ºltigkeit des JWT und stellt sein eigenes Zugriffstoken aus. <br><br><h3>  Kubernetes Regeln <br></h3><br>  In Bezug auf den Servicenamen und zus√§tzliche Metadaten vertrauen wir den Entwicklern.  Es besteht eine geringe Wahrscheinlichkeit, dass Entwickler versehentlich oder absichtlich die Geheimnisse anderer Dienste erfahren, die sich in einem Namespace drehen. Daher haben wir eine Regel eingef√ºhrt: <strong>einen Dienst</strong> - <strong>einen Namespace.</strong> <br><br>  Neuer Microservice?  Holen Sie sich einen neuen Namespace mit Ihren Geheimnissen.  Sie k√∂nnen nicht √ºber die Grenze zum Nachbarn gehen - sie haben ein eigenes Service Account Token.  <strong>Die Sicherheitsgrenze bei Kubernetes ist derzeit der Namespace.</strong>  Wenn Sie in zwei verschiedenen Namespaces ein Geheimnis ben√∂tigen, kopieren Sie es. <br><br>  Kubernetes hat <strong>Kubernetes Geheimnisse</strong> .  Sie werden unverschl√ºsselt in etcd in Kubernetes gespeichert und k√∂nnen im Dashboard oder beim Start von kubectl get pods "aufleuchten".  Wenn die Authentifizierung in etcd in Ihrem Cluster deaktiviert ist oder Sie jemandem vollst√§ndigen Lesezugriff gew√§hrt haben, sind alle Geheimnisse f√ºr ihn sichtbar.  Aus diesem Grund haben wir zwei Regeln eingef√ºhrt: Es ist <strong>verboten, Kubernetes-Geheimnisse zu verwenden,</strong> und es ist <strong>verboten, Geheimnisse in Umgebungsvariablen in Manifesten anzugeben</strong> .  Wenn Sie in deploy.yaml ein Geheimnis in die Umgebung schreiben, ist dies schlecht, da das Manifest selbst von jedem gesehen werden kann, der nicht faul ist. <br><br><h3>  Kubernetes Lieferung <br></h3><br>  Wie gesagt, wir m√ºssen die Datei irgendwie in Kubernetes ablegen.  Wir haben eine Art Geheimnis: die Essenz, das Passwort, das in JSON in Vault geschrieben ist.  Wie kann man es jetzt in eine Datei im Container von Kubernetes verwandeln? <br><img src="https://habrastorage.org/webt/gm/ki/wb/gmkiwblvlm7ca4hiwmvhhx14wxu.png"><br><br>  Die erste Lieferoption. <br><br><ul><li>  Wir starten einen speziellen Init-Container. </li><li>  Es geht von unserem Bild aus. </li><li>  Das Image enth√§lt ein kleines Dienstprogramm, das mit dem Service Account Token an Vault geht, das Geheimnis aufnimmt und es in das freigegebene Volume legt. </li><li>  F√ºr das Dienstprogramm wird ein spezielles freigegebenes Volume nur im TMPFS-Speicher bereitgestellt, damit keine Geheimnisse √ºber die Festplatte √ºbertragen werden. </li><li>  Der Init-Container geht zu Vault und legt in diesem Volume in Form von Dateien alle Geheimnisse ab, die er auf dem angegebenen Pfad findet. </li><li>  Als n√§chstes wird das freigegebene Volume in dem Hauptcontainer bereitgestellt, in dem es ben√∂tigt wird. </li><li>  Wenn der Hauptcontainer gestartet wird, erh√§lt er sofort das, was der Entwickler ben√∂tigt - Geheimnisse in Form einer Datei auf der Festplatte. </li></ul><br>  Der Entwickler muss sich nur an den Weg erinnern, auf dem sein Geheimnis liegt. <br><br>  Wir verwenden so etwas wie dieses Pr√§fix: <br><br><pre><code class="plaintext hljs">/k8s/&lt;cluster&gt;/&lt;namespace&gt;/&lt;service&gt;/some_secret</code> </pre> <br>  Der Pr√§fixname enth√§lt den Clusternamen, den Namespace und den Dienstnamen.  Jeder Dienst hat sein eigenes Geheimnis, jeder Namespace hat sein eigenes Geheimnis. <br><br>  Die zweite Option ist Ihr <strong>eigener Einstiegspunkt</strong> .  Wir ziehen jetzt in Avito um, weil Entwickler Probleme mit dem Init-Container haben.  Im Diagramm befindet sich diese Option rechts. <br><br>  Nicht jeder kann sich seinen eigenen Einstiegspunkt leisten.  Wir k√∂nnen, also erzwingen wir in jedem Container unseren speziellen Einstiegspunkt. <br><br>  Unser Einstiegspunkt macht dasselbe wie der Init-Container: Er geht mit einem Service Account Token zu Vault, nimmt Geheimnisse und l√∂scht sie.  Zus√§tzlich zu den Dateien legt er sie wieder in der Umgebung ab.  Sie haben die M√∂glichkeit, die Anwendung wie vom <strong>Twelve-Factor App-</strong> Konzept empfohlen auszuf√ºhren: Die Anwendung √ºbernimmt alle Einstellungen, einschlie√ülich Geheimnisse, von Umgebungsvariablen. <br><br>  Umgebungsvariablen sind im Manifest und im Dashboard nicht sichtbar, da sie beim Start durch PID 1 (den Hauptcontainerprozess) festgelegt werden.  Hierbei handelt es sich nicht um Umgebungsvariablen aus deploy.yaml, sondern um Umgebungsvariablen, die vom Einstiegspunkt im Prozess festgelegt werden.  Sie sind im Dashboard nicht sichtbar, sie sind auch dann nicht sichtbar, wenn Sie kubectl exec in einem Container ausf√ºhren, da in diesem Fall parallel zu PID1 ein anderer Prozess gestartet wird. <br><br><h3>  Workflow <br></h3><br>  Aus organisatorischer Sicht ist der Prozess wie folgt.  Der Entwickler erf√§hrt vom Sicherheitschampion oder aus der Dokumentation, dass er keine Geheimnisse im Repository, sondern nur in Vault aufbewahren soll.  Dann kommt er zu uns und fragt, wo er Geheimnisse preisgeben soll - er reicht einen Antrag bei der Sicherheit ein, um ein Pr√§fix festzulegen.  In Zukunft k√∂nnen Sie sofort beim Erstellen eines Dienstes ein Pr√§fix ohne Anforderung erstellen. <br><br>  Der Entwickler wartet, und das ist schlecht, weil  Die Hauptsache f√ºr ihn ist die Markteinf√ºhrungszeit.  Dann liest er die Anweisungen, befasst sich mit langen Dateien - "f√ºge diese Zeile dort ein, f√ºge diese Zeile hier ein".  Ein Entwickler hat noch nie einen Init-Container gestartet, muss ihn jedoch herausfinden und in deploy.yaml (Helmdiagramm) registrieren. <br><br> <code>Commit -&gt; deploy -&gt; feel pain -&gt; fix -&gt; repeat</code> <br> <br>  Es legt fest, wartet auf die Einf√ºhrung von TeamCity, sieht Fehler in TeamCity, f√ºhlt Schmerzen, versucht, etwas zu beheben, hat wieder Schmerzen.  Dar√ºber hinaus wird √ºberlagert, dass jeder Rollout in TeamCity weiterhin in die Warteschlange gestellt werden kann.  Manchmal kann ein Entwickler es nicht selbst herausfinden, kommt zu uns und wir kl√§ren es gemeinsam. <br><br>  Grunds√§tzlich leidet der Entwickler an seinen eigenen Fehlern: <strong>falsch angegebener Init-Container oder hat die Dokumentation nicht gelesen</strong> . <br><br>  Sicherheit hat auch Probleme.  Der Sicherheitsbeamte erh√§lt eine Anwendung, in der immer nur wenige Informationen vorhanden sind, und wir finden immer noch die fehlenden Fragen heraus: Finden Sie die Namen der Cluster und den Namespace des Dienstes heraus, da der Entwickler sie in der Anwendung nicht angibt und nicht einmal immer wei√ü, was es ist.  Wenn wir alles herausfinden, Richtlinien und Rollen in Vault erstellen, Gruppen Richtlinien vorschreiben und gemeinsam mit dem Entwickler herausfinden, wo und warum er einen Fehler gemacht hat, lesen wir gemeinsam die Protokolle. <br><br>  Die Einheit ‚ÄûArchitektur‚Äú hilft bei der L√∂sung des Problems, indem sie sich vor dem Entwickler von deploy.yaml versteckt.  Sie entwickeln ein St√ºck, das alles f√ºr den Entwickler generiert, einschlie√ülich des Einstiegspunkts.  Aufgrund der Tatsache, dass wir unseren Einstiegspunkt ersetzen, k√∂nnen wir ihn nicht nur zur √úbermittlung von Geheimnissen verwenden, sondern auch f√ºr andere Dinge, die Sie m√∂glicherweise beim Start tun m√ºssen. <br><br><h3>  Offensichtliche Probleme mit Kubernetes Geheimnissen. <br></h3><br><ul><li>  <strong>Sehr komplizierter Workflow</strong> sowohl f√ºr den Entwickler als auch f√ºr den Sicherheitsbeamten. </li><li>  <strong>Sie k√∂nnen nichts an jemanden delegieren.</strong>  Der Sicherheitsbeamte hat vollen Zugriff auf den Tresor, und ein teilweiser Zugriff ist nicht m√∂glich (siehe Gro√üer Fehler Nr. 1). </li><li>  Beim Verschieben von Entwicklern von Cluster zu Cluster, von Namespace zu Namespace, wenn gemeinsame Geheimnisse ben√∂tigt werden, treten Schwierigkeiten auf, da zun√§chst davon ausgegangen wird, dass verschiedene Geheimnisse in verschiedenen Clustern unterschiedlich sind. </li></ul><br>  Wir sagen: ‚ÄûWarum brauchen Sie Produktionsgeheimnisse im Entwicklungscluster?  Holen Sie sich ein Testgeheimnis, machen Sie mit! ‚Äú  Infolgedessen gibt es <strong>Minen</strong> <strong>und Geheimnisse</strong> , die schwer zu verwalten sind.  Wenn sich das Geheimnis ge√§ndert hat, d√ºrfen Sie es nicht vergessen, es √ºberall √§ndern, und es gibt keine M√∂glichkeit festzustellen, dass es dasselbe Geheimnis ist, au√üer durch den Namen des Dienstes. <br><br><h3>  Idee: Kubernetes KMS <br></h3><br>  In neuen Versionen von Kubernetes ist das KMS-Subsystem Key Management Service eine neue geheime Verschl√ºsselungsfunktion von Kubernetes.  In v1.11 befand es sich im Alpha-Zustand, in v1.12 wurde es in die Beta √ºbertragen. <br><img src="https://habrastorage.org/webt/yq/nw/i9/yqnwi9a_t6atxpxdu_qrtu0qz80.png"><br>  <em>Das Bild stammt von der KMS-Provider-Projektwebsite f√ºr Vault und weist einen Fehler auf.</em>  <em>Wenn Sie finden - schreiben Sie in die Kommentare.</em> <br><br>  Die Bedeutung von KMS besteht darin, einen einzigen Nachteil zu beseitigen - die unverschl√ºsselte Datenspeicherung in etcd. <br><br>  KMS kann dies wie Ansible. <br><br><ul><li>  Gehen Sie irgendwohin, verschl√ºsseln Sie das native Geheimnis von Kubernet und verschl√ºsseln Sie es. </li><li>  Bei Bedarf an den Pod liefern, entschl√ºsseln und in entschl√ºsselte Form bringen. </li></ul><br>  Die Entwickler haben einen speziellen Dienst geschrieben, der dies mithilfe der Transitverschl√ºsselung tut.  Die Idee scheint zu funktionieren, aber es ist wichtig, sich daran zu erinnern, dass Geheimnisse nicht mehr nur unter der Kontrolle von Vault stehen und woanders in den Verantwortungsbereich der Kubernetes-Administratoren gehen. <br><br>  Nachteile KMS. <br><br><ul><li>  <strong>Speicherdezentralisierung</strong> - <strong>√úbernahme von Vault zu Kubernetes (etcd)</strong> .  Geheimnisse werden von Vault unkontrollierbar und eignen sich als zentrales Repository f√ºr Geheimnisse.  Es stellt sich heraus, dass die H√§lfte der Geheimnisse in Vault und die andere H√§lfte. </li><li>  <strong>Nur-Kubernetes-L√∂sung</strong> .  Wenn Sie nur √ºber eine Kubernetes-Infrastruktur verf√ºgen, holen Sie sich Vault und denken fast nicht, was dort gespeichert ist, weil  Es enth√§lt nur die Verschl√ºsselungsschl√ºssel, die Sie korrekt verwalten - regelm√§√üig drehen usw. ... Die Geheimnisse selbst befinden sich in Kubernetes, und dies ist praktisch. </li><li>  <strong>Es ist schwierig, Geheimnisse zwischen Clustern auszutauschen</strong> .  F√ºr jeden neuen Cluster m√ºssen Sie erneut beginnen. Das Kopieren von Geheimnissen wie im Fall eines einzelnen Tresors funktioniert m√∂glicherweise nicht. </li></ul><br>  Vorteile von KMS. <br><br><ul><li>  <strong>Native Unterst√ºtzung</strong> in Kubernetes, einschlie√ülich Verstecken beim Anzeigen der Umgebung. </li><li>  <strong>Autorisierung im Verantwortungsbereich von Kubernetes</strong> . </li><li>  <strong>Praktisch keine Vault-Unterst√ºtzung erforderlich</strong> . </li><li>  <strong>Schl√ºsselumdrehung aus der Box</strong> . </li></ul><br><h2>  CI / CD: TeamCity <br></h2><br>  In TeamCity ist alles einfach, da JetBrains ein Plug-In geschrieben hat, das selbst Geheimnisse f√ºr den Zugriff auf das Geheimnis vorschreiben, diese mit TeamCity verschl√ºsseln und es dann irgendwo in der Vorlage als Parameter in Prozent ersetzen kann.  In diesem Moment geht der TeamCity-Agent selbst zu Vault, nimmt das Geheimnis und bringt es als Parameter zum Build. <br><br>  W√§hrend der Bereitstellung werden einige Geheimnisse ben√∂tigt, z. B. Datenbankmigration oder Warnungen in Slack.  AppRole wird f√ºr jedes Projekt gestartet - die Einstellungen enthalten auch ein Geheimnis (Daten f√ºr AppRole), werden jedoch im Nur-Schreib-Modus eingegeben - TeamCity erlaubt das sp√§tere Lesen nicht. <br><br>  TeamCity selbst sorgt daf√ºr, dass sich ein Geheimnis automatisch tarnt, wenn es in die Build-Protokolle eingeht.  Infolgedessen wird das Geheimnis entweder √ºberhaupt nicht durch die Festplatte "geleitet" oder mit TeamCity von der Festplatte gel√∂scht.  Infolgedessen wird die gesamte Sicherheit des Geheimnisses durch TeamCity selbst und das Plugin gut gew√§hrleistet, und zus√§tzliche T√§nze mit einem Tamburin sind nicht erforderlich <br><br><h3>  CI / CD ist nicht TeamCity? <br></h3><br>  Dies sind die wichtigsten Punkte, die zu ber√ºcksichtigen sind, wenn Sie ein anderes System (nicht TeamCity) als CI verwenden. <br><br><ul><li>  Isolation: Beschr√§nken Sie den Umfang eines Geheimnisses auf ein Projekt, ein Team usw. </li><li>  Wer autorisiert den Zugriff auf das Geheimnis. </li><li>  Schlie√üen Sie die M√∂glichkeit aus, das Geheimnis der autorisierenden Partei anzuzeigen. </li><li>  Eine separate Phase des Builds besteht darin, das Geheimnis in Dateien zu importieren. </li><li>  R√§umen Sie nach sich selbst auf. </li></ul><br>  Infolgedessen werden Sie h√∂chstwahrscheinlich etwas schreiben, das dem TeamCity-Plugin f√ºr Ihr CI / Ihre CD sehr √§hnlich ist.  Die autorisierende Partei hier wird h√∂chstwahrscheinlich CI / CD sein, und sie wird entscheiden, ob dieser Build Zugriff auf dieses Geheimnis haben kann und ob sie das Geheimnis selbst basierend auf den Ergebnissen preisgibt oder nicht. <br><br>  Es ist wichtig, nicht zu vergessen, <strong>die Build-Ergebnisse am Ende der Assembly</strong> zu <strong>bereinigen</strong> , wenn sie auf einer Festplatte angeordnet waren, oder sicherzustellen, dass sie sich nur im Speicher befinden. <br><br><h2>  Zertifizierungen <br></h2><br>  Zertifikate haben nichts Besonderes - wir verwenden Vault haupts√§chlich f√ºr deren Speicherung. <br><img src="https://habrastorage.org/webt/ix/ye/4j/ixye4jru2blznsbq2jxmljomqi8.png"><br><br>  Vault verf√ºgt √ºber ein spezielles PKI-Backend f√ºr die Ausstellung von Zertifikaten, in dem Sie eine Zertifizierungsstelle erstellen und neue Zertifikate signieren k√∂nnen.  Wir haben eine einzige interne PKI ... Die Stammzertifizierungsstelle und die Zertifizierungsstelle der zweiten Ebene sind separat vorhanden, und wir verwalten die Zertifizierungsstelle der dritten Ebene bereits √ºber Vault.  Um ausgestellte Zertifikate jeder Ebene zu speichern, einschlie√ülich von externen Zertifizierungsstellen signierter Zertifikate, verwenden wir ein separates Pr√§fix und legen dort fast alle g√ºltigen Zertifikate f√ºr Buchhaltungs- und √úberwachungszwecke ab.  Das Format zum Speichern von Zertifikaten ist propriet√§r und eignet sich zum Speichern eines separaten privaten Schl√ºssels und des Zertifikats selbst. <br><br><h2>  Zusammenfassung <br></h2><br>  <strong>Zu viel manuelle Arbeit</strong> f√ºr den Sicherheitsbeamten, <strong>zu viel Eingabeschwelle f√ºr den Entwickler</strong> und keine integrierten Delegierungstools, obwohl ich wirklich ... <br><br>  Wie man ist  Dann beginnen die Tr√§ume. <br><br><h2>  Ideen: wie man es besser macht <br></h2><br>  Wie kann ich ein paar Kopien eines Geheimnisses loswerden? <br><br><h3>  Lieferung Master-Slave <br></h3><br>  Wir haben ein Hauptgeheimnis und einen speziellen D√§mon, der heruml√§uft, das Geheimnis und seine Metadaten betrachtet, es wo n√∂tig ablegt und sich als Sklavengeheimnis herausstellt.  Auf dem Weg, auf dem der Daemon den Slave gepostet hat, kann nichts von Hand ge√§ndert werden, da der Daemon kommt und das Master-Geheimnis wieder auf den Slave legt. <br><br>  Zuerst wollten wir einen Symlink-Mechanismus erstellen, um einfach anzuzeigen: "Suchen Sie dort nach diesem Geheimnis!", Wie unter Linux.  Es stellte sich heraus, dass es Probleme mit Zugriffsrechten gibt: Es ist nicht bekannt, wie Zugriffsrechte √ºberpr√ºft werden sollen - wie unter Linux oder nicht, mit √ºbergeordneten Pfaden, mit √úberg√§ngen zwischen Mountpunkten.  Es gibt zu viele zweideutige Momente und Chancen, einen Fehler zu machen, deshalb haben wir die Symlinks abgelehnt. <br><br><h3>  Eigentumsberechtigung <br></h3><br>  Das zweite, was wir tun m√∂chten, ist <strong>, den Besitzer f√ºr jedes Geheimnis zu bestimmen</strong> .  Standardm√§√üig geh√∂rt das Geheimnis der Person, die es erstellt hat.  Bei Bedarf k√∂nnen Sie den Verantwortungsbereich auf die Einheit erweitern, indem Sie eine Eigent√ºmergruppe festlegen. <br><br>  Wenn wir delegieren lernen, geben wir dem Eigent√ºmer das Recht auf ein Geheimnis, und er kann mit dem Geheimnis tun, was er will. <br><br><ul><li>  In k8s verbreiten - eine Richtlinie wird generiert, eine Slave-Kopie wird erstellt. </li><li>  Auf dem Server verteilen - Eine Richtlinie wird generiert, eine Slave-Kopie wird erstellt. </li><li>  Verbreitung in CI / CD - ... </li><li>  √úbertragung an einen anderen Eigent√ºmer. </li><li>  Neuen Zugriff gew√§hren, neue ACLs generieren. </li></ul><br>  Jetzt sind wir f√ºr alle Geheimnisse und die Sicherheit verantwortlich, aber wir m√∂chten die Verantwortung auf den Sch√∂pfer √ºbertragen.  <strong>Die Sicherheit wird nicht beeintr√§chtigt</strong> , da die Person, die mit der Bitte um Geheimhaltung zu uns gekommen ist, versteht, dass sie ein Geheimnis sicher aufbewahren muss, und sich ihrer Verantwortung bewusst ist. <br><br>  Da er der Besitzer des Geheimnisses ist, konnte er f√ºr die Master-Slave-Lieferoption ausw√§hlen, wo und in welchem ‚Äã‚ÄãFormat das Geheimnis an ihn geliefert werden soll.  Es stellt sich heraus, dass der Eigent√ºmer alles selbst verwaltet. Es ist nicht erforderlich, Antr√§ge einzureichen. Sie k√∂nnen das erforderliche Pr√§fix selbst verwenden und Geheimnisse selbst erstellen und l√∂schen. <br><br><h3>  Delegierung √ºber ACL-Vorlagen <br></h3><br>  Die Zugriffsrichtlinie f√ºr die Zugriffssteuerungsliste in Vault ist in zwei Teile unterteilt: <br><br><ul><li>  Zugriffssteuerungsliste in der klassischen Ansicht, die den Zugriff auf das Pr√§fix beschreibt, welche Art zu lesen und zu schreiben ist, welche nur zu lesen ist usw. </li><li>  Wenn Sie eine ACL erstellen, k√∂nnen Sie am Ende ein Sternchen schreiben, was "dieses Pr√§fix und alles darunter" bedeutet.  Das Pr√§fix kann als separate Operation zugewiesen werden, die dem Benutzer oder der Gruppe zugewiesen wird, dh mehreren verschiedenen Entit√§ten zugeordnet ist. </li></ul><br>  Derzeit kann nur der Vault-Administrator die ACL √§ndern.  Nachdem Sie Zugriff auf eine solche ACL erhalten haben, k√∂nnen Sie alles, was Sie m√∂chten, vorschreiben, z. B. den <code>path ‚Äú*‚Äù { capabilities = [sudo, ...] }</code> , und vollen Zugriff erhalten.  Dies ist die Essenz von <strong>Biggest Flaw</strong> # 1 - <strong>es ist unm√∂glich zu verbieten, den</strong> <strong>Inhalt der ACL</strong> <strong>zu √§ndern</strong> <strong>.</strong> <br><br>  Wir m√∂chten die ACLs mit einer vorgefertigten Vorlage festlegen, die den Pfad und die Platzhalter enth√§lt, auf denen neue ACLs f√ºr diese Vorlage generiert werden d√ºrfen. <br><br><h4>  Beispiel <br></h4><br>  Unten finden Sie die gelbe Schriftart, den Pfad der fertigen Standard-ACL von Vault und die zul√§ssigen Aktionen auf diesem Pfad.  Wir betrachten es als ACL f√ºr die Berechtigung, eine andere ACL unten zu √§ndern, die in Form einer Vorlage angegeben wird. <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Wir m√∂chten den Zugriff auf / k8s delegieren, wir lassen nur solche Vorlagen zu generieren.  Geben Sie beispielsweise schreibgesch√ºtzten Zugriff auf einen bestimmten Cluster, Namespace oder Dienst, √§ndern Sie jedoch nicht das Feld "Funktionen". <br><img src="https://habrastorage.org/webt/ew/xe/jc/ewxejc20z7xa7dqg-o8yxwaesxk.png"><br><br>  Dar√ºber hinaus m√∂chten wir die Berechtigung erteilen, diese ACLs zu binden und andere Rechte zu erteilen. <br><br>  Wir haben die Vorlage angewendet, um dem Entwickler Rechte zu gew√§hren.  Beim Templating f√ºhrte er den <code>$ vault write policy-mgr/create/k8s-microservice ...</code> .  Als Ergebnis haben wir eine ACL erhalten, die cluster = prod, namespace = ..., service = ... usw. angibt.  Die Rechte wurden automatisch festgelegt, eine Richtlinie wurde mit dem Namen <code>/k8s/some-srv</code> - dies ist nur der ACL-Name, der aus der Vorlage generiert werden kann. <br><img src="https://habrastorage.org/webt/ro/ih/ur/roihurfk7gxhvrv-hjpik6lctxc.png"><br><br>  Infolgedessen weist der Entwickler diese ACL nach unserem Ermessen jedem zu, der dies w√ºnscht, und wird selbst Eigent√ºmer. Er kann sie als Geheimnis verwalten: L√∂schen, Geben und Entfernen von Benutzern und Gruppen.  Jetzt ist die Person selbst f√ºr ihr Pr√§fix verantwortlich: Er verwaltet alle Geheimnisse, generiert ACLs gem√§√ü der Vorlage und kann den gew√ºnschten ACLs zuweisen.  Nat√ºrlich k√∂nnen wir es auch einschr√§nken. <br><br>  Alle Magie funktioniert mit den neuen Vault-Entity- <strong>Plugins</strong> .  Sie sind ein separater Dienst, der dem eingangs erw√§hnten sehr √§hnlich ist und fast genauso funktioniert.  Der einzige wichtige Unterschied ist, dass sie keine Proxies sind.  Plugins werden "auf der Seite" von Vault gestartet und starten ihren Haupt-Vault-Prozess.  Aus diesem Grund werden alle Anforderungen nicht √ºber den Dienst, sondern an Vault gesendet, der selbst bereits mit dem Plug-In interagiert und ihm eine verifizierte und gel√∂schte Anforderung sendet. <br><br>  Informationen zu Plugins, wie sie angeordnet sind und wie sie geschrieben werden, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Vault-Website</a> .  Es ist am besten, sie auf Go zu schreiben, was ganz einfach ist, weil  Es gibt einen Rahmen f√ºr Go.  Vault kommuniziert mit dem Plugin √ºber grpc, startet es als Dienst, aber keine Angst, Sie ber√ºhren es nicht - alles ist bereits im Framework.  Sie schreiben einfach eine mehr oder weniger standardm√§√üige REST-Anwendung, in der Sie Endpunkte angeben, ihnen vorgefertigte Funktionen und Handler mit Logik zuweisen. <br><br>  Haben Sie keine Angst, dass Sie etwas im Hauptgew√∂lbe zerbrechen.  Ein Plugin ist ein separater Dienst.  Selbst wenn Ihr Plugin in Panik geriet und abst√ºrzte, wird es die Arbeit von Vault nicht beeintr√§chtigen.  Vault startet das Plugin einfach neu und arbeitet weiter. <br><br>  Zus√§tzlich gibt es zus√§tzliche Einstellungen f√ºr das Plugin selbst: Es √ºberpr√ºft immer die Hash-Summen, damit niemand die Bin√§rdatei √§ndert.  <strong>Die Sicherheit der Ausf√ºhrung von Plugins ist gew√§hrleistet</strong> . <br><br><h2>  N√ºtzliche Links: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.vaultproject.io</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jovandeginste/hiera-router</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jsok/hiera-vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.owasp.org/index.php/Security_Champions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blog.jetbrains.com/teamcity/2017/09/vault</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/oracle/kubernetes-vault-kms-plugin</a> </li></ul><br><blockquote>  Wir werden √ºber DevOps und Sicherheit, CI / CD, k8s, Puppet und all das in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++</a> (das n√§chstgelegene in St. Petersburg im April) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevOpsConf sprechen</a> .  Teilen Sie Ihre Erfahrungen mit oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schauen Sie sich</a> andere an.  Um nicht zu vergessen, abonnieren Sie den Blog und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter</a> , in denen wir Sie an Fristen erinnern und n√ºtzliche Materialien sammeln. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438740/">https://habr.com/ru/post/de438740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438726/index.html">Y Combinator: So schlie√üen Sie ein Unternehmen</a></li>
<li><a href="../de438730/index.html">HomoLudens: Alles Gute zum Geburtstag, Sid Meyer (+ alle Artikel in russischer Sprache)</a></li>
<li><a href="../de438732/index.html">Amateurfunkmessungen: I2C-Bussignalanalyse</a></li>
<li><a href="../de438734/index.html">Gewirr von Gleichgesinnten</a></li>
<li><a href="../de438736/index.html">DevDay f√ºr Manager: IT verwalten</a></li>
<li><a href="../de438746/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution. Fortsetzung</a></li>
<li><a href="../de438748/index.html">Infrastruktur als Code gewinnen wir auf einer Skala (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../de438750/index.html">Zivilisation der Quellen, 4/5</a></li>
<li><a href="../de438752/index.html">Buchhaltung direkt bei der Bank: Wie man einzelne Unternehmer gl√ºcklich macht</a></li>
<li><a href="../de438754/index.html">Wie wir die Netzwerk√ºberwachung f√ºr 14.000 Objekte durchgef√ºhrt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>