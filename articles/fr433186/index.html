<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèæ ü•Ö üî∂ Il ne suffit pas de compter les polygones pour optimiser les mod√®les 3D üåà üöå üö®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apr√®s avoir compris les bases du processus de rendu de maillage, vous pouvez appliquer diff√©rentes techniques pour optimiser la vitesse de rendu. 

 P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Il ne suffit pas de compter les polygones pour optimiser les mod√®les 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433186/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png" alt="image"></div><br>  Apr√®s avoir compris les bases du processus de rendu de maillage, vous pouvez appliquer diff√©rentes techniques pour optimiser la vitesse de rendu. <br><br><h2>  Pr√©sentation </h2><br>  Combien de polygones puis-je utiliser?  C'est une question tr√®s courante que les artistes posent lors de la cr√©ation de mod√®les pour le rendu en temps r√©el.  Il est difficile de r√©pondre √† cette question, car ce n'est pas seulement une question de nombre. <br><br>  J'ai commenc√© ma carri√®re en tant qu'artiste 3D √† l'√©poque de la premi√®re PlayStation, puis je suis devenu programmeur graphique.  Je voudrais lire cet article avant de commencer √† cr√©er des mod√®les 3D pour les jeux.  Les fondements fondamentaux qui y sont consid√©r√©s sont utiles √† de nombreux artistes.  Bien que la plupart des informations contenues dans cet article n'affecteront pas de mani√®re significative la productivit√© de votre travail quotidien, elles vous donneront une compr√©hension de base de la fa√ßon dont l'unit√© de traitement graphique (GPU) rend les maillages que vous cr√©ez. <br><br>  La vitesse de son rendu d√©pend g√©n√©ralement du nombre de polygones dans le maillage.  Cependant, bien que le nombre de polygones soit souvent en corr√©lation avec la fr√©quence d'images par seconde (FPS), vous pouvez constater que m√™me apr√®s avoir r√©duit le nombre de polygones, le maillage s'affiche toujours lentement.  Mais en comprenant comment les maillages sont rendus en g√©n√©ral, vous pouvez appliquer un ensemble de techniques pour augmenter la vitesse de rendu. <br><a name="habracut"></a><br><h2>  Pr√©sentation des donn√©es polygonales </h2><br>  Pour comprendre comment le GPU dessine des polygones, vous devez d'abord consid√©rer la structure de donn√©es utilis√©e pour d√©crire les polygones.  Un polygone est constitu√© d'un ensemble de points appel√©s sommets et liens.  Les sommets sont souvent stock√©s sous forme de tableaux de valeurs, par exemple, comme la figure 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/cb1/c94/4ffcb1c945c51025a430d752e475b1c3.png"></div><br>  <i>Figure 1. Un tableau de valeurs polygonales simples.</i> <br><br>  Dans ce cas, quatre sommets en trois dimensions (x, y et z) nous donnent 12 valeurs.  Pour cr√©er des polygones, le deuxi√®me tableau de valeurs d√©crit les sommets eux-m√™mes, comme le montre la figure 2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/1c9/3eb/01d1c93eb3645689d0d30de75b0ea524.png"></div><br>  <i>Figure 2. Un tableau de liens vers les sommets.</i> <br><br>  Ces sommets connect√©s ensemble forment deux polygones.  Notez que deux triangles, chacun avec trois angles, peuvent √™tre d√©crits par quatre sommets, car les sommets 1 et 2 sont utilis√©s dans les deux triangles.  Pour que le GPU traite ces donn√©es, il est suppos√© que chaque polygone est triangulaire.  Les GPU s'attendent √† ce que vous travailliez avec des triangles car ils sont con√ßus sp√©cifiquement pour les dessiner.  Si vous devez dessiner des polygones avec un nombre diff√©rent de sommets, vous avez besoin d'une application qui les divise en triangles avant de les rendre au GPU.  Par exemple, si vous cr√©ez un cube de six polygones, chacun ayant quatre c√¥t√©s, ce n'est pas plus efficace que de cr√©er un cube de 12 polygones compos√© de trois c√¥t√©s;  ce sont ces triangles que le GPU dessinera.  Rappelez-vous la r√®gle: vous devez compter non pas des polygones, mais des triangles. <br><br>  Les donn√©es de sommet utilis√©es dans l'exemple pr√©c√©dent sont tridimensionnelles, mais ce n'est pas n√©cessaire.  Deux dimensions peuvent vous suffire, mais vous devez souvent stocker d'autres donn√©es, par exemple des coordonn√©es UV pour les textures et normales pour l'√©clairage. <br><br><h2>  Dessin de polygone </h2><br>  Lors du rendu d'un polygone, le GPU d√©termine d'abord o√π dessiner le polygone.  Pour ce faire, il calcule la position sur l'√©cran o√π les trois sommets doivent √™tre.  Cette op√©ration est appel√©e transformation.  Ces calculs dans le GPU sont effectu√©s par un petit programme appel√© vertex shader. <br><br>  Le vertex shader effectue souvent d'autres types d'op√©rations, telles que le traitement d'animations.  Apr√®s avoir calcul√© les positions des trois sommets du polygone, le GPU calcule quels pixels se trouvent dans ce triangle, puis commence √† remplir ces pixels avec un autre petit programme appel√© ¬´fragment shader¬ª (fragment shader).  Un shader de fragment est g√©n√©ralement ex√©cut√© une fois par pixel.  Cependant, dans certains cas rares, il peut √™tre effectu√© plusieurs fois par pixel, par exemple, pour am√©liorer l'anti-cr√©nelage.  Les shaders de fragments sont souvent appel√©s shaders de pixels, car dans la plupart des cas, les fragments correspondent √† des pixels (voir figure 3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/5e6/4cc/16c5e64cc4daec8ceef7264fce4b8a08.png"></div><br>  <i>Figure 3. Un polygone dessin√© √† l'√©cran.</i> <br><br>  La figure 4 montre la s√©quence d'actions effectu√©es par le GPU lors du rendu du polygone. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/c60/8d2/87cc608d2ac63afc4c818b824bc11fb5.png"></div><br>  <i>Figure 4. L'ordre du GPU rendant le polygone.</i> <br><br>  Si vous divisez le triangle en deux et dessinez les deux triangles (voir figure 5), la proc√©dure correspondra √† la figure 6. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/34a/521/19a34a521bdd7ace482a8a1defb8c926.png"></div><br>  <i>Figure 5. Division du polygone en deux.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/16c/07c/d0c16c07ce793e36aaa40e237ad60d78.png"></div><br>  <i>Figure 6. La proc√©dure du GPU dessinant deux polygones.</i> <br><br>  Dans ce cas, deux fois plus de transformations et de pr√©parations sont n√©cessaires, mais comme le nombre de pixels reste le m√™me, l'op√©ration n'a pas besoin de pixelliser des pixels suppl√©mentaires.  Cela montre que doubler le nombre de polygones ne double pas n√©cessairement le temps de rendu. <br><br><h2>  Utilisation du cache de vertex </h2><br>  Si vous regardez les deux polygones de l'exemple pr√©c√©dent, vous pouvez voir qu'ils ont deux sommets communs.  On peut supposer que ces sommets devront √™tre calcul√©s deux fois, mais un m√©canisme appel√© cache de sommets vous permet de r√©utiliser les r√©sultats du calcul.  Les r√©sultats des calculs de vertex shader pour la r√©utilisation sont stock√©s dans le cache - une petite zone de m√©moire contenant les derniers sommets.  La proc√©dure pour dessiner deux polygones √† l'aide du cache de sommets est illustr√©e √† la figure 7. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/272/d4a/4f0272d4aed10e3805af75688282cdc2.png"></div><br>  <i>Figure 7. Dessin de deux polygones √† l'aide du cache de sommets.</i> <br><br>  Gr√¢ce au cache de sommets, vous pouvez dessiner deux polygones presque aussi rapidement qu'un s'ils ont des sommets communs. <br><br><h2>  Nous traitons les param√®tres des sommets </h2><br>  Pour que le sommet soit r√©utilisable, il doit √™tre inchang√© √† chaque utilisation.  Bien s√ªr, la position doit rester la m√™me, mais les autres param√®tres ne doivent pas non plus changer.  Les param√®tres pass√©s au sommet d√©pendent du moteur utilis√©.  Voici deux param√®tres communs: <br><br><ul><li>  Coordonn√©es de texture </li><li>  Normal </li></ul><br>  Lorsque des UV sont appliqu√©s √† un objet 3D, tout joint cr√©√© signifie que les sommets le long du joint ne peuvent pas √™tre partag√©s.  Par cons√©quent, dans le cas g√©n√©ral, les coutures doivent √™tre √©vit√©es (voir figure 8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8b/75d/854/c8b75d85471cc476ba6e6f8a9425c7a7.png"></div><br>  <i>Figure 8. Texture de suture UV.</i> <br><br>  Pour un √©clairage correct de la surface, chaque sommet stocke g√©n√©ralement une normale - un vecteur dirig√© depuis la surface.  Du fait que tous les polygones ayant un sommet commun sont d√©finis par une normale, leur forme semble lisse.  C'est ce qu'on appelle un ombrage lisse.  Si chaque triangle a ses propres normales, alors les ar√™tes entre les polygones deviennent prononc√©es et la surface semble plate.  Par cons√©quent, cela s'appelle un ombrage plat.  La figure 9 montre deux mailles identiques, l'une avec un ombrage lisse et l'autre avec un ombrage plat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/379/ee3/41f/379ee341f3720b32dba0d4b753c88b98.png"></div><br>  <i>Figure 9. Comparaison de l'ombrage lisse √† plat.</i> <br><br>  Cette g√©om√©trie ombr√©e lisse se compose de 18 triangles et a 16 sommets communs.  L'ombrage plat de 18 triangles n√©cessite 54 (18 x 3) sommets, car aucun des sommets n'est partag√©.  M√™me si deux maillages ont le m√™me nombre de polygones, leur vitesse de rendu sera toujours diff√©rente. <br><br><h2>  Importance de la forme </h2><br>  Les GPU fonctionnent rapidement car ils peuvent effectuer de nombreuses op√©rations en parall√®le.  Les supports marketing des GPU se concentrent souvent sur le nombre de pipelines qui d√©terminent le nombre de GPU pouvant fonctionner en m√™me temps.  Lorsque le GPU dessine le polygone, il donne la t√¢che √† de nombreux pipelines de remplir les carr√©s de pixels.  Il s'agit g√©n√©ralement d'un carr√© de huit par huit pixels.  Le GPU continue de le faire jusqu'√† ce que tous les pixels soient pleins.  √âvidemment, les triangles ne sont pas des carr√©s, donc certains pixels du carr√© seront √† l'int√©rieur du triangle et d'autres √† l'ext√©rieur.  L'√©quipement fonctionne avec tous les pixels d'un carr√©, m√™me ceux qui sont en dehors du triangle.  Apr√®s avoir calcul√© tous les sommets du carr√©, l'√©quipement rejette les pixels √† l'ext√©rieur du triangle. <br><br>  La figure 10 montre un triangle, qui n√©cessite trois carr√©s (tuiles) pour dessiner.  La plupart des pixels calcul√©s (cyan) sont utilis√©s et ceux affich√©s en rouge d√©passent les limites du triangle et seront supprim√©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/c2e/262/74bc2e262019ac7b5f488babc01d7298.png"></div><br>  <i>Figure 10. Trois tuiles pour dessiner un triangle.</i> <br><br>  Le polygone de la figure 11 avec exactement le m√™me nombre de pixels, mais √©tir√©, n√©cessite plus de tuiles √† remplir;  La plupart des r√©sultats de chaque tuile (zone rouge) seront ignor√©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/a9e/286/9d0a9e28607c023f81928ea60c8c386a.png"></div><br>  <i>Figure 11. Remplissage de tuiles dans une image √©tir√©e.</i> <br><br>  Le nombre de pixels rendus n'est qu'un des facteurs.  La forme du polygone est √©galement importante.  Pour augmenter l'efficacit√©, essayez d'√©viter les polygones longs et √©troits et privil√©giez les triangles avec des longueurs de c√¥t√©s approximativement √©gales, dont les angles sont proches de 60 degr√©s.  Les deux surfaces planes de la figure 12 sont triangul√©es de deux mani√®res diff√©rentes, mais elles se ressemblent lors du rendu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/607/5d0/965/6075d0965cddfabc1a639bc58b476bb1.png"></div><br>  <i>Figure 12. Surfaces triangul√©es de deux mani√®res diff√©rentes.</i> <br><br>  Ils ont exactement le m√™me nombre de polygones et de pixels, mais comme la surface de gauche a des polygones plus longs et plus √©troits que la droite, son rendu sera plus lent. <br><br><h2>  Redessiner </h2><br>  Pour dessiner une √©toile √† six pointes, vous pouvez cr√©er un maillage de 10 polygones ou dessiner la m√™me forme √† partir de seulement deux polygones, comme le montre la figure 13. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/86b/dff/55386bdffeaeabbedb9bda0a913f2dda.png"></div><br>  <i>Figure 13. Deux fa√ßons diff√©rentes de rendre une √©toile √† six pointes.</i> <br><br>  Vous pouvez d√©cider qu'il est plus rapide de dessiner deux polygones que 10. Cependant, dans ce cas, c'est tr√®s probablement incorrect, car les pixels au centre de l'√©toile seront dessin√©s deux fois.  Ce ph√©nom√®ne est appel√© overdraw.  En substance, cela signifie que les pixels sont redessin√©s plus d'une fois.  Le redessin se produit naturellement tout au long du processus de rendu.  Par exemple, si un caract√®re est partiellement masqu√© par une colonne, il sera dessin√© dans son int√©gralit√©, malgr√© le fait que la colonne chevauche une partie du caract√®re.  Certains moteurs utilisent des algorithmes complexes pour √©viter de rendre des objets invisibles dans l'image finale, mais c'est une t√¢che difficile.  Le CPU est souvent plus difficile √† comprendre ce qui n'a pas besoin d'√™tre rendu que le GPU pour le dessiner. <br><br>  En tant qu'artiste, vous devez accepter le fait que vous ne pouvez pas vous d√©barrasser de la repeinture, mais c'est une bonne pratique d'enlever les surfaces qui ne sont pas visibles.  Si vous collaborez avec une √©quipe de d√©veloppement, demandez √† ajouter un mode de d√©bogage au moteur de jeu, dans lequel tout devient transparent.  Cela facilitera la recherche de polygones cach√©s pouvant √™tre supprim√©s. <br><br><h2>  Mise en place d'un tiroir au sol </h2><br>  La figure 14 montre une sc√®ne simple: une bo√Æte pos√©e sur le sol.  Le sol se compose de seulement deux triangles et la bo√Æte se compose de 10 triangles.  Le redessin de cette sc√®ne est affich√© en rouge. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/227/ece/c87227ecea93c82e5870a6c68493bd00.png"></div><br>  <i>Figure 14. Un tiroir pos√© au sol.</i> <br><br>  Dans ce cas, le GPU dessinera une partie du sol au sol avec un tiroir, bien qu'il ne soit pas visible.  Si √† la place, nous avions cr√©√© un trou dans le sol sous la bo√Æte, nous aurions re√ßu plus de polygones, mais beaucoup moins de redessins, comme le montre la figure 15. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/202/1e4/045/2021e4045609645f18c056179196bac0.png"></div><br>  <i>Figure 15. Un trou sous le tiroir pour √©viter de refaire le dessin.</i> <br><br>  Dans de tels cas, tout d√©pend de votre choix.  Parfois, cela vaut la peine de r√©duire le nombre de polygones, d'obtenir un nouveau dessin en retour.  Dans d'autres situations, il vaut la peine d'ajouter des polygones pour √©viter de les redessiner.  Autre exemple: les deux figures ci-dessous sont les m√™mes mailles de surface avec des points qui en sortent.  Dans le premier maillage (figure 16), les pointes sont situ√©es en surface. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/436/a65/569436a65cd84150968803a745098129.png"></div><br>  <i>Figure 16. Les embouts sont situ√©s en surface.</i> <br><br>  Dans le deuxi√®me maillage de la figure 17, des trous sont d√©coup√©s dans la surface sous les pointes pour r√©duire la quantit√© de redessin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/815/692/9c2815692a63c60b9b13fb027405484c.png"></div><br>  <i>Figure 17. Les trous sont d√©coup√©s sous les pointes.</i> <br><br>  Dans ce cas, de nombreux polygones ont √©t√© ajout√©s pour d√©couper des trous, dont certains ont une forme √©troite.  De plus, la surface du redessin, dont nous nous sommes d√©barrass√©s, n'est pas tr√®s grande, donc dans ce cas cette technique est inefficace. <br><br>  Imaginez que vous mod√©lisez une maison au sol.  Pour le cr√©er, vous pouvez soit laisser la terre inchang√©e, soit percer un trou dans le sol sous la maison.  Redessiner est plus lorsque le trou n'est pas d√©coup√© sous la maison.  Cependant, le choix d√©pend de la g√©om√©trie et du point de vue √† partir duquel le joueur verra la maison.  Si vous dessinez de la terre sous la base de la maison, cela cr√©era une grande quantit√© de redessin si vous allez √† l'int√©rieur de la maison et regardez vers le bas.  Cependant, la diff√©rence ne sera pas particuli√®rement grande si vous regardez la maison depuis un avion.  Dans ce cas, il est pr√©f√©rable d'avoir un mode de d√©bogage dans le moteur de jeu qui rend les surfaces transparentes afin que vous puissiez voir ce qui est dessin√© sous les surfaces visibles par le joueur. <br><br><h2>  Lorsque les tampons Z ont un conflit Z </h2><br>  Lorsque le GPU dessine deux polygones qui se chevauchent, comment d√©termine-t-il lequel est au-dessus de l'autre?  Les premiers chercheurs en infographie ont pass√© beaucoup de temps √† rechercher ce probl√®me.  Ed Catmell (qui est devenu plus tard pr√©sident de Pixar et Walt Disney Animation Studios) a √©crit un article qui d√©crivait dix approches diff√©rentes de cette t√¢che.  Dans une partie de l'article, il note que la solution √† ce probl√®me sera triviale si les ordinateurs ont suffisamment de m√©moire pour stocker une valeur de profondeur par pixel.  Dans les ann√©es 1970 et 1980, c'√©tait une tr√®s grande quantit√© de m√©moire.  Cependant, aujourd'hui, la plupart des GPU fonctionnent comme ceci: un tel syst√®me est appel√© un Z-buffer. <br><br>  Le Z-buffer (√©galement connu sous le nom de buffer de profondeur) fonctionne comme suit: √† chaque pixel sa valeur de profondeur est associ√©e.  Lorsque l'√©quipement dessine un objet, il calcule la distance s√©parant un pixel de la cam√©ra.  Il v√©rifie ensuite la valeur de profondeur d'un pixel existant.  S'il est plus √©loign√© de l'appareil photo que le nouveau pixel, le nouveau pixel est dessin√©.  Si un pixel existant est plus proche de l'appareil photo qu'un nouveau, le nouveau pixel n'est pas dessin√©.  Cette approche r√©sout de nombreux probl√®mes et fonctionne m√™me si les polygones se croisent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/210/1dd/a47/2101dda47cad028f91a5104cf9a1525c.png"></div><br>  <i>Figure 18. Polygones entrecrois√©s trait√©s par un tampon de profondeur.</i> <br><br>  Cependant, le Z-buffer n'a pas une pr√©cision infinie.  Si deux surfaces sont presque √† la m√™me distance de la cam√©ra, cela confond le GPU et il peut s√©lectionner au hasard l'une des surfaces, comme le montre la figure 19. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/ec2/2e9/e7fec22e99a74b0147b42bc91bf7be33.png"></div><br>  <i>Figure 19. Les surfaces de m√™me profondeur ont des probl√®mes d'affichage.</i> <br><br>  Cela s'appelle Z-Fighting et semble tr√®s bugg√©.  Souvent, les conflits Z s'aggravent √† mesure que la surface de la cam√©ra est √©loign√©e.  Les d√©veloppeurs de moteurs peuvent y incorporer des corrections pour att√©nuer ce probl√®me, mais si un artiste cr√©e des polygones suffisamment proches et se chevauchant, un probl√®me peut toujours survenir.  Un autre exemple est un mur avec une affiche accroch√©e.  L'affiche est situ√©e presque √† la m√™me profondeur de la cam√©ra que le mur derri√®re elle, donc le risque de conflits Z est tr√®s √©lev√©.  La solution consiste √† percer un trou dans le mur sous l'affiche.  Cela r√©duira √©galement la quantit√© de redessin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/4e2/536/da14e2536deb1d23b0e2a7b4de57bc33.png"></div><br>  <i>Figure 20. Exemple de conflit Z de polygones qui se chevauchent.</i> <br><br>  Dans les cas extr√™mes, un conflit Z peut se produire m√™me lorsque les objets se touchent.  La figure 20 montre le tiroir au sol, et comme nous n'avons pas perc√© de trou dans le sol sous le tiroir, le tampon z peut √™tre confondu √† c√¥t√© du bord o√π le sol rencontre le tiroir. <br><br><h2>  Utilisation d'appels de tirage </h2><br>  Les GPU sont devenus extr√™mement rapides - si rapides que les CPU peuvent ne pas les suivre.  √âtant donn√© que les GPU sont essentiellement con√ßus pour effectuer une t√¢che, ils sont beaucoup plus faciles √† travailler rapidement.  Les graphiques sont intrins√®quement li√©s au calcul de plusieurs pixels, vous pouvez donc cr√©er un √©quipement qui calcule plusieurs pixels en parall√®le.  Cependant, le GPU affiche uniquement ce qu'il ordonne pour dessiner le CPU.  Si le CPU ne peut pas ¬´alimenter¬ª rapidement le GPU en donn√©es, la carte vid√©o sera inactive.  Chaque fois que le CPU ordonne au GPU de dessiner quelque chose, cela s'appelle un appel de tirage.  L'appel de dessin le plus simple consiste √† rendre un maillage, y compris un shader et un ensemble de textures. <br><br>  Imaginez un processeur lent qui peut transf√©rer 100 appels de dessin par image et un GPU rapide qui peut dessiner un million de polygones par image.  Dans ce cas, un appel de tirage id√©al peut dessiner 10 000 polygones.  Si vos maillages ne contiennent que 100 polygones, le GPU ne pourra dessiner que 10 000 polygones par image.  Autrement dit, 99% du temps, le GPU sera inactif.  Dans ce cas, on peut facilement augmenter le nombre de polygones dans les mailles sans rien perdre. <br><br>  La composition de l'appel de tirage et son co√ªt d√©pendent fortement de moteurs et d'architectures sp√©cifiques.  Certains moteurs peuvent combiner plusieurs maillages en un seul appel de dessin (effectuer leur traitement par lots, lot), mais tous les maillages devront avoir le m√™me shader, ou peuvent avoir d'autres restrictions.  De nouvelles API comme Vulkan et DirectX 12 sont con√ßues sp√©cifiquement pour r√©soudre ce probl√®me en optimisant la fa√ßon dont le programme communique avec le pilote graphique, augmentant ainsi le nombre d'appels de tirage qui peuvent √™tre transf√©r√©s dans une seule trame. <br><br>  Si votre √©quipe √©crit son propre moteur, demandez aux d√©veloppeurs du moteur quelles sont les limites des appels d'appel.  Si vous utilisez un moteur pr√™t √† l'emploi comme Unreal ou Unity, ex√©cutez des tests de performances pour d√©terminer les limites des capacit√©s du moteur.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez constater que vous pouvez augmenter le nombre de polygones sans provoquer une diminution de la vitesse. </font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'esp√®re que cet article vous servira de bonne introduction pour vous aider √† comprendre les diff√©rents aspects des performances de rendu. </font><font style="vertical-align: inherit;">Dans les GPU de diff√©rents fabricants, tout est mis en ≈ìuvre un peu √† sa mani√®re. </font><font style="vertical-align: inherit;">Il existe de nombreuses r√©servations et conditions sp√©ciales li√©es √† des moteurs et plates-formes mat√©rielles sp√©cifiques. </font><font style="vertical-align: inherit;">Gardez toujours un dialogue ouvert avec les programmeurs de rendu pour utiliser leurs recommandations dans votre projet.</font></font><br><br><h2>  √Ä propos de l'auteur </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eskil Steenberg est un d√©veloppeur ind√©pendant de jeux et d'outils, et il travaille en tant que consultant et sur des projets ind√©pendants. </font><font style="vertical-align: inherit;">Toutes les captures d'√©cran ont √©t√© prises dans des projets actifs √† l'aide d'outils d√©velopp√©s par Esquil. </font><font style="vertical-align: inherit;">Vous pouvez en savoir plus sur son travail sur le site Web de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel Solaar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et sur son compte Twitter @quelsolaar.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433186/">https://habr.com/ru/post/fr433186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433174/index.html">Tous les correctifs ne sont pas √©galement utiles.</a></li>
<li><a href="../fr433178/index.html">Comment nous avons restaur√© un fichier .wav endommag√©</a></li>
<li><a href="../fr433180/index.html">R√©solution des probl√®mes de type de donn√©es dans Ruby ou Fiabilisation des donn√©es</a></li>
<li><a href="../fr433182/index.html">Est-il possible de former un agent pour la n√©gociation en bourse avec des renforts? Impl√©mentation du langage R</a></li>
<li><a href="../fr433184/index.html">ASP.NET Core 2.2 est sorti. Quoi de neuf (2 sur 3)</a></li>
<li><a href="../fr433188/index.html">Un projet de loi sur le travail autonome de Runet a √©t√© soumis √† la Douma d'√âtat</a></li>
<li><a href="../fr433192/index.html">Kubernetes: une solution de projet personnel incroyablement abordable</a></li>
<li><a href="../fr433194/index.html">Veilleuse programm√©e</a></li>
<li><a href="../fr433196/index.html">Guide cadeaux du Nouvel An</a></li>
<li><a href="../fr433198/index.html">10 dollars pour l'h√©bergement: il y a 20 ans et aujourd'hui</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>