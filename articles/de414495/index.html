<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÆ üßõüèº üßòüèæ toString: Gro√üartig und schrecklich üßõüèø üìï ü§¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die toString- Funktion in JavaScript ist wahrscheinlich die "impliziteste", die sowohl unter js-Entwicklern selbst als auch unter externen Beobachtern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>toString: Gro√üartig und schrecklich</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414495/"><p><img src="https://habrastorage.org/webt/on/px/4c/onpx4cu-vxqkdask5tvj3so9va4.jpeg" alt="Bild"></p><br><p>  Die <em>toString-</em> Funktion in <strong>JavaScript ist</strong> wahrscheinlich die "impliziteste", die sowohl unter js-Entwicklern selbst als auch unter externen Beobachtern diskutiert wird.  Sie ist die Ursache f√ºr zahlreiche Witze und Meme √ºber viele verd√§chtige arithmetische Operationen, Transformationen, die in ein Stupor <em>[Objekt Objekt]</em> eingehen.  Es wird vielleicht nur zugestanden, um bei der Arbeit mit float64 zu √ºberraschen. </p><br><p>  Interessante F√§lle, die ich beobachten, nutzen oder √ºberwinden musste, motivierten mich, eine echte Nachbesprechung zu schreiben.  Wir werden √ºber die Sprachspezifikation galoppieren und die Beispiele verwenden, um die nicht offensichtlichen Merkmale von <em>toString</em> zu analysieren. </p><br><p> Wenn Sie n√ºtzliche und ausreichende Anleitungen erwarten, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jenes</a> Material besser f√ºr Sie geeignet.  Wenn Ihre Neugier immer noch √ºber Pragmatismus herrscht, dann bitte unter Katze. </p><a name="habracut"></a><br><h3 id="vse-chto-nuzhno-znat">  Alles was Sie wissen m√ºssen </h3><br><p>  Die Funktion <em>toString</em> ist eine Eigenschaft des <em>Objektprototypobjekts</em> , in einfachen Worten seine Methode.  Es wird f√ºr die Zeichenfolgenkonvertierung eines Objekts verwendet und sollte auf gute Weise einen primitiven Wert zur√ºckgeben.  Die Prototypobjekte haben auch ihre Implementierungen: <em>Funktion, Array, Zeichenfolge, Boolescher Wert, Zahl, Symbol, Datum, RegExp, Fehler</em> .  Wenn Sie Ihr Prototypobjekt (Klasse) implementieren, ist <em>toString</em> eine gute Form daf√ºr. </p><br><p>  <em>JavaScript</em> ist eine Sprache mit einem schwachen Typsystem: Dies bedeutet, dass wir verschiedene Typen mischen k√∂nnen und viele Operationen implizit ausf√ºhren.  Bei Konvertierungen wird <em>toString</em> mit <em>valueOf</em> gepaart, um das Objekt auf das f√ºr die Operation erforderliche <em>Grundelement</em> zu reduzieren.  Beispielsweise wird der Additionsoperator zur Verkettung, wenn sich unter den Operatoren mindestens eine Zeile befindet.  Einige Standardfunktionen der Sprache vor ihrer Arbeit f√ºhren zu einem Argument f√ºr die Zeichenfolge: <em>parseInt, decodeURI, JSON.parse, btoa</em> usw. </p><br><p>  √úber implizites Casting wurde viel gesagt und verspottet.  Wir werden Implementierungen von <em>toString von</em> Prototypenobjekten in Schl√ºsselsprache in Betracht ziehen. </p><br><h3 id="objectprototypetostring">  Object.prototype.toString </h3><br><p>  Wenn wir uns dem entsprechenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt der</a> Spezifikation zuwenden, stellen wir fest, dass die Hauptaufgabe des Standard- <em>toString darin</em> besteht, das sogenannte <strong>Tag</strong> dazu zu bringen, sich mit der resultierenden Zeichenfolge zu verketten: </p><br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"[object "</span></span> + tag + <span class="hljs-string"><span class="hljs-string">"]"</span></span></code> </pre> <br><p>  Daf√ºr: </p><br><ol><li>  Ein Aufruf des internen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>toStringTag-</em></a> Symbols (oder der Pseudo-Eigenschaft <em>[[Class]]</em> in der alten Edition) erfolgt: Es sind viele Prototypobjekte integriert ( <em>Map, Math, JSON</em> und andere). </li><li>  Wenn eine Zeichenfolge fehlt oder nicht, werden eine Reihe anderer interner Pseudo-Eigenschaften und -Methoden aufgelistet, die den Typ des Objekts signalisieren: <em>[[Aufruf]]</em> f√ºr <em>Funktion</em> , <em>[[DateValue]]</em> f√ºr <em>Datum</em> usw. </li><li>  Nun, wenn √ºberhaupt nichts, dann ist das <em>Tag</em> <em>"Objekt"</em> . </li></ol><br><p>  Diejenigen, die von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflexion</a> betroffen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> werden sofort die M√∂glichkeit bemerken, den Typ eines Objekts mit einer einfachen Operation zu erhalten (nicht von der Spezifikation empfohlen, aber m√∂glich): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getObjT = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(obj).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre> <br><p>  Die Besonderheit der Standardeinstellung f√ºr <em>String</em> ist, dass sie mit jedem <em>dieser</em> Werte funktioniert.  Wenn es sich um ein Grundelement handelt, wird es in das Objekt umgewandelt ( <em>null</em> und <em>undefiniert</em> werden separat gepr√ºft).  Kein <em>TypeError</em> : </p><br><pre> <code class="javascript hljs">[<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}].map(getObjT); &gt; [<span class="hljs-string"><span class="hljs-string">"Number"</span></span>, <span class="hljs-string"><span class="hljs-string">"Null"</span></span>, <span class="hljs-string"><span class="hljs-string">"Function"</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>, <span class="hljs-string"><span class="hljs-string">"GeneratorFunction"</span></span>]</code> </pre> <br><p>  Wie kann das n√ºtzlich sein?  Zum Beispiel bei der Entwicklung von Tools f√ºr die dynamische Code-Analyse.  Mit einem spontanen Pool von Variablen, die w√§hrend der Arbeit der Anwendung verwendet werden, k√∂nnen Sie zur Laufzeit n√ºtzliche homogene Statistiken erfassen. </p><br><p>  Dieser Ansatz hat einen Hauptnachteil: Benutzertypen.  Es ist nicht schwer zu erraten, dass wir f√ºr ihre Instanzen nur <em>"Objekt" bekommen</em> . </p><br><h3 id="kastomnyy-symboltostringtag-i-functionname">  Benutzerdefiniertes Symbol.toStringTag und Funktionsname </h3><br><p>  OOP in JavaScript basiert auf Prototypen und nicht auf Klassen (wie in Java), und wir haben keine vorgefertigte <em>getClass ()</em> -Methode.  Eine explizite Definition des <em>toStringTag-</em> Zeichens f√ºr einen Benutzertyp hilft bei der L√∂sung des Problems: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Cat'</span></span>; } }</code> </pre> <br><p>  oder im Prototypenstil: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} Dog.prototype[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] = <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>;</code> </pre> <br><p>  Es gibt eine alternative L√∂sung √ºber die schreibgesch√ºtzte Eigenschaft <em>Function.name</em> , die noch nicht Teil der Spezifikation ist, aber von den meisten Browsern unterst√ºtzt wird.  Jede Instanz des Prototypobjekts / der Prototypklasse verf√ºgt √ºber eine Verkn√ºpfung zu der Konstruktorfunktion, mit der sie erstellt wurde.  So k√∂nnen wir den Namen des Typs herausfinden: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Cat'</span></span></code> </pre> <br><p>  oder im Prototypenstil: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog).constructor.name &lt; <span class="hljs-string"><span class="hljs-string">'Dog'</span></span></code> </pre> <br><p>  Nat√ºrlich funktioniert diese L√∂sung nicht f√ºr Objekte, die mit einer anonymen Funktion ( <em>"anonym"</em> ) oder <em>Object.create (null) erstellt wurden</em> , oder f√ºr <em>Grundelemente</em> ohne Wrapper-Objekt ( <em>null, undefiniert</em> ). </p><br><p>  F√ºr eine zuverl√§ssige Manipulation von Variablentypen lohnt es sich daher, bekannte Techniken zu kombinieren, die haupts√§chlich auf der jeweiligen Aufgabe basieren.  In den allermeisten F√§llen reichen <em>Typ</em> und <em>Instanz</em> aus. </p><br><h3 id="functionprototypetostring">  Function.prototype.toString </h3><br><p>  Wir waren ein wenig abgelenkt, aber als Ergebnis kamen wir zu Funktionen, die ihren eigenen interessanten <em>Charakter haben</em> .  Schauen Sie sich zun√§chst den folgenden Code an: </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'('</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee.toString() + <span class="hljs-string"><span class="hljs-string">')()'</span></span>); })()</code> </pre> <br><p>  Viele vermuteten wahrscheinlich, dass dies ein Beispiel f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quine ist</a> .  Wenn Sie ein Skript mit solchen Inhalten in den Hauptteil der Seite laden, wird eine genaue Kopie des Quellcodes in der Konsole angezeigt.  Dies ist auf den Aufruf von <em>String</em> aus der Funktion <em>argument.callee zur√ºckzuf√ºhren</em> . </p><br><p>  Die verwendete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung des</a> Prototypobjekts <em>toString of the</em> <em>Function</em> gibt eine Zeichenfolgendarstellung des Quellcodes der Funktion zur√ºck, wobei die in der Definition verwendete Syntax <em>beibehalten wird</em> : <em>FunctionDeclaration, FunctionExpression, ClassDeclaration, ArrowFunction</em> usw. </p><br><p>  Zum Beispiel haben wir eine Pfeilfunktion: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bind = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(ctx, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre> <br><p>  <em>Wenn</em> Sie <em>bind.toString () aufrufen</em> , erhalten Sie eine Zeichenfolgendarstellung von <em>ArrowFunction</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"(f, ctx) =&gt; function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  Der Aufruf von <em>toString</em> von einer umschlossenen Funktion ist bereits eine Zeichenfolgendarstellung von <em>FunctionExpression</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"function() { return f.apply(ctx, arguments); }"</span></span></code> </pre> <br><p>  Dieses <em>Bindungsbeispiel</em> ist kein Zufall, da wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte L√∂sung</a> mit der Kontextbindung <em>Function.prototype.bind</em> haben. In Bezug auf native <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gebundene Funktionen</a> gibt es eine Funktion von <em>Function.prototype.toString,</em> die mit ihnen arbeitet.  Abh√§ngig von der Implementierung kann eine Darstellung sowohl der umschlossenen Funktion selbst als auch der <em>Zielfunktion</em> erhalten werden.  V8 und SpiderMonkey neueste Versionen von Chrome und ff: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } getx.bind({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).toString() &lt; <span class="hljs-string"><span class="hljs-string">"function () { [native code] }"</span></span></code> </pre> <br><p>  Daher ist bei nativ dekorierten Merkmalen Vorsicht geboten. </p><br><h3 id="praktika-ispolzovaniya-ftostring">  √úben Sie mit f.toString </h3><br><p>  Es gibt viele Optionen f√ºr die Verwendung des betreffenden <em>toString</em> , die jedoch nur als Metaprogrammierungswerkzeug oder Debugging dringend erforderlich sind.  Eine typische Anwendung, die in der Gesch√§ftslogik √§hnlich ist, f√ºhrt fr√ºher oder sp√§ter zu einem nicht unterst√ºtzten defekten Trog. </p><br><p>  Das Einfachste, was mir in den Sinn kommt, ist die <strong>Bestimmung der L√§nge der Funktion</strong> : </p><br><pre> <code class="javascript hljs">f.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Die Position und die Anzahl der Leerzeichen des <em>toString-</em> Ergebnisses ergibt sich aus der Spezifikation f√ºr den Kauf einer bestimmten Implementierung. Aus Gr√ºnden der Sauberkeit entfernen wir daher zuerst den √úberschuss, was zu einer allgemeinen Ansicht f√ºhrt.  √úbrigens hatte die Funktion in √§lteren Versionen der Gecko-Engine einen speziellen <em>Einr√ºckungsparameter</em> , der beim Formatieren von <em>Einr√ºckungen</em> hilft. </p><br><p>  Die <strong>Definition von Funktionsparameternamen</strong> f√§llt sofort ein, was sich zum Nachdenken als n√ºtzlich erweisen kann: </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/^function(?:\s+\w+)?\s*\(([^\)]+)/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].split(<span class="hljs-regexp"><span class="hljs-regexp">/\s*,\s*/</span></span>)</code> </pre> <br><p>  Diese Kniel√∂sung eignet sich f√ºr die Syntax <em>FunctionDeclaration</em> und <em>FunctionExpression</em> .  Wenn Sie einen detaillierteren und genaueren ben√∂tigen, empfehle ich Ihnen, nach Beispielen f√ºr den Quellcode Ihres bevorzugten Frameworks zu suchen, das wahrscheinlich eine Art Abh√§ngigkeitsinjektion unter der Haube hat, basierend auf den Namen der deklarierten Parameter. </p><br><p>  Eine gef√§hrliche und interessante Option zum <strong>√úberschreiben einer Funktion</strong> durch <em>Auswertung</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prod = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(sum.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\+(?=\s*(?:a|b))/gm</span></span>, <span class="hljs-string"><span class="hljs-string">'*'</span></span>)); sum(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">15</span></span> prod(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">50</span></span></code> </pre> <br><p>  Da wir die Struktur der urspr√ºnglichen Funktion kennen, haben wir eine neue erstellt, indem wir den in seinem K√∂rper verwendeten Additionsoperator durch Argumente mit Multiplikation ersetzt haben.  Im Fall von Software-generiertem Code oder dem Fehlen einer Funktionserweiterungsschnittstelle kann dies magisch n√ºtzlich sein.  Wenn Sie beispielsweise ein mathematisches Modell untersuchen, eine geeignete Funktion ausw√§hlen und mit Operatoren und Koeffizienten spielen. </p><br><p>  Eine praktischere Anwendung ist das <strong>Zusammenstellen und Verteilen von Vorlagen</strong> .  Viele Template-Engine-Implementierungen kompilieren den Quellcode einer Vorlage und stellen eine Datenfunktion bereit, die bereits den endg√ºltigen HTML-Code (oder einen anderen) bildet.  Das Folgende ist ein Beispiel f√ºr die Funktion <a href="">_.template</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloJst = <span class="hljs-string"><span class="hljs-string">"Hello, &lt;%= user %&gt;"</span></span> _.template(helloJst)({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Was aber, wenn das Kompilieren der Vorlage Hardwareressourcen erfordert oder der Client sehr d√ºnn ist?  In diesem Fall k√∂nnen wir die Vorlage auf der Serverseite kompilieren und den Clients nicht den Vorlagentext, sondern eine Zeichenfolgendarstellung der fertigen Funktion geben.  Dar√ºber hinaus m√ºssen Sie die Vorlagenbibliothek nicht auf den Client laden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloStr = _.template(helloJst).toString() helloStr &lt; <span class="hljs-string"><span class="hljs-string">"function(obj) { obj || (obj = {}); var __t, __p = ''; with (obj) { __p += 'Hello, ' + ((__t = ( user )) == null ? '' : __t); } return __p }"</span></span></code> </pre> <br><p>  Jetzt m√ºssen wir diesen Code vor der Verwendung auf dem Client ausf√ºhren.  Bei der Kompilierung gab es aufgrund der <em>FunctionExpression-</em> Syntax keinen <em>SyntaxError</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(helloStr.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^function\(obj\)/</span></span>, <span class="hljs-string"><span class="hljs-string">'obj=&gt;'</span></span>));</code> </pre> <br><p>  oder so: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloFn = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`const f = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${helloStr}</span></span></span><span class="hljs-string">;f`</span></span>);</code> </pre> <br><p>  Oder wie du mehr magst.  Auf jeden Fall: </p><br><pre> <code class="javascript hljs">helloFn({ <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span> }) &lt; <span class="hljs-string"><span class="hljs-string">"Hello, admin"</span></span></code> </pre> <br><p>  Dies ist m√∂glicherweise nicht die beste Vorgehensweise, um Vorlagen auf der Serverseite zu kompilieren und weiter an Clients zu verteilen.  Nur ein Beispiel mit einer Reihe von <em>Function.prototype.toString</em> und <em>eval</em> . </p><br><p>  Schlie√ülich die alte Aufgabe <strong>, einen Funktionsnamen</strong> (bevor die Eigenschaft <em>Function.name</em> angezeigt wird) √ºber <em>toString zu definieren</em> : </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Dies funktioniert nat√ºrlich gut mit der <em>FunctionDeclaration-</em> Syntax.  Eine intelligentere L√∂sung erfordert gerissene regul√§re Ausdr√ºcke oder Mustervergleiche. </p><br><p>  Das Internet ist voll von interessanten L√∂sungen, die auf <em>Function.prototype.toString</em> basieren. Fragen Sie einfach.  Teilen Sie Ihre Erfahrungen in den Kommentaren: sehr interessant. </p><br><h3 id="arrayprototypetostring">  Array.prototype.toString </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Implementierung des</a> <em>toString</em> eines <em>Array-</em> Prototypobjekts ist generisch und kann f√ºr jedes Objekt aufgerufen werden.  Wenn das Objekt √ºber eine <em>Join-</em> Methode verf√ºgt, ist das Ergebnis von <em>toString</em> sein Aufruf, andernfalls <em>Object.prototype.toString</em> . </p><br><p>  <em>Array</em> verf√ºgt logischerweise √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Join-Methode</a> , die die Zeichenfolgendarstellung aller seiner Elemente √ºber das als Parameter √ºbergebene <em>Trennzeichen</em> verkettet (der Standardwert ist ein Komma). </p><br><p>  Angenommen, wir m√ºssen eine Funktion schreiben, die eine Liste ihrer Argumente serialisiert.  Wenn alle Parameter <em>Grundelemente</em> sind, k√∂nnen wir in vielen F√§llen auf <em>JSON.stringify verzichten</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seria</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>).toString(); }</code> </pre> <br><p>  oder so: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seria = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.toString();</code> </pre> <br><p>  Denken Sie daran, dass die Zeichenfolge '10' und die Nummer 10 gleich serialisiert werden.  Bei dem Problem des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√ºrzesten Memoizers</a> in einer Phase wurde diese L√∂sung verwendet. </p><br><p>  Die native Verkn√ºpfung von Array-Elementen durchl√§uft einen arithmetischen Zyklus von 0 bis <em>L√§nge</em> und filtert nicht nach fehlenden Elementen ( <em>null</em> und <em>undefiniert</em> ).  Stattdessen tritt eine Verkettung mit dem <em>Trennzeichen auf</em> .  Dies f√ºhrt zu Folgendem: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); ar.toString() &lt; <span class="hljs-string"><span class="hljs-string">",,,...,,,"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1000 times</span></span></code> </pre> <br><p>  Wenn Sie daher aus dem einen oder anderen Grund dem Array ein Element mit einem gro√üen Index hinzuf√ºgen (z. B. eine generierte nat√ºrliche ID), verbinden Sie sich in keinem Fall und f√ºhren Sie dementsprechend nicht ohne vorherige Vorbereitung zu einer Zeichenfolge.  Andernfalls kann dies Konsequenzen haben: <em>Ung√ºltige Zeichenfolgenl√§nge, zu wenig Speicher</em> oder nur ein baumelndes Skript.  Verwenden Sie die Funktionen des Objekts <em>Objektwerte</em> und -schl√ºssel, um nur die eigenen aufgez√§hlten Eigenschaften des Objekts zu durchlaufen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> k = []; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">20</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; k[<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1,2,3"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(k).toString() &lt; <span class="hljs-string"><span class="hljs-string">"1024,1048576,1073741824"</span></span></code> </pre> <br><p>  Es ist jedoch viel besser, eine solche Behandlung des Arrays zu vermeiden: H√∂chstwahrscheinlich w√ºrde ein einfaches Schl√ºsselwertobjekt als Speicher f√ºr Sie geeignet sein. </p><br><p>  Die gleiche Gefahr besteht <em>√ºbrigens</em> bei der Serialisierung √ºber <em>JSON.stringify</em> .  Nur schwerwiegender, da leere und nicht unterst√ºtzte Elemente bereits als <em>"null" dargestellt werden</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(ar); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">,</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">null</span></span></span></span><span class="xml"><span class="hljs-tag">]" // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1000</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">times</span></span></span></span></span></span></code> </pre> <br><p>  Abschlie√üend m√∂chte ich Sie daran erinnern, dass Sie Ihre <em>Join-</em> Methode f√ºr den Benutzertyp definieren und <em>Array.prototype.toString.call</em> als alternative <em>Umwandlung</em> zum String aufrufen <em>k√∂nnen</em> , aber ich bezweifle, dass dies praktisch sinnvoll ist. </p><br><h3 id="numberprototypetostring-i-parseint">  Number.prototype.toString und parseInt </h3><br><p>  Eine meiner Lieblingsaufgaben f√ºr js-Tests ist Was gibt den n√§chsten <em>parseInt-</em> Aufruf zur√ºck? </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Das erste, was <em>parseInt</em> tut, ist implizit ein Argument in einen String <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>umzuwandeln</em></a> , indem die abstrakte Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>ToString aufgerufen wird</em></a> , die je nach Argumenttyp den gew√ºnschten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Umwandlungszweig</em></a> ausf√ºhrt.  F√ºr die Typennummer wird Folgendes ausgef√ºhrt: </p><br><ol><li>  Wenn der Wert <em>NaN, 0</em> oder <em>Infinity ist</em> , geben Sie die entsprechende Zeichenfolge zur√ºck. </li><li>  Andernfalls gibt der Algorithmus den f√ºr den Menschen bequemsten Datensatz der Zahl zur√ºck: in Dezimal- oder Exponentialform. </li></ol><br><p>  Ich werde den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmus zur</a> Bestimmung der bevorzugten Form hier nicht duplizieren, sondern nur Folgendes beachten: Wenn die Anzahl der Stellen in einer Dezimalschreibweise <strong>21</strong> √ºberschreitet, wird eine Exponentialform ausgew√§hlt.  Und das bedeutet, dass <em>parseInt</em> in unserem Fall nicht mit "100 ... 000" funktioniert, sondern mit "1e30".  Daher wird die Antwort √ºberhaupt nicht erwartet 2 ^ 30.  Wer kennt die Natur dieser magischen Nummer 21 - schreiben Sie! </p><br><p>  Als n√§chstes untersucht <em>parseInt</em> die Basis des verwendeten <em>Radix-</em> Zahlensystems (standardm√§√üig 10, wir haben 2) und √ºberpr√ºft die Zeichen der empfangenen Zeichenfolge auf Kompatibilit√§t damit.  Nachdem er 'e' getroffen hat, schneidet er den gesamten Schwanz ab und l√§sst nur "1" √ºbrig.  Das Ergebnis ist eine Ganzzahl, die durch Konvertieren vom System mit der Radixbasis in eine Dezimalzahl erhalten wird - in unserem Fall ist es 1. </p><br><p>  Umgekehrte Vorgehensweise: </p><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">30</span></span>).toString(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Hier wird die Funktion <em>toString</em> vom <em>Number-</em> Prototypobjekt aufgerufen, das denselben Algorithmus verwendet, um die <em>Zahl</em> in eine Zeichenfolge umzuwandeln.  Es hat auch den optionalen <em>Radix-</em> Parameter.  Nur es wird ein <em>RangeError</em> f√ºr einen ung√ºltigen Wert <em>ausgel√∂st</em> (es muss eine Ganzzahl von 2 bis einschlie√ülich 36 sein), w√§hrend <em>parseInt</em> <em>NaN</em> zur√ºckgibt. </p><br><p>  Beachten Sie die Obergrenze des Zahlensystems, wenn Sie eine exotische Hash-Funktion implementieren m√∂chten: Dieser <em>toString</em> funktioniert m√∂glicherweise nicht f√ºr Sie. </p><br><p>  Die Aufgabe, f√ºr einen Moment abzulenken: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'3113'</span></span>.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).map(<span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>)</code> </pre> <br><p>  Was wird zur√ºckgegeben und wie kann das Problem behoben werden? </p><br><h3 id="obdelennoe-vnimaniem">  Der Aufmerksamkeit beraubt </h3><br><p>  Wir haben <em>toString</em> keineswegs alle nativen Prototypobjekte untersucht.  Zum Teil, weil ich pers√∂nlich keine Probleme mit ihnen haben musste und es nicht viel Interessantes an ihnen gibt.  Au√üerdem haben wir die Funktion <em>toLocaleString</em> nicht ber√ºhrt, da es sch√∂n w√§re, separat dar√ºber zu sprechen.  Wenn ich etwas vergeblich getan habe, das der Aufmerksamkeit beraubt, aus den Augen verloren oder missverstanden wurde - schreiben Sie unbedingt! </p><br><h3 id="prizyv-k-bezdeystviyu">  Aufruf zur Unt√§tigkeit </h3><br><p>  Die Beispiele, die ich angef√ºhrt habe, sind keineswegs fertige Rezepte - nur Denkanst√∂√üe.  Au√üerdem finde ich es sinnlos und ein wenig dumm, dies in technischen Interviews zu diskutieren: Daf√ºr gibt es ewige Themen wie Schlie√üungen, Beitritt, eine Ereignisschleife, Modul- / Fassaden- / Mediatormuster und ‚Äûnat√ºrlich‚Äú Fragen zu [dem verwendeten Framework]. </p><br><p>  Dieser Artikel hat sich als Durcheinander herausgestellt, und ich hoffe, Sie haben etwas Interessantes f√ºr sich gefunden.  PS Die JavaScript-Sprache - Erstaunlich! </p><br><h3 id="bonus">  Bonus </h3><br><p>  Bei der Vorbereitung dieses Materials f√ºr die Ver√∂ffentlichung habe ich Google Translate verwendet.  Und ganz zuf√§llig habe ich einen unterhaltsamen Effekt entdeckt.  Wenn Sie eine √úbersetzung vom Russischen ins Englische ausw√§hlen, "toString" eingeben und mit der R√ºcktaste l√∂schen, werden wir Folgendes beobachten: </p><br><p><img src="https://habrastorage.org/webt/op/yl/g3/opylg3burl5dlqv5ojibfeis0c4.gif" alt="Bonus"></p><br><p>  So eine Ironie!  Ich glaube, ich bin weit vom ersten entfernt, aber nur f√ºr den Fall, dass ich ihnen einen Screenshot mit einem Wiedergabeskript geschickt habe.  Es sieht aus wie ein harmloses Selbst-XSS, deshalb teile ich es. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414495/">https://habr.com/ru/post/de414495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414483/index.html">Geben Sie Safe SQL in Kotlin ein</a></li>
<li><a href="../de414485/index.html">GNMT, episches Versagen oder Feinheiten der maschinellen √úbersetzung</a></li>
<li><a href="../de414487/index.html">Ein seltener Vertreter des Brute-Force-Typs: die Geschichte eines Angriffs</a></li>
<li><a href="../de414489/index.html">Die USA planen, das Problem der Weltraumm√ºll ernsthaft anzugehen</a></li>
<li><a href="../de414493/index.html">So schreiben Sie in 5 Minuten einen intelligenten Vertrag f√ºr ICO</a></li>
<li><a href="../de414497/index.html">Consulo UI API von der Idee bis zum Prototyp</a></li>
<li><a href="../de414499/index.html">Bericht des Club of Rome 2018, Kapitel 1.1.3: ‚ÄûEine leere Welt gegen einen vollen Frieden‚Äú</a></li>
<li><a href="../de414501/index.html">Bericht des Club of Rome 2018, Kapitel 3.11: ‚ÄûReformen des Finanzsektors‚Äú</a></li>
<li><a href="../de414503/index.html">Intel NUC Hades Canyon mit AMD Vega Graphics - VR oder nicht VR?</a></li>
<li><a href="../de414505/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 2: ‚ÄûKontrolle von Hackerangriffen‚Äú, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>