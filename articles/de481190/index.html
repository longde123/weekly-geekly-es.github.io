<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔙 🙅🏾 👨🏾‍🤝‍👨🏽 Top 10 Bugs in C ++ Projekten für 2019 🙌🏿 👨🏽‍💼 🤱🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein weiteres Jahr neigt sich dem Ende zu, also ist es Zeit, Kaffee zu kochen und die Fehlerberichte für das vergangene Jahr erneut zu lesen. Dies wird...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 Bugs in C ++ Projekten für 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481190/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/cc3/539/7a8cc3539721631b68ce36c56f5471bf.png" alt="Bild 7"></div><br>  Ein weiteres Jahr neigt sich dem Ende zu, also ist es Zeit, Kaffee zu kochen und die Fehlerberichte für das vergangene Jahr erneut zu lesen.  Dies wird natürlich viel Zeit in Anspruch nehmen, daher wurde dieser Artikel verfasst.  Ich schlage vor, uns die interessantesten dunklen Stellen der Projekte anzuschauen, die wir 2019 in Projekten getroffen haben, die in C und C ++ geschrieben wurden. <br><a name="habracut"></a><br><h2>  Zehnter Platz: "Was ist unser Betriebssystem?" </h2><br>  <a href="https://www.viva64.com/ru/w/v1040/">V1040</a> Mögliche Tippfehler in der Schreibweise eines vordefinierten <a href="https://www.viva64.com/ru/w/v1040/">Makronamens</a> .  Das Makro '__MINGW32_' ähnelt dem Makro '__MINGW32__'.  winapi.h 4112 <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(__UNICODE_STRING_DEFINED) &amp;&amp; defined(__MINGW32_) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __UNICODE_STRING_DEFINED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Hier wurde ein Tippfehler im <i>Makronamen __MINGW32</i> _ gemacht (MINGW32 deklariert __MINGW32__).  An anderen Stellen des Projekts wird die Verifizierung korrekt geschrieben: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/ad7/425/ed5ad7425145902765d728287ab5f2fa.png" alt="Bild 3"></div><br><br>  Dies war übrigens nicht nur der erste Fehler im Artikel „ <a href="https://www.viva64.com/ru/b/0658/">CMake: Der Fall, dass das Projekt für die Qualität seines Codes unverzeihlich ist</a> “, sondern im Allgemeinen der erste echte Fehler, der von der V1040-Diagnose in einem echten offenen Projekt (19. August 2019) gefunden wurde. <br><br><h2>  Neunter Platz: "Wer ist der Erste?" </h2><br>  <a href="https://www.viva64.com/ru/w/v502/">V502</a> Vielleicht arbeitet der Operator '?:' Anders als erwartet.  Der Operator '?:' Hat eine niedrigere Priorität als der Operator '=='.  mir_parser.cpp 884 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Opcode : uint8 { kOpUndef, .... OP_intrinsiccall, OP_intrinsiccallassigned, .... kOpLast, }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> MIRParser::ParseStmtIntrinsiccall(StmtNodePtr &amp;stmt, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isAssigned) { Opcode o = !isAssigned ? (....) : (....); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *intrnCallNode = mod.CurFuncCodeMemPool()-&gt;New&lt;IntrinsiccallNode&gt;(....); lexer.NextToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == !isAssigned ? OP_intrinsiccall : OP_intrinsiccallassigned) { intrnCallNode-&gt;SetIntrinsic(GetIntrinsicID(lexer.GetTokenKind())); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { intrnCallNode-&gt;SetIntrinsic(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;MIRIntrinsicID&gt;(....)); } .... }</code> </pre> <br>  Wir interessieren uns für den folgenden Teil dieses Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == !isAssigned ? OP_intrinsiccall : OP_intrinsiccallassigned) { .... }</code> </pre> <br>  Der Operator '==' hat eine höhere Priorität als der ternäre Operator (? :).  Aus diesem Grund wird der Bedingungsausdruck nicht korrekt ausgewertet.  Der geschriebene Code entspricht dem Folgenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o == !isAssigned) ? OP_intrinsiccall : OP_intrinsiccallassigned) { .... }</code> </pre> <br>  Unter Berücksichtigung der Tatsache, dass die <i>zugewiesenen</i> Konstanten <i>OP_intrinsiccall</i> und <i>OP_intrinsiccall</i> Werte ungleich Null haben, gibt diese Bedingung immer den wahren Wert zurück.  Der Body des <i>else-</i> Zweigs ist nicht erreichbarer Code. <br><br>  Dieser Fehler ist auf den Artikel " <a href="https://www.viva64.com/ru/b/0690/">Überprüfen des kürzlich von Huawei geöffneten Ark Compiler-Codes</a> " zurückzuführen. <br><br><h2>  Achter Platz: "Die Gefahr bitweiser Operationen" </h2><br>  <a href="https://www.viva64.com/ru/w/v1046/">V1046</a> Unsichere Verwendung der Typen bool 'und' int 'zusammen in der Operation' &amp; = '.  GSLMultiRootFinder.h 175 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ROOT::Math::IMultiGenFunction &amp; func)</span></span></span><span class="hljs-function"> </span></span>{ ROOT::Math::IMultiGenFunction * f = func.Clone(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fFunctions.push_back(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fFunctions.size(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetFunctionList</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ret = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (FuncIterator itr = begin; itr != end; ++itr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROOT::Math::IMultiGenFunction * f = *itr; ret &amp;= AddFunction(*f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Basierend auf dem Code sollte die <i>SetFunctionList-</i> Funktion die Liste der Iteratoren umgehen.  Und wenn mindestens einer von ihnen ungültig ist, ist der Rückgabewert <i>falsch</i> , andernfalls <i>wahr</i> . <br><br>  In der Realität kann die <i>SetFunctionList-</i> Funktion jedoch auch für gültige Iteratoren <i>false zurückgeben</i> .  <i>Schauen</i> wir uns die Situation an: Die <i>Funktion AddFunction</i> gibt die Anzahl der gültigen Iteratoren in der Liste <i>fFunctions zurück</i> .  Das heißt  Wenn Sie Iteratoren ungleich Null hinzufügen, wird die Liste nacheinander größer: 1, 2, 3, 4 usw.  Hier beginnt sich der Fehler im Code zu manifestieren: <br><br><pre> <code class="cpp hljs">ret &amp;= AddFunction(*f);</code> </pre> <br>  Weil  Da die Funktion ein Ergebnis vom Typ <i>int</i> und nicht <i>bool</i> zurückgibt, gibt die Operation '&amp; =' mit geraden Zahlen den Wert <i>false zurück</i> .  Immerhin wird das niedrigstwertige Bit von geraden Zahlen immer Null sein.  Daher wird ein solcher nicht offensichtlicher Fehler das Ergebnis der <i>SetFunctionsList-</i> Funktion auch für gültige Argumente verderben. <br><br>  Wenn Sie den Code aus dem Beispiel sorgfältig gelesen haben (und genau gelesen haben, oder?), Stellen Sie möglicherweise fest, dass dies Code aus dem ROOT-Projekt ist.  Natürlich haben wir es getestet: " <a href="https://www.viva64.com/ru/b/0682/">ROOT-Code-Analyse - ein Rahmen für die Analyse wissenschaftlicher Forschungsdaten</a> ." <br><br><h2>  Siebter Platz: „Verwirrung in den Variablen“ </h2><br>  <a href="https://www.viva64.com/ru/w/v1001/">V1001</a> [CWE-563] Die Variable 'Mode' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  SIModeRegister.cpp 48 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br>  Es ist sehr gefährlich, Funktionsargumenten dieselben Namen wie Klassenmitglieder zu geben.  Sehr leicht zu verwechseln.  Vor uns liegt so ein Fall.  Dieser Ausdruck ergibt keinen Sinn: <br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br>  Das Argument der Funktion ändert sich.  Und alle.  Dieses Argument wird nicht mehr verwendet.  Am wahrscheinlichsten war es notwendig, dies zu schreiben: <br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br>  Und das ist ein Fehler von <a href="http://llvm.org/">LLVM</a> .  Wir haben von Zeit zu Zeit die Tradition, dieses Projekt zu analysieren.  In diesem Jahr haben wir auch einen <a href="https://www.viva64.com/ru/b/0629/">Artikel</a> zur Verifikation. <br><br><h2>  Sechster Platz: „C ++ hat seine eigenen Gesetze“ </h2><br>  Der folgende Fehler wird im Code angezeigt, da C ++ - Regeln nicht immer mit mathematischen Regeln oder dem "gesunden Menschenverstand" übereinstimmen.  Merken Sie sich, wo der Fehler in einem kleinen Codeausschnitt liegt? <br><br>  <a href="https://www.viva64.com/ru/w/v709/">V709</a> Verdächtiger Vergleich gefunden: 'f0 == f1 == m_fractureBodies.size ()'.  Denken Sie daran, dass 'a == b == c' nicht gleich 'a == b &amp;&amp; b == c' ist.  btFractureDynamicsWorld.cpp 483 <br><br><pre> <code class="cpp hljs">btAlignedObjectArray&lt;btFractureBody*&gt; m_fractureBodies; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> btFractureDynamicsWorld::fractureCallback() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numManifolds; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f0 = m_fractureBodies.findLinearSearch(....); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f1 = m_fractureBodies.findLinearSearch(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f0 == f1 == m_fractureBodies.size()) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... } .... }</code> </pre> <br>  Es scheint, dass die Bedingung prüft, <i>ob f0</i> gleich <i>f1</i> und gleich der Anzahl der Elemente in <i>m_fractureBodies ist</i> .  Es sieht so aus, als hätte dieser Vergleich prüfen müssen, ob sich <i>f0</i> und <i>f1</i> am Ende des Arrays <i>m_fractureBodies befinden</i> , da sie die Position des Objekts enthalten, das von der Methode <i>findLinearSearch () gefunden wurde</i> .  Tatsächlich wird dieser Ausdruck jedoch zu einem Test, um <i>festzustellen,</i> ob <i>f0</i> und <i>f1</i> gleich sind, und um dann zu überprüfen, ob <i>m_fractureBodies.size ()</i> dem Ergebnis von <i>f0 == f1 entspricht</i> .  Infolgedessen wird der dritte Operand hier mit 0 oder 1 verglichen. <br><br>  Schöner Fehler!  Und zum Glück ziemlich selten.  Bisher haben wir sie nur in drei offenen Projekten getroffen, und interessanterweise waren alle nur Game-Engines.  Dies ist übrigens nicht der einzige Fehler, den wir in Bullet gefunden haben.  Die interessantesten sind in unserem Artikel " <a href="https://www.viva64.com/ru/b/0647/">PVS-Studio hat sich mit der Red Dead Redemption - Bullet Engine befasst</a> ". <br><br><h2>  Fünfter Platz: "Was ist das Ende der Linie?" </h2><br>  Der folgende Fehler ist leicht zu erkennen, wenn Sie über eine Subtilität Bescheid wissen. <br><br>  <a href="https://www.viva64.com/ru/w/v739/">V739</a> EOF sollte nicht mit einem Wert vom Typ 'char' verglichen werden.  Das 'ch' sollte vom Typ 'int' sein.  json.cpp 762 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JsonIn::skip_separator() { <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">','</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ate_separator ) { .... } .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == EOF) { .... }</code> </pre> <br>  Dies ist einer der Fehler, die möglicherweise schwer zu bemerken sind, wenn Sie nicht wissen, dass <i>EOF</i> als -1 definiert ist.  Dementsprechend ist die Bedingung fast immer <i>falsch</i> , wenn Sie versuchen, sie mit einer Variablen mit Vorzeichen zu vergleichen.  Die einzige Ausnahme ist, wenn der Zeichencode 0xFF (255) ist.  Beim Vergleich wird ein solches Symbol zu -1 und die Bedingung ist wahr. <br><br>  Es gibt eine Menge Fehler in Bezug auf Spiele in diesem Top: von Engines bis zu offenen Spielen.  Wie Sie vielleicht erraten haben, kam dieser Ort auch aus dieser Gegend zu uns.  Weitere Fehler finden Sie im Artikel " <a href="https://www.viva64.com/ru/b/0628/">Cataclysm Dark Days Ahead, Static Analysis and Bagels</a> ". <br><br><h2>  Vierter Platz: "Die Magie der Zahl Pi" </h2><br>  <a href="https://www.viva64.com/ru/w/v624/">V624</a> Die Konstante '3.141592538' enthält wahrscheinlich einen Druckfehler.  Erwägen Sie die Verwendung der M_PI-Konstante aus &lt;math.h&gt;.  PhysicsClientC_API.cpp 4109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">B3_SHARED_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b3ComputeProjectionMatrixFOV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fov, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> yScale = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>((<span class="hljs-number"><span class="hljs-number">3.141592538</span></span> / <span class="hljs-number"><span class="hljs-number">180.0</span></span>) * fov / <span class="hljs-number"><span class="hljs-number">2</span></span>); .... }</code> </pre> <br><br>  Ein kleiner Tippfehler in der Zahl Pi (3.141592653 ...), bei dem die Zahl "6" an der 7. Stelle im Bruchteil fehlt. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f83/42b/62f/f8342b62f2250ce927675fbbc1f40af7.png" alt="Bild 4"></div>  Vielleicht führt der Fehler in der 10-millionsten Dezimalstelle nicht zu greifbaren Konsequenzen, aber Sie sollten trotzdem die vorhandenen Bibliothekskonstanten ohne Tippfehler verwenden.  Für Pi gibt es beispielsweise eine M_PI-Konstante aus dem math.h-Header. <br><br>  Dieser Fehler stammt aus dem Artikel „ <a href="https://www.viva64.com/ru/b/0647/">PVS-Studio hat sich mit der Red Dead Redemption - Bullet Engine befasst</a> “, der uns bereits auf dem sechsten Platz bekannt war.  Wenn Sie es nicht für später verschoben haben, ist dies die letzte Chance. <br><br><h2>  Ein kleiner Exkurs </h2><br>  Wir befinden uns also in der Nähe der drei interessantesten Fehler.  Wie Sie vielleicht bemerkt haben, werden sie nicht nach den katastrophalen Folgen ihres Vorhandenseins sortiert, sondern nach der Komplexität der Erkennung.  Schließlich ist der wichtigste Vorteil der statischen Analyse gegenüber der Codeüberprüfung, dass die Maschine nicht müde wird und nichts vergisst.  :) <br><br>  Und jetzt mache ich Sie auf die ersten drei aufmerksam. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ff/519/18d/2ff51918d95a06eaf72aa7037aa66732.png" alt="Bild 8"></div><br><br><h2>  Dritter Platz: "The Elusive Exception" </h2><br>  <a href="https://www.viva64.com/ru/w/v702/">V702-</a> Klassen sollten immer von std :: exception (und ähnlichem) als 'public' abgeleitet werden (es wurde kein Schlüsselwort angegeben, daher verwendet der Compiler standardmäßig 'private').  CalcManager CalcException.h 4 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalcException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CalcException(HRESULT hr) { m_hr = hr; } <span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_hr; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HRESULT m_hr; };</code> </pre> <br>  Der Analysator hat eine Klasse erkannt, die über den Modifizierer <i>private</i> von der Klasse <i>std :: exception</i> geerbt wurde (der Standardmodifizierer, wenn nichts angegeben ist).  Das Problem mit diesem Code ist, dass beim Versuch, die allgemeine Ausnahme <i>std :: exception</i> <i>abzufangen</i> <i>, eine</i> Ausnahme vom Typ <i>CalcException</i> übersprungen wird.  Liegt daran, dass private Vererbung implizite Typkonvertierung ausschließt. <br><br>  Ja, ich möchte nicht, dass das Programm aufgrund des fehlenden <i>öffentlichen</i> Modifikators abstürzt <i>.</i>  Ich bin mir übrigens sicher, dass Sie die Anwendung in Ihrem Leben definitiv mindestens einmal verwendet haben, deren Quellcode wir uns gerade angesehen haben.  Dies ist der gute alte <a href="https://github.com/Microsoft/calculator">Windows-</a> Standardrechner, den wir auch <a href="https://www.viva64.com/ru/b/0615/">getestet haben</a> . <br><br><h2>  Zweiter Platz: Nicht geschlossene HTML-Tags </h2><br>  <a href="https://www.viva64.com/ru/w/v735/">V735</a> Möglicherweise falsches HTML.  Das schließende Tag "&lt;/ body&gt;" wurde gefunden, während das Tag "&lt;/ div&gt;" erwartet wurde.  book.cpp 127 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAlgebraLogBaseConversionPage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEGIN INDEX_LINK TITLE(Book::tr(<span class="hljs-string"><span class="hljs-string">"Logarithmic Base Conversion"</span></span>)) FORMULA(y = <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(x) / <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a), <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>&lt;sub&gt;a&lt;/sub&gt;x = <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(x) / <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(a)) END; }</code> </pre> <br>  Wie so oft bei C / C ++ - Code ist aus der Quelle nichts ersichtlich. Wenden wir uns daher dem vorverarbeiteten Code für dieses Fragment zu: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/7cf/4d4/19a7cf4d4da73085a677db2eceede962.png" alt="Bild 6"></div><br><br>  Der Analysator hat ein nicht geschlossenes <i>&lt;div&gt; -Tag</i> erkannt.  Es gibt viele Fragmente von HTML-Code in dieser Datei und jetzt sollte es zusätzlich von den Entwicklern überprüft werden. <br><br>  Überrascht, dass wir das überprüfen können und so?  Als ich das zum ersten Mal sah, war ich beeindruckt.  Also analysieren wir einen Teil des HTML-Codes.  Richtig, nur in C ++ Code.  :) <br><br>  Dies ist nicht nur der zweite Platz, sondern auch der zweite Rechner in unserer Top.  Eine Liste aller Fehler finden Sie im Artikel " <a href="https://www.viva64.com/ru/b/0618/">Auf den Spuren der Taschenrechner: SpeedCrunch</a> ". <br><br><h2>  Erster Platz: „Schwer fassbare Standardfunktionen“ </h2><br>  Also kamen wir zum ersten Platz.  Ein beeindruckend seltsames Problem, das eine Codeüberprüfung durchlief. <br><br>  Versuchen Sie es selbst zu entdecken: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatWhitespace</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE * InFile)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* ----------------------------------------------------------------------- ** * Scan past whitespace (see ctype(3C)) and return the first non-whitespace * character, or newline, or EOF. * * Input: InFile - Input source. * * Output: The next non-whitespace character in the input stream. * * Notes: Because the config files use a line-oriented grammar, we * explicitly exclude the newline character from the list of * whitespace characters. * - Note that both EOF (-1) and the nul character ('\0') are * considered end-of-file markers. * * ----------------------------------------------------------------------- ** */</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (c = getc (InFile); <span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span> (c) &amp;&amp; (<span class="hljs-string"><span class="hljs-string">'\n'</span></span> != c); c = getc (InFile)) ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c); } <span class="hljs-comment"><span class="hljs-comment">/* EatWhitespace */</span></span></code> </pre> <br>  Nun wollen wir sehen, was der Analysator schwört: <br><br>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Ein Teil eines bedingten Ausdrucks ist immer wahr: ('\ n'! = C).  params.c 136. <br><br>  Merkwürdig, nicht wahr?  Schauen wir uns etwas Interessantes im selben Projekt an, aber in einer anderen Datei (charset.h): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> isspace #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> isspace #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> isspace(c) ((c)==</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">' '</span></span></span><span class="hljs-meta"> || (c) == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\t'</span></span></span><span class="hljs-meta">)</span></span></code> </pre> <br>  Also, und das ist schon merkwürdig ... Es stellt sich heraus, dass, wenn die Variable <i>c</i> gleich <i>'\ n' ist,</i> die auf den ersten Blick absolut harmlose Funktion <i>isspace (c)</i> false <i>zurückgibt</i> und der zweite Teil dieses Tests aufgrund einer Kurzschlussbewertung nicht durchgeführt wird.  Wenn <i>isspace (c)</i> ausgeführt wird, ist die Variable <i>c</i> entweder <i>''</i> oder <i>'\ t',</i> und dies ist eindeutig nicht gleich <i>'\ n'</i> . <br><br>  Natürlich kann man sagen, dass dieses Makro wie <i>#define true false</i> ist und ein solcher Code niemals die Codeüberprüfung besteht.  Dieser Code bestand jedoch die Überprüfung und wartete sicher im Projekt-Repository auf uns. <br><br>  Wenn Sie eine genauere Analyse des Fehlers benötigen, lesen Sie den Artikel " <a href="https://www.viva64.com/ru/b/0610/">Für diejenigen, die den Detektiv spielen wollen: Finden Sie den Fehler in der Funktion von Midnight Commander</a> ". <br><br><h2>  Fazit </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a63/2b1/196/a632b119620f61c1a553a02c998b1509.png" alt="Bild 9"></div><br><br>  Im vergangenen Jahr haben wir viele Fehler gefunden.  Dies waren die üblichen Copy-Paste-Fehler, Fehler in Konstanten, nicht geschlossene Tags und viele andere Probleme.  Da sich unser Analyser jedoch verbessert und <a href="https://www.viva64.com/ru/b/0632/">lernt</a> , nach immer mehr Fehlern zu suchen, ist dies noch lange nicht alles und neue Artikel zur Überprüfung von Projekten werden so oft wie bisher veröffentlicht. <br><br>  Wenn jemand unsere Artikel zum ersten Mal liest, werde ich für alle Fälle klarstellen, dass all diese Fehler mit dem statischen Code-Analysator von PVS-Studio gefunden wurden. Wir empfehlen, ihn <a href="https://www.viva64.com/ru/pvs-studio-download/">herunterzuladen</a> und zu testen.  Der Analyzer kann Fehler im Code von Programmen erkennen, die in den Sprachen C, C ++, C # und Java geschrieben sind. <br><br>  Wir sind also am Ende angelangt!  Wenn Sie die ersten beiden Ebenen verpasst haben, dann schlage ich vor, die Gelegenheit nicht zu verpassen und sie mit uns durchzugehen: <a href="https://habr.com/ru/company/pvs-studio/blog/481178/">C #</a> und <a href="https://habr.com/ru/company/pvs-studio/blog/481186/">Java</a> . <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/481188/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen möchten, verwenden Sie bitte den Link zur Übersetzung: Maxim Zvyagintsev.  <a href="https://habr.com/en/company/pvs-studio/blog/481188/">Die 10 häufigsten Fehler in C ++ - Projekten im Jahr 2019</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481190/">https://habr.com/ru/post/de481190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481180/index.html">Müssen Entwickler Vorschläge von Benutzern erhalten?</a></li>
<li><a href="../de481182/index.html">Istio Service Mesh Beiträge Serie</a></li>
<li><a href="../de481184/index.html">Die 10 häufigsten Fehler in Java-Projekten im Jahr 2019</a></li>
<li><a href="../de481186/index.html">Top 10 Bugs in Java-Projekten für 2019</a></li>
<li><a href="../de481188/index.html">Die 10 häufigsten Fehler in C ++ - Projekten im Jahr 2019</a></li>
<li><a href="../de481200/index.html">Sprachsteuerung und VoiceOver: So passen Sie die Anwendung für Blinde oder Standbilder an</a></li>
<li><a href="../de481202/index.html">Antiquitäten: das Prinzip des Müllsammelns und die Ergebnisse von 2019</a></li>
<li><a href="../de481204/index.html">Tech release Mail.ru Group, Winter 2019</a></li>
<li><a href="../de481206/index.html">Wie die Amerikaner ein lebendes Frettchen in einen Collider steckten</a></li>
<li><a href="../de481208/index.html">Leistungsstarkes, kostengünstiges E-Bike zum Selbermachen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>