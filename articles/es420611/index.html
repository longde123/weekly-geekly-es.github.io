<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèø ü§≤üèº üëã Modelado de enredo cu√°ntico en C # üßô ‚ô•Ô∏è ü§úüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A medida que el tema del enredo cu√°ntico aparece cada vez m√°s a menudo, quer√≠a profundizar un poco m√°s. A juzgar por los comentarios sobre los art√≠cul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelado de enredo cu√°ntico en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/">  A medida que el tema del enredo cu√°ntico aparece cada vez m√°s a menudo, quer√≠a profundizar un poco m√°s.  A juzgar por los comentarios sobre los art√≠culos sobre enredo cu√°ntico, esta informaci√≥n no me ser√° √∫til solo.  Bueno, teniendo en cuenta el hecho de que para la mayor√≠a de nosotros, el c√≥digo del programa es mucho m√°s conveniente que cualquier alegor√≠a, se decidi√≥ presentar mi entendimiento en forma de c√≥digo. <br><a name="habracut"></a><br>  Este art√≠culo ampl√≠a el art√≠culo de otro autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Enredos cu√°nticos para tontos"</a> (recomiendo leerlo, me ayud√≥ mucho).  En su art√≠culo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">indomit</a> dio un ejemplo de un programa que demuestra claramente el problema de la teor√≠a de los par√°metros ocultos, pero no puede dar un ejemplo de un c√≥digo para part√≠culas en superposici√≥n.  En este art√≠culo, intentaremos simular 2 casos: <br><br><ol><li>  C√≥mo se comportar√≠an las part√≠culas enredadas en el determinismo, cuando el estado de las part√≠culas se establece antes de la medici√≥n, simplemente no podemos medirlo sin introducir distorsiones (la teor√≠a misma de los par√°metros ocultos).  Obtenemos los n√∫meros y vemos la discrepancia con la pr√°ctica. </li><li>  Escribiremos un modelo de part√≠culas enredadas en superposici√≥n (el estado de las part√≠culas no est√° definido antes de la medici√≥n).  Intentemos asumir c√≥mo se programa la part√≠cula en el interior, es decir, ajustaremos su c√≥digo a los datos obtenidos experimentalmente. </li></ol><br>  El art√≠culo se basa en la explicaci√≥n popular del fen√≥meno del enredo cu√°ntico de Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">La paradoja de Mermin explicada</b> <div class="spoiler_text">  Para el informe popular de la paradoja, D. Mermin propone construir un dispositivo simple [23].  El dispositivo debe consistir en un emisor de part√≠culas y dos detectores.  Se emiten dos part√≠culas id√©nticas a cada una de ellas.  Habiendo atrapado una part√≠cula, el detector da una respuesta binaria (0 o 1), dependiendo de la part√≠cula y su interruptor de ajuste de tres posiciones.  La detecci√≥n de un par de part√≠culas deber√≠a dar las mismas respuestas: <br><br><ol><li>  Siempre que los detectores se configuren de la misma manera. </li><li>  Seg√∫n las estad√≠sticas, en la mitad de los casos cuando se configuran al azar. </li></ol><br>  La primera propiedad requiere que todos los detectores usen la misma codificaci√≥n, la posici√≥n del interruptor es ‚àà {1,2,3} ‚Ü¶ respuesta ‚àà {0,1}, sin ning√∫n elemento de aleatoriedad.  Es decir, deben acordar de antemano cu√°l de las respuestas, 0 o 1, da a la posici√≥n del interruptor, eligiendo para cada part√≠cula una de las ocho funciones posibles, 000, 001, 010, 011, 100, 101, 110 y 111. Al elegir 000 o 111 se obtendr√° al 100% de coincidencia de las lecturas de los detectores, independientemente de la posici√≥n de la perilla de control.  Si los detectores implementan una de las seis funciones restantes, uno de los d√≠gitos se extrae mediante un interruptor sintonizado al azar en 2/3 de los casos, y el otro con una probabilidad de 1/3.  La probabilidad de coincidencia de las dos respuestas ser√° (‚Öî) ¬≤ + (‚Öì) ¬≤ = 5/9.  Entonces, no importa cu√°l sea el algoritmo del aut√≥mata, la correlaci√≥n inevitablemente excede el 50%, violando el segundo requisito. <br><br>  <i>Pero dado que dicha m√°quina todav√≠a se puede construir (por ejemplo, colocando los polarizadores a 120 ¬∞ como en el experimento de Bohm), no puede haber determinismo (par√°metros) incluso en una forma oculta.</i>  <i>En cambio, las correlaciones de respuesta se mantienen transmitiendo informaci√≥n de una part√≠cula "medida" a otra m√°s r√°pido que la segunda medici√≥n.</i> <br><br>  Tomado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqu√≠</a> . <br></div></div><br>  Desafortunadamente, no hago f√≠sica ni profesionalmente ni incluso a nivel amateur, no pretendo ser impecable.  El objetivo principal del art√≠culo es demostrar c√≥mo hacer que un modelo sea comprensible para aquellos familiarizados con la programaci√≥n.  Si alguien est√° trabajando profesionalmente en este campo, en lugar de reprochar, intente escribir modelos de interacci√≥n m√°s precisos basados ‚Äã‚Äãen mi art√≠culo. <br><br><h2>  [Actualizaci√≥n] Explicaci√≥n de la descripci√≥n de Mermin </h2><br>  Aunque han pasado varios meses desde la redacci√≥n del art√≠culo y nadie volver√° a leerlo, decid√≠ hacer una aclaraci√≥n para calmar mi conciencia. <br><br>  Fui un poco m√°s profundo y llegu√© a la conclusi√≥n de que la descripci√≥n seg√∫n Mermin se simplifica enormemente y los intentos de vincularlo con experimentos f√≠sicos reales <i>no</i> tienen <i>sentido</i> . <br><br>  Inicialmente, trat√© de vincular el art√≠culo a un experimento real con polarizaci√≥n circular, y comet√≠ un error al respecto.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">ARad</a> intent√≥ desarrollar un enlace con experimentos f√≠sicos reales, escribi√≥ sobre los errores cometidos e incluso propuso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su propia versi√≥n del c√≥digo</a> (que tampoco corresponde a ning√∫n experimento f√≠sico). <br><br>  Para que el art√≠culo tenga al menos alg√∫n sentido, se decidi√≥ eliminar todos los enlaces imaginarios a experimentos f√≠sicos reales y simplemente <i>explicar la descripci√≥n de Mermin en el c√≥digo</i> y hacerlo m√°s visual.  Los experimentos reales son m√°s complicados y para simularlos necesitas pasar mucho m√°s tiempo. <br><br>  En la primera versi√≥n del art√≠culo, aceptamos que en el primer experimento (la posici√≥n de los sensores coincide), las part√≠culas dan un resultado espejo, pero en la descripci√≥n original seg√∫n Mermin, el resultado de la medici√≥n con la misma posici√≥n de los sensores siempre coincide.  Esto est√° <i>arreglado</i> . <br><br>  Adem√°s, agregar√© una "explicaci√≥n para una explicaci√≥n" de este Mermin mismo, ya que no est√° escrito sin ambig√ºedades: <br><br><blockquote>  Es decir, deben acordar de antemano cu√°l de las respuestas, 0 o 1, da a la posici√≥n del interruptor, eligiendo para cada part√≠cula una de las ocho funciones posibles, 000, 001, 010, 011, 100, 101, 110 y 111. <br></blockquote><br>  La frase "ocho funciones posibles" es ambigua.  Se discuten ocho posibles variantes del impacto <i>potencial</i> de las part√≠culas en el sensor.  El sensor tiene tres posiciones (ver la descripci√≥n completa arriba).  Si creemos que el estado de las dos part√≠culas coincide y se establece de antemano, entonces podemos determinar de antemano qu√© respuesta (0 o 1) potencialmente recibiremos para cada una de las tres posiciones del interruptor (aunque podemos "medir" solo una de las tres opciones). <br><br><blockquote>  Seleccionar 000 o 111 dar√° como resultado una coincidencia del 100% de las lecturas del detector, independientemente de la posici√≥n de la perilla de sintonizaci√≥n. </blockquote><br>  Si las part√≠culas pueden tomar un valor en el que potencialmente podemos recibir una respuesta de "1" para cualquier posici√≥n del interruptor (as√≠ como 0 para cualquier posici√≥n del interruptor), entonces el segundo experimento en estos casos dar√° una coincidencia del 100%.  Para acercarse al 50%, estas opciones pueden excluirse. <br><br><blockquote>  Si los detectores implementan una de las seis funciones restantes, uno de los d√≠gitos se extrae mediante un interruptor sintonizado al azar en 2/3 de los casos, y el otro con una probabilidad de 1/3. </blockquote><br>  Significa que en cada uno de los 6 triples (001, 010, 011, 100, 101, 110), solo dos de los tres d√≠gitos coinciden (en la primera versi√≥n, dos de los tres son "0" y uno de los tres es "1" ) <br><br>  Para evaluar la probabilidad, compilamos una tabla para el primer caso <b>001</b> : <br><br><table><tbody><tr><th>  Posici√≥n del sensor 1 </th><th>  Posici√≥n del sensor 2 </th><th>  ¬øLas medidas coinciden? </th></tr><tr><td>  1 </td><td>  1 </td><td>  + </td></tr><tr><td>  1 </td><td>  2 </td><td>  + </td></tr><tr><td>  1 </td><td>  3 </td><td>  - </td></tr><tr><td>  2 </td><td>  1 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - </td></tr><tr><td>  3 </td><td>  1 </td><td>  - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  Se puede ver que en cinco casos de nueve mediciones coinciden.  La misma probabilidad ser√° para cada una de estas seis opciones (despu√©s de todo, en cada una de ellas los dos n√∫meros son iguales). <br><br><h2>  Medidas </h2><br>  En cada uno de los modelos (tanto deterministas como superposicionales), realizaremos dos experimentos con part√≠culas enredadas correspondientes a la primera y segunda condiciones seg√∫n Mermin: <br><br><ol><li>  Primero, coloque ambos sensores en la misma posici√≥n.  En este caso, obtendremos resultados 100% id√©nticos (si el primer fot√≥n pasa a trav√©s del polarizador, entonces el fot√≥n asociado tambi√©n pasa a trav√©s del polarizador en el mismo √°ngulo). </li><li>  Luego estableceremos la posici√≥n de los sensores al azar. </li></ol><br>  Aqu√≠ est√° el c√≥digo para el primer experimento: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Aqu√≠ est√° el c√≥digo para el segundo experimento: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  Las mismas pruebas ser√°n para todos los modelos de part√≠culas, solo el c√≥digo de part√≠culas ser√° diferente para los modelos deterministas y de superposici√≥n (m√°s sobre esto a continuaci√≥n). <br><br><h2>  Modelo determinista </h2><br>  Atencion  ¬°Vea ACTUALIZACI√ìN al final del art√≠culo! <br><br>  Para aquellos que desean ejecutar el c√≥digo de inmediato, esto se puede hacer desde el navegador: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br>  Entonces, seg√∫n la explicaci√≥n de Mermin, tenemos una part√≠cula cu√°ntica con 3 par√°metros: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Como el modelo es determinista, todos los par√°metros de la part√≠cula se inicializan en el momento de su creaci√≥n, es decir, directamente en el constructor.  ¬°La √∫nica condici√≥n es que la medici√≥n se permita solo una vez! <br><br>  Siguiente  Un par de part√≠culas enredadas: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  Se puede ver que los valores de cada una de las part√≠culas se establecen en el momento de crear un par de part√≠culas enredadas, y los par√°metros de la segunda part√≠cula corresponden a los par√°metros de la primera (sin esto no podemos pasar la primera prueba).  Utilizamos n√∫meros aleatorios, pero seg√∫n el modelo, los par√°metros dependen de factores en el momento del enredo (como resultado de la ruleta, depende de varios factores en el momento del desenrollado). <br><br>  C√≥digo de ejemplo completo: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo C # del modelo determinista (fijo)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Puede iniciarlo desde el navegador (una vez m√°s, el enlace: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnetfiddle.net/N5Xg18</a> ). <br><br>  Despu√©s del lanzamiento, estos son los resultados: <br><br><blockquote>  Experimento No. 1: 100% de los valores coincidieron <br>  Experimento No. 2: 55.6700% de los valores coincidentes <br></blockquote><br>  La primera prueba aprobada, corresponde a lo que est√° sucediendo en la realidad.  Pero el segundo no coincide, ¬°ya que deber√≠an obtener el 50%! <br><br>  Como resultado, los f√≠sicos se vieron obligados a llegar a la conclusi√≥n de que la teor√≠a de los par√°metros ocultos es err√≥nea.  Y con ello, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principio de localidad se</a> refuta y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principio de causalidad</a> incluso se ha sacudido. <br><br><h2>  Modelo superposicional </h2><br>  Inmediatamente un enlace a un c√≥digo de ejemplo, para los amantes de los detalles (se puede iniciar en un navegador): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br>  Para explicar los resultados obtenidos durante los experimentos, fue necesario utilizar modelos m√°s complejos.  En los modelos modernos, el estado de los par√°metros de part√≠culas no se define antes de la medici√≥n, y las part√≠culas enredadas tienen la capacidad de afectar instant√°neamente (por encima de la velocidad de la luz) el estado del otro.  As√≠ es como se ve nuestro modelo de part√≠culas ahora: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Primero, los par√°metros son anulables (pueden no importar) y no los establecemos en el constructor.  En segundo lugar, el m√©todo CreateSuperluminalChannelWith para establecer el canal superligero entre part√≠culas, es decir  Ahora una part√≠cula puede obtener el estado de otra al instante, independientemente de la distancia.  Bueno, y lo m√°s importante, ahora el estado de una part√≠cula se <i>establece solo en el momento de la medici√≥n</i> (llamado m√©todo GetValue) y depende de si se midi√≥ otra part√≠cula relacionada con ella. <br><br>  El interior del m√©todo GetValue es pura especulaci√≥n.  Nadie sabe c√≥mo est√° organizada la part√≠cula en el interior, pero sabemos que funciona as√≠: 100% de desajustes al medir el mismo par√°metro y 50% de desajustes al medir par√°metros en un orden aleatorio. <br><br>  En mi versi√≥n del c√≥digo, una part√≠cula a trav√©s de un canal superluminal verifica si la medici√≥n se confunde con ella y act√∫a as√≠: <br><br><ol><li>  Si el par√°metro medido de otra part√≠cula es el mismo que estamos tratando de medir, da el mismo valor. </li><li>  Si el par√°metro es diferente, en 1/4 de los casos da el mismo valor, y en 3/4 de los casos da el valor opuesto (ya que obtenemos 50/50). </li></ol><br>  Si no se realiz√≥ la medici√≥n, la part√≠cula usa una aleatoriedad verdadera para establecer su valor, es decir, se viola una relaci√≥n causal (el valor no exist√≠a antes de la medici√≥n y la medici√≥n en s√≠ misma no determin√≥ su valor). <br><br>  <i>Por cierto!</i>  <i>Puede reescribir esta funci√≥n de otra manera, pero para que los resultados de la prueba sean los mismos.</i>  <i>De todos modos, nadie sabe c√≥mo se organiza la part√≠cula elemental y c√≥mo se logra el 50% para la segunda prueba.</i> <i><br></i> <br>  Un par de part√≠culas enredadas se ha vuelto m√°s f√°cil, ya que en el momento del enredo no se establecen valores (los valores a√∫n no se han determinado): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  C√≥digo de ejemplo completo: <br><br><div class="spoiler">  <b class="spoiler_title">Modelo superposicional en C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Resultados: <br><br><blockquote>  Experimento No. 1: 100% de los valores coincidieron <br>  Experimento No. 2: 49.7700% de los valores coincidieron <br></blockquote><br>  Ejecutar en el navegador: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  Conclusiones </h2><br>  Me gustar√≠a tener m√°s interpretaciones disponibles, como las expresadas por Mermin.  En base a esta interpretaci√≥n, logr√© crear modelos visuales de teor√≠as existentes e incluso presentar un modelo alternativo, y estos modelos no son aleg√≥ricos: puede ejecutarlos y ver c√≥mo funcionan. <br><br>  Desafortunadamente, no tengo los recursos de tiempo para un conocimiento m√°s profundo de la f√≠sica cu√°ntica y espero que aquellos que saben puedan seguir mi ejemplo y dar modelos de trabajo m√°s precisos. <br><br>  <b>ACTUALIZAR</b> <br>  La explicaci√≥n de Mermin no tiene nada que ver con el dise√±o de detectores.  Por mi propia iniciativa, agregu√© una explicaci√≥n a A, B y C como una proyecci√≥n del giro en los ejes X, Y y Z, respectivamente.  Es decir, quer√≠a agregar un enlace a los fen√≥menos f√≠sicos en los comentarios al c√≥digo para que no sea tan seco.  Y me equivoqu√© en esto ... <br><br>  El art√≠culo se corrige y se eliminan todos los intentos vanos de vincular la explicaci√≥n de Mermin con experimentos f√≠sicos reales. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420611/">https://habr.com/ru/post/es420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420599/index.html">Trece cosas que Lem previeron</a></li>
<li><a href="../es420603/index.html">Estad√≠sticas del propietario de Tesla Model S</a></li>
<li><a href="../es420605/index.html">Descripci√≥n general del algoritmo de entrevista de trabajo: generaci√≥n de conjuntos</a></li>
<li><a href="../es420607/index.html">Eventos digitales en Mosc√∫ del 20 al 26 de agosto.</a></li>
<li><a href="../es420609/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 327 (13 al 19 de agosto de 2018)</a></li>
<li><a href="../es420613/index.html">11 bibliotecas (conjuntos de componentes) para React Native que debes conocer en 2018</a></li>
<li><a href="../es420615/index.html">JavaScript: explorar objetos</a></li>
<li><a href="../es420617/index.html">Gu√≠a de dise√±o web para desarrolladores</a></li>
<li><a href="../es420619/index.html">Im√°genes receptivas: trucos CSS que ahorran tiempo</a></li>
<li><a href="../es420623/index.html">Aplicaciones C ++ distribuidas con un m√≠nimo de esfuerzo.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>