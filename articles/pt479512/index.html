<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüè´ üî§ üôçüèæ MVCC no PostgreSQL-4. Instant√¢neos ü§∂üèæ ‚ÜïÔ∏è üë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depois de discutir os problemas de isolamento e fazer uma digress√£o em rela√ß√£o √† estrutura de dados de baixo n√≠vel , na √∫ltima vez que exploramos as v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC no PostgreSQL-4. Instant√¢neos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/">  Depois de discutir os problemas de <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolamento</a> e fazer uma digress√£o em rela√ß√£o √† <a href="https://habr.com/ru/company/postgrespro/blog/469087/">estrutura de dados de baixo n√≠vel</a> , na √∫ltima vez que exploramos as <a href="https://habr.com/ru/company/postgrespro/blog/477648/">vers√µes de linha</a> e observamos como as diferentes opera√ß√µes alteraram os campos do cabe√ßalho da tupla. <br><br>  Agora, veremos como os snapshots de dados consistentes s√£o obtidos das tuplas. <br><br><h1>  O que √© um instant√¢neo de dados? </h1><br>  As p√°ginas de dados podem conter fisicamente v√°rias vers√µes da mesma linha.  Mas cada transa√ß√£o deve ver apenas uma (ou nenhuma) vers√£o de cada linha, para que todas elas formem uma imagem consistente dos dados (no sentido de ACID) em um determinado momento. <br><br>  O isolamento no PosgreSQL √© baseado em instant√¢neos: cada transa√ß√£o trabalha com seu pr√≥prio instant√¢neo de dados, que "cont√©m" dados confirmados antes do momento em que o instant√¢neo foi criado e n√£o "cont√©m" dados que ainda n√£o foram confirmados naquele momento.  J√° <a href="https://habr.com/ru/company/postgrespro/blog/467437/">vimos</a> que, embora o isolamento resultante pare√ßa mais r√≠gido do que o exigido pelo padr√£o, ele ainda apresenta anomalias. <br><a name="habracut"></a><br>  No n√≠vel de isolamento Read Committed, um instant√¢neo √© criado no in√≠cio de cada instru√ß√£o de transa√ß√£o.  Este instant√¢neo est√° ativo enquanto a instru√ß√£o est√° sendo executada.  Na figura, o momento em que o instant√¢neo foi criado (que, como lembramos, √© determinado pelo ID da transa√ß√£o) √© mostrado em azul. <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br>  Nos n√≠veis Leitura Repet√≠vel e Serializ√°vel, o instant√¢neo √© criado uma vez, no in√≠cio da primeira instru√ß√£o de transa√ß√£o.  Esse instant√¢neo permanece ativo at√© o final da transa√ß√£o. <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1>  Visibilidade das tuplas em um instant√¢neo </h1><br><h2>  Regras de visibilidade </h2><br>  Um instant√¢neo certamente n√£o √© uma c√≥pia f√≠sica de todas as tuplas necess√°rias.  Na verdade, um instant√¢neo √© especificado por v√°rios n√∫meros e a visibilidade das tuplas em um instant√¢neo √© determinada por regras. <br><br>  Se uma tupla estar√° vis√≠vel ou n√£o em uma captura instant√¢nea depende de dois campos no cabe√ßalho, ou seja, <code>xmin</code> e <code>xmax</code> , ou seja, os IDs das transa√ß√µes que criaram e exclu√≠ram a tupla.  Intervalos como esse n√£o se sobrep√µem e, portanto, n√£o mais de uma vers√£o representa uma linha em cada instant√¢neo. <br><br>  As regras exatas de visibilidade s√£o bastante complicadas e levam em considera√ß√£o muitos casos e extremos diferentes. <br><blockquote>  Voc√™ pode garantir isso facilmente, consultando src / backend / utils / time / tqual.c (na vers√£o 12, a verifica√ß√£o foi movida para src / backend / access / heap / heapam_visibility.c). <br></blockquote><br>  Para simplificar, podemos dizer que uma tupla √© vis√≠vel quando, no instant√¢neo, as altera√ß√µes feitas pela transa√ß√£o <code>xmin</code> s√£o vis√≠veis, enquanto as feitas pela transa√ß√£o <code>xmax</code> n√£o s√£o (em outras palavras, j√° est√° claro que a tupla foi criada, mas ainda n√£o est√° claro se foi exclu√≠do). <br><br>  Em rela√ß√£o a uma transa√ß√£o, suas altera√ß√µes s√£o vis√≠veis no instant√¢neo, se √© a pr√≥pria transa√ß√£o que criou o instant√¢neo (ele v√™ suas pr√≥prias altera√ß√µes ainda n√£o confirmadas) ou a transa√ß√£o foi confirmada antes da cria√ß√£o do instant√¢neo. <br><br>  Podemos representar graficamente transa√ß√µes por segmentos (desde o hor√°rio de in√≠cio at√© o hor√°rio de confirma√ß√£o): <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br>  Aqui: <br><br><ul><li>  As altera√ß√µes da transa√ß√£o 2 ser√£o vis√≠veis desde que foram conclu√≠das antes da cria√ß√£o do instant√¢neo. </li><li>  As altera√ß√µes da transa√ß√£o 1 n√£o ser√£o vis√≠veis, pois estavam ativas no momento em que o instant√¢neo foi criado. </li><li>  As altera√ß√µes da transa√ß√£o 3 n√£o ser√£o vis√≠veis desde que foram iniciadas ap√≥s a cria√ß√£o do instant√¢neo (independentemente de ter sido conclu√≠do ou n√£o). </li></ul><br>  Infelizmente, o sistema desconhece o tempo de consolida√ß√£o das transa√ß√µes.  Somente sua hora de in√≠cio √© conhecida (que √© determinada pelo ID da transa√ß√£o e marcada com uma linha tracejada nas figuras acima), mas o evento de conclus√£o n√£o √© gravado em nenhum lugar. <br><br>  Tudo o que podemos fazer √© descobrir o status <em>atual</em> das transa√ß√µes na cria√ß√£o do instant√¢neo.  Esta informa√ß√£o est√° dispon√≠vel na mem√≥ria compartilhada do servidor, na estrutura ProcArray, que cont√©m a lista de todas as sess√µes ativas e suas transa√ß√µes. <br><br>  Mas n√£o seremos capazes de descobrir ap√≥s o fato se uma determinada transa√ß√£o estava ativa ou n√£o no momento em que o instant√¢neo foi criado.  Portanto, um instant√¢neo deve armazenar uma lista de todas as transa√ß√µes ativas atuais. <br><br>  Pelo exposto, segue-se que no PostgreSQL, n√£o √© poss√≠vel criar uma captura instant√¢nea que mostre dados consistentes a partir de um certo tempo, <em>mesmo se</em> todas as tuplas necess√°rias estiverem dispon√≠veis nas p√°ginas da tabela.  Muitas vezes, surge uma pergunta por que o PostgreSQL n√£o possui consultas retrospectivas (ou temporais; ou flashback, como a Oracle as chama) - e esse √© um dos motivos. <br><blockquote>  O engra√ßado √© que essa funcionalidade foi disponibilizada primeiro, mas depois exclu√≠da do DBMS.  Voc√™ pode ler sobre isso no <a href="https://arxiv.org/pdf/1901.01973.pdf">artigo de Joseph M. Hellerstein</a> . <br></blockquote><br>  Portanto, o instant√¢neo √© determinado por v√°rios par√¢metros: <br><br><ul><li>  No momento em que o instant√¢neo foi criado, mais exatamente, o ID da pr√≥xima transa√ß√£o, ainda indispon√≠vel no sistema ( <code>snapshot.xmax</code> ). </li><li>  A lista de transa√ß√µes ativas (em andamento) no momento em que a captura instant√¢nea foi criada ( <code>snapshot.xip</code> ). </li></ul><br>  Por conveni√™ncia e otimiza√ß√£o, o ID da transa√ß√£o ativa mais antiga tamb√©m √© armazenado ( <code>snapshot.xmin</code> ).  Esse valor faz um sentido importante, que ser√° discutido abaixo. <br><br>  O instant√¢neo tamb√©m armazena mais alguns par√¢metros, que n√£o s√£o importantes para n√≥s. <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2>  Exemplo </h2><br>  Para entender como o instant√¢neo determina a visibilidade, vamos reproduzir o exemplo acima com tr√™s transa√ß√µes.  A tabela ter√° tr√™s linhas, onde: <br><br><ul><li>  O primeiro foi adicionado por uma transa√ß√£o iniciada antes da cria√ß√£o da captura instant√¢nea, mas conclu√≠da ap√≥s ela. </li><li>  O segundo foi adicionado por uma transa√ß√£o iniciada e conclu√≠da antes da cria√ß√£o da captura instant√¢nea. </li><li>  O terceiro foi adicionado ap√≥s a cria√ß√£o do instant√¢neo. </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br>  A primeira transa√ß√£o (ainda n√£o conclu√≠da): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  A segunda transa√ß√£o (conclu√≠da antes da cria√ß√£o do instant√¢neo): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Criando um instant√¢neo em uma transa√ß√£o em outra sess√£o. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Confirmando a primeira transa√ß√£o ap√≥s a cria√ß√£o da captura instant√¢nea: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  E a terceira transa√ß√£o (apareceu ap√≥s a cria√ß√£o do instant√¢neo): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Evidentemente, apenas uma linha ainda √© vis√≠vel em nosso instant√¢neo: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  A quest√£o √© como o Postgres entende isso. <br><br>  Tudo √© determinado pelo instant√¢neo.  Vejamos: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Aqui <code>snapshot.xmin</code> , <code>snapshot.xmax</code> e <code>snapshot.xip</code> s√£o listados, delimitados por dois pontos (nesse caso, <code>snapshot.xip</code> √© um n√∫mero, mas em geral √© uma lista). <br><br>  De acordo com as regras acima, no instant√¢neo, essas altera√ß√µes devem ser vis√≠veis pelas transa√ß√µes com os IDs <code>xid</code> modo que <code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code> exceto aqueles que est√£o na lista <code>snapshot.xip</code> .  Vejamos todas as linhas da tabela (no novo instant√¢neo): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  A primeira linha n√£o est√° vis√≠vel: foi criada por uma transa√ß√£o que est√° na lista de transa√ß√µes ativas ( <code>xip</code> ). <br>  A segunda linha √© vis√≠vel: foi criada por uma transa√ß√£o que est√° no intervalo da captura instant√¢nea. <br>  A terceira linha n√£o est√° vis√≠vel: foi criada por uma transa√ß√£o que est√° fora do intervalo da captura instant√¢nea. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Mudan√ßas da pr√≥pria transa√ß√£o </h1><br>  Determinar a visibilidade das pr√≥prias altera√ß√µes da transa√ß√£o complica um pouco a situa√ß√£o.  Nesse caso, pode ser necess√°rio ver apenas parte dessas altera√ß√µes.  Por exemplo: em qualquer n√≠vel de isolamento, um cursor aberto em um determinado momento n√£o deve ver as altera√ß√µes feitas posteriormente. <br><br>  Para esse fim, um cabe√ßalho de tupla possui um campo especial (representado nas pseudo-colunas <code>cmin</code> e <code>cmax</code> ), que mostra o n√∫mero do pedido dentro da transa√ß√£o.  <code>cmin</code> √© o n√∫mero para inser√ß√£o e <code>cmax</code> - para exclus√£o, mas para economizar espa√ßo no cabe√ßalho da tupla, esse √© realmente um campo em vez de dois campos diferentes.  Sup√µe-se que uma transa√ß√£o raramente insira e exclua a mesma linha. <br><br>  Mas se isso acontecer, um ID de comando de combina√ß√£o especial ( <code>combocid</code> ) ser√° inserido no mesmo campo, e o processo de back-end lembrar√° o <code>cmin</code> e <code>cmin</code> reais para esse <code>combocid</code> .  Mas isso √© totalmente ex√≥tico. <br><br>  Aqui est√° um exemplo simples.  Vamos iniciar uma transa√ß√£o e adicionar uma linha √† tabela: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Vamos exibir o conte√∫do da tabela, junto com o campo <code>cmin</code> (mas apenas para linhas adicionadas pela transa√ß√£o - para outras, n√£o faz sentido): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Agora, abrimos um cursor para uma consulta que retorna o n√∫mero de linhas na tabela. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  E depois adicionamos outra linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  A consulta retorna 4 - a linha adicionada ap√≥s abrir o cursor n√£o entra no instant√¢neo de dados: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Porque  Como o instant√¢neo leva em considera√ß√£o apenas as tuplas com <code>cmin &lt; 1</code> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Horizonte de eventos </h1><br>  O ID da transa√ß√£o ativa mais antiga ( <code>snapshot.xmin</code> ) faz um sentido importante: determina o "horizonte de eventos" da transa√ß√£o.  Ou seja, al√©m do seu horizonte, a transa√ß√£o sempre v√™ apenas vers√µes de linha atualizadas. <br><br>  Realmente, uma vers√£o de linha desatualizada (inativa) precisa estar vis√≠vel apenas quando a vers√£o atualizada foi criada por uma transa√ß√£o ainda n√£o conclu√≠da e, portanto, ainda n√£o est√° vis√≠vel.  Mas todas as transa√ß√µes "al√©m do horizonte" s√£o conclu√≠das com certeza. <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br>  Voc√™ pode ver o horizonte de transa√ß√µes no cat√°logo do sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Tamb√©m podemos definir o horizonte no n√≠vel do banco de dados.  Para fazer isso, precisamos tirar todos os instant√¢neos ativos e encontrar o <code>xmin</code> mais antigo entre eles.  E definir√° o horizonte, al√©m do qual as tuplas mortas no banco de dados nunca ser√£o vis√≠veis para nenhuma transa√ß√£o.  <em>Tais tuplas podem ser aspiradas</em> - e √© exatamente por isso que o conceito de horizonte √© t√£o importante do ponto de vista pr√°tico. <br><br>  Se uma determinada transa√ß√£o estiver mantendo um instant√¢neo por um longo tempo, tamb√©m manter√° o horizonte do banco de dados.  Al√©m disso, apenas a exist√™ncia de uma transa√ß√£o incompleta manter√° o horizonte, mesmo que a transa√ß√£o em si n√£o mantenha o instant√¢neo. <br><br>  E isso significa que as tuplas mortas no DB n√£o podem ser aspiradas.  Al√©m disso, √© poss√≠vel que uma transa√ß√£o de "reprodu√ß√£o longa" n√£o cruze os dados com outras transa√ß√µes, mas isso realmente n√£o importa, pois todos compartilham um horizonte de banco de dados. <br><br>  Se agora fizermos um segmento representar snapshots (de <code>snapshot.xmin</code> a <code>snapshot.xmax</code> ) em vez de transa√ß√µes, poderemos visualizar a situa√ß√£o da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br>  Nesta figura, o instant√¢neo mais baixo pertence a uma transa√ß√£o incompleta e, nos outros instant√¢neos, o <code>snapshot.xmin</code> n√£o pode ser maior que o ID da transa√ß√£o. <br><br>  Em nosso exemplo, a transa√ß√£o foi iniciada com o n√≠vel de isolamento Read Committed.  Mesmo que n√£o tenha nenhum instant√¢neo de dados ativo, ele continua mantendo o horizonte: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  E somente ap√≥s a conclus√£o da transa√ß√£o, o horizonte avan√ßa, o que permite aspirar as tuplas mortas de dist√¢ncia: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  Caso a situa√ß√£o descrita realmente cause problemas e n√£o haja como contornar o problema no n√≠vel do aplicativo, dois par√¢metros estar√£o dispon√≠veis a partir da vers√£o 9.6: <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em> determina a vida √∫til m√°xima da captura instant√¢nea.  Quando esse tempo terminar, o servidor estar√° qualificado para aspirar tuplas mortas e, se uma transa√ß√£o de "reprodu√ß√£o prolongada" ainda precisar delas, receber√° um erro "instant√¢neo muito antigo". </li><li>  <em><code>idle_in_transaction_session_timeout</code></em> determina o tempo de vida m√°ximo de uma transa√ß√£o inativa.  Quando esse tempo termina, a transa√ß√£o √© interrompida. </li></ul><br><h1>  Exporta√ß√£o de instant√¢neo </h1><br>  √Äs vezes, surgem situa√ß√µes em que v√°rias transa√ß√µes simult√¢neas devem ser garantidas para ver os mesmos dados.  Um exemplo √© um utilit√°rio <code>pg_dump</code> , que pode funcionar em modo paralelo: todos os processos de trabalho devem ver o banco de dados no mesmo estado para que a c√≥pia de backup seja consistente. <br><br>  Obviamente, n√£o podemos confiar na cren√ßa de que as transa√ß√µes ver√£o os mesmos dados apenas porque foram iniciadas "simultaneamente".  Para esse fim, a exporta√ß√£o e a importa√ß√£o de um instant√¢neo est√£o dispon√≠veis. <br><br>  A fun√ß√£o <code>pg_export_snapshot</code> retorna o ID da captura instant√¢nea, que pode ser passada para outra transa√ß√£o (usando ferramentas fora do DBMS). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  A outra transa√ß√£o pode importar a captura instant√¢nea usando o comando SET TRANSACTION SNAPSHOT antes de executar sua primeira consulta.  O n√≠vel de isolamento Leitura Repet√≠vel ou Serializ√°vel tamb√©m deve ser especificado antes, pois no n√≠vel Leitura Confirmada, as instru√ß√µes usar√£o seus pr√≥prios instant√¢neos. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  A segunda transa√ß√£o agora funcionar√° com o instant√¢neo da primeira e, portanto, ver√° tr√™s linhas (em vez de zero): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  A vida √∫til de uma captura instant√¢nea exportada √© igual √† vida √∫til da transa√ß√£o de exporta√ß√£o. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479512/">https://habr.com/ru/post/pt479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479498/index.html">Como o tempo linear se transforma no Windows em O (n¬≤)</a></li>
<li><a href="../pt479502/index.html">Como sobreviver √† era glacial mais severa da hist√≥ria da Terra?</a></li>
<li><a href="../pt479504/index.html">Criar um Thin Client RDP baseado em Raspberry Pi</a></li>
<li><a href="../pt479508/index.html">Antipadr√µes do PostgreSQL: JOINs e ORs prejudiciais</a></li>
<li><a href="../pt479510/index.html">Revis√£o do PocketBook X - um enorme leitor de 10,3 polegadas com uma tela E Ink Carta Mobius e uma caixa de metal</a></li>
<li><a href="../pt479514/index.html">Privacidade por design e privacidade por padr√£o (prote√ß√£o de dados projetada e privacidade padr√£o pelo GDPR)</a></li>
<li><a href="../pt479516/index.html">O que √© entropia no software e como gerenci√°-lo?</a></li>
<li><a href="../pt479518/index.html">A comunica√ß√£o dentro de uma equipe remota √© a nossa experi√™ncia</a></li>
<li><a href="../pt479522/index.html">Editora Peter. Venda de inverno</a></li>
<li><a href="../pt479524/index.html">Servi√ßo de Restaura√ß√£o Ativa ou o hist√≥rico de um projeto industrial em Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>