<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏻 🕺🏽 📳 Pruebas estáticas o guardar al soldado Ryan 🧗🏾 🚿 🚼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un lanzamiento a menudo pasa desapercibido. Y cualquier error que se descubrió de repente frente a él nos amenaza con un cambio en los plazos, las rev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas estáticas o guardar al soldado Ryan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/452926/">  Un lanzamiento a menudo pasa desapercibido.  Y cualquier error que se descubrió de repente frente a él nos amenaza con un cambio en los plazos, las revisiones, el trabajo hasta la mañana y los nervios.  Cuando tal apuro comenzó a ocurrir sistemáticamente, nos dimos cuenta de que ya no puedes vivir así.  Se decidió desarrollar un sistema de validación integral para salvar al desarrollador <s>ordinario de Ryan</s> , Artyom, que se fue a su casa antes del lanzamiento a las 9 p.m., a las 10 o a las 11 ... bueno, entiendes.  La idea era que el desarrollador descubriera el error, mientras que los cambios aún no habían llegado al repositorio, y él mismo no había perdido el contexto de la tarea. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/050/6ad/e0c0506adfa607df0102904b82c0d96a.png"></div><br>  Hoy, los cambios realizados se comprueban cuidadosamente primero localmente y luego con una serie de pruebas de integración en la granja de ensamblado.  En este artículo, hablaremos sobre la primera etapa de verificación: pruebas estáticas, que monitorean la corrección de los recursos y analizan el código.  Este es el primer subsistema de la cadena y representa la mayor parte de los errores encontrados. <br><a name="habracut"></a><br><h2>  Como empezó todo </h2><br>  El proceso manual de verificar el juego antes del lanzamiento comenzó en QA una semana y media antes del lanzamiento.  Naturalmente, los errores que se encuentran en esta etapa deben corregirse lo antes posible. <br><br>  Debido a la falta de tiempo para una buena solución, se agrega una "muleta" temporal, que luego se arraiga durante mucho tiempo y está rodeada de otras soluciones no muy populares. <br><br>  En primer lugar, decidimos automatizar el hallazgo de errores evidentes: bloqueos, incapacidad para completar el conjunto principal de acciones para el juego (abrir una tienda, hacer una compra, jugar un nivel).  Para hacer esto, el juego comienza en un modo especial de juego automático y si algo sale mal, lo sabremos inmediatamente después de pasar la prueba en nuestra granja. <br><br>  Pero la mayoría de los errores que encontraron tanto los probadores como nuestra prueba de humo automatizada fueron la falta de un recurso o la configuración incorrecta de diferentes sistemas.  Por lo tanto, el siguiente paso fue <i>la prueba estática</i> : verificar la disponibilidad de recursos, sus relaciones y configuraciones sin iniciar la aplicación.  Este sistema fue lanzado por un paso adicional en la granja de ensamblaje y simplificó enormemente la búsqueda y corrección de errores.  Pero, ¿por qué desperdiciar los recursos de la granja de ensamblados si puede detectar un error incluso antes de confirmar y obtener el código del problema en el repositorio?  Esto se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hacer con ganchos de precompromiso</a> , que se inician antes de que se cree el compromiso y se envíe al repositorio. <br><br>  Y sí, somos tan geniales que las pruebas estáticas antes de comprometerse y en la granja de ensamblados se realizan con un código, lo que simplifica enormemente su soporte. <br><br>  Nuestros esfuerzos se pueden dividir en tres áreas: <br><br><ul><li>  creación de una granja de ensamblaje: el mismo lugar donde se recolectará todo lo que se ha recolectado y verificado; </li><li>  desarrollo de pruebas estáticas: verificar la exactitud de los recursos, sus relaciones, lanzar analizadores de código; </li><li>  desarrollo de pruebas de tiempo de ejecución: lanzamiento de la aplicación en modo de reproducción automática. </li></ul><br>  Una tarea separada era organizar el lanzamiento de pruebas en la máquina del desarrollador.  Era necesario minimizar el tiempo de ejecución localmente (el desarrollador no tiene que esperar 10 minutos para confirmar una línea) y asegurarse de que cada sistema que realiza los cambios tenga instalado nuestro sistema. <br><br><h2>  Muchos requisitos: un sistema </h2><br>  Durante el desarrollo, hay un conjunto completo de ensamblajes que pueden ser útiles: con y sin trampas, beta o alfa, iOS o Android.  En cada caso, se pueden necesitar diferentes recursos, configuraciones o incluso códigos diferentes.  Escribir scripts para pruebas estáticas para cada posible ensamblaje da como resultado un sistema complejo con muchos parámetros.  Además de ser difícil de mantener y modificar, cada proyecto también tiene su propio conjunto de bicicletas con muletas. <br><br>  A través de prueba y error, llegamos a un sistema, cada prueba en la que puede tener en cuenta el contexto de lanzamiento y decidir si ejecutarlo o no, qué exactamente y cómo verificarlo.  Al comienzo de las pruebas, identificamos tres propiedades principales: <br><br><ul><li>  tipo de ensamblaje: para los recursos de liberación y depuración, las verificaciones diferirán en términos de rigor, integridad de la cobertura, así como configuraciones para identificadores y verificación de la funcionalidad disponible; </li><li>  plataforma: lo que es válido para Android puede ser incorrecto para iOS, los recursos también se recopilan de manera diferente y no todos los recursos en la versión de Android estarán en iOS y viceversa; </li><li>  ubicación de lanzamiento: dónde exactamente estamos lanzando: en el agente de compilación donde se necesitan todas las pruebas disponibles o en la computadora del usuario donde se debe minimizar la lista de startups. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e86/9b4/a61/e869b4a61b7f46ba9d545058baa4af5a.png"></div><br><h2>  Sistema de prueba estática </h2><br>  El núcleo del sistema y el conjunto básico de pruebas estáticas se implementan en python.  La base es solo unas pocas entidades: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d09/e44/1fd/d09e441fd62385fb616c3875cdc67a4d.png"></div><br>  <i>El contexto de prueba</i> es un concepto extenso.  Almacena tanto los parámetros de compilación como de lanzamiento, de los que hablamos anteriormente, así como la metainformación que las pruebas llenan y usan. <br><br>  Primero debe comprender qué pruebas ejecutar.  Para esto, la metainformación contiene los tipos de recursos que nos interesan específicamente en este lanzamiento.  Los tipos de recursos están determinados por las pruebas registradas en el sistema.  Una prueba se puede "asociar" con un solo tipo o varios, y si, en el momento de la confirmación, resulta que los archivos que verifica esta prueba han cambiado, entonces el recurso asociado ha cambiado.  Esto se adapta convenientemente a nuestra ideología: ejecutar localmente la menor cantidad de comprobaciones posibles: si los archivos de los que es responsable la prueba no han cambiado, entonces no es necesario ejecutarlos. <br><br>  Por ejemplo, hay una descripción del pez, en la que se indican el modelo 3D y la textura. Si el archivo de descripción ha cambiado, se verifica que el modelo y la textura indicados existen.  En otros casos, no es necesario ejecutar un control de peces. <br><br>  Por otro lado, cambiar un recurso puede requerir cambios y entidades dependiendo de él: si el conjunto de texturas que almacenamos en archivos xml ha cambiado, entonces es necesario verificar modelos 3D adicionales, ya que puede resultar que la textura que necesita se elimine.  Las optimizaciones descritas anteriormente se aplican solo localmente en la máquina del usuario en el momento de la confirmación, y cuando se inicia en la granja de ensamblados, se supone que todos los archivos han cambiado y ejecutamos todas las pruebas. <br><br>  El siguiente problema es la dependencia de algunas pruebas en otras: es imposible verificar el pescado antes de encontrar todas las texturas y modelos.  Por lo tanto, dividimos toda la ejecución en dos etapas: <br><br><ul><li>  preparación de contexto </li><li>  comprobando </li></ul><br>  En la primera etapa, el contexto se llena con información sobre los recursos encontrados (en el caso de los peces, con identificadores de patrones y texturas).  En la segunda etapa, utilizando la información almacenada, simplemente verifique si existe el recurso deseado.  Un contexto simplificado se presenta a continuación. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerificationContext</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, app_path, build_type, platform, changed_files=None)</span></span></span><span class="hljs-function">:</span></span>       self.__app_path = app_path       self.__build_type = build_type       self.__platform = platform       <span class="hljs-comment"><span class="hljs-comment">#          self.__modified_resources = set()       self.__expected_resources = set()       #      ,              self.__changed_files = changed_files       # -  ,          self.__resources = {} def expect_resources(self, resources):   self.__expected_resources.update(resources) def is_resource_expected(self, resource):   return resource in self.__expected_resources def register_resource(self, resource_type, resource_id, resource_data=None):   self.__resources.setdefault(resource_type, {})[resource_id] = resource_data def get_resource(self, resource_type, resource_id):   if resource_type not in self.__resources or resource_id not in self.__resources[resource_type]:       return None, None   return resource_id, self.__resources[resource_type][resource_id]</span></span></code> </pre> <br>  Habiendo determinado todos los parámetros que afectan el lanzamiento de la prueba, logramos ocultar toda la lógica dentro de la clase base.  En una prueba específica, queda por escribir solo la prueba misma y los valores necesarios para los parámetros. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, context, build_types=None, platforms=None, predicate=None,               expected_resources=None, modified_resources=None)</span></span></span><span class="hljs-function">:</span></span>      self.__name = name      self.__context = context      self.__build_types = build_types      self.__platforms = platforms      self.__predicate = predicate      self.__expected_resources = expected_resources      self.__modified_resources = modified_resources      <span class="hljs-comment"><span class="hljs-comment">#               #   ,          self.__need_run = self.__check_run()      self.__need_resource_run = False  @property  def context(self):      return self.__context  def fail(self, message):      print('Fail: {}'.format(message))  def __check_run(self):      build_success = self.__build_types is None or self.__context.build_type in self.__build_types      platform_success = self.__platforms is None or self.__context.platform in self.__platforms      hook_success = build_success      if build_success and self.__context.is_build('hook') and self.__predicate:          hook_success = any(self.__predicate(changed_file) for changed_file in self.__context.changed_files)      return build_success and platform_success and hook_success  def __set_context_resources(self):      if not self.__need_run:          return      if self.__modified_resources:          self.__context.modify_resources(self.__modified_resources)      if self.__expected_resources:          self.__context.expect_resources(self.__expected_resources)   def init(self):      """        ,                    ,          """      self.__need_resource_run = self.__modified_resources and any(self.__context.is_resource_expected(resource) for resource in self.__modified_resources)  def _prepare_impl(self):      pass  def prepare(self):      if not self.__need_run and not self.__need_resource_run:          return      self._prepare_impl()  def _run_impl(self):      pass  def run(self):      if self.__need_run:          self._run_impl()</span></span></code> </pre> <br>  Volviendo al ejemplo de los peces, necesitamos dos pruebas, una de las cuales encuentra texturas y las registra en contexto, la otra busca texturas para los modelos encontrados. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyTexture</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TestCase)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span>      super(VerifyTexture, self).__init__(<span class="hljs-string"><span class="hljs-string">'VerifyTexture'</span></span>, context,                                          build_types=[<span class="hljs-string"><span class="hljs-string">'production'</span></span>, <span class="hljs-string"><span class="hljs-string">'hook'</span></span>],                                          platforms=[<span class="hljs-string"><span class="hljs-string">'windows'</span></span>, <span class="hljs-string"><span class="hljs-string">'ios'</span></span>],                                          expected_resources=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>,                                          modified_resources=[<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>],                                          predicate=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> file_path: os.path.splitext(file_path)[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'.png'</span></span>)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      texture_dir = os.path.join(self.context.app_path, <span class="hljs-string"><span class="hljs-string">'resources'</span></span>, <span class="hljs-string"><span class="hljs-string">'textures'</span></span>)      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, dirs, files <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.walk(texture_dir):          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tex_file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files:              self.context.register_resource(<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>, tex_file) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyModels</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TestCase)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span>      super(VerifyModels, self).__init__(<span class="hljs-string"><span class="hljs-string">'VerifyModels'</span></span>, context,                                         expected_resources=[<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>],                                         predicate=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> file_path: os.path.splitext(file_path)[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'.obj'</span></span>)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_run_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      models_descriptions = etree.parse(os.path.join(self.context.app_path, <span class="hljs-string"><span class="hljs-string">'resources'</span></span>, <span class="hljs-string"><span class="hljs-string">'models.xml'</span></span>))      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model_xml <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> models_descriptions.findall(<span class="hljs-string"><span class="hljs-string">'.//Model'</span></span>):          texture_id = model_xml.get(<span class="hljs-string"><span class="hljs-string">'texture'</span></span>)          texture = self.context.get_resource(<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>, texture_id)          <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> texture <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>:              self.fail(<span class="hljs-string"><span class="hljs-string">'Texture for model {} was not found: {}'</span></span>.format(model_xml.get(<span class="hljs-string"><span class="hljs-string">'id'</span></span>), texture_id))</code> </pre> <br><h2>  Proyecto extendido </h2><br>  El desarrollo del juego en Playrix se lleva a cabo en su propio motor y, en consecuencia, todos los proyectos tienen una estructura de archivo y un código similares utilizando las mismas reglas.  Por lo tanto, hay muchas pruebas generales que se escriben una vez y están en el código general.  Es suficiente que los proyectos actualicen la versión del sistema de prueba y se conecten una nueva prueba. <br><br>  Para simplificar la integración, escribimos un corredor que recibe el archivo de configuración y las pruebas de diseño (sobre ellos más adelante).  El archivo de configuración contiene información básica sobre la que escribimos anteriormente: tipo de ensamblaje, plataforma, ruta al proyecto. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runner</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, config_str, setup_function)</span></span></span><span class="hljs-function">:</span></span>      self.__tests = []      config_parser = RawConfigParser()      config_parser.read_string(config_str)      app_path = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'app_path'</span></span>)      build_type = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'build_type'</span></span>)      platform = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'platform'</span></span>)      <span class="hljs-string"><span class="hljs-string">'''      get_changed_files         CVS      '''</span></span>      changed_files = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> build_type != <span class="hljs-string"><span class="hljs-string">'hook'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> get_changed_files()      self.__context = VerificationContext(app_path, build_type, platform, changed_files)      setup_function(self)  @property  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">context</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__context  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, test)</span></span></span><span class="hljs-function">:</span></span>      self.__tests.append(test)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.init()      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.prepare()      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.run()</code> </pre> <br>  La belleza del archivo de configuración es que se puede generar en la granja de ensamblaje para diferentes ensamblajes en modo automático.  Pero pasar la configuración de todas las pruebas a través de este archivo puede no ser muy conveniente.  Para hacer esto, hay un xml de configuración especial que se almacena en el repositorio del proyecto y se escriben en él listas de archivos ignorados, máscaras para buscar en el código, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de archivo de configuración</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[main] app_path = {app_path} build_type = production platform = ios</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de tuning xml</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifySourceCodepage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">allow_utf8</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">allow_utf8Bom</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">autofix_path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ci/autofix"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IgnoreFiles</span></span></span><span class="hljs-tag">&gt;</span></span>*android/tmp/*<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IgnoreFiles</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifySourceCodepage</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifyCodeStructures</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Checker</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"NsStringConversion"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Checker</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"LogConstructions"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifyCodeStructures</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></div></div><br>  Además de la parte general, los proyectos tienen sus propias peculiaridades y diferencias; por lo tanto, hay conjuntos de pruebas de proyectos que están conectados al sistema a través de la configuración del corredor.  Para el código en los ejemplos, un par de líneas serán suficientes para ejecutar: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(runner)</span></span></span><span class="hljs-function">:</span></span>  runner.add_test(VerifyTexture(runner.context))  runner.add_test(VerifyModels(runner.context)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>  raw_config = <span class="hljs-string"><span class="hljs-string">'''  [main]  app_path = {app_path}  build_type = production  platform = ios  '''</span></span>  runner = Runner(raw_config, setup)  runner.run()</code> </pre> <br><h2>  Rastrillo recogido </h2><br>  Aunque Python en sí es multiplataforma, regularmente tuvimos problemas con el hecho de que los usuarios tienen su propio entorno único, en el que pueden no tener la versión que esperamos, varias versiones o ningún intérprete.  Como resultado, no funciona como esperamos o no funciona en absoluto.  Hubo varias iteraciones para resolver este problema: <br><br><ol><li>  Python y todos los paquetes son instalados por el usuario.  Pero hay dos "peros": no todos los usuarios son programadores y la instalación mediante pip install para diseñadores, y también para programadores, puede ser un problema. </li><li>  Hay un script que instala todos los paquetes necesarios.  Esto ya es mejor, pero si el usuario tiene instalada la python incorrecta, pueden producirse conflictos en el trabajo. </li><li>  Entregar la versión correcta del intérprete y las dependencias del almacenamiento de artefactos (Nexus) y ejecutar pruebas en un entorno virtual. </li></ol><br>  Otro problema es el rendimiento.  Cuantas más pruebas, más tiempo se verifica el cambio en la computadora del usuario.  Cada pocos meses hay un perfil y optimización de cuellos de botella.  Por lo tanto, se mejoró el contexto, apareció un caché para archivos de texto, se mejoraron los mecanismos de predicados (determinando que este archivo es interesante para la prueba). <br><br>  Y luego solo queda resolver el problema de cómo implementar el sistema en todos los proyectos y obligar a todos los desarrolladores a incluir ganchos de segunda mano, pero esta es una historia completamente diferente ... <br><br><h2>  Conclusión </h2><br>  Durante el proceso de desarrollo, bailamos en el rastrillo, luchamos duro, pero aún así obtuvimos un sistema que nos permite encontrar errores durante la confirmación, redujo el trabajo de los probadores y las tareas antes del lanzamiento sobre la falta de textura eran cosa del pasado.  Para una felicidad completa, una configuración simple del entorno y la optimización de las pruebas individuales no son suficientes, pero los golems del departamento de ci trabajan duro en esto. <br><br>  Puede encontrar un ejemplo completo del código utilizado como ejemplos en el artículo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro repositorio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452926/">https://habr.com/ru/post/452926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452910/index.html">Hola Habr! Hola tercon</a></li>
<li><a href="../452914/index.html">ML en Scala con una sonrisa, para aquellos que no tienen miedo a la experimentación</a></li>
<li><a href="../452916/index.html">Levántate y vete. Cirugía de columna: cuándo hacer, qué es peligroso</a></li>
<li><a href="../452922/index.html">Tablas de rejilla CSS flexibles</a></li>
<li><a href="../452924/index.html">Lo que debe hacer para evitar que le roben su cuenta de Google</a></li>
<li><a href="../452928/index.html">Restauramos máquinas virtuales del almacén de datos inicializado erróneamente. La historia de un sinsentido con final feliz</a></li>
<li><a href="../452938/index.html">Las pistolas de la impresora 3D están de vuelta, y ahora ya no se pueden detener.</a></li>
<li><a href="../452942/index.html">GeekBrains celebra 12 reuniones en línea gratuitas con expertos en programación</a></li>
<li><a href="../452944/index.html">¿Cuál será el "Diálogo" de lingüistas y especialistas en análisis de datos?</a></li>
<li><a href="../452946/index.html">Relectura de la filosofía de programación de Windows 95 / NT de Lou Greenaw</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>