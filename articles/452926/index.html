<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游돗游낕 游돜游낗 游닙 Pruebas est치ticas o guardar al soldado Ryan 游븽游 游 游뛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un lanzamiento a menudo pasa desapercibido. Y cualquier error que se descubri칩 de repente frente a 칠l nos amenaza con un cambio en los plazos, las rev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas est치ticas o guardar al soldado Ryan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/452926/">  Un lanzamiento a menudo pasa desapercibido.  Y cualquier error que se descubri칩 de repente frente a 칠l nos amenaza con un cambio en los plazos, las revisiones, el trabajo hasta la ma침ana y los nervios.  Cuando tal apuro comenz칩 a ocurrir sistem치ticamente, nos dimos cuenta de que ya no puedes vivir as칤.  Se decidi칩 desarrollar un sistema de validaci칩n integral para salvar al desarrollador <s>ordinario de Ryan</s> , Artyom, que se fue a su casa antes del lanzamiento a las 9 p.m., a las 10 o a las 11 ... bueno, entiendes.  La idea era que el desarrollador descubriera el error, mientras que los cambios a칰n no hab칤an llegado al repositorio, y 칠l mismo no hab칤a perdido el contexto de la tarea. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/050/6ad/e0c0506adfa607df0102904b82c0d96a.png"></div><br>  Hoy, los cambios realizados se comprueban cuidadosamente primero localmente y luego con una serie de pruebas de integraci칩n en la granja de ensamblado.  En este art칤culo, hablaremos sobre la primera etapa de verificaci칩n: pruebas est치ticas, que monitorean la correcci칩n de los recursos y analizan el c칩digo.  Este es el primer subsistema de la cadena y representa la mayor parte de los errores encontrados. <br><a name="habracut"></a><br><h2>  Como empez칩 todo </h2><br>  El proceso manual de verificar el juego antes del lanzamiento comenz칩 en QA una semana y media antes del lanzamiento.  Naturalmente, los errores que se encuentran en esta etapa deben corregirse lo antes posible. <br><br>  Debido a la falta de tiempo para una buena soluci칩n, se agrega una "muleta" temporal, que luego se arraiga durante mucho tiempo y est치 rodeada de otras soluciones no muy populares. <br><br>  En primer lugar, decidimos automatizar el hallazgo de errores evidentes: bloqueos, incapacidad para completar el conjunto principal de acciones para el juego (abrir una tienda, hacer una compra, jugar un nivel).  Para hacer esto, el juego comienza en un modo especial de juego autom치tico y si algo sale mal, lo sabremos inmediatamente despu칠s de pasar la prueba en nuestra granja. <br><br>  Pero la mayor칤a de los errores que encontraron tanto los probadores como nuestra prueba de humo automatizada fueron la falta de un recurso o la configuraci칩n incorrecta de diferentes sistemas.  Por lo tanto, el siguiente paso fue <i>la prueba est치tica</i> : verificar la disponibilidad de recursos, sus relaciones y configuraciones sin iniciar la aplicaci칩n.  Este sistema fue lanzado por un paso adicional en la granja de ensamblaje y simplific칩 enormemente la b칰squeda y correcci칩n de errores.  Pero, 쯣or qu칠 desperdiciar los recursos de la granja de ensamblados si puede detectar un error incluso antes de confirmar y obtener el c칩digo del problema en el repositorio?  Esto se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hacer con ganchos de precompromiso</a> , que se inician antes de que se cree el compromiso y se env칤e al repositorio. <br><br>  Y s칤, somos tan geniales que las pruebas est치ticas antes de comprometerse y en la granja de ensamblados se realizan con un c칩digo, lo que simplifica enormemente su soporte. <br><br>  Nuestros esfuerzos se pueden dividir en tres 치reas: <br><br><ul><li>  creaci칩n de una granja de ensamblaje: el mismo lugar donde se recolectar치 todo lo que se ha recolectado y verificado; </li><li>  desarrollo de pruebas est치ticas: verificar la exactitud de los recursos, sus relaciones, lanzar analizadores de c칩digo; </li><li>  desarrollo de pruebas de tiempo de ejecuci칩n: lanzamiento de la aplicaci칩n en modo de reproducci칩n autom치tica. </li></ul><br>  Una tarea separada era organizar el lanzamiento de pruebas en la m치quina del desarrollador.  Era necesario minimizar el tiempo de ejecuci칩n localmente (el desarrollador no tiene que esperar 10 minutos para confirmar una l칤nea) y asegurarse de que cada sistema que realiza los cambios tenga instalado nuestro sistema. <br><br><h2>  Muchos requisitos: un sistema </h2><br>  Durante el desarrollo, hay un conjunto completo de ensamblajes que pueden ser 칰tiles: con y sin trampas, beta o alfa, iOS o Android.  En cada caso, se pueden necesitar diferentes recursos, configuraciones o incluso c칩digos diferentes.  Escribir scripts para pruebas est치ticas para cada posible ensamblaje da como resultado un sistema complejo con muchos par치metros.  Adem치s de ser dif칤cil de mantener y modificar, cada proyecto tambi칠n tiene su propio conjunto de bicicletas con muletas. <br><br>  A trav칠s de prueba y error, llegamos a un sistema, cada prueba en la que puede tener en cuenta el contexto de lanzamiento y decidir si ejecutarlo o no, qu칠 exactamente y c칩mo verificarlo.  Al comienzo de las pruebas, identificamos tres propiedades principales: <br><br><ul><li>  tipo de ensamblaje: para los recursos de liberaci칩n y depuraci칩n, las verificaciones diferir치n en t칠rminos de rigor, integridad de la cobertura, as칤 como configuraciones para identificadores y verificaci칩n de la funcionalidad disponible; </li><li>  plataforma: lo que es v치lido para Android puede ser incorrecto para iOS, los recursos tambi칠n se recopilan de manera diferente y no todos los recursos en la versi칩n de Android estar치n en iOS y viceversa; </li><li>  ubicaci칩n de lanzamiento: d칩nde exactamente estamos lanzando: en el agente de compilaci칩n donde se necesitan todas las pruebas disponibles o en la computadora del usuario donde se debe minimizar la lista de startups. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e86/9b4/a61/e869b4a61b7f46ba9d545058baa4af5a.png"></div><br><h2>  Sistema de prueba est치tica </h2><br>  El n칰cleo del sistema y el conjunto b치sico de pruebas est치ticas se implementan en python.  La base es solo unas pocas entidades: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d09/e44/1fd/d09e441fd62385fb616c3875cdc67a4d.png"></div><br>  <i>El contexto de prueba</i> es un concepto extenso.  Almacena tanto los par치metros de compilaci칩n como de lanzamiento, de los que hablamos anteriormente, as칤 como la metainformaci칩n que las pruebas llenan y usan. <br><br>  Primero debe comprender qu칠 pruebas ejecutar.  Para esto, la metainformaci칩n contiene los tipos de recursos que nos interesan espec칤ficamente en este lanzamiento.  Los tipos de recursos est치n determinados por las pruebas registradas en el sistema.  Una prueba se puede "asociar" con un solo tipo o varios, y si, en el momento de la confirmaci칩n, resulta que los archivos que verifica esta prueba han cambiado, entonces el recurso asociado ha cambiado.  Esto se adapta convenientemente a nuestra ideolog칤a: ejecutar localmente la menor cantidad de comprobaciones posibles: si los archivos de los que es responsable la prueba no han cambiado, entonces no es necesario ejecutarlos. <br><br>  Por ejemplo, hay una descripci칩n del pez, en la que se indican el modelo 3D y la textura. Si el archivo de descripci칩n ha cambiado, se verifica que el modelo y la textura indicados existen.  En otros casos, no es necesario ejecutar un control de peces. <br><br>  Por otro lado, cambiar un recurso puede requerir cambios y entidades dependiendo de 칠l: si el conjunto de texturas que almacenamos en archivos xml ha cambiado, entonces es necesario verificar modelos 3D adicionales, ya que puede resultar que la textura que necesita se elimine.  Las optimizaciones descritas anteriormente se aplican solo localmente en la m치quina del usuario en el momento de la confirmaci칩n, y cuando se inicia en la granja de ensamblados, se supone que todos los archivos han cambiado y ejecutamos todas las pruebas. <br><br>  El siguiente problema es la dependencia de algunas pruebas en otras: es imposible verificar el pescado antes de encontrar todas las texturas y modelos.  Por lo tanto, dividimos toda la ejecuci칩n en dos etapas: <br><br><ul><li>  preparaci칩n de contexto </li><li>  comprobando </li></ul><br>  En la primera etapa, el contexto se llena con informaci칩n sobre los recursos encontrados (en el caso de los peces, con identificadores de patrones y texturas).  En la segunda etapa, utilizando la informaci칩n almacenada, simplemente verifique si existe el recurso deseado.  Un contexto simplificado se presenta a continuaci칩n. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerificationContext</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, app_path, build_type, platform, changed_files=None)</span></span></span><span class="hljs-function">:</span></span>       self.__app_path = app_path       self.__build_type = build_type       self.__platform = platform       <span class="hljs-comment"><span class="hljs-comment">#          self.__modified_resources = set()       self.__expected_resources = set()       #      ,              self.__changed_files = changed_files       # -  ,          self.__resources = {} def expect_resources(self, resources):   self.__expected_resources.update(resources) def is_resource_expected(self, resource):   return resource in self.__expected_resources def register_resource(self, resource_type, resource_id, resource_data=None):   self.__resources.setdefault(resource_type, {})[resource_id] = resource_data def get_resource(self, resource_type, resource_id):   if resource_type not in self.__resources or resource_id not in self.__resources[resource_type]:       return None, None   return resource_id, self.__resources[resource_type][resource_id]</span></span></code> </pre> <br>  Habiendo determinado todos los par치metros que afectan el lanzamiento de la prueba, logramos ocultar toda la l칩gica dentro de la clase base.  En una prueba espec칤fica, queda por escribir solo la prueba misma y los valores necesarios para los par치metros. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, context, build_types=None, platforms=None, predicate=None,               expected_resources=None, modified_resources=None)</span></span></span><span class="hljs-function">:</span></span>      self.__name = name      self.__context = context      self.__build_types = build_types      self.__platforms = platforms      self.__predicate = predicate      self.__expected_resources = expected_resources      self.__modified_resources = modified_resources      <span class="hljs-comment"><span class="hljs-comment">#               #   ,          self.__need_run = self.__check_run()      self.__need_resource_run = False  @property  def context(self):      return self.__context  def fail(self, message):      print('Fail: {}'.format(message))  def __check_run(self):      build_success = self.__build_types is None or self.__context.build_type in self.__build_types      platform_success = self.__platforms is None or self.__context.platform in self.__platforms      hook_success = build_success      if build_success and self.__context.is_build('hook') and self.__predicate:          hook_success = any(self.__predicate(changed_file) for changed_file in self.__context.changed_files)      return build_success and platform_success and hook_success  def __set_context_resources(self):      if not self.__need_run:          return      if self.__modified_resources:          self.__context.modify_resources(self.__modified_resources)      if self.__expected_resources:          self.__context.expect_resources(self.__expected_resources)   def init(self):      """        ,                    ,          """      self.__need_resource_run = self.__modified_resources and any(self.__context.is_resource_expected(resource) for resource in self.__modified_resources)  def _prepare_impl(self):      pass  def prepare(self):      if not self.__need_run and not self.__need_resource_run:          return      self._prepare_impl()  def _run_impl(self):      pass  def run(self):      if self.__need_run:          self._run_impl()</span></span></code> </pre> <br>  Volviendo al ejemplo de los peces, necesitamos dos pruebas, una de las cuales encuentra texturas y las registra en contexto, la otra busca texturas para los modelos encontrados. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyTexture</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TestCase)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span>      super(VerifyTexture, self).__init__(<span class="hljs-string"><span class="hljs-string">'VerifyTexture'</span></span>, context,                                          build_types=[<span class="hljs-string"><span class="hljs-string">'production'</span></span>, <span class="hljs-string"><span class="hljs-string">'hook'</span></span>],                                          platforms=[<span class="hljs-string"><span class="hljs-string">'windows'</span></span>, <span class="hljs-string"><span class="hljs-string">'ios'</span></span>],                                          expected_resources=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>,                                          modified_resources=[<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>],                                          predicate=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> file_path: os.path.splitext(file_path)[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'.png'</span></span>)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      texture_dir = os.path.join(self.context.app_path, <span class="hljs-string"><span class="hljs-string">'resources'</span></span>, <span class="hljs-string"><span class="hljs-string">'textures'</span></span>)      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, dirs, files <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.walk(texture_dir):          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tex_file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files:              self.context.register_resource(<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>, tex_file) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyModels</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TestCase)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span>      super(VerifyModels, self).__init__(<span class="hljs-string"><span class="hljs-string">'VerifyModels'</span></span>, context,                                         expected_resources=[<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>],                                         predicate=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> file_path: os.path.splitext(file_path)[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'.obj'</span></span>)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_run_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      models_descriptions = etree.parse(os.path.join(self.context.app_path, <span class="hljs-string"><span class="hljs-string">'resources'</span></span>, <span class="hljs-string"><span class="hljs-string">'models.xml'</span></span>))      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model_xml <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> models_descriptions.findall(<span class="hljs-string"><span class="hljs-string">'.//Model'</span></span>):          texture_id = model_xml.get(<span class="hljs-string"><span class="hljs-string">'texture'</span></span>)          texture = self.context.get_resource(<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>, texture_id)          <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> texture <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>:              self.fail(<span class="hljs-string"><span class="hljs-string">'Texture for model {} was not found: {}'</span></span>.format(model_xml.get(<span class="hljs-string"><span class="hljs-string">'id'</span></span>), texture_id))</code> </pre> <br><h2>  Proyecto extendido </h2><br>  El desarrollo del juego en Playrix se lleva a cabo en su propio motor y, en consecuencia, todos los proyectos tienen una estructura de archivo y un c칩digo similares utilizando las mismas reglas.  Por lo tanto, hay muchas pruebas generales que se escriben una vez y est치n en el c칩digo general.  Es suficiente que los proyectos actualicen la versi칩n del sistema de prueba y se conecten una nueva prueba. <br><br>  Para simplificar la integraci칩n, escribimos un corredor que recibe el archivo de configuraci칩n y las pruebas de dise침o (sobre ellos m치s adelante).  El archivo de configuraci칩n contiene informaci칩n b치sica sobre la que escribimos anteriormente: tipo de ensamblaje, plataforma, ruta al proyecto. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runner</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, config_str, setup_function)</span></span></span><span class="hljs-function">:</span></span>      self.__tests = []      config_parser = RawConfigParser()      config_parser.read_string(config_str)      app_path = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'app_path'</span></span>)      build_type = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'build_type'</span></span>)      platform = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'platform'</span></span>)      <span class="hljs-string"><span class="hljs-string">'''      get_changed_files         CVS      '''</span></span>      changed_files = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> build_type != <span class="hljs-string"><span class="hljs-string">'hook'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> get_changed_files()      self.__context = VerificationContext(app_path, build_type, platform, changed_files)      setup_function(self)  @property  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">context</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__context  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, test)</span></span></span><span class="hljs-function">:</span></span>      self.__tests.append(test)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.init()      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.prepare()      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.run()</code> </pre> <br>  La belleza del archivo de configuraci칩n es que se puede generar en la granja de ensamblaje para diferentes ensamblajes en modo autom치tico.  Pero pasar la configuraci칩n de todas las pruebas a trav칠s de este archivo puede no ser muy conveniente.  Para hacer esto, hay un xml de configuraci칩n especial que se almacena en el repositorio del proyecto y se escriben en 칠l listas de archivos ignorados, m치scaras para buscar en el c칩digo, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de archivo de configuraci칩n</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[main] app_path = {app_path} build_type = production platform = ios</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de tuning xml</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifySourceCodepage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">allow_utf8</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">allow_utf8Bom</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">autofix_path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ci/autofix"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IgnoreFiles</span></span></span><span class="hljs-tag">&gt;</span></span>*android/tmp/*<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IgnoreFiles</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifySourceCodepage</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifyCodeStructures</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Checker</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"NsStringConversion"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Checker</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"LogConstructions"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifyCodeStructures</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></div></div><br>  Adem치s de la parte general, los proyectos tienen sus propias peculiaridades y diferencias; por lo tanto, hay conjuntos de pruebas de proyectos que est치n conectados al sistema a trav칠s de la configuraci칩n del corredor.  Para el c칩digo en los ejemplos, un par de l칤neas ser치n suficientes para ejecutar: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(runner)</span></span></span><span class="hljs-function">:</span></span>  runner.add_test(VerifyTexture(runner.context))  runner.add_test(VerifyModels(runner.context)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>  raw_config = <span class="hljs-string"><span class="hljs-string">'''  [main]  app_path = {app_path}  build_type = production  platform = ios  '''</span></span>  runner = Runner(raw_config, setup)  runner.run()</code> </pre> <br><h2>  Rastrillo recogido </h2><br>  Aunque Python en s칤 es multiplataforma, regularmente tuvimos problemas con el hecho de que los usuarios tienen su propio entorno 칰nico, en el que pueden no tener la versi칩n que esperamos, varias versiones o ning칰n int칠rprete.  Como resultado, no funciona como esperamos o no funciona en absoluto.  Hubo varias iteraciones para resolver este problema: <br><br><ol><li>  Python y todos los paquetes son instalados por el usuario.  Pero hay dos "peros": no todos los usuarios son programadores y la instalaci칩n mediante pip install para dise침adores, y tambi칠n para programadores, puede ser un problema. </li><li>  Hay un script que instala todos los paquetes necesarios.  Esto ya es mejor, pero si el usuario tiene instalada la python incorrecta, pueden producirse conflictos en el trabajo. </li><li>  Entregar la versi칩n correcta del int칠rprete y las dependencias del almacenamiento de artefactos (Nexus) y ejecutar pruebas en un entorno virtual. </li></ol><br>  Otro problema es el rendimiento.  Cuantas m치s pruebas, m치s tiempo se verifica el cambio en la computadora del usuario.  Cada pocos meses hay un perfil y optimizaci칩n de cuellos de botella.  Por lo tanto, se mejor칩 el contexto, apareci칩 un cach칠 para archivos de texto, se mejoraron los mecanismos de predicados (determinando que este archivo es interesante para la prueba). <br><br>  Y luego solo queda resolver el problema de c칩mo implementar el sistema en todos los proyectos y obligar a todos los desarrolladores a incluir ganchos de segunda mano, pero esta es una historia completamente diferente ... <br><br><h2>  Conclusi칩n </h2><br>  Durante el proceso de desarrollo, bailamos en el rastrillo, luchamos duro, pero a칰n as칤 obtuvimos un sistema que nos permite encontrar errores durante la confirmaci칩n, redujo el trabajo de los probadores y las tareas antes del lanzamiento sobre la falta de textura eran cosa del pasado.  Para una felicidad completa, una configuraci칩n simple del entorno y la optimizaci칩n de las pruebas individuales no son suficientes, pero los golems del departamento de ci trabajan duro en esto. <br><br>  Puede encontrar un ejemplo completo del c칩digo utilizado como ejemplos en el art칤culo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro repositorio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452926/">https://habr.com/ru/post/452926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452910/index.html">Hola Habr! Hola tercon</a></li>
<li><a href="../452914/index.html">ML en Scala con una sonrisa, para aquellos que no tienen miedo a la experimentaci칩n</a></li>
<li><a href="../452916/index.html">Lev치ntate y vete. Cirug칤a de columna: cu치ndo hacer, qu칠 es peligroso</a></li>
<li><a href="../452922/index.html">Tablas de rejilla CSS flexibles</a></li>
<li><a href="../452924/index.html">Lo que debe hacer para evitar que le roben su cuenta de Google</a></li>
<li><a href="../452928/index.html">Restauramos m치quinas virtuales del almac칠n de datos inicializado err칩neamente. La historia de un sinsentido con final feliz</a></li>
<li><a href="../452938/index.html">Las pistolas de la impresora 3D est치n de vuelta, y ahora ya no se pueden detener.</a></li>
<li><a href="../452942/index.html">GeekBrains celebra 12 reuniones en l칤nea gratuitas con expertos en programaci칩n</a></li>
<li><a href="../452944/index.html">쮺u치l ser치 el "Di치logo" de ling칲istas y especialistas en an치lisis de datos?</a></li>
<li><a href="../452946/index.html">Relectura de la filosof칤a de programaci칩n de Windows 95 / NT de Lou Greenaw</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>