<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéØ üññ üòí OS1: Ein primitiver Kernel auf Rust f√ºr x86. Teil 2. VGA, GDT, IDT üëª üíà ü§µüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erster Teil 


 Der erste Artikel hatte noch keine Zeit zum Abk√ºhlen, aber ich habe beschlossen, Sie nicht zu faszinieren und eine Fortsetzung zu schr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: Ein primitiver Kernel auf Rust f√ºr x86. Teil 2. VGA, GDT, IDT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445584/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a> </p><br><p>  Der erste Artikel hatte noch keine Zeit zum Abk√ºhlen, aber ich habe beschlossen, Sie nicht zu faszinieren und eine Fortsetzung zu schreiben. </p><br><p>  Im vorherigen Artikel haben wir √ºber das Verkn√ºpfen, Laden der Kerneldatei und die prim√§re Initialisierung gesprochen.  Ich gab einige n√ºtzliche Links, erkl√§rte, wie sich der geladene Kernel im Speicher befindet, wie virtuelle und physische Adressen beim Booten verglichen werden und wie die Unterst√ºtzung f√ºr den Seitenmechanismus aktiviert wird.  Zuletzt ging die Kontrolle auf die in Rust geschriebene kmain-Funktion meines Kernels √ºber.  Es ist Zeit weiterzumachen und herauszufinden, wie tief das Kaninchenloch ist! </p><br><p>  In diesem Teil der Hinweise <strong>werde</strong> ich <strong>kurz meine Rust-Konfiguration beschreiben, allgemein √ºber die Ausgabe von Informationen in VGA und ausf√ºhrlich √ºber das Einrichten von Segmenten und Interrupts sprechen</strong> .  Ich frage alle Interessierten unter dem Schnitt, und wir fangen an. </p><a name="habracut"></a><br><h1 id="nastroyka-rust">  Rostaufbau </h1><br><p> Im Allgemeinen ist dieses Verfahren nicht besonders kompliziert. Einzelheiten erfahren Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philippe-Blog</a> .  Ich werde jedoch an einigen Stellen aufh√∂ren. </p><br><p>  Stable Rust unterst√ºtzt einige Funktionen, die f√ºr die Entwicklung auf niedriger Ebene erforderlich sind, immer noch nicht. Um die Standardbibliothek zu deaktivieren und auf Bare Bones aufzubauen, ben√∂tigen wir Rust Nightly.  Seien Sie vorsichtig, einmal nach dem Update auf den neuesten Stand bekam ich einen v√∂llig funktionsunf√§higen Compiler und musste zum n√§chsten stabilen zur√ºcksetzen.  Wenn Sie sicher sind, dass Ihr Compiler gestern funktioniert hat, aber aktualisiert wurde und nicht funktioniert, f√ºhren Sie den Befehl aus und ersetzen Sie das gew√ºnschte Datum </p><br><pre><code class="plaintext hljs">rustup override add nightly-YYYY-MM-DD</code> </pre> <br><p>  Einzelheiten zum Mechanismus erhalten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Konfigurieren Sie als N√§chstes die Zielplattform, f√ºr die wir gehen.  Ich basierte auf dem Blog von Philip Opperman, so dass viele der Dinge in diesem Abschnitt von ihm genommen, von Knochen zerlegt und an meine Bed√ºrfnisse angepasst wurden.  Philip entwickelt in seinem Blog f√ºr x64, ich habe urspr√ºnglich x32 gew√§hlt, daher wird meine target.json etwas anders sein.  Ich bringe es komplett </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"llvm-target"</span></span>: <span class="hljs-string"><span class="hljs-string">"i686-unknown-none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"data-layout"</span></span>: <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-f64:32:64-f80:32-n8:16:32-S128"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"x86"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-endian"</span></span>: <span class="hljs-string"><span class="hljs-string">"little"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-pointer-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-c-int-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"os"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"executables"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker-flavor"</span></span>: <span class="hljs-string"><span class="hljs-string">"ld.lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker"</span></span>: <span class="hljs-string"><span class="hljs-string">"rust-lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"panic-strategy"</span></span>: <span class="hljs-string"><span class="hljs-string">"abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"disable-redzone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"features"</span></span>: <span class="hljs-string"><span class="hljs-string">"-mmx,-sse,+soft-float"</span></span> }</code> </pre> <br><p>  Der schwierigste Teil hier ist der Parameter ‚Äû <strong>Datenlayout</strong> ‚Äú.  Aus der LLVM-Dokumentation geht hervor, dass es sich um Datenlayoutoptionen handelt, die durch ‚Äû-‚Äú getrennt sind.  Das allererste "e" -Zeichen ist f√ºr die Indianit√§t verantwortlich - in unserem Fall ist es Little-Endian, wie es die Plattform erfordert.  Das zweite Zeichen ist m, "Verzerrung".  Verantwortlich f√ºr Charakternamen w√§hrend des Layouts.  Da unser Ausgabeformat ELF ist (siehe Build-Skript), w√§hlen wir "m: e".  Das dritte Zeichen ist die Gr√∂√üe des Zeigers in Bit und ABI (Application Binary Interface).  Hier ist alles einfach, wir haben 32 Bits, also setzen wir mutig ‚Äûp: 32: 32‚Äú.  Als n√§chstes kommen Gleitkommazahlen.  Wir berichten, dass wir 64-Bit-Nummern gem√§√ü ABI 32 mit Ausrichtung 64 - ‚Äûf64: 32: 64‚Äú sowie 80-Bit-Nummern mit standardm√§√üiger Ausrichtung - ‚Äûf80: 32‚Äú unterst√ºtzen.  Das n√§chste Element sind Ganzzahlen.  Wir beginnen mit 8 Bit und gehen zum Plattformmaximum von 32 Bit √ºber - ‚Äûn8: 16: 32‚Äú.  Der letzte ist die Stapelausrichtung.  Ich brauche sogar 128-Bit-Ganzzahlen, also sei es S128.  In jedem Fall kann LLVM diesen Parameter ignorieren. Dies ist unsere Pr√§ferenz. </p><br><p>  In Bezug auf die restlichen Parameter k√∂nnen Sie einen Blick auf Philip werfen, er erkl√§rt alles gut. </p><br><p>  Wir brauchen auch Cargo-Xbuild - ein Tool, mit dem Sie den Rostkern beim Bauen unter einer unbekannten Zielplattform √ºberkompilieren k√∂nnen. <br>  Installieren. </p><br><pre> <code class="bash hljs">cargo install cargo-xbuild</code> </pre> <br><p>  Wir werden es so sammeln. </p><br><pre> <code class="bash hljs">cargo xbuild -Z unstable-options --manifest-path=kernel/Cargo.toml --target kernel/targets/$(ARCH).json --out-dir=build/lib</code> </pre> <br><p>  Ich brauchte ein Manifest f√ºr die korrekte Operation von Make, da es vom Stammverzeichnis ausgeht und der Kernel im Kernelverzeichnis liegt. </p><br><p>  Von den Funktionen des Manifests kann ich nur <em>crate-type = ["staticlib"] hervorheben</em> , wodurch eine verlinkbare Datei zur Ausgabe erstellt wird.  Wir werden ihn in LLD f√ºttern. </p><br><h1 id="kmain-i-pervonachalnaya-nastroyka">  kmain und Ersteinrichtung </h1><br><p>  Wenn wir gem√§√ü den Rust-Konventionen eine statische Bibliothek (oder eine ‚Äûflache‚Äú Bin√§rdatei) erstellen, muss das Stammverzeichnis der Kiste die Datei lib.rs enthalten, die der Einstiegspunkt ist.  Darin werden mithilfe von Attributen Sprachfunktionen konfiguriert und auch der gesch√§tzte kmain gefunden. </p><br><p>  Im ersten Schritt m√ºssen wir also die Standardbibliothek deaktivieren.  Dies geschieht mit einem Makro. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span></code> </pre> <br><p>  Mit einem so einfachen Schritt vergessen wir sofort Multithreading, dynamischen Speicher und andere Freuden der Standardbibliothek.  Dar√ºber hinaus berauben wir uns sogar des println !, Makros, sodass wir es selbst implementieren m√ºssen.  Ich werde dir sagen, wie es das n√§chste Mal geht. </p><br><p>  Viele Tutorials irgendwo an diesem Ort enden mit der Ausgabe von ‚ÄûHello World‚Äú und ohne zu erkl√§ren, wie man davon lebt.  Wir werden den anderen Weg gehen.  Zun√§chst m√ºssen wir Code- und Datensegmente f√ºr den gesch√ºtzten Modus festlegen, VGA konfigurieren und Interrupts konfigurieren, was wir tun werden. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> debug; <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[path = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arch/i686/mod.rs"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> arch; <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmain</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_magic: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { arch::arch_init(pd); ...... } <span class="hljs-meta"><span class="hljs-meta">#[panic_handler]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panic</span></span></span></span>(_info: &amp;PanicInfo) -&gt; ! { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, _info); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> {} }</code> </pre> <br><p>  Was ist hier los?  Wie gesagt, wir schalten die Standardbibliothek aus.  Wir werden auch zwei sehr wichtige Module ank√ºndigen - Debug (in dem wir auf dem Bildschirm schreiben werden) und Arch (in dem alle plattformabh√§ngige Magie leben wird).  Ich verwende die Rust-Funktion mit Konfigurationen, um dieselben Schnittstellen in verschiedenen Architekturimplementierungen zu deklarieren und sie in vollem Umfang zu nutzen.  Hier h√∂re ich nur auf x86 auf und dann reden wir nur dar√ºber. </p><br><p>  Ich erkl√§rte einen v√∂llig primitiven Panikhandler, den Rust ben√∂tigt.  Dann kann es ge√§ndert werden. </p><br><p>  kmain akzeptiert drei Argumente und wird auch in C-Notation ohne Namensverzerrung exportiert, damit der Linker die Funktion korrekt mit dem Aufruf von _loader verkn√ºpfen kann, den ich im vorherigen Artikel beschrieben habe.  Das erste Argument ist die Adresse der PD-Seitentabelle, das zweite ist die <strong>physikalische</strong> Adresse der GRUB-Struktur, von der wir die Speicherkarte erhalten, das dritte ist die magische Zahl.  In Zukunft m√∂chte ich sowohl die Multiboot 2-Unterst√ºtzung als auch meinen eigenen Bootloader implementieren, daher verwende ich eine magische Zahl, um die Bootmethode zu identifizieren. </p><br><p>  Der erste kmain-Aufruf ist die plattformspezifische Initialisierung.  Wir gehen hinein.  Die Funktion arch_init befindet sich in der Datei arch / i686 / mod.rs, ist √∂ffentlich, 32-Bit x86-spezifisch und sieht folgenderma√üen aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arch_init</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { vga::VGA_WRITER.lock().init(); gdt::setup_gdt(); idt::init_idt(); paging::setup_pd(pd); } }</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, werden f√ºr x86 Ausgabe, Segmentierung, Interrupts und Paging der Reihe nach initialisiert.  Beginnen wir mit VGA. </p><br><h1 id="inicializaciya-vga">  VGA-Initialisierung </h1><br><p>  Jedes Tutorial sieht es als seine Pflicht an, Hello World zu drucken, sodass Sie √ºberall erfahren, wie Sie mit VGA arbeiten.  Aus diesem Grund werde ich so kurz wie m√∂glich gehen, ich werde mich nur auf die Chips konzentrieren, die ich selbst gemacht habe.  √úber die Verwendung von lazy_static werde ich Sie zu Philippes Blog schicken und nicht im Detail erkl√§ren.  const fn ist noch nicht in der Version, daher k√∂nnen noch keine statischen Initialisierungen durchgef√ºhrt werden.  Und wir werden eine Drehsperre hinzuf√ºgen, damit es sich nicht als Chaos herausstellt. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> VGA_WRITER : Mutex&lt;Writer&gt; = Mutex::new(Writer { cursor_position: <span class="hljs-number"><span class="hljs-number">0</span></span>, vga_color: ColorCode::new(Color::LightGray, Color::Black), buffer: <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC00B8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer) } }); }</code> </pre> <br><p>  Wie Sie wissen, befindet sich der Bildschirmpuffer an der physischen Adresse 0xB8000 und hat eine Gr√∂√üe von 80x25x2 Byte (Breite und H√∂he des Bildschirms, Byte pro Zeichen und Attribute: Farben, Flimmern).  Da wir den virtuellen Speicher bereits aktiviert haben, st√ºrzt der Zugriff auf diese Adresse ab, sodass wir 3 GB hinzuf√ºgen.  Wir dereferenzieren auch einen rohen Zeiger, der unsicher ist - aber wir wissen, was wir tun. <br>  Von den interessanten Dingen in dieser Datei ist vielleicht nur die Implementierung der Writer-Struktur, die es nicht nur erm√∂glicht, Zeichen in einer Reihe anzuzeigen, sondern auch zu scrollen, an eine beliebige Stelle auf dem Bildschirm zu gehen und andere nette kleine Dinge. </p><br><div class="spoiler">  <b class="spoiler_title">Vga Schriftsteller</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span></span> { cursor_position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, vga_color: ColorCode, buffer: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Writer { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vga_color = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code: vga_color, } } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor_abs</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0F</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D5</span></span>, (position &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0E</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, ((position &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = position; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(y * VGA_WIDTH + x); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position + offset; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position % VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_y</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position / VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scroll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color_code = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ln</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_line = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_y() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next_line &gt;= VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, next_line) } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_xy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_pos</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[position] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position &gt;= VGA_WIDTH * VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte_at_pos(byte, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.move_cursor(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s.bytes() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> byte { <span class="hljs-number"><span class="hljs-number">0x20</span></span>...<span class="hljs-number"><span class="hljs-number">0xFF</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(byte), <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ln(), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(<span class="hljs-number"><span class="hljs-number">0xfe</span></span>), } } } }</code> </pre> </div></div><br><p>  Beim Zur√ºckspulen kopieren Sie einfach Speicherbereiche in der Gr√∂√üe der Bildschirmbreite nach hinten und f√ºllen eine neue Zeile mit Leerzeichen aus (so mache ich die Reinigung).  Outb-Aufrufe sind etwas interessanter - auf keine andere Weise als mit E / A-Ports zu arbeiten, ist es unm√∂glich, den Cursor zu bewegen.  Wir ben√∂tigen jedoch weiterhin Eingabe / Ausgabe √ºber Ports, sodass diese in einem separaten Paket geliefert und in sichere Wrapper verpackt wurden.  Unter dem Spoiler befindet sich der Assembler-Code.  Im Moment reicht es zu wissen, dass: </p><br><ul><li>  Der absolute Cursorversatz, nicht die Koordinate, wird angezeigt. </li><li>  Sie k√∂nnen jeweils ein Byte an den Controller ausgeben </li><li>  Die Ausgabe eines Bytes erfolgt in zwei Befehlen - zuerst schreiben wir den Befehl in die Steuerung, dann die Daten. </li><li>  Der Port f√ºr Befehle ist 0x3D4, der Datenport ist 0x3D5 </li><li>  Drucken Sie zuerst das untere Byte der Position mit dem Befehl 0x0F und dann das obere mit dem Befehl 0x0E </li></ul><br><div class="spoiler">  <b class="spoiler_title">out.asm</b> <div class="spoiler_text"><p>  Achten Sie darauf, mit √ºbergebenen Variablen auf dem Stapel zu arbeiten.  Da der Stapel am Ende des Leerzeichens beginnt und den Stapelzeiger beim Aufrufen der Funktion reduziert, um Parameter, einen R√ºckgabepunkt usw. abzurufen, m√ºssen Sie die mit der Stapelausrichtung ausgerichtete Argumentgr√∂√üe zum ESP-Register hinzuf√ºgen, in unserem Fall 4 Byte. </p><br><pre> <code class="plaintext hljs">global writeb global writew global writed section .text writeb: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 byte value aligned 4 bytes out dx, al ;write byte by port number an dx - value in al mov esp, ebp pop ebp ret writew: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 word value aligned 4 bytes out dx, ax ;write word by port number an dx - value in ax mov esp, ebp pop ebp ret writed: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 double word value aligned 4 bytes out dx, eax ;write double word by port number an dx - value in eax mov esp, ebp pop ebp ret</code> </pre> </div></div><br><h1 id="nastroyka-segmentov">  Segmenteinrichtung </h1><br><p>  Wir kamen zum r√§tselhaftesten, aber gleichzeitig einfachsten Thema.  Wie ich in einem fr√ºheren Artikel sagte, war die Seiten- und Segmentorganisation des Speichers in meinem Kopf gemischt, ich lud die Adresse der Seitentabelle in die GDTR und packte meinen Kopf.  Ich habe mehrere Monate gebraucht, um das Material ausreichend zu lesen, es zu verdauen und es zu realisieren.  Ich bin m√∂glicherweise Opfer von Peter Abels Lehrbuch Assembler geworden.  Die Sprache und Programmierung f√ºr den IBM PC ‚Äú(ein gro√üartiges Buch!), In dem die Segmentierung f√ºr den Intel 8086 beschrieben wird. In diesen angenehmen Zeiten haben wir die oberen 16 Bits einer 20-Bit-Adresse in das Segmentregister geladen, und das war die Adresse im Speicher.  Es stellte sich als grausame Entt√§uschung heraus, dass ab i286 im gesch√ºtzten Modus alles v√∂llig falsch ist. </p><br><p>  Die blo√üe Theorie ist also, dass x86 ein segmentiertes Speichermodell unterst√ºtzt, da √§ltere Programme nur √ºber 640 KB und dann 1 MB Speicher hinaus ausbrechen konnten. </p><br><p>  Programmierer mussten dar√ºber nachdenken, wie sie ausf√ºhrbaren Code platzieren, wie sie Daten platzieren und wie sie ihre Sicherheit gew√§hrleisten k√∂nnen.  Das Aufkommen der Seitenorganisation machte eine segmentierte Organisation unn√∂tig, blieb jedoch aus Gr√ºnden der Kompatibilit√§t und des Schutzes (Trennung der Berechtigungen f√ºr Kernel-Space und User-Space) bestehen. Ohne sie ist es also einfach nirgendwo.  Einige Prozessoranweisungen sind verboten, wenn die Berechtigungsstufe schw√§cher als 0 ist und der Zugriff zwischen Programm- und Kernelsegmenten einen Segmentierungsfehler verursacht. </p><br><p>  Machen wir es noch einmal (hoffentlich im letzten) √ºber die Adress√ºbersetzung <br>  Zeilenadresse [0x08: 0xFFFFFFFF] -&gt; Segmentberechtigungen √ºberpr√ºfen 0x08 -&gt; Virtuelle Adresse [0xFFFFFFFF] -&gt; Seitentabelle + TLB -&gt; Physikalische Adresse [0xAAAAFFFF] </p><br><p>  Ein Segment wird nur innerhalb des Prozessors verwendet, in einem speziellen Segmentregister (CS, SS, DS, ES, FS, GS) gespeichert und ausschlie√ülich zur √úberpr√ºfung der Rechte zur Ausf√ºhrung von Code und zur √úbertragungssteuerung verwendet.  Aus diesem Grund k√∂nnen Sie die Kernelfunktion nicht einfach aus dem Benutzerbereich heraus aufrufen und aufrufen.  Das Segment mit dem 0x18-Deskriptor (ich habe einen, Ihr ist anders) hat Rechte der Stufe 3, und das Segment mit dem 0x08-Deskriptor hat Rechte der Stufe 0. Gem√§√ü der x86-Konvention kann ein Segment mit weniger Berechtigungen zum Schutz vor unbefugtem Zugriff ein Segment mit gro√üen Berechtigungen nicht direkt aufrufen Rechte √ºber jmp 0x08: [EAX], muss jedoch andere Mechanismen wie Traps, Gates und Interrupts verwenden. </p><br><p>  Segmente und ihre Typen (Code, Daten, Leitern, Gates) m√ºssen in der globalen GDT-Deskriptortabelle beschrieben werden, deren <strong>virtuelle</strong> Adresse und deren Gr√∂√üe in das GDTR-Register geladen wird.  Beim √úbergang zwischen Segmenten (der Einfachheit halber gehe ich davon aus, dass ein direkter √úbergang m√∂glich ist) m√ºssen Sie den Befehl jmp 0x08 aufrufen: [EAX], wobei 0x08 der <strong>Offset des ersten g√ºltigen Deskriptors in Bytes vom Anfang der Tabelle</strong> und EAX das Register ist, das die √úbergangsadresse enth√§lt.  Der Offset (Selektor) wird in das CS-Register geladen, und der entsprechende Deskriptor wird in das Schattenregister des Prozessors geladen.  Jeder Deskriptor ist eine 8-Byte-Struktur.  Es ist gut dokumentiert und seine Beschreibung kann sowohl auf OSDev als auch in der Intel-Dokumentation gefunden werden (siehe den ersten Artikel). </p><br><p>  Ich fasse zusammen.  Wenn wir GDT initialisieren und den √úbergang jmp 0x08: [EAX] ausf√ºhren, lautet der Prozessorstatus wie folgt: </p><br><ul><li>  GDTR enth√§lt eine <strong>virtuelle</strong> GDT-Adresse </li><li>  CS enth√§lt den Wert 0x08 </li><li>  Ein Handle an die Adresse [GDTR + 0x08] wurde aus dem Speicher in das Schattenregister CS kopiert </li><li>  Das EIP-Register enth√§lt die Adresse aus dem EAX-Register </li></ul><br><p>  Der Nulldeskriptor muss immer nicht initialisiert sein und der Zugriff darauf ist verboten.  Ich werde n√§her auf den TSS-Deskriptor und seine Bedeutung eingehen, wenn wir √ºber Multithreading sprechen.  Meine GDT-Tabelle sieht jetzt so aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_gdt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_gdt</span></span></span></span>() { GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_offset((&amp;super::tss::TSS) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_limit(core::mem::size_of::&lt;super::tss::Tss&gt;() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gdt_ptr: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry = GDT.as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> limit = (GDT.len() * core::mem::size_of::&lt;GdtEntry&gt;() - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>; load_gdt(gdt_ptr, limit); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> GDT: [GdtEntry; <span class="hljs-number"><span class="hljs-number">7</span></span>] = [ <span class="hljs-comment"><span class="hljs-comment">//null descriptor - cannot access GdtEntry::new(0, 0, 0, 0), //kernel code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //kernel data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //TSS - for interrupt handling in multithreading GdtEntry::new(0, 0, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_TSS_AVAIL, 0), GdtEntry::new(0, 0, 0, 0), ];</span></span></code> </pre> <br><p>  Und hier ist die Initialisierung, √ºber die ich oben so viel gesprochen habe.  Das Laden der GDT-Adresse und -Gr√∂√üe erfolgt √ºber eine separate Struktur, die nur zwei Felder enth√§lt.  Die Adresse dieser Struktur wird an den Befehl lgdt √ºbergeben.  Laden Sie in die Datensegmentregister den folgenden Deskriptor mit einem Offset von 0x10. </p><br><pre> <code class="plaintext hljs">global load_gdt section .text gdtr dw 0 ; For limit storage dd 0 ; For base storage load_gdt: mov eax, [esp + 4] mov [gdtr + 2], eax mov ax, [esp + 8] mov [gdtr], ax lgdt [gdtr] jmp 0x08:.reload_CS .reload_CS: mov ax, 0x10 ; 0x10 points at the new data selector mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov ax, 0x28 ltr ax ret</code> </pre> <br><p>  Dann wird alles etwas einfacher, aber nicht weniger interessant. </p><br><h1 id="preryvaniya">  Unterbrechungen </h1><br><p>  Eigentlich ist es Zeit, uns die M√∂glichkeit zu geben, mit unserem Kern zu interagieren (zumindest um zu sehen, was wir auf der Tastatur dr√ºcken).  Dazu m√ºssen Sie den Interrupt-Controller initialisieren. </p><br><p>  Lyrischer Exkurs √ºber den Codestil. </p><br><p>  Dank der Bem√ºhungen der Community und speziell von Philip Opperman wurde Rust die x86-Interrupt-Aufrufkonvention hinzugef√ºgt, mit der Sie Interrupt-Handler schreiben k√∂nnen, die iret ausf√ºhren.  Ich habe mich jedoch bewusst entschieden, diesen Weg nicht zu gehen, da ich mich entschlossen habe, Assembler und Rust in verschiedene Dateien zu trennen und daher zu funktionieren.  Ja, ich verwende unangemessen Stapelspeicher. Ich bin mir dessen bewusst, aber es schmeckt immer noch.  Meine Interrupt-Handler sind in Assembler geschrieben und machen genau eines: Sie rufen fast dieselben Interrupt-Handler auf, die in Rust geschrieben sind.  Bitte akzeptieren Sie diese Tatsache und lassen Sie sich verw√∂hnen. </p><br><p>  Im Allgemeinen √§hnelt das Initialisieren von Interrupts dem Initialisieren eines GDT, ist jedoch leichter zu verstehen.  Auf der anderen Seite ben√∂tigen Sie viel einheitlichen Code.  Die Entwickler von Redox OS treffen eine sch√∂ne Entscheidung, indem sie alle Freuden der Sprache nutzen, aber ich ging ‚Äûauf die Stirn‚Äú und entschied mich, Code-Duplizierung zuzulassen. </p><br><p>  Gem√§√ü der x86-Konvention haben wir Unterbrechungen, aber es gibt Ausnahmesituationen.  In diesem Zusammenhang sind die Einstellungen f√ºr uns praktisch gleich.  Der einzige Unterschied besteht darin, dass der Stapel beim Ausl√∂sen einer Ausnahme m√∂glicherweise zus√§tzliche Informationen enth√§lt.  Zum Beispiel benutze ich es, um das Fehlen einer Seite zu behandeln, wenn ich mit einem Haufen arbeite (aber alles hat seine Zeit).  Sowohl Interrupts als auch Ausnahmen werden aus derselben Tabelle verarbeitet, die Sie und ich ausf√ºllen m√ºssen.  Es ist auch erforderlich, den PIC (Programmable Interrupt Controller) zu programmieren.  Es gibt auch APIC, aber ich habe es noch nicht herausgefunden. </p><br><p>  Zur Arbeit mit PIC werde ich nicht viele Kommentare abgeben, da es im Netzwerk viele Beispiele f√ºr die Arbeit mit PIC gibt.  Ich werde mit den Handlern im Assembler beginnen.  Sie sind alle v√∂llig identisch, daher werde ich den Code f√ºr den Spoiler entfernen. </p><br><div class="spoiler">  <b class="spoiler_title">IRQ</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global irq0 global irq1 ...... global irq14 global irq15 extern kirq0 extern kirq1 ...... extern kirq14 extern kirq15 section .text irq0: pusha call kirq0 popa iret irq1: pusha call kirq1 popa iret ...... irq14: pusha call kirq14 popa iret irq15: pusha call kirq15 popa iret</code> </pre> </div></div><br><p>  Wie Sie sehen k√∂nnen, beginnen alle Aufrufe von Rust-Funktionen mit dem Pr√§fix ‚Äûk‚Äú - zur Unterscheidung und Bequemlichkeit.  Die Ausnahmebehandlung ist genau die gleiche.  F√ºr Assembler-Funktionen wird das Pr√§fix "e" ausgew√§hlt, f√ºr Rust "k".  Der Page Fault-Handler ist anders, aber dar√ºber - in den Hinweisen zur Speicherverwaltung. </p><br><div class="spoiler">  <b class="spoiler_title">Ausnahmen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global e0_zero_divide global e1_debug ...... global eE_page_fault ...... global e14_virtualization global e1E_security extern k0_zero_divide extern k1_debug ...... extern kE_page_fault ...... extern k14_virtualization extern k1E_security section .text e0_zero_divide: pushad call k0_zero_divide popad iret e1_debug: pushad call k1_debug popad iret ...... eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret ...... e14_virtualization: pushad call k14_virtualization popad iret e1E_security: pushad call k1E_security popad iret</code> </pre> </div></div><br><p>  Wir deklarieren Assembler-Handler: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_idt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e0_zero_divide</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1_debug</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e14_virtualization</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1E_security</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq0</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq1</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq14</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq15</span></span></span></span>(); }</code> </pre> <br><p>  Wir definieren Rust-Handler, die wir oben aufrufen.  Bitte beachten Sie, dass ich zum Unterbrechen der Tastatur einfach den empfangenen Code anzeige, den ich von Port 0x60 erhalte - so funktioniert die Tastatur im einfachsten Modus.  Ich hoffe, dass sich dies in Zukunft in einen vollwertigen Fahrer verwandelt.  Nach jedem Interrupt m√ºssen Sie das Signal vom Ende der Verarbeitung 0x20 an die Steuerung ausgeben, das ist wichtig!  Andernfalls erhalten Sie keine weiteren Interrupts. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kirq0</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// println!("IRQ 0"); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq1() { let ch: char = inb(0x60) as char; crate::arch::vga::VGA_WRITER.force_unlock(); println!("IRQ 1 {}", ch); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq2() { println!("IRQ 2"); outb(0x20, 0x20); } ...</span></span></code> </pre> <br><p>  Initialisierung von IDT und PIC.  √úber PIC und seine Neuzuordnung habe ich eine gro√üe Anzahl von Tutorials mit unterschiedlichem Detaillierungsgrad gefunden, angefangen bei OSDev bis hin zu Amateurseiten.  Da die Programmierprozedur mit einer konstanten Folge von Operationen und konstanten Befehlen arbeitet, werde ich diesen Code ohne weitere Erkl√§rung geben.     ,        0x20-0x2F  ,       0x20  0x28,     16    IDT. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pic</span></span></span></span>(pic1: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, pic2: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Start initialization outb(PIC1, 0x11); outb(PIC2, 0x11); // Set offsets outb(PIC1 + 1, pic1); /* remap */ outb(PIC2 + 1, pic2); /* pics */ // Set up cascade outb(PIC1 + 1, 4); /* IRQ2 -&gt; connection to slave */ outb(PIC2 + 1, 2); // Set up interrupt mode (1 is 8086/88 mode, 2 is auto EOI) outb(PIC1 + 1, 1); outb(PIC2 + 1, 1); // Unmask interrupts outb(PIC1 + 1, 0); outb(PIC2 + 1, 0); // Ack waiting outb(PIC1, 0x20); outb(PIC2, 0x20); } pub unsafe fn init_idt() { IDT[0x0].set_func(e0_zero_divide); IDT[0x1].set_func(e1_debug); ...... IDT[0x14].set_func(e14_virtualization); IDT[0x1E].set_func(e1E_security); IDT[0x20].set_func(irq0); IDT[0x21].set_func(irq1); ...... IDT[0x2E].set_func(irq14); IDT[0x2F].set_func(irq15); setup_pic(0x20, 0x28); let idt_ptr: *const IdtEntry = IDT.as_ptr(); let limit = (IDT.len() * core::mem::size_of::&lt;IdtEntry&gt;() - 1) as u16; load_idt(idt_ptr, limit); }</span></span></code> </pre> <br><p>      IDTR   GDTR ‚Äî       .  STI        ‚Äî         ‚Äî  ,    ,  ASCII-   -. </p><br><pre> <code class="plaintext hljs">global load_idt section .text idtr dw 0 ; For limit storage dd 0 ; For base storage load_idt: mov eax, [esp + 4] mov [idtr + 2], eax mov ax, [esp + 8] mov [idtr], ax lidt [idtr] sti ret</code> </pre> <br><h1 id="posleslovie">  Nachwort </h1><br><p>  ,     ,            .      setup_pd,           . ,   ,     ,  . </p><br><p>   - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  GitLab</a> . </p><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p><br><p> UPD: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445584/">https://habr.com/ru/post/de445584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445568/index.html">Fern√ºberwachung und -verwaltung von Linux / OpenWrt / Lede-basierten Ger√§ten √ºber Port 80 ...</a></li>
<li><a href="../de445570/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Experten im Bereich IT f√ºr April 2019</a></li>
<li><a href="../de445572/index.html">Die US-Regierung plant, Menschen in 5 Jahren zum Mond zu schicken</a></li>
<li><a href="../de445580/index.html">Eine vollst√§ndige Liste der Unterschiede zwischen VB.NET und C #. Teil 2</a></li>
<li><a href="../de445582/index.html">CRM-Systeme: Schutz oder Bedrohung?</a></li>
<li><a href="../de445586/index.html">Android Academy in Moskau - sprechen Sie dar√ºber, wie es war, und teilen Sie Kursmaterialien</a></li>
<li><a href="../de445588/index.html">In der Ausstellung wird das 3D-Scannen einer Person in 30 Sekunden gezeigt</a></li>
<li><a href="../de445590/index.html">Englische Grammatik. Wer vs. Wen - wie man versteht, welches Wort man benutzt</a></li>
<li><a href="../de445592/index.html">Lazy Initialisierung in Spring Boot 2.2</a></li>
<li><a href="../de445594/index.html">Tools zum Erstellen einer reaktionsf√§higen Site ohne Zugriff auf die Site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>