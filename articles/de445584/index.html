<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎯 🖖 😒 OS1: Ein primitiver Kernel auf Rust für x86. Teil 2. VGA, GDT, IDT 👻 💈 🤵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erster Teil 


 Der erste Artikel hatte noch keine Zeit zum Abkühlen, aber ich habe beschlossen, Sie nicht zu faszinieren und eine Fortsetzung zu schr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: Ein primitiver Kernel auf Rust für x86. Teil 2. VGA, GDT, IDT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445584/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a> </p><br><p>  Der erste Artikel hatte noch keine Zeit zum Abkühlen, aber ich habe beschlossen, Sie nicht zu faszinieren und eine Fortsetzung zu schreiben. </p><br><p>  Im vorherigen Artikel haben wir über das Verknüpfen, Laden der Kerneldatei und die primäre Initialisierung gesprochen.  Ich gab einige nützliche Links, erklärte, wie sich der geladene Kernel im Speicher befindet, wie virtuelle und physische Adressen beim Booten verglichen werden und wie die Unterstützung für den Seitenmechanismus aktiviert wird.  Zuletzt ging die Kontrolle auf die in Rust geschriebene kmain-Funktion meines Kernels über.  Es ist Zeit weiterzumachen und herauszufinden, wie tief das Kaninchenloch ist! </p><br><p>  In diesem Teil der Hinweise <strong>werde</strong> ich <strong>kurz meine Rust-Konfiguration beschreiben, allgemein über die Ausgabe von Informationen in VGA und ausführlich über das Einrichten von Segmenten und Interrupts sprechen</strong> .  Ich frage alle Interessierten unter dem Schnitt, und wir fangen an. </p><a name="habracut"></a><br><h1 id="nastroyka-rust">  Rostaufbau </h1><br><p> Im Allgemeinen ist dieses Verfahren nicht besonders kompliziert. Einzelheiten erfahren Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Philippe-Blog</a> .  Ich werde jedoch an einigen Stellen aufhören. </p><br><p>  Stable Rust unterstützt einige Funktionen, die für die Entwicklung auf niedriger Ebene erforderlich sind, immer noch nicht. Um die Standardbibliothek zu deaktivieren und auf Bare Bones aufzubauen, benötigen wir Rust Nightly.  Seien Sie vorsichtig, einmal nach dem Update auf den neuesten Stand bekam ich einen völlig funktionsunfähigen Compiler und musste zum nächsten stabilen zurücksetzen.  Wenn Sie sicher sind, dass Ihr Compiler gestern funktioniert hat, aber aktualisiert wurde und nicht funktioniert, führen Sie den Befehl aus und ersetzen Sie das gewünschte Datum </p><br><pre><code class="plaintext hljs">rustup override add nightly-YYYY-MM-DD</code> </pre> <br><p>  Einzelheiten zum Mechanismus erhalten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Konfigurieren Sie als Nächstes die Zielplattform, für die wir gehen.  Ich basierte auf dem Blog von Philip Opperman, so dass viele der Dinge in diesem Abschnitt von ihm genommen, von Knochen zerlegt und an meine Bedürfnisse angepasst wurden.  Philip entwickelt in seinem Blog für x64, ich habe ursprünglich x32 gewählt, daher wird meine target.json etwas anders sein.  Ich bringe es komplett </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"llvm-target"</span></span>: <span class="hljs-string"><span class="hljs-string">"i686-unknown-none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"data-layout"</span></span>: <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-f64:32:64-f80:32-n8:16:32-S128"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"x86"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-endian"</span></span>: <span class="hljs-string"><span class="hljs-string">"little"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-pointer-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-c-int-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"os"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"executables"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker-flavor"</span></span>: <span class="hljs-string"><span class="hljs-string">"ld.lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker"</span></span>: <span class="hljs-string"><span class="hljs-string">"rust-lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"panic-strategy"</span></span>: <span class="hljs-string"><span class="hljs-string">"abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"disable-redzone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"features"</span></span>: <span class="hljs-string"><span class="hljs-string">"-mmx,-sse,+soft-float"</span></span> }</code> </pre> <br><p>  Der schwierigste Teil hier ist der Parameter „ <strong>Datenlayout</strong> “.  Aus der LLVM-Dokumentation geht hervor, dass es sich um Datenlayoutoptionen handelt, die durch „-“ getrennt sind.  Das allererste "e" -Zeichen ist für die Indianität verantwortlich - in unserem Fall ist es Little-Endian, wie es die Plattform erfordert.  Das zweite Zeichen ist m, "Verzerrung".  Verantwortlich für Charakternamen während des Layouts.  Da unser Ausgabeformat ELF ist (siehe Build-Skript), wählen wir "m: e".  Das dritte Zeichen ist die Größe des Zeigers in Bit und ABI (Application Binary Interface).  Hier ist alles einfach, wir haben 32 Bits, also setzen wir mutig „p: 32: 32“.  Als nächstes kommen Gleitkommazahlen.  Wir berichten, dass wir 64-Bit-Nummern gemäß ABI 32 mit Ausrichtung 64 - „f64: 32: 64“ sowie 80-Bit-Nummern mit standardmäßiger Ausrichtung - „f80: 32“ unterstützen.  Das nächste Element sind Ganzzahlen.  Wir beginnen mit 8 Bit und gehen zum Plattformmaximum von 32 Bit über - „n8: 16: 32“.  Der letzte ist die Stapelausrichtung.  Ich brauche sogar 128-Bit-Ganzzahlen, also sei es S128.  In jedem Fall kann LLVM diesen Parameter ignorieren. Dies ist unsere Präferenz. </p><br><p>  In Bezug auf die restlichen Parameter können Sie einen Blick auf Philip werfen, er erklärt alles gut. </p><br><p>  Wir brauchen auch Cargo-Xbuild - ein Tool, mit dem Sie den Rostkern beim Bauen unter einer unbekannten Zielplattform überkompilieren können. <br>  Installieren. </p><br><pre> <code class="bash hljs">cargo install cargo-xbuild</code> </pre> <br><p>  Wir werden es so sammeln. </p><br><pre> <code class="bash hljs">cargo xbuild -Z unstable-options --manifest-path=kernel/Cargo.toml --target kernel/targets/$(ARCH).json --out-dir=build/lib</code> </pre> <br><p>  Ich brauchte ein Manifest für die korrekte Operation von Make, da es vom Stammverzeichnis ausgeht und der Kernel im Kernelverzeichnis liegt. </p><br><p>  Von den Funktionen des Manifests kann ich nur <em>crate-type = ["staticlib"] hervorheben</em> , wodurch eine verlinkbare Datei zur Ausgabe erstellt wird.  Wir werden ihn in LLD füttern. </p><br><h1 id="kmain-i-pervonachalnaya-nastroyka">  kmain und Ersteinrichtung </h1><br><p>  Wenn wir gemäß den Rust-Konventionen eine statische Bibliothek (oder eine „flache“ Binärdatei) erstellen, muss das Stammverzeichnis der Kiste die Datei lib.rs enthalten, die der Einstiegspunkt ist.  Darin werden mithilfe von Attributen Sprachfunktionen konfiguriert und auch der geschätzte kmain gefunden. </p><br><p>  Im ersten Schritt müssen wir also die Standardbibliothek deaktivieren.  Dies geschieht mit einem Makro. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span></code> </pre> <br><p>  Mit einem so einfachen Schritt vergessen wir sofort Multithreading, dynamischen Speicher und andere Freuden der Standardbibliothek.  Darüber hinaus berauben wir uns sogar des println !, Makros, sodass wir es selbst implementieren müssen.  Ich werde dir sagen, wie es das nächste Mal geht. </p><br><p>  Viele Tutorials irgendwo an diesem Ort enden mit der Ausgabe von „Hello World“ und ohne zu erklären, wie man davon lebt.  Wir werden den anderen Weg gehen.  Zunächst müssen wir Code- und Datensegmente für den geschützten Modus festlegen, VGA konfigurieren und Interrupts konfigurieren, was wir tun werden. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> debug; <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[path = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arch/i686/mod.rs"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> arch; <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmain</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_magic: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { arch::arch_init(pd); ...... } <span class="hljs-meta"><span class="hljs-meta">#[panic_handler]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panic</span></span></span></span>(_info: &amp;PanicInfo) -&gt; ! { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, _info); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> {} }</code> </pre> <br><p>  Was ist hier los?  Wie gesagt, wir schalten die Standardbibliothek aus.  Wir werden auch zwei sehr wichtige Module ankündigen - Debug (in dem wir auf dem Bildschirm schreiben werden) und Arch (in dem alle plattformabhängige Magie leben wird).  Ich verwende die Rust-Funktion mit Konfigurationen, um dieselben Schnittstellen in verschiedenen Architekturimplementierungen zu deklarieren und sie in vollem Umfang zu nutzen.  Hier höre ich nur auf x86 auf und dann reden wir nur darüber. </p><br><p>  Ich erklärte einen völlig primitiven Panikhandler, den Rust benötigt.  Dann kann es geändert werden. </p><br><p>  kmain akzeptiert drei Argumente und wird auch in C-Notation ohne Namensverzerrung exportiert, damit der Linker die Funktion korrekt mit dem Aufruf von _loader verknüpfen kann, den ich im vorherigen Artikel beschrieben habe.  Das erste Argument ist die Adresse der PD-Seitentabelle, das zweite ist die <strong>physikalische</strong> Adresse der GRUB-Struktur, von der wir die Speicherkarte erhalten, das dritte ist die magische Zahl.  In Zukunft möchte ich sowohl die Multiboot 2-Unterstützung als auch meinen eigenen Bootloader implementieren, daher verwende ich eine magische Zahl, um die Bootmethode zu identifizieren. </p><br><p>  Der erste kmain-Aufruf ist die plattformspezifische Initialisierung.  Wir gehen hinein.  Die Funktion arch_init befindet sich in der Datei arch / i686 / mod.rs, ist öffentlich, 32-Bit x86-spezifisch und sieht folgendermaßen aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arch_init</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { vga::VGA_WRITER.lock().init(); gdt::setup_gdt(); idt::init_idt(); paging::setup_pd(pd); } }</code> </pre> <br><p>  Wie Sie sehen können, werden für x86 Ausgabe, Segmentierung, Interrupts und Paging der Reihe nach initialisiert.  Beginnen wir mit VGA. </p><br><h1 id="inicializaciya-vga">  VGA-Initialisierung </h1><br><p>  Jedes Tutorial sieht es als seine Pflicht an, Hello World zu drucken, sodass Sie überall erfahren, wie Sie mit VGA arbeiten.  Aus diesem Grund werde ich so kurz wie möglich gehen, ich werde mich nur auf die Chips konzentrieren, die ich selbst gemacht habe.  Über die Verwendung von lazy_static werde ich Sie zu Philippes Blog schicken und nicht im Detail erklären.  const fn ist noch nicht in der Version, daher können noch keine statischen Initialisierungen durchgeführt werden.  Und wir werden eine Drehsperre hinzufügen, damit es sich nicht als Chaos herausstellt. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> VGA_WRITER : Mutex&lt;Writer&gt; = Mutex::new(Writer { cursor_position: <span class="hljs-number"><span class="hljs-number">0</span></span>, vga_color: ColorCode::new(Color::LightGray, Color::Black), buffer: <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC00B8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer) } }); }</code> </pre> <br><p>  Wie Sie wissen, befindet sich der Bildschirmpuffer an der physischen Adresse 0xB8000 und hat eine Größe von 80x25x2 Byte (Breite und Höhe des Bildschirms, Byte pro Zeichen und Attribute: Farben, Flimmern).  Da wir den virtuellen Speicher bereits aktiviert haben, stürzt der Zugriff auf diese Adresse ab, sodass wir 3 GB hinzufügen.  Wir dereferenzieren auch einen rohen Zeiger, der unsicher ist - aber wir wissen, was wir tun. <br>  Von den interessanten Dingen in dieser Datei ist vielleicht nur die Implementierung der Writer-Struktur, die es nicht nur ermöglicht, Zeichen in einer Reihe anzuzeigen, sondern auch zu scrollen, an eine beliebige Stelle auf dem Bildschirm zu gehen und andere nette kleine Dinge. </p><br><div class="spoiler">  <b class="spoiler_title">Vga Schriftsteller</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span></span> { cursor_position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, vga_color: ColorCode, buffer: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Writer { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vga_color = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code: vga_color, } } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor_abs</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0F</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D5</span></span>, (position &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0E</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, ((position &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = position; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(y * VGA_WIDTH + x); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position + offset; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position % VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_y</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position / VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scroll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color_code = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ln</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_line = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_y() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next_line &gt;= VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, next_line) } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_xy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_pos</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[position] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position &gt;= VGA_WIDTH * VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte_at_pos(byte, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.move_cursor(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s.bytes() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> byte { <span class="hljs-number"><span class="hljs-number">0x20</span></span>...<span class="hljs-number"><span class="hljs-number">0xFF</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(byte), <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ln(), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(<span class="hljs-number"><span class="hljs-number">0xfe</span></span>), } } } }</code> </pre> </div></div><br><p>  Beim Zurückspulen kopieren Sie einfach Speicherbereiche in der Größe der Bildschirmbreite nach hinten und füllen eine neue Zeile mit Leerzeichen aus (so mache ich die Reinigung).  Outb-Aufrufe sind etwas interessanter - auf keine andere Weise als mit E / A-Ports zu arbeiten, ist es unmöglich, den Cursor zu bewegen.  Wir benötigen jedoch weiterhin Eingabe / Ausgabe über Ports, sodass diese in einem separaten Paket geliefert und in sichere Wrapper verpackt wurden.  Unter dem Spoiler befindet sich der Assembler-Code.  Im Moment reicht es zu wissen, dass: </p><br><ul><li>  Der absolute Cursorversatz, nicht die Koordinate, wird angezeigt. </li><li>  Sie können jeweils ein Byte an den Controller ausgeben </li><li>  Die Ausgabe eines Bytes erfolgt in zwei Befehlen - zuerst schreiben wir den Befehl in die Steuerung, dann die Daten. </li><li>  Der Port für Befehle ist 0x3D4, der Datenport ist 0x3D5 </li><li>  Drucken Sie zuerst das untere Byte der Position mit dem Befehl 0x0F und dann das obere mit dem Befehl 0x0E </li></ul><br><div class="spoiler">  <b class="spoiler_title">out.asm</b> <div class="spoiler_text"><p>  Achten Sie darauf, mit übergebenen Variablen auf dem Stapel zu arbeiten.  Da der Stapel am Ende des Leerzeichens beginnt und den Stapelzeiger beim Aufrufen der Funktion reduziert, um Parameter, einen Rückgabepunkt usw. abzurufen, müssen Sie die mit der Stapelausrichtung ausgerichtete Argumentgröße zum ESP-Register hinzufügen, in unserem Fall 4 Byte. </p><br><pre> <code class="plaintext hljs">global writeb global writew global writed section .text writeb: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 byte value aligned 4 bytes out dx, al ;write byte by port number an dx - value in al mov esp, ebp pop ebp ret writew: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 word value aligned 4 bytes out dx, ax ;write word by port number an dx - value in ax mov esp, ebp pop ebp ret writed: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 double word value aligned 4 bytes out dx, eax ;write double word by port number an dx - value in eax mov esp, ebp pop ebp ret</code> </pre> </div></div><br><h1 id="nastroyka-segmentov">  Segmenteinrichtung </h1><br><p>  Wir kamen zum rätselhaftesten, aber gleichzeitig einfachsten Thema.  Wie ich in einem früheren Artikel sagte, war die Seiten- und Segmentorganisation des Speichers in meinem Kopf gemischt, ich lud die Adresse der Seitentabelle in die GDTR und packte meinen Kopf.  Ich habe mehrere Monate gebraucht, um das Material ausreichend zu lesen, es zu verdauen und es zu realisieren.  Ich bin möglicherweise Opfer von Peter Abels Lehrbuch Assembler geworden.  Die Sprache und Programmierung für den IBM PC “(ein großartiges Buch!), In dem die Segmentierung für den Intel 8086 beschrieben wird. In diesen angenehmen Zeiten haben wir die oberen 16 Bits einer 20-Bit-Adresse in das Segmentregister geladen, und das war die Adresse im Speicher.  Es stellte sich als grausame Enttäuschung heraus, dass ab i286 im geschützten Modus alles völlig falsch ist. </p><br><p>  Die bloße Theorie ist also, dass x86 ein segmentiertes Speichermodell unterstützt, da ältere Programme nur über 640 KB und dann 1 MB Speicher hinaus ausbrechen konnten. </p><br><p>  Programmierer mussten darüber nachdenken, wie sie ausführbaren Code platzieren, wie sie Daten platzieren und wie sie ihre Sicherheit gewährleisten können.  Das Aufkommen der Seitenorganisation machte eine segmentierte Organisation unnötig, blieb jedoch aus Gründen der Kompatibilität und des Schutzes (Trennung der Berechtigungen für Kernel-Space und User-Space) bestehen. Ohne sie ist es also einfach nirgendwo.  Einige Prozessoranweisungen sind verboten, wenn die Berechtigungsstufe schwächer als 0 ist und der Zugriff zwischen Programm- und Kernelsegmenten einen Segmentierungsfehler verursacht. </p><br><p>  Machen wir es noch einmal (hoffentlich im letzten) über die Adressübersetzung <br>  Zeilenadresse [0x08: 0xFFFFFFFF] -&gt; Segmentberechtigungen überprüfen 0x08 -&gt; Virtuelle Adresse [0xFFFFFFFF] -&gt; Seitentabelle + TLB -&gt; Physikalische Adresse [0xAAAAFFFF] </p><br><p>  Ein Segment wird nur innerhalb des Prozessors verwendet, in einem speziellen Segmentregister (CS, SS, DS, ES, FS, GS) gespeichert und ausschließlich zur Überprüfung der Rechte zur Ausführung von Code und zur Übertragungssteuerung verwendet.  Aus diesem Grund können Sie die Kernelfunktion nicht einfach aus dem Benutzerbereich heraus aufrufen und aufrufen.  Das Segment mit dem 0x18-Deskriptor (ich habe einen, Ihr ist anders) hat Rechte der Stufe 3, und das Segment mit dem 0x08-Deskriptor hat Rechte der Stufe 0. Gemäß der x86-Konvention kann ein Segment mit weniger Berechtigungen zum Schutz vor unbefugtem Zugriff ein Segment mit großen Berechtigungen nicht direkt aufrufen Rechte über jmp 0x08: [EAX], muss jedoch andere Mechanismen wie Traps, Gates und Interrupts verwenden. </p><br><p>  Segmente und ihre Typen (Code, Daten, Leitern, Gates) müssen in der globalen GDT-Deskriptortabelle beschrieben werden, deren <strong>virtuelle</strong> Adresse und deren Größe in das GDTR-Register geladen wird.  Beim Übergang zwischen Segmenten (der Einfachheit halber gehe ich davon aus, dass ein direkter Übergang möglich ist) müssen Sie den Befehl jmp 0x08 aufrufen: [EAX], wobei 0x08 der <strong>Offset des ersten gültigen Deskriptors in Bytes vom Anfang der Tabelle</strong> und EAX das Register ist, das die Übergangsadresse enthält.  Der Offset (Selektor) wird in das CS-Register geladen, und der entsprechende Deskriptor wird in das Schattenregister des Prozessors geladen.  Jeder Deskriptor ist eine 8-Byte-Struktur.  Es ist gut dokumentiert und seine Beschreibung kann sowohl auf OSDev als auch in der Intel-Dokumentation gefunden werden (siehe den ersten Artikel). </p><br><p>  Ich fasse zusammen.  Wenn wir GDT initialisieren und den Übergang jmp 0x08: [EAX] ausführen, lautet der Prozessorstatus wie folgt: </p><br><ul><li>  GDTR enthält eine <strong>virtuelle</strong> GDT-Adresse </li><li>  CS enthält den Wert 0x08 </li><li>  Ein Handle an die Adresse [GDTR + 0x08] wurde aus dem Speicher in das Schattenregister CS kopiert </li><li>  Das EIP-Register enthält die Adresse aus dem EAX-Register </li></ul><br><p>  Der Nulldeskriptor muss immer nicht initialisiert sein und der Zugriff darauf ist verboten.  Ich werde näher auf den TSS-Deskriptor und seine Bedeutung eingehen, wenn wir über Multithreading sprechen.  Meine GDT-Tabelle sieht jetzt so aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_gdt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_gdt</span></span></span></span>() { GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_offset((&amp;super::tss::TSS) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_limit(core::mem::size_of::&lt;super::tss::Tss&gt;() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gdt_ptr: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry = GDT.as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> limit = (GDT.len() * core::mem::size_of::&lt;GdtEntry&gt;() - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>; load_gdt(gdt_ptr, limit); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> GDT: [GdtEntry; <span class="hljs-number"><span class="hljs-number">7</span></span>] = [ <span class="hljs-comment"><span class="hljs-comment">//null descriptor - cannot access GdtEntry::new(0, 0, 0, 0), //kernel code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //kernel data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //TSS - for interrupt handling in multithreading GdtEntry::new(0, 0, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_TSS_AVAIL, 0), GdtEntry::new(0, 0, 0, 0), ];</span></span></code> </pre> <br><p>  Und hier ist die Initialisierung, über die ich oben so viel gesprochen habe.  Das Laden der GDT-Adresse und -Größe erfolgt über eine separate Struktur, die nur zwei Felder enthält.  Die Adresse dieser Struktur wird an den Befehl lgdt übergeben.  Laden Sie in die Datensegmentregister den folgenden Deskriptor mit einem Offset von 0x10. </p><br><pre> <code class="plaintext hljs">global load_gdt section .text gdtr dw 0 ; For limit storage dd 0 ; For base storage load_gdt: mov eax, [esp + 4] mov [gdtr + 2], eax mov ax, [esp + 8] mov [gdtr], ax lgdt [gdtr] jmp 0x08:.reload_CS .reload_CS: mov ax, 0x10 ; 0x10 points at the new data selector mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov ax, 0x28 ltr ax ret</code> </pre> <br><p>  Dann wird alles etwas einfacher, aber nicht weniger interessant. </p><br><h1 id="preryvaniya">  Unterbrechungen </h1><br><p>  Eigentlich ist es Zeit, uns die Möglichkeit zu geben, mit unserem Kern zu interagieren (zumindest um zu sehen, was wir auf der Tastatur drücken).  Dazu müssen Sie den Interrupt-Controller initialisieren. </p><br><p>  Lyrischer Exkurs über den Codestil. </p><br><p>  Dank der Bemühungen der Community und speziell von Philip Opperman wurde Rust die x86-Interrupt-Aufrufkonvention hinzugefügt, mit der Sie Interrupt-Handler schreiben können, die iret ausführen.  Ich habe mich jedoch bewusst entschieden, diesen Weg nicht zu gehen, da ich mich entschlossen habe, Assembler und Rust in verschiedene Dateien zu trennen und daher zu funktionieren.  Ja, ich verwende unangemessen Stapelspeicher. Ich bin mir dessen bewusst, aber es schmeckt immer noch.  Meine Interrupt-Handler sind in Assembler geschrieben und machen genau eines: Sie rufen fast dieselben Interrupt-Handler auf, die in Rust geschrieben sind.  Bitte akzeptieren Sie diese Tatsache und lassen Sie sich verwöhnen. </p><br><p>  Im Allgemeinen ähnelt das Initialisieren von Interrupts dem Initialisieren eines GDT, ist jedoch leichter zu verstehen.  Auf der anderen Seite benötigen Sie viel einheitlichen Code.  Die Entwickler von Redox OS treffen eine schöne Entscheidung, indem sie alle Freuden der Sprache nutzen, aber ich ging „auf die Stirn“ und entschied mich, Code-Duplizierung zuzulassen. </p><br><p>  Gemäß der x86-Konvention haben wir Unterbrechungen, aber es gibt Ausnahmesituationen.  In diesem Zusammenhang sind die Einstellungen für uns praktisch gleich.  Der einzige Unterschied besteht darin, dass der Stapel beim Auslösen einer Ausnahme möglicherweise zusätzliche Informationen enthält.  Zum Beispiel benutze ich es, um das Fehlen einer Seite zu behandeln, wenn ich mit einem Haufen arbeite (aber alles hat seine Zeit).  Sowohl Interrupts als auch Ausnahmen werden aus derselben Tabelle verarbeitet, die Sie und ich ausfüllen müssen.  Es ist auch erforderlich, den PIC (Programmable Interrupt Controller) zu programmieren.  Es gibt auch APIC, aber ich habe es noch nicht herausgefunden. </p><br><p>  Zur Arbeit mit PIC werde ich nicht viele Kommentare abgeben, da es im Netzwerk viele Beispiele für die Arbeit mit PIC gibt.  Ich werde mit den Handlern im Assembler beginnen.  Sie sind alle völlig identisch, daher werde ich den Code für den Spoiler entfernen. </p><br><div class="spoiler">  <b class="spoiler_title">IRQ</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global irq0 global irq1 ...... global irq14 global irq15 extern kirq0 extern kirq1 ...... extern kirq14 extern kirq15 section .text irq0: pusha call kirq0 popa iret irq1: pusha call kirq1 popa iret ...... irq14: pusha call kirq14 popa iret irq15: pusha call kirq15 popa iret</code> </pre> </div></div><br><p>  Wie Sie sehen können, beginnen alle Aufrufe von Rust-Funktionen mit dem Präfix „k“ - zur Unterscheidung und Bequemlichkeit.  Die Ausnahmebehandlung ist genau die gleiche.  Für Assembler-Funktionen wird das Präfix "e" ausgewählt, für Rust "k".  Der Page Fault-Handler ist anders, aber darüber - in den Hinweisen zur Speicherverwaltung. </p><br><div class="spoiler">  <b class="spoiler_title">Ausnahmen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global e0_zero_divide global e1_debug ...... global eE_page_fault ...... global e14_virtualization global e1E_security extern k0_zero_divide extern k1_debug ...... extern kE_page_fault ...... extern k14_virtualization extern k1E_security section .text e0_zero_divide: pushad call k0_zero_divide popad iret e1_debug: pushad call k1_debug popad iret ...... eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret ...... e14_virtualization: pushad call k14_virtualization popad iret e1E_security: pushad call k1E_security popad iret</code> </pre> </div></div><br><p>  Wir deklarieren Assembler-Handler: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_idt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e0_zero_divide</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1_debug</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e14_virtualization</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1E_security</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq0</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq1</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq14</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq15</span></span></span></span>(); }</code> </pre> <br><p>  Wir definieren Rust-Handler, die wir oben aufrufen.  Bitte beachten Sie, dass ich zum Unterbrechen der Tastatur einfach den empfangenen Code anzeige, den ich von Port 0x60 erhalte - so funktioniert die Tastatur im einfachsten Modus.  Ich hoffe, dass sich dies in Zukunft in einen vollwertigen Fahrer verwandelt.  Nach jedem Interrupt müssen Sie das Signal vom Ende der Verarbeitung 0x20 an die Steuerung ausgeben, das ist wichtig!  Andernfalls erhalten Sie keine weiteren Interrupts. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kirq0</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// println!("IRQ 0"); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq1() { let ch: char = inb(0x60) as char; crate::arch::vga::VGA_WRITER.force_unlock(); println!("IRQ 1 {}", ch); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq2() { println!("IRQ 2"); outb(0x20, 0x20); } ...</span></span></code> </pre> <br><p>  Initialisierung von IDT und PIC.  Über PIC und seine Neuzuordnung habe ich eine große Anzahl von Tutorials mit unterschiedlichem Detaillierungsgrad gefunden, angefangen bei OSDev bis hin zu Amateurseiten.  Da die Programmierprozedur mit einer konstanten Folge von Operationen und konstanten Befehlen arbeitet, werde ich diesen Code ohne weitere Erklärung geben.     ,        0x20-0x2F  ,       0x20  0x28,     16    IDT. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pic</span></span></span></span>(pic1: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, pic2: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Start initialization outb(PIC1, 0x11); outb(PIC2, 0x11); // Set offsets outb(PIC1 + 1, pic1); /* remap */ outb(PIC2 + 1, pic2); /* pics */ // Set up cascade outb(PIC1 + 1, 4); /* IRQ2 -&gt; connection to slave */ outb(PIC2 + 1, 2); // Set up interrupt mode (1 is 8086/88 mode, 2 is auto EOI) outb(PIC1 + 1, 1); outb(PIC2 + 1, 1); // Unmask interrupts outb(PIC1 + 1, 0); outb(PIC2 + 1, 0); // Ack waiting outb(PIC1, 0x20); outb(PIC2, 0x20); } pub unsafe fn init_idt() { IDT[0x0].set_func(e0_zero_divide); IDT[0x1].set_func(e1_debug); ...... IDT[0x14].set_func(e14_virtualization); IDT[0x1E].set_func(e1E_security); IDT[0x20].set_func(irq0); IDT[0x21].set_func(irq1); ...... IDT[0x2E].set_func(irq14); IDT[0x2F].set_func(irq15); setup_pic(0x20, 0x28); let idt_ptr: *const IdtEntry = IDT.as_ptr(); let limit = (IDT.len() * core::mem::size_of::&lt;IdtEntry&gt;() - 1) as u16; load_idt(idt_ptr, limit); }</span></span></code> </pre> <br><p>      IDTR   GDTR —       .  STI        —         —  ,    ,  ASCII-   -. </p><br><pre> <code class="plaintext hljs">global load_idt section .text idtr dw 0 ; For limit storage dd 0 ; For base storage load_idt: mov eax, [esp + 4] mov [idtr + 2], eax mov ax, [esp + 8] mov [idtr], ax lidt [idtr] sti ret</code> </pre> <br><h1 id="posleslovie">  Nachwort </h1><br><p>  ,     ,            .      setup_pd,           . ,   ,     ,  . </p><br><p>   - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  GitLab</a> . </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit! </p><br><p> UPD: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445584/">https://habr.com/ru/post/de445584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445568/index.html">Fernüberwachung und -verwaltung von Linux / OpenWrt / Lede-basierten Geräten über Port 80 ...</a></li>
<li><a href="../de445570/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT für April 2019</a></li>
<li><a href="../de445572/index.html">Die US-Regierung plant, Menschen in 5 Jahren zum Mond zu schicken</a></li>
<li><a href="../de445580/index.html">Eine vollständige Liste der Unterschiede zwischen VB.NET und C #. Teil 2</a></li>
<li><a href="../de445582/index.html">CRM-Systeme: Schutz oder Bedrohung?</a></li>
<li><a href="../de445586/index.html">Android Academy in Moskau - sprechen Sie darüber, wie es war, und teilen Sie Kursmaterialien</a></li>
<li><a href="../de445588/index.html">In der Ausstellung wird das 3D-Scannen einer Person in 30 Sekunden gezeigt</a></li>
<li><a href="../de445590/index.html">Englische Grammatik. Wer vs. Wen - wie man versteht, welches Wort man benutzt</a></li>
<li><a href="../de445592/index.html">Lazy Initialisierung in Spring Boot 2.2</a></li>
<li><a href="../de445594/index.html">Tools zum Erstellen einer reaktionsfähigen Site ohne Zugriff auf die Site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>