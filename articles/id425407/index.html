<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳 🧔 🚁 Firecore - gim seru di AVR 🤰🏻 🍏 ✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin berbagi konstruksi jangka panjang malam yang lain, yang menunjukkan bahwa Anda dapat membuat game bahkan pada perangkat keras yang lemah. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Firecore - gim seru di AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425407/"><img src="https://habrastorage.org/webt/dv/yz/hr/dvyzhr-e4xxmj6jbln7ngiti5d0.png"><br><br>  Saya ingin berbagi konstruksi jangka panjang malam yang lain, yang menunjukkan bahwa Anda dapat membuat game bahkan pada perangkat keras yang lemah. <br><br>  Tentang apa yang harus Anda lakukan, bagaimana diputuskan, dan bagaimana melakukan sesuatu lebih dari sekadar klon Pong lainnya - selamat datang di Cat. <br><br>  Perhatian: artikel bagus, traffic, dan banyak sisipan kode! <br><a name="habracut"></a><br><h3>  Secara singkat tentang permainan </h3><hr>  Tembak`em!  - sekarang di AVR. <br><br>  Sebenarnya, ini adalah shmap lain, jadi sekali lagi karakter utama <s>Shepard</s> harus menyelamatkan galaksi dari serangan mendadak oleh orang tak dikenal, membuat jalan melalui ruang melalui bintang-bintang dan bidang asteroid secara bersamaan membersihkan setiap sistem bintang. <br>  Seluruh permainan ditulis dalam C dan C ++ tanpa menggunakan perpustakaan Wire dari Arduino. <br><br>  Permainan memiliki 4 kapal untuk dipilih (yang terakhir tersedia setelah lewat), masing-masing dengan karakteristiknya sendiri: <br><ul><li>  kemampuan manuver; </li><li>  daya tahan; </li><li>  kekuatan senjata. </li></ul><br>  Juga diterapkan: <br><ul><li>  Grafis warna 2D; </li><li>  nyalakan senjata; </li><li>  bos di akhir level; </li><li>  tingkat dengan asteroid (dan animasi rotasi mereka); </li><li>  perubahan warna latar pada level (dan bukan hanya ruang hitam); </li><li>  pergerakan bintang di latar belakang dengan kecepatan yang berbeda (untuk efek kedalaman); </li><li>  penilaian dan penghematan dalam EEPROM; </li><li>  suara yang sama (tembakan, ledakan, dll.); </li><li>  lautan lawan yang identik. </li></ul><br><h3>  Platform </h3><hr>  Kembalinya hantu. <br><br><blockquote>  Saya akan mengklarifikasi terlebih dahulu bahwa platform ini harus dianggap sebagai konsol game lama generasi ketiga <s>pertama</s> (80-an, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">shiru8bit</a> ). <br></blockquote><br>  Juga, modifikasi perangkat keras atas perangkat keras asli dilarang, yang memastikan peluncuran pada papan identik lainnya langsung dari kotak. <br>  Game ini ditulis untuk papan Arduino Esplora, tetapi mentransfer ke GBA atau platform lain, saya pikir, tidak akan sulit. <br>  Namun demikian, bahkan pada sumber daya ini papan ini hanya dibahas beberapa kali, dan papan lainnya tidak layak disebut sama sekali, meskipun masing-masing komunitasnya cukup besar: <br><ul><li>  GameBuino META: </li><li>  Pokitto; </li><li>  pembuatBuino; </li><li>  Arduboy; </li><li>  UzeBox / FuzeBox; </li><li>  dan banyak lainnya. </li></ul><br>  Untuk memulainya, apa yang tidak ada di Esplora: <br><ul><li>  banyak memori (ROM 28kb, RAM 2.5kb); </li><li>  daya (8 bit CPU pada 16 MHz); </li><li>  DMA </li><li>  generator karakter; </li><li>  area memori yang dialokasikan atau register khusus.  tujuan (palet, ubin, latar belakang, dll.); </li><li>  mengontrol kecerahan layar (oh, begitu banyak efek di tempat sampah); </li><li>  address extender ruang (pemetaan); </li><li>  debugger ( <s>tetapi siapa yang membutuhkannya ketika ada seluruh layar!</s> ). </li></ul><br>  Saya akan melanjutkan dengan fakta bahwa ada: <br><ul><li>  perangkat keras SPI (dapat berjalan pada kecepatan F_CPU / 2); </li><li>  layar berdasarkan ST7735 160x128 1,44 "; </li><li>  sejumput penghitung waktu (hanya 4 pcs); </li><li>  sejumput GPIO; </li><li>  beberapa tombol (5 pcs. + joystick dua sumbu); </li><li>  beberapa sensor (pencahayaan, akselerometer, termometer); </li><li>  pemicu <s>iritasi</s> piezo buzzer. </li></ul><br>  Ternyata hampir tidak ada apa-apa di sana.  Tidak mengherankan bahwa tidak ada yang ingin melakukan apa pun dengannya kecuali klon Pong dan beberapa tiga pertandingan selama ini! <br>  Mungkin faktanya adalah bahwa menulis di bawah pengontrol ATmega32u4 (dan sejenisnya) mirip dengan pemrograman untuk Intel 8051 (yang hampir berusia 40 tahun pada saat publikasi), di mana Anda perlu mengamati sejumlah besar kondisi dan menggunakan berbagai trik dan trik. <br><br><h3>  Pemrosesan perangkat </h3><hr>  Satu untuk semuanya! <br><br>  Setelah melihat sirkuit, tampak jelas bahwa semua periferal terhubung melalui GPIO expander (74HC4067D multiplexer lanjut MUX) dan diganti menggunakan GPIO PF4, PF5, PF6, PF7 atau PORTF senior, dan output MUX dibaca pada GPIO - PF1. <br>  Sangat mudah untuk mengganti input hanya dengan memberikan nilai ke port PORTF dengan mask dan tidak melupakan nibble minor: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> getAnalogMux(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chMux) { MUX_PORTX = ((MUX_PORTX &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | ((chMux&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readADC(); }</code> </pre> <br>  Jajak pendapat klik tombol: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_MIN_LVL 800 bool readSwitchButton(uint8_t btn) { bool state = true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(getAnalogMux(btn) &gt; SW_BTN_MIN_LVL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// low state == pressed state = false; } return state; }</span></span></span></span></code> </pre><br>  Berikut ini adalah nilai untuk port F: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_1_MUX 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_2_MUX 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_3_MUX 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_4_MUX 12</span></span></code> </pre><br>  Dengan menambahkan sedikit lebih banyak: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_A SW_BTN_4_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_B SW_BTN_1_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_X SW_BTN_2_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_Y SW_BTN_3_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> buttonIsPressed(a) readSwitchButton(a)</span></span></code> </pre><br>  Anda dapat mewawancarai salib kanan dengan aman: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateBtnStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_A)) btnStates.aBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_B)) btnStates.bBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_X)) btnStates.xBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_Y)) btnStates.yBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Harap perhatikan bahwa kondisi sebelumnya tidak diatur ulang, jika tidak Anda dapat melewatkan fakta menekan tombol (ini juga berfungsi sebagai perlindungan tambahan terhadap obrolan). <br><br><h3>  Sfx </h3><hr>  Sedikit berdengung. <br><br>  Bagaimana jika tidak ada DAC, tidak ada chip dari Yamaha, dan hanya ada persegi panjang PWM 1-bit untuk suara? <br>  Pada awalnya, tampaknya tidak begitu banyak, tetapi, meskipun demikian, PWM yang licik digunakan di sini untuk menciptakan kembali teknik "PDM audio" dan dengan bantuannya Anda dapat melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini.</a> <br><br>  Sesuatu yang serupa disediakan oleh perpustakaan dari Gamebuino dan yang diperlukan hanyalah mentransfer generator popping ke GPIO lain dan timer ke Esplora (output timer4 dan OCR4D).  Untuk operasi yang benar, timer1 juga digunakan untuk menghasilkan interupsi dan memuat ulang register OCR4D dengan data baru. <br><br>  Mesin Gamebuino menggunakan pola suara (seperti dalam musik pelacak), yang menghemat banyak ruang, tetapi Anda perlu melakukan semua sampel sendiri, tidak ada perpustakaan dengan yang sudah jadi. <br>  Perlu disebutkan bahwa mesin ini terikat pada periode pembaruan sekitar 1/50 detik atau 20 frame / detik. <br><br>  Untuk membaca pola suara, setelah membaca Wiki dalam format audio, saya membuat sketsa GUI sederhana pada Qt.  Ini tidak menghasilkan suara dengan cara yang sama, tetapi memberikan konsep perkiraan tentang bagaimana pola akan berbunyi dan memungkinkan Anda memuat, menyimpan, dan mengeditnya. <br><br><h3>  Grafik </h3><hr>  Pixelart Abadi. <br><br>  Layar mengkodekan warna dalam dua byte (RGB565), tetapi karena gambar dalam format ini akan memakan banyak, semuanya telah diindeks oleh palet untuk menghemat ruang, yang telah saya jelaskan lebih dari sekali dalam artikel saya sebelumnya. <br>  Tidak seperti Famicom / NES, tidak ada batas warna untuk gambar dan ada lebih banyak warna yang tersedia di palet. <br><br>  Setiap gambar dalam game adalah array byte di mana data berikut disimpan: <br><ul><li>  lebar, tinggi; </li><li>  mulai penanda data; </li><li>  kamus (jika ada, tetapi lebih lanjut tentang itu nanti); </li><li>  muatan; </li><li>  akhir penanda data. </li></ul><br>  Misalnya, gambar seperti itu (diperbesar 10 kali): <br><img src="https://habrastorage.org/webt/zk/rr/es/zkrresh27swmtvck9fagoemando.png"><br><br>  dalam kode itu akan terlihat seperti ini: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pic_t</span></span> weaponLaserPic1[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0x0f</span></span>,<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x32</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x23</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>, };</code> </pre><br>  Di mana tanpa kapal dalam genre ini?  Setelah ratusan sketsa uji dengan perbedaan piksel, hanya kapal-kapal ini yang tersisa untuk pemain: <br><img src="https://habrastorage.org/webt/ao/4y/jm/ao4yjmxt3bl3ydqrjajnmgy4ms8.png"><br>  Patut dicatat bahwa kapal-kapal tidak memiliki nyala di ubin (ini untuk kejelasan), itu diterapkan secara terpisah untuk membuat animasi knalpot dari mesin. <br><br>  Jangan lupa tentang pilot dari setiap kapal: <br><img src="https://habrastorage.org/webt/fk/fj/xf/fkfjxfoscgeu69pabaolb4zt6mo.png"><br><br>  Variasi kapal musuh tidak terlalu besar, tetapi izinkan saya mengingatkan Anda, tidak ada terlalu banyak ruang, jadi di sini ada tiga kapal: <br><img src="https://habrastorage.org/webt/w2/-v/o3/w2-vo3itdzkpoptpywwgjn5ytc8.png"><br><br>  Tanpa bonus kanonik dalam bentuk meningkatkan senjata dan memulihkan kesehatan, pemain tidak akan bertahan lama: <br><img src="https://habrastorage.org/webt/kw/gw/7d/kwgw7duf5hnztuobgg_pwclk8nm.png"><br><br>  Tentu saja, dengan meningkatnya kekuatan senjata, jenis peluru yang dipancarkan berubah: <br><img src="https://habrastorage.org/webt/yq/dn/67/yqdn67u3cvbmzbn0j46v9iiievy.png"><br><br>  Seperti yang ditulis di awal, permainan memiliki tingkat dengan asteroid, itu terjadi setelah setiap bos kedua.  Sangat menarik karena ada banyak benda bergerak dan berputar dengan ukuran berbeda.  Selain itu, ketika seorang pemain memukul mereka, mereka sebagian runtuh, menjadi lebih kecil ukurannya. <br><blockquote>  Petunjuk: Asteroid besar mendapat lebih banyak poin. <br></blockquote><br><img src="https://habrastorage.org/webt/d6/hg/9a/d6hg9atxd8gzj9m9njyhac4i7bq.gif"><br><img src="https://habrastorage.org/webt/ow/pv/yf/owpvyfbgmn45yueagrafne4w2ng.gif"><br><img src="https://habrastorage.org/webt/jc/eh/r_/jcehr_zvccitvi24lcdmxiiewik.gif"><br>  Untuk membuat animasi sederhana ini, 12 gambar kecil sudah cukup: <br><img src="https://habrastorage.org/webt/yr/uz/g3/yruzg3mwjlg3bv_z2pljhzyql68.png"><br>  Mereka dibagi menjadi tiga untuk setiap ukuran (besar, sedang dan kecil) dan untuk setiap sudut rotasi Anda perlu 4 lebih diputar 0, 90, 180 dan 270 derajat.  Dalam permainan, cukup untuk mengganti pointer ke array dengan gambar pada interval yang sama sehingga menciptakan ilusi rotasi. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAsteroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">asteroid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;asteroid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { asteroid.sprite.pPic = getAsteroidPic(asteroid); ++asteroid.angle; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveAsteroids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;asteroid : asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(asteroid.onUse) { updateSprite(&amp;asteroid.sprite); rotateAsteroid(asteroid); ...</code> </pre><br>  Ini dilakukan hanya karena kurangnya kemampuan perangkat keras, dan implementasi perangkat lunak seperti transformasi Affine akan mengambil lebih dari gambar itu sendiri dan akan sangat lambat. <br><br><div class="spoiler">  <b class="spoiler_title">Sepotong satin untuk mereka yang tertarik.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/el/uf/0l/eluf0lkcjsygvumvmosh_yzreig.png"><br>  Anda dapat melihat bagian dari prototipe dan apa yang muncul hanya di kredit setelah melewati permainan. <br></div></div><br>  Selain grafis sederhana, untuk menghemat ruang dan menambahkan efek retro, mesin terbang huruf kecil dan semua mesin terbang yang hingga 30 dan setelah 127 byte ASCII dikeluarkan dari font. <br><blockquote>  Penting! <br>  Jangan lupa bahwa const dan constexpr pada AVR tidak berarti sama sekali bahwa data akan ada dalam memori program, di sini untuk ini Anda perlu tambahan menggunakan PROGMEM. <br>  Hal ini disebabkan oleh fakta bahwa inti AVR didasarkan pada arsitektur Harvard, sehingga kode akses khusus untuk CPU diperlukan untuk mengakses data. <br></blockquote><br><h3>  Meremas galaksi </h3><hr>  Cara termudah untuk berkemas adalah RLE. <br><br>  Setelah mempelajari data yang dikemas, Anda dapat melihat bahwa bit paling signifikan dalam byte payload dalam rentang dari 0x00 hingga 0x50 tidak digunakan.  Ini memungkinkan Anda untuk menambahkan data dan penanda awal untuk awal pengulangan (0x80), dan byte berikutnya untuk menunjukkan jumlah pengulangan, yang memungkinkan Anda untuk mengemas serangkaian 257 (+2 dari kenyataan bahwa RLE dua byte bodoh) dengan byte identik hanya dalam dua. <br>  Implementasi dan tampilan unpacker: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_RLE_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpInd, repeatTimes; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); ++pPic; <span class="hljs-comment"><span class="hljs-comment">// make offset to picture data while((tmpInd = getPicByte(++pPic)) != PIC_DATA_END) { // get color index or repeat times if(tmpInd &amp; RLE_MARK) { // is it color index? tmpInd &amp;= DATA_MARK; // get color index to repeat repeatTimes = getPicByte(++pPic)+1; // zero RLE does not exist! } ++repeatTimes; // get color from colorTable by color index repeatColor = palette_RAM[(tmpInd == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpInd]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  Hal utama adalah tidak menampilkan gambar di luar layar, jika tidak akan menjadi sampah, karena tidak ada pemeriksaan perbatasan di sini. <br>  Gambar uji dibongkar dalam ~ 39ms.  pada saat yang sama, menempati 3040 byte, sementara tanpa kompresi dibutuhkan 11.200 byte atau 22.400 byte tanpa pengindeksan. <br><br>  Gambar uji (diperbesar 2 kali): <br><img src="https://habrastorage.org/webt/ao/nl/6n/aonl6nxjmfjhbsmp0uc4n6h7w0e.png"><br>  Pada gambar di atas Anda dapat melihat interlace, tetapi pada layar itu dihaluskan oleh perangkat keras, menciptakan efek yang mirip dengan CRT dan pada saat yang sama secara signifikan meningkatkan rasio kompresi. <br><br><h3>  RLE bukan obat mujarab </h3><hr>  Kami diperlakukan untuk deja vu. <br><br>  Seperti yang Anda tahu, RLE berjalan baik dengan pengepak seperti LZ.  WiKi datang ke penyelamatan dengan daftar metode kompresi.  Dorongannya adalah video dari "GameHut" tentang analisis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intro yang</a> mustahil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Sonic 3D Blast.</a> <br>  Setelah mempelajari banyak pengepak (LZ77, LZW, LZSS, LZO, RNC, dll.), Saya sampai pada kesimpulan bahwa mereka membongkar: <br><ul><li>  membutuhkan banyak RAM untuk data yang tidak dibongkar (setidaknya 64kb. dan lebih banyak); </li><li>  tebal dan lambat (beberapa perlu membangun pohon Huffman untuk setiap subunit); </li><li>  memiliki rasio kompresi yang rendah dengan jendela kecil (persyaratan RAM yang sangat ketat); </li><li>  memiliki ambiguitas dengan perizinan. </li></ul><br>  Setelah berbulan-bulan adaptasi yang sia-sia, diputuskan untuk memodifikasi paket yang ada. <br>  Dengan analogi dengan pengemas mirip LZ, untuk mencapai kompresi maksimum, akses kamus digunakan, tetapi pada tingkat byte - pasangan byte yang paling sering digantikan diganti dengan satu byte pointer dalam kamus. <br>  Tapi ada yang menarik: bagaimana membedakan byte "berapa banyak pengulangan" dari "kamus"? <br>  Setelah lama duduk dengan selembar kertas dan permainan ajaib dengan kelelawar, ini muncul: <br><blockquote><ul><li>  "Kamus penanda" adalah penanda RLE (0x80) + byte data (0x50) + nomor posisi dalam kamus; </li><li>  batasi byte "berapa banyak pengulangan" ke ukuran penanda kamus - 1 (0xCF); </li><li>  kamus tidak dapat menggunakan nilai 0xff (ini untuk penanda untuk akhir gambar). </li></ul><br></blockquote><br>  Menerapkan semua ini, kami mendapatkan ukuran kamus tetap: tidak lebih dari 46 byte pasangan dan pengurangan RLE menjadi 209 byte.  Jelas, tidak semua gambar dapat dikemas seperti ini, tetapi mereka tidak akan menjadi lagi. <br>  Dalam kedua algoritma, struktur gambar yang dikemas adalah sebagai berikut: <br><ul><li>  1 byte per lebar dan tinggi; </li><li>  1 byte untuk ukuran kamus, itu adalah penanda marker ke awal data yang dikemas; </li><li>  dari 0 hingga 92 byte kamus; </li><li>  1 hingga N byte data yang dikemas. </li></ul><br>  Utilitas packer yang dihasilkan pada D (pickoPacker) cukup untuk dimasukkan ke dalam folder dengan file * .png yang diindeks dan dijalankan dari terminal (atau cmd).  Jika Anda butuh bantuan, jalankan dengan opsi "-h" atau "--help". <br>  Setelah utilitas berjalan, kami mendapatkan file * .h, yang isinya nyaman untuk ditransfer ke tempat yang tepat dalam proyek (oleh karena itu, tidak ada perlindungan). <br><br>  Sebelum membongkar, layar, kamus, dan data awal disiapkan: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_DIC_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpByte, unfoldPos, dictMarker; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pDict = &amp;pPic[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// save dictionary pointer pPic += getPicByte(&amp;pPic[2]); // make offset to picture data do { unfoldPos = dictMarker = 0; do { if((tmpByte = getPicByte(++pPic)) != PIC_DATA_END) { if(tmpByte &lt; DICT_MARK) { buf_packed[unfoldPos] = tmpByte; } else { dictMarker = 1; setPicWData(&amp;buf_packed[unfoldPos]) = getPicWData(pDict, tmpByte); ++unfoldPos; } ++unfoldPos; } else { break; } } while((unfoldPos &lt; MAX_UNFOLD_SIZE) //&amp;&amp; (unfoldPos) &amp;&amp; ((tmpByte &gt; DATA_MARK) || (tmpByte &gt; MAX_DATA_LENGTH))); if(unfoldPos) { buf_packed[unfoldPos] = PIC_DATA_END; // mark end of chunk printBuf_RLE( dictMarker ? unpackBuf_DIC(pDict) : &amp;buf_packed[0] ); // V2V3 decoder } } while(unfoldPos); }</span></span></code> </pre><br>  Potongan data yang sudah dibaca dapat dikemas dalam kamus, jadi kami memeriksa dan membukanya: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPackedMark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptr &gt;= DICT_MARK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*(++ptr) != PIC_DATA_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackBuf_DIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pDict)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> swap = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dictMarker = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getBufferPtr = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a[], <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap ? &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : &amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrP = getBufferPtr(buf_unpacked, buf_packed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrU = getBufferPtr(buf_packed, buf_unpacked); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dictMarker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP &gt;= DICT_MARK) { setPicWData(ptrU) = getPicWData(pDict, *ptrP); ++ptrU; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *ptrU = *ptrP; } ++ptrU; ++ptrP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP == PIC_DATA_END) { *ptrU = *ptrP; <span class="hljs-comment"><span class="hljs-comment">// mark end of chunk swap = !swap; ptrP = getBufferPtr(buf_unpacked, buf_packed); ptrU = getBufferPtr(buf_packed, buf_unpacked); dictMarker = findPackedMark(ptrP); } } return getBufferPtr(buf_unpacked, buf_packed); }</span></span></code> </pre><br>  Sekarang dari buffer yang diterima kami membongkar RLE dengan cara yang akrab dan menampilkannya di layar: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printBuf_RLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> repeatTimes, tmpByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tmpByte = *pData) != PIC_DATA_END) { <span class="hljs-comment"><span class="hljs-comment">// get color index or repeat times if(tmpByte &amp; RLE_MARK) { // is it RLE byte? tmpByte &amp;= DATA_MARK; // get color index to repeat repeatTimes = *(++pData)+1; // zero RLE does not exist! } ++repeatTimes; ++pData; // get color from colorTable by color index repeatColor = palette_RAM[(tmpByte == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpByte]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  Anehnya, mengganti algoritma tidak secara signifikan mempengaruhi waktu pembongkaran dan ~ 47ms.  Ini hampir 8 ms.  lebih lama, tetapi gambar uji hanya membutuhkan 1.650 byte! <br><br><h3>  Sampai langkah terakhir </h3><hr>  Hampir semuanya bisa dilakukan lebih cepat! <br><br>  Meskipun ada perangkat keras SPI, inti AVR memberikan banyak sakit kepala saat menggunakannya. <br>  Sudah lama diketahui bahwa SPI pada AVR, selain berjalan pada kecepatan F_CPU / 2, juga memiliki register data hanya 1 byte (tidak mungkin memuat 2 byte sekaligus). <br>  Selain itu, hampir semua kode SPI pada AVR yang saya temui berfungsi sesuai dengan skema ini: <br><ul><li>  Unduh data SPDR </li><li>  menginterogasi bit SPIF dalam SPSR dalam satu lingkaran. </li></ul><br>  Seperti yang Anda lihat, pasokan data yang berkelanjutan, seperti yang dilakukan pada STM32, tidak berbau di sini.  Tetapi, bahkan di sini Anda dapat mempercepat output dari kedua unpacker dengan ~ 3ms! <br><br>  Dengan membuka lembar data dan melihat bagian "Instruction set clocks", Anda dapat menghitung biaya CPU saat mengirimkan byte melalui SPI: <br><ul><li>  1 siklus untuk memuat register dengan data baru; </li><li>  2 denyut per bit (atau 16 denyut per byte); </li><li>  1 bilah per baris sihir jam (sedikit kemudian tentang "NOP"); </li><li>  1 jam untuk memeriksa bit status di SPSR (atau 2 jam di cabang); </li></ul><br>  Secara total, untuk mengirimkan satu piksel (dua byte), 38 siklus clock atau ~ 425600 siklus clock untuk gambar uji (11.200 byte) harus dihabiskan. <br>  Mengetahui bahwa F_CPU == 16 MHz kita mendapatkan <s>0,0000000625</s> 62,5 nanosecond per clock cycle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Process0169</a> ), dengan mengalikan nilainya, kita mendapatkan ~ 26 milidetik.  Muncul pertanyaan: “Dari mana saya menulis sebelumnya bahwa waktu pembongkaran 39ms.  dan 47ms. "?  Semuanya sederhana - logika unpacker + penanganan interupsi. <br><br>  Ini adalah contoh dari interupsi output: <br><img src="https://habrastorage.org/webt/du/ks/p1/duksp1nkfluio5sgfwyimgo9aik.png"><br>  dan tanpa gangguan: <br><img src="https://habrastorage.org/webt/v7/hp/xq/v7hpxqzhvsazrct5sbq7dkywq1w.png"><br>  Grafik menunjukkan bahwa waktu antara pengaturan jendela alamat di layar VRAM dan awal transfer data dalam versi tanpa gangguan lebih sedikit dan hampir tidak ada kesenjangan antara byte selama transmisi (grafik seragam). <br>  Sayangnya, Anda tidak dapat menonaktifkan interupsi untuk setiap output gambar, jika tidak suara dan inti dari seluruh permainan akan pecah (lebih lanjut tentang itu nanti). <br><br>  Itu ditulis di atas tentang "sihir NOP" tertentu untuk garis jam.  Faktanya adalah bahwa untuk menstabilkan CLK dan mengatur flag SPIF, dibutuhkan siklus 1 jam dan saat flag ini dibaca, flag tersebut sudah diset, yang menghindari percabangan menjadi 2 bar pada instruksi BREQ. <br>  Berikut ini adalah contoh tanpa NOP: <br><img src="https://habrastorage.org/webt/vp/ia/w5/vpiaw5asga4dqawu3byh03k9gii.png"><br>  dan bersamanya: <br><img src="https://habrastorage.org/webt/jg/-q/4b/jg-q4b4ot1sy445kc5rvoyq-ixe.png"><br><br>  Perbedaannya tampaknya tidak signifikan, hanya beberapa mikrodetik, tetapi jika Anda mengambil skala yang berbeda: <br>  NOP besar: <br><img src="https://habrastorage.org/webt/nf/ds/gi/nfdsgii8xkar_f6jo5fihrpx8ei.png"><br>  dan dengan itu terlalu besar: <br><img src="https://habrastorage.org/webt/8z/d9/e9/8zd9e9l79lnhj9qshrykzxxptmw.png"><br>  maka perbedaannya menjadi jauh lebih terlihat, mencapai ~ 4.3ms. <br><br>  Sekarang mari kita lakukan trik kotor berikut: <br><blockquote>  Kami menukar urutan memuat dan membaca register dan Anda tidak bisa menunggu setiap byte kedua dari bendera SPIF, tetapi memeriksanya hanya sebelum memuat byte pertama dari piksel berikutnya. <br></blockquote><br>  Kami menerapkan pengetahuan dan menyebarkan fungsi "pushColorFast (repeatColor);": <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPDR_TX_WAIT(a) asm volatile(a); while((SPSR &amp; (1&lt;&lt;SPIF)) == 0); typedef union { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } SPDR_t; ... do { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_t in = {.val = repeatColor}; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); SPDR = in.msb; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nop"</span></span></span><span class="hljs-meta">); SPDR = in.lsb; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pushColorFast(repeatColor); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } while(--repeatTimes); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// dummy wait to stable SPI #endif }</span></span></span></span></code> </pre><br>  Meskipun ada gangguan dari timer, menggunakan trik di atas memberikan keuntungan hampir 6ms.: <br><img src="https://habrastorage.org/webt/ba/ah/hm/baahhmqnnvjznm1ssuihfi-ryhu.png"><br><br>  Inilah cara pengetahuan besi yang sederhana memungkinkan Anda memeras sedikit lebih banyak darinya dan menghasilkan sesuatu yang serupa: <br><img src="https://habrastorage.org/webt/xo/fj/wv/xofjwvtbu_w_4leeunorug-axri.gif"><br><br><h3>  Tabrakan colosseum </h3><hr>  Pertempuran kotak. <br><br>  Untuk mulai dengan, seluruh rangkaian objek (kapal, kerang, asteroid, bonus) adalah struktur (sprite) dengan parameter berikut: <br><ul><li>  koordinat X, Y saat ini; </li><li>  koordinat baru X, Y; </li><li>  arahkan ke gambar. </li></ul><br>  Karena gambar menyimpan lebar dan tinggi, tidak perlu menduplikasi parameter ini, apalagi, organisasi seperti itu menyederhanakan logika dalam banyak aspek. <br><br>  Perhitungannya sendiri dibuat sederhana untuk dangkal - berdasarkan persimpangan dari segi empat.  Meskipun tidak cukup akurat dan tidak menghitung konflik di masa depan, ini lebih dari cukup. <br>  Verifikasi berlangsung secara bergantian pada sumbu X dan Y. Karena ini, tidak adanya persimpangan pada sumbu X mengurangi perhitungan tabrakan. <br><blockquote>  Pertama, sisi kanan dari persegi panjang pertama dengan sisi kiri dari persegi panjang kedua diperiksa untuk bagian umum dari sumbu X. Jika berhasil, pemeriksaan serupa dilakukan untuk sisi kiri dari sisi pertama dan sisi kanan dari persegi panjang kedua. <br>  Setelah berhasil mendeteksi persimpangan di sepanjang sumbu X, pemeriksaan dilakukan dengan cara yang sama untuk sisi atas dan bawah dari persegi panjang di sepanjang sumbu Y. <br></blockquote><br>  Di atas terlihat jauh lebih mudah daripada yang terlihat: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSpriteCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprOne, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprTwo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataOne = getPicSize(pSprOne-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataTwo = getPicSize(pSprTwo-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ----------- Check X position ----------- */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objOnePosEndX = (pSprOne-&gt;pos.Old.x + tmpDataOne.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(objOnePosEndX &gt;= pSprTwo-&gt;pos.Old.x) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objTwoPosEndX = (pSprTwo-&gt;pos.Old.x + tmpDataTwo.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pSprOne-&gt;pos.Old.x &gt;= objTwoPosEndX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nope, different X positions } // ok, objects on same X lines; Go next... } else { return false; // nope, absolutelly different X positions } /* ---------------------------------------- */ /* ----------- Check Y position ----------- */ uint8_t objOnePosEndY = (pSprOne-&gt;pos.Old.y + tmpDataOne.u8Data2); if(objOnePosEndY &gt;= pSprTwo-&gt;pos.Old.y) { uint8_t objTwoPosEndY = (pSprTwo-&gt;pos.Old.y + tmpDataTwo.u8Data2); if(pSprOne-&gt;pos.Old.y &lt;= objTwoPosEndY) { // ok, objects on same Y lines; Go next... // yep, if we are here // then, part of one object collide wthith another object return true; } else { return false; // nope, different Y positions } } else { return false; // nope, absolutelly different Y positions } }</span></span></code> </pre><br>  Tetap menambahkan ini ke permainan: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInVadersCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(aliens[<span class="hljs-number"><span class="hljs-number">0</span></span>].weapon.ray) gopher; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alien.alive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkSpriteCollision(&amp;ship.sprite, &amp;alien.sprite)) { gopher.sprite.pos.Old = alien.sprite.pos.Old; rocketEpxlosion(&amp;gopher); <span class="hljs-comment"><span class="hljs-comment">// now make gopher to explode \(^_^)/ removeSprite(&amp;alien.sprite); alien.alive = false; score -= SCORE_PENALTY; if(score &lt; 0) score = 0; } } } }</span></span></code> </pre><br><br><h3>  Kurva Bezier </h3><hr>  Rel ruang. <br><br>  Seperti dalam game lain dengan genre ini, kapal musuh harus bergerak di sepanjang kurva. <br>  Diputuskan untuk menerapkan kurva kuadrat sebagai yang paling sederhana untuk controller dan tugas ini.  Tiga poin sudah cukup untuk mereka: awal (P0), final (P2) dan imajiner (P1).  Dua yang pertama menentukan awal dan akhir garis, titik terakhir menggambarkan jenis kelengkungan. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel bagus tentang kurva.</a> <br>  Karena ini adalah kurva parametrik Bezier, itu juga membutuhkan satu parameter lagi - jumlah titik antara antara titik awal dan titik akhir. <br><br>  Jadi kita mendapatkan struktur ini: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 7 bytes position_t P0; position_t P1; position_t P2; uint8_t totalSteps; } bezier_t;</span></span></code> </pre>  Di dalamnya, position_t adalah struktur dua byte koordinat X dan Y. <br>  Menemukan titik untuk setiap koordinat dihitung menggunakan rumus ini (thx Wiki): <br>  B = ((1,0 - t) ^ 2) P0 + 2t (1,0 - t) P1 + (t ^ 2) P2, <br>  t [&gt; = 0 &amp;&amp; &lt;= 1] <br><br>  Untuk waktu yang lama, implementasinya diselesaikan secara langsung tanpa matematika titik tetap: <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pItemLine-&gt;step)/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pLine-&gt;totalSteps); pPos-&gt;x = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.x + t*t*pLine-&gt;P2.x; pPos-&gt;y = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.y + t*t*pLine-&gt;P2.y; ...</code> </pre><br>  Tentu saja, ini tidak bisa dibiarkan.  Bagaimanapun, menyingkirkan float tidak hanya dapat memberikan peningkatan dalam kecepatan, tetapi juga membebaskan ROM, sehingga implementasi berikut ditemukan: <br><ul><li>  avrfix; </li><li>  stdfix; </li><li>  libfixmath; </li><li>  fixedptc. </li></ul><br>  Yang pertama tetap menjadi kuda hitam, karena merupakan perpustakaan yang dikompilasi dan tidak ingin mengacaukan pembongkaran. <br><br>  Kandidat kedua dari bundel GCC juga tidak berhasil, karena avr-gcc yang digunakan tidak ditambal dan tipe "short _Accum" tetap tidak tersedia. <br><br>  Pilihan ketiga, meskipun memiliki sejumlah besar mat.  fungsi, memiliki operasi bit kode keras pada bit tertentu di bawah format Q16.16, yang membuatnya tidak mungkin untuk mengontrol nilai-nilai Q dan I. <br><br>  Yang terakhir dapat dianggap sebagai versi yang disederhanakan dari "fixedmath", tetapi keuntungan utama adalah kemampuan untuk mengontrol tidak hanya ukuran variabel, yang secara default adalah 32bit dengan format Q24.8, tetapi juga nilai Q dan I. <br><br>  Hasil pengujian pada pengaturan yang berbeda: <br><table><tbody><tr><th>  Jenis </th><th>  IQ </th><th>  Bendera tambahan </th><th>  Byte ROM </th><th>  Tms. * </th></tr><tr><td>  mengapung </td><td>  - </td><td>  - </td><td>  4236 </td><td>  35 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  - </td><td>  4796 </td><td>  119 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  FIXMATH_NO_OVERFLOW </td><td>  4664 </td><td>  89 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  FIXMATH_OPTIMIZE_8BIT </td><td>  5036 </td><td>  92 </td></tr><tr><td>  fixedmath </td><td>  16.16 </td><td>  _NO_OVERFLOW + _8BIT </td><td>  4916 </td><td>  89 </td></tr><tr><td>  fixedptc </td><td>  24.8 </td><td>  FIXEDPT_BITS 32 </td><td>  4420 </td><td>  64 </td></tr><tr><td>  fixedptc </td><td>  9.7 </td><td>  FIXEDPT_BITS 16 </td><td>  3490 </td><td>  31 </td></tr></tbody></table>  * Cek dilakukan pada pola: "195.175.145.110.170.170.170" dan kunci "-O". <br><br>  Dapat dilihat dari tabel bahwa kedua perpustakaan mengambil lebih banyak ROM dan menunjukkan diri mereka lebih buruk daripada kode yang dikompilasi dari GCC saat menggunakan float. <br>  Terlihat juga bahwa revisi kecil untuk format Q9.7 dan penurunan variabel ke 16bit memberikan akselerasi 4ms.  dan membebaskan ROM pada ~ 50 byte. <br><br>  Efek yang diharapkan adalah penurunan akurasi dan peningkatan jumlah kesalahan: <br><img src="https://habrastorage.org/webt/sz/v0/yt/szv0ytpsb0ogl5hkp39blbggvzw.png"><br>  yang dalam hal ini tidak kritis. <br><br><h3>  Mengalokasikan sumber daya </h3><hr>  Selasa dan Kamis hanya bekerja satu jam. <br><br>  Dalam kebanyakan kasus, semua perhitungan dilakukan setiap frame, yang tidak selalu dibenarkan, karena mungkin tidak ada cukup waktu dalam frame untuk menghitung sesuatu dan Anda harus mengelabui dengan bergantian, menghitung frame atau melewatkannya.  Jadi saya melangkah lebih jauh - benar-benar meninggalkan staf. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memecah semuanya menjadi tugas-tugas kecil, baik itu: menghitung tabrakan, memproses suara, tombol dan menampilkan grafik, itu sudah cukup untuk melakukan mereka pada interval tertentu, dan kelambanan mata dan kemampuan untuk memperbarui hanya bagian layar akan melakukan trik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengelola semua ini tidak hanya dengan OS, tetapi dengan mesin negara yang saya buat beberapa tahun yang lalu, atau, lebih tepatnya, bukan task manager SM yang kecil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan mengulangi alasan untuk menggunakannya daripada RTOS:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> persyaratan ROM yang lebih rendah (~ 250 byte inti); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> persyaratan RAM yang lebih rendah (~ 9 byte per tugas); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prinsip kerja yang sederhana dan mudah dipahami; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> determinisme perilaku; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih sedikit waktu CPU yang terbuang; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meninggalkan akses ke zat besi; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> platform independen; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditulis dalam C dan mudah dibungkus dalam C ++; </font></font></li><li> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan sepeda saya sendiri.</font></font></s> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang pernah saya jelaskan, tugas untuknya diatur ke dalam array pointer ke struktur, di mana pointer ke fungsi dan interval panggilannya disimpan. </font><font style="vertical-align: inherit;">Pengelompokan ini menyederhanakan deskripsi gim dalam tahap-tahap terpisah, yang juga memungkinkan Anda untuk mengurangi jumlah cabang dan secara dinamis mengganti serangkaian tugas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, selama layar mulai, 7 tugas dilakukan, dan selama permainan sudah ada 20 tugas (semua tugas dijelaskan dalam file gameTasks.c). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, Anda perlu mendefinisikan beberapa makro untuk kenyamanan Anda:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> T(a) a##Task #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_N(a) const taskParams_t T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK(a,b) TASK_N(a) PROGMEM = {.pFunc=a, .timeOut=b} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_P(a) (taskParams_t*)&amp;T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR_N(a) const tasksArr_t a##TasksArr[] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR(a) TASK_ARR_N(a) PROGMEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_END NULL</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deklarasi tugas sebenarnya membuat struktur, menginisialisasi bidangnya dan menempatkannya di ROM: </font></font><br><pre> <code class="cpp hljs">TASK(updateBtnStates, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap struktur tersebut menempati 4 byte ROM (dua per pointer dan dua per interval). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus bagus untuk makro adalah tidak berfungsi untuk membuat lebih dari satu struktur unik untuk setiap fungsi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mendeklarasikan tugas yang diperlukan, kami menambahkannya ke array dan juga meletakkannya di ROM:</font></font><br><pre> <code class="cpp hljs">TASK_ARR( game ) = { TASK_P(updateBtnStates), TASK_P(playMusic), TASK_P(drawStars), TASK_P(moveShip), TASK_P(drawShip), TASK_P(checkFireButton), TASK_P(pauseMenu), TASK_P(drawPlayerWeapon), TASK_P(checkShipHealth), TASK_P(drawSomeGUI), TASK_P(checkInVaders), TASK_P(drawInVaders), TASK_P(moveInVaders), TASK_P(checkInVadersRespawn), TASK_P(checkInVadersRay), TASK_P(checkInVadersCollision), TASK_P(dropWeaponGift), TASK_END };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat mengatur flag USE_DYNAMIC_MEM ke 0 untuk memori statis, hal utama yang perlu diingat adalah menginisialisasi pointer ke task store di RAM dan mengatur jumlah maksimumnya yang akan dieksekusi: </font></font><br><pre> <code class="cpp hljs">... tasksContainer_t tasksContainer; taskFunc_t tasksArr[MAX_GAME_TASKS]; ... initTasksArr(&amp;tasksContainer, &amp;tasksArr[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_GAME_TASKS); …</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengatur tugas untuk dieksekusi: </font></font><br><pre> <code class="cpp hljs">... addTasksArray_P(gameTasksArr); …</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlindungan overflow dikendalikan oleh flag USE_MEM_PANIC, jika Anda yakin tentang jumlah tugas, Anda dapat menonaktifkannya untuk menyimpan ROM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinggal menjalankan handler saja:</font></font><br><pre> <code class="cpp hljs">... runTasks(); ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di dalam adalah loop tak terbatas yang berisi logika dasar. </font><font style="vertical-align: inherit;">Setelah masuk, tumpukan juga dikembalikan berkat "__attribute__ ((noreturn))". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam loop, elemen-elemen array dipindai secara bergantian untuk keperluan memanggil tugas setelah interval berakhir. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penghitungan interval dibuat berdasarkan timer0 sebagai sistem dengan kuantum 1ms ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun distribusi tugas berhasil dalam waktu, mereka terkadang tumpang tindih (jitter), yang menyebabkan pemudaran jangka pendek dari segala sesuatu dan segala sesuatu dalam permainan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasti harus diputuskan, tetapi bagaimana? </font><font style="vertical-align: inherit;">Tentang bagaimana semuanya diprofilkan di waktu berikutnya, tetapi untuk sekarang coba cari telur Paskah di sumbernya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akhirnya </font></font></h3><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, menggunakan banyak trik (dan banyak lagi yang belum saya jelaskan), semuanya ternyata sesuai dengan ROM 24kb dan 1500 byte RAM. </font><font style="vertical-align: inherit;">Jika Anda memiliki pertanyaan, saya akan dengan senang hati menjawabnya.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagi mereka yang tidak menemukan atau tidak mencari telur Paskah:</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gali ke samping: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invadersMagicRespawn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak ada yang luar biasa, bukan? </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raaaaazvorachivaem macro invadersMagicRespawn:</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tftSetTextSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { tftSetCP437(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); tftSetTextColorBG((((RN % <span class="hljs-number"><span class="hljs-number">192</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFC</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), COLOR_BLACK); tftDrawCharInt(((RN % <span class="hljs-number"><span class="hljs-number">26</span></span>) * <span class="hljs-number"><span class="hljs-number">6</span></span>), ((RN &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>), (RN % <span class="hljs-number"><span class="hljs-number">255</span></span>)); tftPrintAt_P(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)creditP0); } } a(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   «(void)»    ,  «action()»          10 ,    «disablePause();».               «Matrix Falling code»    .       130  ROM. <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk membangun dan menjalankan, cukup letakkan folder (atau tautan) "esploraAPI" di "/ arduino / libraries /". </font></font><br><br>  Referensi: <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebuah game;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esploraAPI;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pickoPacker packer;</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NB. Anda dapat melihat dan mendengar bagaimana tampilannya nanti setelah saya membuat video yang dapat diterima. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425407/">https://habr.com/ru/post/id425407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425395/index.html">10 fakta fisik yang seharusnya Anda ketahui di sekolah tetapi mungkin tidak diketahui</a></li>
<li><a href="../id425397/index.html">10 perpustakaan yang harus diketahui oleh setiap pengembang Android</a></li>
<li><a href="../id425401/index.html">Laporan Club of Rome 2018, Bab 1.11: Teknologi Mengganggu dan Revolusi Digital</a></li>
<li><a href="../id425403/index.html">Keuangan pembuat Craigslist: situs melawan berita palsu, diskriminasi dan ekses raksasa internet</a></li>
<li><a href="../id425405/index.html">Newtype kekuatan besar</a></li>
<li><a href="../id425409/index.html">DevBoy: membuat generator sinyal</a></li>
<li><a href="../id425411/index.html">Scrum sudah mati</a></li>
<li><a href="../id425413/index.html">Apakah joon sangat baik?</a></li>
<li><a href="../id425415/index.html">Perl 5: bagaimana makro menyembunyikan kesalahan</a></li>
<li><a href="../id425417/index.html">Flash untuk semua orang. Semua Flash Array dari QSAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>