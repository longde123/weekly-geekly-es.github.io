<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❤️ 🤙🏿 💺 PostgreSQL中的WAL：1.缓冲区缓存 🚵 👌🏼 👶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="之前的系列致力于PostgreSQL的隔离和多版本 ，今天我们开始了一个新的- 关于预写日志记录机制 。 让我提醒您，该材料基于Pavel pluzanov和我所做的行政培训课程 ，但不会逐字重复，并且旨在进行深思熟虑的阅读和独立的实验。 

 此周期将包括四个部分： 



- 缓冲区缓存（本文）...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL中的WAL：1.缓冲区缓存</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/458186/"> 之前的系列致力于PostgreSQL的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隔离和多版本</a> ，今天我们开始了一个新的- <strong>关于</strong>预写日志记录<strong>机制</strong> 。 让我提醒您，该材料基于Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">pluzanov</a>和我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">所做的</a>行政<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">培训课程</a> ，但不会逐字重复，并且旨在进行深思熟虑的阅读和独立的实验。 <br><br> 此周期将包括四个部分： <br><br><ul><li> 缓冲区缓存（本文）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预录日志</a> -在恢复过程中如何安排以及如何使用它； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">检查点</a>和后台记录-为什么需要它们以及如何配置它们； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">日志调整</a> -要解决的级别和任务，可靠性和性能。 </li></ul><br><h1> 为什么需要日记？ </h1><br> 在此过程中，DBMS处理的部分数据以延迟的方式存储在RAM中并写入磁盘（或其他非易失性介质）。 这种情况发生的次数越少，输入输出越少，系统运行越快。 <br><br> 但是，如果发生故障（例如，关闭电源或DBMS代码或操作系统中发生错误），将会发生什么？  RAM中的所有内容都将丢失，仅保留写入磁盘的数据（在某些类型的故障中，磁盘也可能会受到影响，但在这种情况下，仅备份副本会有所帮助）。 原则上，I / O的组织方式可以使磁盘上的数据始终保持一致状态，但这很困难且效率不高（据我所知，只有Firebird才这样）。 <br><br> 通常，包括PostgreSQL在内，写入磁盘的数据不一致，并且从故障中恢复时，需要采取特殊措施来恢复一致性。 日记是使之成为可能的机制。 <br><a name="habracut"></a><br><h1> 缓冲区缓存 </h1><br> 奇怪的是，我们将开始讨论使用缓冲区高速缓存的日志记录。 缓冲区高速缓存不是存储在RAM中的唯一结构，而是最重要和最复杂的结构之一。 此外，了解其操作原理本身很重要，在本示例中，我们将熟悉如何在RAM和磁盘之间交换数据。 <br><br> 缓存在现代计算系统中无处不在；一个处理器可以单独计算三或四个缓存级别。 通常，需要任何高速缓存来消除两种类型的内存之间的性能差异，其中一种速度相对较快，但不足以满足所有人的需求，而另一种速度相对较慢，但容量却很大。 因此，缓冲区缓存可平滑对RAM（纳秒）和磁盘（毫秒）的访问时间之间的差异。 <br><br> 请注意，操作系统还具有解决相同问题的磁盘缓存。 因此，DBMS通常试图通过绕过OS缓存直接访问磁盘来避免双重缓存。 但是对于PostgreSQL，情况并非如此：所有数据都是使用普通文件操作读取和写入的。 <br><br> 此外，磁盘阵列，甚至磁盘本身也具有自己的缓存。 当我们谈到可靠性问题时，这一事实对我们仍然有用。 <br><br> 但是回到DBMS缓冲区缓存。 <br><br> 之所以这样称呼它，是因为它是一个<em>缓冲区</em>数组。 每个缓冲区是一个数据页（块）和一个标题的位置。 标题除其他外包括： <br><br><ul><li> 页面在磁盘上的缓冲区中的位置（其中的文件和块号）； </li><li> 页面上的数据已更改并且迟早应将其写入磁盘的迹象（这种缓冲区称为<em>dirty</em> ）； </li><li> 缓冲区的调用次数（使用计数）； </li><li> 固定缓冲区的标志（引脚计数）。 </li></ul><br> 缓冲区高速缓存位于服务器的共享内存中，所有进程均可访问。 要处理数据-读取或修改，-处理缓存中的读取页面。 当页面处于缓存中时，我们在RAM中使用它并保存对磁盘的访问。 <br><br><img src="https://habrastorage.org/webt/1u/-j/fd/1u-jfdnjvzjwvrddgb7tbvohhge.png"><br><br> 最初，缓存包含空缓冲区，并且所有缓冲区都链接到空闲缓冲区列表中。 指向“下一个受害者”的指针的含义稍后将变得清楚。 为了在高速缓存中快速找到所需的页面，使用了哈希表。 <br><br><h1> 缓存中的搜索页面 </h1><br> 当进程需要读取页面时，它首先尝试使用哈希表在缓冲区高速缓存中找到它。 哈希键是文件号和文件内的页码。 在哈希表的相应篮子中，该过程找到缓冲区编号并检查其是否确实包含所需的页面。 与任何哈希表一样，此处可能发生冲突； 在这种情况下，该过程将不得不检查多个页面。 <br><br><blockquote> 长期以来一直批评使用哈希表。 这种结构使您可以快速找到页面上的缓冲区，但是，例如，当您需要查找特定表占用的所有缓冲区时，它是完全没有用的。 但是还没有人提出好的替代方案。 <br></blockquote><br> 如果在高速缓存中找到了所需的页面，则该过程应通过增加引脚数来“冻结”缓冲区（多个过程可以同时执行此操作）。 只要缓冲区是固定的（计数器值大于零），就认为缓冲区已被使用，并且其内容不应“激进”地更改。 例如，该行的新版本可能会出现在页面中-由于多版本和可见性规则，这不会打扰任何人。 但是无法将另一个页面读入固定缓冲区。 <br><br><h1> 挤出来 </h1><br> 可能会在缓存中找不到所需的页面。 在这种情况下，必须将其从磁盘读取到某个缓冲区。 <br><br> 如果缓存中仍然有可用缓冲区，则选择第一个可用缓冲区。 但是它们迟早会结束（通常数据库的大小大于为高速缓存分配的内存），然后您必须选择一个已占用的缓冲区，将页面强行移出并在空闲空间上读取一个新的页面。 <br><br> 抢占机制基于以下事实：每次访问缓冲区时，进程都会增加缓冲区头中的使用计数。 因此，那些不经常使用的缓冲区具有较低的计数器值，并且是排挤的良好候选者。 <br><br> 时钟扫描算法循环遍历所有缓冲区（使用指向“下一个受害者”的指针），从而将其访问计数减少一。 为了排挤，选择了第一个缓冲区，该缓冲区： <br><br><ol><li> 计数器为零（使用次数）， </li><li> 且不固定（零引脚数）。 </li></ol><br> 您可以看到，如果所有缓冲区的命中计数器都为非零，则该算法将必须执行多个循环，以重置计数器，直到其中一个最终变为零为止。 为了避免“盘绕”，命中计数器的最大值限制为5。但是，即使缓冲区高速缓存大小较大，该算法也会导致大量开销。 <br><br> 找到缓冲区后，将发生以下情况。 <br><br> 缓冲区被固定以显示正在使用的其他进程。 除了修复之外，还使用其他阻塞方法，但是我们将单独讨论更多。 <br><br> 如果缓冲区原来是脏的，也就是说，它包含已更改的数据，则不能简单地丢弃该页面-首先需要将其保存到磁盘。 这不是一个好情况，因为将要读取页面的过程必须等待“外来”数据的记录，但是这种影响可以通过检查点和后台记录过程来解决，这将在后面进行讨论。 <br><br> 接下来，从磁盘将新页面读取到所选缓冲区中。 呼叫次数计数器设置为1。 此外，到加载页面的链接必须在哈希表中注册，以便将来可以找到它。 <br><br> 现在，指向“下一个受害者”的链接指向下一个缓冲区，刚加载的缓冲区有时间增加命中计数器，直到指针绕过整个缓冲区高速缓存并再次返回为止。 <br><br><h1> 用我自己的眼睛 </h1><br> 按照PostgreSQL的惯例，有一个扩展允许您查看缓冲区缓存内部。 <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache;</code> </pre> <br> 创建一个表并将一行插入其中。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cacheme( id <span class="hljs-type"><span class="hljs-type">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br> 缓冲区缓存中将包含什么？ 至少应在其中显示一个页面，并添加一行。 我们将通过以下查询对此进行验证，在该查询中，我们仅选择属于我们表的缓冲区（通过文件号relfilenode），并解码层号（relforknumber）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bufferid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> relforknumber <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'fsm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'vm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> relfork, relblocknumber, isdirty, usagecount, pinning_backends <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'cacheme'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 1 | 0 (1 row)</code> </pre><br> 就是这样-缓冲区中只有一页。 它是脏的（脏），命中计数器等于1（使用计数），并且不受任何进程固定（pinning_backends）。 <br><br> 现在添加另一行并重复查询。 为了保存字母，我们在另一个会话中插入一行，然后使用<code>\g</code>命令重复长的请求。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 2 | 0 (1 row)</code> </pre><br> 没有添加新的缓冲区-第二行适合同一页面。 请注意，使用情况计数器已增加。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cacheme;</code> </pre><pre> <code class="plaintext hljs">| id | ---- | 1 | 2 | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 3 | 0 (1 row)</code> </pre><br> 在访问要阅读的页面后，计数器也会增加。 <br><br> 如果你打扫？ <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> cacheme;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15731 | fsm | 1 | t | 1 | 0 15732 | fsm | 0 | t | 1 | 0 15733 | fsm | 2 | t | 2 | 0 15734 | vm | 0 | t | 2 | 0 15735 | main | 0 | t | 3 | 0 (5 rows)</code> </pre><br> 清洗创建了一个可见性图（一页）和一个可用空间图（三页-此图的最小尺寸）。 <br><br> 等等。 <br><br><h1> 尺寸设定 </h1><br> 缓存大小由<em>shared_buffers</em>参数设置。 默认值为荒谬的128 MB。 这是在安装PostgreSQL之后立即增加的有意义的参数之一。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'shared_buffers'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> setting | unit ---------+------ 16384 | 8kB (1 row)</code> </pre><br> 请记住，更改参数需要重新启动服务器，因为所有必需的缓存内存都是在服务器启动时分配的。 <br><br> 由于什么原因选择合适的值？ <br><br> 即使最大的数据库也只有有限的“热”数据集，利用这些数据可以在每个时刻进行有效的工作。 理想情况下，应将此集放置在缓冲区高速缓存中（以及一些用于“一次性”数据的空间）。 如果缓存大小较小，则频繁使用的页面将不断相互挤压，从而产生过多的输入输出。 但是，盲目地增加缓存也是错误的。 大尺寸的情况下，维护它的开销会增加，此外，RAM还需要用于其他需求。 <br><br> 因此，最佳缓冲区高速缓存大小在不同系统中会有所不同：它取决于数据，应用程序和负载。 不幸的是，没有任何一种神奇的含义能同样适合所有人。 <br><br> 标准建议是将RAM的1/4作为第一近似值（对于PostgreSQL 10之前的Windows，建议选择较小的大小）。 <br><br> 然后，您需要查看情况。 最好做一个实验：增加或减少缓存大小并比较系统性能。 当然，为此，必须有一个测试台并能够再现典型的负载-在生产环境中，这样的实验看起来令人怀疑。 <br><br><blockquote> 请务必查看Nikolay Samokhvalov在PgConf-2019上的报告：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PostgreSQL</a>调整的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工业方法：数据库实验</a> ” <br></blockquote><br> 但是，可以使用相同的pg_buffercache扩展在实时系统上直接收集有关正在发生的事情的一些信息-最重要的是，以正确的角度查看。 <br><br> 例如，您可以根据缓冲区的使用程度来研究它们的分布： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> usagecount, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount;</code> </pre><pre> <code class="plaintext hljs"> usagecount | count ------------+------- 1 | 221 2 | 869 3 | 29 4 | 12 5 | 564 | 14689 (6 rows)</code> </pre><br> 在这种情况下，许多空计数器值都是空闲缓冲区。 对于没有任何反应的系统，这不足为奇。 <br><br> 您可以看到数据库中有多少表被缓存以及这些数据的使用有多活跃（在此查询中，活跃使用是指使用计数器大于3的缓冲区）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.relname, count(*) blocks, round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) / pg_table_size(c.oid) ) "% of rel", round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) <span class="hljs-keyword"><span class="hljs-keyword">FILTER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.usagecount &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) / pg_table_size(c.oid) ) "% hot" <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pg_relation_filenode(c.oid) = b.relfilenode <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.reldatabase <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = current_database()) ) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> b.usagecount <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> c.relname, c.oid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relname | blocks | % of rel | % hot ---------------------------+--------+----------+------- vac | 833 | 100 | 0 pg_proc | 71 | 85 | 37 pg_depend | 57 | 98 | 19 pg_attribute | 55 | 100 | 64 vac_s | 32 | 4 | 0 pg_statistic | 27 | 71 | 63 autovac | 22 | 100 | 95 pg_depend_reference_index | 19 | 48 | 35 pg_rewrite | 17 | 23 | 8 pg_class | 16 | 100 | 100 (10 rows)</code> </pre><br> 例如，在这里可以看到vac表占据了最大的位置（我们在前面的主题之一中使用了它），但是很长一段时间没有人解决过这个问题，并且仅仅由于可用缓冲区还没有用完而还没有被挤出。 <br><br> 您可以提出其他章节，以提供有用的思想信息。 只需要考虑这样的请求： <br><br><ul><li> 必须重复几次：数字将在一定范围内变化； </li><li> 由于扩展程序会在短时间内阻止使用缓冲区高速缓存进行操作，因此无需经常执行此操作（作为监视的一部分）。 </li></ul><br> 还有一件事。 我们不应忘记PostgreSQL是通过定期调用操作系统来处理文件的，因此，存在双重缓存：页面同时进入DBMS缓冲区缓存和OS缓存。 因此，缓冲区高速缓存中的“未命中”并不总是导致对实际I / O的需求。 但是排挤操作系统的策略与DBMS策略不同：操作系统对读取的数据的含义一无所知。 <br><br><h1> 质量排量 </h1><br> 在执行批量读取或写入数据的操作中，存在使用“一次性”数据快速将缓冲区高速缓存中的有用页面替换的危险。 <br><br> 为了防止这种情况发生，所谓的<em>缓冲区环</em>用于此类操作-为每个操作分配一小部分缓冲区高速缓存。 挤出仅在环内起作用，因此其余缓冲区高速缓存数据不会受到影响。 <br><br> 为了顺序读取大表（其大小超过缓冲区高速缓存的四分之一），分配了32页。 如果另一个进程在读取表时也需要此数据，则它不会首先开始读取表，而是连接到现有的缓冲环。 扫描后，他读取表的“缺失”开头。 <br><br> 让我们来看看。 为此，请创建一个表格，以便一行占据整个页面-计数起来更加方便。 默认的缓冲区高速缓存大小为128 MB = 16384页8 KB。 因此，您需要在表中插入4096个以上的行。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> big( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor=<span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> big(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4096</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br> 让我们分析一下表格。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> big; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 4097 (1 row)</code> </pre><br> 现在，我们必须重新启动服务器，以清除分析读取的表数据的缓存。 <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br> 重新启动后，请阅读整个表： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Aggregate (actual time=14.472..14.473 rows=1 loops=1) -&gt; Seq Scan on big (actual time=0.031..13.022 rows=4097 loops=1) Planning Time: 0.528 ms Execution Time: 14.590 ms (4 rows)</code> </pre><br> 并确保缓冲区高速缓存中的表格页面仅占用32个缓冲区： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 32 (1 row)</code> </pre><br> 如果禁止顺序扫描，则将按索引读取表： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------- Aggregate (actual time=50.300..50.301 rows=1 loops=1) -&gt; Index Only Scan using big_pkey on big (actual time=0.098..48.547 rows=4097 loops=1) Heap Fetches: 4097 Planning Time: 0.067 ms Execution Time: 50.340 ms (5 rows)</code> </pre><br> 在这种情况下，不使用缓冲区环，并且整个表都出现在缓冲区高速缓存中（几乎也包括整个索引）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br> 以类似的方式，缓冲区环用于清理过程（也为32页）和批量写入操作COPY IN和CREATE TABLE AS SELECT（通常为2048页，但不超过总缓冲区高速缓存的1/8）。 <br><br><h1> 临时表 </h1><br> 一般规则的一个例外是临时表。 由于临时数据仅对一个进程可见，因此它们与共享缓冲区高速缓存无关。 此外，临时数据仅存在于单个会话中，因此不需要对其进行保护以免发生故障。 <br><br> 对于临时数据，在拥有该表的进程的本地内存中使用高速缓存。 由于此类数据仅可用于一个进程，因此不需要使用锁进行保护。 本地缓存使用通常的抢先算法。 <br><br> 与常规缓冲区高速缓存不同，本地高速缓存的内存是根据需要分配的，因为并非在所有会话中都使用临时表。 一个会话中临时表的最大内存量受<em>temp_buffers</em>参数限制。 <br><br><h1> 预热缓存 </h1><br> 重新启动服务器后，缓存“预热”之前应该经过一段时间-累积实际的活动使用数据。 有时立即将某些表的数据读入缓存可能很有用，为此专门设计了一个扩展名： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_prewarm;</code> </pre><br> 以前，扩展只能读取缓冲区缓存中的某些表（或仅读取OS缓存中的表）。 但是在PostgreSQL 11中，它能够将当前缓存状态保存到磁盘上，并在服务器重启后将其还原。 要利用此优势，您需要将库添加到<em>shared_preload_libraries</em>并重新启动服务器。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_prewarm'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br> 如果未更改<em>pg_prewarm.autoprewarm</em>参数，则重新启动字段将自动启动autoprewarm主后台进程，该进程一旦进入<em>pg_prewarm.autoprewarm_interval，</em>便会将高速缓存的页面列表<em>刷新</em>到磁盘（设置<em>max_parallel_processes</em>时不要忘记考虑新进程）。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>, setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'pg_prewarm%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | setting | unit ---------------------------------+---------+------ pg_prewarm.autoprewarm | on | pg_prewarm.autoprewarm_interval | 300 | s (2 rows)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ps -o pid,command --ppid `head -n 1 /var/lib/postgresql/11/main/postmaster.pid` | grep prewarm</code> </pre><pre> <code class="plaintext hljs">10436 postgres: 11/main: autoprewarm master</code> </pre><br> 现在缓存中没有大表： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br> 如果我们假设其所有内容都很重要，则可以通过调用以下函数将其读入缓冲区高速缓存： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_prewarm(<span class="hljs-string"><span class="hljs-string">'big'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_prewarm ------------ 4097 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br> 页面列表将转储到autoprewarm.blocks文件中。 要查看它，您可以等到自动预热主进程第一次运行时，但是我们手动启动它： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> autoprewarm_dump_now();</code> </pre><pre> <code class="plaintext hljs"> autoprewarm_dump_now ---------------------- 4340 (1 row)</code> </pre><br> 丢弃的页面数超过4097，其中包括服务器已读取的系统目录对象的页面。 这是文件： <br><br><pre> <code class="plaintext hljs">postgres$ ls -l /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 102078  29 15:51 /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><br> 现在再次重新启动服务器。 <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br> 启动后，我们的表立即再次出现在缓存中。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br> 这提供了相同的自动预热主过程：读取文件，将页面拆分为数据库，对页面进行排序（以便从磁盘读取尽可能一致），并将自动预热工作程序传递给单独的工作流程进行处理。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">待续</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458186/">https://habr.com/ru/post/zh-CN458186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458172/index.html">跟踪印刷电路板上的差分对时配对电气连接的方法</a></li>
<li><a href="../zh-CN458176/index.html">exaflops障碍将在2021年克服</a></li>
<li><a href="../zh-CN458180/index.html">基于Kea的故障转移DHCP服务器</a></li>
<li><a href="../zh-CN458182/index.html">我们通过RSS阅读VKontakte</a></li>
<li><a href="../zh-CN458184/index.html">Haxe和PHP：静态输入，箭头功能，元编程等等</a></li>
<li><a href="../zh-CN458190/index.html">我知道，这意味着我存在：计算机视觉深度学习的回顾（第2部分）</a></li>
<li><a href="../zh-CN458202/index.html">如果要在C ++项目中使用Actor或CSP，只需看一下SObjectizer</a></li>
<li><a href="../zh-CN458204/index.html">如何评估Linux上的存储性能：使用开放工具进行基准测试</a></li>
<li><a href="../zh-CN458206/index.html">Sublime Text 3用于网站布局。 自定义外观并安装插件。 初学者指南</a></li>
<li><a href="../zh-CN458208/index.html">7月1日至7月7日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>