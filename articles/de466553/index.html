<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏻 👇🏻 💖 6 Lektionen aus der Suche nach einer Lösung für ein massives Problem bei gitlab.com. Teil 2 🧗🏿 ⚕️ 👌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir stellen Ihnen den zweiten Teil der Übersetzung des Materials zum Kampf des gitlab.com-Teams gegen die Tyrannei der Zeit vor. 

  

 → Hier ist übr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>6 Lektionen aus der Suche nach einer Lösung für ein massives Problem bei gitlab.com. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466553/">  Wir stellen Ihnen den zweiten Teil der Übersetzung des Materials zum Kampf des gitlab.com-Teams gegen die Tyrannei der Zeit vor. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/nt/tn/-m/nttn-m8gmjyftqrghwzprgboj0g.jpeg"></a> <br><br>  → Hier ist übrigens der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Teil</a> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Verarbeitungsgeschwindigkeitsbegrenzung anfordern</font> </h2><br>  Zu diesem Zeitpunkt waren wir nicht daran interessiert, die Werte des <code>MaxStartups</code> Parameters einfach zu erhöhen.  Obwohl sich eine 50% ige Erhöhung dieses Parameters als gut erwies, schien seine weitere Erhöhung ohne ausreichenden Grund eine ziemlich grobe Lösung des Problems zu sein.  Sicherlich konnten wir noch etwas anderes tun. <br><br>  Die Suche brachte mich auf die HAProxy-Ebene, die sich vor den SSH-Servern befand.  HAProxy hat eine nette Option für <code>rate-limit sessions</code> Ratenbegrenzung, die sich auf den Teil des Systems auswirkt, der eingehende Anforderungen akzeptiert.  Wenn diese Option konfiguriert ist, wird sie verwendet, um die Anzahl neuer TCP-Anforderungen pro Sekunde zu begrenzen, die das Frontend an die Backends sendet, während zusätzliche eingehende Verbindungen zum TCP-Socket verbleiben.  Wenn die Geschwindigkeit eingehender Anforderungen den Grenzwert überschreitet (jede Millisekunde änderbar), werden neue Verbindungen einfach verzögert.  Der TCP-Client (in diesem Fall SSH) sieht einfach die Verzögerung, bevor eine TCP-Verbindung hergestellt wird.  Dies ist meiner Meinung nach ein sehr schöner Schachzug.  Bis die Geschwindigkeit, mit der Anfragen über einen zu langen Zeitraum empfangen werden, den Grenzwert zu stark überschreitet, funktioniert das System einwandfrei. <br><br>  Die nächste Frage war die Auswahl des Werts der Option für <code>rate-limit sessions</code> , die wir verwenden sollten.  Die Beantwortung dieser Frage wurde durch die Tatsache erschwert, dass wir 27 SSH-Backends und 18 HAProxy-Frontends (16 Haupt- und 2 Alt-SSH) haben, sowie durch die Tatsache, dass die Frontends hinsichtlich der Geschwindigkeit der Anforderungsverarbeitung nicht miteinander koordinieren .  Außerdem mussten wir berücksichtigen, wie lange der Authentifizierungsschritt der neuen SSH-Sitzung dauert.  Angenommen, der erste Wert von <code>MaxStartups</code> ist 150. Wenn die Authentifizierungsphase zwei Sekunden dauert, können wir für jedes Backend nur 75 neue Sitzungen pro Sekunde übertragen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie Details zur Berechnung des Werts von <code>rate-limit sessions</code> . Ich werde hier nicht auf Details eingehen.  Ich stelle nur fest, dass zur Berechnung dieses Wertes vier Parameter berücksichtigt werden müssen.  Der erste und der zweite sind die Anzahl der Server beider Typen.  Der dritte ist der Wert von <code>MaxStartups</code> .  Der vierte ist <code>T</code> - wie lange dauert die Authentifizierung einer SSH-Sitzung?  Der Wert von <code>T</code> äußerst wichtig, kann jedoch nur annähernd abgeleitet werden.  Wir haben genau das getan und das Ergebnis bei 2 Sekunden belassen.  Als Ergebnis haben wir den <code>rate-limit</code> für die Frontends erhalten, der 112,5 betrug.  Wir haben es auf 110 gerundet. <br><br>  Und jetzt wurden die neuen Einstellungen wirksam.  Vielleicht denkst du, dass danach alles glücklich endete?  Es muss gewesen sein, dass die Anzahl der Fehler auf Null gestiegen ist und alle um uns herum sehr glücklich waren?  Nun, eigentlich war es alles andere als gut.  Diese Änderung führte zu keinen sichtbaren Änderungen der Fehlerrate.  Ehrlich gesagt war ich ziemlich verärgert.  Wir haben etwas Wichtiges übersehen oder die Essenz des Problems missverstanden. <br><br>  Infolgedessen kehrten wir zu den Protokollen (und schließlich zu den HAProxy-Informationen) zurück und konnten sicherstellen, dass die Geschwindigkeitsbegrenzung für die Abfrageverarbeitung zumindest funktioniert, indem wir wie erwartet auf die Abfragen reagierten.  Zuvor waren die entsprechenden Indikatoren höher, sodass wir den Schluss ziehen konnten, dass wir die Geschwindigkeit, mit der eingehende Anforderungen zur Verarbeitung gesendet werden, erfolgreich begrenzt haben.  Es war jedoch klar, dass die Rate, mit der die Anfragen eintrafen, immer noch zu hoch war.  Obwohl auch klar war, dass es nicht einmal an diese Werte heranrückte, wenn es spürbare Auswirkungen auf das System haben könnte.  Als wir den Prozess der Auswahl von Backends (gemäß den HAProxy-Protokollen) analysierten, stellten wir dort eine Verrücktheit fest.  Zu Beginn der Stunde waren die Backend-Verbindungen ungleichmäßig auf die SSH-Server verteilt.  In dem für die Analyse ausgewählten Zeitintervall variierte die Anzahl der Verbindungen pro Sekunde auf verschiedenen Servern zwischen 30 und 121. Dies bedeutete, dass unser Lastausgleich seine Aufgabe nicht gut erledigte.  Die Analyse der Konfiguration ergab, dass wir die Option <code>balance source</code> , sodass ein Client mit einer bestimmten IP-Adresse immer mit demselben Backend verbunden ist.  Dies kann als positives Phänomen in Fällen angesehen werden, in denen eine Sitzungsbindung erforderlich ist.  Aber wir haben es mit SSH zu tun, also brauchen wir das nicht.  Diese Option wurde einmal von uns konfiguriert, aber wir haben keine Hinweise gefunden, warum dies getan wurde.  Wir konnten keinen würdigen Grund finden, es weiter zu verwenden.  Aus diesem Grund haben wir uns entschlossen, auf <code>leastconn</code> .  Dank dieser Option bieten neue eingehende Verbindungen Backends mit der minimalen Anzahl aktueller Verbindungen.  Dies wirkte sich auf die Verwendung von Prozessorressourcen durch unsere SSH (Git) -Server aus.  Hier ist der entsprechende Zeitplan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/eeb/535/d7eeeb535c31867c14d70759f48a4734.png"><br>  <i><font color="#999999">CPU-Verbrauch durch Server vor und nach Anwendung der Option "Leastconn"</font></i> <br><br>  Nachdem wir dies gesehen hatten, stellten wir fest, dass die Verwendung von <code>leastconn</code> eine gute Idee ist.  Die beiden Linien am unteren Rand des Diagramms sind unsere kanarischen Server. Sie können sie ignorieren.  Zuvor wurde die Verteilung der CPU-Lastwerte für verschiedene Server jedoch mit 2: 1 (von 30% auf 60%) korreliert.  Dies zeigte deutlich, dass einige unserer Backends früher aufgrund der Verbindung von Clients mehr als andere geladen wurden.  Es war eine Überraschung für mich.  Es schien zu erwarten, dass ein breiter Bereich von Client-IP-Adressen ausreichte, um unsere Server viel gleichmäßiger zu laden.  Um jedoch die Serverlastindikatoren zu verzerren, reichten anscheinend mehrere große Clients aus, deren Verhalten sich von einer durchschnittlichen Option unterscheidet. <br><br>  <b>Lektion Nummer 4.</b>  Wenn Sie bestimmte Einstellungen auswählen, die von den Standardeinstellungen abweichen, kommentieren Sie diese oder hinterlassen Sie einen Link zu den Materialien, in denen die Änderungen erläutert werden.  Jeder, der sich in Zukunft mit diesen Einstellungen befassen muss, wird Ihnen dafür dankbar sein. <br><br>  Diese Transparenz ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer der Grundwerte von GitLab</a> . <br><br>  Durch Aktivieren der Option " <code>leastconn</code> " konnten auch die Fehlerquoten reduziert werden.  Und genau das haben wir angestrebt.  Aus diesem Grund haben wir uns entschlossen, diese Option zu verlassen.  Während sie weiter experimentierten, reduzierten sie die Geschwindigkeitsbegrenzungen für die Anforderungsverarbeitung auf 100, was dazu beitrug, die Fehlerquote weiter zu reduzieren.  Dies zeigte an, dass die anfängliche Auswahl des Wertes von <code>T</code> wahrscheinlich falsch durchgeführt wurde.  Wenn ja, war dieser Indikator zu klein, was zu einem zu starken Tempolimit führte, und sogar 100 Anfragen pro Sekunde wurden als sehr niedriger Wert angesehen, und wir waren nicht bereit, ihn weiter zu reduzieren.  Leider waren diese beiden Änderungen aus irgendeinem internen Grund nur ein Experiment.  Wir mussten wieder die Option <code>balance source</code> und die Verarbeitungsgeschwindigkeit von Anforderungen auf 100 Anforderungen pro Sekunde begrenzen. <br><br>  Da die Verarbeitungsgeschwindigkeit für Abfragen auf ein für uns <code>leastconn</code> niedriges Niveau eingestellt wurde und wir <code>leastconn</code> nicht verwenden <code>leastconn</code> , haben wir versucht, den Parameter <code>MaxStartups</code> zu erhöhen.  Zuerst haben wir es auf 200 erhöht, dies ergab einen gewissen Effekt.  Dann - bis zu 250. Fehler sind fast vollständig verschwunden und nichts Schlimmes ist passiert. <br><br>  <b>Lektion Nummer 5.</b>  Hohe MaxStartups sehen zwar einschüchternd aus, haben jedoch nur geringe Auswirkungen auf die Leistung, selbst wenn sie viel höher als die Standardwerte sind. <br><br>  Vielleicht ist dies so etwas wie ein großer und leistungsfähiger Hebel, den wir bei Bedarf in Zukunft verwenden können.  Vielleicht werden wir auf Probleme stoßen, wenn wir über Zahlen in der Größenordnung von mehreren Tausend oder mehreren Zehntausend sprechen, aber davon sind wir noch weit entfernt. <br><br>  Was sagt dies über meine Schätzungen des <code>T</code> Parameters aus, wie lange es dauert, eine SSH-Sitzung zu installieren und zu authentifizieren?  Wenn Sie mit der Formel zur Berechnung der Geschwindigkeitsbegrenzungsanzeige für die Verbindungsverarbeitung arbeiten und wissen, dass 200 für die <code>MaxStartups</code> Anzeige nicht ausreicht und 250 ausreicht, können Sie feststellen, dass <code>T</code> wahrscheinlich einen Wert zwischen 2,7 und 3,4 Sekunden hat.  Infolgedessen war ein geschätzter Wert von 2 Sekunden nicht weit von der Wahrheit entfernt, aber der tatsächliche Wert war natürlich höher als erwartet.  Wir werden etwas später darauf zurückkommen. <br><br><h2>  <font color="#3AC1EF">Letzte Schritte</font> </h2><br>  Wir haben uns die Protokolle noch einmal angesehen und dabei berücksichtigt, was wir bereits wussten, und nach einiger Überlegung herausgefunden, dass das Problem, mit dem alles begann, durch die folgenden Zeichen identifiziert werden kann.  Erstens ist dies ein <code>t_state</code> Wert gleich <code>SD</code> .  Zweitens ist dies der Wert von <code>b_read</code> (vom Client gelesene Bytes) gleich 0. Wie bereits erwähnt, verarbeiten wir ungefähr <code>b_read</code> bis 28 Millionen SSH-Verbindungen pro Tag.  Es war unangenehm zu erfahren, dass mitten in der Katastrophe ungefähr 1,5% dieser Verbindungen grob unterbrochen waren.  Offensichtlich war das Ausmaß des Problems viel größer als wir am Anfang dachten.  Gleichzeitig gab es nichts, was wir früher nicht erkennen konnten (selbst als wir feststellten, dass <code>t_state="SD"</code> das Problem in den Protokollen anzeigte), aber wir haben nicht darüber <code>t_state="SD"</code> , wie dies zu tun ist, obwohl wir und du solltest darüber nachdenken.  Wahrscheinlich haben wir deshalb viel mehr Zeit und Mühe darauf verwendet, das Problem zu lösen, als wir hätten aufwenden können. <br><br>  <b>Lektion Nummer 6.</b>  Messen Sie die tatsächlichen Fehlerwerte so früh wie möglich. <br><br>  Wenn wir uns zunächst des Ausmaßes des Problems bewusst wären, könnten wir ihm mehr Aufmerksamkeit schenken.  Wie man es wahrnimmt, hängt jedoch immer noch von der Kenntnis der Merkmale ab, die es uns ermöglichen, die Probleme zu beschreiben. <br><br>  Wenn wir über die Vorteile sprechen, die sich ergeben haben, nachdem wir die Werte von <code>MaxStartups</code> und die Geschwindigkeit der Verarbeitungsanforderungen <code>MaxStartups</code> , können wir sagen, dass die Fehlerquote auf 0,001% gesunken ist.  Das heißt - bis zu mehreren tausend pro Tag.  Diese Situation sah viel besser aus, aber eine ähnliche Fehlerquote war immer noch höher als die, die wir erreichen möchten.  Nachdem wir einige Dinge herausgefunden hatten, konnten wir wieder die Option " <code>leastconn</code> " verwenden und die Fehler verschwanden vollständig.  Danach konnten wir erleichtert aufatmen. <br><br><h2>  <font color="#3AC1EF">Zukünftige Arbeit</font> </h2><br>  Offensichtlich nimmt die SSH-Authentifizierungsphase noch viel Zeit in Anspruch.  Vielleicht bis zu 3,4 Sekunden.  GitLab kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AuthorizedKeysCommand verwenden,</a> um direkt nach einem SSH-Schlüssel in einer Datenbank zu suchen.  Dies ist sehr wichtig für schnelle Vorgänge, wenn eine große Anzahl von Benutzern vorhanden ist.  Andernfalls muss SSHD nacheinander eine sehr große Datei " <code>authorized_keys</code> lesen, um den öffentlichen Schlüssel des Benutzers zu finden.  Diese Aufgabe lässt sich nicht gut skalieren.  Wir haben eine Suche mit einer bestimmten Menge Ruby-Code implementiert, die Aufrufe einer externen HTTP-API ausführt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stan Hugh</a> , der Leiter unserer technischen Abteilung und eine unerschöpfliche Wissensquelle über GitLab, stellte fest, dass Unicorn-Instanzen von Git / SSH-Servern aufgrund von Anfragen an sie ständig belastet werden.  Dies könnte einen wesentlichen Beitrag zu den drei Sekunden leisten, die zur Authentifizierung von Anforderungen erforderlich sind.  Infolgedessen haben wir erkannt, dass wir dieses Problem in Zukunft untersuchen sollten.  Vielleicht erhöhen wir die Anzahl der Unicorn- (oder Puma-) Instanzen auf diesen Knoten, damit SSH-Server nicht warten müssen, um auf sie zuzugreifen.  Da hier jedoch ein gewisses Risiko besteht, müssen wir vorsichtig sein und auf die Erfassung und Analyse von Systemindikatoren achten.  Die Arbeit an der Produktivität geht weiter, aber jetzt, nachdem das Hauptproblem gelöst ist, geht es langsamer voran.  Möglicherweise können wir den Wert von <code>MaxStartups</code> reduzieren, aber da sein hohes Niveau nicht die negativen Auswirkungen auf das System hat, die es zu erzeugen scheint, ist dies nicht besonders notwendig.  Es wird für alle viel einfacher zu leben sein, wenn OpenSSH uns jederzeit mitteilen kann, wie nahe wir den Grenzen von <code>MaxStartups</code> .  Es wird besser sein, wenn wir immer Bescheid wissen können.  Dies ist viel schöner als zu lernen, dass die Grenzen bei unterbrochenen Verbindungen überschritten werden. <br><br>  Darüber hinaus benötigen wir eine Art Benachrichtigungssystem, wenn HAProxy-Protokolleinträge angezeigt werden, die auf ein Problem mit getrennten Verbindungen hinweisen.  Tatsache ist, dass dies in der Praxis überhaupt nicht passieren sollte.  Wenn dies erneut geschieht, müssen wir die <code>MaxStartups</code> Werte weiter erhöhen, oder wenn uns Ressourcen fehlen, müssen wir dem System weitere Git / SSH-Knoten hinzufügen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Teile komplexer Systeme interagieren in komplexen Mustern.  Und um verschiedene Probleme zu lösen, findet man in ihnen oft weit entfernt von einem "Hebel".  Im Umgang mit solchen Systemen ist es hilfreich, die darin enthaltenen Tools zu kennen.  Tatsache ist, dass sie alle ihre Vor- und Nachteile haben.  Darüber hinaus sollte beachtet werden, dass es riskant sein kann, bestimmte Einstellungen basierend auf Annahmen und geschätzten Werten vorzunehmen.  Wenn ich nun den Weg betrachte, den wir zurückgelegt haben, würde ich versuchen, die Zeit, die erforderlich ist, um die Authentifizierung der Anfrage abzuschließen, so genau wie möglich zu messen, was dazu führen würde, dass der ungefähre Wert von <code>T</code> , den ich abgeleitet habe, näher an der Wahrheit liegt. <br><br>  Die wichtigste Lektion, die wir daraus gelernt haben, ist jedoch, dass wenn viele Leute Aufgaben auf der Grundlage einiger netter Zeitmetriken planen, dies für zentralisierte Dienstanbieter wie GitLab zu wirklich ungewöhnlichen Skalierungsproblemen führt. <br><br>  Wenn Sie zu denjenigen gehören, die die geplanten Tools zum Starten von Aufgaben verwenden, müssen Sie möglicherweise die Zeit für das Starten Ihrer Aufgaben auf eine neue Weise festlegen.  Sie können beispielsweise festlegen, dass die Aufgaben für eine Weile „einschlafen“ und erst 30 Sekunden nach dem Start richtig funktionieren.  Sie können beispielsweise im Zeitplan für den Start der Aufgabe zufällige Zeiten innerhalb einer Stunde angeben (hier können Sie eine zufällige Wartezeit vor der tatsächlichen Ausführung der Aufgabe hinzufügen).  Dies wird uns allen im Kampf gegen die Tyrannei der Uhren helfen. <br><br>  <b>Liebe Leser!</b>  Sind Sie auf ähnliche Probleme gestoßen wie die, deren Geschichte dieses Material gewidmet ist? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466553/">https://habr.com/ru/post/de466553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466541/index.html">Verwenden von DbTool zum Seeding von Datenbanken in .NET-Anwendungen (Core)</a></li>
<li><a href="../de466543/index.html">Habr Weekly # 17 / Sberbank-Darlehen werden von AI genehmigt - beängstigend, Werbung in Open-Source-Produkten - zweifelhaft</a></li>
<li><a href="../de466547/index.html">Glücklicher Programmiertag</a></li>
<li><a href="../de466549/index.html">Allgemeine Funktionsprinzipien von QEMU-KVM</a></li>
<li><a href="../de466551/index.html">Puppenspieler mit ES6 in einem Knoten und Browser oder warum Zora das beste Testframework in seiner Nische ist</a></li>
<li><a href="../de466555/index.html">6 Lektionen aus der Suche nach einer Lösung für ein massives Problem bei gitlab.com. Teil 1</a></li>
<li><a href="../de466557/index.html">So erstellen Sie ein Layout für die Site und bleiben nicht extrem</a></li>
<li><a href="../de466559/index.html">Lass uns den neuen Var</a></li>
<li><a href="../de466561/index.html">Benötigen Sie absolut transparente Entscheidungen? - Ich habe sie</a></li>
<li><a href="../de466563/index.html">KOST: Was ist im neuen Technologie-Stack für die Entwicklung von Cloud-Anwendungen enthalten?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>