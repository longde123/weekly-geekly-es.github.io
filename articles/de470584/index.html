<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé° üïé üé≤ √úberpr√ºfen Sie die Telerik-Benutzeroberfl√§che auf UWP, um sich mit PVS-Studio vertraut zu machen üôåüèª üçª üë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist bereits Tradition geworden, dass Programmierer, die das PVS-Studio-Team auff√ºllen, ihre Arbeit mit dem Schreiben eines Artikels √ºber die Analys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfen Sie die Telerik-Benutzeroberfl√§che auf UWP, um sich mit PVS-Studio vertraut zu machen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/470584/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ww/cf/vp/wwcfvpz0hkpkv-ubqtskjfq2ahg.png" alt="Bild 2"></div><br>  Es ist bereits Tradition geworden, dass Programmierer, die das PVS-Studio-Team auff√ºllen, ihre Arbeit mit dem Schreiben eines Artikels √ºber die Analyse eines Open-Source-Projekts beginnen.  Dieses Mal wird ein solch bew√§hrtes Projekt die Telerik-Benutzeroberfl√§che f√ºr UWP sein. <br><a name="habracut"></a><br><h2>  PVS-Studio Code Analyzer </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> ist ein Tool zum Erkennen von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # und Java geschrieben wurden.  L√§uft unter Windows, Linux und MacOS. <br><br>  Der Analysator bietet verschiedene Verwendungsszenarien: <br><br><ul><li>  kann lokal auf Entwicklungsmaschinen verwendet werden und als Plug-In in Visual Studio oder IntelliJ IDEA integriert werden; </li><li>  kann in die SonarQube-Plattform f√ºr kontinuierliche Qualit√§tssicherung integriert werden; </li><li>  kann unabh√§ngig verwendet werden und in das Montagesystem integriert werden; </li><li>  Es ist m√∂glich, das Dienstprogramm zur Kompilierungs√ºberwachung zu verwenden. </li><li>  Die Integration mit Azure DevOps, Jenkins, TeamCity, Travis CI und √§hnlichen Systemen ist m√∂glich. </li><li>  usw. </li></ul><br><h2>  Gepr√ºftes Projekt </h2><br>  Telerik UI for UWP ist eine Reihe von Benutzeroberfl√§chenkomponenten f√ºr die Universal Windows Platform (UWP).  Der Quellcode f√ºr das Projekt ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Github</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">finden</a> .  Das Set enth√§lt mehr als 20 Komponenten, mit denen Sie Daten in Form von Diagrammen visualisieren, Listen und Tabellen erstellen und mithilfe einer Karte Daten demonstrieren k√∂nnen, die einem Standort zugeordnet sind. <br><br><h2>  Fragmente, die beim Studium des Analysatorberichts Aufmerksamkeit erregt haben </h2><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3013</a> Es ist merkw√ºrdig, dass der Hauptteil der Funktion 'OnMinValuePropertyChanged' dem Hauptteil der Funktion 'OnMaxValuePropertyChanged' vollst√§ndig entspricht.  RadGauge.cs 446 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMinValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> newVal = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue; ValidateValue(newVal); RadGauge gauge = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGauge; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gauge.panel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { gauge.panel.UpdateOnMinMaxValueChange(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peer = FrameworkElementAutomationPeer.FromElement(gauge) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGaugeAutomationPeer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (peer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { peer.RaiseMinimumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMaxValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> newVal = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue; ValidateValue(newVal); RadGauge gauge = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGauge; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gauge.panel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { gauge.panel.UpdateOnMinMaxValueChange(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peer = FrameworkElementAutomationPeer.FromElement(gauge) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RadGaugeAutomationPeer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (peer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { peer.RaiseMinimumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); } } }</code> </pre> <br>  Der Analysator hat zwei Methoden erkannt, <i>OnMinValuePropertyChanged</i> und <i>OnMaxValuePropertyChanged</i> , die dieselben Aktionen ausf√ºhren.  Ich habe den starken Verdacht, dass sich ein Fehler in diesen Code eingeschlichen hat.  Beachten Sie, dass sowohl die <i>OnMinValuePropertyChanged-</i> Methode als auch die <i>OnMaxValuePropertyChanged-</i> Methode <i>RaiseMinimumPropertyChangedEvent verwenden</i> .  Gleichzeitig finden <i>Sie</i> in der <i>RadGaugeAutomationPeer-</i> Klasse sowohl eine Methode f√ºr "Minimum" als auch f√ºr "Maximum": <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseMaximumPropertyChangedEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RaisePropertyChangedEvent( RangeValuePatternIdentifiers.MaximumProperty, oldValue, newValue); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseMinimumPropertyChangedEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RaisePropertyChangedEvent( RangeValuePatternIdentifiers.MinimumProperty, oldValue, newValue); }</code> </pre> <br>  Die <i>RaiseMaximumPropertyChangedEvent-</i> Methode wird im Code nie verwendet, <i>RaiseMinimumPropertyChangedEvent</i> wird jedoch zweimal verwendet.  Und, wissen Sie, die Leistung der <i>OnMaxValuePropertyChanged-</i> Methode wirft Fragen auf ... Ich denke, sie sollte Folgendes schreiben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMaxValuePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> DependencyObject sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { .... peer.RaiseMaximumPropertyChangedEvent((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.OldValue, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)args.NewValue); .... }</code> </pre> <br>  Trotzdem sieht der Code aufgrund der gro√üen Anzahl sich wiederholender Elemente nicht sehr ordentlich aus.  Es ist schwer zu verstehen, und wiederholte Zeilen tr√ºben die Aufmerksamkeit des Programmierers, und es wird schwieriger, unter solchen Bedingungen eine Code√ºberpr√ºfung durchzuf√ºhren.  Die statischen Analysetools k√∂nnen diesen Code jedoch hervorragend √ºberpr√ºfen (dies bedeutet jedoch nicht, dass Sie auf Refactoring und insbesondere auf die Reduzierung der Anzahl wiederholter Zeilen verzichten k√∂nnen). <br><br>  Aus dem obigen und dem folgenden Codeausschnitt k√∂nnen wir annehmen, dass die Autoren dem Kopieren und Einf√ºgen nicht abgeneigt sind.  Wie wir alle ... :) <br><br>  <b>PVS-Studio</b> <b>Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3001</a> Links und rechts von '||' befinden sich identische Unterausdr√ºcke 'element.RenderSize == emptySize'.  Betreiber.  TiltInteractionEffect.cs 181 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInElementBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameworkElement element, Point position</span></span></span><span class="hljs-function">)</span></span> { Size emptySize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Size(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element.RenderSize == emptySize || element.RenderSize == emptySize) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(....).Contains(position); }</code> </pre> <br>  Der Analysator hat ein Fehlercodefragment erkannt, in dem sich rechts und links vom Operator '||' befindet  Die if- <i>Anweisung</i> verwendet dieselben Unterausdr√ºcke.  Der zweite Unterausdruck h√§tte eindeutig anders aussehen sollen.  Vielleicht sollte anstelle des zweiten <i>RenderSize</i> <i>DesiredSize sein</i> .  Oder es sollte √ºberhaupt keinen zweiten Unterausdruck geben.  In jedem Fall muss dieser Code repariert werden. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3001</a> Links und rechts vom '||' befinden sich identische Unterausdr√ºcke 'text [0] ==' - ''.  Betreiber.  RadNumericBox.cs 1057 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.textBox.Text; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text.Length == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span> || text[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'-'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isNegative) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isNegative = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetText(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Hier schreibt der Entwickler den im Textfeld eingegebenen Text in eine Variable.  Dann wird das erste Zeichen der Zeichenfolge zweimal mit demselben Zeichen '-' verglichen, was eine verd√§chtige Entscheidung ist.  Offensichtlich funktioniert die Text√ºberpr√ºfung in dieser Funktion nicht wie urspr√ºnglich beabsichtigt. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3001</a> Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke 'newValue.HasValue'.  DateTimePicker.cs 576 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValueChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, DependencyPropertyChangedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { DateTimePicker picker = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DateTimePicker; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newValue = (DateTime?)args.NewValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newValue.HasValue &amp;&amp; newValue != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Der Ausdruck <i>newValue.HasValue</i> gibt <i>true</i> zur√ºck <i>,</i> wenn <i>newValue</i> einen Wert enth√§lt, und der Ausdruck <i>newValue! =</i> <i>Null</i> macht dasselbe.  Der Analysator achtet darauf, und was zu tun ist, ist, einen der Unterausdr√ºcke zu entfernen oder durch einen anderen zu ersetzen (wenn etwas anderes √ºberpr√ºft werden musste), liegt es an den Entwicklern, zu entscheiden. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> Das Objekt 'CurrentAttachedMenu' wurde verwendet, nachdem es gegen null √ºberpr√ºft wurde.  √úberpr√ºfen Sie die Zeilen: 98, 96. PopupService.cs 98 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PopupService</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Overlay_PointerPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentAttachedMenu == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !CurrentAttachedMenu.hitTestService. HitTest(e.GetCurrentPoint(CurrentAttachedMenu).Position).Any()) { CurrentAttachedMenu.IsOpen = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; HideOverlay(); } } }</code> </pre> <br>  Wenn sich herausstellt, dass die Variable <i>CurrentAttachedMenu</i> <i>null ist</i> , <i>l√∂st</i> die Auswertung des Ausdrucks <i>CurrentAttachedMenu.IsOpen</i> eine Ausnahme aus.  Auf den ersten Blick scheint dies ein einfacher Tippfehler zu sein und bedeutete keinen Vergleich mit <i>null</i> , sondern die inverse Operation - '! ='.  In der Bedingung der <i>if-Anweisung tritt jedoch</i> eine Ausnahme auf, wenn die Variable <i>CurrentAttachedMenu</i> <i>null ist</i> . <br><br>  Weiter im Code gab es weitere <b>37</b> der gleichen Warnungen, von denen einige auf Fehler hinweisen.  Aber sie im Rahmen eines Artikels zu beschreiben, ist immer noch zu viel, deshalb werde ich sie unbeaufsichtigt lassen. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'dragDropElement', 'uiDragDropElement'.  DragDrop.cs 91 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDrag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dragDropElement = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IDragDropElement; .... UIElement uiDragDropElement = dragDropElement <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UIElement; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dragDropElement == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !dragDropElement.CanStartDrag(trigger, initializeContext)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Es ist sehr wahrscheinlich, dass der Autor die Variablen verwechselt hat.  Die <i>Nullungleichung</i> wird nicht durch den Link √ºberpr√ºft, der als Ergebnis der <i>Umwandlung erhalten wurde</i> , sondern durch das Original ( <i>dragDropElement</i> ).  H√∂chstwahrscheinlich sollte der Link <i>uiDragDropElement √ºberpr√ºft werden</i> .  Die Vermutung wird auch durch die Tatsache best√§tigt, dass der Programmierer <i>uiDragDropElement</i> weiter verwendet <i>hat,</i> ohne nach <i>Null zu</i> <i>suchen</i> . <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3030</a> Wiederkehrende Pr√ºfung.  Die Bedingung '! ShowIndicatorWhenNoData' wurde bereits in Zeile 139 √ºberpr√ºft. RadDataBoundListBox.PullToRefresh.cs 141 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandlePullToRefreshItemStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item, ItemState state</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showIndicatorWhenNoData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ShowPullToRefreshWhenNoData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.realizedItems.Count == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !showIndicatorWhenNoData) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == ItemState.Recycled &amp;&amp; !showIndicatorWhenNoData) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.StopPullToRefreshLoading(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HidePullToRefreshIndicator(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Der Analysator hat einen Code gefunden, in dem unter zwei Bedingungen dieselbe <i>showIndicatorWhenNoData-</i> Variable erneut √ºberpr√ºft wird.  Vielleicht ist die Pr√ºfung einfach redundant, aber es besteht auch die M√∂glichkeit, dass einer der doppelten Unterausdr√ºcke √ºberhaupt anders sein sollte. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3031</a> Eine √ºberm√§√üige √úberpr√ºfung kann vereinfacht werden.  Das '||'  Der Operator ist von entgegengesetzten Ausdr√ºcken umgeben.  SelectedItemCollection.cs 77 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SelectedItemCollection</span></span> : <span class="hljs-title"><span class="hljs-title">ObservableCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanInsertItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspendLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowSelect &amp;&amp; ((!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect); } }</code> </pre> <br>  Dieser Code ist formal nicht fehlerhaft.  Der Analysator weist auf eine gewisse Code-Redundanz in der Bedingung hin.  Es ist jedoch zu beachten, dass zus√§tzlicher Code manchmal das Ergebnis eines Fehlers ist, z. B. wenn anstelle einer Variablen eine andere mehrmals √ºberpr√ºft wird. <br><br>  Sie k√∂nnen diesen Zustand etwas reduzieren und den zus√§tzlichen Code entfernen.  Zum Beispiel so: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SelectedItemCollection</span></span> : <span class="hljs-title"><span class="hljs-title">ObservableCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanInsertItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspendLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowSelect &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllowMultipleSelect || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br>  Andere √§hnliche Nachrichten: <br><br><ul><li>  V3031 Eine √ºberm√§√üige √úberpr√ºfung kann vereinfacht werden.  Das '||'  Der Operator ist von entgegengesetzten Ausdr√ºcken umgeben.  SelectedItemCollection.cs 93 </li><li>  V3031 Eine √ºberm√§√üige √úberpr√ºfung kann vereinfacht werden.  Das '||'  Der Operator ist von entgegengesetzten Ausdr√ºcken umgeben.  StackVirtualizationStrategy.cs 49 </li><li>  V3031 Eine √ºberm√§√üige √úberpr√ºfung kann vereinfacht werden.  Das '||'  Der Operator ist von entgegengesetzten Ausdr√ºcken 'state == null' und 'state! = null' umgeben.  LocalFieldDescriptionsProviderBase.cs 24 </li></ul><br>  Stellen Sie sich einen anderen Code vor, bei dem der Analysator Folgendes zur√ºckgegeben hat: <br><br>  <b>PVS-Studio-Warnungen</b> : <br><br><ul><li>  V3137 Die Variable 'leftMargin' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  DragDrop.cs 87 </li><li>  V3137 Die Variable 'topMargin' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  DragDrop.cs 88 </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DragDrop</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> leftMargin = <span class="hljs-number"><span class="hljs-number">0</span></span>d; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> topMargin = <span class="hljs-number"><span class="hljs-number">0</span></span>d; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frameworkElementSource != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { leftMargin = frameworkElementSource.Margin.Left; <span class="hljs-comment"><span class="hljs-comment">// &lt;= topMargin = frameworkElementSource.Margin.Top; // &lt;= } if (dragDropElement == null || !dragDropElement.CanStartDrag(trigger, initializeContext)) { return; } var context = dragDropElement .DragStarting(trigger, initializeContext); if (context == null) { return; } var startDragPosition = e .GetCurrentPoint(context.DragSurface.RootElement).Position; var relativeStartDragPosition = e .GetCurrentPoint(uiDragDropElement).Position; var dragPositionMode = DragDrop .GetDragPositionMode(uiDragDropElement); AddOperation(new DragDropOperation( context, dragDropElement, dragPositionMode, e.Pointer, startDragPosition, relativeStartDragPosition)); }</span></span></code> </pre> <br>  Der Analysator meldet, dass den <i>Variablen</i> <i>leftMargin</i> und <i>topMargin</i> Werte zugewiesen wurden. <i>Danach werden</i> diese Variablen jedoch erst am Ende der Methode verwendet.  Hier liegt wahrscheinlich kein Fehler vor, aber ein solcher Code sieht verd√§chtig aus.  Dies kann auf einen Tippfehler oder ein erfolgloses Refactoring zur√ºckzuf√ºhren sein. <br><br>  Das gleiche Problem wurde an anderer Stelle gefunden: V3137 Die Variable 'currentColumnLength' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  WrapLayout.cs 824 <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3061 Der</a> Parameter 'index' wird vor der Verwendung immer im Methodenk√∂rper neu geschrieben.  DataEngine.cs 1443 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Tuple&lt;Group, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindGroupAndItemIndex</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">.... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exhaustiveSearch) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aggregateRowGroup = rowRootGroup; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rowGroupNames = valueProvider.GetRowGroupNames(item); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> groupName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rowGroupNames) { Group <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aggregateRowGroup.TryGetGroup(groupName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { aggregateRowGroup = <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>; } } index = aggregateRowGroup.IndexOf(item, <span class="hljs-comment"><span class="hljs-comment">// &lt;= valueProvider.GetSortComparer()); return Tuple.Create(aggregateRowGroup, index); } }</span></span></code> </pre> <br>  Der <i>Indexparameter</i> der <i>FindGroupAndItemIndex-</i> Methode <i>wird</i> vor der Verwendung √ºberschrieben.  Dies weist h√∂chstwahrscheinlich auf einen Programmiererfehler hin. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> Unsicherer Aufruf des Ereignisses 'Abgeschlossen', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  ActionBase.cs 32 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ActionBase</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsCompleted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Completed != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Completed(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } } }</code> </pre> <br>  Der Programmierer hat bei dieser Methode einen m√∂glicherweise unsicheren Aufruf des Ereignishandlers zugelassen, was zu einer Ausnahme vom Typ <i>NullReferenceException f√ºhren kann</i> .  Eine Ausnahme wird ausgel√∂st, sofern dieses Ereignis zwischen der <i>Nullpr√ºfung</i> und dem Aufruf der Ereignishandler nicht verbleibt. <br><br>  Es gibt weitere <b>49</b> √§hnliche Probleme im Code.  Es wird nicht interessant sein, alle in diesem Artikel zu sehen, und die Autoren k√∂nnen sie mit PVS-Studio leicht selbst finden, sodass wir zu anderen Fehlern √ºbergehen. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3145</a> Unsichere Dereferenzierung eines WeakReference-Ziels. √úberpr√ºfen Sie info.Target.  Das Objekt k√∂nnte zwischen der √úberpr√ºfung von 'IsAlive' und dem Zugriff auf die Eigenschaft 'Target' M√ºll gesammelt haben.  FadeAnimation.cs 84 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RadFadeAnimation</span></span> : <span class="hljs-title"><span class="hljs-title">RadAnimation</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyAnimationValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayAnimationInfo info</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.Target.Opacity != opacity) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { info.Target.Opacity = opacity; } .... } .... }</span></span></code> </pre> <br>  Der Analysator warnt vor der Gefahr einer Ausnahme vom Typ <i>NullReferenceException</i> beim Zugriff auf die Eigenschaft <i>info.Target.Opacity</i> .  Um das Wesentliche des Problems besser zu verstehen, m√ºssen Sie sich Fragmente der <i>PlayAnimationInfo-</i> Klasse <i>ansehen</i> , insbesondere die <i>Target-</i> Eigenschaft. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayAnimationInfo</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WeakReference target; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayAnimationInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Storyboard storyboard, RadAnimation animation, UIElement target</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(target); .... } .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UIElement Target { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target.IsAlive) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target.Target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UIElement; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } .... }</code> </pre> <br>  Je weiter Sie diesen Code ausgraben, desto mehr potenzielle Probleme k√∂nnen Sie im Allgemeinen darin finden.  Schauen wir uns das vielleicht interessanteste an - das, an das der Analysator eine Warnung ausgegeben hat.  Tatsache ist, dass selbst wenn die Ausf√ºhrung dem damaligen Zweig der <i>if-Anweisung</i> folgt, dies nicht garantiert, dass eine Referenz ungleich Null zur√ºckgegeben wird.  Unabh√§ngig von Gespr√§chen √ºber die Besetzung betrachten wir hier alles, was aufgrund der Initialisierung des Objekts im Konstruktor zul√§ssig ist. <br><br>  Wie ist das m√∂glich?  Tatsache ist, dass <i>this.target.Target null zur√ºckgibt</i> , wenn zwischen der <i>IsAlive-</i> Pr√ºfung und dem <i>Target-</i> Aufruf die Garbage Collection ausgef√ºhrt wird, unter die das von <i>WeakReference</i> referenzierte <i>Objekt f√§llt</i> .  Das hei√üt, die <i>IsAlive-</i> Pr√ºfung garantiert nicht, dass das Objekt beim n√§chsten Zugriff auf das Ziel weiterhin verf√ºgbar ist. <br><br>  √úbrigens ist die Situation <i>null;</i>  f√§ngt eine andere Diagnoseregel ab: V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'info.Target'.  FadeAnimation.cs 84 <br><br>  √Ñhnliche Probleme im Code traten mehrmals auf: <br><br><ul><li>  V3145 Unsichere Dereferenzierung eines WeakReference-Ziels. √úberpr√ºfen Sie das Ziel.  Das Objekt k√∂nnte M√ºll gesammelt worden sein, bevor auf die Eigenschaft 'Target' zugegriffen wurde.  MoveXAnimation.cs 80 </li><li>  V3145 Unsichere Dereferenzierung eines WeakReference-Ziels. √úberpr√ºfen Sie das Ziel.  Das Objekt k√∂nnte M√ºll gesammelt worden sein, bevor auf die Eigenschaft 'Target' zugegriffen wurde.  MoveYAnimation.cs 80 </li><li>  V3145 Unsichere Dereferenzierung eines WeakReference-Ziels. √úberpr√ºfen Sie info.Target.  Das Objekt k√∂nnte M√ºll gesammelt worden sein, bevor auf die Eigenschaft 'Target' zugegriffen wurde.  PlaneProjectionAnimation.cs 244 </li><li>  V3145 Unsichere Dereferenzierung eines WeakReference-Ziels.  Das Objekt k√∂nnte zwischen der √úberpr√ºfung von 'IsAlive' und dem Zugriff auf die Eigenschaft 'Target' M√ºll gesammelt haben.  WeakEventHandler.cs 109 </li></ul><br>  Fahren wir mit dem n√§chsten Beispiel fort. <br><br>  <b>Warnung PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3066</a> M√∂glicherweise falsche Reihenfolge der an den Konstruktor 'NotifyCollectionChangedEventArgs' √ºbergebenen Argumente: 'oldItem' und 'newItem'.  CheckedItemsCollection.cs 470 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CheckedItemsCollection</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">INotifyCollectionChanged</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> NotifyCollectionChangedEventArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Add: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Remove: .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NotifyCollectionChangedAction.Replace: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs( action, oldItem, newItem, changeIndex); <span class="hljs-comment"><span class="hljs-comment">// &lt;= default: return new NotifyCollectionChangedEventArgs(action); } } }</span></span></code> </pre> <br>  Um zu verstehen, was diese Warnung des Analysators bedeutet, sollten Sie sich die Konstruktorparameter <i>NotifyCollectionChangedEventArgs ansehen</i> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotifyCollectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> NotifyCollectionChangedAction action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldItem, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  Der Analysator warnt dies im Ausdruck <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotifyCollectionChangedEventArgs( action, oldItem, newItem, changeIndex);</code> </pre> <br>  tauschte die Variablen <i>oldItem</i> und <i>newItem aus</i> .  In der Konstruktordefinition werden sie in einer anderen Reihenfolge aufgelistet.  Ob dies bewusst gemacht wurde oder nicht, kann man nur erraten. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3102</a> Verd√§chtiger Zugriff auf das Element des ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x'</a> -Objekts durch einen konstanten Index innerhalb einer Schleife.  DataEngine.cs 1718 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ObjectArrayComparer</span></span> : <span class="hljs-title"><span class="hljs-title">IEqualityComparer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>[]&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] y</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; x.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(x[<span class="hljs-number"><span class="hljs-number">0</span></span>], y[<span class="hljs-number"><span class="hljs-number">0</span></span>])) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return false; } } return true; } .... }</span></span></code> </pre> <br>  Bei jeder Iteration in der Schleife vergleicht der Programmierer <i>x [0]</i> und <i>y [0].</i>  Die Schleife ist in diesem Code jedoch nicht sinnvoll, da nur die ersten Elemente verglichen werden.  Dies bedeutete h√∂chstwahrscheinlich einen Vergleich der entsprechenden Elemente von Arrays.  Dann lautet der richtige Code wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; x.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.Equals(x[i], y[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  <b>Warnung PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3123</a> M√∂glicherweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert</a> der Operator '?:' Anders als erwartet.  Seine Priorit√§t ist niedriger als die Priorit√§t anderer Betreiber in seinem Zustand.  EditRowHostPanel.cs 35 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Size </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureOverride</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Size availableSize</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> shouldUpdateRowHeight = editorLine == <span class="hljs-number"><span class="hljs-number">0</span></span> || displayedElement == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-literal"><span class="hljs-literal">false</span></span> : displayedElement.ContainerType != <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DataGridGroupHeader); .... }</code> </pre> <br>  Mit der Verwendung des Operators '?:' Ist eine Warnung verbunden.  Es hat eine niedrigere Priorit√§t als <i>! =, ||, ==.</i>  Daher wird ein Ausdruck m√∂glicherweise nicht wie vom Programmierer geplant ausgewertet.  Anscheinend ist dies in diesem Fall falsch positiv und der Code funktioniert korrekt.  Das Lesen eines solchen Codes ist jedoch sehr schwierig und es gibt nie die Gewissheit, dass er richtig verstanden wird.  Es f√ºhlt sich so an, als h√§tte der Entwickler so geschrieben, dass niemand etwas verstanden hat :) Der beste Weg, dies zu tun, ist besser lesbar - verwenden Sie Klammern oder die <i>if-Anweisung</i> . <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3078 Die</a> urspr√ºngliche Sortierreihenfolge geht nach wiederholtem Aufruf der 'OrderBy'-Methode verloren.  Verwenden Sie die 'ThenBy'-Methode, um die urspr√ºngliche Sortierung beizubehalten.  GridModel.Selection.cs 107 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GridModel</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildCellSelectionRegions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MergeCellSelectionRegions(selectedItemsInView .OrderBy(c =&gt; c.Column.ItemInfo.LayoutInfo.Line) .OrderBy(c =&gt; c.RowItemInfo.LayoutInfo.Line)); } }</code> </pre> <br>  Der Fehler h√§ngt mit dem <i>erneuten</i> Aufrufen von <i>OrderBy</i> f√ºr eine Auflistung vom Typ <i>IOrderedEnumerable zusammen</i> .  Hier wird die Sammlung zuerst nach Spalten und dann nach Zeilen sortiert.  Dar√ºber hinaus wird zum Zeitpunkt der Sortierung nach Zeilen die vorherige Sortierung nach Spalten nirgendwo ber√ºcksichtigt.  Verwenden Sie <i>ThenBy</i> , um die Sortierung nach Spalten nicht zu verlieren und die Sammlung nach mehreren Kriterien gleichzeitig zu <i>sortieren</i> : <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MergeCellSelectionRegions(selectedItemsInView .OrderBy(c =&gt; c.Column.ItemInfo.LayoutInfo.Line) .ThenBy(c =&gt; c.RowItemInfo.LayoutInfo.Line));</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> Der Variablen 'currentColumnLength' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 791, 785. WrapLayout.cs 791 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAvailableLengthChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumnLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> paddingValue = Math.Max(<span class="hljs-number"><span class="hljs-number">0</span></span>, newValue - currentColumnLength); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.paddingRenderInfo.Add(paddingValue); currentColumnLength = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= slotCount++; } this.ColumnSlotsRenderInfo.Update(i, newValue); this.paddingRenderInfo.Add(0); currentColumnLength = 0; // &lt;= slotCount++; continue; } else { .... } .... }</span></span></code> </pre> <br>  Dem Analysator erschien es verd√§chtig, dass der Variablen <i>currentColumnLength</i> zweimal ein Wert zugewiesen wurde.  Die Variable wird nicht zwischen Zuweisungen verwendet.  Unabh√§ngig von der Bedingung ist diese Variable letztendlich Null.  Dieser Code ist entweder falsch oder redundant. <br><br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3127</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise handelt es sich um einen Tippfehler, und anstelle von RadRatingItem.cs 240 sollte die Variable 'emptyIconContainer' verwendet werden <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RadRatingItem</span></span> : <span class="hljs-title"><span class="hljs-title">RadContentControl</span></span> { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnApplyTemplate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.filledIconContainer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetTemplateChild( <span class="hljs-string"><span class="hljs-string">"FilledIconContainer"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Border; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.filledIconContainer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { throw new MissingTemplatePartException( "FilledIconContainer", typeof(Border)); } this.emptyIconContainer = this.GetTemplateChild( "EmptyIconContainer") as Border; if (this.filledIconContainer == null) // &lt;= { throw new MissingTemplatePartException( "EmptyIconContainer", typeof(Border)); } this.Initialize(); } .... }</span></span></code> </pre> <br>  Aufgrund eines Tippfehlers wurden im Code zwei identische Bedingungen angezeigt.  Gemessen an der generierten Ausnahme sollte die zweite Bedingung folgenderma√üen aussehen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emptyIconContainer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MissingTemplatePartException( <span class="hljs-string"><span class="hljs-string">"EmptyIconContainer"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Border)); }</code> </pre> <br>  <b>PVS-Studio Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3020</a> Eine bedingungslose Unterbrechung innerhalb einer Schleife.  NodePool.cs 189 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;T&gt;&gt;&gt; GetUnfrozenDisplayedElements() { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generatedContainers) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> item.Value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pair.IsFrozen) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> <br>  Der Analysator stellte fest, dass hier die <i>break-</i> Anweisung nicht zur <i>if-Anweisung geh√∂rt</i> .  <i>Break</i> wird unabh√§ngig vom Wert von <i>pair.IsFrozen</i> ausgef√ºhrt. <i>Aus diesem</i> Grund wird in <i>foreach</i> nur eine Iteration ausgef√ºhrt. <br><br>  Damit ist meine √úberlegung zu Warnungen abgeschlossen.  Damit Telerik-Entwickler eine gr√ºndlichere Code-Analyse durchf√ºhren und Fehler beheben k√∂nnen, sind wir bereit, ihnen eine tempor√§re Lizenz zur Verf√ºgung zu stellen.  Dar√ºber hinaus k√∂nnen sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlose Nutzung der PVS-Studio-</a> Option nutzen, die Autoren von Open Source-Projekten zur Verf√ºgung gestellt wird. <br><br><h2>  Fazit </h2><br>  Obwohl die Entwickler von Telerik UI f√ºr UWP gro√üartige Arbeit geleistet haben, war es nicht ohne Tippfehler, wie es normalerweise passiert :).  Alle diese Fehler konnten leicht von einem statischen Analyseger√§t gefunden und korrigiert werden.  Das Wichtigste ist, den Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">korrekt und regelm√§√üig zu verwenden</a> . <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Ekaterina Nikiforova.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberpr√ºfen der Telerik-Benutzeroberfl√§che auf UWP als Einstieg in PVS-Studio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470584/">https://habr.com/ru/post/de470584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470570/index.html">GridmiAPI - eine einfache und flexible Android-Bibliothek f√ºr die Arbeit mit REST & RPC</a></li>
<li><a href="../de470572/index.html">‚ÄûAutomatisierung der Infrastruktur. Warum machen wir das? " (Denis Yakovlev)</a></li>
<li><a href="../de470576/index.html">Banks of America wird in den kommenden Jahren 200.000 Arbeitspl√§tze abbauen</a></li>
<li><a href="../de470578/index.html">Wie wir die Buchhaltung in einer mobilen Bank ‚Äûhumanisiert‚Äú haben</a></li>
<li><a href="../de470582/index.html">√úberpr√ºfen der Telerik-Benutzeroberfl√§che auf UWP als Einstieg in PVS-Studio</a></li>
<li><a href="../de470594/index.html">Bericht von der Lichtshow ‚ÄûCircle of Light‚Äú 2019 in Moskau</a></li>
<li><a href="../de470596/index.html">Funktionen von Q und KDB + am Beispiel eines Echtzeitdienstes</a></li>
<li><a href="../de470598/index.html">Das Buch "Modernes Java. Lambda-Ausdr√ºcke, Streams und funktionale Programmierung ‚Äú</a></li>
<li><a href="../de470600/index.html">√úber sichere noVNC-Konsolen, automatische Skalierung in Kubernetes, Haproxy in Ostrovka und die Arbeit von Administratoren mit Programmierern</a></li>
<li><a href="../de470604/index.html">Geschwindigkeit beim Laden von Websites im E-Commerce: Analyse von 48 Top-Online-Shops in Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>