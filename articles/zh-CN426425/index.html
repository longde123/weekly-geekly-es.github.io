<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍💼 🛑 🏇 关于RTOS的全部真相。 第十四条 内存部分：简介和基本服务 😈 ⛹🏾 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前面的一篇文章（＃6）中前面提到了内存的各个部分，其中与C malloc（）语言的标准功能进行了比较。 分区是从分区池（内存池）获得的内存区域。 共享内存提供了一种灵活而可靠的方法，可以确定地分配和释放内存。 

 该系列中的先前文章： 
 第十三条 任务数据结构和不受支持的API调用 
 第十二条...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第十四条 内存部分：简介和基本服务</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426425/"><img src="https://habrastorage.org/webt/nh/9i/nk/nh9inkxdyuljdn4wesz0e-lpjhg.jpeg"><br><br> 前面的一篇文章（＃6）中前面提到了内存的各个部分，其中与C <b>malloc（）</b>语言的标准功能进行了比较。 分区是从分区池（内存池）获得的内存区域。 共享内存提供了一种灵活而可靠的方法，可以确定地分配和释放内存。 <br><a name="habracut"></a><br> 该系列中的先前文章： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十三条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务数据结构和不受支持的API调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><h2> 使用部分 </h2><br> 在Nucleus SE中，分区池是在创建时配置的。 一个应用程序最多可以有16个分区池。 如果未配置它们，则与这些池相关的数据结构和服务调用将不包含在应用程序中。 <br><br> 分区池是划分为一定数量的固定大小的块的存储区域。 开发人员可以完全控制每个池中分区的大小和数量。 任务可以请求分配的内存部分，并接收指向存储区域的指针，并且不应在分配的部分之外写入数据。 将指针传递给API函数时，任何任务都可以释放该节。 在没有可用分区的情况下分配分区的请求可能导致错误或请求中止，具体取决于所选的API调用参数和Nucleus SE配置。 <br><br><h2> 设置内存分区 </h2><br><h3> 分区池数 </h3><br> 与大多数Nucleus SE对象一样，分区池配置主要使用<b>nuse_config.h中</b>的<b>#define</b>指令<b>完成</b> 。 主要参数是<b>NUSE_PARTITION_POOL_NUMBER</b> ，它确定在应用程序中定义了多少个分区池。 默认值为0（即不使用分区池），开发人员可以设置0到16之间的任何值。其他值将导致编译错误，该错误在<b>nuse_config_check.h</b>验证过程中检测到（包含在<b>nuse_config.c中</b> ，并且，则使用此模块进行编译），从而导致<b>#error</b>指令的编译。 <br><br> 选择非零值是激活分区池的优先方法。 这导致了数据结构的定义和适当大小的分配。  ROM中的数据结构必须使用描述每个分区池的适当值进行初始化。 下一篇文章将提供有关数据结构的更多详细信息。 此选择还会激活API设置。 <br><br><h3> 激活API调用 </h3><br>  Nucleus SE中的每个API函数（实用程序调用） <b>都由nuse_config.h中</b>的<b>#define</b>指令激活。 对于分区池，这些包括： <br><br>  <b>NUSE_PARTITION_ALLOCATE</b> <br>  <b>NUSE_PARTITION_DEALLOCATE</b> <br>  <b>NUSE_PARTITION_POOL_INFORMATION</b> <br>  <b>NUSE_PARTITION_POOL_COUNT</b> <br><br> 默认情况下，它们都设置为<b>FALSE</b> ，从而禁用每个服务调用并防止包含实现代码。 要在应用程序中配置分区池，您需要选择必要的API调用并将相应的指令设置为<b>TRUE</b> 。 <br><br> 以下是默认<b>nuse_config.h</b>文件的摘录： <br><br><img src="https://habrastorage.org/webt/gm/ih/_b/gmih_baxfyopw1op4ujx2t2fzue.jpeg"><br><br> 如果激活了分区池API功能，但未配置池，则会发生编译错误（始终启用的<b>NUSE_Partition_Pool_Count（）</b>除外）。 如果您的代码使用尚未激活的API调用，则会发生布局错误，因为实现代码未包含在应用程序中。 <br><br><h2> 分区池实用程序调用 </h2><br>  Nucleus RTOS支持与分区池有关的七个实用程序调用，它们提供以下功能： <br><br><table><tbody><tr><th>  <b>功能说明</b> </th><th>  <b>核RTOS</b> </th><th>  <b>核SE</b> </th></tr><tr><td> 选区 </td><td>  <b>NU_Allocate_Partition（）</b> </td><td>  <b>NUSE_Partition_Allocate（）</b> </td></tr><tr><td> 部分发布 </td><td>  <b>NU_Deallocate_Partition（）</b> </td><td>  <b>NUSE_Partition_Deallocate（）</b> </td></tr><tr><td> 提供信息 <br> 关于特定分区池 </td><td>  <b>NU_Partition_Pool_Information（）</b> </td><td>  <b>NUSE_Partition_Pool_Information（）</b> </td></tr><tr><td> 返回（当前）已配置数量的值 <br> 应用程序池 </td><td>  <b>NU_Established_Partition_Pools（）</b> </td><td>  <b>NUSE_Partition_Pool_Count（）</b> </td></tr><tr><td> 向应用程序添加（创建）新的分区池 </td><td>  <b>NU_Create_Partition_Pool（）</b> </td><td> 未实施。 </td></tr><tr><td> 从应用程序更改（删除）分区池 </td><td>  <b>NU_Delete_Partition_Pool（）</b> </td><td> 未实施。 </td></tr><tr><td> 返回指向应用程序中当前存在的所有分区池的指针 </td><td>  <b>NU_Partition_Pool_Pointers（）</b> </td><td> 未实施。 </td></tr></tbody></table><br> 将详细讨论每个调用的实现。 <br><br> 值得注意的是，Nucleus RTOS和Nucleus SE都没有重启功能。 这是有目的的。 通常，一个任务分配一个节并将一个指针传递给另一个任务（稍后可能会释放它）。 如果重新加载分区池，则所有分区都将标记为未使用，但是，没有机制可以监视和通知所有可以使用分区的任务。 <br><br><h2> 分区和发布服务 </h2><br> 分区池的基本操作是在池中分配分区（即，将分区标记为已使用并返回其地址）并释放该分区（即，该分区被标记为未使用）。  Nucleus RTOS和Nucleus SE为这些操作提供了两个基本的API调用，如下所述。 <br><br><h3> 选区 </h3><br>  Nucleus RTOS API调用分配分区非常灵活，如果无法立即完成操作，例如当您尝试从已经分配了所有分区的池中分配分区时，开发人员可以无限期地暂停任务或在没有超时的情况下暂停任务。  Nucleus SE提供相同的服务，只是其中的暂停任务是可选的，并且未实现超时。 <br><br><h3>  Nucleus RTOS API分区调用 </h3><br> 调用原型： <br><br>  <b>状态NU_Allocate_Partition（NU_PARTITION_POOL *池，VOID ** return_pointer，未签名挂起）;</b> <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_NO_PARTITION-</b>没有可用的部分； <br>  <b>NU_INVALID_POOL-</b>无效的分区池指针； <br>  <b>NU_INVALID_POINTER-</b>将空指针传递给返回的数据（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SUSPEND-</b>尝试从与任务无关的线程挂起任务； <br>  <b>NU_TIMEOUT-</b>即使暂停了指定的等待时间，也没有可用的分区； <br>  <b>NU_POOL_DELETED-</b>挂起任务时删除了分区池。 <br><br><h3>  Nucleus SE API调用以突出显示分区 </h3><br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 调用原型： <br><br>  <b>状态NUSE_Partition_Allocate（NUSE_PARTITION_POOL池，ADDR * return_pointer，U8挂起）；</b> <br><br> 参数： <br><br>  <b>pool-</b>使用的分区池的索引（ID）； <br>  <b>return_pointer-</b>指向<b>ADDR</b>类型变量的指针，该变量采用所选节的地址； <br>  <b>暂停</b> -用于暂停任务的参数；它可以采用值<b>NUSE_NO_SUSPEND</b>或<b>NUSE_SUSPEND</b> 。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_NO_PARTITION-</b>没有可用的部分； <br>  <b>NUSE_INVALID_POOL-</b>无效的分区池索引； <br>  <b>NUSE_INVALID_POINTER-</b>将空指针传递给返回的数据（ <b>NULL</b> ）； <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从与任务不相关的线程或禁用锁定API时挂起任务。 <br><br><h3>  Nucleus SE中的分区分配实现 </h3><br> 在检查参数之后，使用条件编译选择API函数代码<b>NUSE_Partition_Allocate</b> ，具体取决于是否激活了对块的API调用（挂起任务）。 下面我们将分别考虑这两个选项。 <br><br> 如果禁用了阻塞调用，则API调用非常简单： <br><br><img src="https://habrastorage.org/webt/se/0i/fx/se0ifxxbybhe2mjp5owlfc2zrr0.jpeg"><br><br> 首先，检查可用分区的可用性。 如果没有这样的分区，则返回错误（ <b>NUSE_NO_PARTITION</b> ）。 然后是部分的枚举，在此期间检查第一个字节是否为零值（指示未使用该部分）。 找到这样的分区后，将为其分配“ used”标志，其中包括分区池的索引（请参见下面的“释放分区”），并返回指向下一个字节（真实数据区域的开始）的指针。 有关分区池的数据结构的说明将在下一篇文章的“数据结构”部分中介绍。 <br><br> 如果激活了锁定，则此API调用的代码会变得更加复杂： <br><br><img src="https://habrastorage.org/webt/y_/os/bd/y_osbdsgsaqfon1cm0351zzxbxq.jpeg"><br><br> 该代码包含在<b>do ... while循环中</b> ，只要pause参数为<b>NUSE_SUSPEND</b> ，该<b>循环就会</b>继续运行。 <br><br> 如果没有可用的分区，并且pause参数为<b>NUSE_NO_SUSPEND</b> ，则API调用将停止并返回<b>NUSE_NO_PARTITION</b> 。 如果暂停参数设置为<b>NUSE_SUSPEND</b> ，任务将暂停。 当返回时（例如，当任务恢复时）， <b>NUSE_SUCCESS</b>的返回值指示该任务已恢复，因为释放了内存部分，并且代码返回到循环的开头。 由于没有用于重新加载分区池的API函数，因此，由于其他原因无法恢复任务，但是为了稳定阻止其他类型的对象，保留了<b>NUSE_Task_Blocking_Return []</b>验证过程。 <br><br><h3> 部分发布 </h3><br>  Nucleus RTOS和Nucleus SE中该部分的发布使其再次可用。 在发布之前，它不会检查此部分是否被任何任务使用，应用程序程序员对此负责。 仅需要指向数据区域的指针即可释放节。 <br><br><h3>  Nucleus RTOS API调用以进行免费分区 </h3><br> 调用原型： <br><br>  <b>状态NU_Deallocate_Partition（VOID *分区）;</b> <br><br> 参数： <br><br>  <b>partition-</b>指向要释放的分区的数据区域（由<b>NU_Allocate_Partition（）</b>函数返回<b>）</b>的指针； <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_POINTER-</b>空节指针，或不指示使用的有效节。 <br><br><h3>  Nucleus SE API调用到自由分区 </h3><br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 调用原型： <br><br>  <b>STATUS NUSE_Partition_Deallocate（ADDR分区）；</b> <br><br> 参数： <br><br>  <b>partition-</b>指向要释放的分区的数据区域（由<b>NUSE_Partition_Allocate（）</b>函数返回<b>）</b>的指针 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_POINTER-</b>节指针为null（ <b>NULL</b> ），或者不表示使用的有效节 <br><br><h3> 实作 </h3><br>  <b>NUSE_Partition_Deallocate（）</b>函数没有包含使用阻塞和非阻塞API函数来实现， <b>而是</b>仅包含一个有条件编译的部分，该部分负责解锁任务。 这段代码实现了节的释放： <br><br><img src="https://habrastorage.org/webt/sz/ro/zl/szrozlvg_xc8hbpeqmthmmdbm7a.jpeg"><br><br> 首先，从状态字节中检索节索引。 然后，分区的状态更改为“未使用”，已使用分区的计数器减少，并且该功能报告操作成功完成。 <br><br> 如果激活了锁定，则以下代码用于恢复等待可用分区池的任务： <br><br><img src="https://habrastorage.org/webt/9k/jm/3w/9kjm3wbdcj1lj6ruhimnhm67xva.jpeg"><br><br> 如果在此池中分配分区时任务被阻止，则将恢复第一个表。 <br><br> 在下一篇文章中，我们将讨论与内存分区以及相关数据结构有关的其他API调用。 <br><br>  <b>关于作者：</b> Colin Walls在电子行业工作了30多年，大部分时间用于固件。 他现在是Mentor Embedded（Mentor Graphics的一个部门）的固件工程师。  Colin Walls经常在会议和研讨会上发表演讲，他撰写了许多技术文章并撰写了两本有关固件的书。 居住在英国。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426425/">https://habr.com/ru/post/zh-CN426425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426415/index.html">金融科技摘要：中央银行的数字化控制，加密货币工资，手镯和钥匙圈形式的Mir卡</a></li>
<li><a href="../zh-CN426417/index.html">Pavel 2.0：JS，带有套接字和电话的node.js上的复制顾问</a></li>
<li><a href="../zh-CN426419/index.html">Java中禁止的重载或桥接方法</a></li>
<li><a href="../zh-CN426421/index.html">EHCI人为俄语</a></li>
<li><a href="../zh-CN426423/index.html">mmWave在智能手机上：高通如何使不可能变为可能</a></li>
<li><a href="../zh-CN426427/index.html">对“东西”有用的东西：少量低价选择</a></li>
<li><a href="../zh-CN426429/index.html">在Debian 9上安装FreeSWITCH 1.8（Raspbian Stretch，Rasbperri Pi上MajorDoMo智能家庭系统的基本映像）</a></li>
<li><a href="../zh-CN426431/index.html">拆卸Qlie视觉小说引擎</a></li>
<li><a href="../zh-CN426433/index.html">餐厅的美味SMM</a></li>
<li><a href="../zh-CN426435/index.html">最好的专家是我自己准备的专家：Mail.Ru集团专家提供的游戏测试课程</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>