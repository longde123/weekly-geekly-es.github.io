<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏻 🙍 ⏺️ PHP: estructura de base de datos cambiante en el desarrollo de equipos 💆 ⚰️ 📱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el mundo de PHP, las herramientas de migración de estructura de base de datos son bien conocidas: Doctrine , Phinx de CakePHP, de Laravel , de Yii ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP: estructura de base de datos cambiante en el desarrollo de equipos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435438/"><img src="https://habrastorage.org/webt/9w/hm/1i/9whm1icwtg7per-15vfhyjejcx8.png"><br><br>  En el mundo de PHP, las herramientas de migración de estructura de base de datos son bien conocidas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Doctrine</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Phinx</a> de CakePHP, de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Laravel</a> , de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yii</a> , esto es lo primero que se me ocurrió.  Seguramente hay una docena más.  Y la mayoría de ellos trabajan con migraciones: comandos para realizar cambios incrementales en el esquema de la base de datos. <br><br>  No describiré por qué esto es así, hay muchas publicaciones sobre este tema en Habré.  Por ejemplo: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Migración versionada de la estructura de la base de datos: enfoques básicos</a> : aunque el artículo anterior, los principios no envejecen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diseño de base de datos evolutiva</a> : traducción del artículo de Martin Fowler, buena descripción [enfoque incremental] </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Experimente las migraciones de la base de datos 1440</a> : una publicación práctica sobre el trabajo con PostgesSQL </li></ul><br>  Además, el desarrollo de mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">experiencia</a> como equipo con un cambio constante en la estructura de la base de datos en diferentes ramas. <br><a name="habracut"></a><br><h2>  SQL sin formato vs PHP api </h2><br>  Escribimos migraciones en SQL puro.  Muchas herramientas proporcionan API de PHP para escribir instrucciones traducidas al código SQL.  Ahora no entiendo por qué es esto.  Dicha herramienta siempre estará limitada en sus capacidades.  No permiten escribir instrucciones específicas para un motor específico; aún debe usar SQL puro.  No estoy hablando de escribir procedimientos y puntos de vista. <br><br>  Alguien se quejó de que no quería aprender la sintaxis de los comandos ALTER ... Bueno, no sé, abrí el directorio y escribí ejemplos de la montaña, especialmente en un gran proyecto. <br><br>  Las migraciones de datos (INSERT, UPDATE) también se escriben siempre en SQL.  Porque nunca puede confiar en la versión actual de ORM y Modelos.  En una revisión son, en la otra ya no. <br><br>  Por ejemplo: <br><br><pre><code class="plaintext hljs">Rollback Country::delete()-&gt;where(....)-&gt;execute();</code> </pre> <br>  Quiere revertir el estado de la base de datos.  Y esta clase de PHP ya no está en el repositorio.  Debes buscar el último commit donde estuvo y retroceder desde allí.  Brrr ... <br><br>  Por lo tanto, SQL es simple y confiable: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--TRANSACTION --UP ALTER TABLE authors ADD COLUMN code INT; ALTER TABLE posts ADD COLUMN slug TEXT; UPDATE authors SET ... --DOWN ALTER TABLE authors DROP COLUMN code; ALTER TABLE posts DROP COLUMN slug;</span></span></code> </pre><br><h2>  Transacciones en DDL </h2><br>  Con la transición a PostgreSQL, me olvidé de las migraciones rotas como una pesadilla: la migración cayó en el medio, algo enrollado, algo que no está allí, sentarse y editar los bolígrafos ... Esto nos obligó a escribir comandos atómicos de una sola línea y ejecutarlos uno por uno.  Todo es simple con las transacciones: si algo se rompe, todo retrocede (bueno, casi todo))).  Simplemente arréglalo y reinícialo.  El ensamblaje automático funciona con una explosión, si algo cae, se arregla y sube rápidamente. <br><br><h2>  Vistas (vistas) y funciones </h2><br>  El problema aquí es que no se pueden actualizar de forma incremental, como ALTERAR en las tablas.  Necesita GOTAR y CREAR.  Es decir  sobre el diferencial (texto de migración) no está del todo claro qué cambió al final.  Especialmente cuando la lógica está torcida, es bastante inconveniente.  Por ejemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--UP DROP VIEW ... CREATE VIEW mvstock AS SELECT (now() - '7 days'::interval) AS refreshed_at, o.pid, COALESCE(sum(o.debit), 0)::integer AS debit, COALESCE(sum(o.credit) FILTER (WHERE d.type &lt;&gt; 104), 0)::integer AS credit, COALESCE(sum(o.debit), 0) - COALESCE(sum(o.credit), 0)::integer AS total FROM operations o JOIN docs d ON d.id = o.doc_id AND d.deleted_at IS NULL WHERE d.closed_at &lt; (now() - '7 days'::interval) AND d.type &lt;&gt; 500 GROUP BY o.pid WITH DATA; --DOWN DROP VIEW ... CREATE VIEW mvstock AS SELECT (now() - '10 days'::interval) AS refreshed_at, o.pid, COALESCE(sum(o.debit), 0)::integer AS debit, COALESCE(sum(o.credit) FILTER (WHERE d.type &lt;&gt; 104), 0)::integer AS credit, COALESCE(sum(o.debit), 0) - COALESCE(sum(o.credit), 0)::integer AS total FROM operations o JOIN docs d ON d.id = o.doc_id AND d.deleted_at IS NULL WHERE d.closed_at &lt; (now() - '10 days'::interval) AND d.type &lt;&gt; 500 GROUP BY o.pid WITH DATA;</span></span></code> </pre><br>  ¿Qué ha cambiado aquí? <br><br>  Nos detuvimos ante el hecho de que al lado de las migraciones hay un papá, donde se almacena el código de vista y procedimiento actual, que se actualiza y copia en la migración de reversión. <br><br>  Y ahora la diferencia se convierte en: <br><br><img src="https://habrastorage.org/webt/it/lh/rx/itlhrxyorlounbpannounrvyewa.png"><br><br>  De vuelta en Avito, creamos una solución interesante para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versionar el código de procedimiento almacenado.</a> <br><br>  En general, este caso plantea un buen problema: cómo ver el historial de cambios en un objeto particular de la estructura de la base de datos.  Para cada tabla, quiero ver el historial de cambios en relación con la solución de tareas específicas. <br><br><img src="https://habrastorage.org/webt/hr/pw/rz/hrpwrzndgamurxtdv9i0g4ixai8.png"><br><br>  En Habré se encontró un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enfoque</a> interesante para la automatización de la fijación de cambios en la estructura de la base de datos. <br><br><h2>  Trabajar con ramas </h2><br>  Mi dolor eterno es cómo cambiar entre dos ramas A y B, cada una de las cuales tiene ediciones en la estructura de la base de datos. <br><br><img src="https://habrastorage.org/webt/m7/te/j8/m7tej8krsjwkp6dw7vf3d7yb9iy.png"><br><br>  Es necesario revertir las migraciones en la rama A (también debemos recordar cuál y cuántas), luego cambiar a la rama B y rodar nuevas migraciones.  De acuerdo, si nuestras ediciones son compatibles y puedo cambiar a la segunda rama y realizar migraciones adicionales desde B. <br><br>  Y si no?  ¿Y si tengo más de una rama?  Y luego revertir todos estos estado de revisión?  Siempre lo odié ... <br><br>  Ahora, al cambiar a la sucursal de otra persona, puedo eliminar automáticamente las migraciones de otras personas y pasar las actuales: <br><br><img src="https://habrastorage.org/webt/9w/hm/1i/9whm1icwtg7per-15vfhyjejcx8.png"><br><br>  donde: <br><br>  <b>D</b> : migraciones A que se iniciaron en la rama A, pero que no están en la rama actual, y se recomienda eliminarlas <br>  <b>A</b> - B-migraciones que aparecieron en la nueva sucursal y necesitan ser rodadas <br><br>  Se vuelve increíblemente conveniente al probar y ensamblar automáticamente en una base.  Cuando no hay sentido u oportunidad para que cada rama cree una base desde cero.  Cambie a la rama y sincronice automáticamente el estado de la base de datos. <br><br><h2>  Numeración y orden de ejecución. </h2><br>  Todas las herramientas que conozco son migraciones estampadas cronometradas es una buena solución.  Si escribo varias migraciones, se conserva la secuencia necesaria.  Otro desarrollador puede tener cualquier fecha en otro hilo, incluso el mío, pero no importa en qué orden lo hagamos, nuestros cambios son independientes entre sí.  Incluso si trabajamos con la misma tabla (agregar por columna), todos los cambios necesarios tendrán lugar en cualquier orden.  Lo principal es que se respeta la secuencia de mis ediciones dependientes. <br><br><img src="https://habrastorage.org/webt/n9/4q/dg/n94qdgqakyab2tmjoa2bmhw5oga.png"><br><br>  No considero casos en los que necesitamos editar lo mismo: estos puntos siempre son consistentes.  Bueno, o habrá un fallo en la etapa de montaje y prueba. <br><br>  Aquí hay un ejemplo interesante. <br><br>  Realizamos diferentes ediciones en una vista o procedimiento, es decir  en aquellas estructuras que se actualizan mediante eliminación.  Es decir  Por ejemplo, agregué la columna col_A a la vista y mi colega col_B.  En consecuencia, si su código se implementa después del mío, entonces su columna no tendrá mi columna: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> login, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- ....</span></span></code> </pre><table><tbody><tr><th>  rama-A </th><th>  rama-B </th></tr><tr><td><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> login, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, col_A, <span class="hljs-comment"><span class="hljs-comment">-- ....</span></span></code> </pre></td><td><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> login, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, col_B, <span class="hljs-comment"><span class="hljs-comment">-- ....</span></span></code> </pre></td></tr></tbody></table>  En este caso, una rama debe hacerse dependiente de otra. <br><br>  Otro caso interesante son las correcciones en las migraciones. <br><br>  La conclusión es que la migración que se aplicó ya no se volverá a aplicar, sin importar cuántos cambios se realicen (primero debe retroceder y luego volver a aplicarla).  Es decir  Enviaste Migration para probar, todas las reglas, y luego te diste cuenta e hiciste una pequeña edición.  Pero la prueba u otro servidor donde lo usó no lo sabrán. <br><br>  En estos casos, cambiamos el nombre del archivo de migración, agregando un nuevo número de versión, para que el migrador comience a interpretar esto como 2 comandos: retroceder 1 y retroceder 2, <br>  por ejemplo: <br><br><img src="https://habrastorage.org/webt/x4/kn/7f/x4kn7fbvvoi0uhm-3yktgq3pkz0.png"><br><br><h2>  Rollback </h2><br>  Siempre escriba ROLLBACK, incluso si no puede devolver la base a su estado original.  Por ejemplo, DROP TABLE, ¿qué tipo de ROLLBACK puede ser? <br><br>  En tales casos, escribimos una CREAR TABLA vacía.  La conclusión es que el sistema de desarrollo siempre puede cambiar fácilmente entre ramas.  Para PROD, la gestión de revisión irreversible ya está decidida a un nivel diferente.  Puedo hacer una copia de la tabla o cambiarle el nombre en lugar de eliminarla.  Pero el principio de la migración de escritura: la reversión está OBLIGADA a devolver la ESTRUCTURA de la base al nivel inicial, y los datos ya son posibles. <br><br>  En un ambiente de combate, usé una reversión solo 1-2 veces en mi vida.  Y en desarrollo todo el tiempo.  Por lo tanto, siempre verifico que la reversión devuelva todo al estado deseado. <br><br>  A menudo, los desarrolladores pueden cometer errores en la reversión.  Porque  se concentran principalmente en nuevas ediciones, se prueban y trabajan con ellas.  Otras personas y procesos ya están trabajando con la reversión.  Por lo tanto, siempre pruebo las migraciones UP - ROLLBACK - UP <br><br>  Aparece un punto interesante en una base de prueba permanente (la base de datos no se elimina).  Escribieron una migración, la reversión funciona bien, la enviaron para probar, el probador generó datos en un nuevo formato, intenta revertir, pero no dan datos nuevos.  Ejemplo clásico <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre> <br>  Genial  Después de la prueba, la base de datos está llena de valores NULL.  Hacer ROLLBACK: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre> <br>  y viceversa :-( <br><br>  Necesita agregar el comando: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre> <br>  La dificultad es que debe tener esto en cuenta y no automatizarlo si no estamos hablando de volver a crear la base de datos desde cero cada vez. <br><br><h5>  Un poco sobre la eliminación de datos </h5><br>  Por lo general, tratamos de NO eliminar tablas y columnas rellenas a la vez.  Es mejor cambiar el nombre o hacer una copia y eliminarla más tarde, cuando todo se estabilice y los datos pierdan relevancia: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> user_logs <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> user_logs_20190223; <span class="hljs-comment"><span class="hljs-comment">--  CREATE TABLE user_logs_20190223 AS TABLE user_logs;</span></span></code> </pre><br><h2>  Migrador </h2><br>  Ahora estamos trabajando con Laravel: tiene un motor de gestión de migración estándar y familiar.  Si lo desea, escriba incluso en SQL puro, aunque todavía está en la clase PHP.  Pero mis repetidos intentos de hacerlo funcionar de la manera que necesitábamos resultaron en un repositorio separado: <br><br><ul><li>  La solución consta de 2 partes: lib e implementación para una consola específica (Laravel, Symfony).  Puede integrarse en cualquier consola, o al menos en el bozal web. </li><li>  No hay configuración ni conexión: por qué, cuando ya está en su proyecto.  Aferra tu conexión a la interfaz y listo. </li><li>  La reversión de SQL se almacena en la base de datos.  Esto es necesario para cambiar entre ramas. </li><li>  Probado en Postgesql, Mysql (sin transacciones).  Es adecuado en principio para cualquier base y estructura, porque se utiliza el formato sin formato. </li></ul><br><br>  Referencias <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">migrations-lib</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementación bajo Laravel / Artisan</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementación bajo Symfony / Console</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435438/">https://habr.com/ru/post/es435438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435426/index.html">Cómo funciona Microsoft Excel con alturas de fila</a></li>
<li><a href="../es435428/index.html">Control remoto del emulador Fceux usando Python</a></li>
<li><a href="../es435430/index.html">Las mejores noticias CES 2019</a></li>
<li><a href="../es435432/index.html">Año nuevo, GitHub nuevo: repositorios privados gratuitos ilimitados</a></li>
<li><a href="../es435436/index.html">5 tendencias en infraestructura de TI: pronóstico para 2019</a></li>
<li><a href="../es435442/index.html">Embudo de cambio</a></li>
<li><a href="../es435444/index.html">Estamos implementando OSGI en la plataforma Karaf</a></li>
<li><a href="../es435446/index.html">Algoritmo de Verhuff para un sistema arbitrario de números pares</a></li>
<li><a href="../es435448/index.html">Sobre la experiencia de comunicarse con un generador de señal a través de QTcpSocket y SCPI</a></li>
<li><a href="../es435450/index.html">Feliz año nuevo, feliz nuevo MQTT / UDP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>